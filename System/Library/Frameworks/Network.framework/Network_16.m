void sub_1839EAF1C(_Unwind_Exception *a1)
{
  void *v1;
  void *v2;
  void *v3;

  _Unwind_Resume(a1);
}

BOOL nw_protocol_http_retry_create(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  v6 = (char *)malloc_type_calloc(1uLL, 0x2A8uLL, 0xEAFB8F1AuLL);
  if (!v6)
  {
    v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    v28 = "strict_calloc";
    __int16 v29 = 2048;
    uint64_t v30 = 1;
    __int16 v31 = 2048;
    uint64_t v32 = 680;
    v25 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v25);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v25);
  }
  bzero(v6, 0x2A8uLL);
  if (gLogDatapath)
  {
    v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      v28 = "nw_protocol_http_retry_create";
      __int16 v29 = 2082;
      uint64_t v30 = (uint64_t)(v6 + 114);
      __int16 v31 = 2080;
      uint64_t v32 = (uint64_t)" ";
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
    }
  }
  if (nw_protocol_http_retry_identifier::onceToken[0] != -1) {
    dispatch_once(nw_protocol_http_retry_identifier::onceToken, &__block_literal_global_42074);
  }
  *((void *)v6 + 2) = &nw_protocol_http_retry_identifier::protocol_identifier;
  if (nw_protocol_http_retry_get_callbacks(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_http_retry_get_callbacks(void)::onceToken, &__block_literal_global_30_42075);
  }
  *((void *)v6 + 3) = &nw_protocol_http_retry_get_callbacks(void)::protocol_callbacks;
  *((void *)v6 + 5) = v6;
  if (a3) {
    a3 = os_retain(a3);
  }
  char v7 = v6[632];
  if (v7)
  {
    v8 = (void *)*((void *)v6 + 78);
    if (v8)
    {
      os_release(v8);
      char v7 = v6[632];
    }
  }
  *((void *)v6 + 78) = a3;
  v6[632] = v7 | 1;
  if (!a4)
  {
    v9 = 0;
    char v10 = v6[648];
    if ((v10 & 1) == 0) {
      goto LABEL_18;
    }
LABEL_16:
    v11 = (void *)*((void *)v6 + 80);
    if (v11)
    {
      os_release(v11);
      char v10 = v6[648];
    }
    goto LABEL_18;
  }
  v9 = os_retain(a4);
  char v10 = v6[648];
  if (v10) {
    goto LABEL_16;
  }
LABEL_18:
  *((void *)v6 + 80) = v9;
  v6[648] = v10 | 1;
  id v12 = nw_parameters_copy_context(a4);
  char v13 = v6[664];
  if (v13)
  {
    v14 = (void *)*((void *)v6 + 82);
    if (v14)
    {
      os_release(v14);
      char v13 = v6[664];
    }
  }
  *((void *)v6 + 82) = v12;
  v6[664] = v13 | 1;
  v6[676] = v6[676] & 0xFE | nw_parameters_get_server_mode(a4);
  if (nw_protocol_copy_http_retry_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_retry_definition_onceToken, &__block_literal_global_42_74646);
  }
  id v15 = (id)nw_protocol_copy_http_retry_definition_http_retry_definition;
  v16 = nw_parameters_copy_protocol_options_for_definition(a4, v15);
  *((_DWORD *)v6 + 168) = nw_http_retry_options_get_limit(v16);
  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
  }
  id v17 = (id)nw_protocol_copy_http_client_definition_definition;
  v18 = nw_parameters_copy_protocol_options_for_definition(a4, v17);
  v19 = nw_http_client_options_copy_retry_with_h1_handler(v18);
  char v20 = v6[616];
  if (v20)
  {
    v21 = (const void *)*((void *)v6 + 76);
    if (v21)
    {
      _Block_release(v21);
      char v20 = v6[616];
    }
  }
  *((void *)v6 + 25) = 0;
  *((void *)v6 + 76) = v19;
  v6[616] = v20 | 1;
  *((void *)v6 + 9) = v6 + 200;
  *((void *)v6 + 26) = v6 + 200;
  *((void *)v6 + 27) = 0;
  *((void *)v6 + 28) = v6 + 216;
  *((void *)v6 + 29) = 0;
  *((void *)v6 + 30) = v6 + 232;
  v6[340] = 2;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  id v22 = (id)nw_protocol_copy_http_definition_http_definition;
  nw_protocol_plugin_metadata_set_callbacks((uint64_t)v6, v22, (uint64_t)nw_protocol_http_retry_create::$_0::__invoke, (uint64_t)nw_protocol_http_retry_create::$_1::__invoke);
  if (v22) {
    os_release(v22);
  }
  *((void *)v6 + 10) = v6 + 344;
  nw_protocol_plugin_reset_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_retry_create::$_2::__invoke);
  *((void *)v6 + 11) = v6 + 360;
  nw_protocol_plugin_retry_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_retry_create::$_3::__invoke, (uint64_t)nw_protocol_http_retry_create::$_4::__invoke, (uint64_t)nw_protocol_http_retry_create::$_5::__invoke, (uint64_t)nw_protocol_http_retry_create::$_6::__invoke);
  *((void *)v6 + 8) = v6 + 104;
  nw_protocol_plugin_name_set_callbacks((uint64_t)v6, (uint64_t)nw_protocol_http_retry_create::$_7::__invoke);
  if (v18) {
    os_release(v18);
  }
  if (v17) {
    os_release(v17);
  }
  if (v16) {
    os_release(v16);
  }
  if (v15) {
    os_release(v15);
  }
  return (BOOL)v6;
}

uint64_t nw_protocol_http_retry_create::$_7::__invoke(nw_protocol_http_retry_create::$_7 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_retry_create::$_6::__invoke(nw_protocol_http_retry_create::$_6 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_retry_create::$_5::__invoke(nw_protocol_http_retry_create::$_5 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (this)
  {
    uint64_t v3 = *((void *)this + 5);
    if (v3)
    {
      *(unsigned char *)(v3 + 676) |= 4u;
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v16 = "operator()";
    v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_retry";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v13)
    {
      v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_retry, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v12 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null http_retry, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "operator()";
      __int16 v17 = 2082;
      v18 = backtrace_string;
      v11 = "%{public}s called with null http_retry, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "operator()";
  v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v13)
    {
      v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "operator()";
        v8 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      v16 = "operator()";
      __int16 v17 = 2082;
      v18 = backtrace_string;
      v11 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v6, v7, v11, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  if (os_log_type_enabled(v6, type))
  {
    *(_DWORD *)buf = 136446210;
    v16 = "operator()";
    v8 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
  }
LABEL_32:
  if (v5) {
    free(v5);
  }
  return 0;
}

uint64_t nw_protocol_http_retry_create::$_4::__invoke(nw_protocol_http_retry_create::$_4 *this, nw_protocol *a2, nw_protocol *a3)
{
  return 1;
}

uint64_t nw_protocol_http_retry_create::$_3::__invoke(nw_protocol_http_retry_create::$_3 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    v37 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v77[0] = 0;
    if (!__nwlog_fault(v37, type, v77)) {
      goto LABEL_98;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v77[0])
      {
        v38 = __nwlog_obj();
        os_log_type_t v39 = type[0];
        if (!os_log_type_enabled(v38, type[0])) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        v40 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_97;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v38 = __nwlog_obj();
      os_log_type_t v39 = type[0];
      BOOL v42 = os_log_type_enabled(v38, type[0]);
      if (!backtrace_string)
      {
        if (!v42) {
          goto LABEL_98;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "operator()";
        v40 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_97;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "operator()";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v43 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_87:
        _os_log_impl(&dword_1830D4000, v38, v39, v43, buf, 0x16u);
      }
LABEL_88:
      free(backtrace_string);
      goto LABEL_98;
    }
    v38 = __nwlog_obj();
    os_log_type_t v39 = type[0];
    if (!os_log_type_enabled(v38, type[0])) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    v40 = "%{public}s called with null protocol";
LABEL_97:
    _os_log_impl(&dword_1830D4000, v38, v39, v40, buf, 0xCu);
LABEL_98:
    if (v37) {
      free(v37);
    }
    return 0;
  }
  uint64_t v3 = *((void *)this + 5);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    v37 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    v77[0] = 0;
    if (!__nwlog_fault(v37, type, v77)) {
      goto LABEL_98;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v38 = __nwlog_obj();
      os_log_type_t v39 = type[0];
      if (!os_log_type_enabled(v38, type[0])) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      v40 = "%{public}s called with null http_retry";
      goto LABEL_97;
    }
    if (!v77[0])
    {
      v38 = __nwlog_obj();
      os_log_type_t v39 = type[0];
      if (!os_log_type_enabled(v38, type[0])) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "operator()";
      v40 = "%{public}s called with null http_retry, backtrace limit exceeded";
      goto LABEL_97;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v38 = __nwlog_obj();
    os_log_type_t v39 = type[0];
    BOOL v44 = os_log_type_enabled(v38, type[0]);
    if (backtrace_string)
    {
      if (v44)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "operator()";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v43 = "%{public}s called with null http_retry, dumping backtrace:%{public}s";
        goto LABEL_87;
      }
      goto LABEL_88;
    }
    if (!v44) {
      goto LABEL_98;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "operator()";
    v40 = "%{public}s called with null http_retry, no backtrace";
    goto LABEL_97;
  }
  if ((*(unsigned char *)(v3 + 676) & 8) == 0)
  {
    if ((*(unsigned char *)(v3 + 676) & 5) == 0 && *(_DWORD *)(v3 + 672))
    {
      uint64_t result = *(void *)(v3 + 576);
      if (!result) {
        return result;
      }
      uint64_t v5 = *(void *)(v3 + 592);
      uint64_t result = (uint64_t)nw_http_metadata_copy_request((void *)result);
      if (v5 || !result)
      {
        if (!result) {
          return result;
        }
      }
      else
      {
        id v6 = (id)result;
        char has_method = _nw_http_request_has_method((uint64_t)v6);

        if ((has_method & 1) != 0
          || (id v8 = v6, v9 = _nw_http_request_has_method((uint64_t)v8), v8, v9))
        {
          if ((*(unsigned char *)(v3 + 198) & 1) == 0)
          {
            if (gLogDatapath)
            {
              v21 = __nwlog_obj();
              if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_http_retry_can_retry";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v3 + 114;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v83 = (uint64_t)" ";
                id v22 = "%{public}s %{public}s%sidempotent request has not received any response, able to retry";
                goto LABEL_106;
              }
            }
          }
LABEL_14:
          os_release(v6);
          BOOL v10 = *(void **)(v3 + 576);
          if (v10)
          {
            if ((*(unsigned char *)(v3 + 198) & 1) == 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              v11 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
              {
                int v12 = *(_DWORD *)(v3 + 672);
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v3 + 114;
                *(_WORD *)&buf[22] = 2080;
                uint64_t v83 = (uint64_t)" ";
                *(_WORD *)v84 = 1024;
                *(_DWORD *)&v84[2] = v12;
                _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%sretrying, remaining limit %u", buf, 0x26u);
              }
            }
            int v13 = *(_DWORD *)(v3 + 672);
            *(_DWORD *)(v3 + 672) = v13 - 1;
            if (v13)
            {
LABEL_49:
              *(unsigned char *)(v3 + 676) |= 8u;
              *(void *)buf = 0;
              *(void *)&buf[8] = buf;
              *(void *)&buf[16] = 0x3802000000;
              uint64_t v83 = (uint64_t)__Block_byref_object_copy__42118;
              *(void *)v84 = __Block_byref_object_dispose__42119;
              parameters = (void *)nw_protocol_get_parameters(v3);
              if (parameters) {
                parameters = os_retain(parameters);
              }
              *(void *)&v84[8] = parameters;
              v84[16] |= 1u;
              if (*(_DWORD *)(v3 + 536) == 43)
              {
                uint64_t v29 = *(void *)(v3 + 608);
                if (!v29
                  || (*(void *)os_log_type_t type = MEMORY[0x1E4F143A8],
                      uint64_t v71 = 0x40000000,
                      uint64_t v72 = (uint64_t)___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke,
                      v73 = (uint64_t (*)(uint64_t, uint64_t))&__block_descriptor_tmp_15_42120,
                      v74 = (void (*)(uint64_t))v3,
                      ((*(uint64_t (**)(uint64_t, void, os_log_type_t *))(v29 + 16))(v29, *(void *)(*(void *)&buf[8] + 40), type) & 1) == 0))
                {
                  nw_protocol_error(*(void **)(v3 + 48), v3);
                  nw_protocol_disconnected(*(void **)(v3 + 48), v3);
                }
LABEL_65:
                *(unsigned char *)(v3 + 676) &= ~8u;
LABEL_66:
                _Block_object_dispose(buf, 8);
                if (v84[16])
                {
                  if (*(void *)&v84[8]) {
                    os_release(*(void **)&v84[8]);
                  }
                }
                return 1;
              }
              nw_http_messaging_options_create_transaction_in_parameters(*(void **)(*(void *)&buf[8] + 40), v3, 3);
              nw_protocol_plugin_metadata_prepare_for_reissue(v3 + 200);
              *(void *)os_log_type_t type = 0;
              uint64_t v71 = (uint64_t)type;
              uint64_t v72 = 0x3802000000;
              v73 = __Block_byref_object_copy__16_42121;
              v74 = __Block_byref_object_dispose__17_42122;
              id v30 = nw_http_metadata_copy_request(v10);
              if (v30)
              {
                id v31 = v30;
                uint64_t v32 = (void *)_nw_http_fields_copy((uint64_t)v31);

                metadata_for_request = nw_http_create_metadata_for_request(v32);
                if (v32) {
                  os_release(v32);
                }
                os_release(v31);
                goto LABEL_59;
              }
              __nwlog_obj();
              *(_DWORD *)v77 = 136446210;
              *(void *)&v77[4] = "nw_http_retry_copy_metadata";
              v49 = (char *)_os_log_send_and_compose_impl();
              v64[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v63[0]) = 0;
              if (__nwlog_fault(v49, v64, v63))
              {
                if (v64[0] == OS_LOG_TYPE_FAULT)
                {
                  v50 = __nwlog_obj();
                  os_log_type_t v51 = v64[0];
                  if (os_log_type_enabled(v50, v64[0]))
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                    v52 = "%{public}s called with null orig_request";
LABEL_143:
                    _os_log_impl(&dword_1830D4000, v50, v51, v52, v77, 0xCu);
                  }
                }
                else if (LOBYTE(v63[0]))
                {
                  v59 = (char *)__nw_create_backtrace_string();
                  v50 = __nwlog_obj();
                  os_log_type_t v51 = v64[0];
                  BOOL v60 = os_log_type_enabled(v50, v64[0]);
                  if (v59)
                  {
                    if (v60)
                    {
                      *(_DWORD *)v77 = 136446466;
                      *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                      *(_WORD *)&v77[12] = 2082;
                      *(void *)&v77[14] = v59;
                      _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s called with null orig_request, dumping backtrace:%{public}s", v77, 0x16u);
                    }
                    free(v59);
                    goto LABEL_144;
                  }
                  if (v60)
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                    v52 = "%{public}s called with null orig_request, no backtrace";
                    goto LABEL_143;
                  }
                }
                else
                {
                  v50 = __nwlog_obj();
                  os_log_type_t v51 = v64[0];
                  if (os_log_type_enabled(v50, v64[0]))
                  {
                    *(_DWORD *)v77 = 136446210;
                    *(void *)&v77[4] = "nw_http_retry_copy_metadata";
                    v52 = "%{public}s called with null orig_request, backtrace limit exceeded";
                    goto LABEL_143;
                  }
                }
              }
LABEL_144:
              if (v49) {
                free(v49);
              }
              metadata_for_request = 0;
LABEL_59:
              object = metadata_for_request;
              v76 |= 1u;
              uint64_t v34 = *(void *)(v71 + 40);
              if (v34)
              {
                v35 = *(void **)(v3 + 656);
                v36 = *(void **)(v3 + 624);
                *(void *)v64 = MEMORY[0x1E4F143A8];
                uint64_t v65 = 0x40000000;
                v66 = ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_18;
                v67 = &unk_1E5241AB0;
                v68 = type;
                uint64_t v69 = v3;
                *(void *)v77 = MEMORY[0x1E4F143A8];
                *(void *)&v77[8] = 0x40000000;
                *(void *)&v77[16] = ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_3;
                v78 = &unk_1E5241B00;
                v80 = type;
                uint64_t v81 = v3;
                v79 = buf;
                v63[0] = MEMORY[0x1E4F143A8];
                v63[1] = 0x40000000;
                v63[2] = ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_5;
                v63[3] = &__block_descriptor_tmp_27_42135;
                v63[4] = v3;
                nw_protocol_plugin_retry_reissue_output_frames(v3 + 360, v3, v35, v36, 0, 2, 1, v64, v77, (uint64_t)v63);
                goto LABEL_61;
              }
              __nwlog_obj();
              *(_DWORD *)v77 = 136446210;
              *(void *)&v77[4] = "nw_http_retry_reissue";
              v53 = (char *)_os_log_send_and_compose_impl();
              v64[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v63[0]) = 0;
              if (__nwlog_fault(v53, v64, v63))
              {
                if (v64[0] == OS_LOG_TYPE_FAULT)
                {
                  v54 = __nwlog_obj();
                  os_log_type_t v55 = v64[0];
                  if (!os_log_type_enabled(v54, v64[0])) {
                    goto LABEL_150;
                  }
                  *(_DWORD *)v77 = 136446210;
                  *(void *)&v77[4] = "nw_http_retry_reissue";
                  v56 = "%{public}s called with null request_metadata";
                  goto LABEL_149;
                }
                if (!LOBYTE(v63[0]))
                {
                  v54 = __nwlog_obj();
                  os_log_type_t v55 = v64[0];
                  if (!os_log_type_enabled(v54, v64[0])) {
                    goto LABEL_150;
                  }
                  *(_DWORD *)v77 = 136446210;
                  *(void *)&v77[4] = "nw_http_retry_reissue";
                  v56 = "%{public}s called with null request_metadata, backtrace limit exceeded";
                  goto LABEL_149;
                }
                v61 = (char *)__nw_create_backtrace_string();
                v54 = __nwlog_obj();
                os_log_type_t v55 = v64[0];
                BOOL v62 = os_log_type_enabled(v54, v64[0]);
                if (v61)
                {
                  if (v62)
                  {
                    *(_DWORD *)v77 = 136446466;
                    *(void *)&v77[4] = "nw_http_retry_reissue";
                    *(_WORD *)&v77[12] = 2082;
                    *(void *)&v77[14] = v61;
                    _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s called with null request_metadata, dumping backtrace:%{public}s", v77, 0x16u);
                  }
                  free(v61);
                  goto LABEL_150;
                }
                if (v62)
                {
                  *(_DWORD *)v77 = 136446210;
                  *(void *)&v77[4] = "nw_http_retry_reissue";
                  v56 = "%{public}s called with null request_metadata, no backtrace";
LABEL_149:
                  _os_log_impl(&dword_1830D4000, v54, v55, v56, v77, 0xCu);
                }
              }
LABEL_150:
              if (v53) {
                free(v53);
              }
LABEL_61:
              _Block_object_dispose(type, 8);
              if ((v76 & 1) != 0 && object) {
                os_release(object);
              }
              if (!v34) {
                goto LABEL_66;
              }
              goto LABEL_65;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v14 = *(unsigned int *)(v3 + 672);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "http_retry->limit";
            *(_WORD *)&buf[22] = 2048;
            uint64_t v83 = 1;
            *(_WORD *)v84 = 2048;
            *(void *)&v84[2] = v14;
            id v15 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            v77[0] = 0;
            if (__nwlog_fault(v15, type, v77))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v16 = gLogObj;
                os_log_type_t v17 = type[0];
                if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
                {
                  uint64_t v18 = *(unsigned int *)(v3 + 672);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http_retry->limit";
                  *(_WORD *)&buf[22] = 2048;
                  uint64_t v83 = 1;
                  *(_WORD *)v84 = 2048;
                  *(void *)&v84[2] = v18;
                  uint64_t v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_45:
                  _os_log_impl(&dword_1830D4000, v16, v17, v19, buf, 0x2Au);
                }
              }
              else if (v77[0])
              {
                v23 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v16 = gLogObj;
                os_log_type_t v17 = type[0];
                BOOL v24 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
                if (v23)
                {
                  if (v24)
                  {
                    uint64_t v25 = *(unsigned int *)(v3 + 672);
                    *(_DWORD *)buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = "http_retry->limit";
                    *(_WORD *)&buf[22] = 2048;
                    uint64_t v83 = 1;
                    *(_WORD *)v84 = 2048;
                    *(void *)&v84[2] = v25;
                    *(_WORD *)&v84[10] = 2082;
                    *(void *)&v84[12] = v23;
                    _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }
                  free(v23);
                  goto LABEL_46;
                }
                if (v24)
                {
                  uint64_t v27 = *(unsigned int *)(v3 + 672);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http_retry->limit";
                  *(_WORD *)&buf[22] = 2048;
                  uint64_t v83 = 1;
                  *(_WORD *)v84 = 2048;
                  *(void *)&v84[2] = v27;
                  uint64_t v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                  goto LABEL_45;
                }
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v16 = gLogObj;
                os_log_type_t v17 = type[0];
                if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
                {
                  uint64_t v26 = *(unsigned int *)(v3 + 672);
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = "http_retry->limit";
                  *(_WORD *)&buf[22] = 2048;
                  uint64_t v83 = 1;
                  *(_WORD *)v84 = 2048;
                  *(void *)&v84[2] = v26;
                  uint64_t v19 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                  goto LABEL_45;
                }
              }
            }
LABEL_46:
            if (v15) {
              free(v15);
            }
            *(_DWORD *)(v3 + 672) = 0;
            goto LABEL_49;
          }
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
          v45 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          v77[0] = 0;
          if (__nwlog_fault(v45, type, v77))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              v46 = __nwlog_obj();
              os_log_type_t v47 = type[0];
              if (!os_log_type_enabled(v46, type[0])) {
                goto LABEL_135;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
              v48 = "%{public}s called with null _request_metadata";
              goto LABEL_134;
            }
            if (!v77[0])
            {
              v46 = __nwlog_obj();
              os_log_type_t v47 = type[0];
              if (!os_log_type_enabled(v46, type[0])) {
                goto LABEL_135;
              }
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
              v48 = "%{public}s called with null _request_metadata, backtrace limit exceeded";
              goto LABEL_134;
            }
            v57 = (char *)__nw_create_backtrace_string();
            v46 = __nwlog_obj();
            os_log_type_t v47 = type[0];
            BOOL v58 = os_log_type_enabled(v46, type[0]);
            if (v57)
            {
              if (v58)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = v57;
                _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null _request_metadata, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v57);
              goto LABEL_135;
            }
            if (v58)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_http_retry_reissue";
              v48 = "%{public}s called with null _request_metadata, no backtrace";
LABEL_134:
              _os_log_impl(&dword_1830D4000, v46, v47, v48, buf, 0xCu);
            }
          }
LABEL_135:
          if (v45) {
            free(v45);
          }
          return 1;
        }
        int v20 = *(_DWORD *)(v3 + 536);
        if (v20 == 35)
        {
          if (*(unsigned char *)(v3 + 198)) {
            goto LABEL_14;
          }
          if (!gLogDatapath) {
            goto LABEL_14;
          }
          v21 = __nwlog_obj();
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_14;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_retry_can_retry";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v3 + 114;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v83 = (uint64_t)" ";
          id v22 = "%{public}s %{public}s%srequest received no response and EAGAIN, able to retry";
LABEL_106:
          _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, v22, buf, 0x20u);
          goto LABEL_14;
        }
        if (v20 == 43)
        {
          if (*(unsigned char *)(v3 + 198)) {
            goto LABEL_14;
          }
          if (!gLogDatapath) {
            goto LABEL_14;
          }
          v21 = __nwlog_obj();
          if (!os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_14;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_http_retry_can_retry";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v3 + 114;
          *(_WORD *)&buf[22] = 2080;
          uint64_t v83 = (uint64_t)" ";
          id v22 = "%{public}s %{public}s%srequest received no response, should retry using HTTP/1.1";
          goto LABEL_106;
        }
        uint64_t result = (uint64_t)v8;
      }
      os_release((void *)result);
      return 0;
    }
    return 0;
  }
  return 1;
}

uint64_t __Block_byref_object_copy__42118(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(result + 48) = *(unsigned char *)(result + 48) & 0xFE | *(unsigned char *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0;
  *(unsigned char *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__42119(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }
  *(void *)(a1 + 40) = 0;
}

uint64_t ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 572) |= 0x10u;
  return result;
}

uint64_t __Block_byref_object_copy__16_42121(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(result + 48) = *(unsigned char *)(result + 48) & 0xFE | *(unsigned char *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0;
  *(unsigned char *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__17_42122(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    v2 = *(void **)(a1 + 40);
    if (v2) {
      os_release(v2);
    }
  }
  *(void *)(a1 + 40) = 0;
}

uint64_t ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_18(uint64_t a1, uint64_t *a2)
{
  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 0x40000000;
  os_log_type_t v7 = ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_2;
  id v8 = &unk_1E5241A88;
  long long v9 = *(_OWORD *)(a1 + 32);
  uint64_t v2 = *a2;
  do
  {
    if (!v2) {
      break;
    }
    uint64_t v3 = *(void *)(v2 + 32);
    char v4 = ((uint64_t (*)(void *))v7)(v6);
    uint64_t v2 = v3;
  }
  while ((v4 & 1) != 0);
  return 1;
}

uint64_t ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_3(void *a1)
{
  if (nw_protocol_copy_http_client_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_client_definition_onceToken, &__block_literal_global_72_75798);
  }
  id v2 = (id)nw_protocol_copy_http_client_definition_definition;
  identifier = nw_protocol_definition_get_identifier(v2);
  if (v2) {
    os_release(v2);
  }
  uint64_t v4 = a1[6];
  do
  {
    uint64_t v4 = *(void *)(v4 + 48);
    if (!v4) {
      return 1;
    }
  }
  while (!nw_protocols_are_equal(*(void **)(v4 + 16), identifier));
  uint64_t v5 = nw_parameters_copy_protocol_options_legacy(*(void **)(*(void *)(a1[4] + 8) + 40), (nw_protocol *)v4);
  id v6 = nw_http_client_options_copy_resend_handler(v5);
  BOOL v7 = v6 == 0;
  if (v6)
  {
    id v8 = v6;
    uint64_t v9 = *(void *)(a1[4] + 8);
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 0x40000000;
    v11[2] = ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_4;
    v11[3] = &unk_1E5241AD8;
    v11[4] = a1[5];
    (*((void (**)(void *, void, void *))v6 + 2))(v6, *(void *)(v9 + 40), v11);
    _Block_release(v8);
  }
  if (v5) {
    os_release(v5);
  }
  return v7;
}

void ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_5(uint64_t a1)
{
}

void nw_http_retry_destroy(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if ((*(unsigned char *)(a1 + 198) & 1) == 0)
  {
    if (gLogDatapath)
    {
      int v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 136446722;
        uint64_t v14 = "nw_http_retry_destroy";
        __int16 v15 = 2082;
        uint64_t v16 = a1 + 114;
        __int16 v17 = 2080;
        uint64_t v18 = " ";
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", (uint8_t *)&v13, 0x20u);
      }
    }
  }
  if (*(_DWORD *)(a1 + 568))
  {
    *(unsigned char *)(a1 + 572) |= 0x40u;
    if ((*(unsigned char *)(a1 + 198) & 1) == 0 && gLogDatapath)
    {
      id v2 = __nwlog_obj();
      if (os_log_type_enabled(v2, OS_LOG_TYPE_DEBUG))
      {
        int v13 = 136446722;
        uint64_t v14 = "nw_http_retry_destroy";
        __int16 v15 = 2082;
        uint64_t v16 = a1 + 114;
        __int16 v17 = 2080;
        uint64_t v18 = " ";
        _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sdeferring destroy because the request is being reissued", (uint8_t *)&v13, 0x20u);
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 664))
    {
      uint64_t v3 = *(void **)(a1 + 656);
      if (v3) {
        os_release(v3);
      }
    }
    *(void *)(a1 + 656) = 0;
    if (*(unsigned char *)(a1 + 648))
    {
      uint64_t v4 = *(void **)(a1 + 640);
      if (v4) {
        os_release(v4);
      }
    }
    *(void *)(a1 + 640) = 0;
    if (*(unsigned char *)(a1 + 632))
    {
      uint64_t v5 = *(void **)(a1 + 624);
      if (v5) {
        os_release(v5);
      }
    }
    *(void *)(a1 + 624) = 0;
    if (*(unsigned char *)(a1 + 616))
    {
      id v6 = *(const void **)(a1 + 608);
      if (v6) {
        _Block_release(v6);
      }
    }
    *(void *)(a1 + 608) = 0;
    if (*(unsigned char *)(a1 + 600))
    {
      BOOL v7 = *(void **)(a1 + 592);
      if (v7) {
        os_release(v7);
      }
    }
    *(void *)(a1 + 592) = 0;
    if (*(unsigned char *)(a1 + 584))
    {
      id v8 = *(void **)(a1 + 576);
      if (v8) {
        os_release(v8);
      }
    }
    *(void *)(a1 + 576) = 0;
    nw_protocol_plugin_retry::~nw_protocol_plugin_retry((nw_protocol_plugin_retry *)(a1 + 360));
    if (*(unsigned char *)(a1 + 288))
    {
      uint64_t v9 = *(void **)(a1 + 280);
      if (v9) {
        os_release(v9);
      }
    }
    *(void *)(a1 + 280) = 0;
    if (*(unsigned char *)(a1 + 272))
    {
      BOOL v10 = *(void **)(a1 + 264);
      if (v10) {
        os_release(v10);
      }
    }
    *(void *)(a1 + 264) = 0;
    if (*(unsigned char *)(a1 + 256))
    {
      v11 = *(void **)(a1 + 248);
      if (v11) {
        os_release(v11);
      }
    }
    free((void *)a1);
  }
}

void ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_4(uint64_t a1, nw_content_context_t context)
{
}

uint64_t ___ZL21nw_http_retry_reissueP22nw_protocol_http_retryP20nw_protocol_metadata_block_invoke_2(uint64_t a1, uint64_t a2)
{
  nw_frame_set_metadata(a2, *(NSObject **)(*(void *)(*(void *)(a1 + 32) + 8) + 40), 0, (*(unsigned char *)(*(void *)(a1 + 40) + 676) & 2) == 0);
  return 1;
}

void nw_protocol_http_retry_create::$_2::__invoke(nw_protocol_http_retry_create::$_2 *this, nw_protocol *a2, nw_protocol *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!this)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v20 = "operator()";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v9, &type, &v17)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v20 = "operator()";
      int v12 = "%{public}s called with null protocol";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          int v20 = "operator()";
          __int16 v21 = 2082;
          id v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v9) {
          return;
        }
        goto LABEL_42;
      }
      if (!v14) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v20 = "operator()";
      int v12 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      int v20 = "operator()";
      int v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
    goto LABEL_41;
  }
  uint64_t v3 = *((void *)this + 5);
  if (v3)
  {
    char v4 = *(unsigned char *)(v3 + 584);
    if (v4)
    {
      uint64_t v5 = *(void **)(v3 + 576);
      if (v5)
      {
        os_release(v5);
        char v4 = *(unsigned char *)(v3 + 584);
      }
    }
    *(void *)(v3 + 576) = 0;
    *(unsigned char *)(v3 + 584) = v4 | 1;
    char v6 = *(unsigned char *)(v3 + 600);
    if (v6)
    {
      BOOL v7 = *(void **)(v3 + 592);
      if (v7)
      {
        os_release(v7);
        char v6 = *(unsigned char *)(v3 + 600);
      }
    }
    *(void *)(v3 + 592) = 0;
    *(unsigned char *)(v3 + 600) = v6 | 1;
    id v8 = nw_parameters_copy_protocol_options_legacy(*(void **)(v3 + 640), (nw_protocol *)v3);
    *(_DWORD *)(v3 + 672) = nw_http_retry_options_get_limit(v8);
    *(unsigned char *)(v3 + 676) &= 0xF9u;
    if (v8)
    {
      os_release(v8);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v20 = "operator()";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (!__nwlog_fault(v9, &type, &v17)) {
    goto LABEL_41;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    int v20 = "operator()";
    int v12 = "%{public}s called with null http_retry";
    goto LABEL_40;
  }
  if (!v17)
  {
    BOOL v10 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (!os_log_type_enabled(v10, type)) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    int v20 = "operator()";
    int v12 = "%{public}s called with null http_retry, backtrace limit exceeded";
    goto LABEL_40;
  }
  __int16 v15 = (char *)__nw_create_backtrace_string();
  BOOL v10 = __nwlog_obj();
  os_log_type_t v11 = type;
  BOOL v16 = os_log_type_enabled(v10, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    int v20 = "operator()";
    int v12 = "%{public}s called with null http_retry, no backtrace";
    goto LABEL_40;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    int v20 = "operator()";
    __int16 v21 = 2082;
    id v22 = v15;
    _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null http_retry, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v15);
  if (v9) {
LABEL_42:
  }
    free(v9);
}

void nw_protocol_http_retry_create::$_1::__invoke(uint64_t a1, int a2, void *object, int a4, uint64_t a5)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v14, &type, &v25)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null protocol";
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          v28 = "operator()";
          __int16 v29 = 2082;
          id v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_67:
        if (!v14) {
          return;
        }
        goto LABEL_68;
      }
      if (!v19) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_66;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v14, &type, &v25)) {
      goto LABEL_67;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        __int16 v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446210;
        v28 = "operator()";
        char v17 = "%{public}s called with null http_retry, backtrace limit exceeded";
        goto LABEL_66;
      }
      int v20 = (char *)__nw_create_backtrace_string();
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v21 = os_log_type_enabled(v15, type);
      if (!v20)
      {
        if (!v21) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446210;
        v28 = "operator()";
        char v17 = "%{public}s called with null http_retry, no backtrace";
        goto LABEL_66;
      }
      if (!v21) {
        goto LABEL_48;
      }
      *(_DWORD *)buf = 136446466;
      v28 = "operator()";
      __int16 v29 = 2082;
      id v30 = v20;
      id v22 = "%{public}s called with null http_retry, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_67;
    }
    *(_DWORD *)buf = 136446210;
    v28 = "operator()";
    char v17 = "%{public}s called with null http_retry";
LABEL_66:
    _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
    goto LABEL_67;
  }
  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v14, &type, &v25)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null metadata";
      goto LABEL_66;
    }
    if (!v25)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_66;
    }
    int v20 = (char *)__nw_create_backtrace_string();
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v23 = os_log_type_enabled(v15, type);
    if (!v20)
    {
      if (!v23) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_66;
    }
    if (!v23) {
      goto LABEL_48;
    }
    *(_DWORD *)buf = 136446466;
    v28 = "operator()";
    __int16 v29 = 2082;
    id v30 = v20;
    id v22 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_47:
    _os_log_impl(&dword_1830D4000, v15, v16, v22, buf, 0x16u);
    goto LABEL_48;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v28 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v14, &type, &v25)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null completion";
      goto LABEL_66;
    }
    if (!v25)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_66;
    }
    int v20 = (char *)__nw_create_backtrace_string();
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v24 = os_log_type_enabled(v15, type);
    if (!v20)
    {
      if (!v24) {
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      v28 = "operator()";
      char v17 = "%{public}s called with null completion, no backtrace";
      goto LABEL_66;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      v28 = "operator()";
      __int16 v29 = 2082;
      id v30 = v20;
      id v22 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
LABEL_48:
    free(v20);
    if (!v14) {
      return;
    }
LABEL_68:
    free(v14);
    return;
  }
  uint64_t v9 = os_retain(object);
  char v10 = *(unsigned char *)(v5 + 584);
  if (v10)
  {
    os_log_type_t v11 = *(void **)(v5 + 576);
    if (v11)
    {
      os_release(v11);
      char v10 = *(unsigned char *)(v5 + 584);
    }
  }
  *(void *)(v5 + 576) = v9;
  *(unsigned char *)(v5 + 584) = v10 | 1;
  if (a4) {
    char v12 = 0;
  }
  else {
    char v12 = 2;
  }
  *(unsigned char *)(v5 + 676) = *(unsigned char *)(v5 + 676) & 0xFD | v12;
  int v13 = *(void (**)(uint64_t, uint64_t, void *))(a5 + 16);

  v13(a5, 1, object);
}

void nw_protocol_http_retry_create::$_0::__invoke(uint64_t a1, uint64_t a2, void *object, uint64_t a4, uint64_t a5)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null protocol";
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v23 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "operator()";
          __int16 v37 = 2082;
          v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_101:
        if (!v14) {
          return;
        }
        goto LABEL_102;
      }
      if (!v23) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_100;
  }
  uint64_t v5 = *(void *)(a1 + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33)) {
      goto LABEL_101;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v33)
      {
        __int16 v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v36 = "operator()";
        char v17 = "%{public}s called with null http_retry, backtrace limit exceeded";
        goto LABEL_100;
      }
      BOOL v24 = (char *)__nw_create_backtrace_string();
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v25 = os_log_type_enabled(v15, type);
      if (!v24)
      {
        if (!v25) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v36 = "operator()";
        char v17 = "%{public}s called with null http_retry, no backtrace";
        goto LABEL_100;
      }
      if (!v25) {
        goto LABEL_69;
      }
      *(_DWORD *)buf = 136446466;
      v36 = "operator()";
      __int16 v37 = 2082;
      v38 = v24;
      uint64_t v26 = "%{public}s called with null http_retry, dumping backtrace:%{public}s";
      goto LABEL_68;
    }
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_101;
    }
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    char v17 = "%{public}s called with null http_retry";
LABEL_100:
    _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
    goto LABEL_101;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33)) {
      goto LABEL_101;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v33)
      {
        __int16 v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v36 = "operator()";
        char v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_100;
      }
      BOOL v24 = (char *)__nw_create_backtrace_string();
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v27 = os_log_type_enabled(v15, type);
      if (!v24)
      {
        if (!v27) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        v36 = "operator()";
        char v17 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_100;
      }
      if (!v27) {
        goto LABEL_69;
      }
      *(_DWORD *)buf = 136446466;
      v36 = "operator()";
      __int16 v37 = 2082;
      v38 = v24;
      uint64_t v26 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_68;
    }
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_101;
    }
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    char v17 = "%{public}s called with null other_protocol";
    goto LABEL_100;
  }
  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null metadata";
      goto LABEL_100;
    }
    if (!v33)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null metadata, backtrace limit exceeded";
      goto LABEL_100;
    }
    BOOL v24 = (char *)__nw_create_backtrace_string();
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v28 = os_log_type_enabled(v15, type);
    if (!v24)
    {
      if (!v28) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null metadata, no backtrace";
      goto LABEL_100;
    }
    if (!v28) {
      goto LABEL_69;
    }
    *(_DWORD *)buf = 136446466;
    v36 = "operator()";
    __int16 v37 = 2082;
    v38 = v24;
    uint64_t v26 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_68:
    _os_log_impl(&dword_1830D4000, v15, v16, v26, buf, 0x16u);
    goto LABEL_69;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "operator()";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v14, &type, &v33)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null completion";
      goto LABEL_100;
    }
    if (!v33)
    {
      __int16 v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null completion, backtrace limit exceeded";
      goto LABEL_100;
    }
    BOOL v24 = (char *)__nw_create_backtrace_string();
    __int16 v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v29 = os_log_type_enabled(v15, type);
    if (!v24)
    {
      if (!v29) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "operator()";
      char v17 = "%{public}s called with null completion, no backtrace";
      goto LABEL_100;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      v36 = "operator()";
      __int16 v37 = 2082;
      v38 = v24;
      uint64_t v26 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_68;
    }
LABEL_69:
    free(v24);
    if (!v14) {
      return;
    }
LABEL_102:
    free(v14);
    return;
  }
  if (!*(void *)(v5 + 576))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v36 = "nw_http_retry_process";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v18, &type, &v33)) {
      goto LABEL_106;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_106;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "nw_http_retry_process";
      BOOL v21 = "%{public}s called with null http_retry->request_metadata";
    }
    else if (v33)
    {
      id v30 = (char *)__nw_create_backtrace_string();
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v31 = os_log_type_enabled(v19, type);
      if (v30)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          v36 = "nw_http_retry_process";
          __int16 v37 = 2082;
          v38 = v30;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null http_retry->request_metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v30);
        goto LABEL_106;
      }
      if (!v31)
      {
LABEL_106:
        if (v18) {
          free(v18);
        }
        goto LABEL_14;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "nw_http_retry_process";
      BOOL v21 = "%{public}s called with null http_retry->request_metadata, no backtrace";
    }
    else
    {
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_106;
      }
      *(_DWORD *)buf = 136446210;
      v36 = "nw_http_retry_process";
      BOOL v21 = "%{public}s called with null http_retry->request_metadata, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
    goto LABEL_106;
  }
  id v8 = os_retain(object);
  char v9 = *(unsigned char *)(v5 + 600);
  if (v9)
  {
    char v10 = *(void **)(v5 + 592);
    if (v10)
    {
      os_release(v10);
      char v9 = *(unsigned char *)(v5 + 600);
    }
  }
  *(void *)(v5 + 592) = v8;
  *(unsigned char *)(v5 + 600) = v9 | 1;
  if ((*(unsigned char *)(v5 + 676) & 8) == 0)
  {
    if ((*(unsigned char *)(v5 + 676) & 5) == 0)
    {
      if (*(_DWORD *)(v5 + 672))
      {
        char v12 = *(void **)(v5 + 576);
        if (v12)
        {
          id v13 = nw_http_metadata_copy_request(v12);
          if (v13) {
            os_release(v13);
          }
        }
      }
    }
    if ((*(unsigned char *)(v5 + 198) & 1) == 0 && gLogDatapath)
    {
      uint64_t v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v36 = "nw_http_retry_process";
        __int16 v37 = 2082;
        v38 = (char *)(v5 + 114);
        __int16 v39 = 2080;
        v40 = " ";
        _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sCannot retry request on stream", buf, 0x20u);
      }
    }
LABEL_14:
    (*(void (**)(uint64_t, uint64_t, void *))(a5 + 16))(a5, 1, object);
    return;
  }
  os_log_type_t v11 = *(void (**)(uint64_t, uint64_t, void *))(a5 + 16);

  v11(a5, 3, object);
}

void ___ZL36nw_protocol_http_retry_get_callbacksv_block_invoke()
{
  nw_protocol_http_retry_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_common_add_input_handler;
  qword_1E8F6A5D0 = (uint64_t)nw_protocol_common_replace_input_handler;
  qword_1E8F6A610 = (uint64_t)nw_protocol_common_get_input_frames;
  qword_1E8F6A618 = (uint64_t)nw_protocol_common_get_output_frames;
  qword_1E8F6A620 = (uint64_t)nw_protocol_common_finalize_output_frames;
  qword_1E8F6A630 = (uint64_t)nw_protocol_common_get_parameters;
  qword_1E8F6A638 = (uint64_t)nw_protocol_common_get_path;
  qword_1E8F6A648 = (uint64_t)nw_protocol_common_get_remote_endpoint;
  qword_1E8F6A640 = (uint64_t)nw_protocol_common_get_local_endpoint;
  qword_1E8F6A688 = (uint64_t)nw_protocol_common_get_output_local_endpoint;
  qword_1E8F6A690 = (uint64_t)nw_protocol_common_get_output_interface;
  qword_1E8F6A5D8 = (uint64_t)nw_protocol_common_connect;
  qword_1E8F6A5E8 = (uint64_t)nw_protocol_common_connected;
  qword_1E8F6A5E0 = (uint64_t)nw_protocol_common_disconnect;
  qword_1E8F6A5F0 = (uint64_t)nw_protocol_common_disconnected;
  qword_1E8F6A600 = (uint64_t)nw_protocol_common_input_available;
  qword_1E8F6A608 = (uint64_t)nw_protocol_common_output_available;
  qword_1E8F6A678 = (uint64_t)nw_protocol_common_input_finished;
  qword_1E8F6A680 = (uint64_t)nw_protocol_common_output_finished;
  qword_1E8F6A6C8 = (uint64_t)nw_protocol_common_input_flush;
  qword_1E8F6A5F8 = (uint64_t)nw_protocol_common_error;
  qword_1E8F6A6C0 = (uint64_t)nw_protocol_common_reset;
  qword_1E8F6A6B8 = (uint64_t)nw_protocol_common_get_message_properties;
  qword_1E8F6A6A0 = (uint64_t)nw_protocol_common_copy_info;
  qword_1E8F6A670 = (uint64_t)nw_protocol_common_supports_external_data;
  qword_1E8F6A698 = (uint64_t)nw_protocol_common_waiting_for_output;
  qword_1E8F6A650 = (uint64_t)nw_protocol_common_register_notification;
  qword_1E8F6A658 = (uint64_t)nw_protocol_common_unregister_notification;
  qword_1E8F6A660 = (uint64_t)nw_protocol_common_notify;
  qword_1E8F6A668 = (uint64_t)nw_protocol_common_updated_path;
  qword_1E8F6A628 = (uint64_t)nw_protocol_common_link_state;
  qword_1E8F6A5C8 = (uint64_t)nw_protocol_http_retry_remove_input_handler;
}

uint64_t nw_protocol_http_retry_remove_input_handler(nw_protocol *a1, nw_protocol *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if ((handle[198] & 1) == 0 && gLogDatapath)
      {
        char v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
          __int16 v24 = 2082;
          BOOL v25 = handle + 114;
          __int16 v26 = 2080;
          BOOL v27 = " ";
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%scalled", buf, 0x20u);
        }
      }
      v19[0] = MEMORY[0x1E4F143A8];
      v19[1] = 0x40000000;
      v19[2] = ___ZL43nw_protocol_http_retry_remove_input_handlerP11nw_protocolS0_b_block_invoke;
      v19[3] = &__block_descriptor_tmp_31_42242;
      v19[4] = handle;
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 0x40000000;
      v17[2] = ___ZL43nw_protocol_http_retry_remove_input_handlerP11nw_protocolS0_b_block_invoke_2;
      v17[3] = &__block_descriptor_tmp_32_42243;
      char v18 = a3;
      v17[4] = handle;
      return nw_protocol_common_remove_input_handler_with_cleanup_blocks(a1, a2, a3, (uint64_t)v19, (uint64_t)v17);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
    id v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v21 = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v8, &v21, &v20)) {
      goto LABEL_36;
    }
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      char v9 = __nwlog_obj();
      os_log_type_t v10 = v21;
      if (os_log_type_enabled(v9, v21))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
        os_log_type_t v11 = "%{public}s called with null http_retry";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (!v20)
    {
      char v9 = __nwlog_obj();
      os_log_type_t v10 = v21;
      if (os_log_type_enabled(v9, v21))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
        os_log_type_t v11 = "%{public}s called with null http_retry, backtrace limit exceeded";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v9 = __nwlog_obj();
    os_log_type_t v10 = v21;
    BOOL v16 = os_log_type_enabled(v9, v21);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
        os_log_type_t v11 = "%{public}s called with null http_retry, no backtrace";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
      __int16 v24 = 2082;
      BOOL v25 = backtrace_string;
      __int16 v15 = "%{public}s called with null http_retry, dumping backtrace:%{public}s";
      goto LABEL_25;
    }
    goto LABEL_26;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
  id v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v21 = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v8, &v21, &v20)) {
    goto LABEL_36;
  }
  if (v21 != OS_LOG_TYPE_FAULT)
  {
    if (!v20)
    {
      char v9 = __nwlog_obj();
      os_log_type_t v10 = v21;
      if (os_log_type_enabled(v9, v21))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
        os_log_type_t v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v9 = __nwlog_obj();
    os_log_type_t v10 = v21;
    BOOL v14 = os_log_type_enabled(v9, v21);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
        os_log_type_t v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_35;
      }
      goto LABEL_36;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
      __int16 v24 = 2082;
      BOOL v25 = backtrace_string;
      __int16 v15 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_25:
      _os_log_impl(&dword_1830D4000, v9, v10, v15, buf, 0x16u);
    }
LABEL_26:
    free(backtrace_string);
    goto LABEL_36;
  }
  char v9 = __nwlog_obj();
  os_log_type_t v10 = v21;
  if (os_log_type_enabled(v9, v21))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v23 = "nw_protocol_http_retry_remove_input_handler";
    os_log_type_t v11 = "%{public}s called with null protocol";
LABEL_35:
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
  }
LABEL_36:
  if (v8) {
    free(v8);
  }
  return 0;
}

void ___ZL43nw_protocol_http_retry_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (gLogDatapath)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v9 = 136446210;
      os_log_type_t v10 = "nw_protocol_plugin_metadata_teardown";
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v9, 0xCu);
    }
  }
  nw_protocol_plugin_metadata_reset((uint64_t *)(v2 + 200));
  *(void *)(v2 + 328) = 0;
  uint64_t v3 = *(void *)(a1 + 32);
  char v4 = *(unsigned char *)(v3 + 480);
  if (v4)
  {
    uint64_t v5 = *(const void **)(v3 + 472);
    if (v5)
    {
      _Block_release(v5);
      char v4 = *(unsigned char *)(v3 + 480);
    }
  }
  *(void *)(v3 + 472) = 0;
  *(unsigned char *)(v3 + 480) = v4 | 1;
  char v6 = *(unsigned char *)(v3 + 528);
  if (v6)
  {
    BOOL v7 = *(const void **)(v3 + 520);
    if (v7)
    {
      _Block_release(v7);
      char v6 = *(unsigned char *)(v3 + 528);
    }
  }
  *(void *)(v3 + 520) = 0;
  *(unsigned char *)(v3 + 528) = v6 | 1;
}

void ___ZL43nw_protocol_http_retry_remove_input_handlerP11nw_protocolS0_b_block_invoke_2(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40)) {
    nw_http_retry_destroy(*(void *)(a1 + 32));
  }
}

double __nw_protocol_http_retry_identifier_block_invoke()
{
  strcpy((char *)&nw_protocol_http_retry_identifier::protocol_identifier, "http_retry");
  *(void *)&double result = 0x100000005;
  qword_1E8F6A540 = 0x100000005;
  return result;
}

uint64_t nw_content_context_get_expiration_milliseconds(nw_content_context_t context)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v1 = context;
  nw_content_context_t v2 = v1;
  if (!v1)
  {
    char v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v16 = "nw_content_context_get_expiration_milliseconds";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v16 = "nw_content_context_get_expiration_milliseconds";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v6 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v16 = "nw_content_context_get_expiration_milliseconds";
            __int16 v17 = 2082;
            char v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v16 = "nw_content_context_get_expiration_milliseconds";
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v6 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v16 = "nw_content_context_get_expiration_milliseconds";
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_24:
    if (v5) {
      free(v5);
    }
    goto LABEL_26;
  }
  uint64_t isa = 0;
  if (v1 != (nw_content_context_t)&__block_literal_global_10_42276
    && v1 != (nw_content_context_t)&__block_literal_global_8_42267
    && v1 != (nw_content_context_t)&__block_literal_global_6_42258
    && v1 != (nw_content_context_t)&__block_literal_global_42249)
  {
    if ((BYTE6(v1[14].isa) & 1) == 0)
    {
      uint64_t isa = (uint64_t)v1[8].isa;
      goto LABEL_27;
    }
LABEL_26:
    uint64_t isa = 0;
  }
LABEL_27:

  return isa;
}

double nw_content_context_get_relative_priority(nw_content_context_t context)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v1 = context;
  nw_content_context_t v2 = v1;
  if (v1)
  {
    double v3 = 0.5;
    if (v1 != (nw_content_context_t)&__block_literal_global_10_42276
      && v1 != (nw_content_context_t)&__block_literal_global_8_42267
      && v1 != (nw_content_context_t)&__block_literal_global_6_42258
      && v1 != (nw_content_context_t)&__block_literal_global_42249
      && (BYTE6(v1[14].isa) & 1) == 0)
    {
      double v3 = *(double *)&v1[10].isa;
    }
    goto LABEL_8;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_content_context_get_relative_priority";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_content_context_get_relative_priority";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_content_context_get_relative_priority";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_content_context_get_relative_priority";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_content_context_get_relative_priority";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v6) {
    free(v6);
  }
  double v3 = 0.5;
LABEL_8:

  return v3;
}

void nw_content_context_set_antecedent(nw_content_context_t context, nw_content_context_t antecedent_context)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  char v4 = antecedent_context;
  uint64_t v5 = v4;
  if (!v3)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_content_context_set_antecedent";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          id v22 = "nw_content_context_set_antecedent";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            id v22 = "nw_content_context_set_antecedent";
            __int16 v23 = 2082;
            __int16 v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          id v22 = "nw_content_context_set_antecedent";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          id v22 = "nw_content_context_set_antecedent";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_35:
    if (v12) {
      free(v12);
    }
    goto LABEL_18;
  }
  if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
    && v3 != (nw_content_context_t)&__block_literal_global_8_42267
    && v3 != (nw_content_context_t)&__block_literal_global_6_42258
    && v3 != (nw_content_context_t)&__block_literal_global_42249
    && v4 != &__block_literal_global_10_42276
    && v4 != &__block_literal_global_8_42267
    && v4 != &__block_literal_global_6_42258
    && v4 != &__block_literal_global_42249)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&v3[14]);
    char v6 = v5;
    if (v6)
    {
      os_log_type_t v7 = v6;
      os_log_type_t v8 = v6;
      while (v8 != (id *)v3)
      {
        os_log_type_t v9 = (id *)v8[7];

        os_log_type_t v8 = v9;
        if (!v9) {
          goto LABEL_14;
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        id v22 = "nw_content_context_set_antecedent";
        __int16 v23 = 2114;
        __int16 v24 = (char *)v7;
        __int16 v25 = 2114;
        nw_content_context_t v26 = v3;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s Cannot create antecedent loops (%{public}@ introduces loop to %{public}@)", buf, 0x20u);
      }

      os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
    }
    else
    {
LABEL_14:
      objc_storeStrong((id *)&v3[7].isa, antecedent_context);
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
    }
  }
LABEL_18:
}

nw_content_context_t nw_content_context_copy_antecedent(nw_content_context_t context)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v1 = context;
  nw_content_context_t v2 = v1;
  if (!v1)
  {
    char v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_content_context_copy_antecedent";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_content_context_copy_antecedent";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v6 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v16 = "nw_content_context_copy_antecedent";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_content_context_copy_antecedent";
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v6 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_content_context_copy_antecedent";
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_24:
    if (v5) {
      free(v5);
    }
    goto LABEL_26;
  }
  nw_content_context_t v3 = 0;
  if (v1 != (nw_content_context_t)&__block_literal_global_10_42276
    && v1 != (nw_content_context_t)&__block_literal_global_8_42267
    && v1 != (nw_content_context_t)&__block_literal_global_6_42258
    && v1 != (nw_content_context_t)&__block_literal_global_42249)
  {
    if ((BYTE6(v1[14].isa) & 1) == 0)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v1[14]);
      nw_content_context_t v3 = v2[7].isa;
      os_unfair_lock_unlock((os_unfair_lock_t)&v2[14]);
      goto LABEL_27;
    }
LABEL_26:
    nw_content_context_t v3 = 0;
  }
LABEL_27:

  return v3;
}

uint64_t __Block_byref_object_copy__42473(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__42474(uint64_t a1)
{
}

uint64_t nw_content_context_supports_replies(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v1 = a1;
  nw_content_context_t v2 = v1;
  if (v1)
  {
    if (v1 == (os_unfair_lock_s *)&__block_literal_global_10_42276)
    {
      uint64_t v3 = 1;
    }
    else
    {
      uint64_t v3 = 0;
      if (v1 != (os_unfair_lock_s *)&__block_literal_global_8_42267
        && v1 != (os_unfair_lock_s *)&__block_literal_global_6_42258
        && v1 != (os_unfair_lock_s *)&__block_literal_global_42249)
      {
        os_unfair_lock_lock(v1 + 28);
        uint64_t v3 = (BYTE2(v2[29]._os_unfair_lock_opaque) >> 6) & 1;
        os_unfair_lock_unlock(v2 + 28);
      }
    }
    goto LABEL_8;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_content_context_supports_replies";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_content_context_supports_replies";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_content_context_supports_replies";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_content_context_supports_replies";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_content_context_supports_replies";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_8:

  return v3;
}

void nw_content_context_set_packet_id(void *a1, _OWORD *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  char v4 = v3;
  if (!v3)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_content_context_set_packet_id";
    char v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_content_context_set_packet_id";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v22 = "nw_content_context_set_packet_id";
          __int16 v23 = 2082;
          __int16 v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_42:
        if (!v6) {
          goto LABEL_8;
        }
LABEL_43:
        free(v6);
        goto LABEL_8;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_content_context_set_packet_id";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_content_context_set_packet_id";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  if (a2)
  {
    if (v3 != (char *)&__block_literal_global_10_42276
      && v3 != (char *)&__block_literal_global_8_42267
      && v3 != (char *)&__block_literal_global_6_42258
      && v3 != (char *)&__block_literal_global_42249)
    {
      v3[118] |= 8u;
      *(_OWORD *)(v3 + 8) = *a2;
    }
    goto LABEL_8;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_content_context_set_packet_id";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_42;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_content_context_set_packet_id";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null packet_id", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (!v19)
  {
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_content_context_set_packet_id";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null packet_id, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_41;
  }
  os_log_type_t v14 = (char *)__nw_create_backtrace_string();
  os_log_type_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_content_context_set_packet_id";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null packet_id, no backtrace", buf, 0xCu);
    }
    goto LABEL_41;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_content_context_set_packet_id";
    __int16 v23 = 2082;
    __int16 v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null packet_id, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_43;
  }
LABEL_8:
}

void nw_content_context_set_app_metadata(void *a1, char a2, char a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  char v6 = v5;
  if (v5)
  {
    if (v5 != &__block_literal_global_10_42276
      && v5 != &__block_literal_global_8_42267
      && v5 != &__block_literal_global_6_42258
      && v5 != &__block_literal_global_42249)
    {
      *((unsigned char *)v5 + 119) |= 1u;
      *((unsigned char *)v5 + 116) = a2;
      *((unsigned char *)v5 + 117) = a3;
    }
    goto LABEL_7;
  }
  os_log_type_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_content_context_set_app_metadata";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_content_context_set_app_metadata";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_content_context_set_app_metadata";
          __int16 v19 = 2082;
          char v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_content_context_set_app_metadata";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_content_context_set_app_metadata";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v8) {
    free(v8);
  }
LABEL_7:
}

uint64_t nw_content_context_copy_local_endpoint(void *a1)
{
  nw_content_context_t v1 = a1;
  nw_content_context_t v2 = v1;
  if (v1 == (os_unfair_lock_s *)&__block_literal_global_10_42276
    || v1 == (os_unfair_lock_s *)&__block_literal_global_8_42267
    || v1 == (os_unfair_lock_s *)&__block_literal_global_6_42258
    || v1 == (os_unfair_lock_s *)&__block_literal_global_42249)
  {
    uint64_t v7 = 0;
  }
  else
  {
    os_unfair_lock_lock(v1 + 28);
    if ((v2[29]._os_unfair_lock_opaque & 0x200000) != 0
      && (uint64_t v6 = *(void *)&v2[26]._os_unfair_lock_opaque) != 0
      && *(void *)(v6 + 24) != *(void *)(v6 + 16))
    {
      uint64_t v7 = nw_array_get_object_at_index(v6, 0);
    }
    else
    {
      uint64_t v7 = 0;
    }
    os_unfair_lock_unlock(v2 + 28);
  }

  return v7;
}

uint64_t nw_content_context_copy_remote_endpoint(void *a1)
{
  nw_content_context_t v1 = a1;
  nw_content_context_t v2 = v1;
  if (v1 == (os_unfair_lock_s *)&__block_literal_global_10_42276
    || v1 == (os_unfair_lock_s *)&__block_literal_global_8_42267
    || v1 == (os_unfair_lock_s *)&__block_literal_global_6_42258
    || v1 == (os_unfair_lock_s *)&__block_literal_global_42249)
  {
    uint64_t v7 = 0;
  }
  else
  {
    os_unfair_lock_lock(v1 + 28);
    if ((v2[29]._os_unfair_lock_opaque & 0x200000) != 0
      && (uint64_t v6 = *(void *)&v2[26]._os_unfair_lock_opaque) != 0
      && *(void *)(v6 + 24) - *(void *)(v6 + 16) >= 9uLL)
    {
      uint64_t v7 = nw_array_get_object_at_index(v6, 1uLL);
    }
    else
    {
      uint64_t v7 = 0;
    }
    os_unfair_lock_unlock(v2 + 28);
  }

  return v7;
}

uint64_t nw_content_context_copy_interface(void *a1)
{
  nw_content_context_t v1 = a1;
  nw_content_context_t v2 = v1;
  if (v1 == (os_unfair_lock_s *)&__block_literal_global_10_42276
    || v1 == (os_unfair_lock_s *)&__block_literal_global_8_42267
    || v1 == (os_unfair_lock_s *)&__block_literal_global_6_42258
    || v1 == (os_unfair_lock_s *)&__block_literal_global_42249)
  {
    uint64_t v7 = 0;
  }
  else
  {
    os_unfair_lock_lock(v1 + 28);
    if ((v2[29]._os_unfair_lock_opaque & 0x200000) != 0
      && (uint64_t v6 = *(void *)&v2[26]._os_unfair_lock_opaque) != 0
      && *(void *)(v6 + 24) - *(void *)(v6 + 16) >= 0x11uLL)
    {
      uint64_t v7 = nw_array_get_object_at_index(v6, 2uLL);
    }
    else
    {
      uint64_t v7 = 0;
    }
    os_unfair_lock_unlock(v2 + 28);
  }

  return v7;
}

uint64_t llhttp__after_headers_complete(uint64_t a1)
{
  __int16 v1 = *(_WORD *)(a1 + 82);
  if ((v1 & 8) != 0)
  {
    BOOL v2 = 1;
    if (!*(unsigned char *)(a1 + 80)) {
      goto LABEL_9;
    }
  }
  else
  {
    BOOL v2 = *(void *)(a1 + 64) != 0;
    if (!*(unsigned char *)(a1 + 80)) {
      goto LABEL_9;
    }
  }
  if (*(unsigned char *)(a1 + 73) == 5) {
    return 1;
  }
  if ((v1 & 0x40) != 0) {
    BOOL v2 = 0;
  }
  if (!v2) {
    return 1;
  }
LABEL_9:
  int v3 = *(unsigned __int8 *)(a1 + 72);
  if (v3 == 2)
  {
    int v4 = *(unsigned __int16 *)(a1 + 84);
    if (v4 == 101) {
      return 1;
    }
    uint64_t v7 = 0;
    if ((v1 & 0x40) != 0) {
      return v7;
    }
    if (v4 == 100) {
      return v7;
    }
    uint64_t v7 = 0;
    if ((v4 - 102) < 2 || v4 == 204 || v4 == 304) {
      return v7;
    }
  }
  else if ((v1 & 0x40) != 0)
  {
    return 0;
  }
  if ((v1 & 8) != 0) {
    return 2;
  }
  if ((*(_WORD *)(a1 + 82) & 0x200) == 0)
  {
    if ((v1 & 0x20) != 0)
    {
      if (*(void *)(a1 + 64)) {
        return 3;
      }
      else {
        return 0;
      }
    }
    else
    {
      if (v3 == 1) {
        return 0;
      }
      int v6 = *(unsigned __int16 *)(a1 + 84);
      if ((v6 - 100) < 0x64) {
        return 0;
      }
      uint64_t v7 = 0;
      if (v6 != 204 && v6 != 304)
      {
        if ((v1 & 0x40) == 0)
        {
          int v8 = v1 & 0x208;
          unsigned int v9 = 4 * ((v1 & 0x28) == 0);
          if (v8 == 512) {
            return 4;
          }
          else {
            return v9;
          }
        }
        return 0;
      }
    }
    return v7;
  }
  if (v3 == 1 && (*(_WORD *)(a1 + 78) & 0xA) == 0) {
    return 5;
  }
  else {
    return 4;
  }
}

BOOL llhttp_message_needs_eof(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 72) == 1) {
    return 0;
  }
  int v2 = *(unsigned __int16 *)(a1 + 84);
  if ((v2 - 100) < 0x64) {
    return 0;
  }
  uint64_t v3 = 0;
  if (v2 != 204 && v2 != 304)
  {
    __int16 v4 = *(_WORD *)(a1 + 82);
    BOOL v5 = (v4 & 0x208) == 0x200 || (v4 & 0x28) == 0;
    return (v4 & 0x40) == 0 && v5;
  }
  return v3;
}

void sub_1839F3D60(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__42974(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__42975(uint64_t a1)
{
}

uint64_t connectionMatchesEntitlementGroup(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v21 = a1;
  long long v22 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v25 = 0u;
  id obj = a2;
  uint64_t v20 = [obj countByEnumeratingWithState:&v22 objects:v30 count:16];
  if (v20)
  {
    uint64_t v19 = *(void *)v23;
    while (2)
    {
      uint64_t v3 = 0;
      while (2)
      {
        if (*(void *)v23 != v19) {
          objc_enumerationMutation(obj);
        }
        __int16 v4 = *(void **)(*((void *)&v22 + 1) + 8 * v3);
        id v5 = v21;
        id v6 = v4;
        long long v26 = 0u;
        long long v27 = 0u;
        long long v28 = 0u;
        long long v29 = 0u;
        id v7 = v6;
        uint64_t v8 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
        if (!v8)
        {
LABEL_21:

          uint64_t v16 = 1;
          goto LABEL_22;
        }
        uint64_t v9 = v8;
        uint64_t v10 = *(void *)v27;
LABEL_10:
        uint64_t v11 = 0;
        while (1)
        {
          if (*(void *)v27 != v10) {
            objc_enumerationMutation(v7);
          }
          id v12 = *(id *)(*((void *)&v26 + 1) + 8 * v11);
          id v13 = v5;
          [v12 UTF8String];
          os_log_type_t v14 = (void *)xpc_connection_copy_entitlement_value();

          if (!v14 || object_getClass(v14) != (Class)MEMORY[0x1E4F14570]) {
            break;
          }
          BOOL value = xpc_BOOL_get_value(v14);

          if (!value) {
            goto LABEL_5;
          }
          if (v9 == ++v11)
          {
            uint64_t v9 = [v7 countByEnumeratingWithState:&v26 objects:v31 count:16];
            if (v9) {
              goto LABEL_10;
            }
            goto LABEL_21;
          }
        }

LABEL_5:
        if (++v3 != v20) {
          continue;
        }
        break;
      }
      uint64_t v20 = [obj countByEnumeratingWithState:&v22 objects:v30 count:16];
      if (v20) {
        continue;
      }
      break;
    }
  }
  uint64_t v16 = 0;
LABEL_22:

  return v16;
}

void sub_1839F7CC0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location)
{
  objc_destroyWeak(v21);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_1839F84F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,id location,uint64_t a22,uint64_t a23,uint64_t a24,char a25)
{
}

uint64_t __Block_byref_object_copy__43223(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__43224(uint64_t a1)
{
}

uint64_t handleRunProbes()
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  v0 = (void *)os_transaction_create();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v1 = (id)gLogObj;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "handleRunProbes";
    *(_WORD *)&buf[12] = 2112;
    *(void *)&buf[14] = v0;
    _os_log_impl(&dword_1830D4000, v1, OS_LOG_TYPE_DEFAULT, "%{public}s created transaction %@", buf, 0x16u);
  }

  id v2 = v0;
  if (v2)
  {
    id v3 = +[ManagedNetworkSettings sharedMNS];
    __int16 v4 = [v3 queue];
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = __runProbes_block_invoke;
    uint64_t v19 = &unk_1E524BAA8;
    id v20 = v2;
    dispatch_async(v4, buf);

    goto LABEL_5;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "runProbes";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "runProbes";
        uint64_t v10 = "%{public}s called with null transaction";
LABEL_17:
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v9;
LABEL_18:
        _os_log_impl(&dword_1830D4000, v14, v15, v10, buf, 0xCu);
      }
    }
    else
    {
      if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v8 = (id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "runProbes";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s called with null transaction, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v13) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "runProbes";
        uint64_t v10 = "%{public}s called with null transaction, no backtrace";
        os_log_type_t v14 = v8;
        os_log_type_t v15 = v12;
        goto LABEL_18;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "runProbes";
        uint64_t v10 = "%{public}s called with null transaction, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_19:
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_5:

  return 0;
}

uint64_t handleRadioType(void *a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  long long v38 = 0u;
  long long v39 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22;
    goto LABEL_51;
  }
  __strlcpy_chk();
  id v5 = [v1 request];
  LOBYTE(v39) = xpc_dictionary_get_uint64(v5, (const char *)networkd_privileged_key_radio_type);

  id v6 = [v1 request];
  BYTE1(v39) = xpc_dictionary_get_uint64(v6, (const char *)networkd_privileged_key_radio_channel);

  int v7 = socket(2, 2, 0);
  if ((v7 & 0x80000000) == 0)
  {
    int v8 = v7;
    if (ioctl(v7, 0xC02069D5uLL, &v38) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "handleRadioType";
        __int16 v36 = 2082;
        *(void *)__int16 v37 = &v38;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully set radio type on %{public}s", buf, 0x16u);
      }

      uint64_t v4 = 0;
LABEL_50:
      close(v8);
      goto LABEL_51;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      v35 = "handleRadioType";
      __int16 v36 = 2082;
      *(void *)__int16 v37 = &v38;
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&v37[10] = v16;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Failed to set radio type on %{public}s: %{darwin.errno}d", buf, 0x1Cu);
    }
    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (id)gLogObj;
    uint64_t v19 = v18;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = 6;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d", buf, 0x18u);
      }

      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446722;
    v35 = "handleRadioType";
    __int16 v36 = 1024;
    *(_DWORD *)__int16 v37 = v8;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v16;
    long long v23 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault((const char *)v23, &type, &v32))
    {
LABEL_48:
      if (v23) {
        free(v23);
      }
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        long long v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_46:
        _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0x18u);
      }
    }
    else
    {
      if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        long long v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v30 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446978;
            v35 = "handleRadioType";
            __int16 v36 = 1024;
            *(_DWORD *)__int16 v37 = v8;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v16;
            *(_WORD *)&v37[10] = 2082;
            *(void *)&v37[12] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (!v30) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446722;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        long long v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_46;
      }
      long long v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        long long v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v35 = "handleRadioType";
  __int16 v36 = 1024;
  *(_DWORD *)__int16 v37 = v10;
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v12, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_30:
        long long v27 = v13;
        os_log_type_t v28 = v14;
LABEL_31:
        _os_log_impl(&dword_1830D4000, v27, v28, v15, buf, 0x12u);
      }
    }
    else
    {
      if (v32)
      {
        id v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (id)gLogObj;
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v13, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446722;
            v35 = "handleRadioType";
            __int16 v36 = 1024;
            *(_DWORD *)__int16 v37 = v10;
            *(_WORD *)&v37[4] = 2082;
            *(void *)&v37[6] = v20;
            _os_log_impl(&dword_1830D4000, v13, v21, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v20);
          goto LABEL_33;
        }
        if (!v22) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        long long v27 = v13;
        os_log_type_t v28 = v21;
        goto LABEL_31;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "handleRadioType";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_30;
      }
    }
LABEL_32:
  }
LABEL_33:
  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_51:

  return v4;
}

uint64_t handleThroughputEstimates(void *a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  long long v38 = 0u;
  long long v39 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22;
    goto LABEL_51;
  }
  __strlcpy_chk();
  id v5 = [v1 request];
  LOBYTE(v39) = xpc_dictionary_get_uint64(v5, (const char *)networkd_privileged_key_upload);

  id v6 = [v1 request];
  BYTE1(v39) = xpc_dictionary_get_uint64(v6, (const char *)networkd_privileged_key_download);

  int v7 = socket(2, 2, 0);
  if ((v7 & 0x80000000) == 0)
  {
    int v8 = v7;
    if (ioctl(v7, 0xC02069D4uLL, &v38) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 2082;
        *(void *)__int16 v37 = &v38;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully set throughput estimate on %{public}s", buf, 0x16u);
      }

      uint64_t v4 = 0;
LABEL_50:
      close(v8);
      goto LABEL_51;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446722;
      v35 = "handleThroughputEstimates";
      __int16 v36 = 2082;
      *(void *)__int16 v37 = &v38;
      *(_WORD *)&v37[8] = 1024;
      *(_DWORD *)&v37[10] = v16;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Failed to set throughput estimate on %{public}s: %{darwin.errno}d", buf, 0x1Cu);
    }
    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v18 = (id)gLogObj;
    uint64_t v19 = v18;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = 6;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d", buf, 0x18u);
      }

      goto LABEL_50;
    }
    *(_DWORD *)buf = 136446722;
    v35 = "handleThroughputEstimates";
    __int16 v36 = 1024;
    *(_DWORD *)__int16 v37 = v8;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v16;
    long long v23 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault((const char *)v23, &type, &v32))
    {
LABEL_48:
      if (v23) {
        free(v23);
      }
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        long long v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_46:
        _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0x18u);
      }
    }
    else
    {
      if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        long long v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v30 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446978;
            v35 = "handleThroughputEstimates";
            __int16 v36 = 1024;
            *(_DWORD *)__int16 v37 = v8;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v16;
            *(_WORD *)&v37[10] = 2082;
            *(void *)&v37[12] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (!v30) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446722;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        long long v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_46;
      }
      long long v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446722;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v8;
        *(_WORD *)&v37[4] = 1024;
        *(_DWORD *)&v37[6] = v16;
        long long v26 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_46;
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  v35 = "handleThroughputEstimates";
  __int16 v36 = 1024;
  *(_DWORD *)__int16 v37 = v10;
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v12, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_30:
        long long v27 = v13;
        os_log_type_t v28 = v14;
LABEL_31:
        _os_log_impl(&dword_1830D4000, v27, v28, v15, buf, 0x12u);
      }
    }
    else
    {
      if (v32)
      {
        id v20 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (id)gLogObj;
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v13, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446722;
            v35 = "handleThroughputEstimates";
            __int16 v36 = 1024;
            *(_DWORD *)__int16 v37 = v10;
            *(_WORD *)&v37[4] = 2082;
            *(void *)&v37[6] = v20;
            _os_log_impl(&dword_1830D4000, v13, v21, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v20);
          goto LABEL_33;
        }
        if (!v22) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        long long v27 = v13;
        os_log_type_t v28 = v21;
        goto LABEL_31;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        v35 = "handleThroughputEstimates";
        __int16 v36 = 1024;
        *(_DWORD *)__int16 v37 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_30;
      }
    }
LABEL_32:
  }
LABEL_33:
  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_51:

  return v4;
}

uint64_t handleTeardownFakeEthernetPair(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  if (!string
    || strlen(string) > 0x10
    || ([v1 request],
        uint64_t v4 = objc_claimAutoreleasedReturnValue(),
        id v5 = xpc_dictionary_get_string(v4, (const char *)networkd_privileged_key_second_interface_name),
        v4,
        !v5)
    || strlen(v5) > 0x10)
  {
    uint64_t v6 = 22;
    goto LABEL_6;
  }
  int v8 = socket(2, 2, 0);
  if ((v8 & 0x80000000) == 0)
  {
    int v9 = v8;
    teardownFakeEthernet(v8, (uint64_t)string);
    teardownFakeEthernet(v9, (uint64_t)v5);
    close(v9);
    uint64_t v6 = 0;
    goto LABEL_6;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  os_log_type_t v21 = "handleTeardownFakeEthernetPair";
  __int16 v22 = 1024;
  int v23 = v10;
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v12, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v21 = "handleTeardownFakeEthernetPair";
        __int16 v22 = 1024;
        int v23 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_22:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0x12u);
      }
    }
    else
    {
      if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v21 = "handleTeardownFakeEthernetPair";
            __int16 v22 = 1024;
            int v23 = v10;
            __int16 v24 = 2082;
            os_log_type_t v25 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (!v17) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v21 = "handleTeardownFakeEthernetPair";
        __int16 v22 = 1024;
        int v23 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        goto LABEL_22;
      }
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v21 = "handleTeardownFakeEthernetPair";
        __int16 v22 = 1024;
        int v23 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_22;
      }
    }
LABEL_23:
  }
LABEL_24:
  uint64_t v6 = v10;
  if (v12) {
    free(v12);
  }
LABEL_6:

  return v6;
}

void teardownFakeEthernet(int a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  int v22 = 0;
  if (sysctlbyname("net.link.fake.nxattach", 0, 0, &v22, 4uLL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v24 = "teardownFakeEthernet";
      id v5 = "%{public}s Failed to clear sysctl to attach fake ethernet";
      uint64_t v6 = v4;
      os_log_type_t v7 = OS_LOG_TYPE_ERROR;
      uint32_t v8 = 12;
LABEL_7:
      _os_log_impl(&dword_1830D4000, v6, v7, v5, buf, v8);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  memset(v31, 0, sizeof(v31));
  __strlcpy_chk();
  if ((ioctl(a1, 0x80206979uLL, v31) & 0x80000000) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v24 = "teardownFakeEthernet";
      __int16 v25 = 2082;
      *(void *)uint64_t v26 = v31;
      id v5 = "%{public}s Successfully destroyed interface %{public}s";
      uint64_t v6 = v4;
      os_log_type_t v7 = OS_LOG_TYPE_DEFAULT;
      uint32_t v8 = 22;
      goto LABEL_7;
    }
LABEL_8:

    return;
  }
  int v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v10 = (id)gLogObj;
  *(_DWORD *)buf = 136446978;
  __int16 v24 = "teardownFakeEthernet";
  __int16 v25 = 1024;
  *(_DWORD *)uint64_t v26 = a1;
  *(_WORD *)&v26[4] = 2082;
  *(void *)&v26[6] = a2;
  __int16 v27 = 1024;
  int v28 = v9;
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v11, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v24 = "teardownFakeEthernet";
        __int16 v25 = 1024;
        *(_DWORD *)uint64_t v26 = a1;
        *(_WORD *)&v26[4] = 2082;
        *(void *)&v26[6] = a2;
        __int16 v27 = 1024;
        int v28 = v9;
        os_log_type_t v14 = "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d";
LABEL_21:
        char v18 = v12;
        os_log_type_t v19 = v13;
LABEL_22:
        _os_log_impl(&dword_1830D4000, v18, v19, v14, buf, 0x22u);
      }
    }
    else
    {
      if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (id)gLogObj;
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136447234;
            __int16 v24 = "teardownFakeEthernet";
            __int16 v25 = 1024;
            *(_DWORD *)uint64_t v26 = a1;
            *(_WORD *)&v26[4] = 2082;
            *(void *)&v26[6] = a2;
            __int16 v27 = 1024;
            int v28 = v9;
            __int16 v29 = 2082;
            BOOL v30 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v16, "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (!v17) {
          goto LABEL_23;
        }
        *(_DWORD *)buf = 136446978;
        __int16 v24 = "teardownFakeEthernet";
        __int16 v25 = 1024;
        *(_DWORD *)uint64_t v26 = a1;
        *(_WORD *)&v26[4] = 2082;
        *(void *)&v26[6] = a2;
        __int16 v27 = 1024;
        int v28 = v9;
        os_log_type_t v14 = "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d, no backtrace";
        char v18 = v12;
        os_log_type_t v19 = v16;
        goto LABEL_22;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (id)gLogObj;
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v24 = "teardownFakeEthernet";
        __int16 v25 = 1024;
        *(_DWORD *)uint64_t v26 = a1;
        *(_WORD *)&v26[4] = 2082;
        *(void *)&v26[6] = a2;
        __int16 v27 = 1024;
        int v28 = v9;
        os_log_type_t v14 = "%{public}s ioctl(%d, SIOCIFDESTROY, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_23:
  }
LABEL_24:
  if (v11) {
    free(v11);
  }
}

uint64_t handleSetupFakeEthernetPair(void *a1)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  if (string)
  {
    if (strlen(string) <= 0x10)
    {
      uint64_t v4 = [v1 request];
      id v5 = xpc_dictionary_get_string(v4, (const char *)networkd_privileged_key_second_interface_name);

      if (v5)
      {
        if (strlen(v5) <= 0x10)
        {
          int v8 = socket(2, 2, 0);
          if ((v8 & 0x80000000) == 0)
          {
            int v9 = v8;
            LODWORD(v6) = setupFakeEthernet(v8, (uint64_t)string);
            if (v6)
            {
LABEL_23:
              close(v9);
LABEL_32:
              uint64_t v6 = (int)v6;
              goto LABEL_6;
            }
            int v10 = setupFakeEthernet(v9, (uint64_t)v5);
            if (v10)
            {
              LODWORD(v6) = v10;
              int v11 = v9;
              uint64_t v12 = (uint64_t)string;
LABEL_11:
              teardownFakeEthernet(v11, v12);
              goto LABEL_23;
            }
            v50[0] = 0u;
            long long v48 = 0u;
            long long v49 = 0u;
            long long v46 = 0u;
            long long v47 = 0u;
            long long v44 = 0u;
            long long v45 = 0u;
            long long v42 = 0u;
            long long v43 = 0u;
            memset(buf, 0, sizeof(buf));
            __strlcpy_chk();
            v50[1] = xmmword_183D5CD60;
            os_log_type_t v51 = buf;
            __strlcpy_chk();
            if ((ioctl(v9, 0x8028697BuLL, v50) & 0x80000000) == 0)
            {
              LODWORD(v6) = 0;
              goto LABEL_23;
            }
            LODWORD(v6) = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            char v20 = __nwlog_obj();
            *(_DWORD *)os_log_type_t type = 136447234;
            BOOL v30 = "handleSetupFakeEthernetPair";
            __int16 v31 = 1024;
            int v32 = v9;
            __int16 v33 = 2082;
            uint64_t v34 = string;
            __int16 v35 = 2082;
            __int16 v36 = v5;
            __int16 v37 = 1024;
            int v38 = v6;
            os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();

            os_log_type_t v28 = OS_LOG_TYPE_ERROR;
            char v27 = 0;
            if (!__nwlog_fault((const char *)v21, &v28, &v27))
            {
LABEL_48:
              if (v21) {
                free(v21);
              }
              teardownFakeEthernet(v9, (uint64_t)string);
              int v11 = v9;
              uint64_t v12 = (uint64_t)v5;
              goto LABEL_11;
            }
            if (v28 == OS_LOG_TYPE_FAULT)
            {
              int v22 = __nwlog_obj();
              os_log_type_t v23 = v28;
              if (os_log_type_enabled(v22, v28))
              {
                *(_DWORD *)os_log_type_t type = 136447234;
                BOOL v30 = "handleSetupFakeEthernetPair";
                __int16 v31 = 1024;
                int v32 = v9;
                __int16 v33 = 2082;
                uint64_t v34 = string;
                __int16 v35 = 2082;
                __int16 v36 = v5;
                __int16 v37 = 1024;
                int v38 = v6;
                __int16 v24 = "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d";
LABEL_46:
                _os_log_impl(&dword_1830D4000, v22, v23, v24, (uint8_t *)type, 0x2Cu);
              }
            }
            else
            {
              if (v27)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                int v22 = __nwlog_obj();
                os_log_type_t v23 = v28;
                BOOL v26 = os_log_type_enabled(v22, v28);
                if (backtrace_string)
                {
                  if (v26)
                  {
                    *(_DWORD *)os_log_type_t type = 136447490;
                    BOOL v30 = "handleSetupFakeEthernetPair";
                    __int16 v31 = 1024;
                    int v32 = v9;
                    __int16 v33 = 2082;
                    uint64_t v34 = string;
                    __int16 v35 = 2082;
                    __int16 v36 = v5;
                    __int16 v37 = 1024;
                    int v38 = v6;
                    __int16 v39 = 2082;
                    uint64_t v40 = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x36u);
                  }

                  free(backtrace_string);
                  goto LABEL_48;
                }
                if (!v26) {
                  goto LABEL_47;
                }
                *(_DWORD *)os_log_type_t type = 136447234;
                BOOL v30 = "handleSetupFakeEthernetPair";
                __int16 v31 = 1024;
                int v32 = v9;
                __int16 v33 = 2082;
                uint64_t v34 = string;
                __int16 v35 = 2082;
                __int16 v36 = v5;
                __int16 v37 = 1024;
                int v38 = v6;
                __int16 v24 = "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d, no backtrace";
                goto LABEL_46;
              }
              int v22 = __nwlog_obj();
              os_log_type_t v23 = v28;
              if (os_log_type_enabled(v22, v28))
              {
                *(_DWORD *)os_log_type_t type = 136447234;
                BOOL v30 = "handleSetupFakeEthernetPair";
                __int16 v31 = 1024;
                int v32 = v9;
                __int16 v33 = 2082;
                uint64_t v34 = string;
                __int16 v35 = 2082;
                __int16 v36 = v5;
                __int16 v37 = 1024;
                int v38 = v6;
                __int16 v24 = "%{public}s ioctl(%d, SIOCSDRVSPEC, %{public}s<->%{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_46;
              }
            }
LABEL_47:

            goto LABEL_48;
          }
          LODWORD(v6) = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v13 = (id)gLogObj;
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v6;
          os_log_type_t v14 = (void *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v50[0]) = 0;
          if (!__nwlog_fault((const char *)v14, type, v50))
          {
LABEL_30:
            if (v14) {
              free(v14);
            }
            goto LABEL_32;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v15 = __nwlog_obj();
            os_log_type_t v16 = type[0];
            if (os_log_type_enabled(v15, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v6;
              BOOL v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_28:
              _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0x12u);
            }
          }
          else
          {
            if (LOBYTE(v50[0]))
            {
              char v18 = (char *)__nw_create_backtrace_string();
              os_log_type_t v15 = __nwlog_obj();
              os_log_type_t v16 = type[0];
              BOOL v19 = os_log_type_enabled(v15, type[0]);
              if (v18)
              {
                if (v19)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v6;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v18;
                  _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }

                free(v18);
                goto LABEL_30;
              }
              if (!v19) {
                goto LABEL_29;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v6;
              BOOL v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
              goto LABEL_28;
            }
            os_log_type_t v15 = __nwlog_obj();
            os_log_type_t v16 = type[0];
            if (os_log_type_enabled(v15, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "handleSetupFakeEthernetPair";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v6;
              BOOL v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
              goto LABEL_28;
            }
          }
LABEL_29:

          goto LABEL_30;
        }
      }
    }
  }
  uint64_t v6 = 22;
LABEL_6:

  return v6;
}

uint64_t setupFakeEthernet(int a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  int v31 = 1;
  uint64_t v4 = sysctlbyname("net.link.fake.nxattach", 0, 0, &v31, 4uLL);
  if (v4)
  {
    uint64_t v5 = v4;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v33 = "setupFakeEthernet";
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s Failed to set sysctl to attach fake ethernet", buf, 0xCu);
    }

    return v5;
  }
  long long v40 = 0u;
  long long v41 = 0u;
  __strlcpy_chk();
  if (ioctl(a1, 0xC0206978uLL, &v40) < 0)
  {
    uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v10, &type, &v29)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v11 = (id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      id v13 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d";
LABEL_70:
      __int16 v24 = v11;
      os_log_type_t v25 = v12;
      goto LABEL_71;
    }
    if (!v29)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v11 = (id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      id v13 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_70;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (!v17) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      __int16 v38 = 2082;
      __int16 v39 = backtrace_string;
      char v18 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
    if (!v17) {
      goto LABEL_72;
    }
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    id v13 = "%{public}s ioctl(%d, SIOCIFCREATE, %{public}s) failed %{darwin.errno}d, no backtrace";
LABEL_56:
    __int16 v24 = v11;
    os_log_type_t v25 = v16;
LABEL_71:
    _os_log_impl(&dword_1830D4000, v24, v25, v13, buf, 0x22u);
    goto LABEL_72;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v7 = (id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 2082;
    *(void *)__int16 v35 = &v40;
    _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully created interface %{public}s", buf, 0x16u);
  }

  if (ioctl(a1, 0xC0206950uLL, &v40) < 0)
  {
    uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v10, &type, &v29)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v11 = (id)gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      id v13 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d";
      goto LABEL_70;
    }
    if (!v29)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        id v13 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_70;
      }
      goto LABEL_72;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v20 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (!v20) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136447234;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      __int16 v38 = 2082;
      __int16 v39 = backtrace_string;
      char v18 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_1830D4000, v11, v16, v18, buf, 0x2Cu);
LABEL_36:

      free(backtrace_string);
      if (!v10) {
        return v5;
      }
      goto LABEL_74;
    }
    if (!v20) {
      goto LABEL_72;
    }
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    id v13 = "%{public}s ioctl(%d, SIOCPROTOATTACH, %{public}s) failed %{darwin.errno}d, no backtrace";
    goto LABEL_56;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v8 = (id)gLogObj;
  if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 2082;
    *(void *)__int16 v35 = &v40;
    _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully attach proto to interface %{public}s", buf, 0x16u);
  }

  long long v40 = 0u;
  long long v41 = 0u;
  __strlcpy_chk();
  if ((ioctl(a1, 0xC0206911uLL, &v40) & 0x80000000) == 0)
  {
    if (v41) {
      return 0;
    }
    LOWORD(v41) = v41 | 1;
    if ((ioctl(a1, 0x80206910uLL, &v40) & 0x80000000) == 0) {
      return 0;
    }
    uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v10, &type, &v29)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        id v13 = "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d";
        goto LABEL_70;
      }
    }
    else if (v29)
    {
      BOOL v26 = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v27 = os_log_type_enabled(v11, type);
      if (v26)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136447234;
          __int16 v33 = "setupFakeEthernet";
          __int16 v34 = 1024;
          *(_DWORD *)__int16 v35 = a1;
          *(_WORD *)&v35[4] = 2082;
          *(void *)&v35[6] = a2;
          __int16 v36 = 1024;
          int v37 = v5;
          __int16 v38 = 2082;
          __int16 v39 = v26;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }

        free(v26);
LABEL_73:
        if (!v10) {
          return v5;
        }
LABEL_74:
        free(v10);
        return v5;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        id v13 = "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d, no backtrace";
        goto LABEL_70;
      }
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446978;
        __int16 v33 = "setupFakeEthernet";
        __int16 v34 = 1024;
        *(_DWORD *)__int16 v35 = a1;
        *(_WORD *)&v35[4] = 2082;
        *(void *)&v35[6] = a2;
        __int16 v36 = 1024;
        int v37 = v5;
        id v13 = "%{public}s ioctl(%d, SIOCSIFFLAGS, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_70;
      }
    }
LABEL_72:

    goto LABEL_73;
  }
  uint64_t v5 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v19 = (id)gLogObj;
  *(_DWORD *)buf = 136446978;
  __int16 v33 = "setupFakeEthernet";
  __int16 v34 = 1024;
  *(_DWORD *)__int16 v35 = a1;
  *(_WORD *)&v35[4] = 2082;
  *(void *)&v35[6] = a2;
  __int16 v36 = 1024;
  int v37 = v5;
  int v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (!__nwlog_fault(v10, &type, &v29)) {
    goto LABEL_73;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = (id)gLogObj;
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_72;
    }
    *(_DWORD *)buf = 136446978;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    id v13 = "%{public}s ioctl(%d, SIOCGIFFLAGS, %{public}s) failed %{darwin.errno}d";
    goto LABEL_70;
  }
  if (!v29)
  {
    int v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      id v13 = "%{public}s ioctl(%d, SIOCGIFFLAGS, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_70;
    }
    goto LABEL_72;
  }
  os_log_type_t v21 = (char *)__nw_create_backtrace_string();
  int v11 = __nwlog_obj();
  os_log_type_t v12 = type;
  BOOL v22 = os_log_type_enabled(v11, type);
  if (!v21)
  {
    if (v22)
    {
      *(_DWORD *)buf = 136446978;
      __int16 v33 = "setupFakeEthernet";
      __int16 v34 = 1024;
      *(_DWORD *)__int16 v35 = a1;
      *(_WORD *)&v35[4] = 2082;
      *(void *)&v35[6] = a2;
      __int16 v36 = 1024;
      int v37 = v5;
      id v13 = "%{public}s ioctl(%d, SIOCGIFFLAGS, %{public}s) failed %{darwin.errno}d, no backtrace";
      goto LABEL_70;
    }
    goto LABEL_72;
  }
  if (v22)
  {
    *(_DWORD *)buf = 136447234;
    __int16 v33 = "setupFakeEthernet";
    __int16 v34 = 1024;
    *(_DWORD *)__int16 v35 = a1;
    *(_WORD *)&v35[4] = 2082;
    *(void *)&v35[6] = a2;
    __int16 v36 = 1024;
    int v37 = v5;
    __int16 v38 = 2082;
    __int16 v39 = v21;
    _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s ioctl(%d, SIOCGIFFLAGS, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
  }

  free(v21);
  if (v10) {
    goto LABEL_74;
  }
  return v5;
}

uint64_t handleExpensive(void *a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  long long v40 = 0u;
  long long v41 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22;
    goto LABEL_56;
  }
  __strlcpy_chk();
  uint64_t v5 = [v1 request];
  LODWORD(v41) = xpc_dictionary_get_BOOL(v5, (const char *)networkd_privileged_key_expensive);

  int v6 = socket(2, 2, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (ioctl(v6, 0xC02069A1uLL, &v40) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v36 = "handleExpensive";
        *(_DWORD *)buf = 136446722;
        if (v41) {
          id v9 = "Set";
        }
        else {
          id v9 = "Cleared";
        }
        __int16 v37 = 2082;
        *(void *)__int16 v38 = v9;
        *(_WORD *)&v38[8] = 2082;
        *(void *)&v38[10] = &v40;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully %{public}s expensive on %{public}s", buf, 0x20u);
      }

      uint64_t v4 = 0;
LABEL_55:
      close(v7);
      goto LABEL_56;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      char v18 = "set";
      __int16 v36 = "handleExpensive";
      *(_DWORD *)buf = 136446978;
      __int16 v37 = 2082;
      if (!v41) {
        char v18 = "clear";
      }
      *(void *)__int16 v38 = v18;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = &v40;
      *(_WORD *)&v38[18] = 1024;
      int v39 = v16;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Failed to %{public}s expensive on %{public}s: %{darwin.errno}d", buf, 0x26u);
    }
    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    BOOL v20 = v19;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 6;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d", buf, 0x18u);
      }

      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v36 = "handleExpensive";
    __int16 v37 = 1024;
    *(_DWORD *)__int16 v38 = v7;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v16;
    __int16 v24 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v24, &type, &v33))
    {
LABEL_53:
      if (v24) {
        free(v24);
      }
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d";
LABEL_51:
        _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0x18u);
      }
    }
    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446978;
            __int16 v36 = "handleExpensive";
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = v7;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v16;
            *(_WORD *)&v38[10] = 2082;
            *(void *)&v38[12] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }
        if (!v31) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_51;
      }
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFEXPENSIVE, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  __int16 v36 = "handleExpensive";
  __int16 v37 = 1024;
  *(_DWORD *)__int16 v38 = v10;
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (__nwlog_fault(v12, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_35:
        os_log_type_t v28 = v13;
        os_log_type_t v29 = v14;
LABEL_36:
        _os_log_impl(&dword_1830D4000, v28, v29, v15, buf, 0x12u);
      }
    }
    else
    {
      if (v33)
      {
        os_log_type_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (id)gLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v13, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446722;
            __int16 v36 = "handleExpensive";
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = v10;
            *(_WORD *)&v38[4] = 2082;
            *(void *)&v38[6] = v21;
            _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v21);
          goto LABEL_38;
        }
        if (!v23) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        os_log_type_t v28 = v13;
        os_log_type_t v29 = v22;
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleExpensive";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
LABEL_37:
  }
LABEL_38:
  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_56:

  return v4;
}

uint64_t handleUltraConstrained(void *a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  long long v40 = 0u;
  long long v41 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22;
    goto LABEL_56;
  }
  __strlcpy_chk();
  uint64_t v5 = [v1 request];
  LODWORD(v41) = xpc_dictionary_get_BOOL(v5, (const char *)networkd_privileged_key_constrained);

  int v6 = socket(2, 2, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (ioctl(v6, 0xC02069DBuLL, &v40) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v36 = "handleUltraConstrained";
        *(_DWORD *)buf = 136446722;
        if (v41) {
          id v9 = "Set";
        }
        else {
          id v9 = "Cleared";
        }
        __int16 v37 = 2082;
        *(void *)__int16 v38 = v9;
        *(_WORD *)&v38[8] = 2082;
        *(void *)&v38[10] = &v40;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully %{public}s ultra constrained on %{public}s", buf, 0x20u);
      }

      uint64_t v4 = 0;
LABEL_55:
      close(v7);
      goto LABEL_56;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      char v18 = "set";
      __int16 v36 = "handleUltraConstrained";
      *(_DWORD *)buf = 136446978;
      __int16 v37 = 2082;
      if (!v41) {
        char v18 = "clear";
      }
      *(void *)__int16 v38 = v18;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = &v40;
      *(_WORD *)&v38[18] = 1024;
      int v39 = v16;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Failed to %{public}s ultra constrained on %{public}s: %{darwin.errno}d", buf, 0x26u);
    }
    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    BOOL v20 = v19;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 6;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d", buf, 0x18u);
      }

      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v36 = "handleUltraConstrained";
    __int16 v37 = 1024;
    *(_DWORD *)__int16 v38 = v7;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v16;
    __int16 v24 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v24, &type, &v33))
    {
LABEL_53:
      if (v24) {
        free(v24);
      }
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_51:
        _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0x18u);
      }
    }
    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446978;
            __int16 v36 = "handleUltraConstrained";
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = v7;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v16;
            *(_WORD *)&v38[10] = 2082;
            *(void *)&v38[12] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }
        if (!v31) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_51;
      }
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFULTRACONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  __int16 v36 = "handleUltraConstrained";
  __int16 v37 = 1024;
  *(_DWORD *)__int16 v38 = v10;
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (__nwlog_fault(v12, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_35:
        os_log_type_t v28 = v13;
        os_log_type_t v29 = v14;
LABEL_36:
        _os_log_impl(&dword_1830D4000, v28, v29, v15, buf, 0x12u);
      }
    }
    else
    {
      if (v33)
      {
        os_log_type_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (id)gLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v13, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446722;
            __int16 v36 = "handleUltraConstrained";
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = v10;
            *(_WORD *)&v38[4] = 2082;
            *(void *)&v38[6] = v21;
            _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v21);
          goto LABEL_38;
        }
        if (!v23) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        os_log_type_t v28 = v13;
        os_log_type_t v29 = v22;
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleUltraConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
LABEL_37:
  }
LABEL_38:
  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_56:

  return v4;
}

uint64_t handleConstrained(void *a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_interface_name);

  long long v40 = 0u;
  long long v41 = 0u;
  if (!string || strlen(string) > 0x10)
  {
    uint64_t v4 = 22;
    goto LABEL_56;
  }
  __strlcpy_chk();
  uint64_t v5 = [v1 request];
  LODWORD(v41) = xpc_dictionary_get_BOOL(v5, (const char *)networkd_privileged_key_constrained);

  int v6 = socket(2, 2, 0);
  if ((v6 & 0x80000000) == 0)
  {
    int v7 = v6;
    if (ioctl(v6, 0xC02069CDuLL, &v40) != -1)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        __int16 v36 = "handleConstrained";
        *(_DWORD *)buf = 136446722;
        if (v41) {
          id v9 = "Set";
        }
        else {
          id v9 = "Cleared";
        }
        __int16 v37 = 2082;
        *(void *)__int16 v38 = v9;
        *(_WORD *)&v38[8] = 2082;
        *(void *)&v38[10] = &v40;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully %{public}s constrained on %{public}s", buf, 0x20u);
      }

      uint64_t v4 = 0;
LABEL_55:
      close(v7);
      goto LABEL_56;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      char v18 = "set";
      __int16 v36 = "handleConstrained";
      *(_DWORD *)buf = 136446978;
      __int16 v37 = 2082;
      if (!v41) {
        char v18 = "clear";
      }
      *(void *)__int16 v38 = v18;
      *(_WORD *)&v38[8] = 2082;
      *(void *)&v38[10] = &v40;
      *(_WORD *)&v38[18] = 1024;
      int v39 = v16;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Failed to %{public}s constrained on %{public}s: %{darwin.errno}d", buf, 0x26u);
    }
    uint64_t v4 = v16;

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    BOOL v20 = v19;
    if (v16 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = 6;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d", buf, 0x18u);
      }

      goto LABEL_55;
    }
    *(_DWORD *)buf = 136446722;
    __int16 v36 = "handleConstrained";
    __int16 v37 = 1024;
    *(_DWORD *)__int16 v38 = v7;
    *(_WORD *)&v38[4] = 1024;
    *(_DWORD *)&v38[6] = v16;
    __int16 v24 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault((const char *)v24, &type, &v33))
    {
LABEL_53:
      if (v24) {
        free(v24);
      }
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d";
LABEL_51:
        _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0x18u);
      }
    }
    else
    {
      if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446978;
            __int16 v36 = "handleConstrained";
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = v7;
            *(_WORD *)&v38[4] = 1024;
            *(_DWORD *)&v38[6] = v16;
            *(_WORD *)&v38[10] = 2082;
            *(void *)&v38[12] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          goto LABEL_53;
        }
        if (!v31) {
          goto LABEL_52;
        }
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, no backtrace";
        goto LABEL_51;
      }
      os_log_type_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446722;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v7;
        *(_WORD *)&v38[4] = 1024;
        *(_DWORD *)&v38[6] = v16;
        BOOL v27 = "%{public}s ioctl(%d, SIOCSIFCONSTRAINED, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  int v10 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  __int16 v36 = "handleConstrained";
  __int16 v37 = 1024;
  *(_DWORD *)__int16 v38 = v10;
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (__nwlog_fault(v12, &type, &v33))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_35:
        os_log_type_t v28 = v13;
        os_log_type_t v29 = v14;
LABEL_36:
        _os_log_impl(&dword_1830D4000, v28, v29, v15, buf, 0x12u);
      }
    }
    else
    {
      if (v33)
      {
        os_log_type_t v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (id)gLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v13, type);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446722;
            __int16 v36 = "handleConstrained";
            __int16 v37 = 1024;
            *(_DWORD *)__int16 v38 = v10;
            *(_WORD *)&v38[4] = 2082;
            *(void *)&v38[6] = v21;
            _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v21);
          goto LABEL_38;
        }
        if (!v23) {
          goto LABEL_37;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        os_log_type_t v28 = v13;
        os_log_type_t v29 = v22;
        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v13 = (id)gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v36 = "handleConstrained";
        __int16 v37 = 1024;
        *(_DWORD *)__int16 v38 = v10;
        os_log_type_t v15 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_35;
      }
    }
LABEL_37:
  }
LABEL_38:
  uint64_t v4 = v10;
  if (v12) {
    free(v12);
  }
LABEL_56:

  return v4;
}

uint64_t handleSetNetworkdSetting(void *a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_settings_key);

  if (string)
  {
    uint64_t v4 = [v1 request];
    uint64_t v5 = xpc_dictionary_get_string(v4, (const char *)networkd_privileged_key_settings_file_prefix);

    if (v5)
    {
      int v6 = [NSString stringWithUTF8String:v5];
      int v7 = [MEMORY[0x1E4F28E58] characterSetWithCharactersInString:@"_-"];
      int v8 = [MEMORY[0x1E4F28B88] alphanumericCharacterSet];
      [v7 formUnionWithCharacterSet:v8];

      id v9 = [v7 invertedSet];
      if ([v6 rangeOfCharacterFromSet:v9] != 0x7FFFFFFFFFFFFFFFLL)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446722;
          long long v40 = "handleSetNetworkdSetting";
          __int16 v41 = 1024;
          *(_DWORD *)uint64_t v42 = [v1 pid];
          *(_WORD *)&v42[4] = 2082;
          *(void *)&v42[6] = v5;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s pid %d sent us file_prefix \"%{public}s\" containing invalid characters", buf, 0x1Cu);
        }

        int v10 = 0;
        uint64_t v11 = 22;
        goto LABEL_33;
      }
      int v10 = [NSString stringWithFormat:@"%@%@%@", @"/Library/Preferences/com.apple.networkd.", v6, @".plist"];
    }
    else
    {
      int v10 = [NSString stringWithUTF8String:nw_file_path_settings];
    }
    os_log_type_t v12 = [v1 request];
    int v6 = xpc_dictionary_get_value(v12, (const char *)networkd_privileged_key_settings_value);

    id v13 = [MEMORY[0x1E4F1CA60] dictionaryWithContentsOfFile:v10];
    if (v6) {
      int v7 = (void *)_CFXPCCreateCFObjectFromXPCObject();
    }
    else {
      int v7 = 0;
    }
    id v9 = [NSString stringWithUTF8String:string];
    if (v7)
    {
      if (!v13)
      {
        id v13 = [MEMORY[0x1E4F1CA60] dictionary];
      }
      os_log_type_t v15 = [v13 objectForKeyedSubscript:v9];
      char v16 = [v7 isEqual:v15];

      if ((v16 & 1) == 0)
      {
        [v13 setObject:v7 forKeyedSubscript:v9];
        if (!v13) {
          goto LABEL_45;
        }
        goto LABEL_25;
      }
    }
    else if (v13)
    {
      BOOL v17 = [v13 objectForKeyedSubscript:v9];

      if (v17)
      {
        [v13 removeObjectForKey:v9];
        if (![v13 count])
        {

LABEL_45:
          if (unlink((const char *)[v10 UTF8String]))
          {
            int v29 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v30 = (id)gLogObj;
            *(_DWORD *)buf = 136446722;
            long long v40 = "handleSetNetworkdSetting";
            __int16 v41 = 2114;
            *(void *)uint64_t v42 = v10;
            *(_WORD *)&v42[8] = 1024;
            *(_DWORD *)&v42[10] = v29;
            BOOL v31 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v37 = 0;
            if (!__nwlog_fault(v31, &type, &v37)) {
              goto LABEL_72;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v32 = (id)gLogObj;
              os_log_type_t v33 = type;
              if (os_log_type_enabled(v32, type))
              {
                *(_DWORD *)buf = 136446722;
                long long v40 = "handleSetNetworkdSetting";
                __int16 v41 = 2114;
                *(void *)uint64_t v42 = v10;
                *(_WORD *)&v42[8] = 1024;
                *(_DWORD *)&v42[10] = v29;
                __int16 v34 = "%{public}s unlink(%{public}@) failed %{darwin.errno}d";
LABEL_70:
                _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0x1Cu);
              }
            }
            else
            {
              if (v37)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                int v32 = __nwlog_obj();
                os_log_type_t v33 = type;
                BOOL v36 = os_log_type_enabled(v32, type);
                if (backtrace_string)
                {
                  if (v36)
                  {
                    *(_DWORD *)buf = 136446978;
                    long long v40 = "handleSetNetworkdSetting";
                    __int16 v41 = 2114;
                    *(void *)uint64_t v42 = v10;
                    *(_WORD *)&v42[8] = 1024;
                    *(_DWORD *)&v42[10] = v29;
                    *(_WORD *)&v42[14] = 2082;
                    *(void *)&v42[16] = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s unlink(%{public}@) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                  }

                  free(backtrace_string);
                  goto LABEL_72;
                }
                if (!v36) {
                  goto LABEL_71;
                }
                *(_DWORD *)buf = 136446722;
                long long v40 = "handleSetNetworkdSetting";
                __int16 v41 = 2114;
                *(void *)uint64_t v42 = v10;
                *(_WORD *)&v42[8] = 1024;
                *(_DWORD *)&v42[10] = v29;
                __int16 v34 = "%{public}s unlink(%{public}@) failed %{darwin.errno}d, no backtrace";
                goto LABEL_70;
              }
              int v32 = __nwlog_obj();
              os_log_type_t v33 = type;
              if (os_log_type_enabled(v32, type))
              {
                *(_DWORD *)buf = 136446722;
                long long v40 = "handleSetNetworkdSetting";
                __int16 v41 = 2114;
                *(void *)uint64_t v42 = v10;
                *(_WORD *)&v42[8] = 1024;
                *(_DWORD *)&v42[10] = v29;
                __int16 v34 = "%{public}s unlink(%{public}@) failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_70;
              }
            }
LABEL_71:

LABEL_72:
            uint64_t v11 = v29;
            if (v31) {
              free(v31);
            }
            goto LABEL_33;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v13 = (id)gLogObj;
          if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            long long v40 = "handleSetNetworkdSetting";
            __int16 v41 = 2114;
            *(void *)uint64_t v42 = v9;
            _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully removed value of setting %{public}@", buf, 0x16u);
          }
LABEL_32:

          fixFilePermissions(v10);
          uint64_t v11 = 0;
LABEL_33:

          goto LABEL_34;
        }
LABEL_25:
        char v18 = [v13 writeToFile:v10 atomically:1];
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        BOOL v20 = v19;
        if (v18)
        {
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)buf = 136446466;
            long long v40 = "handleSetNetworkdSetting";
            __int16 v41 = 2114;
            *(void *)uint64_t v42 = v9;
            _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully changed value of setting %{public}@", buf, 0x16u);
          }

          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        long long v40 = "handleSetNetworkdSetting";
        __int16 v41 = 2114;
        *(void *)uint64_t v42 = v10;
        BOOL v23 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v37 = 0;
        if (!__nwlog_fault((const char *)v23, &type, &v37))
        {
LABEL_65:
          if (v23) {
            free(v23);
          }

          uint64_t v11 = 5;
          goto LABEL_33;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v24 = (id)gLogObj;
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446466;
            long long v40 = "handleSetNetworkdSetting";
            __int16 v41 = 2114;
            *(void *)uint64_t v42 = v10;
            os_log_type_t v26 = "%{public}s settings writeToFile:\"%{public}@\" failed";
LABEL_63:
            _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0x16u);
          }
        }
        else
        {
          if (v37)
          {
            BOOL v27 = (char *)__nw_create_backtrace_string();
            __int16 v24 = __nwlog_obj();
            os_log_type_t v25 = type;
            BOOL v28 = os_log_type_enabled(v24, type);
            if (v27)
            {
              if (v28)
              {
                *(_DWORD *)buf = 136446722;
                long long v40 = "handleSetNetworkdSetting";
                __int16 v41 = 2114;
                *(void *)uint64_t v42 = v10;
                *(_WORD *)&v42[8] = 2082;
                *(void *)&v42[10] = v27;
                _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s settings writeToFile:\"%{public}@\" failed, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v27);
              goto LABEL_65;
            }
            if (!v28) {
              goto LABEL_64;
            }
            *(_DWORD *)buf = 136446466;
            long long v40 = "handleSetNetworkdSetting";
            __int16 v41 = 2114;
            *(void *)uint64_t v42 = v10;
            os_log_type_t v26 = "%{public}s settings writeToFile:\"%{public}@\" failed, no backtrace";
            goto LABEL_63;
          }
          __int16 v24 = __nwlog_obj();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446466;
            long long v40 = "handleSetNetworkdSetting";
            __int16 v41 = 2114;
            *(void *)uint64_t v42 = v10;
            os_log_type_t v26 = "%{public}s settings writeToFile:\"%{public}@\" failed, backtrace limit exceeded";
            goto LABEL_63;
          }
        }
LABEL_64:

        goto LABEL_65;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v21 = (id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)buf = 136446466;
      long long v40 = "handleSetNetworkdSetting";
      __int16 v41 = 2114;
      *(void *)uint64_t v42 = v9;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEFAULT, "%{public}s new value is the same, will not save settings for %{public}@", buf, 0x16u);
    }

    goto LABEL_32;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v10 = (id)gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    long long v40 = "handleSetNetworkdSetting";
    __int16 v41 = 1024;
    *(_DWORD *)uint64_t v42 = [v1 pid];
    _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s pid %d sent us NULL settings key", buf, 0x12u);
  }
  uint64_t v11 = 22;
LABEL_34:

  return v11;
}

uint64_t handleCheckMobileAsset()
{
  v34[3] = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v1 = (id)gLogObj;
  if (os_log_type_enabled(v1, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
    _os_log_impl(&dword_1830D4000, v1, OS_LOG_TYPE_DEBUG, "%{public}s starting mobile asset check", buf, 0xCu);
  }

  gotLoadHelper_x26__OBJC_CLASS___MAAsset(v2);
  if (objc_opt_class())
  {
    id v3 = [MEMORY[0x1E4F1CA60] dictionaryWithContentsOfFile:@"/Library/Preferences/com.apple.networkd.networknomicon.plist"];
    if (!v3) {
      id v3 = objc_alloc_init(MEMORY[0x1E4F1CA60]);
    }
    uint64_t v4 = (void *)MEMORY[0x1E4F1C9C8];
    uint64_t v5 = v3;
    int v6 = [v4 date];
    int v7 = [v5 objectForKeyedSubscript:@"LastAttempt"];
    int v8 = [v5 objectForKeyedSubscript:@"LastSuccess"];
    id v9 = [v5 objectForKeyedSubscript:@"PollFrequencySeconds"];

    if (v9 && (objc_opt_class(), (objc_opt_isKindOfClass() & 1) != 0))
    {
      uint64_t v10 = [v9 longLongValue];
      double v11 = 86400.0;
      if ((unint64_t)(v10 - 3600) < 0x277EF1) {
        double v11 = (double)v10;
      }
    }
    else
    {
      double v11 = 86400.0;
    }
    char v12 = nwphShouldRunCheck(v6, v7, v8, 1, 3600.0, v11);

    if ((v12 & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s skipping Mobile Asset attempt", buf, 0xCu);
      }
      goto LABEL_37;
    }
    id v13 = [MEMORY[0x1E4F1C9C8] date];
    [v5 setObject:v13 forKeyedSubscript:@"LastAttempt"];

    if ([v5 writeToFile:@"/Library/Preferences/com.apple.networkd.networknomicon.plist" atomically:1])
    {
LABEL_34:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v25 = (id)gLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEFAULT, "%{public}s starting mobile asset catalog download", buf, 0xCu);
      }

      os_log_type_t v26 = *(void **)(v0 + 4008);
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = __nwphCheckMobileAsset_block_invoke;
      os_log_type_t v33 = (__CFString *)&unk_1E523D6D8;
      v34[0] = v5;
      [v26 startCatalogDownload:@"com.apple.MobileAsset.network.networknomicon" then:buf];
      id v19 = v34[0];
LABEL_37:

      goto LABEL_38;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
    *(_WORD *)&buf[12] = 2114;
    *(void *)&buf[14] = v5;
    *(_WORD *)&buf[22] = 2114;
    os_log_type_t v33 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
    os_log_type_t v15 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault((const char *)v15, &type, &v30))
    {
LABEL_32:
      if (v15) {
        free(v15);
      }
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v16 = (id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&buf[22] = 2114;
        os_log_type_t v33 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
        char v18 = "%{public}s Failed to save mobile asset networknomicon attempt %{public}@ to \"%{public}@\"";
LABEL_29:
        BOOL v23 = v16;
        os_log_type_t v24 = v17;
LABEL_30:
        _os_log_impl(&dword_1830D4000, v23, v24, v18, buf, 0x20u);
      }
    }
    else
    {
      if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (id)gLogObj;
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
            *(_WORD *)&buf[12] = 2114;
            *(void *)&buf[14] = v5;
            *(_WORD *)&buf[22] = 2114;
            os_log_type_t v33 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
            LOWORD(v34[0]) = 2082;
            *(void *)((char *)v34 + 2) = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s Failed to save mobile asset networknomicon attempt %{public}@ to \"%{public}@\", dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (!v22) {
          goto LABEL_31;
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&buf[22] = 2114;
        os_log_type_t v33 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
        char v18 = "%{public}s Failed to save mobile asset networknomicon attempt %{public}@ to \"%{public}@\", no backtrace";
        BOOL v23 = v16;
        os_log_type_t v24 = v21;
        goto LABEL_30;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v16 = (id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
        *(_WORD *)&buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&buf[22] = 2114;
        os_log_type_t v33 = @"/Library/Preferences/com.apple.networkd.networknomicon.plist";
        char v18 = "%{public}s Failed to save mobile asset networknomicon attempt %{public}@ to \"%{public}@\", backtrace limit exceeded";
        goto LABEL_29;
      }
    }
LABEL_31:

    goto LABEL_32;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nwphCheckMobileAsset";
    _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Mobile Asset not available", buf, 0xCu);
  }
LABEL_38:

  id v27 = +[ManagedNetworkSettings sharedMNS];
  BOOL v28 = [v27 queue];
  dispatch_async(v28, &__block_literal_global_511);

  return 0;
}

uint64_t handleReloadManagedNetworkSettings()
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v0 = (id)gLogObj;
  if (os_log_type_enabled(v0, OS_LOG_TYPE_DEFAULT))
  {
    int v4 = 136446210;
    uint64_t v5 = "handleReloadManagedNetworkSettings";
    _os_log_impl(&dword_1830D4000, v0, OS_LOG_TYPE_DEFAULT, "%{public}s Reloading managed network settings", (uint8_t *)&v4, 0xCu);
  }

  id v1 = +[ManagedNetworkSettings sharedMNS];
  [v1 reloadNetworkdSettings];

  id v2 = +[ManagedNetworkSettings sharedMNS];
  [v2 reloadMNS];

  return 0;
}

uint64_t handleSetPersistentNetworkAgentOnInterface(void *a1)
{
  return internalHandleSetNetworkAgentOnInterface(a1, 1);
}

uint64_t internalHandleSetNetworkAgentOnInterface(void *a1, int a2)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  int v4 = [v3 request];
  uuid = xpc_dictionary_get_uuid(v4, (const char *)networkd_privileged_key_agent_uuid);

  if (!uuid)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v17 = (id)gLogObj;
    *(_DWORD *)length = 136446466;
    *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
    __int16 v48 = 1024;
    int v49 = [v3 pid];
    LODWORD(v45) = 18;
    char v18 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v18, uu, &v46)) {
      goto LABEL_51;
    }
    if (uu[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      unsigned __int8 v20 = uu[0];
      if (!os_log_type_enabled(v19, uu[0])) {
        goto LABEL_42;
      }
      int v21 = objc_msgSend(v3, "pid", length, v45);
      *(_DWORD *)length = 136446466;
      *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
      __int16 v48 = 1024;
      int v49 = v21;
      BOOL v22 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d";
    }
    else
    {
      if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        os_log_type_t v28 = uu[0];
        BOOL v29 = os_log_type_enabled(v19, uu[0]);
        if (backtrace_string)
        {
          if (v29)
          {
            int v30 = objc_msgSend(v3, "pid", length, v45);
            *(_DWORD *)length = 136446722;
            *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
            __int16 v48 = 1024;
            int v49 = v30;
            __int16 v50 = 2082;
            os_log_type_t v51 = backtrace_string;
            BOOL v31 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d, dumping backtrace:%{public}s";
LABEL_29:
            _os_log_impl(&dword_1830D4000, v19, v28, v31, length, 0x1Cu);
          }
LABEL_30:

          free(backtrace_string);
          goto LABEL_51;
        }
        if (!v29)
        {
LABEL_42:

          if (!v18) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }
        int v38 = objc_msgSend(v3, "pid", length, v45);
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        __int16 v48 = 1024;
        int v49 = v38;
        BOOL v22 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d, no backtrace";
        BOOL v36 = v19;
        os_log_type_t v37 = v28;
LABEL_41:
        _os_log_impl(&dword_1830D4000, v36, v37, v22, length, 0x12u);
        goto LABEL_42;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      unsigned __int8 v20 = uu[0];
      if (!os_log_type_enabled(v19, uu[0])) {
        goto LABEL_42;
      }
      int v35 = objc_msgSend(v3, "pid", length, v45);
      *(_DWORD *)length = 136446466;
      *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
      __int16 v48 = 1024;
      int v49 = v35;
      BOOL v22 = "%{public}s Unable to extract agent UUID bytes from agent request from pid %d, backtrace limit exceeded";
    }
    BOOL v36 = v19;
    os_log_type_t v37 = v20;
    goto LABEL_41;
  }
  uint64_t v6 = [v3 request];
  string = xpc_dictionary_get_string(v6, (const char *)networkd_privileged_key_interface_name);

  if (!string)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)length = 136446466;
    *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
    __int16 v48 = 1024;
    int v49 = [v3 pid];
    LODWORD(v45) = 18;
    char v18 = (char *)_os_log_send_and_compose_impl();

    uu[0] = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v18, uu, &v46)) {
      goto LABEL_51;
    }
    if (uu[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      unsigned __int8 v24 = uu[0];
      if (os_log_type_enabled(v19, uu[0]))
      {
        int v25 = objc_msgSend(v3, "pid", length, v45);
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        __int16 v48 = 1024;
        int v49 = v25;
        os_log_type_t v26 = "%{public}s Unable to extract interface name from agent request from pid %d";
LABEL_48:
        long long v40 = v19;
        os_log_type_t v41 = v24;
LABEL_49:
        _os_log_impl(&dword_1830D4000, v40, v41, v26, length, 0x12u);
        goto LABEL_50;
      }
      goto LABEL_50;
    }
    if (!v46)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v19 = (id)gLogObj;
      unsigned __int8 v24 = uu[0];
      if (os_log_type_enabled(v19, uu[0]))
      {
        int v39 = objc_msgSend(v3, "pid", length, v45);
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        __int16 v48 = 1024;
        int v49 = v39;
        os_log_type_t v26 = "%{public}s Unable to extract interface name from agent request from pid %d, backtrace limit exceeded";
        goto LABEL_48;
      }
LABEL_50:

LABEL_51:
      if (!v18)
      {
LABEL_53:
        uint64_t v16 = 22;
        goto LABEL_61;
      }
LABEL_52:
      free(v18);
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    os_log_type_t v28 = uu[0];
    BOOL v32 = os_log_type_enabled(v19, uu[0]);
    if (!backtrace_string)
    {
      if (!v32) {
        goto LABEL_50;
      }
      int v42 = objc_msgSend(v3, "pid", length, v45);
      *(_DWORD *)length = 136446466;
      *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
      __int16 v48 = 1024;
      int v49 = v42;
      os_log_type_t v26 = "%{public}s Unable to extract interface name from agent request from pid %d, no backtrace";
      long long v40 = v19;
      os_log_type_t v41 = v28;
      goto LABEL_49;
    }
    if (v32)
    {
      int v33 = objc_msgSend(v3, "pid", length, v45);
      *(_DWORD *)length = 136446722;
      *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
      __int16 v48 = 1024;
      int v49 = v33;
      __int16 v50 = 2082;
      os_log_type_t v51 = backtrace_string;
      BOOL v31 = "%{public}s Unable to extract interface name from agent request from pid %d, dumping backtrace:%{public}s";
      goto LABEL_29;
    }
    goto LABEL_30;
  }
  int v8 = [v3 request];
  BOOL v9 = xpc_dictionary_get_BOOL(v8, (const char *)networkd_privileged_key_remove);

  *(_OWORD *)uu = *(_OWORD *)uuid;
  if (a2)
  {
    BOOL v10 = nw_network_agent_copy_dictionary_for_uuid((const unsigned __int8 *)uu);
    double v11 = (void *)v10;
    if (!v10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v14 = (id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        __int16 v48 = 1024;
        int v49 = [v3 pid];
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s Failed to find agent for request from pid %d", length, 0x12u);
      }
      uint64_t v16 = 2;
      goto LABEL_37;
    }
    *(void *)length = 0;
    data = (const char *)xpc_dictionary_get_data((xpc_object_t)v10, "data", (size_t *)length);
    if (!data || *(void *)length < 0xD8uLL || (id v13 = data, *(void *)length != *((unsigned int *)data + 53) + 216))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v14 = (id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v34 = [v3 pid];
        *(_DWORD *)length = 136446466;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        __int16 v48 = 1024;
        int v49 = v34;
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s Failed to parse agent for request from pid %d", length, 0x12u);
      }
      uint64_t v16 = -1006;
      goto LABEL_37;
    }
    if (strncmp(data + 16, "Persistent", 0x20uLL) || strncmp(v13 + 48, "Persistent", 0x20uLL))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v14 = (id)gLogObj;
      if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
      {
        int v15 = [v3 pid];
        *(_DWORD *)length = 136447234;
        *(void *)&length[4] = "internalHandleSetNetworkAgentOnInterface";
        __int16 v48 = 1024;
        int v49 = v15;
        __int16 v50 = 2082;
        os_log_type_t v51 = (void *)string;
        __int16 v52 = 2082;
        v53 = v13 + 16;
        __int16 v54 = 2082;
        os_log_type_t v55 = v13 + 48;
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s Client pid %d not allowed to modify agent on %{public}s (domain:%{public}s, type:%{public}s)", length, 0x30u);
      }
      uint64_t v16 = 1;
LABEL_37:

      goto LABEL_61;
    }
  }
  if (v9) {
    int v43 = nw_network_agent_remove_from_interface((uint64_t)string, (unsigned __int8 *)uu);
  }
  else {
    int v43 = nw_network_agent_add_to_interface((uint64_t)string, (unsigned __int8 *)uu);
  }
  uint64_t v16 = v43;
LABEL_61:

  return v16;
}

uint64_t handleSetNetworkAgentOnInterface(void *a1)
{
  return internalHandleSetNetworkAgentOnInterface(a1, 0);
}

uint64_t handleCreateNetworkAdvisoryKernelSocket(void *a1)
{
  return internalHandleCreateKernelSocket(a1, (uint64_t)"com.apple.network.advisory");
}

uint64_t internalHandleCreateKernelSocket(void *a1, uint64_t a2)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  int v4 = socket(32, 2, 2);
  if ((v4 & 0x80000000) == 0)
  {
    int v5 = v4;
    int v80 = 0;
    long long v78 = 0u;
    long long v79 = 0u;
    long long v77 = 0u;
    memset(buf, 0, sizeof(buf));
    __strlcpy_chk();
    if (ioctl(v5, 0xC0644E03uLL, buf) != -1)
    {
      *(void *)&v66[12] = 0;
      uint64_t v67 = 0;
      int v68 = 0;
      *(_DWORD *)v66 = 139296;
      *(_DWORD *)&v66[4] = *(_DWORD *)buf;
      *(_DWORD *)&v66[8] = 0;
      if (connect(v5, (const sockaddr *)v66, 0x20u))
      {
        int v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v7 = (id)gLogObj;
        *(_DWORD *)v70 = 136447234;
        uint64_t v71 = "createKernelSocket";
        __int16 v72 = 1024;
        *(_DWORD *)v73 = *(_DWORD *)buf;
        *(_WORD *)&v73[4] = 2082;
        *(void *)&v73[6] = &buf[4];
        *(_WORD *)&v73[14] = 1024;
        *(_DWORD *)&v73[16] = v5;
        __int16 v74 = 1024;
        LODWORD(v75[0]) = v6;
        int v8 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v65 = 0;
        if (!__nwlog_fault(v8, &type, &v65)) {
          goto LABEL_64;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v9 = (id)gLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = *(_DWORD *)buf;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = &buf[4];
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v5;
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v6;
            double v11 = "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d";
LABEL_61:
            uint64_t v45 = v9;
            os_log_type_t v46 = v10;
            uint32_t v47 = 40;
            goto LABEL_62;
          }
        }
        else
        {
          if (v65)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v9 = (id)gLogObj;
            os_log_type_t v10 = type;
            BOOL v34 = os_log_type_enabled(v9, type);
            if (backtrace_string)
            {
              if (v34)
              {
                *(_DWORD *)v70 = 136447490;
                uint64_t v71 = "createKernelSocket";
                __int16 v72 = 1024;
                *(_DWORD *)v73 = *(_DWORD *)buf;
                *(_WORD *)&v73[4] = 2082;
                *(void *)&v73[6] = &buf[4];
                *(_WORD *)&v73[14] = 1024;
                *(_DWORD *)&v73[16] = v5;
                __int16 v74 = 1024;
                LODWORD(v75[0]) = v6;
                WORD2(v75[0]) = 2082;
                *(void *)((char *)v75 + 6) = backtrace_string;
                _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)v70, 0x32u);
              }

              free(backtrace_string);
              if (!v8) {
                goto LABEL_66;
              }
              goto LABEL_65;
            }
            if (!v34) {
              goto LABEL_63;
            }
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = *(_DWORD *)buf;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = &buf[4];
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v5;
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v6;
            double v11 = "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d, no backtrace";
            goto LABEL_61;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v9 = (id)gLogObj;
          os_log_type_t v10 = type;
          if (os_log_type_enabled(v9, type))
          {
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = *(_DWORD *)buf;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = &buf[4];
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v5;
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v6;
            double v11 = "%{public}s unable to connect to id %u for socket control name %{public}s on fd %d %{darwin.errno}d, ba"
                  "cktrace limit exceeded";
            goto LABEL_61;
          }
        }
LABEL_63:

        goto LABEL_64;
      }
      int v25 = fcntl(v5, 3, 0);
      if (v25 != -1)
      {
        int v26 = v25;
        if (fcntl(v5, 4, v25 | 4u) != -1) {
          goto LABEL_89;
        }
        int v27 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v28 = (id)gLogObj;
        *(_DWORD *)v70 = 136447234;
        uint64_t v71 = "createKernelSocket";
        __int16 v72 = 1024;
        *(_DWORD *)v73 = v5;
        *(_WORD *)&v73[4] = 1024;
        *(_DWORD *)&v73[6] = v26;
        *(_WORD *)&v73[10] = 2082;
        *(void *)&v73[12] = &buf[4];
        __int16 v74 = 1024;
        LODWORD(v75[0]) = v27;
        BOOL v29 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v65 = 0;
        if (__nwlog_fault((const char *)v29, &type, &v65))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_118;
            }
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v27;
            BOOL v32 = "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errno}d";
            goto LABEL_117;
          }
          if (!v65)
          {
            int v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            if (!os_log_type_enabled(v30, type)) {
              goto LABEL_118;
            }
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v27;
            BOOL v32 = "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errn"
                  "o}d, backtrace limit exceeded";
            goto LABEL_117;
          }
          int v64 = v27;
          __int16 v50 = (char *)__nw_create_backtrace_string();
          int v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          BOOL v51 = os_log_type_enabled(v30, type);
          if (!v50)
          {
            if (!v51) {
              goto LABEL_118;
            }
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v64;
            BOOL v32 = "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errn"
                  "o}d, no backtrace";
LABEL_117:
            _os_log_impl(&dword_1830D4000, v30, v31, v32, (uint8_t *)v70, 0x28u);
LABEL_118:

            if (!v29) {
              goto LABEL_89;
            }
LABEL_88:
            free(v29);
            goto LABEL_89;
          }
          if (v51)
          {
            *(_DWORD *)v70 = 136447490;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 1024;
            *(_DWORD *)v73 = v5;
            *(_WORD *)&v73[4] = 1024;
            *(_DWORD *)&v73[6] = v26;
            *(_WORD *)&v73[10] = 2082;
            *(void *)&v73[12] = &buf[4];
            __int16 v74 = 1024;
            LODWORD(v75[0]) = v64;
            WORD2(v75[0]) = 2082;
            *(void *)((char *)v75 + 6) = v50;
            _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s fcntl(%d, F_SETFL, %d | O_NONBLOCK) failed for socket control name %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)v70, 0x32u);
          }

          free(v50);
          if (v29) {
            goto LABEL_88;
          }
LABEL_89:
          xpc_object_t v52 = xpc_fd_create(v5);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v53 = (id)gLogObj;
          __int16 v54 = v53;
          if (v52)
          {
            if (os_log_type_enabled(v53, OS_LOG_TYPE_DEFAULT))
            {
              int v55 = [v3 pid];
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v55;
              _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully created kernel socket %d with name \"%{public}s\" for pid %d", buf, 0x22u);
            }

            v56 = [v3 reply];
            xpc_dictionary_set_value(v56, (const char *)networkd_privileged_key_kernel_socket_fd, v52);

            uint64_t v24 = 0;
LABEL_113:
            close(v5);

            goto LABEL_114;
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v5;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = a2;
          uint64_t v57 = (void *)_os_log_send_and_compose_impl();

          v70[0] = OS_LOG_TYPE_ERROR;
          v66[0] = 0;
          if (!__nwlog_fault((const char *)v57, v70, v66))
          {
LABEL_110:
            if (v57) {
              free(v57);
            }
            uint64_t v24 = -1005;
            goto LABEL_113;
          }
          if (v70[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v58 = (id)gLogObj;
            os_log_type_t v59 = v70[0];
            if (os_log_type_enabled(v58, v70[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              BOOL v60 = "%{public}s xpc_fd_create(%d) name \"%{public}s\" failed";
LABEL_108:
              _os_log_impl(&dword_1830D4000, v58, v59, v60, buf, 0x1Cu);
            }
          }
          else
          {
            if (v66[0])
            {
              v61 = (char *)__nw_create_backtrace_string();
              BOOL v58 = __nwlog_obj();
              os_log_type_t v59 = v70[0];
              BOOL v62 = os_log_type_enabled(v58, v70[0]);
              if (v61)
              {
                if (v62)
                {
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v5;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = a2;
                  *(_WORD *)&buf[28] = 2082;
                  *(void *)&buf[30] = v61;
                  _os_log_impl(&dword_1830D4000, v58, v59, "%{public}s xpc_fd_create(%d) name \"%{public}s\" failed, dumping backtrace:%{public}s", buf, 0x26u);
                }

                free(v61);
                goto LABEL_110;
              }
              if (!v62) {
                goto LABEL_109;
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              BOOL v60 = "%{public}s xpc_fd_create(%d) name \"%{public}s\" failed, no backtrace";
              goto LABEL_108;
            }
            BOOL v58 = __nwlog_obj();
            os_log_type_t v59 = v70[0];
            if (os_log_type_enabled(v58, v70[0]))
            {
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "internalHandleCreateKernelSocket";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v5;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = a2;
              BOOL v60 = "%{public}s xpc_fd_create(%d) name \"%{public}s\" failed, backtrace limit exceeded";
              goto LABEL_108;
            }
          }
LABEL_109:

          goto LABEL_110;
        }
LABEL_87:
        if (!v29) {
          goto LABEL_89;
        }
        goto LABEL_88;
      }
      int v40 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v41 = (id)gLogObj;
      *(_DWORD *)v70 = 136446978;
      uint64_t v71 = "createKernelSocket";
      __int16 v72 = 2082;
      *(void *)v73 = &buf[4];
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v5;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v40;
      BOOL v29 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v65 = 0;
      if (!__nwlog_fault((const char *)v29, &type, &v65)) {
        goto LABEL_87;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v42 = (id)gLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)v70 = 136446978;
          uint64_t v71 = "createKernelSocket";
          __int16 v72 = 2082;
          *(void *)v73 = &buf[4];
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v5;
          *(_WORD *)&v73[14] = 1024;
          *(_DWORD *)&v73[16] = v40;
          long long v44 = "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d";
LABEL_85:
          _os_log_impl(&dword_1830D4000, v42, v43, v44, (uint8_t *)v70, 0x22u);
        }
      }
      else
      {
        if (v65)
        {
          __int16 v48 = (char *)__nw_create_backtrace_string();
          int v42 = __nwlog_obj();
          os_log_type_t v43 = type;
          BOOL v49 = os_log_type_enabled(v42, type);
          if (v48)
          {
            if (v49)
            {
              *(_DWORD *)v70 = 136447234;
              uint64_t v71 = "createKernelSocket";
              __int16 v72 = 2082;
              *(void *)v73 = &buf[4];
              *(_WORD *)&v73[8] = 1024;
              *(_DWORD *)&v73[10] = v5;
              *(_WORD *)&v73[14] = 1024;
              *(_DWORD *)&v73[16] = v40;
              __int16 v74 = 2082;
              v75[0] = v48;
              _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)v70, 0x2Cu);
            }

            free(v48);
            if (v29) {
              goto LABEL_88;
            }
            goto LABEL_89;
          }
          if (!v49) {
            goto LABEL_86;
          }
          *(_DWORD *)v70 = 136446978;
          uint64_t v71 = "createKernelSocket";
          __int16 v72 = 2082;
          *(void *)v73 = &buf[4];
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v5;
          *(_WORD *)&v73[14] = 1024;
          *(_DWORD *)&v73[16] = v40;
          long long v44 = "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d, no backtrace";
          goto LABEL_85;
        }
        int v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)v70 = 136446978;
          uint64_t v71 = "createKernelSocket";
          __int16 v72 = 2082;
          *(void *)v73 = &buf[4];
          *(_WORD *)&v73[8] = 1024;
          *(_DWORD *)&v73[10] = v5;
          *(_WORD *)&v73[14] = 1024;
          *(_DWORD *)&v73[16] = v40;
          long long v44 = "%{public}s get flags failed for socket control name %{public}s on fd %d %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_85;
        }
      }
LABEL_86:

      goto LABEL_87;
    }
    int v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    *(_DWORD *)v70 = 136446978;
    uint64_t v71 = "createKernelSocket";
    __int16 v72 = 2082;
    *(void *)v73 = &buf[4];
    *(_WORD *)&v73[8] = 1024;
    *(_DWORD *)&v73[10] = v5;
    *(_WORD *)&v73[14] = 1024;
    *(_DWORD *)&v73[16] = v18;
    int v8 = (char *)_os_log_send_and_compose_impl();

    v66[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, v66, &type)) {
      goto LABEL_64;
    }
    if (v66[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (id)gLogObj;
      os_log_type_t v20 = v66[0];
      if (!os_log_type_enabled(v9, (os_log_type_t)v66[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)v70 = 136446978;
      uint64_t v71 = "createKernelSocket";
      __int16 v72 = 2082;
      *(void *)v73 = &buf[4];
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v5;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v18;
      double v11 = "%{public}s unable to look up socket control name %{public}s on fd %d %{darwin.errno}d";
    }
    else
    {
      if (type)
      {
        int v35 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (id)gLogObj;
        os_log_type_t v36 = v66[0];
        BOOL v37 = os_log_type_enabled(v9, (os_log_type_t)v66[0]);
        if (v35)
        {
          if (v37)
          {
            *(_DWORD *)v70 = 136447234;
            uint64_t v71 = "createKernelSocket";
            __int16 v72 = 2082;
            *(void *)v73 = &buf[4];
            *(_WORD *)&v73[8] = 1024;
            *(_DWORD *)&v73[10] = v5;
            *(_WORD *)&v73[14] = 1024;
            *(_DWORD *)&v73[16] = v18;
            __int16 v74 = 2082;
            v75[0] = v35;
            _os_log_impl(&dword_1830D4000, v9, v36, "%{public}s unable to look up socket control name %{public}s on fd %d %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)v70, 0x2Cu);
          }

          free(v35);
LABEL_64:
          if (!v8)
          {
LABEL_66:
            close(v5);
            uint64_t v24 = -1004;
            goto LABEL_114;
          }
LABEL_65:
          free(v8);
          goto LABEL_66;
        }
        if (!v37) {
          goto LABEL_63;
        }
        *(_DWORD *)v70 = 136446978;
        uint64_t v71 = "createKernelSocket";
        __int16 v72 = 2082;
        *(void *)v73 = &buf[4];
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v5;
        *(_WORD *)&v73[14] = 1024;
        *(_DWORD *)&v73[16] = v18;
        double v11 = "%{public}s unable to look up socket control name %{public}s on fd %d %{darwin.errno}d, no backtrace";
        uint64_t v45 = v9;
        os_log_type_t v46 = v36;
LABEL_58:
        uint32_t v47 = 34;
LABEL_62:
        _os_log_impl(&dword_1830D4000, v45, v46, v11, (uint8_t *)v70, v47);
        goto LABEL_63;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (id)gLogObj;
      os_log_type_t v20 = v66[0];
      if (!os_log_type_enabled(v9, (os_log_type_t)v66[0])) {
        goto LABEL_63;
      }
      *(_DWORD *)v70 = 136446978;
      uint64_t v71 = "createKernelSocket";
      __int16 v72 = 2082;
      *(void *)v73 = &buf[4];
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v5;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v18;
      double v11 = "%{public}s unable to look up socket control name %{public}s on fd %d %{darwin.errno}d, backtrace limit exceeded";
    }
    uint64_t v45 = v9;
    os_log_type_t v46 = v20;
    goto LABEL_58;
  }
  int v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v13 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  *(void *)&uint8_t buf[4] = "createKernelSocket";
  *(_WORD *)&buf[12] = 1024;
  *(_DWORD *)&buf[14] = v12;
  id v14 = (char *)_os_log_send_and_compose_impl();

  v70[0] = OS_LOG_TYPE_ERROR;
  v66[0] = 0;
  if (__nwlog_fault(v14, v70, v66))
  {
    if (v70[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v16 = v70[0];
      if (!os_log_type_enabled(v15, v70[0])) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      id v17 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d";
LABEL_43:
      int v38 = v15;
      os_log_type_t v39 = v16;
      goto LABEL_44;
    }
    if (!v66[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v16 = v70[0];
      if (!os_log_type_enabled(v15, v70[0])) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      id v17 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_43;
    }
    int v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v15 = (id)gLogObj;
    os_log_type_t v22 = v70[0];
    BOOL v23 = os_log_type_enabled(v15, v70[0]);
    if (!v21)
    {
      if (!v23)
      {
LABEL_45:

        if (!v14) {
          goto LABEL_23;
        }
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      id v17 = "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, no backtrace";
      int v38 = v15;
      os_log_type_t v39 = v22;
LABEL_44:
      _os_log_impl(&dword_1830D4000, v38, v39, v17, buf, 0x12u);
      goto LABEL_45;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "createKernelSocket";
      *(_WORD *)&buf[12] = 1024;
      *(_DWORD *)&buf[14] = v12;
      *(_WORD *)&buf[18] = 2082;
      *(void *)&buf[20] = v21;
      _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s socket(PF_SYSTEM, SOCK_DGRAM, SYSPROTO_CONTROL) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

    free(v21);
  }
  if (v14) {
LABEL_22:
  }
    free(v14);
LABEL_23:
  uint64_t v24 = -1004;
LABEL_114:

  return v24;
}

uint64_t handleCreateNetworkAgentKernelSocket(void *a1)
{
  return internalHandleCreateKernelSocket(a1, (uint64_t)"com.apple.net.netagent");
}

uint64_t handleOpportunistic(void *a1)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = [v1 request];
  string = xpc_dictionary_get_string(v2, (const char *)networkd_privileged_key_opportunistic_ifname);

  if (!string)
  {
    uint64_t v8 = 0;
    uint64_t v11 = 22;
    goto LABEL_52;
  }
  int v4 = socket(2, 2, 0);
  if ((v4 & 0x80000000) == 0)
  {
    int v5 = v4;
    int v6 = [v1 request];
    BOOL v7 = xpc_dictionary_get_BOOL(v6, (const char *)networkd_privileged_key_opportunistic_disable);

    *(_OWORD *)os_log_type_t type = 0u;
    long long v49 = 0u;
    __strlcpy_chk();
    LODWORD(v49) = v7;
    if (ioctl(v5, 0xC020698BuLL, type) != -1)
    {
      uint64_t v8 = DWORD1(v49);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v9 = (id)gLogObj;
      if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
      {
        if (v7) {
          os_log_type_t v10 = "";
        }
        else {
          os_log_type_t v10 = "un";
        }
        *(_DWORD *)buf = 136447234;
        int v42 = "handleOpportunistic";
        __int16 v43 = 2082;
        *(void *)long long v44 = v10;
        *(_WORD *)&v44[8] = 2082;
        *(void *)&v44[10] = string;
        *(_WORD *)&v44[18] = 1024;
        int v45 = [v1 pid];
        __int16 v46 = 2048;
        uint64_t v47 = v8;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully %{public}sblocked opportunistic for \"%{public}s\" from %d count=%llu", buf, 0x30u);
      }

      uint64_t v11 = 0;
LABEL_51:
      close(v5);
      goto LABEL_52;
    }
    int v18 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    os_log_type_t v20 = v19;
    if (v18 == 6)
    {
      if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v5;
        *(_WORD *)&v44[4] = 1024;
        *(_DWORD *)&v44[6] = 6;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCSIFOPPORTUNISTIC, ...) failed %{darwin.errno}d", buf, 0x18u);
      }

      uint64_t v8 = 0;
      uint64_t v11 = 6;
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446722;
    int v42 = "handleOpportunistic";
    __int16 v43 = 1024;
    *(_DWORD *)long long v44 = v5;
    *(_WORD *)&v44[4] = 1024;
    *(_DWORD *)&v44[6] = v18;
    LODWORD(v38) = 24;
    BOOL v37 = buf;
    uint64_t v24 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault((const char *)v24, &v40, &v39))
    {
LABEL_48:
      uint64_t v11 = v18;
      if (v24) {
        free(v24);
      }
      uint64_t v8 = 0;
      goto LABEL_51;
    }
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v25 = (id)gLogObj;
      os_log_type_t v26 = v40;
      if (os_log_type_enabled(v25, v40))
      {
        *(_DWORD *)buf = 136446722;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v5;
        *(_WORD *)&v44[4] = 1024;
        *(_DWORD *)&v44[6] = v18;
        int v27 = "%{public}s ioctl(%d, SIOCSIFOPPORTUNISTIC, ...) failed %{darwin.errno}d";
LABEL_45:
        int v33 = v25;
        os_log_type_t v34 = v26;
LABEL_46:
        _os_log_impl(&dword_1830D4000, v33, v34, v27, buf, 0x18u);
      }
    }
    else
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v25 = (id)gLogObj;
        os_log_type_t v31 = v40;
        BOOL v32 = os_log_type_enabled(v25, v40);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446978;
            int v42 = "handleOpportunistic";
            __int16 v43 = 1024;
            *(_DWORD *)long long v44 = v5;
            *(_WORD *)&v44[4] = 1024;
            *(_DWORD *)&v44[6] = v18;
            *(_WORD *)&v44[10] = 2082;
            *(void *)&v44[12] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v31, "%{public}s ioctl(%d, SIOCSIFOPPORTUNISTIC, ...) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (!v32) {
          goto LABEL_47;
        }
        *(_DWORD *)buf = 136446722;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v5;
        *(_WORD *)&v44[4] = 1024;
        *(_DWORD *)&v44[6] = v18;
        int v27 = "%{public}s ioctl(%d, SIOCSIFOPPORTUNISTIC, ...) failed %{darwin.errno}d, no backtrace";
        int v33 = v25;
        os_log_type_t v34 = v31;
        goto LABEL_46;
      }
      int v25 = __nwlog_obj();
      os_log_type_t v26 = v40;
      if (os_log_type_enabled(v25, v40))
      {
        *(_DWORD *)buf = 136446722;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v5;
        *(_WORD *)&v44[4] = 1024;
        *(_DWORD *)&v44[6] = v18;
        int v27 = "%{public}s ioctl(%d, SIOCSIFOPPORTUNISTIC, ...) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_45;
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  int v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v13 = (id)gLogObj;
  *(_DWORD *)buf = 136446466;
  int v42 = "handleOpportunistic";
  __int16 v43 = 1024;
  *(_DWORD *)long long v44 = v12;
  LODWORD(v38) = 18;
  BOOL v37 = buf;
  id v14 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v40 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v14, type, &v40))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v12;
        id v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
LABEL_30:
        id v28 = v15;
        os_log_type_t v29 = v16;
LABEL_31:
        _os_log_impl(&dword_1830D4000, v28, v29, v17, buf, 0x12u);
      }
    }
    else
    {
      if (v40)
      {
        int v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v15 = (id)gLogObj;
        os_log_type_t v22 = type[0];
        BOOL v23 = os_log_type_enabled(v15, type[0]);
        if (v21)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446722;
            int v42 = "handleOpportunistic";
            __int16 v43 = 1024;
            *(_DWORD *)long long v44 = v12;
            *(_WORD *)&v44[4] = 2082;
            *(void *)&v44[6] = v21;
            _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v21);
          goto LABEL_33;
        }
        if (!v23) {
          goto LABEL_32;
        }
        *(_DWORD *)buf = 136446466;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v12;
        id v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
        id v28 = v15;
        os_log_type_t v29 = v22;
        goto LABEL_31;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        int v42 = "handleOpportunistic";
        __int16 v43 = 1024;
        *(_DWORD *)long long v44 = v12;
        id v17 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_30;
      }
    }
LABEL_32:
  }
LABEL_33:
  uint64_t v11 = v12;
  if (v14) {
    free(v14);
  }
  uint64_t v8 = 0;
LABEL_52:
  int v35 = objc_msgSend(v1, "reply", v37, v38);
  xpc_dictionary_set_uint64(v35, (const char *)networkd_privileged_key_opportunistic_inuse, v8);

  return v11;
}

void NWPrivilegedHelperStart(void *a1)
{
  id v1 = a1;
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __NWPrivilegedHelperStart_block_invoke;
  block[3] = &unk_1E524BAA8;
  id v5 = v1;
  uint64_t v2 = NWPrivilegedHelperStart_onceToken;
  id v3 = v1;
  if (v2 != -1) {
    dispatch_once(&NWPrivilegedHelperStart_onceToken, block);
  }
}

void __NWPrivilegedHelperStart_block_invoke(uint64_t a1)
{
  id v1 = [[NWPrivilegedHelper alloc] initWithQueue:*(void *)(a1 + 32)];
  uint64_t v2 = (void *)NWPrivilegedHelperStart_sNWPrivilegedHelper;
  NWPrivilegedHelperStart_sNWPrivilegedHelper = (uint64_t)v1;
}

void NWPrivilegedHelperHandleEvent(void *a1, const char *a2)
{
  id v3 = a1;
  if (!strcmp(a2, "com.apple.fsevents.matching"))
  {
    id v4 = +[ManagedNetworkSettings sharedMNS];
    id v5 = [v4 queue];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __handleEventForManagedNetworkSettings_block_invoke;
    block[3] = &unk_1E524BAA8;
    id v7 = v3;
    dispatch_async(v5, block);
  }
}

void sub_183A02674(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183A02F60(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183A03A90(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

BOOL nw_remote_director_write_request(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  uint64_t v71 = a1;
  uint64_t v72 = a2;
  while (1)
  {
    int v6 = objc_msgSend(v5, "data", v69, v70);
    unint64_t v7 = [v6 length];

    uint64_t v8 = [v5 data];
    BOOL v9 = [v5 clientID];
    id v10 = v8;
    id v11 = v9;
    uint64_t v12 = [v10 length];
    uint64_t v13 = [v10 bytes];
    __int16 v74 = v11;
    if (!a1)
    {
      long long v49 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
      LODWORD(v70) = 12;
      uint64_t v69 = buf;
      uint64_t v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v75) = 0;
      if (__nwlog_fault(v50, type, &v75))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          BOOL v51 = __nwlog_obj();
          os_log_type_t v52 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
            v53 = v51;
            os_log_type_t v54 = v52;
            int v55 = "%{public}s called with null protocol";
LABEL_90:
            _os_log_impl(&dword_1830D4000, v53, v54, v55, buf, 0xCu);
          }
LABEL_91:

          goto LABEL_92;
        }
        if (!(_BYTE)v75)
        {
          BOOL v51 = __nwlog_obj();
          os_log_type_t v66 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
            v53 = v51;
            os_log_type_t v54 = v66;
            int v55 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_90;
          }
          goto LABEL_91;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v51 = __nwlog_obj();
        os_log_type_t v59 = type[0];
        BOOL v60 = os_log_type_enabled(v51, type[0]);
        if (!backtrace_string)
        {
          if (v60)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
            v53 = v51;
            os_log_type_t v54 = v59;
            int v55 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_90;
          }
          goto LABEL_91;
        }
        if (!v60) {
          goto LABEL_81;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v61 = v51;
        os_log_type_t v62 = v59;
        v63 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
        goto LABEL_80;
      }
LABEL_92:
      if (v50) {
        free(v50);
      }
      unsigned int v19 = 0;
      goto LABEL_61;
    }
    if (!a2)
    {
      v56 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
      LODWORD(v70) = 12;
      uint64_t v69 = buf;
      uint64_t v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v75) = 0;
      if (__nwlog_fault(v50, type, &v75))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          BOOL v51 = __nwlog_obj();
          os_log_type_t v57 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
            v53 = v51;
            os_log_type_t v54 = v57;
            int v55 = "%{public}s called with null output_handler";
            goto LABEL_90;
          }
          goto LABEL_91;
        }
        if (!(_BYTE)v75)
        {
          BOOL v51 = __nwlog_obj();
          os_log_type_t v67 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
            v53 = v51;
            os_log_type_t v54 = v67;
            int v55 = "%{public}s called with null output_handler, backtrace limit exceeded";
            goto LABEL_90;
          }
          goto LABEL_91;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v51 = __nwlog_obj();
        os_log_type_t v64 = type[0];
        BOOL v65 = os_log_type_enabled(v51, type[0]);
        if (!backtrace_string)
        {
          if (v65)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
            v53 = v51;
            os_log_type_t v54 = v64;
            int v55 = "%{public}s called with null output_handler, no backtrace";
            goto LABEL_90;
          }
          goto LABEL_91;
        }
        if (!v65) {
          goto LABEL_81;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        v61 = v51;
        os_log_type_t v62 = v64;
        v63 = "%{public}s called with null output_handler, dumping backtrace:%{public}s";
LABEL_80:
        _os_log_impl(&dword_1830D4000, v61, v62, v63, buf, 0x16u);
LABEL_81:

        free(backtrace_string);
        goto LABEL_92;
      }
      goto LABEL_92;
    }
    uint64_t v14 = v13;
    *(void *)os_log_type_t type = 0;
    uint64_t v78 = 0;
    int v15 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, os_log_type_t *))(*(void *)(a2 + 24)
                                                                                                  + 88))(a2, a1, 1, v12, 1, type);
    os_log_type_t v16 = *(void **)type;
    if (*(void *)type && v15)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = 0;
      unint64_t v73 = v7;
      if (v11)
      {
        id v17 = buf;
        [v11 getUUIDBytes:buf];
        os_log_type_t v16 = *(void **)type;
      }
      else
      {
        id v17 = 0;
      }
      uint64_t v75 = 0;
      char v76 = &v75;
      id v20 = v16;
      if (v20)
      {
        uint64_t v21 = (uint64_t)v20;
        unsigned int v19 = 0;
        if (!v17)
        {
          while (1)
          {
            os_log_type_t v34 = *(void **)(v21 + 32);
            if (!v34 && !*(void *)(v21 + 40)) {
              os_log_type_t v34 = 0;
            }
            id v35 = v34;
            uint64_t v36 = *(void *)(v21 + 112);
            if (v36)
            {
              if ((*(_WORD *)(v21 + 204) & 0x100) == 0
                || !g_channel_check_validity
                || g_channel_check_validity(v21, *(void *)(v21 + 88)))
              {
                LODWORD(v36) = *(_DWORD *)(v21 + 52);
                uint64_t v37 = *(unsigned int *)(v21 + 56);
                if (v36) {
                  LODWORD(v36) = v36 - (v37 + *(_DWORD *)(v21 + 60));
                }
                uint64_t v38 = (void *)(*(void *)(v21 + 112) + v37);
                goto LABEL_51;
              }
              LODWORD(v36) = 0;
            }
            uint64_t v38 = 0;
LABEL_51:
            if (v36 >= v12 - v19) {
              size_t v39 = v12 - v19;
            }
            else {
              size_t v39 = v36;
            }
            memcpy(v38, (const void *)(v14 + v19), v39);
            nw_frame_claim(v21, v40, v39, 0);
            nw_frame_collapse(v21);
            nw_frame_unclaim(v21, v41, v39, 0);
            uint64_t v42 = *(void *)(v21 + 32);
            __int16 v43 = *(void **)(v21 + 40);
            if (v42)
            {
              *(void *)(v42 + 40) = v43;
              __int16 v43 = *(void **)(v21 + 40);
            }
            else
            {
              uint64_t v78 = *(void *)(v21 + 40);
            }
            v19 += v39;
            void *v43 = v42;
            int v33 = v76;
            *(void *)(v21 + 32) = 0;
            *(void *)(v21 + 40) = v33;
            *int v33 = v21;
            char v76 = (uint64_t *)(v21 + 32);

            uint64_t v21 = (uint64_t)v35;
            if (!v35) {
              goto LABEL_57;
            }
          }
        }
        while (2)
        {
          BOOL v23 = *(void **)(v21 + 32);
          if (!v23 && !*(void *)(v21 + 40)) {
            BOOL v23 = 0;
          }
          id v24 = v23;
          if ((*(_WORD *)(v21 + 204) & 0x100) != 0 && g_channel_set_flow_handler) {
            g_channel_set_flow_handler(v21, v17);
          }
          uint64_t v25 = *(void *)(v21 + 112);
          if (v25)
          {
            if ((*(_WORD *)(v21 + 204) & 0x100) == 0
              || !g_channel_check_validity
              || g_channel_check_validity(v21, *(void *)(v21 + 88)))
            {
              LODWORD(v25) = *(_DWORD *)(v21 + 52);
              uint64_t v26 = *(unsigned int *)(v21 + 56);
              if (v25) {
                LODWORD(v25) = v25 - (v26 + *(_DWORD *)(v21 + 60));
              }
              int v27 = (void *)(*(void *)(v21 + 112) + v26);
LABEL_32:
              if (v25 >= v12 - v19) {
                size_t v28 = v12 - v19;
              }
              else {
                size_t v28 = v25;
              }
              memcpy(v27, (const void *)(v14 + v19), v28);
              nw_frame_claim(v21, v29, v28, 0);
              nw_frame_collapse(v21);
              nw_frame_unclaim(v21, v30, v28, 0);
              uint64_t v31 = *(void *)(v21 + 32);
              BOOL v32 = *(void **)(v21 + 40);
              if (v31)
              {
                *(void *)(v31 + 40) = v32;
                BOOL v32 = *(void **)(v21 + 40);
              }
              else
              {
                uint64_t v78 = *(void *)(v21 + 40);
              }
              v19 += v28;
              *BOOL v32 = v31;
              os_log_type_t v22 = v76;
              *(void *)(v21 + 32) = 0;
              *(void *)(v21 + 40) = v22;
              *os_log_type_t v22 = v21;
              char v76 = (uint64_t *)(v21 + 32);

              uint64_t v21 = (uint64_t)v24;
              if (!v24) {
                goto LABEL_57;
              }
              continue;
            }
            LODWORD(v25) = 0;
          }
          break;
        }
        int v27 = 0;
        goto LABEL_32;
      }
      unsigned int v19 = 0;
LABEL_57:
      a2 = v72;
      (*(void (**)(uint64_t, uint64_t *))(*(void *)(v72 + 24) + 96))(v72, &v75);
      uint64_t v44 = *(void *)type;
      if (*(void *)type)
      {
        do
        {
          if (!v44) {
            break;
          }
          uint64_t v45 = *(void *)(v44 + 32);
          char v46 = __nw_remote_director_write_one_block_invoke((uint64_t)&__block_literal_global_108, v44);
          uint64_t v44 = v45;
        }
        while ((v46 & 1) != 0);
      }
      a1 = v71;
      unint64_t v7 = v73;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v18 = (id)gLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_remote_director_write_one";
        *(_WORD *)&buf[12] = 1024;
        *(_DWORD *)&buf[14] = v12;
        *(_WORD *)&buf[18] = 2114;
        *(void *)&buf[20] = v11;
        _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s Failed to write %u bytes for %{public}@", buf, 0x1Cu);
      }

      unsigned int v19 = 0;
    }
LABEL_61:

    if (!v19 || v7 <= v19) {
      break;
    }
    uint64_t v47 = [v5 data];
    __int16 v48 = objc_msgSend(v47, "subdataWithRange:", v19, v7 - v19);
    [v5 setData:v48];
  }
  return v19 != 0;
}

uint64_t __nw_remote_director_write_one_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

void nw_remote_director_output_available(uint64_t a1, uint64_t a2)
{
  id obj = *(id *)(a1 + 40);
  objc_sync_enter(obj);
  while (1)
  {
    id v4 = [obj writeRequests];
    uint64_t v5 = [v4 count];

    if (!v5) {
      break;
    }
    int v6 = [obj writeRequests];
    unint64_t v7 = [v6 firstObject];

    if (!nw_remote_director_write_request(a1, a2, v7))
    {

      break;
    }
    uint64_t v8 = [obj writeRequests];
    [v8 removeObjectAtIndex:0];
  }
  objc_sync_exit(obj);
}

void sub_183A07B1C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

uint64_t nw_remote_director_input_available(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = a1;
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v36 = 0;
  uint64_t v37 = 0;
  uint64_t result = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t, uint64_t, id *))(*(void *)(a2 + 24) + 80))(a2, a1, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, &v36);
  if (result)
  {
    id v4 = (void *)&unk_1EB267000;
    uint64_t v30 = v2;
    do
    {
      id v35 = *(id *)(v2 + 40);
      unint64_t v32 = [v35 maximumDataChunkSize];
      int v33 = [MEMORY[0x1E4F1CA48] array];
      id v8 = v36;
      long long v39 = 0uLL;
      if (!v8)
      {
        uint64_t v5 = 0;
        goto LABEL_4;
      }
      uint64_t v9 = (uint64_t)v8;
      int v6 = 0;
      uint64_t v34 = 0;
      uint64_t v5 = 0;
      do
      {
        id v10 = *(void **)(v9 + 32);
        if (!v10 && !*(void *)(v9 + 40)) {
          id v10 = 0;
        }
        id v11 = v10;
        if (!*(void *)(v9 + 112)) {
          goto LABEL_43;
        }
        if ((*(_WORD *)(v9 + 204) & 0x100) != 0)
        {
          uint64_t v12 = (unsigned int (*)(uint64_t, void))v4[305];
          if (v12)
          {
            if (!v12(v9, *(void *)(v9 + 88))) {
              goto LABEL_43;
            }
          }
        }
        int v13 = *(_DWORD *)(v9 + 52);
        if (!v13) {
          goto LABEL_43;
        }
        uint64_t v14 = *(unsigned int *)(v9 + 56);
        int v15 = v14 + *(_DWORD *)(v9 + 60);
        uint64_t v16 = (v13 - v15);
        if (v13 == v15) {
          goto LABEL_43;
        }
        uint64_t v17 = *(void *)(v9 + 112);
        if (!v17) {
          goto LABEL_43;
        }
        uint64_t v18 = 0;
        long long v38 = 0uLL;
        if ((*(_WORD *)(v9 + 204) & 0x100) != 0)
        {
          uint64_t v19 = 0;
          if (g_channel_get_flow_handler)
          {
            g_channel_get_flow_handler(v9, &v38);
            uint64_t v18 = *((void *)&v38 + 1);
            uint64_t v19 = v38;
          }
        }
        else
        {
          uint64_t v19 = 0;
        }
        BOOL v20 = v19 == (void)v39 && v18 == *((void *)&v39 + 1);
        char v21 = v20;
        if (v20 && [v6 length] + (unint64_t)v16 <= v32) {
          goto LABEL_37;
        }
        if (v6 && v5)
        {
          os_log_type_t v22 = [v35 createSendDataMessageForClientID:v5 data:v6 receiveWindow:0];
          [v33 addObject:v22];

          int v6 = 0;
        }
        if (v21)
        {
LABEL_37:
          uint64_t v23 = v34;
        }
        else
        {
          long long v39 = v38;
          uint64_t v24 = [objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDBytes:&v39];

          uint64_t v23 = [v35 dataModeForFlowID:v24];
          uint64_t v5 = (void *)v24;
        }
        uint64_t v34 = v23;
        id v4 = &unk_1EB267000;
        if (v23 == 2)
        {
          if (!v6)
          {
            int v6 = [MEMORY[0x1E4F1CA58] data];
          }
          objc_msgSend(v6, "appendBytes:length:", v17 + v14, v16, v30);
LABEL_43:
          uint64_t v25 = *(void *)(v9 + 32);
          uint64_t v26 = *(void **)(v9 + 40);
          if (!v25) {
            goto LABEL_8;
          }
          goto LABEL_44;
        }
        int v27 = [MEMORY[0x1E4F1C9B8] dataWithBytes:v17 + v14 length:v16];
        size_t v28 = [v35 createSendDataMessageForClientID:v5 data:v27 receiveWindow:0];
        [v33 addObject:v28];

        uint64_t v25 = *(void *)(v9 + 32);
        uint64_t v26 = *(void **)(v9 + 40);
        if (!v25)
        {
LABEL_8:
          uint64_t v37 = v26;
          goto LABEL_9;
        }
LABEL_44:
        *(void *)(v25 + 40) = v26;
        uint64_t v26 = *(void **)(v9 + 40);
LABEL_9:
        void *v26 = v25;
        *(void *)(v9 + 32) = 0;
        *(void *)(v9 + 40) = 0;
        nw_frame_finalize(v9);

        uint64_t v9 = (uint64_t)v11;
      }
      while (v11);
      if (v6)
      {
        uint64_t v2 = v30;
        if (v5)
        {
          uint64_t v29 = [v35 createSendDataMessageForClientID:v5 data:v6 receiveWindow:0];
          [v33 addObject:v29];

LABEL_4:
          int v6 = 0;
        }
      }
      else
      {
        uint64_t v2 = v30;
      }
      unint64_t v7 = objc_msgSend(v35, "delegate", v30);
      [v7 sendRemoteCommands:v33];

      id v36 = 0;
      uint64_t v37 = 0;
      uint64_t result = (*(uint64_t (**)(void))(*(void *)(a2 + 24) + 80))();
    }
    while (result);
  }
  return result;
}

uint64_t areNSSetsEqual(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (![v3 count])
  {

    id v3 = 0;
  }
  if ([v4 count])
  {
    uint64_t v5 = v3 == v4;
    if (v3 != v4 && v4 && v3) {
      uint64_t v5 = [v3 isEqualToSet:v4];
    }
  }
  else
  {

    id v4 = 0;
    uint64_t v5 = v3 == 0;
  }

  return v5;
}

void sub_183A0964C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__44102(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__44103(uint64_t a1)
{
}

void sub_183A09880(void *a1)
{
  objc_begin_catch(a1);
  os_unfair_lock_unlock(v1);
  objc_exception_rethrow();
}

void sub_183A09894(_Unwind_Exception *a1)
{
}

void sub_183A09AB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0A250(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0A6E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0ABB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0AFA8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0B36C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0B734(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0BAB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0BF04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0C320(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0C744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0CC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0CF90(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0D2E0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0D66C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0DA98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A0DEE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void _systemPowerNotificationsCallback(uint64_t a1, uint64_t a2, int a3, intptr_t a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (__nwlog_url_log::onceToken != -1) {
      dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_68_44915);
    }
    unint64_t v7 = (id)gurlLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 67109120;
      *(_DWORD *)&uint8_t buf[4] = a3;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "Received power notification: %x", buf, 8u);
    }

    if (a3 == -536870272)
    {
      -[NWURLSession teardownAllConnections](a1);
      uint64_t v12 = 0;
      int v13 = &v12;
      uint64_t v14 = 0x2020000000;
      uint64_t v15 = 0;
      id v10 = *(id *)(a1 + 160);
      *(void *)buf = MEMORY[0x1E4F143A8];
      uint64_t v17 = 3221225472;
      uint64_t v18 = __62__NWURLSession_systemPowerChangedNotification_notificationID___block_invoke;
      uint64_t v19 = &unk_1E524BAF8;
      char v21 = &v12;
      intptr_t v22 = a4;
      uint64_t v20 = a1;
      BOOL source = nw_queue_context_create_source(v10, 2, 3, 0, buf, 0);
      v13[3] = source;

      nw_queue_set_timer_values(v13[3], 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3E8uLL);
      nw_queue_activate_source(v13[3]);
      _Block_object_dispose(&v12, 8);
    }
    else if (a3 == -536870288)
    {
      IOReturn v8 = IOAllowPowerChange(*(_DWORD *)(a1 + 36), a4);
      if (v8)
      {
        if (__nwlog_url_log::onceToken != -1) {
          dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_68_44915);
        }
        uint64_t v9 = (id)gurlLogObj;
        if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 67109120;
          *(_DWORD *)&uint8_t buf[4] = v8;
          _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "Failed to allow system sleep: %d", buf, 8u);
        }
      }
    }
  }
}

void sub_183A0FBC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void __isWebKitNetworking_block_invoke()
{
  uint64_t v0 = [MEMORY[0x1E4F28B50] mainBundle];
  id v1 = [v0 bundleIdentifier];
  int v2 = [v1 hasPrefix:@"com.apple.WebKit.Networking"];

  if (v2) {
    isWebKitNetworking_uint64_t result = 1;
  }
}

uint64_t nw_protocol_registrar_get_accept_function_for_identifier(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v9, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v12 = "%{public}s called with null identifier";
LABEL_35:
          _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_36;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v12 = "%{public}s called with null identifier, no backtrace";
          goto LABEL_35;
        }
      }
      else
      {
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_protocol_registrar_get_accept_function_for_identifier";
          uint64_t v12 = "%{public}s called with null identifier, backtrace limit exceeded";
          goto LABEL_35;
        }
      }
    }
LABEL_36:
    if (v9) {
      free(v9);
    }
    return 0;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  int v2 = &g_registration_list;
  while (1)
  {
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    if (*a1 == v2[4] && a1[1] == v2[5] && a1[2] == v2[6] && a1[3] == v2[7] && a1[4] == v2[8])
    {
      uint64_t v7 = v2[13];
      goto LABEL_20;
    }
  }
  uint64_t v7 = 0;
LABEL_20:
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  return v7;
}

BOOL nw_protocol_register_many_to_one(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  nw_allow_use_of_dispatch_internal();
  if (*(_DWORD *)(a1 + 36) != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    id v36 = "nw_protocol_register_many_to_one";
    __int16 v37 = 2082;
    uint64_t v38 = a1;
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v16, &type, &v33)) {
      goto LABEL_51;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int16 v19 = "%{public}s Protocol identifier %{public}s is not a many-to-one protocol";
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = gLogObj;
      os_log_type_t v18 = type;
      BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446722;
          id v36 = "nw_protocol_register_many_to_one";
          __int16 v37 = 2082;
          uint64_t v38 = a1;
          __int16 v39 = 2082;
          uint64_t v40 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Protocol identifier %{public}s is not a many-to-one protocol, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
LABEL_51:
        if (v16) {
          free(v16);
        }
        return 0;
      }
      if (!v27) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int16 v19 = "%{public}s Protocol identifier %{public}s is not a many-to-one protocol, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      __int16 v19 = "%{public}s Protocol identifier %{public}s is not a many-to-one protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0x16u);
    goto LABEL_51;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  int v6 = &g_registration_list;
  while (1)
  {
    int v6 = (uint64_t *)*v6;
    BOOL v7 = v6 == 0;
    if (!v6) {
      break;
    }
    if (*(void *)a1 == v6[4]
      && *(void *)(a1 + 8) == v6[5]
      && *(void *)(a1 + 16) == v6[6]
      && *(void *)(a1 + 24) == v6[7]
      && *(void *)(a1 + 32) == v6[8])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_protocol_register_many_to_one";
      __int16 v37 = 2082;
      uint64_t v38 = a1;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v33 = 0;
      if (!__nwlog_fault(v12, &type, &v33)) {
        goto LABEL_59;
      }
      if (type != OS_LOG_TYPE_FAULT)
      {
        if (v33)
        {
          size_t v28 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v13 = gLogObj;
          os_log_type_t v14 = type;
          BOOL v29 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v28)
          {
            if (v29)
            {
              *(_DWORD *)buf = 136446722;
              id v36 = "nw_protocol_register_many_to_one";
              __int16 v37 = 2082;
              uint64_t v38 = a1;
              __int16 v39 = 2082;
              uint64_t v40 = (uint64_t)v28;
              _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s Protocol identifier %{public}s is already registered, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v28);
            goto LABEL_59;
          }
          if (!v29) {
            goto LABEL_59;
          }
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_protocol_register_many_to_one";
          __int16 v37 = 2082;
          uint64_t v38 = a1;
          char v15 = "%{public}s Protocol identifier %{public}s is already registered, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v13 = gLogObj;
          os_log_type_t v14 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_59;
          }
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_protocol_register_many_to_one";
          __int16 v37 = 2082;
          uint64_t v38 = a1;
          char v15 = "%{public}s Protocol identifier %{public}s is already registered, backtrace limit exceeded";
        }
LABEL_58:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0x16u);
        goto LABEL_59;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v13 = gLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        id v36 = "nw_protocol_register_many_to_one";
        __int16 v37 = 2082;
        uint64_t v38 = a1;
        char v15 = "%{public}s Protocol identifier %{public}s is already registered";
        goto LABEL_58;
      }
LABEL_59:
      if (v12) {
        free(v12);
      }
LABEL_61:
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      return v7;
    }
  }
  uint64_t v20 = malloc_type_calloc(1uLL, 0x78uLL, 0xEAFB8F1AuLL);
  if (v20)
  {
LABEL_27:
    long long v21 = *(_OWORD *)a1;
    long long v22 = *(_OWORD *)(a1 + 16);
    v20[8] = *(void *)(a1 + 32);
    *((_OWORD *)v20 + 2) = v21;
    *((_OWORD *)v20 + 3) = v22;
    v20[11] = a2;
    v20[13] = a3;
    uint64_t v23 = g_registration_list;
    *uint64_t v20 = g_registration_list;
    if (v23) {
      *(void *)(v23 + _Block_object_dispose(&a9, 8) = v20;
    }
    g_registration_list = (uint64_t)v20;
    v20[1] = &g_registration_list;
    if (a3)
    {
      uint64_t v24 = g_many_to_one_list;
      v20[2] = g_many_to_one_list;
      if (v24) {
        *(void *)(v24 + 24) = v20 + 2;
      }
      g_many_to_one_list = (uint64_t)v20;
      v20[3] = &g_many_to_one_list;
    }
    v20[9] = nw_array_create();
    if (gLogDatapath)
    {
      uint64_t v25 = __nwlog_obj();
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        id v36 = "nw_protocol_register_many_to_one";
        __int16 v37 = 2080;
        uint64_t v38 = a1;
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s created new registration for many-to-one protocol %s", buf, 0x16u);
      }
    }
    goto LABEL_61;
  }
  uint64_t v31 = __nwlog_obj();
  os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  id v36 = "strict_calloc";
  __int16 v37 = 2048;
  uint64_t v38 = 1;
  __int16 v39 = 2048;
  uint64_t v40 = 120;
  unint64_t v32 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v32);
  if (!result)
  {
    free(v32);
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_unregister(void *a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  int v2 = &g_registration_list;
  while (1)
  {
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    if (*a1 == v2[4] && a1[1] == v2[5] && a1[2] == v2[6] && a1[3] == v2[7] && a1[4] == v2[8])
    {
      uint64_t v7 = *v2;
      if (*v2) {
        *(void *)(v7 + _Block_object_dispose(&a9, 8) = v2[1];
      }
      *(void *)v2[1] = v7;
      uint64_t v8 = v2[2];
      if (v8) {
        *(void *)(v8 + 24) = v2[3];
      }
      *(void *)v2[3] = v8;
      uint64_t v9 = (void *)v2[14];
      if (v9)
      {
        os_release(v9);
        v2[14] = 0;
      }
      free(v2);
      goto LABEL_26;
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v10 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    int v12 = 136446466;
    int v13 = "nw_protocol_unregister";
    __int16 v14 = 2082;
    char v15 = a1;
    _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s Protocol %{public}s is not registered", (uint8_t *)&v12, 0x16u);
  }
LABEL_26:
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  return v2 != 0;
}

BOOL nw_protocol_is_registered(void *a1)
{
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  int v2 = &g_registration_list;
  do
  {
    int v2 = (uint64_t *)*v2;
    if (!v2) {
      break;
    }
    BOOL v3 = *a1 == v2[4] && a1[1] == v2[5];
    BOOL v4 = v3 && a1[2] == v2[6];
    BOOL v5 = v4 && a1[3] == v2[7];
  }
  while (!v5 || a1[4] != v2[8]);
  BOOL v7 = v2 != 0;
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  return v7;
}

uint64_t nw_protocol_create(uint64_t a1, void *a2, const char *a3)
{
  return nw_protocol_create_internal(a1, a2, a3, 1);
}

uint64_t nw_protocol_copy_shared_connection_state(uint64_t a1, uint64_t a2, void *a3, char a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v19, &type, &v29)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        long long v22 = "%{public}s called with null protocol";
LABEL_54:
        _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
      }
LABEL_55:
      if (v19) {
        free(v19);
      }
      return 0;
    }
    if (!v29)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        long long v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v24 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        long long v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v25 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_44:
      _os_log_impl(&dword_1830D4000, v20, v21, v25, buf, 0x16u);
    }
LABEL_45:
    free(backtrace_string);
    goto LABEL_55;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v19, &type, &v29)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        long long v22 = "%{public}s called with null context";
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    if (!v29)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        long long v22 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v26 = os_log_type_enabled(v20, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
        long long v22 = "%{public}s called with null context, no backtrace";
        goto LABEL_54;
      }
      goto LABEL_55;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_copy_shared_connection_state";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v25 = "%{public}s called with null context, dumping backtrace:%{public}s";
      goto LABEL_44;
    }
    goto LABEL_45;
  }
  BOOL v7 = a3;
  uint64_t v8 = v7;
  if (((_BYTE)v7[17] & 8) == 0) {
    dispatch_assert_queue_V2(v7[1]);
  }

  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000;
  uint64_t v32 = 0;
  uint64_t v9 = a1;
  do
  {
    if (*(void *)(*(void *)&buf[8] + 24)) {
      break;
    }
    uint64_t v10 = *(void *)(v9 + 16);
    if (*(_DWORD *)(v10 + 36) == 2)
    {
      os_log_type_t v11 = &g_registration_list;
      while (1)
      {
        os_log_type_t v11 = (uint64_t *)*v11;
        if (!v11) {
          break;
        }
        if (*(void *)v10 == v11[4]
          && *(void *)(v10 + 8) == v11[5]
          && *(void *)(v10 + 16) == v11[6]
          && *(void *)(v10 + 24) == v11[7]
          && *(void *)(v10 + 32) == v11[8])
        {
          uint64_t v16 = (atomic_uchar *)v11[9];
          v27[0] = MEMORY[0x1E4F143A8];
          v27[1] = 0x40000000;
          v27[2] = __nw_protocol_copy_shared_connection_state_block_invoke;
          v27[3] = &unk_1E5241E10;
          v27[4] = buf;
          v27[5] = v9;
          v27[6] = a1;
          v27[7] = a2;
          v27[8] = v8;
          char v28 = a4;
          nw_array_apply(v16, (uint64_t)v27);
          break;
        }
      }
    }
    uint64_t v9 = *(void *)(v9 + 32);
  }
  while (v9);
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  uint64_t v17 = *(void *)(*(void *)&buf[8] + 24);
  _Block_object_dispose(buf, 8);
  return v17;
}

void sub_183A11154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_copy_shared_connection_state_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  id v4 = nw_endpoint_copy_registrar_for_identifier(a3, *(long long **)(*(void *)(a1 + 40) + 16), 0);
  if (v4)
  {
    uint64_t v6 = *(void *)(a1 + 48);
    BOOL v5 = *(void **)(a1 + 56);
    BOOL v7 = *(void **)(a1 + 64);
    char v8 = *(unsigned char *)(a1 + 72);
    uint64_t v9 = (os_unfair_lock_s *)v4;
    id v10 = v5;
    id v11 = v7;
    int v12 = v11;
    if (v6)
    {
      if (v10)
      {
        if (v11)
        {
          int v13 = (dispatch_queue_t *)v11;
          __int16 v14 = v13;
          if (((_BYTE)v13[17] & 8) == 0) {
            dispatch_assert_queue_V2(v13[1]);
          }

          *(void *)os_log_type_t type = 0;
          uint64_t v38 = type;
          uint64_t v39 = 0x3032000000;
          uint64_t v40 = __Block_byref_object_copy__3858;
          uint64_t v41 = __Block_byref_object_dispose__3859;
          id v42 = 0;
          *(void *)aBlock = MEMORY[0x1E4F143A8];
          *(void *)&aBlock[8] = 3221225472;
          *(void *)&aBlock[16] = __nw_protocol_instance_registrar_copy_shared_connection_state_block_invoke;
          uint64_t v45 = &unk_1E523B040;
          char v46 = v9;
          uint64_t v50 = v6;
          char v51 = v8;
          uint64_t v47 = v14;
          id v48 = v10;
          long long v49 = type;
          char v15 = (void (**)(void))_Block_copy(aBlock);
          os_unfair_lock_lock(v9 + 2);
          v15[2](v15);
          os_unfair_lock_unlock(v9 + 2);

          id v16 = *((id *)v38 + 5);
          _Block_object_dispose(type, 8);

          goto LABEL_8;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v24 = (id)gLogObj;
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
        __int16 v19 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        char v43 = 0;
        if (__nwlog_fault(v19, type, &v43))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v20 = (id)gLogObj;
            os_log_type_t v25 = type[0];
            if (os_log_type_enabled(v20, type[0]))
            {
              *(_DWORD *)aBlock = 136446210;
              *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
              _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null context", aBlock, 0xCu);
            }
LABEL_58:

            goto LABEL_59;
          }
          if (!v43)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v20 = (id)gLogObj;
            os_log_type_t v36 = type[0];
            if (os_log_type_enabled(v20, type[0]))
            {
              *(_DWORD *)aBlock = 136446210;
              *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
              _os_log_impl(&dword_1830D4000, v20, v36, "%{public}s called with null context, backtrace limit exceeded", aBlock, 0xCu);
            }
            goto LABEL_58;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (id)gLogObj;
          os_log_type_t v32 = type[0];
          BOOL v33 = os_log_type_enabled(v20, type[0]);
          if (!backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)aBlock = 136446210;
              *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
              _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s called with null context, no backtrace", aBlock, 0xCu);
            }
            goto LABEL_58;
          }
          if (v33)
          {
            *(_DWORD *)aBlock = 136446466;
            *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
            *(_WORD *)&aBlock[12] = 2082;
            *(void *)&aBlock[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s called with null context, dumping backtrace:%{public}s", aBlock, 0x16u);
          }

          free(backtrace_string);
        }
LABEL_59:
        if (!v19)
        {
LABEL_61:
          id v16 = 0;
LABEL_8:

          *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v16;
          os_release(v9);
          return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
        }
LABEL_60:
        free(v19);
        goto LABEL_61;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (id)gLogObj;
      *(_DWORD *)aBlock = 136446210;
      *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
      __int16 v19 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (!__nwlog_fault(v19, type, &v43)) {
        goto LABEL_59;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null definition", aBlock, 0xCu);
        }
        goto LABEL_58;
      }
      if (!v43)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (id)gLogObj;
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
          _os_log_impl(&dword_1830D4000, v20, v35, "%{public}s called with null definition, backtrace limit exceeded", aBlock, 0xCu);
        }
        goto LABEL_58;
      }
      BOOL v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = (id)gLogObj;
      os_log_type_t v29 = type[0];
      BOOL v30 = os_log_type_enabled(v20, type[0]);
      if (!v26)
      {
        if (v30)
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
          _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null definition, no backtrace", aBlock, 0xCu);
        }
        goto LABEL_58;
      }
      if (v30)
      {
        *(_DWORD *)aBlock = 136446466;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
        *(_WORD *)&aBlock[12] = 2082;
        *(void *)&aBlock[14] = v26;
        _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s called with null definition, dumping backtrace:%{public}s", aBlock, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v18 = (id)gLogObj;
      *(_DWORD *)aBlock = 136446210;
      *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
      __int16 v19 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (!__nwlog_fault(v19, type, &v43)) {
        goto LABEL_59;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (id)gLogObj;
        os_log_type_t v21 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null protocol", aBlock, 0xCu);
        }
        goto LABEL_58;
      }
      if (!v43)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v20 = (id)gLogObj;
        os_log_type_t v34 = type[0];
        if (os_log_type_enabled(v20, type[0]))
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
          _os_log_impl(&dword_1830D4000, v20, v34, "%{public}s called with null protocol, backtrace limit exceeded", aBlock, 0xCu);
        }
        goto LABEL_58;
      }
      BOOL v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = (id)gLogObj;
      os_log_type_t v27 = type[0];
      BOOL v28 = os_log_type_enabled(v20, type[0]);
      if (!v26)
      {
        if (v28)
        {
          *(_DWORD *)aBlock = 136446210;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
          _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null protocol, no backtrace", aBlock, 0xCu);
        }
        goto LABEL_58;
      }
      if (v28)
      {
        *(_DWORD *)aBlock = 136446466;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_copy_shared_connection_state";
        *(_WORD *)&aBlock[12] = 2082;
        *(void *)&aBlock[14] = v26;
        _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null protocol, dumping backtrace:%{public}s", aBlock, 0x16u);
      }
    }

    free(v26);
    if (!v19) {
      goto LABEL_61;
    }
    goto LABEL_60;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) == 0;
}

void sub_183A11B6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, char a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, id a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id a25,id a26,id a27)
{
  _Block_object_dispose(&a14, 8);
  _Unwind_Resume(a1);
}

void nw_protocol_enumerate_instances(void *a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_enumerate_instances";
    id v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v10, &v20, &v19)) {
      goto LABEL_50;
    }
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      int v13 = "%{public}s called with null identifier";
      goto LABEL_49;
    }
    if (!v19)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      int v13 = "%{public}s called with null identifier, backtrace limit exceeded";
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v11 = __nwlog_obj();
    os_log_type_t v12 = v20;
    BOOL v15 = os_log_type_enabled(v11, v20);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      int v13 = "%{public}s called with null identifier, no backtrace";
      goto LABEL_49;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      id v22 = "nw_protocol_enumerate_instances";
      __int16 v23 = 2082;
      id v24 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_50:
    if (!v10) {
      return;
    }
    goto LABEL_51;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_protocol_enumerate_instances";
    id v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v20 = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v10, &v20, &v19)) {
      goto LABEL_50;
    }
    if (v20 == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      int v13 = "%{public}s called with null enumerator";
      goto LABEL_49;
    }
    if (!v19)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = v20;
      if (!os_log_type_enabled(v11, v20)) {
        goto LABEL_50;
      }
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      int v13 = "%{public}s called with null enumerator, backtrace limit exceeded";
      goto LABEL_49;
    }
    id v16 = (char *)__nw_create_backtrace_string();
    id v11 = __nwlog_obj();
    os_log_type_t v12 = v20;
    BOOL v17 = os_log_type_enabled(v11, v20);
    if (v16)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        id v22 = "nw_protocol_enumerate_instances";
        __int16 v23 = 2082;
        id v24 = v16;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null enumerator, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v16);
      if (!v10) {
        return;
      }
LABEL_51:
      free(v10);
      return;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_protocol_enumerate_instances";
      int v13 = "%{public}s called with null enumerator, no backtrace";
LABEL_49:
      _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      goto LABEL_50;
    }
    goto LABEL_50;
  }
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  id v4 = &g_registration_list;
  while (1)
  {
    id v4 = (uint64_t *)*v4;
    if (!v4) {
      break;
    }
    if (*a1 == v4[4] && a1[1] == v4[5] && a1[2] == v4[6] && a1[3] == v4[7] && a1[4] == v4[8])
    {
      uint64_t v9 = (atomic_uchar *)v4[9];
      v18[0] = MEMORY[0x1E4F143A8];
      v18[1] = 0x40000000;
      v18[2] = __nw_protocol_enumerate_instances_block_invoke;
      v18[3] = &unk_1E5241E38;
      v18[4] = a2;
      v18[5] = a1;
      nw_array_apply(v9, (uint64_t)v18);
      break;
    }
  }
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
}

uint64_t __nw_protocol_enumerate_instances_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  BOOL v3 = *(void **)(a1 + 32);
  id v4 = *(long long **)(a1 + 40);
  id v5 = a3;
  id v6 = v3;
  BOOL v7 = v6;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
    int v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null registered_endpoint", aBlock, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)aBlock = 136446466;
          *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
          *(_WORD *)&aBlock[12] = 2082;
          *(void *)&aBlock[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null registered_endpoint, dumping backtrace:%{public}s", aBlock, 0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v13) {
          goto LABEL_7;
        }
LABEL_58:
        free(v13);
        goto LABEL_7;
      }
      if (v22)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null registered_endpoint, no backtrace", aBlock, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null registered_endpoint, backtrace limit exceeded", aBlock, 0xCu);
      }
    }
LABEL_56:

    goto LABEL_57;
  }
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v16 = (id)gLogObj;
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
    int v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null identifier", aBlock, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null identifier, backtrace limit exceeded", aBlock, 0xCu);
      }
      goto LABEL_56;
    }
    __int16 v23 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v14 = (id)gLogObj;
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null identifier, no backtrace", aBlock, 0xCu);
      }
      goto LABEL_56;
    }
    if (v25)
    {
      *(_DWORD *)aBlock = 136446466;
      *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
      *(_WORD *)&aBlock[12] = 2082;
      *(void *)&aBlock[14] = v23;
      _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null identifier, dumping backtrace:%{public}s", aBlock, 0x16u);
    }
    goto LABEL_37;
  }
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)aBlock = 136446210;
    *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
    int v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null enumerator", aBlock, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v31)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v14 = (id)gLogObj;
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v30, "%{public}s called with null enumerator, backtrace limit exceeded", aBlock, 0xCu);
      }
      goto LABEL_56;
    }
    __int16 v23 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v14 = (id)gLogObj;
    os_log_type_t v26 = type;
    BOOL v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)aBlock = 136446210;
        *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
        _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null enumerator, no backtrace", aBlock, 0xCu);
      }
      goto LABEL_56;
    }
    if (v27)
    {
      *(_DWORD *)aBlock = 136446466;
      *(void *)&aBlock[4] = "nw_protocol_instance_registrar_enumerate_instances";
      *(_WORD *)&aBlock[12] = 2082;
      *(void *)&aBlock[14] = v23;
      _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null enumerator, dumping backtrace:%{public}s", aBlock, 0x16u);
    }
LABEL_37:

    free(v23);
    if (!v13) {
      goto LABEL_7;
    }
    goto LABEL_58;
  }
  char v8 = (os_unfair_lock_s *)nw_endpoint_copy_registrar_for_identifier(v5, v4, 0);
  uint64_t v9 = v8;
  if (v8)
  {
    *(void *)aBlock = MEMORY[0x1E4F143A8];
    *(void *)&aBlock[8] = 3221225472;
    *(void *)&aBlock[16] = __nw_protocol_instance_registrar_enumerate_instances_block_invoke;
    os_log_type_t v34 = &unk_1E52498B8;
    os_log_type_t v35 = v8;
    __int16 v37 = v4;
    id v36 = v7;
    id v10 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v9 + 2);
    v10[2](v10);
    os_unfair_lock_unlock(v9 + 2);
  }
LABEL_7:

  return 1;
}

void sub_183A1295C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_register_parameter_modifier(uint64_t a1)
{
  nw_allow_use_of_dispatch_internal();
  os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
  int v2 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (!v2)
  {
    id v5 = __nwlog_obj();
    os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    id v6 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v6);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v6);
  }
  v2[2] = a1;
  uint64_t v3 = g_modifier_list;
  void *v2 = g_modifier_list;
  if (v3) {
    *(void *)(v3 + _Block_object_dispose(&a9, 8) = v2;
  }
  g_modifier_list = (uint64_t)v2;
  v2[1] = &g_modifier_list;
  has_modifiers = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
  return 1;
}

const char *nw_protocol_notification_type_to_string(unsigned int a1)
{
  if (a1 > 0x1A) {
    return "unknown";
  }
  else {
    return off_1E5241E58[a1];
  }
}

BOOL nw_protocol_input_handler_is_connection_flow(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v12 = "nw_protocol_input_handler_is_connection_flow";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v3, &type, &v9)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      id v12 = "nw_protocol_input_handler_is_connection_flow";
      id v6 = "%{public}s called with null input_handler";
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          id v12 = "nw_protocol_input_handler_is_connection_flow";
          __int16 v13 = 2082;
          __int16 v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null input_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v8)
      {
LABEL_20:
        if (v3) {
          free(v3);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      id v12 = "nw_protocol_input_handler_is_connection_flow";
      id v6 = "%{public}s called with null input_handler, no backtrace";
    }
    else
    {
      id v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446210;
      id v12 = "nw_protocol_input_handler_is_connection_flow";
      id v6 = "%{public}s called with null input_handler, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_20;
  }
  id v1 = *(const char **)(a1 + 16);
  if (!v1) {
    return 0;
  }
  return !strcmp(*(const char **)(a1 + 16), "endpoint_flow") || strcmp(v1, "flow_replay") == 0;
}

const char *nw_protocol_input_handler_is_flow_replay(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    BOOL result = *(const char **)(a1 + 16);
    if (result) {
      return (const char *)(strcmp(result, "flow_replay") == 0);
    }
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v11 = "nw_protocol_input_handler_is_flow_replay";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_protocol_input_handler_is_flow_replay";
        os_log_type_t v5 = "%{public}s called with null input_handler";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          id v11 = "nw_protocol_input_handler_is_flow_replay";
          __int16 v12 = 2082;
          __int16 v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null input_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_19;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_protocol_input_handler_is_flow_replay";
        os_log_type_t v5 = "%{public}s called with null input_handler, no backtrace";
        goto LABEL_18;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_protocol_input_handler_is_flow_replay";
        os_log_type_t v5 = "%{public}s called with null input_handler, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
  }
LABEL_19:
  if (v2) {
    free(v2);
  }
  return 0;
}

void __nw_utilities_set_log_intercept_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 32)) {
    BOOL v1 = nw_utilities_set_log_intercept::stream == 0;
  }
  else {
    BOOL v1 = 0;
  }
  if (v1)
  {
    if (nw_utilities_get_log_event_source(void)::once != -1) {
      dispatch_once(&nw_utilities_get_log_event_source(void)::once, &__block_literal_global_53_44427);
    }
    id v4 = (id)nw_utilities_get_log_event_source(void)::source;
    if (v4)
    {
      gotLoadHelper_x8__OBJC_CLASS___OSLogEventLiveStream(v5);
      uint64_t v7 = [objc_alloc(*(Class *)(v6 + 160)) initWithLiveSource:v4];
      char v8 = (void *)nw_utilities_set_log_intercept::stream;
      nw_utilities_set_log_intercept::stream = v7;

      [(id)nw_utilities_set_log_intercept::stream setFlags:7];
      char v9 = objc_msgSend(MEMORY[0x1E4F28F60], "predicateWithFormat:", @"processIdentifier == %d && subsystem == \"com.apple.network\"", getpid());
      [(id)nw_utilities_set_log_intercept::stream setFilterPredicate:v9];

      [(id)nw_utilities_set_log_intercept::stream setStreamHandler:&__block_literal_global_44430];
      [(id)nw_utilities_set_log_intercept::stream activate];
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v12 = "nw_utilities_set_log_intercept_block_invoke";
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s Unable to start intercept, no log source", buf, 0xCu);
      }
    }
  }
  else
  {
    if (*(unsigned char *)(a1 + 32)) {
      BOOL v2 = 1;
    }
    else {
      BOOL v2 = nw_utilities_set_log_intercept::stream == 0;
    }
    if (!v2)
    {
      [(id)nw_utilities_set_log_intercept::stream invalidate];
      uint64_t v3 = (void *)nw_utilities_set_log_intercept::stream;
      nw_utilities_set_log_intercept::stream = 0;
    }
  }
}

void sub_183A131D4(_Unwind_Exception *a1)
{
  uint64_t v3 = v2;

  _Unwind_Resume(a1);
}

void __nw_utilities_set_log_intercept_block_invoke_3(uint64_t a1, void *a2)
{
  id v3 = a2;
  BOOL v2 = [v3 composedMessage];
  __nwlog_handle_composed([v2 UTF8String], objc_msgSend(v3, "unixDate"));
}

void sub_183A13264(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL33nw_utilities_get_log_event_sourcev_block_invoke(double a1)
{
  gotLoadHelper_x19__OBJC_CLASS___OSLogEventLiveSource(a1);
  if (objc_opt_class())
  {
    id v2 = objc_alloc_init(*(Class *)(v1 + 144));
    id v3 = (void *)nw_utilities_get_log_event_source(void)::source;
    nw_utilities_get_log_event_source(void)::BOOL source = (uint64_t)v2;
  }
}

void *nw_utilities_public_key_info_for_sec_identity(void *a1)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    id v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(privateKeyRef) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v19, &privateKeyRef, &type)) {
      goto LABEL_112;
    }
    if (privateKeyRef == 17)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = privateKeyRef;
      if (os_log_type_enabled(v20, (os_log_type_t)privateKeyRef))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null identity", buf, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v34 = privateKeyRef;
      BOOL v35 = os_log_type_enabled(v20, (os_log_type_t)privateKeyRef);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          int v55 = "nw_utilities_public_key_info_for_sec_identity";
          __int16 v56 = 2082;
          os_log_type_t v57 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v34, "%{public}s called with null identity, dumping backtrace:%{public}s", buf, 0x16u);
        }

LABEL_78:
        free(backtrace_string);
        if (!v19) {
          goto LABEL_114;
        }
        goto LABEL_113;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v20, v34, "%{public}s called with null identity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v46 = privateKeyRef;
      if (os_log_type_enabled(v20, (os_log_type_t)privateKeyRef))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v20, v46, "%{public}s called with null identity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_105:

    goto LABEL_112;
  }
  id v3 = sec_identity_copy_ref(v1);
  id v4 = v3;
  if (!v3)
  {
    BOOL v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(privateKeyRef) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v19, &privateKeyRef, &type)) {
      goto LABEL_112;
    }
    if (privateKeyRef == 17)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v23 = privateKeyRef;
      if (os_log_type_enabled(v20, (os_log_type_t)privateKeyRef))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null secIdentity", buf, 0xCu);
      }
    }
    else if (type)
    {
      id v36 = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v37 = privateKeyRef;
      BOOL v38 = os_log_type_enabled(v20, (os_log_type_t)privateKeyRef);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          int v55 = "nw_utilities_public_key_info_for_sec_identity";
          __int16 v56 = 2082;
          os_log_type_t v57 = v36;
          _os_log_impl(&dword_1830D4000, v20, v37, "%{public}s called with null secIdentity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v36);
LABEL_112:
        if (!v19)
        {
LABEL_114:
          uint64_t v15 = 0;
          goto LABEL_32;
        }
LABEL_113:
        free(v19);
        goto LABEL_114;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v20, v37, "%{public}s called with null secIdentity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v47 = privateKeyRef;
      if (os_log_type_enabled(v20, (os_log_type_t)privateKeyRef))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v20, v47, "%{public}s called with null secIdentity, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_105;
  }
  SecKeyRef privateKeyRef = 0;
  OSStatus v5 = SecIdentityCopyPrivateKey(v3, &privateKeyRef);
  CFRelease(v4);
  if (!v5) {
    goto LABEL_25;
  }
  if (privateKeyRef)
  {
    CFRelease(privateKeyRef);
    SecKeyRef privateKeyRef = 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v55 = "nw_utilities_public_key_info_for_sec_identity";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v51 = 0;
  if (!__nwlog_fault(v7, &type, &v51))
  {
LABEL_23:
    if (!v7) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (id)gLogObj;
    os_log_type_t v9 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      int v55 = "nw_utilities_public_key_info_for_sec_identity";
      _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s SecIdentityCopyPrivateKey failed", buf, 0xCu);
    }
LABEL_22:

    goto LABEL_23;
  }
  if (!v51)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = (id)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      int v55 = "nw_utilities_public_key_info_for_sec_identity";
      _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s SecIdentityCopyPrivateKey failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_22;
  }
  id v10 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v8 = (id)gLogObj;
  os_log_type_t v11 = type;
  BOOL v12 = os_log_type_enabled(v8, type);
  if (!v10)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      int v55 = "nw_utilities_public_key_info_for_sec_identity";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s SecIdentityCopyPrivateKey failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_22;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    __int16 v56 = 2082;
    os_log_type_t v57 = v10;
    _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s SecIdentityCopyPrivateKey failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v10);
  if (v7) {
LABEL_24:
  }
    free(v7);
LABEL_25:
  if (!privateKeyRef)
  {
    os_log_type_t v24 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v19, &type, &v51)) {
      goto LABEL_112;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null privateKey", buf, 0xCu);
      }
      goto LABEL_111;
    }
    if (!v51)
    {
      BOOL v25 = __nwlog_obj();
      os_log_type_t v48 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v25, v48, "%{public}s called with null privateKey, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_111;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v25 = __nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v40 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v25, v39, "%{public}s called with null privateKey, no backtrace", buf, 0xCu);
      }
      goto LABEL_111;
    }
    if (v40)
    {
      *(_DWORD *)buf = 136446466;
      int v55 = "nw_utilities_public_key_info_for_sec_identity";
      __int16 v56 = 2082;
      os_log_type_t v57 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v25, v39, "%{public}s called with null privateKey, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_77:

    goto LABEL_78;
  }
  SecKeyRef v14 = SecKeyCopyPublicKey(privateKeyRef);
  if (privateKeyRef)
  {
    CFRelease(privateKeyRef);
    SecKeyRef privateKeyRef = 0;
  }
  if (!v14)
  {
    BOOL v27 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v19, &type, &v51)) {
      goto LABEL_112;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v25 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v25, v28, "%{public}s called with null publicKey", buf, 0xCu);
      }
LABEL_111:

      goto LABEL_112;
    }
    if (!v51)
    {
      BOOL v25 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v25, v49, "%{public}s called with null publicKey, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_111;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v25 = __nwlog_obj();
    os_log_type_t v41 = type;
    BOOL v42 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        int v55 = "nw_utilities_public_key_info_for_sec_identity";
        _os_log_impl(&dword_1830D4000, v25, v41, "%{public}s called with null publicKey, no backtrace", buf, 0xCu);
      }
      goto LABEL_111;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      int v55 = "nw_utilities_public_key_info_for_sec_identity";
      __int16 v56 = 2082;
      os_log_type_t v57 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v25, v41, "%{public}s called with null publicKey, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_77;
  }
  uint64_t v15 = (void *)SecKeyCopySubjectPublicKeyInfo();
  CFRelease(v14);
  if (!v15)
  {
    os_log_type_t v29 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v55 = "nw_utilities_public_key_info_for_sec_identity";
    os_log_type_t v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (__nwlog_fault(v30, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          int v55 = "nw_utilities_public_key_info_for_sec_identity";
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null result", buf, 0xCu);
        }
      }
      else if (v51)
      {
        char v43 = (char *)__nw_create_backtrace_string();
        char v31 = __nwlog_obj();
        os_log_type_t v44 = type;
        BOOL v45 = os_log_type_enabled(v31, type);
        if (v43)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            int v55 = "nw_utilities_public_key_info_for_sec_identity";
            __int16 v56 = 2082;
            os_log_type_t v57 = v43;
            _os_log_impl(&dword_1830D4000, v31, v44, "%{public}s called with null result, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v43);
          goto LABEL_118;
        }
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          int v55 = "nw_utilities_public_key_info_for_sec_identity";
          _os_log_impl(&dword_1830D4000, v31, v44, "%{public}s called with null result, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v31 = __nwlog_obj();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          int v55 = "nw_utilities_public_key_info_for_sec_identity";
          _os_log_impl(&dword_1830D4000, v31, v50, "%{public}s called with null result, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_118:
    if (v30) {
      free(v30);
    }
    goto LABEL_31;
  }
  id v16 = v15;
LABEL_31:

LABEL_32:
  return v15;
}

void sub_183A14070(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

sec_identity_t nw_utilities_identity_for_key_pair(__SecKey *a1)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  SecKeyRef v1 = SecKeyCopyPublicKey(a1);
  SelfSignedCertificate = (const void *)SecGenerateSelfSignedCertificate();
  if (v1) {
    CFRelease(v1);
  }
  if (!SelfSignedCertificate)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v6, &type, &v27)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s SecGenerateSelfSignedCertificate failed", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v22, "%{public}s SecGenerateSelfSignedCertificate failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s SecGenerateSelfSignedCertificate failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
      __int16 v31 = 2082;
      os_log_type_t v32 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s SecGenerateSelfSignedCertificate failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_30;
  }
  id v3 = (__SecIdentity *)SecIdentityCreate();
  CFRelease(SelfSignedCertificate);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v6, &type, &v27)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s SecIdentityCreate failed", buf, 0xCu);
      }
LABEL_55:

LABEL_56:
      if (!v6) {
        return 0;
      }
LABEL_57:
      free(v6);
      return 0;
    }
    if (!v27)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v23, "%{public}s SecIdentityCreate failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v16, "%{public}s SecIdentityCreate failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
      __int16 v31 = 2082;
      os_log_type_t v32 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v7, v16, "%{public}s SecIdentityCreate failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_30:

    free(backtrace_string);
    if (!v6) {
      return 0;
    }
    goto LABEL_57;
  }
  sec_identity_t v4 = sec_identity_create(v3);
  CFRelease(v3);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v6, &type, &v27)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s sec_identity_create failed", buf, 0xCu);
      }
    }
    else if (v27)
    {
      id v18 = __nw_create_backtrace_string();
      if (v18)
      {
        os_log_type_t v19 = (char *)v18;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v20 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
          __int16 v31 = 2082;
          os_log_type_t v32 = v19;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s sec_identity_create failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v19);
        if (!v6) {
          return 0;
        }
        goto LABEL_57;
      }
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v25, "%{public}s sec_identity_create failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = (id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v30 = "nw_utilities_identity_for_key_pair";
        _os_log_impl(&dword_1830D4000, v7, v24, "%{public}s sec_identity_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_55;
  }
  return v4;
}

void sub_183A14924(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_utilities_trust_ref_matches_public_key(void *a1, void *a2, unsigned char *a3)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = sec_trust_copy_ref(v5);
  os_log_type_t v8 = v7;
  if (!v7)
  {
    os_log_type_t v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (!__nwlog_fault(v26, &type, &v52)) {
      goto LABEL_71;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null trustRef", buf, 0xCu);
      }
    }
    else if (v52)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v27 = __nwlog_obj();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
          __int16 v57 = 2082;
          uint64_t v58 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v27, v36, "%{public}s called with null trustRef, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v26) {
          goto LABEL_73;
        }
        goto LABEL_72;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v27, v36, "%{public}s called with null trustRef, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v27 = __nwlog_obj();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v27, v44, "%{public}s called with null trustRef, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_70;
  }
  SecKeyRef v9 = SecTrustCopyKey(v7);
  CFRelease(v8);
  if (!v9)
  {
    os_log_type_t v29 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (!__nwlog_fault(v26, &type, &v52)) {
      goto LABEL_71;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v27 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null publicKey", buf, 0xCu);
      }
    }
    else if (v52)
    {
      BOOL v38 = (char *)__nw_create_backtrace_string();
      char v27 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v40 = os_log_type_enabled(v27, type);
      if (v38)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
          __int16 v57 = 2082;
          uint64_t v58 = (uint64_t)v38;
          _os_log_impl(&dword_1830D4000, v27, v39, "%{public}s called with null publicKey, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v38);
LABEL_71:
        if (!v26)
        {
LABEL_73:
          uint64_t v21 = 0;
          goto LABEL_24;
        }
LABEL_72:
        free(v26);
        goto LABEL_73;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v27, v39, "%{public}s called with null publicKey, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v27 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v27, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v27, v45, "%{public}s called with null publicKey, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_70:

    goto LABEL_71;
  }
  os_log_type_t v10 = (void *)SecKeyCopySubjectPublicKeyInfo();
  os_log_type_t v47 = v5;
  CFRelease(v9);
  if (v10)
  {
    long long v50 = 0u;
    long long v51 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    id v11 = v6;
    id v12 = v6;
    uint64_t v13 = [v12 countByEnumeratingWithState:&v48 objects:v54 count:16];
    if (v13)
    {
      int v14 = 0;
      uint64_t v15 = *(void *)v49;
      while (2)
      {
        uint64_t v16 = 0;
        char v17 = v14;
        v14 += v13;
        do
        {
          if (*(void *)v49 != v15) {
            objc_enumerationMutation(v12);
          }
          id v18 = *(void **)(*((void *)&v48 + 1) + 8 * v16);
          if ([v18 isEqual:v10])
          {
            if (a3) {
              *a3 = v17;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v22 = (id)gLogObj;
            id v5 = v47;
            id v6 = v11;
            if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v23 = [v18 hash];
              *(_DWORD *)buf = 136446466;
              __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
              __int16 v57 = 2048;
              uint64_t v58 = v23;
              _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s Matches key: #0x%lx", buf, 0x16u);
            }

            uint64_t v21 = 1;
            goto LABEL_23;
          }
          ++v17;
          ++v16;
        }
        while (v13 != v16);
        uint64_t v13 = [v12 countByEnumeratingWithState:&v48 objects:v54 count:16];
        if (v13) {
          continue;
        }
        break;
      }
    }

    id v5 = v47;
    id v6 = v11;
    if (a3) {
      *a3 = -1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v20 = [v10 hash];
      *(_DWORD *)buf = 136446466;
      __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
      __int16 v57 = 2048;
      uint64_t v58 = v20;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s No match for peer key #0x%lx, returning false", buf, 0x16u);
    }

    goto LABEL_17;
  }
  __int16 v31 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
  os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v52 = 0;
  if (__nwlog_fault(v32, &type, &v52))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null keyInfo", buf, 0xCu);
      }
LABEL_76:

      goto LABEL_77;
    }
    if (!v52)
    {
      uint64_t v33 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v33, v46, "%{public}s called with null keyInfo, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_76;
    }
    os_log_type_t v41 = (char *)__nw_create_backtrace_string();
    uint64_t v33 = __nwlog_obj();
    os_log_type_t v42 = type;
    BOOL v43 = os_log_type_enabled(v33, type);
    if (!v41)
    {
      if (v43)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
        _os_log_impl(&dword_1830D4000, v33, v42, "%{public}s called with null keyInfo, no backtrace", buf, 0xCu);
      }
      goto LABEL_76;
    }
    if (v43)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v56 = "nw_utilities_trust_ref_matches_public_key";
      __int16 v57 = 2082;
      uint64_t v58 = (uint64_t)v41;
      _os_log_impl(&dword_1830D4000, v33, v42, "%{public}s called with null keyInfo, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v41);
  }
LABEL_77:
  if (v32)
  {
    free(v32);
    uint64_t v21 = 0;
    goto LABEL_23;
  }
LABEL_17:
  uint64_t v21 = 0;
LABEL_23:

LABEL_24:
  return v21;
}

void sub_183A15244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t nw_utilities_cidr_string_to_subnet_and_mask(const char *a1, uint64_t a2, uint64_t a3, unsigned char *a4)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    BOOL v43 = __nwlog_obj();
    int __dst = 136446210;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v44, &type, &v59)) {
      goto LABEL_151;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        BOOL v52 = os_log_type_enabled(v45, type);
        if (backtrace_string)
        {
          if (v52)
          {
            int __dst = 136446466;
            os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
            __int16 v63 = 2082;
            os_log_type_t v64 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null netstr, dumping backtrace:%{public}s", (uint8_t *)&__dst, 0x16u);
          }

          free(backtrace_string);
LABEL_151:
          if (!v44) {
            return 0;
          }
LABEL_152:
          free(v44);
          return 0;
        }
        if (v52)
        {
          int __dst = 136446210;
          os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null netstr, no backtrace";
          goto LABEL_149;
        }
      }
      else
      {
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          int __dst = 136446210;
          os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null netstr, backtrace limit exceeded";
          goto LABEL_149;
        }
      }
      goto LABEL_150;
    }
    os_log_type_t v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_150;
    }
    int __dst = 136446210;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v47 = "%{public}s called with null netstr";
    goto LABEL_149;
  }
  if (!a2)
  {
    long long v48 = __nwlog_obj();
    int __dst = 136446210;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v44, &type, &v59)) {
      goto LABEL_151;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v59)
      {
        os_log_type_t v45 = __nwlog_obj();
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v45, type))
        {
          int __dst = 136446210;
          os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null network, backtrace limit exceeded";
          goto LABEL_149;
        }
        goto LABEL_150;
      }
      v53 = (char *)__nw_create_backtrace_string();
      os_log_type_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      BOOL v54 = os_log_type_enabled(v45, type);
      if (!v53)
      {
        if (v54)
        {
          int __dst = 136446210;
          os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
          os_log_type_t v47 = "%{public}s called with null network, no backtrace";
          goto LABEL_149;
        }
        goto LABEL_150;
      }
      if (!v54) {
        goto LABEL_131;
      }
      int __dst = 136446466;
      os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
      __int16 v63 = 2082;
      os_log_type_t v64 = v53;
      int v55 = "%{public}s called with null network, dumping backtrace:%{public}s";
      goto LABEL_130;
    }
    os_log_type_t v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    if (!os_log_type_enabled(v45, type)) {
      goto LABEL_150;
    }
    int __dst = 136446210;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v47 = "%{public}s called with null network";
LABEL_149:
    _os_log_impl(&dword_1830D4000, v45, v46, v47, (uint8_t *)&__dst, 0xCu);
    goto LABEL_150;
  }
  if (!a3)
  {
    long long v49 = __nwlog_obj();
    int __dst = 136446210;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v44, &type, &v59)) {
      goto LABEL_151;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_150;
      }
      int __dst = 136446210;
      os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
      os_log_type_t v47 = "%{public}s called with null mask";
      goto LABEL_149;
    }
    if (!v59)
    {
      os_log_type_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        int __dst = 136446210;
        os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null mask, backtrace limit exceeded";
        goto LABEL_149;
      }
      goto LABEL_150;
    }
    v53 = (char *)__nw_create_backtrace_string();
    os_log_type_t v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    BOOL v56 = os_log_type_enabled(v45, type);
    if (!v53)
    {
      if (v56)
      {
        int __dst = 136446210;
        os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null mask, no backtrace";
        goto LABEL_149;
      }
      goto LABEL_150;
    }
    if (!v56) {
      goto LABEL_131;
    }
    int __dst = 136446466;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    __int16 v63 = 2082;
    os_log_type_t v64 = v53;
    int v55 = "%{public}s called with null mask, dumping backtrace:%{public}s";
LABEL_130:
    _os_log_impl(&dword_1830D4000, v45, v46, v55, (uint8_t *)&__dst, 0x16u);
    goto LABEL_131;
  }
  if (!a4)
  {
    long long v50 = __nwlog_obj();
    int __dst = 136446210;
    os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
    os_log_type_t v44 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v44, &type, &v59)) {
      goto LABEL_151;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        int __dst = 136446210;
        os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null prefix";
        goto LABEL_149;
      }
LABEL_150:

      goto LABEL_151;
    }
    if (!v59)
    {
      os_log_type_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        int __dst = 136446210;
        os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null prefix, backtrace limit exceeded";
        goto LABEL_149;
      }
      goto LABEL_150;
    }
    v53 = (char *)__nw_create_backtrace_string();
    os_log_type_t v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    BOOL v57 = os_log_type_enabled(v45, type);
    if (!v53)
    {
      if (v57)
      {
        int __dst = 136446210;
        os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
        os_log_type_t v47 = "%{public}s called with null prefix, no backtrace";
        goto LABEL_149;
      }
      goto LABEL_150;
    }
    if (v57)
    {
      int __dst = 136446466;
      os_log_type_t v62 = "nw_utilities_cidr_string_to_subnet_and_mask";
      __int16 v63 = 2082;
      os_log_type_t v64 = v53;
      int v55 = "%{public}s called with null prefix, dumping backtrace:%{public}s";
      goto LABEL_130;
    }
LABEL_131:

    free(v53);
    if (!v44) {
      return 0;
    }
    goto LABEL_152;
  }
  size_t v8 = strlen(a1);
  if (!v8)
  {
    int v13 = 0;
    int v11 = 0;
    char v14 = 0;
    int v12 = 0;
    size_t v15 = 0;
    goto LABEL_12;
  }
  int v9 = *(unsigned __int8 *)a1;
  uint64_t v10 = (v9 - 46);
  if (v10 > 0x38) {
    goto LABEL_67;
  }
  if (((1 << (v9 - 46)) & 0x1F8000001F80000) == 0)
  {
    uint64_t v27 = 0;
    if (((1 << (v9 - 46)) & 3) != 0) {
      return v27;
    }
    if (v10 == 12)
    {
      int v12 = 0;
      int v11 = 1;
      goto LABEL_9;
    }
LABEL_67:
    int v11 = 0;
    int v12 = 0;
    uint64_t v27 = 0;
    if ((v9 - 48) > 9) {
      return v27;
    }
    goto LABEL_9;
  }
  int v11 = 0;
  int v12 = 1;
LABEL_9:
  if (v8 != 1)
  {
    uint64_t v25 = 0;
    char v14 = 0;
    int v13 = 0;
    size_t v15 = v8;
    while (1)
    {
      unint64_t v26 = v25 + 1;
      switch(a1[v25 + 1])
      {
        case '.':
          uint64_t v27 = 0;
          if (!v12 && !v11 && v15 > v26)
          {
            int v11 = 0;
            int v12 = 0;
            ++v13;
            goto LABEL_34;
          }
          return v27;
        case '/':
          if (v15 <= v26 || v13 && a1[v25] == 46) {
            return 0;
          }
          if (v26 < 3 || !v11 || a1[v25] != 58)
          {
            size_t v15 = v25 + 1;
            goto LABEL_34;
          }
          size_t v15 = v25 + 1;
          if (a1[v25 - 1] == 58) {
            goto LABEL_34;
          }
          return 0;
        case ':':
          uint64_t v27 = 0;
          if (v13 || v15 <= v26) {
            return v27;
          }
          ++v11;
          if (a1[v25] == 58)
          {
            if (v14) {
              return 0;
            }
            int v13 = 0;
            char v14 = 1;
          }
          else
          {
            int v13 = 0;
          }
LABEL_34:
          if (v8 - 1 == ++v25) {
            goto LABEL_12;
          }
          break;
        case 'A':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'a':
        case 'b':
        case 'c':
        case 'd':
        case 'e':
        case 'f':
          uint64_t v27 = 0;
          if (v13 || v15 <= v26) {
            return v27;
          }
          int v13 = 0;
          ++v12;
          goto LABEL_34;
        default:
          if (a1[v25 + 1] - 48 > 9) {
            return 0;
          }
          goto LABEL_34;
      }
    }
  }
  int v13 = 0;
  char v14 = 0;
  size_t v15 = 1;
LABEL_12:
  if (v15 >= v8) {
    return 0;
  }
  *(void *)a2 = 0;
  *(void *)(a2 + _Block_object_dispose(&a9, 8) = 0;
  *(_DWORD *)(a2 + 24) = 0;
  *(void *)(a2 + 16) = 0;
  *(void *)a3 = 0;
  *(void *)(a3 + _Block_object_dispose(&a9, 8) = 0;
  *(_DWORD *)(a3 + 24) = 0;
  *(void *)(a3 + 16) = 0;
  uint64_t v16 = a4;
  size_t v17 = v15 + 1;
  uint64_t v58 = v16;
  unsigned char *v16 = 0;
  uint64_t v18 = strtol(&a1[v15 + 1], 0, 0);
  if (v18 < 1) {
    return 0;
  }
  uint64_t v19 = v18;
  if (v12 | v11)
  {
    if ((unint64_t)v18 > 0x80) {
      return 0;
    }
    *(unsigned char *)(a3 + 1) = 30;
    *(unsigned char *)(a2 + 1) = 30;
    *(unsigned char *)a3 = 28;
    *(unsigned char *)a2 = 28;
    if (v15 > 0x26) {
      return 0;
    }
    memcpy(&__dst, a1, v15);
    if (!(v14 & 1 | (v11 > 6)))
    {
      if (v15 - 37 < 0xFFFFFFFFFFFFFFD8) {
        return 0;
      }
      *((unsigned char *)&__dst + v15) = 58;
      *((unsigned char *)&__dst + v17) = 58;
      v15 += 2;
    }
    *((unsigned char *)&__dst + v15) = 0;
    int v29 = inet_pton(30, (const char *)&__dst, (void *)(a2 + 8));
    uint64_t v27 = 0;
    os_log_type_t v22 = v58;
    if (v29 != 1) {
      return v27;
    }
    uint64_t v20 = (unsigned char *)(a3 + 8);
    goto LABEL_77;
  }
  if ((unint64_t)v18 > 0x20) {
    return 0;
  }
  *(unsigned char *)(a3 + 1) = 2;
  *(unsigned char *)(a2 + 1) = 2;
  *(unsigned char *)a3 = 16;
  *(unsigned char *)a2 = 16;
  if (v15 > 0xE) {
    return 0;
  }
  uint64_t v20 = (unsigned char *)(a3 + 4);
  memcpy(&__dst, a1, v15);
  if (v13 > 2 || v15 == 14)
  {
    os_log_type_t v22 = v58;
    goto LABEL_76;
  }
  size_t v21 = v15 + 2;
  *((unsigned char *)&__dst + v15) = 46;
  *((unsigned char *)&__dst + v17) = 48;
  if (v13 <= 1)
  {
    os_log_type_t v22 = v58;
    if (v15 <= 0xB)
    {
      size_t v23 = v15 + 4;
      *((unsigned char *)&__dst + v21) = 46;
      *((unsigned char *)&__dst + v15 + 3) = 48;
      if (v13 > 0 || v15 > 9) {
        goto LABEL_74;
      }
      size_t v21 = v15 + 6;
      *((unsigned char *)&__dst + v23) = 46;
      *((unsigned char *)&__dst + v15 + 5) = 48;
      if ((v13 & 0x80000000) == 0 || v15 > 7) {
        goto LABEL_73;
      }
      size_t v23 = v15 + 8;
      *((unsigned char *)&__dst + v21) = 46;
      *((unsigned char *)&__dst + v15 + 7) = 48;
      if (v13 > -2 || v15 > 5)
      {
LABEL_74:
        size_t v15 = v23;
        goto LABEL_76;
      }
      size_t v21 = v15 + 10;
      *((unsigned char *)&__dst + v23) = 46;
      *((unsigned char *)&__dst + v15 + 9) = 48;
      if (v13 <= -3 && v15 <= 3)
      {
        size_t v23 = v15 + 12;
        *((unsigned char *)&__dst + v21) = 46;
        *((unsigned char *)&__dst + v15 + 11) = 48;
        if (v13 <= -4 && v15 <= 1)
        {
          os_log_type_t v24 = (char *)&__dst + v15;
          v15 += 14;
          *((unsigned char *)&__dst + v23) = 46;
          v24[13] = 48;
          goto LABEL_76;
        }
        goto LABEL_74;
      }
    }
LABEL_73:
    size_t v15 = v21;
    goto LABEL_76;
  }
  v15 += 2;
  os_log_type_t v22 = v58;
LABEL_76:
  *((unsigned char *)&__dst + v15) = 0;
  int v30 = inet_pton(2, (const char *)&__dst, (void *)(a2 + 4));
  uint64_t v27 = 0;
  if (v30 != 1) {
    return v27;
  }
LABEL_77:
  *os_log_type_t v22 = v19;
  uint64_t v31 = 8;
  if (v19 < 8) {
    uint64_t v31 = v19;
  }
  unint64_t v32 = v19 - v31 + 7;
  if (v32 >= 8)
  {
    uint64_t v34 = (v32 >> 3) + 1;
    uint64_t v35 = v34 & 0x3FFFFFFFFFFFFFFELL;
    uint64_t v33 = v19 - 8 * (v34 & 0x3FFFFFFFFFFFFFFELL);
    os_log_type_t v36 = v20 + 1;
    uint64_t v37 = v34 & 0x3FFFFFFFFFFFFFFELL;
    do
    {
      uint64_t v38 = v19 - 8;
      if (v19 >= 8) {
        uint64_t v39 = 8;
      }
      else {
        uint64_t v39 = v19;
      }
      if (v38 >= 8) {
        uint64_t v38 = 8;
      }
      char v40 = nw_utilities_cidr_string_to_subnet_and_mask::bb[v38 - 1];
      *(v36 - 1) = nw_utilities_cidr_string_to_subnet_and_mask::bb[v39 - 1];
      unsigned char *v36 = v40;
      v36 += 2;
      v19 -= 16;
      v37 -= 2;
    }
    while (v37);
    if (v34 == v35) {
      return 1;
    }
    v20 += v35;
  }
  else
  {
    uint64_t v33 = v19;
  }
  uint64_t v27 = 1;
  do
  {
    uint64_t v42 = v33 - 8;
    BOOL v41 = v33 <= 8;
    if (v33 >= 8) {
      uint64_t v33 = 8;
    }
    *v20++ = nw_utilities_cidr_string_to_subnet_and_mask::bb[v33 - 1];
    uint64_t v33 = v42;
  }
  while (!v41);
  return v27;
}

BOOL nw_string_is_ip_address(const char *a1, void *a2, size_t a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    char v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
    size_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null str";
LABEL_42:
          _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0xCu);
        }
LABEL_43:

        goto LABEL_44;
      }
      if (!v24)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null str, backtrace limit exceeded";
          goto LABEL_42;
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v21 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null str, no backtrace";
          goto LABEL_42;
        }
        goto LABEL_43;
      }
      if (!v21) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      os_log_type_t v22 = "%{public}s called with null str, dumping backtrace:%{public}s";
      goto LABEL_32;
    }
LABEL_44:
    if (v15) {
      free(v15);
    }
    return 0;
  }
  if (!a2)
  {
    uint64_t v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
    size_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null addr";
          goto LABEL_42;
        }
        goto LABEL_43;
      }
      if (!v24)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null addr, backtrace limit exceeded";
          goto LABEL_42;
        }
        goto LABEL_43;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v23 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
          uint64_t v18 = "%{public}s called with null addr, no backtrace";
          goto LABEL_42;
        }
        goto LABEL_43;
      }
      if (!v23) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_string_is_ip_address";
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      os_log_type_t v22 = "%{public}s called with null addr, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_1830D4000, v16, v17, v22, buf, 0x16u);
LABEL_33:

      free(backtrace_string);
      goto LABEL_44;
    }
    goto LABEL_44;
  }
  *(void *)buf = 0;
  int v5 = getaddrinfo(a1, 0, &nw_string_is_ip_address::hints, (addrinfo **)buf);
  BOOL v6 = v5 == 0;
  if (!v5)
  {
    uint64_t v7 = *(addrinfo **)buf;
    if (*(void *)buf)
    {
      uint64_t v8 = *(void *)buf;
      while (1)
      {
        int v9 = *(unsigned __int8 **)(v8 + 32);
        int v10 = v9[1];
        if (v10 == 30 || v10 == 2) {
          break;
        }
        uint64_t v8 = *(void *)(v8 + 40);
        if (!v8) {
          goto LABEL_14;
        }
      }
      size_t v12 = *v9;
      if (v12 <= a3) {
        memcpy(a2, v9, v12);
      }
LABEL_14:
      freeaddrinfo(v7);
    }
  }
  return v6;
}

void nw_utilities_get_c_string_from_cfstring(const __CFString *a1, CFStringEncoding a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  int v5 = a3;
  BOOL v6 = v5;
  if (!a1)
  {
    os_log_type_t v28 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
    uint64_t v10 = _os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault((const char *)v10, &type, &v39)) {
      goto LABEL_44;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v12 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v12, v29, "%{public}s called with null stringRef", buf, 0xCu);
      }
      goto LABEL_79;
    }
    if (!v39)
    {
      size_t v12 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v12, v37, "%{public}s called with null stringRef, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_79;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v12 = __nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v34 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v12, v33, "%{public}s called with null stringRef, no backtrace", buf, 0xCu);
      }
      goto LABEL_79;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
      __int16 v43 = 2082;
      os_log_type_t v44 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v33, "%{public}s called with null stringRef, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_66;
  }
  if (!v5)
  {
    int v30 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
    uint64_t v10 = _os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault((const char *)v10, &type, &v39)) {
      goto LABEL_44;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v12 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v12, v31, "%{public}s called with null access_block", buf, 0xCu);
      }
      goto LABEL_79;
    }
    if (!v39)
    {
      size_t v12 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v12, v38, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_79;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v12 = __nwlog_obj();
    os_log_type_t v35 = type;
    BOOL v36 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v12, v35, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
      goto LABEL_79;
    }
    if (v36)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
      __int16 v43 = 2082;
      os_log_type_t v44 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v35, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_66:

    free(backtrace_string);
    if (!v10) {
      goto LABEL_46;
    }
    goto LABEL_45;
  }
  if (CFStringGetCStringPtr(a1, a2))
  {
    v6[2](v6);
    goto LABEL_46;
  }
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, a2);
  if (MaximumSizeForEncoding != -1)
  {
    CFIndex v9 = MaximumSizeForEncoding + 1;
    uint64_t v10 = nw_calloc_type<unsigned char>(MaximumSizeForEncoding + 1);
    if (CFStringGetCString(a1, (char *)v10, v9, a2))
    {
      ((void (*)(void (**)(void), uint64_t))v6[2])(v6, v10);
      goto LABEL_44;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
    size_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v15, &type, &v39))
    {
LABEL_42:
      if (!v15) {
        goto LABEL_44;
      }
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = (id)gLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s CFStringGetCString failed", buf, 0xCu);
      }
LABEL_41:

      goto LABEL_42;
    }
    if (!v39)
    {
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s CFStringGetCString failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_41;
    }
    os_log_type_t v22 = (char *)__nw_create_backtrace_string();
    uint64_t v16 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v16, type);
    if (!v22)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
        _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s CFStringGetCString failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_41;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
      __int16 v43 = 2082;
      os_log_type_t v44 = v22;
      _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s CFStringGetCString failed, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v22);
    if (v15) {
LABEL_43:
    }
      free(v15);
LABEL_44:
    if (!v10) {
      goto LABEL_46;
    }
LABEL_45:
    free((void *)v10);
    goto LABEL_46;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v11 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
  uint64_t v10 = _os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v39 = 0;
  if (!__nwlog_fault((const char *)v10, &type, &v39)) {
    goto LABEL_44;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v12 = (id)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
      _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s CFStringGetMaximumSizeForEncoding failed", buf, 0xCu);
    }
LABEL_79:

    goto LABEL_44;
  }
  if (!v39)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v12 = (id)gLogObj;
    os_log_type_t v25 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
      _os_log_impl(&dword_1830D4000, v12, v25, "%{public}s CFStringGetMaximumSizeForEncoding failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_79;
  }
  uint64_t v18 = __nw_create_backtrace_string();
  if (!v18)
  {
    size_t v12 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
      _os_log_impl(&dword_1830D4000, v12, v26, "%{public}s CFStringGetMaximumSizeForEncoding failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_79;
  }
  uint64_t v19 = (char *)v18;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v20 = (id)gLogObj;
  os_log_type_t v21 = type;
  if (os_log_type_enabled(v20, type))
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v42 = "nw_utilities_get_c_string_from_cfstring";
    __int16 v43 = 2082;
    os_log_type_t v44 = v19;
    _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s CFStringGetMaximumSizeForEncoding failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v10) {
    goto LABEL_45;
  }
LABEL_46:
}

void sub_183A16E4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_utf8_validator_init(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(_WORD *)a1 = 0;
    *(unsigned char *)(a1 + 2) = 0;
    return;
  }
  SecKeyRef v1 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v11 = "nw_utf8_validator_init";
  id v2 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_utf8_validator_init";
        int v5 = "%{public}s called with null state";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)buf = 136446466;
            id v11 = "nw_utf8_validator_init";
            __int16 v12 = 2082;
            os_log_type_t v13 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null state, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v7) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_utf8_validator_init";
        int v5 = "%{public}s called with null state, no backtrace";
        goto LABEL_17;
      }
      id v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        id v11 = "nw_utf8_validator_init";
        int v5 = "%{public}s called with null state, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v2) {
    free(v2);
  }
}

uint64_t nw_utf8_validator_parse(char *a1, uint64_t a2, unint64_t a3, int a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_utf8_validator_parse";
    size_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          uint64_t v18 = "%{public}s called with null state";
LABEL_86:
          _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0xCu);
        }
LABEL_87:

        goto LABEL_88;
      }
      if (!v24)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          uint64_t v18 = "%{public}s called with null state, backtrace limit exceeded";
          goto LABEL_86;
        }
        goto LABEL_87;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v21 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          uint64_t v18 = "%{public}s called with null state, no backtrace";
          goto LABEL_86;
        }
        goto LABEL_87;
      }
      if (!v21) {
        goto LABEL_77;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v27 = "nw_utf8_validator_parse";
      __int16 v28 = 2082;
      os_log_type_t v29 = backtrace_string;
      os_log_type_t v22 = "%{public}s called with null state, dumping backtrace:%{public}s";
      goto LABEL_76;
    }
LABEL_88:
    if (v15) {
      free(v15);
    }
    return 0;
  }
  if (!a2)
  {
    uint64_t v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v27 = "nw_utf8_validator_parse";
    size_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v15, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          uint64_t v18 = "%{public}s called with null buffer";
          goto LABEL_86;
        }
        goto LABEL_87;
      }
      if (!v24)
      {
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          uint64_t v18 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_86;
        }
        goto LABEL_87;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v23 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v27 = "nw_utf8_validator_parse";
          uint64_t v18 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_86;
        }
        goto LABEL_87;
      }
      if (!v23) {
        goto LABEL_77;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v27 = "nw_utf8_validator_parse";
      __int16 v28 = 2082;
      os_log_type_t v29 = backtrace_string;
      os_log_type_t v22 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_76:
      _os_log_impl(&dword_1830D4000, v16, v17, v22, buf, 0x16u);
LABEL_77:

      free(backtrace_string);
      goto LABEL_88;
    }
    goto LABEL_88;
  }
  int v4 = *a1;
  if ((v4 & 0x80000000) == 0 && a3)
  {
    uint64_t v5 = 0;
    while (!(_BYTE)v4)
    {
      int v9 = *(char *)(a2 + v5);
      if ((v9 & 0x80000000) == 0)
      {
        LOBYTE(v4) = 0;
        goto LABEL_48;
      }
      a1[1] = v9;
      char v10 = *(unsigned char *)(a2 + v5);
      if ((v10 + 62) > 0x1Du)
      {
        if ((v10 & 0xF0) == 0xE0)
        {
          LOBYTE(v4) = 2;
        }
        else
        {
          if ((v10 + 16) > 4u)
          {
LABEL_53:
            LOBYTE(v4) = -1;
            *a1 = -1;
LABEL_54:
            LODWORD(v12) = a4 ^ 1;
            if ((char)v4 > 0) {
              uint64_t v12 = v12;
            }
            else {
              uint64_t v12 = 0;
            }
            if (a4) {
              goto LABEL_58;
            }
LABEL_52:
            a1[2] = 1;
            return v12;
          }
          LOBYTE(v4) = 3;
        }
      }
      else
      {
        LOBYTE(v4) = 1;
      }
LABEL_31:
      *a1 = v4;
LABEL_48:
      if ((v4 & 0x80) == 0 && ++v5 < a3) {
        continue;
      }
      goto LABEL_50;
    }
    unsigned int v6 = a1[1];
    if (!a1[1]) {
      goto LABEL_53;
    }
    if (v6 > 0xDF)
    {
      if (v6 == 224)
      {
        int v7 = *(char *)(a2 + v5);
        if (v4 == 2)
        {
          if ((v7 + 64) < 0xE0u) {
            char v8 = -1;
          }
          else {
            char v8 = 2;
          }
          goto LABEL_30;
        }
        goto LABEL_28;
      }
      if (v6 > 0xEC)
      {
        if (v6 == 237)
        {
          int v7 = *(char *)(a2 + v5);
          if (v4 == 2)
          {
            if (v7 > -97) {
              char v8 = -1;
            }
            else {
              char v8 = 2;
            }
            goto LABEL_30;
          }
          goto LABEL_28;
        }
        if (v6 > 0xEF)
        {
          if (v6 == 240)
          {
            int v7 = *(char *)(a2 + v5);
            if (v4 == 3)
            {
              if ((v7 + 64) < 0xD0u) {
                char v8 = -1;
              }
              else {
                char v8 = 3;
              }
              goto LABEL_30;
            }
            goto LABEL_28;
          }
          if (v6 > 0xF3)
          {
            if (v6 != 244) {
              goto LABEL_46;
            }
            int v11 = *(char *)(a2 + v5);
            if (v4 == 3)
            {
              if (v11 > -113) {
                char v8 = -1;
              }
              else {
                char v8 = 3;
              }
              goto LABEL_30;
            }
            if (v11 < -64)
            {
LABEL_46:
              LOBYTE(v4) = v4 - 1;
              *a1 = v4;
              if (!(_BYTE)v4)
              {
                LOBYTE(v4) = 0;
                a1[1] = 0;
              }
              goto LABEL_48;
            }
            goto LABEL_29;
          }
        }
      }
    }
    int v7 = *(char *)(a2 + v5);
LABEL_28:
    if (v7 <= -65) {
      goto LABEL_46;
    }
LABEL_29:
    char v8 = -1;
LABEL_30:
    LOBYTE(v4) = v8 - 1;
    goto LABEL_31;
  }
LABEL_50:
  if ((_BYTE)v4) {
    goto LABEL_54;
  }
  uint64_t v12 = 1;
  if (!a4) {
    goto LABEL_52;
  }
LABEL_58:
  *(_WORD *)a1 = 0;
  a1[2] = 0;
  return v12;
}

BOOL nw_utf8_validator_is_parsing(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(unsigned char *)(a1 + 2) != 0;
  }
  id v2 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v12 = "nw_utf8_validator_is_parsing";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v9 = 0;
  if (__nwlog_fault(v3, &type, &v9))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_utf8_validator_is_parsing";
        unsigned int v6 = "%{public}s called with null state";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v12 = "nw_utf8_validator_is_parsing";
            __int16 v13 = 2082;
            uint64_t v14 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null state, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v8) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_utf8_validator_is_parsing";
        unsigned int v6 = "%{public}s called with null state, no backtrace";
        goto LABEL_17;
      }
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v12 = "nw_utf8_validator_is_parsing";
        unsigned int v6 = "%{public}s called with null state, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v3) {
    free(v3);
  }
  return 0;
}

void nw_utilities_get_uuid_for_pid(int pid, _OWORD *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!pid)
  {
    os_log_type_t v5 = __nwlog_obj();
    LODWORD(buffer[0]) = 136446210;
    *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v16 = 0;
    if (!__nwlog_fault(v6, buf, &v16)) {
      goto LABEL_44;
    }
    if (buf[0] == 17)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = buf[0];
      if (os_log_type_enabled(v7, (os_log_type_t)buf[0]))
      {
        LODWORD(buffer[0]) = 136446210;
        *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
        char v9 = "%{public}s called with null pid";
LABEL_42:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, (uint8_t *)buffer, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v8 = buf[0];
      BOOL v12 = os_log_type_enabled(v7, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v12)
        {
          LODWORD(buffer[0]) = 136446466;
          *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
          WORD6(buffer[0]) = 2082;
          *(void *)((char *)buffer + 14) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null pid, dumping backtrace:%{public}s", (uint8_t *)buffer, 0x16u);
        }

        free(backtrace_string);
LABEL_44:
        if (!v6) {
          return;
        }
LABEL_45:
        free(v6);
        return;
      }
      if (v12)
      {
        LODWORD(buffer[0]) = 136446210;
        *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
        char v9 = "%{public}s called with null pid, no backtrace";
        goto LABEL_42;
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = buf[0];
      if (os_log_type_enabled(v7, (os_log_type_t)buf[0]))
      {
        LODWORD(buffer[0]) = 136446210;
        *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
        char v9 = "%{public}s called with null pid, backtrace limit exceeded";
        goto LABEL_42;
      }
    }
LABEL_43:

    goto LABEL_44;
  }
  if (a2)
  {
    if (pid >= 1)
    {
      uint64_t v26 = 0;
      memset(buffer, 0, sizeof(buffer));
      if (proc_pidinfo(pid, 17, 1uLL, buffer, 56) == 56)
      {
        if (!uuid_is_null((const unsigned __int8 *)buffer))
        {
          if (gLogDatapath)
          {
            uint64_t v15 = __nwlog_obj();
            if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              uint64_t v18 = "nw_utilities_get_uuid_for_pid";
              __int16 v19 = 1024;
              int v20 = pid;
              __int16 v21 = 1040;
              int v22 = 16;
              __int16 v23 = 2096;
              char v24 = buffer;
              _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s Looked up PID (%d) -> UUID (%{uuid_t}.16P)", buf, 0x22u);
            }
          }
          *a2 = buffer[0];
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v4 = (id)gLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_utilities_get_uuid_for_pid";
          __int16 v19 = 1024;
          int v20 = pid;
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s Failed to convert from PID (%d) to UUID", buf, 0x12u);
        }
      }
    }
    return;
  }
  char v10 = __nwlog_obj();
  LODWORD(buffer[0]) = 136446210;
  *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  char v16 = 0;
  if (!__nwlog_fault(v6, buf, &v16)) {
    goto LABEL_44;
  }
  if (buf[0] == 17)
  {
    int v7 = __nwlog_obj();
    os_log_type_t v8 = buf[0];
    if (os_log_type_enabled(v7, (os_log_type_t)buf[0]))
    {
      LODWORD(buffer[0]) = 136446210;
      *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
      char v9 = "%{public}s called with null out_uuid";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if (!v16)
  {
    int v7 = __nwlog_obj();
    os_log_type_t v8 = buf[0];
    if (os_log_type_enabled(v7, (os_log_type_t)buf[0]))
    {
      LODWORD(buffer[0]) = 136446210;
      *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
      char v9 = "%{public}s called with null out_uuid, backtrace limit exceeded";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  __int16 v13 = (char *)__nw_create_backtrace_string();
  int v7 = __nwlog_obj();
  os_log_type_t v8 = buf[0];
  BOOL v14 = os_log_type_enabled(v7, (os_log_type_t)buf[0]);
  if (!v13)
  {
    if (v14)
    {
      LODWORD(buffer[0]) = 136446210;
      *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
      char v9 = "%{public}s called with null out_uuid, no backtrace";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if (v14)
  {
    LODWORD(buffer[0]) = 136446466;
    *(void *)((char *)buffer + 4) = "nw_utilities_get_uuid_for_pid";
    WORD6(buffer[0]) = 2082;
    *(void *)((char *)buffer + 14) = v13;
    _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null out_uuid, dumping backtrace:%{public}s", (uint8_t *)buffer, 0x16u);
  }

  free(v13);
  if (v6) {
    goto LABEL_45;
  }
}

BOOL nw_utilities_copy_bundle_id_for_uuid(const unsigned __int8 *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (uuid_is_null(a1))
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    int v22 = "nw_utilities_copy_bundle_id_for_uuid";
    __int16 v23 = 2080;
    *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
    char v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v9, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_utilities_copy_bundle_id_for_uuid";
          __int16 v23 = 2080;
          *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s NULL uuid passed to %s", buf, 0x16u);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v10 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446722;
            int v22 = "nw_utilities_copy_bundle_id_for_uuid";
            __int16 v23 = 2080;
            *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
            *(_WORD *)&v24[8] = 2082;
            *(void *)&v24[10] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v14, "%{public}s NULL uuid passed to %s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_utilities_copy_bundle_id_for_uuid";
          __int16 v23 = 2080;
          *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
          _os_log_impl(&dword_1830D4000, v10, v14, "%{public}s NULL uuid passed to %s, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        char v10 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_utilities_copy_bundle_id_for_uuid";
          __int16 v23 = 2080;
          *(void *)char v24 = "nw_utilities_copy_bundle_id_for_uuid";
          _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s NULL uuid passed to %s, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
LABEL_35:
    if (v9) {
      free(v9);
    }
    return 0;
  }
  id v2 = (void *)NEHelperCacheCopySigningIdentifierMapping();
  if (gLogDatapath)
  {
    BOOL v12 = __nwlog_obj();
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      int v22 = "nw_utilities_copy_bundle_id_for_uuid";
      __int16 v23 = 2112;
      *(void *)char v24 = v2;
      _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s NEHelperCacheCopySigningIdentifierMapping returned %@", buf, 0x16u);
    }
  }
  if (!v2) {
    goto LABEL_5;
  }
  if (object_getClass(v2) != (Class)MEMORY[0x1E4F145F0]) {
    goto LABEL_5;
  }
  string_ptr = xpc_string_get_string_ptr(v2);
  if (!string_ptr) {
    goto LABEL_5;
  }
  if (gLogDatapath)
  {
    os_log_type_t v17 = string_ptr;
    uint64_t v18 = __nwlog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446978;
      int v22 = "nw_utilities_copy_bundle_id_for_uuid";
      __int16 v23 = 1040;
      *(_DWORD *)char v24 = 16;
      *(_WORD *)&v24[4] = 2096;
      *(void *)&v24[6] = a1;
      *(_WORD *)&v24[14] = 2080;
      *(void *)&v24[16] = v17;
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s Looked up UUID (%{uuid_t}.16P) -> Bundle ID (%s)", buf, 0x26u);
    }

    string_ptr = v17;
  }
  id v3 = strdup(string_ptr);
  if (v3) {
    goto LABEL_6;
  }
  unsigned int v6 = __nwlog_obj();
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  int v22 = "strict_strdup";
  int v7 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
LABEL_5:
    id v3 = 0;
LABEL_6:

    return (BOOL)v3;
  }
  __break(1u);
  return result;
}

void sub_183A182F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_utilities_copy_bundle_id_for_pid(int a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    id v3 = __nwlog_obj();
    *(_DWORD *)uu = 136446210;
    *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
    int v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v4, &type, &v10)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
        int v7 = "%{public}s called with null pid";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, uu, 0xCu);
      }
    }
    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)uu = 136446466;
            *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
            *(_WORD *)&uu[12] = 2082;
            *(void *)&uu[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null pid, dumping backtrace:%{public}s", uu, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v9) {
          goto LABEL_19;
        }
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
        int v7 = "%{public}s called with null pid, no backtrace";
        goto LABEL_18;
      }
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)uu = 136446210;
        *(void *)&uu[4] = "nw_utilities_copy_bundle_id_for_pid";
        int v7 = "%{public}s called with null pid, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
LABEL_19:

LABEL_20:
    if (v4) {
      free(v4);
    }
    return 0;
  }
  if (a1 < 1) {
    return 0;
  }
  *(void *)uu = 0;
  *(void *)&uu[8] = 0;
  nw_utilities_get_uuid_for_pid(a1, uu);
  int is_null = uuid_is_null(uu);
  BOOL result = 0;
  if (!is_null) {
    return nw_utilities_copy_bundle_id_for_uuid(uu);
  }
  return result;
}

BOOL nw_utilities_copy_bundle_id_for_audit_token(long long *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  long long v1 = a1[1];
  long long v14 = *a1;
  long long v15 = v1;
  if (!((unint64_t)v14 | *((void *)&v14 + 1) | (unint64_t)v1 | *((void *)&v1 + 1)))
  {
    int v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
    __int16 v18 = 2080;
    char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v5, &type, &v12)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
        __int16 v18 = 2080;
        char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
        os_log_type_t v8 = "%{public}s NULL audit_token passed to %s";
LABEL_21:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x16u);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
            __int16 v18 = 2080;
            char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
            __int16 v20 = 2082;
            __int16 v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s NULL audit_token passed to %s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (!v11) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
        __int16 v18 = 2080;
        char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
        os_log_type_t v8 = "%{public}s NULL audit_token passed to %s, no backtrace";
        goto LABEL_21;
      }
      os_log_type_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
        __int16 v18 = 2080;
        char v19 = "nw_utilities_copy_bundle_id_for_audit_token";
        os_log_type_t v8 = "%{public}s NULL audit_token passed to %s, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_22:

LABEL_23:
    if (v5) {
      free(v5);
    }
    return 0;
  }
  int v2 = *((_DWORD *)a1 + 5);
  if (v2 < 1) {
    return 0;
  }
  if (gLogDatapath)
  {
    BOOL v9 = __nwlog_obj();
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v17 = "nw_utilities_copy_bundle_id_for_audit_token";
      __int16 v18 = 1024;
      LODWORD(v19) = v2;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s Looked up Audit Token -> PID (%d)", buf, 0x12u);
    }
  }
  return nw_utilities_copy_bundle_id_for_pid(v2);
}

void nw_utilities_get_self_uuid(_OWORD *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (nw_utilities_get_self_uuid::onceToken != -1) {
      dispatch_once(&nw_utilities_get_self_uuid::onceToken, &__block_literal_global_7_44674);
    }
    if (gLogDatapath)
    {
      os_log_type_t v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446978;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        __int16 v14 = 1024;
        *(_DWORD *)long long v15 = nw_utilities_get_self_uuid::self_pid;
        *(_WORD *)&v15[4] = 1040;
        *(_DWORD *)&v15[6] = 16;
        __int16 v16 = 2096;
        os_log_type_t v17 = &nw_utilities_get_self_uuid::self_uuid;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s Self UUID for pid %d: %{uuid_t}.16P", buf, 0x22u);
      }
    }
    *a1 = nw_utilities_get_self_uuid::self_uuid;
    return;
  }
  int v2 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v13 = "nw_utilities_get_self_uuid";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        os_log_type_t v6 = "%{public}s called with null out_uuid";
LABEL_23:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v9 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v13 = "nw_utilities_get_self_uuid";
            __int16 v14 = 2082;
            *(void *)long long v15 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null out_uuid, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (!v9) {
          goto LABEL_24;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        os_log_type_t v6 = "%{public}s called with null out_uuid, no backtrace";
        goto LABEL_23;
      }
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v13 = "nw_utilities_get_self_uuid";
        os_log_type_t v6 = "%{public}s called with null out_uuid, backtrace limit exceeded";
        goto LABEL_23;
      }
    }
LABEL_24:
  }
LABEL_25:
  if (v3) {
    free(v3);
  }
}

void __nw_utilities_get_self_uuid_block_invoke()
{
  pid_t v0 = getpid();
  nw_utilities_get_self_uuid::self_pid = v0;
  if (v0)
  {
    nw_utilities_get_uuid_for_pid(v0, &nw_utilities_get_self_uuid::self_uuid);
  }
}

uint64_t nw_utilities_get_self_bundle_id()
{
  if (nw_utilities_get_self_bundle_id::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_9);
  }
  return nw_utilities_get_self_bundle_id::bundle_identifier_string;
}

uint64_t nw_utilities_get_self_name()
{
  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_11_44681);
  }
  return nw_utilities_get_self_name::name;
}

uint64_t nw_utilities_get_user_agent()
{
  if (nw_utilities_get_user_agent::onceToken != -1) {
    dispatch_once(&nw_utilities_get_user_agent::onceToken, &__block_literal_global_13);
  }
  return nw_utilities_get_user_agent::user_agent_string;
}

void __nw_utilities_get_user_agent_block_invoke()
{
  CFAllocatorRef v0 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFMutableStringRef Mutable = CFStringCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0);
  MainBundle = CFBundleGetMainBundle();
  if (!MainBundle) {
    goto LABEL_14;
  }
  id v3 = MainBundle;
  CFDictionaryRef InfoDictionary = CFBundleGetInfoDictionary(MainBundle);
  if (InfoDictionary)
  {
    Value = CFDictionaryGetValue(InfoDictionary, (const void *)*MEMORY[0x1E4F1D008]);
    CFTypeRef ValueForInfoDictionaryKey = CFBundleGetValueForInfoDictionaryKey(v3, (CFStringRef)*MEMORY[0x1E4F1D020]);
    CFTypeRef v7 = ValueForInfoDictionaryKey;
    if (Value)
    {
      if (ValueForInfoDictionaryKey) {
        CFStringAppendFormat(Mutable, 0, @"%@/%@", Value, ValueForInfoDictionaryKey);
      }
      else {
        CFStringAppendFormat(Mutable, 0, @"%@", Value);
      }
      goto LABEL_14;
    }
  }
  else
  {
    CFTypeRef v7 = CFBundleGetValueForInfoDictionaryKey(v3, (CFStringRef)*MEMORY[0x1E4F1D020]);
  }
  if (nw_utilities_get_self_name::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_11_44681);
  }
  if (nw_utilities_get_self_name::name)
  {
    if (v7) {
      CFStringAppendFormat(Mutable, 0, @"%s/%@", nw_utilities_get_self_name::name, v7);
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"%s", nw_utilities_get_self_name::name);
    }
  }
LABEL_14:
  if (CFStringGetLength(Mutable) <= 0) {
    os_log_type_t v8 = "";
  }
  else {
    os_log_type_t v8 = " ";
  }
  CFStringAppendFormat(Mutable, 0, @"%sNetwork/%s", v8, "4277.60.255");
  BOOL v9 = (const void *)MGCopyAnswer();
  char v10 = (const void *)MGCopyAnswer();
  if (v9)
  {
    if (CFStringGetLength(Mutable) <= 0) {
      BOOL v11 = "";
    }
    else {
      BOOL v11 = " ";
    }
    if (v10) {
      CFStringAppendFormat(Mutable, 0, @"%s%@/%@", v11, v9, v10);
    }
    else {
      CFStringAppendFormat(Mutable, 0, @"%s%@", v11, 0);
    }
    CFRelease(v9);
  }
  if (v10) {
    CFRelease(v10);
  }
  CFCharacterSetRef URLPathAllowedCharacterSet = (const __CFCharacterSet *)_CFURLComponentsGetURLPathAllowedCharacterSet();
  MutableCopy = CFCharacterSetCreateMutableCopy(v0, URLPathAllowedCharacterSet);
  CFCharacterSetAddCharactersInString(MutableCopy, @" ");
  CFStringRef v14 = (const __CFString *)_CFStringCreateByAddingPercentEncodingWithAllowedCharacters();
  if (Mutable) {
    CFRelease(Mutable);
  }
  if (MutableCopy) {
    CFRelease(MutableCopy);
  }
  if (CFStringGetLength(v14) >= 1) {
    nw_utilities_get_user_agent::user_agent_string = nw_utilities_create_c_string_from_cfstring(v14);
  }
  if (v14)
  {
    CFRelease(v14);
  }
}

uint64_t nw_utilities_get_self_is_daemon()
{
  if (nw_utilities_get_self_is_daemon::onceToken != -1) {
    dispatch_once(&nw_utilities_get_self_is_daemon::onceToken, &__block_literal_global_48_44718);
  }
  return nw_utilities_get_self_is_daemon::is_daemon;
}

void __nw_utilities_get_self_is_daemon_block_invoke(double a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  gotLoadHelper_x19__OBJC_CLASS___RBSProcessHandle(a1);
  if (objc_opt_class()
    && ([*(id *)(v1 + 1008) currentProcess],
        int v2 = objc_claimAutoreleasedReturnValue(),
        char v3 = [v2 isDaemon],
        v2,
        (v3 & 1) != 0))
  {
    BOOL v4 = 1;
  }
  else
  {
    if (nw_utilities_get_self_bundle_id::onceToken != -1) {
      dispatch_once(&nw_utilities_get_self_bundle_id::onceToken, &__block_literal_global_9);
    }
    BOOL v4 = nw_utilities_get_self_bundle_id::bundle_identifier_string == 0;
  }
  nw_utilities_get_self_is_daemon::is_daemon = v4;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v5 = (id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
  {
    int v6 = 136446466;
    CFTypeRef v7 = "nw_utilities_get_self_is_daemon_block_invoke";
    __int16 v8 = 1024;
    int v9 = nw_utilities_get_self_is_daemon::is_daemon;
    _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s is_daemon: %{BOOL}d", (uint8_t *)&v6, 0x12u);
  }
}

void sub_183A190FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_utilities_convert_hex_string_to_bytes(const char *a1, size_t *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
    CFStringRef v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v14, &type, &v28)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null hex_string";
LABEL_53:
        _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
      }
LABEL_54:

      goto LABEL_55;
    }
    if (!v28)
    {
      long long v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null hex_string, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    long long v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v25 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null hex_string, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
      __int16 v32 = 2082;
      uint64_t v33 = (uint64_t)backtrace_string;
      uint64_t v26 = "%{public}s called with null hex_string, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_1830D4000, v15, v16, v26, buf, 0x16u);
    }
LABEL_44:

    free(backtrace_string);
    goto LABEL_55;
  }
  if (a2)
  {
    size_t v4 = strlen(a1);
    *a2 = 0;
    if (v4 <= 1)
    {
      char v19 = __nwlog_obj();
      os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      os_log_type_t v31 = "strict_calloc";
      __int16 v20 = (void *)_os_log_send_and_compose_impl();

      BOOL result = __nwlog_abort((uint64_t)v20);
      if (result)
      {
LABEL_58:
        __break(1u);
        return result;
      }
      free(v20);
    }
    os_log_type_t v5 = malloc_type_calloc(1uLL, v4 >> 1, 0xEAFB8F1AuLL);
    if (v5)
    {
      if (v4)
      {
LABEL_6:
        unint64_t v6 = 0;
        while (1)
        {
          int v9 = a1[v6];
          char v10 = v9 - 48;
          if ((v9 - 48) < 0xA) {
            goto LABEL_12;
          }
          if ((v9 - 97) <= 5) {
            break;
          }
          if ((v9 - 65) > 5)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v11 = (id)gLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              int v12 = a1[v6];
              *(_DWORD *)buf = 136446466;
              os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
              __int16 v32 = 1024;
              LODWORD(v33) = v12;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s Not hex character: %c", buf, 0x12u);
            }

            if (v5)
            {
              free(v5);
              return 0;
            }
            return (BOOL)v5;
          }
          char v10 = v9 - 55;
          if ((v6 & 1) == 0)
          {
LABEL_13:
            char v8 = 16 * v10;
            unint64_t v7 = v6 >> 1;
            goto LABEL_8;
          }
LABEL_7:
          unint64_t v7 = v6 >> 1;
          char v8 = *((unsigned char *)v5 + (v6 >> 1)) | v10;
LABEL_8:
          *((unsigned char *)v5 + v7) = v8;
          if (v4 == ++v6) {
            goto LABEL_33;
          }
        }
        char v10 = v9 - 87;
LABEL_12:
        if ((v6 & 1) == 0) {
          goto LABEL_13;
        }
        goto LABEL_7;
      }
LABEL_33:
      *a2 = v4 >> 1;
      return (BOOL)v5;
    }
    uint64_t v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v31 = "strict_calloc";
    __int16 v32 = 2048;
    uint64_t v33 = 1;
    __int16 v34 = 2048;
    size_t v35 = v4 >> 1;
    __int16 v23 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v23);
    if (!result)
    {
      free(v23);
      if (v4) {
        goto LABEL_6;
      }
      goto LABEL_33;
    }
    goto LABEL_58;
  }
  uint64_t v18 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
  CFStringRef v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v14, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null output_buffer_length";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (!v28)
    {
      long long v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null output_buffer_length, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    long long v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v27 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
        os_log_type_t v17 = "%{public}s called with null output_buffer_length, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v31 = "nw_utilities_convert_hex_string_to_bytes";
      __int16 v32 = 2082;
      uint64_t v33 = (uint64_t)backtrace_string;
      uint64_t v26 = "%{public}s called with null output_buffer_length, dumping backtrace:%{public}s";
      goto LABEL_43;
    }
    goto LABEL_44;
  }
LABEL_55:
  if (v14) {
    free(v14);
  }
  return 0;
}

uint64_t nw_utilities_execute_block_as_persona(const unsigned __int8 *a1, void *a2)
{
  *(void *)&v30[13] = *MEMORY[0x1E4F143B8];
  size_t v4 = a2;
  if (!v4)
  {
    os_log_type_t v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v28 = "nw_utilities_execute_block_as_persona";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v17, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          char v28 = "nw_utilities_execute_block_as_persona";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null block", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v18 = __nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            char v28 = "nw_utilities_execute_block_as_persona";
            __int16 v29 = 2082;
            *(void *)uint64_t v30 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          char v28 = "nw_utilities_execute_block_as_persona";
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null block, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v18 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          char v28 = "nw_utilities_execute_block_as_persona";
          _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v17) {
      free(v17);
    }
    goto LABEL_4;
  }
  if (uuid_is_null(a1) || (gotLoadHelper_x22__OBJC_CLASS___UMUserPersona(v5), !objc_opt_class()))
  {
    v4[2](v4);
LABEL_4:
    uint64_t v6 = 0;
    goto LABEL_9;
  }
  unint64_t v7 = (void *)[objc_alloc(MEMORY[0x1E4F29128]) initWithUUIDBytes:a1];
  char v8 = [v7 UUIDString];
  int v9 = [*(id *)(v2 + 1800) currentPersona];
  id v24 = 0;
  char v10 = (void *)[v9 copyCurrentPersonaContextWithError:&v24];
  id v11 = v24;
  int v12 = [v9 generateAndRestorePersonaContextWithPersonaUniqueString:v8];

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (id)gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)buf = 136446722;
    char v28 = "nw_utilities_execute_block_as_persona";
    __int16 v29 = 1040;
    *(_DWORD *)uint64_t v30 = 16;
    v30[2] = 2096;
    *(void *)&v30[3] = a1;
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s Executing block as persona %{uuid_t}.16P", buf, 0x1Cu);
  }

  v4[2](v4);
  id v14 = (id)[v9 restorePersonaWithSavedPersonaContext:v10];

  uint64_t v6 = 1;
LABEL_9:

  return v6;
}

void sub_183A19B80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_protocol_socksv4_copy_definition()
{
  if (nw_protocol_socksv4_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_socksv4_copy_definition::onceToken, &__block_literal_global_44786);
  }
  BOOL result = (void *)nw_protocol_socksv4_copy_definition::definition;
  if (nw_protocol_socksv4_copy_definition::definition)
  {
    return os_retain(result);
  }
  return result;
}

BOOL __nw_protocol_socksv4_copy_definition_block_invoke()
{
  nw_protocol_definition_t definition = nw_framer_create_definition("socksv4", 0, &__block_literal_global_9_44791);
  nw_protocol_socksv4_copy_definition::nw_protocol_definition_t definition = (uint64_t)definition;

  return nw_protocol_definition_register(definition);
}

uint64_t __nw_protocol_socksv4_copy_definition_block_invoke_2(uint64_t a1, NSObject *a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  char v3 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v3)
  {
LABEL_2:
    v3[2] = 0;
    nw_parameters_t v4 = nw_framer_copy_parameters(a2);
    if (v4)
    {
      double v5 = v4;
      id v6 = v5[23];

      if (v6)
      {
        unint64_t v7 = (id *)v6;
        id v8 = v7[13];

        if (v8)
        {
          int v9 = v8;
          char v10 = (const char *)v9[2];

          if (v10) {
            *(void *)char v3 = xpc_string_create(v10);
          }
        }
        os_release(v7);
      }
      os_release(v5);
    }
    input_handler[0] = MEMORY[0x1E4F143A8];
    input_handler[1] = 0x40000000;
    input_handler[2] = __nw_protocol_socksv4_copy_definition_block_invoke_3;
    input_handler[3] = &__block_descriptor_tmp_14_44797;
    input_handler[4] = v3;
    input_handler[5] = a2;
    nw_framer_set_input_handler(a2, input_handler);
    output_handler[0] = MEMORY[0x1E4F143A8];
    output_handler[1] = 0x40000000;
    output_handler[2] = __nw_protocol_socksv4_copy_definition_block_invoke_2_15;
    output_handler[3] = &__block_descriptor_tmp_17_44798;
    output_handler[4] = v3;
    nw_framer_set_output_handler(a2, output_handler);
    cleanup_handler[0] = MEMORY[0x1E4F143A8];
    cleanup_handler[1] = 0x40000000;
    cleanup_handler[2] = __nw_protocol_socksv4_copy_definition_block_invoke_3_18;
    cleanup_handler[3] = &__block_descriptor_tmp_20_44799;
    cleanup_handler[4] = v3;
    nw_framer_set_cleanup_handler(a2, cleanup_handler);
    if (a2)
    {
      nw_endpoint_t v11 = nw_framer_copy_remote_endpoint(a2);
      BOOL v12 = nw_endpoint_copy_proxy_original_endpoint(v11);
      if (v11) {
        os_release(v11);
      }
      nw_endpoint_type_t v13 = nw_endpoint_get_type((nw_endpoint_t)v12);
      bzero(&v67, 0x204uLL);
      *(_WORD *)output_buffer = 260;
      *(_WORD *)&output_buffer[2] = __rev16(nw_endpoint_get_port((nw_endpoint_t)v12));
      if (v13 == nw_endpoint_type_address)
      {
        address = nw_endpoint_get_address((nw_endpoint_t)v12);
        if (address->sa_family == 30)
        {
          if (gLogDatapath)
          {
            BOOL v54 = __nwlog_obj();
            if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446210;
              v61 = "nw_socksv4_send_connect";
              _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEBUG, "%{public}s IPv6 is not supported with SOCKSv4", buf, 0xCu);
            }
          }
          nw_framer_mark_failed_with_error(a2, 43);
          if (!v12) {
            return 2;
          }
          goto LABEL_85;
        }
        LODWORD(v67) = *(_DWORD *)&address->sa_data[2];
        if (!*(void *)v3) {
          goto LABEL_81;
        }
        string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)v3);
        if (!string_ptr) {
          goto LABEL_81;
        }
        id v24 = string_ptr;
        size_t v25 = strlen(string_ptr);
        size_t v18 = v25;
        if (!v25) {
          goto LABEL_82;
        }
        if (v25 < 0xFF)
        {
          memcpy((char *)&v67 + 4, v24, v25);
          goto LABEL_82;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        v61 = "nw_socksv4_send_connect";
        __int16 v62 = 2048;
        size_t v63 = v18;
        uint64_t v26 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v58 = 0;
        if (__nwlog_fault(v26, &type, &v58))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            BOOL v27 = __nwlog_obj();
            os_log_type_t v28 = type;
            if (!os_log_type_enabled(v27, type)) {
              goto LABEL_79;
            }
            *(_DWORD *)buf = 136446466;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v18;
            __int16 v29 = "%{public}s SOCKS (by address) username has invalid length %zu";
            goto LABEL_78;
          }
          if (!v58)
          {
            BOOL v27 = __nwlog_obj();
            os_log_type_t v28 = type;
            if (!os_log_type_enabled(v27, type)) {
              goto LABEL_79;
            }
            *(_DWORD *)buf = 136446466;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v18;
            __int16 v29 = "%{public}s SOCKS (by address) username has invalid length %zu, backtrace limit exceeded";
            goto LABEL_78;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v27 = __nwlog_obj();
          os_log_type_t v28 = type;
          BOOL v33 = os_log_type_enabled(v27, type);
          if (backtrace_string)
          {
            if (v33)
            {
              *(_DWORD *)buf = 136446722;
              v61 = "nw_socksv4_send_connect";
              __int16 v62 = 2048;
              size_t v63 = v18;
              __int16 v64 = 2082;
              uint64_t v65 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s SOCKS (by address) username has invalid length %zu, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_79;
          }
          if (v33)
          {
            *(_DWORD *)buf = 136446466;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v18;
            __int16 v29 = "%{public}s SOCKS (by address) username has invalid length %zu, no backtrace";
LABEL_78:
            _os_log_impl(&dword_1830D4000, v27, v28, v29, buf, 0x16u);
          }
        }
LABEL_79:
        if (v26) {
          free(v26);
        }
LABEL_81:
        LODWORD(v1_Block_object_dispose(&a9, 8) = 0;
        goto LABEL_82;
      }
      LODWORD(v67) = 0x10000000;
      if (!*(void *)v3) {
        goto LABEL_52;
      }
      long long v15 = xpc_string_get_string_ptr(*(xpc_object_t *)v3);
      if (!v15) {
        goto LABEL_52;
      }
      os_log_type_t v16 = v15;
      size_t v17 = strlen(v15);
      size_t v18 = v17;
      if (v17)
      {
        if (v17 >= 0xFF)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136446466;
          v61 = "nw_socksv4_send_connect";
          __int16 v62 = 2048;
          size_t v63 = v18;
          os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v58 = 0;
          if (!__nwlog_fault(v19, &type, &v58)) {
            goto LABEL_50;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v20 = gLogObj;
            os_log_type_t v21 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_50;
            }
            *(_DWORD *)buf = 136446466;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v18;
            BOOL v22 = "%{public}s SOCKS (by host) username has invalid length %zu";
          }
          else if (v58)
          {
            uint64_t v30 = (char *)__nw_create_backtrace_string();
            __int16 v20 = __nwlog_obj();
            os_log_type_t v21 = type;
            BOOL v31 = os_log_type_enabled(v20, type);
            if (v30)
            {
              if (v31)
              {
                *(_DWORD *)buf = 136446722;
                v61 = "nw_socksv4_send_connect";
                __int16 v62 = 2048;
                size_t v63 = v18;
                __int16 v64 = 2082;
                uint64_t v65 = v30;
                _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s SOCKS (by host) username has invalid length %zu, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v30);
              goto LABEL_50;
            }
            if (!v31)
            {
LABEL_50:
              if (v19) {
                free(v19);
              }
LABEL_52:
              LODWORD(v1_Block_object_dispose(&a9, 8) = 0;
              goto LABEL_53;
            }
            *(_DWORD *)buf = 136446466;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v18;
            BOOL v22 = "%{public}s SOCKS (by host) username has invalid length %zu, no backtrace";
          }
          else
          {
            __int16 v20 = __nwlog_obj();
            os_log_type_t v21 = type;
            if (!os_log_type_enabled(v20, type)) {
              goto LABEL_50;
            }
            *(_DWORD *)buf = 136446466;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v18;
            BOOL v22 = "%{public}s SOCKS (by host) username has invalid length %zu, backtrace limit exceeded";
          }
          _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0x16u);
          goto LABEL_50;
        }
        memcpy((char *)&v67 + 4, v16, v17);
      }
LABEL_53:
      *((unsigned char *)&v67 + v18 + 4) = 0;
      LODWORD(v1_Block_object_dispose(&a9, 8) = v18 + 1;
      hostname = nw_endpoint_get_hostname((nw_endpoint_t)v12);
      if (!hostname) {
        goto LABEL_82;
      }
      size_t v35 = hostname;
      size_t v36 = strlen(hostname);
      if (!v36) {
        goto LABEL_82;
      }
      size_t v37 = v36;
      if (v36 < 0xFF)
      {
        memcpy((char *)&v67 + v18 + 4, v35, v36);
        LODWORD(v1_Block_object_dispose(&a9, 8) = v18 + v37;
        goto LABEL_82;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446466;
      v61 = "nw_socksv4_send_connect";
      __int16 v62 = 2048;
      size_t v63 = v37;
      os_log_type_t v38 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v58 = 0;
      if (__nwlog_fault(v38, &type, &v58))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v39 = gLogObj;
          os_log_type_t v40 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_71;
          }
          *(_DWORD *)buf = 136446466;
          v61 = "nw_socksv4_send_connect";
          __int16 v62 = 2048;
          size_t v63 = v37;
          BOOL v41 = "%{public}s SOCKS hostname has invalid length %zu";
          goto LABEL_70;
        }
        if (!v58)
        {
          char v39 = __nwlog_obj();
          os_log_type_t v40 = type;
          if (!os_log_type_enabled(v39, type)) {
            goto LABEL_71;
          }
          *(_DWORD *)buf = 136446466;
          v61 = "nw_socksv4_send_connect";
          __int16 v62 = 2048;
          size_t v63 = v37;
          BOOL v41 = "%{public}s SOCKS hostname has invalid length %zu, backtrace limit exceeded";
          goto LABEL_70;
        }
        uint64_t v42 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v39 = gLogObj;
        os_log_type_t v40 = type;
        BOOL v43 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446722;
            v61 = "nw_socksv4_send_connect";
            __int16 v62 = 2048;
            size_t v63 = v37;
            __int16 v64 = 2082;
            uint64_t v65 = v42;
            _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s SOCKS hostname has invalid length %zu, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v42);
          goto LABEL_71;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446466;
          v61 = "nw_socksv4_send_connect";
          __int16 v62 = 2048;
          size_t v63 = v37;
          BOOL v41 = "%{public}s SOCKS hostname has invalid length %zu, no backtrace";
LABEL_70:
          _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, 0x16u);
        }
      }
LABEL_71:
      if (v38) {
        free(v38);
      }
LABEL_82:
      *((unsigned char *)&v67 + v18 + 4) = 0;
      nw_framer_write_output(a2, output_buffer, (v18 + 9));
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v44 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        v61 = "nw_socksv4_send_connect";
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Sent client request", buf, 0xCu);
      }
      v3[2] = 1;
      if (!v12) {
        return 2;
      }
LABEL_85:
      os_release((void *)v12);
      return 2;
    }
    __nwlog_obj();
    *(_DWORD *)output_buffer = 136446210;
    os_log_type_t v67 = "nw_socksv4_send_connect";
    long long v48 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v48, buf, &type))
    {
      if (buf[0] == 17)
      {
        long long v49 = __nwlog_obj();
        os_log_type_t v50 = buf[0];
        if (!os_log_type_enabled(v49, (os_log_type_t)buf[0])) {
          goto LABEL_105;
        }
        *(_DWORD *)output_buffer = 136446210;
        os_log_type_t v67 = "nw_socksv4_send_connect";
        long long v51 = "%{public}s called with null framer";
        goto LABEL_104;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        long long v49 = __nwlog_obj();
        os_log_type_t v50 = buf[0];
        if (!os_log_type_enabled(v49, (os_log_type_t)buf[0])) {
          goto LABEL_105;
        }
        *(_DWORD *)output_buffer = 136446210;
        os_log_type_t v67 = "nw_socksv4_send_connect";
        long long v51 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_104;
      }
      BOOL v52 = (char *)__nw_create_backtrace_string();
      long long v49 = __nwlog_obj();
      os_log_type_t v50 = buf[0];
      BOOL v53 = os_log_type_enabled(v49, (os_log_type_t)buf[0]);
      if (v52)
      {
        if (v53)
        {
          *(_DWORD *)output_buffer = 136446466;
          os_log_type_t v67 = "nw_socksv4_send_connect";
          __int16 v68 = 2082;
          uint64_t v69 = (uint64_t)v52;
          _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null framer, dumping backtrace:%{public}s", output_buffer, 0x16u);
        }
        free(v52);
        goto LABEL_105;
      }
      if (v53)
      {
        *(_DWORD *)output_buffer = 136446210;
        os_log_type_t v67 = "nw_socksv4_send_connect";
        long long v51 = "%{public}s called with null framer, no backtrace";
LABEL_104:
        _os_log_impl(&dword_1830D4000, v49, v50, v51, output_buffer, 0xCu);
      }
    }
LABEL_105:
    if (v48) {
      free(v48);
    }
    return 2;
  }
  os_log_type_t v46 = __nwlog_obj();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *(_DWORD *)output_buffer = 136446722;
  os_log_type_t v67 = "strict_calloc";
  __int16 v68 = 2048;
  uint64_t v69 = 1;
  __int16 v70 = 2048;
  uint64_t v71 = 16;
  os_log_type_t v47 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v47);
  if (!result)
  {
    free(v47);
    goto LABEL_2;
  }
  __break(1u);
  return result;
}

uint64_t __nw_protocol_socksv4_copy_definition_block_invoke_3(uint64_t a1, nw_framer_t framer)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  int v5 = *(_DWORD *)(v4 + 8);
  if (v5 != 1)
  {
    if (!v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_socksv4_copy_definition_block_invoke_3";
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s Reading packets in initial state", (uint8_t *)&buf, 0xCu);
      }
      return 0;
    }
LABEL_7:
    if (v5 == 2)
    {
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v16 = 0x2000000000;
      size_t v17 = 0;
      *(void *)temp_buffer = 0;
      BOOL v12 = temp_buffer;
      uint64_t v13 = 0x2000000000;
      char v14 = 0;
      v10[0] = MEMORY[0x1E4F143A8];
      v10[1] = 0x40000000;
      v10[2] = __nw_protocol_socksv4_copy_definition_block_invoke_10;
      v10[3] = &unk_1E5241FF8;
      v10[4] = &buf;
      v10[5] = temp_buffer;
      nw_framer_parse_input(framer, 1uLL, 0xFFFFFFFFuLL, 0, v10);
      id v8 = nw_framer_message_create(*(nw_framer_t *)(a1 + 40));
      nw_framer_deliver_input_no_copy(framer, *(void *)(*((void *)&buf + 1) + 24), v8, v12[24]);
      if (v8) {
        os_release(v8);
      }
      _Block_object_dispose(temp_buffer, 8);
      _Block_object_dispose(&buf, 8);
    }
    return 0;
  }
  *(void *)temp_buffer = 0;
  *(void *)&long long buf = MEMORY[0x1E4F143A8];
  *((void *)&buf + 1) = 0x40000000;
  uint64_t v16 = (uint64_t)___ZL24nw_socksv4_parse_connectP9nw_framerP10nw_socksv4_block_invoke;
  size_t v17 = &__block_descriptor_tmp_27_44826;
  nw_framer_t v18 = framer;
  uint64_t v19 = v4;
  uint64_t v7 = 8;
  if (nw_framer_parse_input(framer, 8uLL, 8uLL, temp_buffer, &buf))
  {
    int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 8);
    goto LABEL_7;
  }
  return v7;
}

BOOL __nw_protocol_socksv4_copy_definition_block_invoke_2_15(BOOL result, nw_framer_t framer, int a3, size_t output_length)
{
  if (*(_DWORD *)(*(void *)(result + 32) + 8) == 2) {
    return nw_framer_write_output_no_copy(framer, output_length);
  }
  return result;
}

void __nw_protocol_socksv4_copy_definition_block_invoke_3_18(uint64_t a1)
{
  uint64_t v2 = *(xpc_object_t **)(a1 + 32);
  if (!*v2 || (xpc_release(*v2), **(void **)(a1 + 32) = 0, (uint64_t v2 = *(xpc_object_t **)(a1 + 32)) != 0))
  {
    free(v2);
  }
}

uint64_t ___ZL24nw_socksv4_parse_connectP9nw_framerP10nw_socksv4_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (*a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v5 = *a2;
      int v12 = 136446466;
      uint64_t v13 = "nw_socksv4_parse_connect_block_invoke";
      __int16 v14 = 1024;
      int v15 = v5;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s SOCKSv4 replies must start will a NULL byte, received 0x%x", (uint8_t *)&v12, 0x12u);
    }
    id v6 = *(NSObject **)(a1 + 32);
    int v7 = 100;
LABEL_12:
    nw_framer_mark_failed_with_error(v6, v7);
    return 8;
  }
  int v8 = a2[1];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v9 = gLogObj;
  if (v8 != 90)
  {
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v10 = a2[1];
      int v12 = 136446466;
      uint64_t v13 = "nw_socksv4_parse_connect_block_invoke";
      __int16 v14 = 1024;
      int v15 = v10;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s Received SOCKS connect status %d, failing", (uint8_t *)&v12, 0x12u);
    }
    id v6 = *(NSObject **)(a1 + 32);
    int v7 = 1;
    goto LABEL_12;
  }
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    int v12 = 136446210;
    uint64_t v13 = "nw_socksv4_parse_connect_block_invoke";
    _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s Received complete connect message from SOCKS server", (uint8_t *)&v12, 0xCu);
  }
  *(_DWORD *)(*(void *)(a1 + 40) + _Block_object_dispose(&a9, 8) = 2;
  nw_framer_pass_through_input(*(nw_framer_t *)(a1 + 32));
  nw_framer_pass_through_output(*(nw_framer_t *)(a1 + 32));
  nw_framer_mark_ready(*(nw_framer_t *)(a1 + 32));
  return 8;
}

uint64_t __nw_protocol_socksv4_copy_definition_block_invoke_10(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a4;
  return 0;
}

uint64_t __Block_byref_object_copy__44835(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(unsigned char *)(result + 4_Block_object_dispose(&a9, 8) = *(unsigned char *)(result + 48) & 0xFE | *(unsigned char *)(a2 + 48) & 1;
  *(void *)(a2 + 40) = 0;
  *(unsigned char *)(a2 + 48) &= ~1u;
  return result;
}

void __Block_byref_object_dispose__44836(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 48))
  {
    uint64_t v2 = *(const void **)(a1 + 40);
    if (v2) {
      _Block_release(v2);
    }
  }
  *(void *)(a1 + 40) = 0;
}

void ____nwlog_fault_block_invoke(uint64_t a1)
{
  if (s_override_fault_handler)
  {
    uint64_t v2 = _Block_copy((const void *)s_override_fault_handler);
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 8);
    char v4 = *(unsigned char *)(v3 + 48);
    if (v4)
    {
      int v5 = *(const void **)(v3 + 40);
      if (v5)
      {
        _Block_release(v5);
        char v4 = *(unsigned char *)(v3 + 48);
      }
    }
    *(void *)(v3 + 40) = v2;
    *(unsigned char *)(v3 + 4_Block_object_dispose(&a9, 8) = v4 | 1;
  }
}

uint64_t ____nwlog_fault_block_invoke_2(uint64_t result)
{
  if (!*(unsigned char *)(result + 48))
  {
    int v1 = __nwlog_fault::num_faults;
    if (__nwlog_fault::num_faults <= 0x18)
    {
      **(unsigned char **)(result + 32) = 17;
      __nwlog_fault::num_faults = v1 + 1;
    }
    int v2 = __nwlog_fault::num_backtraces;
    if (__nwlog_fault::num_backtraces <= 0x63)
    {
      **(unsigned char **)(result + 40) = 1;
      __nwlog_fault::num_backtraces = v2 + 1;
    }
  }
  return result;
}

BOOL __nw_should_fault()
{
  return !networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_disable_simulate_crash);
}

void __Block_byref_object_copy__2(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__3(uint64_t a1)
{
}

void *____nwlog_abort_block_invoke(uint64_t a1)
{
  uint64_t result = (void *)s_abort_override_handler;
  if (s_abort_override_handler)
  {
    uint64_t result = _Block_copy((const void *)s_abort_override_handler);
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = result;
  }
  return result;
}

uint64_t __nw_should_log_backtrace()
{
  uint64_t v3 = 0;
  char v4 = &v3;
  uint64_t v5 = 0x2000000000;
  char v6 = 0;
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 0x40000000;
  v2[2] = ____nw_should_log_backtrace_block_invoke;
  v2[3] = &unk_1E5242110;
  v2[4] = &v3;
  os_unfair_lock_lock(&__nw_should_log_backtrace::backtrace_lock);
  ____nw_should_log_backtrace_block_invoke((uint64_t)v2);
  os_unfair_lock_unlock(&__nw_should_log_backtrace::backtrace_lock);
  uint64_t v0 = *((unsigned __int8 *)v4 + 24);
  _Block_object_dispose(&v3, 8);
  return v0;
}

uint64_t ____nw_should_log_backtrace_block_invoke(uint64_t result)
{
  int v1 = __nw_should_log_backtrace::num_backtraces;
  if (__nw_should_log_backtrace::num_backtraces <= 0x31)
  {
    *(unsigned char *)(*(void *)(*(void *)(result + 32) + 8) + 24) = 1;
    __nw_should_log_backtrace::num_backtraces = v1 + 1;
  }
  return result;
}

uint64_t __nwlog_override_fault_block(uint64_t a1, const void *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  pthread_rwlock_wrlock(&s_fault_lock);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v15 = 0x3802000000;
  uint64_t v16 = __Block_byref_object_copy__44835;
  size_t v17 = __Block_byref_object_dispose__44836;
  aBlock = 0;
  char v19 = -1;
  uint64_t v8 = MEMORY[0x1E4F143A8];
  uint64_t v9 = 0x40000000;
  int v10 = ____nwlog_set_override_fault_handler_block_invoke;
  nw_endpoint_t v11 = &unk_1E5242138;
  int v12 = a2;
  p_long long buf = &buf;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_set_override_fault_handler_block_invoke((uint64_t)&v8);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  char v4 = *(const void **)(*((void *)&buf + 1) + 40);
  *(void *)(*((void *)&buf + 1) + 40) = 0;
  _Block_object_dispose(&buf, 8);
  if ((v19 & 1) != 0 && aBlock) {
    _Block_release(aBlock);
  }
  (*(void (**)(uint64_t))(a1 + 16))(a1);
  *(void *)&long long buf = 0;
  *((void *)&buf + 1) = &buf;
  uint64_t v15 = 0x3802000000;
  uint64_t v16 = __Block_byref_object_copy__44835;
  size_t v17 = __Block_byref_object_dispose__44836;
  aBlock = 0;
  char v19 = -1;
  uint64_t v8 = MEMORY[0x1E4F143A8];
  uint64_t v9 = 0x40000000;
  int v10 = ____nwlog_set_override_fault_handler_block_invoke;
  nw_endpoint_t v11 = &unk_1E5242138;
  int v12 = v4;
  p_long long buf = &buf;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  v10((uint64_t)&v8);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  uint64_t v5 = *(const void **)(*((void *)&buf + 1) + 40);
  *(void *)(*((void *)&buf + 1) + 40) = 0;
  _Block_object_dispose(&buf, 8);
  if ((v19 & 1) != 0 && aBlock) {
    _Block_release(aBlock);
  }
  _Block_release(v4);
  if (v5 != a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf) = 136446210;
      *(void *)((char *)&buf + 4) = "__nwlog_override_fault_block";
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s __nwlog_set_override_fault_handler called while in block", (uint8_t *)&buf, 0xCu);
    }
  }
  _Block_release(v5);
  return pthread_rwlock_unlock(&s_fault_lock);
}

void ____nwlog_set_override_fault_handler_block_invoke(uint64_t a1)
{
  if (s_override_fault_handler) {
    int v2 = _Block_copy((const void *)s_override_fault_handler);
  }
  else {
    int v2 = 0;
  }
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  char v4 = *(unsigned char *)(v3 + 48);
  if (v4)
  {
    uint64_t v5 = *(const void **)(v3 + 40);
    if (v5)
    {
      _Block_release(v5);
      char v4 = *(unsigned char *)(v3 + 48);
    }
  }
  *(void *)(v3 + 40) = v2;
  *(unsigned char *)(v3 + 4_Block_object_dispose(&a9, 8) = v4 | 1;
  char v6 = *(const void **)(a1 + 32);
  if (!v6)
  {
    int v7 = 0;
    uint64_t v8 = (const void *)s_override_fault_handler;
    if (!s_override_fault_handler) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  int v7 = _Block_copy(v6);
  uint64_t v8 = (const void *)s_override_fault_handler;
  if (s_override_fault_handler) {
LABEL_9:
  }
    _Block_release(v8);
LABEL_10:
  s_override_fault_handler = (uint64_t)v7;
}

uint64_t __nwlog_set_override_fault_handler(uint64_t a1)
{
  uint64_t v4 = 0;
  uint64_t v5 = &v4;
  uint64_t v6 = 0x3802000000;
  int v7 = __Block_byref_object_copy__44835;
  uint64_t v8 = __Block_byref_object_dispose__44836;
  aBlock = 0;
  char v10 = -1;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ____nwlog_set_override_fault_handler_block_invoke;
  v3[3] = &unk_1E5242138;
  v3[4] = a1;
  v3[5] = &v4;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_set_override_fault_handler_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  uint64_t v1 = v5[5];
  v5[5] = 0;
  _Block_object_dispose(&v4, 8);
  if ((v10 & 1) != 0 && aBlock) {
    _Block_release(aBlock);
  }
  return v1;
}

void __nwlog_override_abort_block(uint64_t a1, uint64_t a2)
{
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 0x40000000;
  v3[2] = ____nwlog_override_abort_block_block_invoke;
  v3[3] = &unk_1E5242160;
  v3[4] = a2;
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_override_abort_block_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  (*(void (**)(uint64_t))(a1 + 16))(a1);
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  ____nwlog_override_abort_block_block_invoke_2();
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
}

uint64_t ____nwlog_override_abort_block_block_invoke(uint64_t result)
{
  s_abort_override_handler = *(void *)(result + 32);
  return result;
}

void ____nwlog_override_abort_block_block_invoke_2()
{
  s_abort_override_handler = 0;
}

uint64_t __nwlog_activity_log()
{
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  return gactivityLogObj;
}

uint64_t __nwlog_browser_log()
{
  if (__nwlog_browser_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
  }
  return gbrowserLogObj;
}

void ____nwlog_browser_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gbrowserLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "browser");
  }
}

uint64_t __nwlog_candidate_manager_log()
{
  if (__nwlog_candidate_manager_log::onceToken != -1) {
    dispatch_once(&__nwlog_candidate_manager_log::onceToken, &__block_literal_global_24);
  }
  return gcandidate_managerLogObj;
}

void ____nwlog_candidate_manager_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gcandidate_managerLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "candidate_manager");
  }
}

uint64_t __nwlog_connection_log()
{
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  return gconnectionLogObj;
}

uint64_t __nwlog_connection_group_log()
{
  if (__nwlog_connection_group_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_group_log::onceToken, &__block_literal_global_32);
  }
  return gconnection_groupLogObj;
}

void ____nwlog_connection_group_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gconnection_groupLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "connection_group");
  }
}

uint64_t __nwlog_http_log()
{
  if (__nwlog_http_log::onceToken != -1) {
    dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
  }
  return ghttpLogObj;
}

void ____nwlog_http_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    ghttpLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "http");
  }
}

uint64_t __nwlog_listener_log()
{
  if (__nwlog_listener_log::onceToken != -1) {
    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
  }
  return glistenerLogObj;
}

uint64_t __nwlog_metrics_log()
{
  if (__nwlog_metrics_log::onceToken != -1) {
    dispatch_once(&__nwlog_metrics_log::onceToken, &__block_literal_global_44);
  }
  return gmetricsLogObj;
}

void ____nwlog_metrics_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gmetricsLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "metrics");
  }
}

uint64_t __nwlog_path_log()
{
  if (__nwlog_path_log::onceToken != -1) {
    dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_48_44893);
  }
  return gpathLogObj;
}

uint64_t __nwlog_privacy_proxy_log()
{
  if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
  }
  return gprivacy_proxyLogObj;
}

void ____nwlog_privacy_proxy_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gprivacy_proxyLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "privacy_proxy");
  }
}

uint64_t __nwlog_network_test_log()
{
  if (__nwlog_network_test_log::onceToken != -1) {
    dispatch_once(&__nwlog_network_test_log::onceToken, &__block_literal_global_60_44905);
  }
  return gnetwork_testLogObj;
}

void ____nwlog_network_test_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gnetwork_testLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "network_test");
  }
}

uint64_t __nwlog_metricstream_log()
{
  if (__nwlog_metricstream_log::onceToken != -1) {
    dispatch_once(&__nwlog_metricstream_log::onceToken, &__block_literal_global_64);
  }
  return gmetricstreamLogObj;
}

void ____nwlog_metricstream_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gmetricstreamLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "metricstream");
  }
}

uint64_t __nwlog_url_log()
{
  if (__nwlog_url_log::onceToken != -1) {
    dispatch_once(&__nwlog_url_log::onceToken, &__block_literal_global_68_44915);
  }
  return gurlLogObj;
}

uint64_t nwlog_get_private_redacted()
{
  if (nwlog_get_private_redacted::onceToken != -1) {
    dispatch_once(&nwlog_get_private_redacted::onceToken, &__block_literal_global_72);
  }
  return nwlog_get_private_redacted::privateRedacted;
}

uint64_t nwlog_get_sensitive_redacted()
{
  if (nwlog_get_sensitive_redacted::onceToken != -1) {
    dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
  }
  return nwlog_get_sensitive_redacted::sensitiveRedacted;
}

void __nwlog_handle_composed(uint64_t a1, uint64_t a2)
{
  if (gLogFDOverride != -1)
  {
    if (a2)
    {
      uint64_t v3 = 1000 * *(int *)(a2 + 8);
      *(void *)&long long v7 = *(void *)a2;
      *((void *)&v7 + 1) = v3;
    }
    else
    {
      mach_get_times();
    }
    v4[0] = MEMORY[0x1E4F143A8];
    v4[1] = 0x40000000;
    v4[2] = ____nwlog_handle_composed_block_invoke;
    v4[3] = &__block_descriptor_tmp_80_44931;
    long long v5 = v7;
    uint64_t v6 = a1;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
    ____nwlog_handle_composed_block_invoke((uint64_t)v4);
    os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  }
}

uint64_t ____nwlog_handle_composed_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if ((_ZZZ23__nwlog_handle_composedEUb_E9tz_is_set & 1) == 0)
  {
    tzset();
    _ZZZ23__nwlog_handle_composedEUb_E9tz_is_set = 1;
  }
  memset(&v4, 0, sizeof(v4));
  int v2 = localtime_r((const time_t *)(a1 + 32), &v4);
  if (!strftime(v5, 9uLL, "%T", v2)) {
    return dprintf(gLogFDOverride, "%s\n");
  }
  v5[8] = 0;
  return dprintf(gLogFDOverride, "%s.%06lu %s\n");
}

void __nwlog_run_with_lock(uint64_t a1)
{
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  (*(void (**)(uint64_t))(a1 + 16))(a1);

  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
}

uint64_t __nwlog_override_fd(int a1)
{
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  uint64_t v2 = gLogFDOverride;
  gLogFDOverride = a1;
  if ((a1 & 0x80000000) == 0)
  {
    gLogDatapath = 1;
    gLogDatapathOverridden = 1;
  }
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = __nw_utilities_set_log_intercept_block_invoke;
  v4[3] = &__block_descriptor_33_e5_v8__0l;
  BOOL v5 = a1 >= 0;
  os_unfair_lock_lock(&nw_utilities_set_log_intercept::lock);
  __nw_utilities_set_log_intercept_block_invoke((uint64_t)v4);
  os_unfair_lock_unlock(&nw_utilities_set_log_intercept::lock);
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  return v2;
}

uint64_t __nwlog_override_datapath(char a1)
{
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
  uint64_t v2 = gLogDatapath;
  gLogDatapath = a1;
  gLogDatapathOverridden = 1;
  os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  return v2;
}

uint64_t __nwlog_register_helper()
{
  if ((gIsHelper & 1) == 0)
  {
    gIsHelper = 1;
    nw_allow_use_of_dispatch_internal();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    return networkd_settings_init();
  }
  return result;
}

uint64_t __nwlog_create_hash_from_private_string(const char *a1, char *a2)
{
  size_t v4 = strlen(a1);
  __nwlog_salted_hash(a1, v4, a2);
  return 1;
}

void nwlog_send_copy_to_fd(int a1)
{
  if (os_variant_has_internal_content())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
    gLogFDOverride = a1;
    if ((a1 & 0x80000000) == 0)
    {
      gLogDatapath = 1;
      gLogDatapathOverridden = 1;
    }
    v2[0] = MEMORY[0x1E4F143A8];
    v2[1] = 3221225472;
    v2[2] = __nw_utilities_set_log_intercept_block_invoke;
    v2[3] = &__block_descriptor_33_e5_v8__0l;
    BOOL v3 = a1 >= 0;
    os_unfair_lock_lock(&nw_utilities_set_log_intercept::lock);
    __nw_utilities_set_log_intercept_block_invoke((uint64_t)v2);
    os_unfair_lock_unlock(&nw_utilities_set_log_intercept::lock);
    os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
  }
}

BOOL __nwlog_compose_logs()
{
  return gLogFDOverride != -1;
}

BOOL __nwlog_level_enabled(NSObject *a1, os_log_type_t a2)
{
  return gLogFDOverride != -1 || os_log_type_enabled(a1, a2);
}

uint64_t nwlog_get_signposts_enabled()
{
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_18_90123);
  }
  return _nw_signposts_enabled;
}

void nw_mpkl_child_has_forked()
{
  gMpklHasForked = 1;
  gMpklLogObj = MEMORY[0x1E4F14500];
}

uint64_t nw_mpkl_copy_log_object()
{
  return gMpklLogObj;
}

uint64_t nw_mpkl_log_init_once(void)
{
  uint64_t result = pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if ((gMpklHasForked & 1) == 0)
  {
    uint64_t result = (uint64_t)os_log_create("com.apple.magnetpacketlog", "libnetcore");
    gMpklLogObj = result;
  }
  return result;
}

BOOL nw_ws_copy_response_for_challenge(const __CFString *a1)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  CFIndex Length = CFStringGetLength(a1);
  CFIndex MaximumSizeForEncoding = CFStringGetMaximumSizeForEncoding(Length, 0x8000100u);
  size_t v4 = MaximumSizeForEncoding + 1;
  if (MaximumSizeForEncoding == -1)
  {
    id v24 = __nwlog_obj();
    os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_malloc";
    size_t v25 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v25);
    if (result) {
      goto LABEL_40;
    }
    free(v25);
  }
  BOOL v5 = (char *)malloc_type_malloc(v4, 0xF2B69DE5uLL);
  if (!v5)
  {
    uint64_t v26 = __nwlog_obj();
    os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "strict_malloc";
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = v4;
    BOOL v27 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v27);
    if (result) {
      goto LABEL_40;
    }
    free(v27);
  }
  int CString = CFStringGetCString(a1, v5, v4, 0x8000100u);
  if (v5 && !CString)
  {
    free(v5);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v29[0]) = 0;
    if (__nwlog_fault(v8, type, v29))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (id)gLogObj;
        os_log_type_t v10 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s CFStringGetCString failed", buf, 0xCu);
        }
      }
      else if (LOBYTE(v29[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (id)gLogObj;
        os_log_type_t v21 = type[0];
        BOOL v22 = os_log_type_enabled(v9, type[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s CFStringGetCString failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v8) {
            return 0;
          }
          goto LABEL_11;
        }
        if (v22)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
          _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s CFStringGetCString failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v9 = (id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v9, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
          _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s CFStringGetCString failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v8) {
      return 0;
    }
LABEL_11:
    free(v8);
    return 0;
  }
  os_log_type_t v28 = 0;
  CC_LONG v12 = asprintf(&v28, "%s%s", v5, "258EAFA5-E914-47DA-95CA-C5AB0DC85B11");
  if (v5) {
    free(v5);
  }
  if (v12 != -1)
  {
LABEL_18:
    *(void *)md = 0;
    uint64_t v39 = 0;
    int v40 = 0;
    CC_SHA1(v28, v12, md);
    if (v28)
    {
      free(v28);
      os_log_type_t v28 = 0;
    }
    uint64_t v16 = dispatch_get_global_queue(0, 0);
    dispatch_data_t v17 = dispatch_data_create(md, 0x14uLL, v16, &__block_literal_global_44977);

    nw_framer_t v18 = dispatch_data_create_with_transform();
    char v19 = v18;
    *(void *)bytes = 0;
    uint64_t v35 = 0;
    int v37 = 0;
    uint64_t v36 = 0;
    *(void *)os_log_type_t type = 0;
    BOOL v31 = type;
    uint64_t v32 = 0x2000000000;
    uint64_t v33 = 0;
    v29[0] = 0;
    v29[1] = v29;
    v29[2] = 0x2000000000;
    v29[3] = bytes;
    if (v18)
    {
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
      uint64_t v42 = &unk_1E5242B60;
      os_log_type_t v44 = v29;
      uint64_t v45 = 28;
      BOOL v43 = type;
      dispatch_data_apply(v18, buf);
    }
    _Block_object_dispose(v29, 8);
    _Block_object_dispose(type, 8);
    CFStringRef v11 = CFStringCreateWithBytes((CFAllocatorRef)*MEMORY[0x1E4F1CF80], bytes, 28, 0x8000100u, 0);

    return (BOOL)v11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v13 = (id)gLogObj;
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_copy_response_for_challenge";
  __int16 v14 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_18;
  }
LABEL_40:
  __break(1u);
  return result;
}

void sub_183A1CA2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFDataRef nw_ws_create_client_request(uint64_t a1, void *a2, void *a3)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  BOOL v5 = a2;
  id v6 = a3;
  id v7 = v6;
  if (a1)
  {
    if (v5)
    {
      if (v6)
      {
        CFURLRef v8 = (const __CFURL *)nw_endpoint_copy_cfurl(v6);
        if (v8)
        {
          CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
          Request = CFHTTPMessageCreateRequest((CFAllocatorRef)*MEMORY[0x1E4F1CF80], @"GET", v8, (CFStringRef)*MEMORY[0x1E4F18F90]);
          if (Request)
          {
            CFStringRef v11 = CFURLCopyHostName(v8);
            if (v11)
            {
              CFHTTPMessageSetHeaderFieldValue(Request, @"Host", v11);
              CFRelease(v11);
              CFRelease(v8);
              CFHTTPMessageSetHeaderFieldValue(Request, @"Upgrade", @"WebSocket");
              CFHTTPMessageSetHeaderFieldValue(Request, @"Connection", @"Upgrade");
              __buf[0] = 0;
              __buf[1] = 0;
              arc4random_buf(__buf, 0x10uLL);
              CC_LONG v12 = dispatch_get_global_queue(0, 0);
              dispatch_data_t v13 = dispatch_data_create(__buf, 0x10uLL, v12, &__block_literal_global_21);

              __int16 v14 = dispatch_data_create_with_transform();
              uint64_t v15 = v14;
              *(void *)bytes = 0;
              uint64_t v85 = 0;
              uint64_t v86 = 0;
              *(void *)os_log_type_t type = 0;
              uint64_t v81 = type;
              uint64_t v82 = 0x2000000000;
              uint64_t v83 = 0;
              v79[0] = 0;
              v79[1] = v79;
              v79[2] = 0x2000000000;
              v79[3] = bytes;
              if (v14)
              {
                *(void *)applier = MEMORY[0x1E4F143A8];
                *(void *)&applier[8] = 0x40000000;
                *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
                v89 = &unk_1E5242B60;
                v91 = v79;
                uint64_t v92 = 24;
                v90 = type;
                dispatch_data_apply(v14, applier);
              }
              _Block_object_dispose(v79, 8);
              _Block_object_dispose(type, 8);
              CFStringRef v16 = CFStringCreateWithBytes(v9, bytes, 24, 0x8000100u, 0);
              if (v16)
              {
                CFHTTPMessageSetHeaderFieldValue(Request, @"Sec-WebSocket-Key", v16);
                *(void *)(a1 + _Block_object_dispose(&a9, 8) = v16;
                nw_protocol_options_t v17 = nw_framer_copy_options(v5);
                v78[0] = MEMORY[0x1E4F143A8];
                v78[1] = 3221225472;
                v78[2] = __nw_ws_create_client_request_block_invoke_25;
                v78[3] = &__block_descriptor_48_e9_B16__0_v8l;
                v78[4] = Request;
                v78[5] = a1;
                char v18 = nw_protocol_options_access_handle(v17, v78);

                if (v18)
                {
                  CFDataRef v19 = CFHTTPMessageCopySerializedMessage(Request);
                  CFRelease(Request);
                  if (v19)
                  {
LABEL_104:

                    goto LABEL_105;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v20 = (id)gLogObj;
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

                  type[0] = OS_LOG_TYPE_ERROR;
                  LOBYTE(v79[0]) = 0;
                  if (!__nwlog_fault(v21, type, v79)) {
                    goto LABEL_112;
                  }
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v22 = __nwlog_obj();
                    os_log_type_t v23 = type[0];
                    if (os_log_type_enabled(v22, type[0]))
                    {
                      *(_DWORD *)applier = 136446210;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed", applier, 0xCu);
                    }
                  }
                  else if (LOBYTE(v79[0]))
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    BOOL v22 = __nwlog_obj();
                    os_log_type_t v59 = type[0];
                    BOOL v60 = os_log_type_enabled(v22, type[0]);
                    if (backtrace_string)
                    {
                      if (v60)
                      {
                        *(_DWORD *)applier = 136446466;
                        *(void *)&applier[4] = "nw_ws_create_client_request";
                        *(_WORD *)&applier[12] = 2082;
                        *(void *)&applier[14] = backtrace_string;
                        _os_log_impl(&dword_1830D4000, v22, v59, "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed, dumping backtrace:%{public}s", applier, 0x16u);
                      }

                      free(backtrace_string);
                      goto LABEL_112;
                    }
                    if (v60)
                    {
                      *(_DWORD *)applier = 136446210;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      _os_log_impl(&dword_1830D4000, v22, v59, "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed, no backtrace", applier, 0xCu);
                    }
                  }
                  else
                  {
                    BOOL v22 = __nwlog_obj();
                    os_log_type_t v62 = type[0];
                    if (os_log_type_enabled(v22, type[0]))
                    {
                      *(_DWORD *)applier = 136446210;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      _os_log_impl(&dword_1830D4000, v22, v62, "%{public}s ws.output.client: CFHTTPMessageCopySerializedMessage failed, backtrace limit exceeded", applier, 0xCu);
                    }
                  }

LABEL_112:
                  if (v21) {
                    free(v21);
                  }
                  goto LABEL_103;
                }
                CFRelease(Request);
LABEL_103:
                CFDataRef v19 = 0;
                goto LABEL_104;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v42 = (id)gLogObj;
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              BOOL v43 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v79[0]) = 0;
              if (__nwlog_fault(v43, type, v79))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v44 = (id)gLogObj;
                  os_log_type_t v45 = type[0];
                  if (os_log_type_enabled(v44, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s CFStringCreateWithBytes failed", applier, 0xCu);
                  }
                }
                else if (LOBYTE(v79[0]))
                {
                  long long v51 = (char *)__nw_create_backtrace_string();
                  os_log_type_t v44 = __nwlog_obj();
                  os_log_type_t v52 = type[0];
                  BOOL v53 = os_log_type_enabled(v44, type[0]);
                  if (v51)
                  {
                    if (v53)
                    {
                      *(_DWORD *)applier = 136446466;
                      *(void *)&applier[4] = "nw_ws_create_client_request";
                      *(_WORD *)&applier[12] = 2082;
                      *(void *)&applier[14] = v51;
                      _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s CFStringCreateWithBytes failed, dumping backtrace:%{public}s", applier, 0x16u);
                    }

                    free(v51);
                    if (!v43) {
                      goto LABEL_102;
                    }
                    goto LABEL_101;
                  }
                  if (v53)
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s CFStringCreateWithBytes failed, no backtrace", applier, 0xCu);
                  }
                }
                else
                {
                  os_log_type_t v44 = __nwlog_obj();
                  os_log_type_t v57 = type[0];
                  if (os_log_type_enabled(v44, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    _os_log_impl(&dword_1830D4000, v44, v57, "%{public}s CFStringCreateWithBytes failed, backtrace limit exceeded", applier, 0xCu);
                  }
                }
              }
              if (!v43)
              {
LABEL_102:
                CFRelease(Request);
                goto LABEL_103;
              }
LABEL_101:
              free(v43);
              goto LABEL_102;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v35 = (id)gLogObj;
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            uint64_t v36 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v79[0]) = 0;
            if (__nwlog_fault(v36, type, v79))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                int v37 = (id)gLogObj;
                os_log_type_t v38 = type[0];
                if (os_log_type_enabled(v37, type[0]))
                {
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s CFURLCopyHostName failed", applier, 0xCu);
                }
              }
              else if (LOBYTE(v79[0]))
              {
                uint64_t v46 = __nw_create_backtrace_string();
                if (v46)
                {
                  os_log_type_t v47 = (char *)v46;
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  long long v48 = (id)gLogObj;
                  os_log_type_t v49 = type[0];
                  if (os_log_type_enabled(v48, type[0]))
                  {
                    *(_DWORD *)applier = 136446466;
                    *(void *)&applier[4] = "nw_ws_create_client_request";
                    *(_WORD *)&applier[12] = 2082;
                    *(void *)&applier[14] = v47;
                    _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s CFURLCopyHostName failed, dumping backtrace:%{public}s", applier, 0x16u);
                  }

                  free(v47);
                  if (!v36) {
                    goto LABEL_87;
                  }
                  goto LABEL_86;
                }
                int v37 = __nwlog_obj();
                os_log_type_t v56 = type[0];
                if (os_log_type_enabled(v37, type[0]))
                {
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  _os_log_impl(&dword_1830D4000, v37, v56, "%{public}s CFURLCopyHostName failed, no backtrace", applier, 0xCu);
                }
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                int v37 = (id)gLogObj;
                os_log_type_t v55 = type[0];
                if (os_log_type_enabled(v37, type[0]))
                {
                  *(_DWORD *)applier = 136446210;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  _os_log_impl(&dword_1830D4000, v37, v55, "%{public}s CFURLCopyHostName failed, backtrace limit exceeded", applier, 0xCu);
                }
              }
            }
            if (!v36)
            {
LABEL_87:
              CFRelease(Request);
              CFRelease(v8);
              goto LABEL_88;
            }
LABEL_86:
            free(v36);
            goto LABEL_87;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v28 = (id)gLogObj;
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          __int16 v29 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v79[0]) = 0;
          if (__nwlog_fault(v29, type, v79))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v30 = (id)gLogObj;
              os_log_type_t v31 = type[0];
              if (os_log_type_enabled(v30, type[0]))
              {
                *(_DWORD *)applier = 136446210;
                *(void *)&applier[4] = "nw_ws_create_client_request";
                _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s CFHTTPMessageCreateRequest failed", applier, 0xCu);
              }
            }
            else if (LOBYTE(v79[0]))
            {
              uint64_t v39 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v30 = (id)gLogObj;
              os_log_type_t v40 = type[0];
              BOOL v41 = os_log_type_enabled(v30, type[0]);
              if (v39)
              {
                if (v41)
                {
                  *(_DWORD *)applier = 136446466;
                  *(void *)&applier[4] = "nw_ws_create_client_request";
                  *(_WORD *)&applier[12] = 2082;
                  *(void *)&applier[14] = v39;
                  _os_log_impl(&dword_1830D4000, v30, v40, "%{public}s CFHTTPMessageCreateRequest failed, dumping backtrace:%{public}s", applier, 0x16u);
                }

                free(v39);
                if (!v29) {
                  goto LABEL_78;
                }
                goto LABEL_77;
              }
              if (v41)
              {
                *(_DWORD *)applier = 136446210;
                *(void *)&applier[4] = "nw_ws_create_client_request";
                _os_log_impl(&dword_1830D4000, v30, v40, "%{public}s CFHTTPMessageCreateRequest failed, no backtrace", applier, 0xCu);
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v30 = (id)gLogObj;
              os_log_type_t v54 = type[0];
              if (os_log_type_enabled(v30, type[0]))
              {
                *(_DWORD *)applier = 136446210;
                *(void *)&applier[4] = "nw_ws_create_client_request";
                _os_log_impl(&dword_1830D4000, v30, v54, "%{public}s CFHTTPMessageCreateRequest failed, backtrace limit exceeded", applier, 0xCu);
              }
            }
          }
          if (!v29)
          {
LABEL_78:
            CFRelease(v8);
            goto LABEL_88;
          }
LABEL_77:
          free(v29);
          goto LABEL_78;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v24 = (id)gLogObj;
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_client_request";
        size_t v25 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v79[0]) = 0;
        if (__nwlog_fault(v25, type, v79))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v26 = (id)gLogObj;
            os_log_type_t v27 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s CFURLCreateWithString failed", applier, 0xCu);
            }
LABEL_67:

            goto LABEL_68;
          }
          if (!LOBYTE(v79[0]))
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v26 = (id)gLogObj;
            os_log_type_t v50 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_1830D4000, v26, v50, "%{public}s CFURLCreateWithString failed, backtrace limit exceeded", applier, 0xCu);
            }
            goto LABEL_67;
          }
          uint64_t v32 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v26 = (id)gLogObj;
          os_log_type_t v33 = type[0];
          BOOL v34 = os_log_type_enabled(v26, type[0]);
          if (!v32)
          {
            if (v34)
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_1830D4000, v26, v33, "%{public}s CFURLCreateWithString failed, no backtrace", applier, 0xCu);
            }
            goto LABEL_67;
          }
          if (v34)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = v32;
            _os_log_impl(&dword_1830D4000, v26, v33, "%{public}s CFURLCreateWithString failed, dumping backtrace:%{public}s", applier, 0x16u);
          }
LABEL_31:

          free(v32);
          if (!v25) {
            goto LABEL_88;
          }
          goto LABEL_69;
        }
      }
      else
      {
        os_log_type_t v67 = __nwlog_obj();
        *(_DWORD *)applier = 136446210;
        *(void *)&applier[4] = "nw_ws_create_client_request";
        size_t v25 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v79[0]) = 0;
        if (__nwlog_fault(v25, type, v79))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v26 = __nwlog_obj();
            os_log_type_t v68 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_1830D4000, v26, v68, "%{public}s called with null endpoint", applier, 0xCu);
            }
            goto LABEL_67;
          }
          if (!LOBYTE(v79[0]))
          {
            uint64_t v26 = __nwlog_obj();
            os_log_type_t v77 = type[0];
            if (os_log_type_enabled(v26, type[0]))
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_1830D4000, v26, v77, "%{public}s called with null endpoint, backtrace limit exceeded", applier, 0xCu);
            }
            goto LABEL_67;
          }
          uint64_t v32 = (char *)__nw_create_backtrace_string();
          uint64_t v26 = __nwlog_obj();
          os_log_type_t v73 = type[0];
          BOOL v74 = os_log_type_enabled(v26, type[0]);
          if (!v32)
          {
            if (v74)
            {
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nw_ws_create_client_request";
              _os_log_impl(&dword_1830D4000, v26, v73, "%{public}s called with null endpoint, no backtrace", applier, 0xCu);
            }
            goto LABEL_67;
          }
          if (v74)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = v32;
            _os_log_impl(&dword_1830D4000, v26, v73, "%{public}s called with null endpoint, dumping backtrace:%{public}s", applier, 0x16u);
          }
          goto LABEL_31;
        }
      }
    }
    else
    {
      uint64_t v65 = __nwlog_obj();
      *(_DWORD *)applier = 136446210;
      *(void *)&applier[4] = "nw_ws_create_client_request";
      size_t v25 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v79[0]) = 0;
      if (__nwlog_fault(v25, type, v79))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v26 = __nwlog_obj();
          os_log_type_t v66 = type[0];
          if (os_log_type_enabled(v26, type[0]))
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            _os_log_impl(&dword_1830D4000, v26, v66, "%{public}s called with null framer", applier, 0xCu);
          }
          goto LABEL_67;
        }
        if (!LOBYTE(v79[0]))
        {
          uint64_t v26 = __nwlog_obj();
          os_log_type_t v76 = type[0];
          if (os_log_type_enabled(v26, type[0]))
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            _os_log_impl(&dword_1830D4000, v26, v76, "%{public}s called with null framer, backtrace limit exceeded", applier, 0xCu);
          }
          goto LABEL_67;
        }
        uint64_t v32 = (char *)__nw_create_backtrace_string();
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v71 = type[0];
        BOOL v72 = os_log_type_enabled(v26, type[0]);
        if (!v32)
        {
          if (v72)
          {
            *(_DWORD *)applier = 136446210;
            *(void *)&applier[4] = "nw_ws_create_client_request";
            _os_log_impl(&dword_1830D4000, v26, v71, "%{public}s called with null framer, no backtrace", applier, 0xCu);
          }
          goto LABEL_67;
        }
        if (v72)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          *(_WORD *)&applier[12] = 2082;
          *(void *)&applier[14] = v32;
          _os_log_impl(&dword_1830D4000, v26, v71, "%{public}s called with null framer, dumping backtrace:%{public}s", applier, 0x16u);
        }
        goto LABEL_31;
      }
    }
  }
  else
  {
    size_t v63 = __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_ws_create_client_request";
    size_t v25 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v79[0]) = 0;
    if (__nwlog_fault(v25, type, v79))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v64 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          _os_log_impl(&dword_1830D4000, v26, v64, "%{public}s called with null state", applier, 0xCu);
        }
        goto LABEL_67;
      }
      if (!LOBYTE(v79[0]))
      {
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v75 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          _os_log_impl(&dword_1830D4000, v26, v75, "%{public}s called with null state, backtrace limit exceeded", applier, 0xCu);
        }
        goto LABEL_67;
      }
      uint64_t v32 = (char *)__nw_create_backtrace_string();
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v69 = type[0];
      BOOL v70 = os_log_type_enabled(v26, type[0]);
      if (!v32)
      {
        if (v70)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_ws_create_client_request";
          _os_log_impl(&dword_1830D4000, v26, v69, "%{public}s called with null state, no backtrace", applier, 0xCu);
        }
        goto LABEL_67;
      }
      if (v70)
      {
        *(_DWORD *)applier = 136446466;
        *(void *)&applier[4] = "nw_ws_create_client_request";
        *(_WORD *)&applier[12] = 2082;
        *(void *)&applier[14] = v32;
        _os_log_impl(&dword_1830D4000, v26, v69, "%{public}s called with null state, dumping backtrace:%{public}s", applier, 0x16u);
      }
      goto LABEL_31;
    }
  }
LABEL_68:
  if (v25) {
LABEL_69:
  }
    free(v25);
LABEL_88:
  CFDataRef v19 = 0;
LABEL_105:

  return v19;
}

void sub_183A1DFD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_create_client_request_block_invoke_25(uint64_t a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(a2 + 56) != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v23 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    uint64_t v46 = "nw_ws_create_client_request_block_invoke";
    id v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v24, &type, &v43)) {
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v25 = (id)gLogObj;
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v46 = "nw_ws_create_client_request_block_invoke";
      os_log_type_t v27 = "%{public}s nw_ws_options_get_version failed";
    }
    else
    {
      if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v25 = (id)gLogObj;
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (!v30) {
            goto LABEL_66;
          }
          *(_DWORD *)long long buf = 136446466;
          uint64_t v46 = "nw_ws_create_client_request_block_invoke";
          __int16 v47 = 2082;
          long long v48 = backtrace_string;
          os_log_type_t v31 = "%{public}s nw_ws_options_get_version failed, dumping backtrace:%{public}s";
          goto LABEL_65;
        }
        if (!v30)
        {
LABEL_43:

          if (!v24) {
            return 0;
          }
          goto LABEL_75;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_ws_create_client_request_block_invoke";
        os_log_type_t v27 = "%{public}s nw_ws_options_get_version failed, no backtrace";
        id v35 = v25;
        os_log_type_t v36 = v29;
LABEL_42:
        _os_log_impl(&dword_1830D4000, v35, v36, v27, buf, 0xCu);
        goto LABEL_43;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v25 = (id)gLogObj;
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v46 = "nw_ws_create_client_request_block_invoke";
      os_log_type_t v27 = "%{public}s nw_ws_options_get_version failed, backtrace limit exceeded";
    }
    id v35 = v25;
    os_log_type_t v36 = v26;
    goto LABEL_42;
  }
  CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 32), @"Sec-WebSocket-Version", @"13");
  CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
  if (!Mutable)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v32 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    uint64_t v46 = "nw_ws_create_client_request_block_invoke";
    id v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v24, &type, &v43)) {
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v25 = (id)gLogObj;
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_ws_create_client_request_block_invoke";
        BOOL v34 = "%{public}s CFStringCreateMutable failed";
LABEL_71:
        os_log_type_t v40 = v25;
        os_log_type_t v41 = v33;
LABEL_72:
        _os_log_impl(&dword_1830D4000, v40, v41, v34, buf, 0xCu);
      }
LABEL_73:

      goto LABEL_74;
    }
    if (!v43)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v25 = (id)gLogObj;
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_ws_create_client_request_block_invoke";
        BOOL v34 = "%{public}s CFStringCreateMutable failed, backtrace limit exceeded";
        goto LABEL_71;
      }
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v25 = (id)gLogObj;
    os_log_type_t v29 = type;
    BOOL v37 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_73;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v46 = "nw_ws_create_client_request_block_invoke";
      BOOL v34 = "%{public}s CFStringCreateMutable failed, no backtrace";
      goto LABEL_79;
    }
    if (!v37) {
      goto LABEL_66;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v46 = "nw_ws_create_client_request_block_invoke";
    __int16 v47 = 2082;
    long long v48 = backtrace_string;
    os_log_type_t v31 = "%{public}s CFStringCreateMutable failed, dumping backtrace:%{public}s";
LABEL_65:
    _os_log_impl(&dword_1830D4000, v25, v29, v31, buf, 0x16u);
    goto LABEL_66;
  }
  CFStringRef v5 = Mutable;
  if (*(void *)a2)
  {
    xpc_object_t v6 = xpc_copy(*(xpc_object_t *)a2);
    uint64_t v7 = *(void *)(a1 + 40);
    CFURLRef v8 = *(void **)(v7 + 16);
    *(void *)(v7 + 16) = v6;

    xpc_object_t v9 = *(xpc_object_t *)a2;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3221225472;
    applier[2] = __nw_ws_create_client_request_block_invoke_32;
    applier[3] = &__block_descriptor_48_e36_B24__0Q8__NSObject_OS_xpc_object__16l;
    applier[4] = v5;
    applier[5] = a2;
    if (!xpc_array_apply(v9, applier))
    {
      CFRelease(v5);
      return 0;
    }
  }
  if (CFStringGetLength(v5) >= 1) {
    CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 32), @"Sec-WebSocket-Protocol", v5);
  }
  CFRelease(v5);
  if ((*(unsigned char *)(a2 + 70) & 8) != 0)
  {
    CFMutableStringRef v10 = CFStringCreateMutable(0, 0);
    CFStringAppendCString(v10, "permessage-deflate", 0x8000100u);
    char v11 = *(unsigned char *)(a2 + 70);
    if ((v11 & 0x10) == 0)
    {
      CFStringAppendCString(v10, "; server_no_context_takeover", 0x8000100u);
      char v11 = *(unsigned char *)(a2 + 70);
    }
    if ((v11 & 0x20) == 0) {
      CFStringAppendCString(v10, "; client_no_context_takeover", 0x8000100u);
    }
    if ((*(unsigned char *)(a2 + 68) & 0xF8) == 8) {
      CFStringAppendFormat(v10, 0, @"; server_max_window_bits=%d", *(unsigned __int8 *)(a2 + 68));
    }
    if ((*(unsigned char *)(a2 + 69) & 0xF8) == 8) {
      CFStringAppendFormat(v10, 0, @"; client_max_window_bits=%d", *(unsigned __int8 *)(a2 + 69));
    }
    CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 32), @"Sec-WebSocket-Extensions", v10);
    if (v10) {
      CFRelease(v10);
    }
  }
  size_t count = xpc_array_get_count(*(xpc_object_t *)(a2 + 8));
  if (!count) {
    return 1;
  }
  size_t v13 = count;
  size_t v14 = 0;
  CFAllocatorRef v15 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  while (1)
  {
    string = xpc_array_get_string(*(xpc_object_t *)(a2 + 8), v14);
    nw_protocol_options_t v17 = xpc_array_get_string(*(xpc_object_t *)(a2 + 16), v14);
    CFStringRef v18 = CFStringCreateWithCString(v15, string, 0x600u);
    CFStringRef v19 = CFStringCreateWithCString(v15, v17, 0x600u);
    CFStringRef v20 = v19;
    if (!v18 || v19 == 0) {
      break;
    }
    CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 32), v18, v19);
    CFRelease(v18);
    CFRelease(v20);
    if (v13 == ++v14) {
      return 1;
    }
  }
  if (v18) {
    CFRelease(v18);
  }
  if (v20) {
    CFRelease(v20);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v38 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446210;
  uint64_t v46 = "nw_ws_create_client_request_block_invoke";
  id v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (__nwlog_fault(v24, &type, &v43))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v25 = (id)gLogObj;
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_ws_create_client_request_block_invoke";
        BOOL v34 = "%{public}s CFStringCreateWithCString failed";
        goto LABEL_71;
      }
      goto LABEL_73;
    }
    if (!v43)
    {
      size_t v25 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_ws_create_client_request_block_invoke";
        BOOL v34 = "%{public}s CFStringCreateWithCString failed, backtrace limit exceeded";
        goto LABEL_71;
      }
      goto LABEL_73;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v25 = (id)gLogObj;
    os_log_type_t v29 = type;
    BOOL v39 = os_log_type_enabled(v25, type);
    if (backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v46 = "nw_ws_create_client_request_block_invoke";
        __int16 v47 = 2082;
        long long v48 = backtrace_string;
        os_log_type_t v31 = "%{public}s CFStringCreateWithCString failed, dumping backtrace:%{public}s";
        goto LABEL_65;
      }
LABEL_66:

      free(backtrace_string);
      goto LABEL_74;
    }
    if (!v39) {
      goto LABEL_73;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v46 = "nw_ws_create_client_request_block_invoke";
    BOOL v34 = "%{public}s CFStringCreateWithCString failed, no backtrace";
LABEL_79:
    os_log_type_t v40 = v25;
    os_log_type_t v41 = v29;
    goto LABEL_72;
  }
LABEL_74:
  if (v24) {
LABEL_75:
  }
    free(v24);
  return 0;
}

BOOL __nw_ws_create_client_request_block_invoke_32(uint64_t a1, size_t a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v5 = a3;
  string_ptr = xpc_string_get_string_ptr(v5);
  CFStringRef v7 = CFStringCreateWithCString(0, string_ptr, 0x8000100u);
  if (v7)
  {
    CFStringAppend(*(CFMutableStringRef *)(a1 + 32), v7);
    CFRelease(v7);
    if (xpc_array_get_count(**(xpc_object_t **)(a1 + 40)) - 1 > a2) {
      CFStringAppend(*(CFMutableStringRef *)(a1 + 32), @",");
    }
    goto LABEL_11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v8 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446210;
  CFStringRef v20 = "nw_ws_create_client_request_block_invoke";
  xpc_object_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (!__nwlog_fault(v9, &type, &v17)) {
    goto LABEL_9;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFMutableStringRef v10 = (id)gLogObj;
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)long long buf = 136446210;
      CFStringRef v20 = "nw_ws_create_client_request_block_invoke";
      _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s CFStringCreatewithCString failed", buf, 0xCu);
    }
LABEL_8:

LABEL_9:
    if (!v9) {
      goto LABEL_11;
    }
LABEL_10:
    free(v9);
    goto LABEL_11;
  }
  if (!v17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFMutableStringRef v10 = (id)gLogObj;
    os_log_type_t v16 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)long long buf = 136446210;
      CFStringRef v20 = "nw_ws_create_client_request_block_invoke";
      _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s CFStringCreatewithCString failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_8;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  CFMutableStringRef v10 = (id)gLogObj;
  os_log_type_t v14 = type;
  BOOL v15 = os_log_type_enabled(v10, type);
  if (!backtrace_string)
  {
    if (v15)
    {
      *(_DWORD *)long long buf = 136446210;
      CFStringRef v20 = "nw_ws_create_client_request_block_invoke";
      _os_log_impl(&dword_1830D4000, v10, v14, "%{public}s CFStringCreatewithCString failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_8;
  }
  if (v15)
  {
    *(_DWORD *)long long buf = 136446466;
    CFStringRef v20 = "nw_ws_create_client_request_block_invoke";
    __int16 v21 = 2082;
    BOOL v22 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v10, v14, "%{public}s CFStringCreatewithCString failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v9) {
    goto LABEL_10;
  }
LABEL_11:

  return v7 != 0;
}

void sub_183A1ED28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_ws_validate_client_request(uint64_t a1, void *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  size_t v4 = *(__CFHTTPMessage **)(a1 + 24);
  CFStringRef v5 = CFHTTPMessageCopyHeaderFieldValue(v4, @"Upgrade");
  CFStringRef v6 = v5;
  if (!v5)
  {
LABEL_4:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFStringRef v7 = (id)gLogObj;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
LABEL_6:

      uint64_t v8 = 0;
      goto LABEL_7;
    }
LABEL_5:
    *(_DWORD *)long long buf = 136446466;
    id v32 = "nw_ws_validate_client_request";
    __int16 v33 = 2082;
    BOOL v34 = (const char *)(a1 + 227);
    _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s client request doesn't match expected value", buf, 0x16u);
    goto LABEL_6;
  }
  if (CFStringCompare(v5, @"WebSocket", 1uLL))
  {
    CFRelease(v6);
    goto LABEL_4;
  }
  CFRelease(v6);
  CFStringRef v10 = CFHTTPMessageCopyHeaderFieldValue(v4, @"Connection");
  CFStringRef v11 = v10;
  if (!v10)
  {
LABEL_11:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    CFStringRef v7 = (id)gLogObj;
    if (!os_log_type_enabled(v7, OS_LOG_TYPE_ERROR)) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  if (CFStringCompare(v10, @"Upgrade", 1uLL))
  {
    CFRelease(v11);
    goto LABEL_11;
  }
  CFRelease(v11);
  if ((*(_WORD *)(a1 + 225) & 0x40) != 0)
  {
    CFStringRef v12 = CFHTTPMessageCopyHeaderFieldValue(v4, @"Sec-WebSocket-Extensions");
    if (v12)
    {
      *(_WORD *)(a1 + 225) &= ~0x40u;
      CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v12, @",");
      CFRelease(v12);
      CFArrayRef v14 = 0;
      for (CFIndex i = 0; i < CFArrayGetCount(ArrayBySeparatingStrings); ++i)
      {
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, i);
        if (v14) {
          CFRelease(v14);
        }
        CFArrayRef v17 = nw_ws_copy_extension_decl_as_array(ValueAtIndex);
        CFArrayRef v14 = v17;
        if (v17)
        {
          if (CFArrayGetCount(v17) >= 1)
          {
            CFStringRef v18 = (const __CFString *)CFArrayGetValueAtIndex(v14, 0);
            if (CFStringCompare(v18, @"permessage-deflate", 1uLL) == kCFCompareEqualTo)
            {
              int v19 = 0;
              CFIndex v20 = 1;
              *(_WORD *)(a1 + 225) |= 0x40u;
              while (1)
              {
                while (1)
                {
                  while (1)
                  {
                    if (v20 >= CFArrayGetCount(v14)) {
                      goto LABEL_76;
                    }
                    CFStringRef v21 = (const __CFString *)CFArrayGetValueAtIndex(v14, v20);
                    unint64_t v30 = -1;
                    if (CFStringCompare(v21, @"server_no_context_takeover", 1uLL)) {
                      break;
                    }
                    if (v19)
                    {
                      BOOL v22 = __nwlog_obj();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        *(_DWORD *)long long buf = 136446466;
                        id v32 = "nw_ws_validate_client_request";
                        __int16 v33 = 2082;
                        BOOL v34 = (const char *)(a1 + 227);
                        uint64_t v23 = "%{public}s %{public}s Duplicate value for server_no_context_takeover";
                        goto LABEL_68;
                      }
                      goto LABEL_75;
                    }
                    v19 |= 1u;
                    *(_WORD *)(a1 + 225) &= ~0x80u;
                    ++v20;
                  }
                  if (CFStringCompare(v21, @"client_no_context_takeover", 1uLL) == kCFCompareEqualTo) {
                    break;
                  }
                  if (nw_ws_get_extension_parameter(v21, @"server_max_window_bits", &v30))
                  {
                    if ((v19 & 4) != 0)
                    {
                      BOOL v22 = __nwlog_obj();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        id v24 = "";
                        if (a1) {
                          id v24 = (const char *)(a1 + 227);
                        }
                        goto LABEL_67;
                      }
                      goto LABEL_75;
                    }
                    if ((v30 & 0xFFFFFFFFFFFFFFF8) != 8)
                    {
                      BOOL v22 = __nwlog_obj();
                      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_75;
                      }
                      size_t v25 = "";
                      id v32 = "nw_ws_validate_client_request";
                      *(_DWORD *)long long buf = 136446722;
                      if (a1) {
                        size_t v25 = (const char *)(a1 + 227);
                      }
                      __int16 v33 = 2082;
                      BOOL v34 = v25;
                      __int16 v35 = 2048;
                      unint64_t v36 = v30;
                      uint64_t v23 = "%{public}s %{public}s Invalid value for server_max_window_bits (%llu)";
LABEL_73:
                      os_log_type_t v27 = v22;
                      uint32_t v28 = 32;
                      goto LABEL_74;
                    }
                    v19 |= 4u;
                    *(unsigned char *)(a1 + 220) = v30;
                    ++v20;
                  }
                  else if (CFStringCompare(v21, @"client_max_window_bits", 1uLL))
                  {
                    if (!nw_ws_get_extension_parameter(v21, @"client_max_window_bits", &v30))
                    {
                      BOOL v22 = __nwlog_obj();
                      if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                        goto LABEL_75;
                      }
                      os_log_type_t v26 = (const char *)(a1 + 227);
                      id v32 = "nw_ws_validate_client_request";
                      *(_DWORD *)long long buf = 136446722;
                      if (!a1) {
                        os_log_type_t v26 = "";
                      }
                      __int16 v33 = 2082;
                      BOOL v34 = v26;
                      __int16 v35 = 2112;
                      unint64_t v36 = (unint64_t)v21;
                      uint64_t v23 = "%{public}s %{public}s Invalid parameter in permessage-deflate extension (%@)";
                      goto LABEL_73;
                    }
                    if ((v19 & 8) != 0)
                    {
                      BOOL v22 = __nwlog_obj();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        id v24 = "";
                        if (a1) {
                          id v24 = (const char *)(a1 + 227);
                        }
                        goto LABEL_67;
                      }
                      goto LABEL_75;
                    }
                    v19 |= 8u;
                    if (v30 == -1)
                    {
                      *(unsigned char *)(a1 + 221) = 15;
                      ++v20;
                    }
                    else
                    {
                      if ((v30 & 0xFFFFFFFFFFFFFFF8) != 8)
                      {
                        BOOL v22 = __nwlog_obj();
                        if (!os_log_type_enabled(v22, OS_LOG_TYPE_ERROR)) {
                          goto LABEL_75;
                        }
                        os_log_type_t v29 = "";
                        id v32 = "nw_ws_validate_client_request";
                        *(_DWORD *)long long buf = 136446722;
                        if (a1) {
                          os_log_type_t v29 = (const char *)(a1 + 227);
                        }
                        __int16 v33 = 2082;
                        BOOL v34 = v29;
                        __int16 v35 = 2048;
                        unint64_t v36 = v30;
                        uint64_t v23 = "%{public}s %{public}s Invalid value for client_max_window_bits (%llu)";
                        goto LABEL_73;
                      }
                      *(unsigned char *)(a1 + 221) = v30;
                      ++v20;
                    }
                  }
                  else
                  {
                    if ((v19 & 8) != 0)
                    {
                      BOOL v22 = __nwlog_obj();
                      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                      {
                        id v24 = "";
                        if (a1) {
                          id v24 = (const char *)(a1 + 227);
                        }
LABEL_67:
                        *(_DWORD *)long long buf = 136446466;
                        id v32 = "nw_ws_validate_client_request";
                        __int16 v33 = 2082;
                        BOOL v34 = v24;
                        uint64_t v23 = "%{public}s %{public}s Duplicate value for server_max_window_bits";
LABEL_68:
                        os_log_type_t v27 = v22;
                        uint32_t v28 = 22;
LABEL_74:
                        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, v23, buf, v28);
                      }
LABEL_75:

                      *(_WORD *)(a1 + 225) &= ~0x40u;
                      goto LABEL_76;
                    }
                    v19 |= 8u;
                    *(unsigned char *)(a1 + 221) = 8;
                    ++v20;
                  }
                }
                if ((v19 & 2) != 0)
                {
                  BOOL v22 = __nwlog_obj();
                  if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)long long buf = 136446466;
                    id v32 = "nw_ws_validate_client_request";
                    __int16 v33 = 2082;
                    BOOL v34 = (const char *)(a1 + 227);
                    uint64_t v23 = "%{public}s %{public}s Duplicate value for client_no_context_takeover";
                    goto LABEL_68;
                  }
                  goto LABEL_75;
                }
                v19 |= 2u;
                *(_WORD *)(a1 + 225) &= ~0x100u;
                ++v20;
              }
            }
          }
        }
      }
LABEL_76:
      if (v14) {
        CFRelease(v14);
      }
      if (ArrayBySeparatingStrings) {
        CFRelease(ArrayBySeparatingStrings);
      }
    }
  }
  uint64_t v8 = 1;
LABEL_7:

  return v8;
}

void sub_183A1F504(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

CFArrayRef nw_ws_copy_extension_decl_as_array(CFStringRef theString)
{
  CFAllocatorRef v1 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @";");
  CFIndex Count = CFArrayGetCount(ArrayBySeparatingStrings);
  CFArrayRef MutableCopy = CFArrayCreateMutableCopy(v1, Count, ArrayBySeparatingStrings);
  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
  for (CFIndex i = 0; i < CFArrayGetCount(MutableCopy); ++i)
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(MutableCopy, i);
    CFIndex Length = CFStringGetLength(ValueAtIndex);
    uint64_t v8 = CFStringCreateMutableCopy(v1, Length, ValueAtIndex);
    CFStringTrimWhitespace(v8);
    CFArraySetValueAtIndex(MutableCopy, i, v8);
    if (v8) {
      CFRelease(v8);
    }
  }
  return MutableCopy;
}

BOOL nw_ws_get_extension_parameter(CFStringRef theString, CFStringRef theString2, unint64_t *a3)
{
  if (!a3) {
    return CFStringCompare(theString, theString2, 1uLL) == kCFCompareEqualTo;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], theString, @"=");
  if (CFArrayGetCount(ArrayBySeparatingStrings) == 2
    && (CFStringRef v6 = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 0),
        CFStringCompare(v6, theString2, 1uLL) == kCFCompareEqualTo))
  {
    uint64_t v7 = 1;
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, 1);
    c_string_from_cfstring = (const char *)nw_utilities_create_c_string_from_cfstring(ValueAtIndex);
    if (c_string_from_cfstring)
    {
      CFStringRef v11 = (char *)c_string_from_cfstring;
      *a3 = atoi(c_string_from_cfstring);
      free(v11);
      uint64_t v7 = 1;
    }
  }
  else
  {
    uint64_t v7 = 0;
  }
  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
  return v7;
}

void nw_ws_present_request_to_user(uint64_t a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  size_t v4 = *(__CFHTTPMessage **)(a1 + 24);
  CFStringRef v5 = objc_alloc_init(NWConcrete_nw_ws_request);
  CFDictionaryRef v6 = CFHTTPMessageCopyAllHeaderFields(v4);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    size_t v25 = "nw_ws_present_request_to_user";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v8, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v9 = (id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)long long buf = 136446210;
          size_t v25 = "nw_ws_present_request_to_user";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s CFHTTPMessageCopyAllHeaderFields failed", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v9 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)long long buf = 136446466;
            size_t v25 = "nw_ws_present_request_to_user";
            __int16 v26 = 2082;
            os_log_type_t v27 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v15, "%{public}s CFHTTPMessageCopyAllHeaderFields failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v8) {
            goto LABEL_9;
          }
          goto LABEL_8;
        }
        if (v16)
        {
          *(_DWORD *)long long buf = 136446210;
          size_t v25 = "nw_ws_present_request_to_user";
          _os_log_impl(&dword_1830D4000, v9, v15, "%{public}s CFHTTPMessageCopyAllHeaderFields failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v9 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)long long buf = 136446210;
          size_t v25 = "nw_ws_present_request_to_user";
          _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s CFHTTPMessageCopyAllHeaderFields failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v8)
    {
LABEL_9:
      nw_framer_mark_failed_with_error(v3, 14);
      goto LABEL_10;
    }
LABEL_8:
    free(v8);
    goto LABEL_9;
  }
LABEL_10:
  CFDictionaryApplyFunction(v6, (CFDictionaryApplierFunction)nw_ws_copy_headers_into_ws_request, v5);
  if (v6) {
    CFRelease(v6);
  }
  nw_protocol_options_t v11 = nw_framer_copy_options(v3);
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 3221225472;
  v18[2] = __nw_ws_present_request_to_user_block_invoke;
  v18[3] = &unk_1E5242408;
  CFStringRef v12 = v5;
  int v19 = v12;
  uint64_t v21 = a1;
  size_t v13 = v3;
  CFIndex v20 = v13;
  nw_protocol_options_access_handle(v11, v18);
}

void sub_183A1FAEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_present_request_to_user_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3 = *(NSObject **)(a2 + 48);
  if (v3 && *(void *)(a2 + 40))
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = __nw_ws_present_request_to_user_block_invoke_2;
    v8[3] = &unk_1E5244068;
    uint64_t v11 = a2;
    id v4 = *(id *)(a1 + 32);
    CFDictionaryRef v6 = *(void **)(a1 + 40);
    uint64_t v5 = *(void *)(a1 + 48);
    id v9 = v4;
    uint64_t v12 = v5;
    id v10 = v6;
    dispatch_async(v3, v8);
  }
  else
  {
    nw_ws_write_server_response(*(void *)(a1 + 48), *(void **)(a1 + 40), 0);
  }
  return 1;
}

void __nw_ws_present_request_to_user_block_invoke_2(uint64_t a1)
{
  (*(void (**)(void))(*(void *)(*(void *)(a1 + 48) + 40) + 16))();
  id v2 = (id)objc_claimAutoreleasedReturnValue();
  nw_ws_write_server_response(*(void *)(a1 + 56), *(void **)(a1 + 40), v2);
}

void sub_183A1FC64(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void nw_ws_write_server_response(uint64_t a1, void *a2, void *a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a2;
  CFDictionaryRef v6 = a3;
  id v7 = v6;
  uint64_t v56 = 0;
  os_log_type_t v57 = &v56;
  uint64_t v58 = 0x2020000000;
  uint64_t v59 = 0;
  if (v6)
  {
    unsigned int v8 = v6[2];
    if (v8 >= 2)
    {
      if (v8 != 2) {
        goto LABEL_30;
      }
      CFHTTPMessageRef Response = CFHTTPMessageCreateResponse((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 400, @"Bad Request", (CFStringRef)*MEMORY[0x1E4F18F90]);
      v57[3] = (uint64_t)Response;
      if (Response) {
        goto LABEL_30;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v33 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446210;
      v61 = "nw_ws_write_server_response";
      uint64_t v23 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v54 = 0;
      if (!__nwlog_fault((const char *)v23, &type, &v54))
      {
LABEL_84:
        if (!v23)
        {
LABEL_86:
          nw_framer_mark_failed_with_error(v5, 14);
          goto LABEL_87;
        }
LABEL_85:
        free(v23);
        goto LABEL_86;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v24 = (id)gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          v61 = "nw_ws_write_server_response";
          _os_log_impl(&dword_1830D4000, v24, v34, "%{public}s CFHTTPMessageCreateResponse failed", buf, 0xCu);
        }
        goto LABEL_83;
      }
      if (!v54)
      {
        id v24 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          v61 = "nw_ws_write_server_response";
          _os_log_impl(&dword_1830D4000, v24, v42, "%{public}s CFHTTPMessageCreateResponse failed, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_83;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v24 = __nwlog_obj();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)long long buf = 136446210;
          v61 = "nw_ws_write_server_response";
          _os_log_impl(&dword_1830D4000, v24, v36, "%{public}s CFHTTPMessageCreateResponse failed, no backtrace", buf, 0xCu);
        }
        goto LABEL_83;
      }
      if (v37)
      {
        *(_DWORD *)long long buf = 136446466;
        v61 = "nw_ws_write_server_response";
        __int16 v62 = 2082;
        size_t v63 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v24, v36, "%{public}s CFHTTPMessageCreateResponse failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_45;
    }
  }
  CFAllocatorRef v9 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  id v10 = CFHTTPMessageCreateResponse((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 101, @"Switching Protocols", (CFStringRef)*MEMORY[0x1E4F18F90]);
  v57[3] = (uint64_t)v10;
  if (!v10)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    v61 = "nw_ws_write_server_response";
    uint64_t v23 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault((const char *)v23, &type, &v54)) {
      goto LABEL_84;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v24 = (id)gLogObj;
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)long long buf = 136446210;
        v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s CFHTTPMessageCreateResponse failed", buf, 0xCu);
      }
LABEL_83:

      goto LABEL_84;
    }
    if (!v54)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v24 = (id)gLogObj;
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)long long buf = 136446210;
        v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_1830D4000, v24, v35, "%{public}s CFHTTPMessageCreateResponse failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_83;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v24 = (id)gLogObj;
    os_log_type_t v29 = type;
    BOOL v30 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (v30)
      {
        *(_DWORD *)long long buf = 136446210;
        v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s CFHTTPMessageCreateResponse failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_83;
    }
    if (v30)
    {
      *(_DWORD *)long long buf = 136446466;
      v61 = "nw_ws_write_server_response";
      __int16 v62 = 2082;
      size_t v63 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s CFHTTPMessageCreateResponse failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_45:

    free(backtrace_string);
    if (!v23) {
      goto LABEL_86;
    }
    goto LABEL_85;
  }
  CFHTTPMessageSetHeaderFieldValue(v10, @"Upgrade", @"WebSocket");
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v57[3], @"Connection", @"Upgrade");
  CFStringRef v11 = CFHTTPMessageCopyHeaderFieldValue(*(CFHTTPMessageRef *)(a1 + 24), @"Sec-WebSocket-Key");
  CFStringRef v12 = v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v26 = (id)gLogObj;
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      v61 = "nw_ws_write_server_response";
      __int16 v62 = 2082;
      size_t v63 = (char *)(a1 + 227);
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s keyRef should not be nil", buf, 0x16u);
    }

    os_log_type_t v27 = (const void *)v57[3];
    if (v27)
    {
      CFRelease(v27);
      v57[3] = 0;
    }
    goto LABEL_40;
  }
  BOOL v13 = nw_ws_copy_response_for_challenge(v11);
  CFRelease(v12);
  if (!v13)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v31 = (id)gLogObj;
    if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      v61 = "nw_ws_write_server_response";
      __int16 v62 = 2082;
      size_t v63 = (char *)(a1 + 227);
      _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s %{public}s acceptRef should not be nil", buf, 0x16u);
    }

    id v32 = (const void *)v57[3];
    if (v32)
    {
      CFRelease(v32);
      v57[3] = 0;
    }
LABEL_40:
    nw_framer_mark_failed_with_error(v5, 14);
    goto LABEL_87;
  }
  CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v57[3], @"Sec-WebSocket-Accept", (CFStringRef)v13);
  CFRelease((CFTypeRef)v13);
  if ((*(_WORD *)(a1 + 225) & 0x40) != 0)
  {
    CFMutableStringRef Mutable = CFStringCreateMutable(0, 0);
    CFStringAppendCString(Mutable, "permessage-deflate", 0x8000100u);
    __int16 v15 = *(_WORD *)(a1 + 225);
    if ((v15 & 0x80) == 0)
    {
      CFStringAppendCString(Mutable, "; server_no_context_takeover", 0x8000100u);
      __int16 v15 = *(_WORD *)(a1 + 225);
    }
    if ((v15 & 0x100) == 0) {
      CFStringAppendCString(Mutable, "; client_no_context_takeover", 0x8000100u);
    }
    if ((*(unsigned char *)(a1 + 220) & 0xF8) == 8) {
      CFStringAppendFormat(Mutable, 0, @"; server_max_window_bits=%d", *(unsigned __int8 *)(a1 + 220));
    }
    if ((*(unsigned char *)(a1 + 221) & 0xF8) == 8) {
      CFStringAppendFormat(Mutable, 0, @"; client_max_window_bits=%d", *(unsigned __int8 *)(a1 + 221));
    }
    CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v57[3], @"Sec-WebSocket-Extensions", Mutable);
    if (Mutable) {
      CFRelease(Mutable);
    }
  }
  if (!v7) {
    goto LABEL_30;
  }
  BOOL v16 = v7;
  uint64_t isa = (const char *)v16[2].isa;

  if (isa && *isa)
  {
    CFStringRef v18 = CFStringCreateWithCString(v9, isa, 0x8000100u);
    if (v18)
    {
      CFHTTPMessageSetHeaderFieldValue((CFHTTPMessageRef)v57[3], @"Sec-WebSocket-Protocol", v18);
      CFRelease(v18);
      goto LABEL_22;
    }
    id v38 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    v61 = "nw_ws_write_server_response";
    BOOL v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v39, &type, &v54)) {
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)long long buf = 136446210;
        v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s CFStringCreateWithCString failed", buf, 0xCu);
      }
    }
    else if (v54)
    {
      char v43 = (char *)__nw_create_backtrace_string();
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v44 = type;
      BOOL v45 = os_log_type_enabled(v40, type);
      if (v43)
      {
        if (v45)
        {
          *(_DWORD *)long long buf = 136446466;
          v61 = "nw_ws_write_server_response";
          __int16 v62 = 2082;
          size_t v63 = v43;
          _os_log_impl(&dword_1830D4000, v40, v44, "%{public}s CFStringCreateWithCString failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v43);
        goto LABEL_94;
      }
      if (v45)
      {
        *(_DWORD *)long long buf = 136446210;
        v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_1830D4000, v40, v44, "%{public}s CFStringCreateWithCString failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)long long buf = 136446210;
        v61 = "nw_ws_write_server_response";
        _os_log_impl(&dword_1830D4000, v40, v46, "%{public}s CFStringCreateWithCString failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_94:
    if (v39) {
      free(v39);
    }
    __int16 v47 = (const void *)v57[3];
    if (v47)
    {
      CFRelease(v47);
      v57[3] = 0;
    }
    goto LABEL_86;
  }
LABEL_22:
  enumerator[0] = MEMORY[0x1E4F143A8];
  enumerator[1] = 3221225472;
  enumerator[2] = ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke;
  enumerator[3] = &unk_1E5242430;
  enumerator[4] = &v56;
  if (nw_ws_response_enumerate_additional_headers(v16, enumerator))
  {
LABEL_30:
    async_block[0] = MEMORY[0x1E4F143A8];
    async_block[1] = 3221225472;
    async_block[2] = ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke_93;
    async_block[3] = &unk_1E5242458;
    uint64_t v52 = a1;
    uint64_t v49 = v7;
    long long v51 = &v56;
    os_log_type_t v50 = v5;
    nw_framer_async(v50, async_block);

    goto LABEL_87;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v19 = (id)gLogObj;
  if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136446466;
    v61 = "nw_ws_write_server_response";
    __int16 v62 = 2082;
    size_t v63 = (char *)(a1 + 227);
    _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s failed to set all additional headers", buf, 0x16u);
  }

  CFIndex v20 = (const void *)v57[3];
  if (v20)
  {
    CFRelease(v20);
    v57[3] = 0;
  }
  nw_framer_mark_failed_with_error(v5, 14);
LABEL_87:
  _Block_object_dispose(&v56, 8);
}

void sub_183A2095C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke(uint64_t a1, const char *a2, const char *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  CFStringRef v6 = CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  CFStringRef v7 = CFStringCreateWithCString(v5, a3, 0x8000100u);
  CFStringRef v8 = v7;
  if (v6) {
    BOOL v9 = v7 == 0;
  }
  else {
    BOOL v9 = 1;
  }
  uint64_t v10 = !v9;
  if (v9)
  {
    if (v6) {
      CFRelease(v6);
    }
    if (v8) {
      CFRelease(v8);
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
    CFStringRef v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v12, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v15 = "%{public}s CFStringCreateWithCString failed";
LABEL_27:
        CFIndex v20 = v13;
        os_log_type_t v21 = v14;
        goto LABEL_28;
      }
      if (!v22)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v13 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_29;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v15 = "%{public}s CFStringCreateWithCString failed, backtrace limit exceeded";
        goto LABEL_27;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v13 = (id)gLogObj;
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (!v18)
        {
LABEL_29:

          if (!v12) {
            return v10;
          }
          goto LABEL_23;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v15 = "%{public}s CFStringCreateWithCString failed, no backtrace";
        CFIndex v20 = v13;
        os_log_type_t v21 = v17;
LABEL_28:
        _os_log_impl(&dword_1830D4000, v20, v21, v15, buf, 0xCu);
        goto LABEL_29;
      }
      if (v18)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v25 = "nw_ws_write_server_response_block_invoke";
        __int16 v26 = 2082;
        os_log_type_t v27 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v17, "%{public}s CFStringCreateWithCString failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v12) {
      return v10;
    }
LABEL_23:
    free(v12);
    return v10;
  }
  CFHTTPMessageSetHeaderFieldValue(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 32) + 8) + 24), v6, v7);
  CFRelease(v6);
  CFRelease(v8);
  return v10;
}

void ___ZL27nw_ws_write_server_responseP13nw_ws_state_tPU23objcproto12OS_nw_framer8NSObjectPU28objcproto17OS_nw_ws_responseS1__block_invoke_93(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  objc_storeStrong((id *)(*(void *)(a1 + 56) + 48), *(id *)(a1 + 32));
  CFDataRef v2 = CFHTTPMessageCopySerializedMessage(*(CFHTTPMessageRef *)(*(void *)(*(void *)(a1 + 48) + 8) + 24));
  id v3 = *(const void **)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  if (v3)
  {
    CFRelease(v3);
    *(void *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    __int16 v26 = "nw_ws_write_server_response_block_invoke";
    CFAllocatorRef v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v5, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFStringRef v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)long long buf = 136446210;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        CFStringRef v8 = "%{public}s CFHTTPMessageCopySerializedMessage failed";
LABEL_22:
        BOOL v16 = v6;
        os_log_type_t v17 = v7;
        goto LABEL_23;
      }
      if (!v23)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFStringRef v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_24;
        }
        *(_DWORD *)long long buf = 136446210;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        CFStringRef v8 = "%{public}s CFHTTPMessageCopySerializedMessage failed, backtrace limit exceeded";
        goto LABEL_22;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFStringRef v6 = (id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_24:

          if (!v5) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
        *(_DWORD *)long long buf = 136446210;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        CFStringRef v8 = "%{public}s CFHTTPMessageCopySerializedMessage failed, no backtrace";
        BOOL v16 = v6;
        os_log_type_t v17 = v10;
LABEL_23:
        _os_log_impl(&dword_1830D4000, v16, v17, v8, buf, 0xCu);
        goto LABEL_24;
      }
      if (v11)
      {
        *(_DWORD *)long long buf = 136446466;
        __int16 v26 = "nw_ws_write_server_response_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s CFHTTPMessageCopySerializedMessage failed, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v5)
    {
LABEL_15:
      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 40), 14);
      goto LABEL_16;
    }
LABEL_14:
    free(v5);
    goto LABEL_15;
  }
LABEL_16:
  CFStringRef v12 = *(NSObject **)(a1 + 40);
  BytePtr = CFDataGetBytePtr(v2);
  CFIndex Length = CFDataGetLength(v2);
  nw_framer_write_output(v12, BytePtr, Length);
  if (v2) {
    CFRelease(v2);
  }
  if (gLogDatapath)
  {
    BOOL v18 = __nwlog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v19 = *(void *)(a1 + 56);
      CFIndex v20 = (const char *)(v19 + 227);
      if (!v19) {
        CFIndex v20 = "";
      }
      char v21 = *(_WORD *)(v19 + 225);
      __int16 v26 = "nw_ws_write_server_response_block_invoke";
      *(_DWORD *)long long buf = 136446722;
      __int16 v27 = 2082;
      uint64_t v28 = (void *)v20;
      if ((v21 & 4) != 0) {
        char v22 = "server";
      }
      else {
        char v22 = "client";
      }
      __int16 v29 = 2082;
      BOOL v30 = v22;
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s %{public}s handshake complete", buf, 0x20u);
    }
  }
  uint64_t v15 = *(void *)(a1 + 56);
  *(_DWORD *)(v15 + 180) = 2;
  *(_DWORD *)(v15 + 18_Block_object_dispose(&a9, 8) = 2;
  *(_WORD *)(v15 + 225) &= ~2u;
  nw_framer_mark_ready(*(nw_framer_t *)(a1 + 40));
}

void nw_ws_copy_headers_into_ws_request(const __CFString *a1, const __CFString *a2, void *a3)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  CFAllocatorRef v5 = a3;
  if (CFStringCompare(a1, @"Sec-WebSocket-Version", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Upgrade", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Connection", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Sec-WebSocket-Key", 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_44;
  }
  if (CFStringCompare(a1, @"Sec-WebSocket-Protocol", 1uLL))
  {
    c_string_from_cfstring = (char *)nw_utilities_create_c_string_from_cfstring(a1);
    uint64_t v7 = nw_utilities_create_c_string_from_cfstring(a2);
    CFStringRef v8 = (char *)v7;
    if (!c_string_from_cfstring || !v7)
    {
      if (!c_string_from_cfstring) {
        goto LABEL_42;
      }
      goto LABEL_41;
    }
    BOOL v9 = v5;
    os_log_type_t v10 = v9;
    if (v9)
    {
      BOOL v11 = (void *)v9[2];
      xpc_object_t v12 = xpc_string_create(c_string_from_cfstring);
      xpc_array_append_value(v11, v12);

      BOOL v13 = (void *)v10[3];
      xpc_object_t v14 = xpc_string_create(v8);
      xpc_array_append_value(v13, v14);

LABEL_10:
LABEL_41:
      free(c_string_from_cfstring);
LABEL_42:
      if (v8) {
        free(v8);
      }
      goto LABEL_44;
    }
    id v32 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v46 = "nw_ws_request_add_additional_header";
    id v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v33, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v34 = __nwlog_obj();
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v46 = "nw_ws_request_add_additional_header";
          _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s called with null request", buf, 0xCu);
        }
      }
      else if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v34 = __nwlog_obj();
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v46 = "nw_ws_request_add_additional_header";
            __int16 v47 = 2082;
            long long v48 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_61;
        }
        if (v38)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v46 = "nw_ws_request_add_additional_header";
          _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v34 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v46 = "nw_ws_request_add_additional_header";
          _os_log_impl(&dword_1830D4000, v34, v39, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_61:
    if (v33) {
      free(v33);
    }
    goto LABEL_10;
  }
  CFArrayRef ArrayBySeparatingStrings = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, @",");
  CFIndex v16 = 0;
  while (v16 < CFArrayGetCount(ArrayBySeparatingStrings))
  {
    CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(ArrayBySeparatingStrings, v16);
    BOOL v18 = (char *)nw_utilities_create_c_string_from_cfstring(ValueAtIndex);
    if (v18)
    {
      uint64_t v19 = v5;
      if (v5)
      {
        CFIndex v20 = (void *)v5[1];
        xpc_object_t v21 = xpc_string_create(v18);
        xpc_array_append_value(v20, v21);

        goto LABEL_16;
      }
      char v23 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v46 = "nw_ws_request_add_subprotocol";
      id v24 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (__nwlog_fault(v24, &type, &v43))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_t log = (os_log_t)v24;
          os_log_type_t v25 = __nwlog_obj();
          os_log_type_t v26 = type;
          __int16 v27 = v25;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)long long buf = 136446210;
            os_log_type_t v46 = "nw_ws_request_add_subprotocol";
            _os_log_impl(&dword_1830D4000, v27, v26, "%{public}s called with null request", buf, 0xCu);
          }
        }
        else
        {
          if (v43)
          {
            uint64_t v28 = (char *)__nw_create_backtrace_string();
            loga = __nwlog_obj();
            os_log_type_t v40 = type;
            BOOL v29 = os_log_type_enabled(loga, type);
            if (v28)
            {
              if (v29)
              {
                *(_DWORD *)long long buf = 136446466;
                os_log_type_t v46 = "nw_ws_request_add_subprotocol";
                __int16 v47 = 2082;
                long long v48 = v28;
                _os_log_impl(&dword_1830D4000, loga, v40, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v28);
            }
            else
            {
              if (v29)
              {
                *(_DWORD *)long long buf = 136446210;
                os_log_type_t v46 = "nw_ws_request_add_subprotocol";
                _os_log_impl(&dword_1830D4000, loga, v40, "%{public}s called with null request, no backtrace", buf, 0xCu);
              }
            }
            goto LABEL_36;
          }
          os_log_t log = (os_log_t)v24;
          BOOL v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          __int16 v27 = v30;
          if (os_log_type_enabled(v30, type))
          {
            *(_DWORD *)long long buf = 136446210;
            os_log_type_t v46 = "nw_ws_request_add_subprotocol";
            _os_log_impl(&dword_1830D4000, v27, v31, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
          }
        }

        id v24 = (char *)log;
      }
LABEL_36:
      if (v24) {
        free(v24);
      }
LABEL_16:

      free(v18);
      ++v16;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v22 = (id)gLogObj;
      if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v46 = "nw_ws_copy_headers_into_ws_request";
        _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s failed to add subprotocol to websocket request", buf, 0xCu);
      }

      ++v16;
    }
  }
  if (ArrayBySeparatingStrings) {
    CFRelease(ArrayBySeparatingStrings);
  }
LABEL_44:
}

void sub_183A21844(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_ws_validate_server_response_with_protocol_options(uint64_t a1, uint64_t a2, void *a3, _DWORD *a4)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  id v7 = a3;
  CFStringRef v8 = v7;
  if (!a1)
  {
    xpc_object_t v12 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null response", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (!v31)
    {
      xpc_object_t v14 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v27, "%{public}s called with null response, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    xpc_object_t v14 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null response, no backtrace", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (v22)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null response, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_37:

    free(backtrace_string);
    goto LABEL_56;
  }
  if (!a2)
  {
    CFIndex v16 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null client_key", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (!v31)
    {
      xpc_object_t v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null client_key, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    xpc_object_t v14 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null client_key, no backtrace", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (v24)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null client_key, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_37;
  }
  if (v7)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x16812000000;
    os_log_type_t v34 = __Block_byref_object_copy__45180;
    os_log_type_t v35 = __Block_byref_object_dispose__45181;
    os_log_type_t v36 = "!0!2/\x130";
    uint64_t v37 = 0;
    id v39 = 0;
    long long v41 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v48 = 0u;
    long long v49 = 0u;
    long long v50 = 0u;
    long long v51 = 0u;
    long long v52 = 0u;
    long long v53 = 0u;
    long long v54 = 0u;
    long long v55 = 0u;
    long long v56 = 0u;
    memset(v57, 0, sizeof(v57));
    uint64_t v38 = a2;
    uint64_t v40 = a1;
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 3221225472;
    v30[2] = __nw_ws_validate_server_response_with_protocol_options_block_invoke;
    v30[3] = &unk_1E5248E90;
    v30[4] = buf;
    nw_protocol_options_access_handle(v7, v30);
    uint64_t v9 = nw_ws_validate_server_response(*(void *)&buf[8] + 48);
    uint64_t v10 = *(void *)&buf[8];
    if (a4) {
      *a4 = *(_DWORD *)(*(void *)&buf[8] + 260);
    }
    nw_ws_options_set_permessage_deflate(v8, (*(_WORD *)(v10 + 273) & 0x40) != 0);
    nw_ws_options_set_permessage_deflate_client_context_takeover(v8, HIBYTE(*(_WORD *)(*(void *)&buf[8] + 273)) & 1);
    nw_ws_options_set_permessage_deflate_server_context_takeover(v8, (*(_WORD *)(*(void *)&buf[8] + 273) & 0x80) != 0);
    nw_ws_options_set_permessage_deflate_client_max_window_bits(v8, *(unsigned char *)(*(void *)&buf[8] + 269));
    nw_ws_options_set_permessage_deflate_server_max_window_bits(v8, *(unsigned char *)(*(void *)&buf[8] + 268));
    _Block_object_dispose(buf, 8);

    goto LABEL_7;
  }
  BOOL v18 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
  BOOL v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (__nwlog_fault(v13, &type, &v31))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null options", buf, 0xCu);
      }
LABEL_55:

      goto LABEL_56;
    }
    if (!v31)
    {
      xpc_object_t v14 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    xpc_object_t v14 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v26 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v26)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
        _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
      goto LABEL_55;
    }
    if (v26)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response_with_protocol_options";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_37;
  }
LABEL_56:
  if (v13) {
    free(v13);
  }
  uint64_t v9 = 0;
LABEL_7:

  return v9;
}

void sub_183A220E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);
  nw_ws_state_t::~nw_ws_state_t((id *)(v12 + 48));

  _Unwind_Resume(a1);
}

__n128 __Block_byref_object_copy__45180(uint64_t a1, uint64_t a2)
{
  *(_OWORD *)(a1 + 4_Block_object_dispose(&a9, 8) = *(_OWORD *)(a2 + 48);
  uint64_t v2 = *(void *)(a2 + 64);
  *(void *)(a2 + 64) = 0;
  *(void *)(a1 + 64) = v2;
  *(_OWORD *)(a1 + 72) = *(_OWORD *)(a2 + 72);
  long long v3 = *(_OWORD *)(a2 + 88);
  *(void *)(a2 + 8_Block_object_dispose(&a9, 8) = 0;
  *(void *)(a2 + 96) = 0;
  *(_OWORD *)(a1 + 8_Block_object_dispose(&a9, 8) = v3;
  uint64_t v4 = *(void *)(a2 + 104);
  *(void *)(a2 + 104) = 0;
  *(void *)(a1 + 104) = v4;
  *(_OWORD *)(a1 + 112) = *(_OWORD *)(a2 + 112);
  long long v5 = *(_OWORD *)(a2 + 128);
  long long v6 = *(_OWORD *)(a2 + 144);
  long long v7 = *(_OWORD *)(a2 + 176);
  *(_OWORD *)(a1 + 160) = *(_OWORD *)(a2 + 160);
  *(_OWORD *)(a1 + 176) = v7;
  *(_OWORD *)(a1 + 12_Block_object_dispose(&a9, 8) = v5;
  *(_OWORD *)(a1 + 144) = v6;
  long long v8 = *(_OWORD *)(a2 + 192);
  long long v9 = *(_OWORD *)(a2 + 208);
  long long v10 = *(_OWORD *)(a2 + 224);
  *(_DWORD *)(a1 + 240) = *(_DWORD *)(a2 + 240);
  *(_OWORD *)(a1 + 20_Block_object_dispose(&a9, 8) = v9;
  *(_OWORD *)(a1 + 224) = v10;
  *(_OWORD *)(a1 + 192) = v8;
  uint64_t v11 = *(void *)(a2 + 244);
  *(void *)(a2 + 244) = 0;
  *(void *)(a1 + 244) = v11;
  long long v12 = *(_OWORD *)(a2 + 252);
  long long v13 = *(_OWORD *)(a2 + 268);
  *(_OWORD *)(a1 + 284) = *(_OWORD *)(a2 + 284);
  *(_OWORD *)(a1 + 26_Block_object_dispose(&a9, 8) = v13;
  *(_OWORD *)(a1 + 252) = v12;
  __n128 result = *(__n128 *)(a2 + 300);
  long long v15 = *(_OWORD *)(a2 + 316);
  long long v16 = *(_OWORD *)(a2 + 332);
  *(_OWORD *)(a1 + 343) = *(_OWORD *)(a2 + 343);
  *(_OWORD *)(a1 + 316) = v15;
  *(_OWORD *)(a1 + 332) = v16;
  *(__n128 *)(a1 + 300) = result;
  return result;
}

void __Block_byref_object_dispose__45181(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 64);
}

uint64_t __nw_ws_validate_server_response_with_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 144) = *(void *)(a2 + 32);
  uint64_t v2 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 273);
  _WORD *v2 = *v2 & 0xFFFE | ((*(unsigned char *)(a2 + 70) & 4) != 0);
  long long v3 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 273);
  *v3 &= ~4u;
  uint64_t v4 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 273);
  *uint64_t v4 = *v4 & 0xFFBF | (8 * *(unsigned __int8 *)(a2 + 70)) & 0x40;
  long long v5 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 273);
  _WORD *v5 = *v5 & 0xFF7F | (8 * *(unsigned __int8 *)(a2 + 70)) & 0x80;
  long long v6 = (_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 273);
  _WORD *v6 = *v6 & 0xFEFF | (((*(unsigned char *)(a2 + 70) & 0x20) != 0) << 8);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 26_Block_object_dispose(&a9, 8) = *(unsigned char *)(a2 + 68);
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 269) = *(unsigned char *)(a2 + 69);
  uint64_t v7 = *(unsigned int *)(a2 + 60);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 200) = *(unsigned int *)(a2 + 64);
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 192) = v7;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 64), *(id *)a2);
  return 1;
}

uint64_t nw_ws_validate_server_response(uint64_t a1)
{
  uint64_t v75 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(__CFHTTPMessage **)(a1 + 24);
  CFStringRef v3 = *(const __CFString **)(a1 + 8);
  if (CFHTTPMessageGetResponseStatusCode(v2) != 101)
  {
    nw_ws_response_t v9 = nw_ws_response_create(nw_ws_response_status_reject, 0);
    long long v10 = *(void **)(a1 + 48);
    *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = v9;

    uint64_t result = 0;
    *(_DWORD *)(a1 + 212) = 0;
    return result;
  }
  nw_ws_response_t v4 = nw_ws_response_create(nw_ws_response_status_accept, 0);
  long long v5 = *(void **)(a1 + 48);
  *(void *)(a1 + 4_Block_object_dispose(&a9, 8) = v4;

  if (gLogDatapath)
  {
    char v31 = __nwlog_obj();
    if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got 101 response", buf, 0x16u);
    }
  }
  CFStringRef v6 = CFHTTPMessageCopyVersion(v2);
  CFStringRef v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v12 = (id)gLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response didn't contain http version", buf, 0x16u);
    }

    goto LABEL_12;
  }
  if (CFStringCompare(v6, (CFStringRef)*MEMORY[0x1E4F18F90], 1uLL))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v8 = (id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      *(_WORD *)&buf[22] = 2112;
      CFStringRef v74 = v7;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response has invalid http version %@", buf, 0x20u);
    }

    CFRelease(v7);
LABEL_12:
    uint64_t result = 0;
    int v13 = 1;
LABEL_13:
    *(_DWORD *)(a1 + 212) = v13;
    return result;
  }
  CFRelease(v7);
  CFStringRef v14 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Upgrade");
  CFStringRef v15 = v14;
  if (!v14 || (BOOL v16 = CFStringCompare(v14, @"WebSocket", 1uLL) == kCFCompareEqualTo, CFRelease(v15), !v16))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response doesn't match expected value", buf, 0x16u);
    }

    uint64_t result = 0;
    int v13 = 3;
    goto LABEL_13;
  }
  CFStringRef v18 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Connection");
  CFStringRef v19 = v18;
  if (!v18 || (BOOL v20 = CFStringCompare(v18, @"Upgrade", 1uLL) == kCFCompareEqualTo, CFRelease(v19), !v20))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v21 = (id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response doesn't match expected value", buf, 0x16u);
    }

    uint64_t result = 0;
    int v13 = 2;
    goto LABEL_13;
  }
  CFStringRef v22 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Sec-WebSocket-Accept");
  if (!v22)
  {
    BOOL v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Sec-WebSocket-Accept has no value!", buf, 0x16u);
    }

    goto LABEL_36;
  }
  BOOL v23 = nw_ws_copy_response_for_challenge(v3);
  BOOL v24 = (const void *)v23;
  if (!v23)
  {
    os_log_type_t v27 = __nwlog_obj();
    if (os_log_type_enabled(v27, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s nw_ws_copy_response_for_challenge", buf, 0x16u);
    }

    CFRelease(v22);
    goto LABEL_36;
  }
  if (CFStringCompare((CFStringRef)v23, v22, 1uLL))
  {
    os_log_type_t v25 = __nwlog_obj();
    if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response doesn't match expected value", buf, 0x16u);
    }

    CFRelease(v24);
    CFRelease(v22);
LABEL_36:
    uint64_t result = 0;
    int v13 = 5;
    goto LABEL_13;
  }
  CFRelease(v24);
  CFRelease(v22);
  CFStringRef v28 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Sec-WebSocket-Protocol");
  CFStringRef v29 = v28;
  if (!v28)
  {
LABEL_47:
    CFStringRef v33 = CFHTTPMessageCopyHeaderFieldValue(v2, @"Sec-WebSocket-Extensions");
    if (v33)
    {
      CFArrayRef theArray = CFStringCreateArrayBySeparatingStrings((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v33, @",");
      CFRelease(v33);
      CFIndex v34 = 0;
      for (char i = 1; ; char i = 0)
      {
LABEL_49:
        if (v34 >= CFArrayGetCount(theArray))
        {
          char v49 = i;
          goto LABEL_111;
        }
        CFStringRef ValueAtIndex = (const __CFString *)CFArrayGetValueAtIndex(theArray, v34);
        CFArrayRef v36 = nw_ws_copy_extension_decl_as_array(ValueAtIndex);
        CFArrayRef v37 = v36;
        if (!v36) {
          break;
        }
        if (CFArrayGetCount(v36) < 1
          || (CFStringRef v38 = (const __CFString *)CFArrayGetValueAtIndex(v37, 0),
              CFStringCompare(v38, @"permessage-deflate", 1uLL)))
        {
          CFArrayRef v47 = v37;
          goto LABEL_99;
        }
        if ((*(_WORD *)(a1 + 225) & 0x40) == 0)
        {
          long long v51 = __nwlog_obj();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 227;
            long long v52 = "%{public}s %{public}s server response contains a permessage-deflate extension that was not negotiated";
            goto LABEL_107;
          }
LABEL_108:

          CFArrayRef v47 = v37;
LABEL_109:
          CFRelease(v47);
          goto LABEL_110;
        }
        if (v34 == 1)
        {
          long long v51 = __nwlog_obj();
          if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 227;
            long long v52 = "%{public}s %{public}s server response contains multiple permessage-deflate extensions";
LABEL_107:
            _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_ERROR, v52, buf, 0x16u);
          }
          goto LABEL_108;
        }
        int v39 = 0;
        for (CFIndex j = 1; ; ++j)
        {
          while (1)
          {
            while (1)
            {
              if (j >= CFArrayGetCount(v37))
              {
                CFRelease(v37);
                ++v34;
                goto LABEL_49;
              }
              CFStringRef v41 = (const __CFString *)CFArrayGetValueAtIndex(v37, j);
              *(void *)os_log_type_t v68 = 0;
              if (CFStringCompare(v41, @"server_no_context_takeover", 1uLL)) {
                break;
              }
              if (v39)
              {
                long long v42 = __nwlog_obj();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                long long v43 = v42;
                long long v44 = "%{public}s %{public}s Duplicate use of parameter server_no_context_takeover";
                uint32_t v45 = 22;
                goto LABEL_87;
              }
              v39 |= 1u;
              *(_WORD *)(a1 + 225) &= ~0x80u;
              ++j;
            }
            if (CFStringCompare(v41, @"client_no_context_takeover", 1uLL) == kCFCompareEqualTo) {
              break;
            }
            if (nw_ws_get_extension_parameter(v41, @"server_max_window_bits", (unint64_t *)v68))
            {
              if ((v39 & 4) != 0)
              {
                long long v42 = __nwlog_obj();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
LABEL_77:
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                long long v43 = v42;
                long long v44 = "%{public}s %{public}s Duplicate use of parameter server_max_window_bits";
                uint32_t v45 = 22;
                goto LABEL_87;
              }
              if ((*(void *)v68 & 0xFFFFFFFFFFFFFFF8) != 8)
              {
                long long v42 = __nwlog_obj();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)long long buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                *(_WORD *)&buf[22] = 2048;
                CFStringRef v74 = *(const __CFString **)v68;
                long long v43 = v42;
                long long v44 = "%{public}s %{public}s Invalid value for server_max_window_bits (%llu)";
LABEL_86:
                uint32_t v45 = 32;
                goto LABEL_87;
              }
              v39 |= 4u;
              *(unsigned char *)(a1 + 220) = v68[0];
              ++j;
            }
            else
            {
              if (!nw_ws_get_extension_parameter(v41, @"client_max_window_bits", (unint64_t *)v68))
              {
                long long v42 = __nwlog_obj();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)long long buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                *(_WORD *)&buf[22] = 2112;
                CFStringRef v74 = v41;
                long long v43 = v42;
                long long v44 = "%{public}s %{public}s Invalid parameter in server permessage-deflate response (%@)";
                goto LABEL_86;
              }
              if ((v39 & 8) != 0)
              {
                long long v42 = __nwlog_obj();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                goto LABEL_77;
              }
              if ((*(void *)v68 & 0xFFFFFFFFFFFFFFF8) != 8)
              {
                long long v42 = __nwlog_obj();
                if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
                  goto LABEL_88;
                }
                *(_DWORD *)long long buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 227;
                *(_WORD *)&buf[22] = 2048;
                CFStringRef v74 = *(const __CFString **)v68;
                long long v43 = v42;
                long long v44 = "%{public}s %{public}s Invalid value for client_max_window_bits (%llu)";
                goto LABEL_86;
              }
              v39 |= 8u;
              *(unsigned char *)(a1 + 221) = v68[0];
              ++j;
            }
          }
          if ((v39 & 2) != 0) {
            break;
          }
          v39 |= 2u;
          *(_WORD *)(a1 + 225) &= ~0x100u;
        }
        long long v42 = __nwlog_obj();
        if (!os_log_type_enabled(v42, OS_LOG_TYPE_ERROR)) {
          goto LABEL_88;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 227;
        long long v43 = v42;
        long long v44 = "%{public}s %{public}s Duplicate use of parameter client_no_context_takeover";
        uint32_t v45 = 22;
LABEL_87:
        _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_ERROR, v44, buf, v45);
LABEL_88:

        CFRelease(v37);
        ++v34;
      }
      CFArrayRef v47 = 0;
LABEL_99:
      long long v50 = __nwlog_obj();
      if (os_log_type_enabled(v50, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 227;
        *(_WORD *)&buf[22] = 2112;
        CFStringRef v74 = ValueAtIndex;
        _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response contains an extension that was not negotiated (%@", buf, 0x20u);
      }

      if (v37) {
        goto LABEL_109;
      }
LABEL_110:
      char v49 = 0;
LABEL_111:
      if (theArray)
      {
        char v53 = v49;
        CFRelease(theArray);
        char v49 = v53;
      }
      if ((v49 & 1) == 0) {
        goto LABEL_116;
      }
    }
    else if ((*(_WORD *)(a1 + 225) & 0x40) != 0)
    {
      long long v46 = __nwlog_obj();
      if (os_log_type_enabled(v46, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_INFO, "%{public}s Not using per-message-deflate compression because server response did not include it in negotiated extensions", buf, 0xCu);
      }

      *(_WORD *)(a1 + 225) &= ~0x40u;
    }
    CFDictionaryRef v54 = CFHTTPMessageCopyAllHeaderFields(v2);
    CFDictionaryRef v55 = v54;
    if (v54)
    {
      CFDictionaryApplyFunction(v54, (CFDictionaryApplierFunction)nw_ws_copy_headers_into_ws_response, *(void **)(a1 + 48));
      CFRelease(v55);
      return 1;
    }
    long long v56 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();

    v68[0] = 16;
    char v66 = 0;
    if (!__nwlog_fault(v57, v68, &v66)) {
      goto LABEL_133;
    }
    if (v68[0] == 17)
    {
      uint64_t v58 = __nwlog_obj();
      os_log_type_t v59 = v68[0];
      if (os_log_type_enabled(v58, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl(&dword_1830D4000, v58, v59, "%{public}s CFHTTPMessageCopyAllHeaderFields failed", buf, 0xCu);
      }
    }
    else if (v66)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v58 = __nwlog_obj();
      os_log_type_t v61 = v68[0];
      BOOL v62 = os_log_type_enabled(v58, (os_log_type_t)v68[0]);
      if (backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v58, v61, "%{public}s CFHTTPMessageCopyAllHeaderFields failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_133;
      }
      if (v62)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl(&dword_1830D4000, v58, v61, "%{public}s CFHTTPMessageCopyAllHeaderFields failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v58 = __nwlog_obj();
      os_log_type_t v63 = v68[0];
      if (os_log_type_enabled(v58, (os_log_type_t)v68[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
        _os_log_impl(&dword_1830D4000, v58, v63, "%{public}s CFHTTPMessageCopyAllHeaderFields failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_133:
    if (v57) {
      free(v57);
    }
    return 0;
  }
  if (CFStringFind(v28, @",", 0).location != -1)
  {
    BOOL v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ws_validate_server_response";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 227;
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response contains multiple Sec-WebSocket-Protocol values", buf, 0x16u);
    }

    CFRelease(v29);
LABEL_116:
    uint64_t result = 0;
    int v13 = 4;
    goto LABEL_13;
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  LOBYTE(v74) = 0;
  id v32 = *(void **)(a1 + 16);
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = __nw_ws_validate_server_response_block_invoke;
  applier[3] = &unk_1E5248460;
  applier[4] = buf;
  applier[5] = v29;
  xpc_array_apply(v32, applier);
  if (*(unsigned char *)(*(void *)&buf[8] + 24))
  {
    CFRelease(v29);
    _Block_object_dispose(buf, 8);
    goto LABEL_47;
  }
  long long v48 = __nwlog_obj();
  if (os_log_type_enabled(v48, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)os_log_type_t v68 = 136446722;
    *(void *)&v68[4] = "nw_ws_validate_server_response";
    __int16 v69 = 2082;
    uint64_t v70 = a1 + 227;
    __int16 v71 = 2112;
    CFStringRef v72 = v29;
    _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_ERROR, "%{public}s %{public}s server response contains a Sec-WebSocket-Protocol value that was not advertised (%@)", v68, 0x20u);
  }

  CFRelease(v29);
  *(_DWORD *)(a1 + 212) = 4;
  _Block_object_dispose(buf, 8);
  return 0;
}

void sub_183A23428(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v1 - 128), 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_validate_server_response_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  string_ptr = xpc_string_get_string_ptr(v4);
  CFStringRef v6 = CFStringCreateWithCString(0, string_ptr, 0x8000100u);
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
    long long v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s CFStringCreatewithCString failed", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
            __int16 v22 = 2082;
            BOOL v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s CFStringCreatewithCString failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v10) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }
        if (v16)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
          _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s CFStringCreatewithCString failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v11 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v21 = "nw_ws_validate_server_response_block_invoke";
          _os_log_impl(&dword_1830D4000, v11, v17, "%{public}s CFStringCreatewithCString failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v10) {
      goto LABEL_11;
    }
LABEL_10:
    free(v10);
    goto LABEL_11;
  }
  CFComparisonResult v7 = CFStringCompare(*(CFStringRef *)(a1 + 40), v6, 0);
  CFRelease(v6);
  uint64_t v8 = 1;
  if (v7 == kCFCompareEqualTo)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
LABEL_11:
    uint64_t v8 = 0;
  }

  return v8;
}

void sub_183A2379C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_copy_headers_into_ws_response(const __CFString *a1, const __CFString *a2, void *a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  long long v5 = a3;
  if (CFStringCompare(a1, @"Sec-WebSocket-Version", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Upgrade", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Connection", 1uLL) == kCFCompareEqualTo
    || CFStringCompare(a1, @"Sec-WebSocket-Accept", 1uLL) == kCFCompareEqualTo)
  {
    goto LABEL_18;
  }
  if (CFStringCompare(a1, @"Sec-WebSocket-Protocol", 1uLL))
  {
    c_string_from_cfstring = (char *)nw_utilities_create_c_string_from_cfstring(a1);
    CFComparisonResult v7 = (const char *)nw_utilities_create_c_string_from_cfstring(a2);
    uint64_t v8 = (void *)v7;
    if (c_string_from_cfstring && v7)
    {
      nw_ws_response_add_additional_header(v5, c_string_from_cfstring, v7);
    }
    else if (!c_string_from_cfstring)
    {
      goto LABEL_16;
    }
    free(c_string_from_cfstring);
LABEL_16:
    if (!v8)
    {
LABEL_18:

      return;
    }
LABEL_17:
    free(v8);
    goto LABEL_18;
  }
  uint64_t v8 = (void *)nw_utilities_create_c_string_from_cfstring(a2);
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v25 = "nw_ws_copy_headers_into_ws_response";
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s failed to get selected_subprotocol from websocket response", buf, 0xCu);
    }

    goto LABEL_18;
  }
  id v9 = v5;
  if (!v9)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v25 = "nw_ws_response_set_selected_subprotocol";
    int v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        CFStringRef v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v25 = "nw_ws_response_set_selected_subprotocol";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null response", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        CFStringRef v14 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v25 = "nw_ws_response_set_selected_subprotocol";
            __int16 v26 = 2082;
            os_log_type_t v27 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null response, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }
        if (v20)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v25 = "nw_ws_response_set_selected_subprotocol";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null response, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        CFStringRef v14 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v25 = "nw_ws_response_set_selected_subprotocol";
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null response, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_40:
    if (v13) {
      free(v13);
    }
    goto LABEL_13;
  }
  long long v10 = strdup((const char *)v8);
  if (v10)
  {
LABEL_12:
    v9[2].uint64_t isa = (Class)v10;
LABEL_13:

    goto LABEL_17;
  }
  BOOL v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v25 = "strict_strdup";
  os_log_type_t v17 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v17))
  {
    free(v17);
    goto LABEL_12;
  }
  __break(1u);
}

void sub_183A23C48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_storage_register_provider(void *a1, const char *a2, long long *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  long long v5 = a1;
  if (!a2)
  {
    CFStringRef v14 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v35 = "nw_storage_register_provider";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v33.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &v33, &type)) {
      goto LABEL_48;
    }
    if (LOBYTE(v33.receiver) == 17)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v33.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v33.receiver))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v35 = "nw_storage_register_provider";
        char v18 = "%{public}s called with null type";
LABEL_46:
        _os_log_impl(&dword_1830D4000, v16, receiver, v18, buf, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v16 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v33.receiver;
      BOOL v26 = os_log_type_enabled(v16, (os_log_type_t)v33.receiver);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v35 = "nw_storage_register_provider";
          __int16 v36 = 2082;
          CFArrayRef v37 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, receiver, "%{public}s called with null type, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_48:
        if (!v15) {
          goto LABEL_7;
        }
LABEL_49:
        free(v15);
        goto LABEL_7;
      }
      if (v26)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v35 = "nw_storage_register_provider";
        char v18 = "%{public}s called with null type, no backtrace";
        goto LABEL_46;
      }
    }
    else
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v33.receiver;
      if (os_log_type_enabled(v16, (os_log_type_t)v33.receiver))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v35 = "nw_storage_register_provider";
        char v18 = "%{public}s called with null type, backtrace limit exceeded";
        goto LABEL_46;
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  if (a3)
  {
    CFStringRef v6 = [NWConcrete_nw_storage_provider_obj alloc];
    if (!v6)
    {
LABEL_56:
      uint64_t v8 = 0;
      goto LABEL_6;
    }
    v33.os_log_type_t receiver = v6;
    v33.super_class = (Class)NWConcrete_nw_storage_provider_obj;
    CFComparisonResult v7 = (char *)objc_msgSendSuper2(&v33, sel_init);
    if (v7)
    {
      uint64_t v8 = v7;
      long long v9 = *a3;
      long long v10 = a3[1];
      *(_OWORD *)(v7 + 40) = a3[2];
      *(_OWORD *)(v7 + 24) = v10;
      *(_OWORD *)(v7 + _Block_object_dispose(&a9, 8) = v9;
      long long v11 = a3[3];
      long long v12 = a3[4];
      long long v13 = a3[5];
      *(_OWORD *)(v7 + 104) = a3[6];
      *(_OWORD *)(v7 + 8_Block_object_dispose(&a9, 8) = v13;
      *(_OWORD *)(v7 + 72) = v12;
      *(_OWORD *)(v7 + 56) = v11;
LABEL_6:
      nw_dictionary_set_value(v5[7], a2, v8);

      goto LABEL_7;
    }
    BOOL v20 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
    os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault((const char *)v21, &type, &v31))
    {
LABEL_54:
      if (v21) {
        free(v21);
      }
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
        uint64_t v24 = "%{public}s [super init] failed";
LABEL_52:
        _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
      }
    }
    else
    {
      if (v31)
      {
        CFStringRef v29 = (char *)__nw_create_backtrace_string();
        char v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        BOOL v30 = os_log_type_enabled(v22, type);
        if (v29)
        {
          if (v30)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
            __int16 v36 = 2082;
            CFArrayRef v37 = v29;
            _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v29);
          goto LABEL_54;
        }
        if (!v30) {
          goto LABEL_53;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
        uint64_t v24 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_52;
      }
      char v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v35 = "-[NWConcrete_nw_storage_provider_obj initWithProvider:]";
        uint64_t v24 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_52;
      }
    }
LABEL_53:

    goto LABEL_54;
  }
  os_log_type_t v19 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v35 = "nw_storage_register_provider";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v33.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v15, &v33, &type)) {
    goto LABEL_48;
  }
  if (LOBYTE(v33.receiver) == 17)
  {
    BOOL v16 = __nwlog_obj();
    os_log_type_t receiver = (os_log_type_t)v33.receiver;
    if (os_log_type_enabled(v16, (os_log_type_t)v33.receiver))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v35 = "nw_storage_register_provider";
      char v18 = "%{public}s called with null provider";
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    BOOL v16 = __nwlog_obj();
    os_log_type_t receiver = (os_log_type_t)v33.receiver;
    if (os_log_type_enabled(v16, (os_log_type_t)v33.receiver))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v35 = "nw_storage_register_provider";
      char v18 = "%{public}s called with null provider, backtrace limit exceeded";
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  os_log_type_t v27 = (char *)__nw_create_backtrace_string();
  BOOL v16 = __nwlog_obj();
  os_log_type_t receiver = (os_log_type_t)v33.receiver;
  BOOL v28 = os_log_type_enabled(v16, (os_log_type_t)v33.receiver);
  if (!v27)
  {
    if (v28)
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v35 = "nw_storage_register_provider";
      char v18 = "%{public}s called with null provider, no backtrace";
      goto LABEL_46;
    }
    goto LABEL_47;
  }
  if (v28)
  {
    *(_DWORD *)long long buf = 136446466;
    os_log_type_t v35 = "nw_storage_register_provider";
    __int16 v36 = 2082;
    CFArrayRef v37 = v27;
    _os_log_impl(&dword_1830D4000, v16, receiver, "%{public}s called with null provider, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v27);
  if (v15) {
    goto LABEL_49;
  }
LABEL_7:
}

void nw_storage_flush_all_storages_atexit()
{
  os_unfair_lock_lock((os_unfair_lock_t)&storages_lock);
  uint64_t v0 = (objc_class *)objc_opt_class();
  InstanceVariable = class_getInstanceVariable(v0, "chain");
  ptrdiff_t Offset = ivar_getOffset(InstanceVariable);
  CFStringRef v3 = (void *)storages;
  if (storages)
  {
    ptrdiff_t v4 = Offset;
    do
    {
      long long v5 = (char *)v3 - v4;
      CFStringRef v6 = *((void *)v5 + 2);
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __nw_storage_flush_all_storages_atexit_block_invoke;
      block[3] = &unk_1E524BAA8;
      long long v9 = v5;
      CFComparisonResult v7 = v5;
      dispatch_async_and_wait(v6, block);

      CFStringRef v3 = (void *)*v3;
    }
    while (v3);
  }
  os_unfair_lock_unlock((os_unfair_lock_t)&storages_lock);
}

void __nw_storage_flush_all_storages_atexit_block_invoke(uint64_t a1)
{
}

void nw_storage_flush(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    CFStringRef v3 = (atomic_uchar *)v1[9];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __nw_storage_flush_block_invoke;
    v11[3] = &unk_1E524AE18;
    long long v12 = v1;
    nw_array_apply(v3, (uint64_t)v11);
    nw_array_remove_all_objects(v2[9]);

    goto LABEL_3;
  }
  ptrdiff_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v16 = "nw_storage_flush";
  long long v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      CFStringRef v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v16 = "nw_storage_flush";
        uint64_t v8 = "%{public}s called with null storage";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        CFStringRef v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v16 = "nw_storage_flush";
            __int16 v17 = 2082;
            char v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null storage, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v10) {
          goto LABEL_18;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v16 = "nw_storage_flush";
        uint64_t v8 = "%{public}s called with null storage, no backtrace";
        goto LABEL_17;
      }
      CFStringRef v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v16 = "nw_storage_flush";
        uint64_t v8 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

uint64_t __nw_storage_flush_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    ptrdiff_t v4 = *(const char **)(a3 + 8);
    long long v5 = *(const char **)(a3 + 16);
  }
  else
  {
    ptrdiff_t v4 = 0;
    long long v5 = 0;
  }
  CFStringRef v6 = nw_storage_provider_for_type(*(void **)(a1 + 32), (uint64_t)v4);
  os_log_type_t v7 = nw_dictionary_copy_value(*(void *)(*(void *)(a1 + 32) + 64), (uint64_t)v5);
  uint64_t v8 = v7;
  if (v7)
  {
    long long v9 = nw_dictionary_copy_value((uint64_t)v7, (uint64_t)v4);
    BOOL v10 = v9;
    if (!v9 || !(*((unsigned int (**)(void *))v6 + 7))(v9)) {
      goto LABEL_146;
    }
    *(void *)n = 0;
    uint64_t v11 = (*((uint64_t (**)(void *, int *))v6 + 6))(v10, n);
    long long v12 = *(sqlite3 ***)(a1 + 32);
    if (v11)
    {
      char v13 = (void *)v11;
      CFStringRef v14 = v12[5];
      if (!v14)
      {
        if (sqlite3_prepare_v2(v12[3], "INSERT OR REPLACE INTO network_storage(key, type, canvas, time) \t\t\t\t\tVALUES (?, ?, ?, strftime('%s','now'))", -1, v12 + 5, 0))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v26 = (id)gLogObj;
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          BOOL v16 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v49 = 0;
          if (!__nwlog_fault(v16, &type, &v49)) {
            goto LABEL_143;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            __int16 v17 = __nwlog_obj();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to prepare statement";
              goto LABEL_141;
            }
LABEL_142:

            goto LABEL_143;
          }
          if (!v49)
          {
            __int16 v17 = __nwlog_obj();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to prepare statement, backtrace limit exceeded";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          __int16 v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          BOOL v34 = os_log_type_enabled(v17, type);
          if (!backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to prepare statement, no backtrace";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          if (v34)
          {
            *(_DWORD *)long long buf = 136446466;
            char v53 = "nw_storage_flush_block_invoke";
            __int16 v54 = 2082;
            CFDictionaryRef v55 = backtrace_string;
            os_log_type_t v35 = "%{public}s Failed to prepare statement, dumping backtrace:%{public}s";
LABEL_97:
            _os_log_impl(&dword_1830D4000, v17, v18, v35, buf, 0x16u);
            goto LABEL_98;
          }
          goto LABEL_98;
        }
        CFStringRef v14 = *(sqlite3_stmt **)(*(void *)(a1 + 32) + 40);
      }
      if (!sqlite3_bind_text(v14, 1, v5, -1, 0))
      {
        if (sqlite3_bind_text(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 40), 2, v4, -1, 0))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v27 = (id)gLogObj;
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          BOOL v16 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v49 = 0;
          if (!__nwlog_fault(v16, &type, &v49)) {
            goto LABEL_143;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            __int16 v17 = __nwlog_obj();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to bind variable";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          if (!v49)
          {
            __int16 v17 = __nwlog_obj();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to bind variable, backtrace limit exceeded";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          __int16 v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          BOOL v37 = os_log_type_enabled(v17, type);
          if (!backtrace_string)
          {
            if (v37)
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to bind variable, no backtrace";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          if (!v37) {
            goto LABEL_98;
          }
        }
        else
        {
          if (!sqlite3_bind_blob(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 40), 3, v13, n[0], 0))
          {
            if (sqlite3_step(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 40)) == 101) {
              goto LABEL_145;
            }
            long long v42 = __nwlog_obj();
            *(_DWORD *)long long buf = 136446210;
            char v53 = "nw_storage_flush_block_invoke";
            BOOL v16 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v49 = 0;
            if (__nwlog_fault(v16, &type, &v49))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __int16 v17 = __nwlog_obj();
                os_log_type_t v18 = type;
                if (os_log_type_enabled(v17, type))
                {
                  *(_DWORD *)long long buf = 136446210;
                  char v53 = "nw_storage_flush_block_invoke";
                  uint64_t v19 = "%{public}s Failed to update";
                  goto LABEL_141;
                }
                goto LABEL_142;
              }
              if (!v49)
              {
                __int16 v17 = __nwlog_obj();
                os_log_type_t v18 = type;
                if (os_log_type_enabled(v17, type))
                {
                  *(_DWORD *)long long buf = 136446210;
                  char v53 = "nw_storage_flush_block_invoke";
                  uint64_t v19 = "%{public}s Failed to update, backtrace limit exceeded";
                  goto LABEL_141;
                }
                goto LABEL_142;
              }
              long long v46 = (char *)__nw_create_backtrace_string();
              __int16 v17 = __nwlog_obj();
              os_log_type_t v18 = type;
              BOOL v47 = os_log_type_enabled(v17, type);
              if (!v46)
              {
                if (v47)
                {
                  *(_DWORD *)long long buf = 136446210;
                  char v53 = "nw_storage_flush_block_invoke";
                  uint64_t v19 = "%{public}s Failed to update, no backtrace";
                  goto LABEL_141;
                }
                goto LABEL_142;
              }
              if (v47)
              {
                *(_DWORD *)long long buf = 136446466;
                char v53 = "nw_storage_flush_block_invoke";
                __int16 v54 = 2082;
                CFDictionaryRef v55 = v46;
                _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Failed to update, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v46);
            }
LABEL_143:
            if (v16) {
LABEL_144:
            }
              free(v16);
LABEL_145:
            sqlite3_reset(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 40));
            free(v13);
            goto LABEL_146;
          }
          __int16 v36 = __nwlog_obj();
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          BOOL v16 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v49 = 0;
          if (!__nwlog_fault(v16, &type, &v49)) {
            goto LABEL_143;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            __int16 v17 = __nwlog_obj();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to bind variable";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          if (!v49)
          {
            __int16 v17 = __nwlog_obj();
            os_log_type_t v18 = type;
            if (os_log_type_enabled(v17, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to bind variable, backtrace limit exceeded";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          __int16 v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          BOOL v43 = os_log_type_enabled(v17, type);
          if (!backtrace_string)
          {
            if (v43)
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              uint64_t v19 = "%{public}s Failed to bind variable, no backtrace";
              goto LABEL_141;
            }
            goto LABEL_142;
          }
          if (!v43) {
            goto LABEL_98;
          }
        }
LABEL_96:
        *(_DWORD *)long long buf = 136446466;
        char v53 = "nw_storage_flush_block_invoke";
        __int16 v54 = 2082;
        CFDictionaryRef v55 = backtrace_string;
        os_log_type_t v35 = "%{public}s Failed to bind variable, dumping backtrace:%{public}s";
        goto LABEL_97;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v15 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446210;
      char v53 = "nw_storage_flush_block_invoke";
      BOOL v16 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v49 = 0;
      if (!__nwlog_fault(v16, &type, &v49)) {
        goto LABEL_143;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v17 = (id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          uint64_t v19 = "%{public}s Failed to bind variable";
LABEL_141:
          _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
          goto LABEL_142;
        }
        goto LABEL_142;
      }
      if (!v49)
      {
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          uint64_t v19 = "%{public}s Failed to bind variable, backtrace limit exceeded";
          goto LABEL_141;
        }
        goto LABEL_142;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v29 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          uint64_t v19 = "%{public}s Failed to bind variable, no backtrace";
          goto LABEL_141;
        }
        goto LABEL_142;
      }
      if (v29) {
        goto LABEL_96;
      }
LABEL_98:

      free(backtrace_string);
      if (!v16) {
        goto LABEL_145;
      }
      goto LABEL_144;
    }
    BOOL v20 = v12[6];
    if (!v20)
    {
      if (sqlite3_prepare_v2(v12[3], "DELETE FROM network_storage WHERE key = ? AND os_log_type_t type = ?", -1, v12 + 6, 0))
      {
        BOOL v30 = __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        char v53 = "nw_storage_flush_block_invoke";
        char v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v49 = 0;
        if (!__nwlog_fault(v22, &type, &v49)) {
          goto LABEL_134;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v24 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)long long buf = 136446210;
            char v53 = "nw_storage_flush_block_invoke";
            os_log_type_t v25 = "%{public}s Failed to prepare statement";
            goto LABEL_132;
          }
LABEL_133:

          goto LABEL_134;
        }
        if (!v49)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v24 = type;
          if (os_log_type_enabled(v23, type))
          {
            *(_DWORD *)long long buf = 136446210;
            char v53 = "nw_storage_flush_block_invoke";
            os_log_type_t v25 = "%{public}s Failed to prepare statement, backtrace limit exceeded";
            goto LABEL_132;
          }
          goto LABEL_133;
        }
        id v32 = (char *)__nw_create_backtrace_string();
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v38 = os_log_type_enabled(v23, type);
        if (!v32)
        {
          if (v38)
          {
            *(_DWORD *)long long buf = 136446210;
            char v53 = "nw_storage_flush_block_invoke";
            os_log_type_t v25 = "%{public}s Failed to prepare statement, no backtrace";
            goto LABEL_132;
          }
          goto LABEL_133;
        }
        if (v38)
        {
          *(_DWORD *)long long buf = 136446466;
          char v53 = "nw_storage_flush_block_invoke";
          __int16 v54 = 2082;
          CFDictionaryRef v55 = v32;
          int v39 = "%{public}s Failed to prepare statement, dumping backtrace:%{public}s";
LABEL_79:
          _os_log_impl(&dword_1830D4000, v23, v24, v39, buf, 0x16u);
          goto LABEL_80;
        }
        goto LABEL_80;
      }
      BOOL v20 = *(sqlite3_stmt **)(*(void *)(a1 + 32) + 48);
    }
    if (sqlite3_bind_text(v20, 1, v5, -1, 0))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v21 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446210;
      char v53 = "nw_storage_flush_block_invoke";
      char v22 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v49 = 0;
      if (!__nwlog_fault(v22, &type, &v49)) {
        goto LABEL_134;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          os_log_type_t v25 = "%{public}s Failed to bind variable";
LABEL_132:
          _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0xCu);
          goto LABEL_133;
        }
        goto LABEL_133;
      }
      if (!v49)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          os_log_type_t v25 = "%{public}s Failed to bind variable, backtrace limit exceeded";
          goto LABEL_132;
        }
        goto LABEL_133;
      }
      id v32 = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v33 = os_log_type_enabled(v23, type);
      if (!v32)
      {
        if (v33)
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          os_log_type_t v25 = "%{public}s Failed to bind variable, no backtrace";
          goto LABEL_132;
        }
        goto LABEL_133;
      }
      if (v33) {
        goto LABEL_78;
      }
    }
    else
    {
      if (!sqlite3_bind_text(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 48), 2, v4, -1, 0))
      {
        if (sqlite3_step(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 48)) == 101) {
          goto LABEL_136;
        }
        uint64_t v40 = __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        char v53 = "nw_storage_flush_block_invoke";
        char v22 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v49 = 0;
        if (__nwlog_fault(v22, &type, &v49))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v23 = __nwlog_obj();
            os_log_type_t v24 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              os_log_type_t v25 = "%{public}s Failed to update";
              goto LABEL_132;
            }
            goto LABEL_133;
          }
          if (!v49)
          {
            os_log_type_t v23 = __nwlog_obj();
            os_log_type_t v24 = type;
            if (os_log_type_enabled(v23, type))
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              os_log_type_t v25 = "%{public}s Failed to update, backtrace limit exceeded";
              goto LABEL_132;
            }
            goto LABEL_133;
          }
          long long v44 = (char *)__nw_create_backtrace_string();
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v24 = type;
          BOOL v45 = os_log_type_enabled(v23, type);
          if (!v44)
          {
            if (v45)
            {
              *(_DWORD *)long long buf = 136446210;
              char v53 = "nw_storage_flush_block_invoke";
              os_log_type_t v25 = "%{public}s Failed to update, no backtrace";
              goto LABEL_132;
            }
            goto LABEL_133;
          }
          if (v45)
          {
            *(_DWORD *)long long buf = 136446466;
            char v53 = "nw_storage_flush_block_invoke";
            __int16 v54 = 2082;
            CFDictionaryRef v55 = v44;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Failed to update, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v44);
        }
LABEL_134:
        if (v22) {
LABEL_135:
        }
          free(v22);
LABEL_136:
        sqlite3_reset(*(sqlite3_stmt **)(*(void *)(a1 + 32) + 48));
LABEL_146:

        goto LABEL_147;
      }
      char v31 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      char v53 = "nw_storage_flush_block_invoke";
      char v22 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v49 = 0;
      if (!__nwlog_fault(v22, &type, &v49)) {
        goto LABEL_134;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          os_log_type_t v25 = "%{public}s Failed to bind variable";
          goto LABEL_132;
        }
        goto LABEL_133;
      }
      if (!v49)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v23, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          os_log_type_t v25 = "%{public}s Failed to bind variable, backtrace limit exceeded";
          goto LABEL_132;
        }
        goto LABEL_133;
      }
      id v32 = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v41 = os_log_type_enabled(v23, type);
      if (!v32)
      {
        if (v41)
        {
          *(_DWORD *)long long buf = 136446210;
          char v53 = "nw_storage_flush_block_invoke";
          os_log_type_t v25 = "%{public}s Failed to bind variable, no backtrace";
          goto LABEL_132;
        }
        goto LABEL_133;
      }
      if (v41)
      {
LABEL_78:
        *(_DWORD *)long long buf = 136446466;
        char v53 = "nw_storage_flush_block_invoke";
        __int16 v54 = 2082;
        CFDictionaryRef v55 = v32;
        int v39 = "%{public}s Failed to bind variable, dumping backtrace:%{public}s";
        goto LABEL_79;
      }
    }
LABEL_80:

    free(v32);
    if (!v22) {
      goto LABEL_136;
    }
    goto LABEL_135;
  }
LABEL_147:

  return 1;
}

char *nw_storage_provider_for_type(void *a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  CFStringRef v3 = a1;
  ptrdiff_t v4 = v3;
  if (v3)
  {
    if (a2)
    {
      long long v5 = (char *)nw_dictionary_copy_value(v3[7], a2);
      if (v5) {
        CFStringRef v6 = v5 + 8;
      }
      else {
        CFStringRef v6 = 0;
      }

      goto LABEL_7;
    }
    char v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    id v21 = "nw_storage_provider_for_type";
    long long v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)long long buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          long long v12 = "%{public}s called with null type";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (!v18)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)long long buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          long long v12 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v17 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)long long buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          long long v12 = "%{public}s called with null type, no backtrace";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (!v17) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      id v21 = "nw_storage_provider_for_type";
      __int16 v22 = 2082;
      os_log_type_t v23 = backtrace_string;
      BOOL v16 = "%{public}s called with null type, dumping backtrace:%{public}s";
LABEL_24:
      _os_log_impl(&dword_1830D4000, v10, v11, v16, buf, 0x16u);
LABEL_25:

      free(backtrace_string);
    }
  }
  else
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    id v21 = "nw_storage_provider_for_type";
    long long v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)long long buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          long long v12 = "%{public}s called with null storage";
LABEL_34:
          _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
        }
LABEL_35:

        goto LABEL_36;
      }
      if (!v18)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)long long buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          long long v12 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v15 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446210;
          id v21 = "nw_storage_provider_for_type";
          long long v12 = "%{public}s called with null storage, no backtrace";
          goto LABEL_34;
        }
        goto LABEL_35;
      }
      if (!v15) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      id v21 = "nw_storage_provider_for_type";
      __int16 v22 = 2082;
      os_log_type_t v23 = backtrace_string;
      BOOL v16 = "%{public}s called with null storage, dumping backtrace:%{public}s";
      goto LABEL_24;
    }
  }
LABEL_36:
  if (v9) {
    free(v9);
  }
  CFStringRef v6 = 0;
LABEL_7:

  return v6;
}

void nw_dns_cache_storage_canvas_remove_past(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v1 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v11 = "nw_dns_cache_storage_canvas_remove_past";
    uint64_t v2 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v8 = 0;
    if (!__nwlog_fault(v2, &type, &v8)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      CFStringRef v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v11 = "nw_dns_cache_storage_canvas_remove_past";
        long long v5 = "%{public}s called with null canvas";
LABEL_16:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        CFStringRef v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v11 = "nw_dns_cache_storage_canvas_remove_past";
            __int16 v12 = 2082;
            char v13 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }
        if (!v7) {
          goto LABEL_17;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v11 = "nw_dns_cache_storage_canvas_remove_past";
        long long v5 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_16;
      }
      CFStringRef v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v11 = "nw_dns_cache_storage_canvas_remove_past";
        long long v5 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
LABEL_17:

LABEL_18:
    if (v2) {
      free(v2);
    }
  }
}

uint64_t nw_dns_cache_storage_needs_canvas_destroy()
{
  return 0;
}

uint64_t nw_dns_cache_storage_canvas_memory_size(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    CFStringRef v3 = v1;
    uint64_t v4 = v3[1];
    if (!v4 || *(void *)(v4 + 24) == *(void *)(v4 + 16))
    {
      uint64_t v5 = 0;
    }
    else
    {
      *(void *)long long buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      uint64_t v19 = 0;
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 3221225472;
      v15[2] = __nw_dns_cache_storage_canvas_memory_size_block_invoke;
      v15[3] = &unk_1E5248058;
      v15[4] = buf;
      nw_array_apply((atomic_uchar *)v4, (uint64_t)v15);
      uint64_t v5 = *(void *)(*(void *)&buf[8] + 24);
      _Block_object_dispose(buf, 8);
    }

    goto LABEL_7;
  }
  BOOL v7 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
  char v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null canvas", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v13)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null canvas, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_memory_size";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null canvas, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0;
LABEL_7:

  return v5;
}

uint64_t __nw_dns_cache_storage_canvas_memory_size_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  int address_family = nw_endpoint_get_address_family(a3);
  if (address_family == 2)
  {
    uint64_t v5 = 9;
    goto LABEL_5;
  }
  if (address_family == 30)
  {
    uint64_t v5 = 21;
LABEL_5:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
  }
  return 1;
}

uint64_t nw_dns_cache_storage_canvas_can_evict()
{
  return 1;
}

BOOL nw_dns_cache_storage_canvas_dirty(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((unsigned char *)v1 + 16) != 0;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v15 = "nw_dns_cache_storage_canvas_dirty";
  CFStringRef v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_dns_cache_storage_canvas_dirty";
        long long v9 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v15 = "nw_dns_cache_storage_canvas_dirty";
            __int16 v16 = 2082;
            BOOL v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_dns_cache_storage_canvas_dirty";
        long long v9 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_dns_cache_storage_canvas_dirty";
        long long v9 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_dns_cache_storage_canvas_serialize(void *a1, size_t *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
    char v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null canvas", buf, 0xCu);
        }
        goto LABEL_42;
      }
      if (!v27)
      {
        BOOL v13 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_1830D4000, v13, v24, "%{public}s called with null canvas, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v13 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null canvas, no backtrace", buf, 0xCu);
        }
        goto LABEL_42;
      }
      if (v21)
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_30:

      free(backtrace_string);
    }
LABEL_43:
    if (v12) {
      free(v12);
    }
    os_log_type_t v8 = 0;
    goto LABEL_8;
  }
  if (!a2)
  {
    BOOL v15 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
    char v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null size", buf, 0xCu);
        }
LABEL_42:

        goto LABEL_43;
      }
      if (!v27)
      {
        BOOL v13 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s called with null size, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_42;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v13 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
          _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null size, no backtrace", buf, 0xCu);
        }
        goto LABEL_42;
      }
      if (v23)
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_canvas_serialize";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null size, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_30;
    }
    goto LABEL_43;
  }
  id v5 = v3;
  *((unsigned char *)v5 + 16) = 0;
  size_t v6 = nw_dns_cache_storage_canvas_memory_size(v5);
  *a2 = v6;
  if (!v6)
  {
    os_log_type_t v8 = 0;
    goto LABEL_7;
  }
  size_t v7 = v6;
  os_log_type_t v8 = malloc_type_malloc(v6, 0xF2B69DE5uLL);
  if (v8)
  {
LABEL_5:
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    BOOL v30 = v8;
    long long v9 = (atomic_uchar *)*((void *)v5 + 1);
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = __nw_dns_cache_storage_canvas_serialize_block_invoke;
    v26[3] = &unk_1E5248058;
    v26[4] = buf;
    nw_array_apply(v9, (uint64_t)v26);
    _Block_object_dispose(buf, 8);
LABEL_7:

LABEL_8:
    return (BOOL)v8;
  }
  BOOL v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  *(void *)&uint8_t buf[4] = "strict_malloc";
  *(_WORD *)&unsigned char buf[12] = 2048;
  *(void *)&buf[14] = v7;
  uint64_t v18 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

uint64_t __nw_dns_cache_storage_canvas_serialize_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  address = nw_endpoint_get_address(v4);
  __int16 priority = nw_endpoint_get_priority(v4);

  if (address)
  {
    int sa_family = address->sa_family;
    if (sa_family == 30)
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v8 = a1 + 32;
      **(unsigned char **)(*(void *)(v12 + 8) + 24) = 30;
      *(sockaddr *)++*(void *)(*(void *)(*(void *)v8 + 8) + 24) = *(sockaddr *)&address->sa_data[6];
      uint64_t v10 = *(void *)(*(void *)v8 + 8);
      uint64_t v11 = *(void *)(v10 + 24) + 16;
      goto LABEL_6;
    }
    if (sa_family == 2)
    {
      uint64_t v9 = *(void *)(a1 + 32);
      uint64_t v8 = a1 + 32;
      **(unsigned char **)(*(void *)(v9 + 8) + 24) = 2;
      *(_DWORD *)++*(void *)(*(void *)(*(void *)v8 + 8) + 24) = *(_DWORD *)&address->sa_data[2];
      uint64_t v10 = *(void *)(*(void *)v8 + 8);
      uint64_t v11 = *(void *)(v10 + 24) + 4;
LABEL_6:
      *(void *)(v10 + 24) = v11;
      **(_WORD **)(*(void *)(*(void *)v8 + 8) + 24) = *(_WORD *)address->sa_data;
      *(void *)(*(void *)(*(void *)v8 + 8) + 24) += 2;
      **(_WORD **)(*(void *)(*(void *)v8 + 8) + 24) = priority;
      *(void *)(*(void *)(*(void *)v8 + 8) + 24) += 2;
    }
  }
  return 1;
}

NWConcrete_nw_dns_cache_storage_canvas *nw_dns_cache_storage_canvas_deserialize(unsigned __int8 *a1, unint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = objc_alloc_init(NWConcrete_nw_dns_cache_storage_canvas);
  BOOL v5 = nw_array_create();
  endpoints = v4->endpoints;
  v4->endpoints = (OS_nw_array *)v5;

  if (!a2)
  {
LABEL_12:
    os_log_type_t v14 = v4;
    goto LABEL_16;
  }
  while (1)
  {
    size_t v7 = (sockaddr *)(a1 + 1);
    int v8 = *a1;
    if (v8 != 30) {
      break;
    }
    sockaddr address_8 = (sockaddr)0;
    int v18 = 0;
    uint64_t address = 7708;
    if (a2 < 0x11) {
      goto LABEL_15;
    }
    sockaddr address_8 = *v7;
    if (a2 - 17 <= 1) {
      goto LABEL_15;
    }
    WORD1(address) = *(_WORD *)(a1 + 17);
    unint64_t v9 = a2 - 19;
    uint64_t v10 = (unsigned __int16 *)(a1 + 19);
LABEL_10:
    nw_endpoint_t v11 = nw_endpoint_create_address((const sockaddr *)&address);
    nw_endpoint_t v12 = v11;
    if (v9 <= 1) {
      goto LABEL_14;
    }
    unsigned int v13 = *v10;
    a1 = (unsigned __int8 *)(v10 + 1);
    a2 = v9 - 2;
    nw_endpoint_set_priority(v11, v13);
    nw_array_append((uint64_t)v4->endpoints, v12);

    if (!a2) {
      goto LABEL_12;
    }
  }
  if (v8 == 2)
  {
    *(void *)&address_8.sa_len = 0;
    uint64_t address = 528;
    if (a2 < 5) {
      goto LABEL_15;
    }
    HIDWORD(address) = *(_DWORD *)&v7->sa_len;
    if (a2 - 5 <= 1) {
      goto LABEL_15;
    }
    WORD1(address) = *(_WORD *)(a1 + 5);
    unint64_t v9 = a2 - 7;
    uint64_t v10 = (unsigned __int16 *)(a1 + 7);
    goto LABEL_10;
  }
  nw_endpoint_t v12 = 0;
LABEL_14:

LABEL_15:
  os_log_type_t v14 = 0;
LABEL_16:

  return v14;
}

NWConcrete_nw_dns_cache_storage_canvas *nw_dns_cache_storage_canvas_create()
{
  return objc_alloc_init(NWConcrete_nw_dns_cache_storage_canvas);
}

BOOL nw_dns_cache_storage_key(void *a1, void *a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    BOOL v15 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
    unsigned int v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v13, type, &v24))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v19 = type[0];
        BOOL v20 = os_log_type_enabled(v16, type[0]);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v13) {
            goto LABEL_28;
          }
          goto LABEL_27;
        }
        if (v20)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
          _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_dns_cache_storage_key";
          _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (v13) {
LABEL_27:
    }
      free(v13);
LABEL_28:
    nw_endpoint_t v11 = 0;
    goto LABEL_29;
  }
  id v5 = v3;
  int v6 = [v5 type];

  if (v6 != 2) {
    goto LABEL_28;
  }
  size_t v7 = (os_unfair_lock_s *)v5;
  *(void *)os_log_type_t type = 0;
  id v26 = type;
  uint64_t v27 = 0x2020000000;
  int v8 = v7 + 45;
  uint64_t v28 = 0;
  *(void *)long long buf = MEMORY[0x1E4F143A8];
  *(void *)&uint8_t buf[8] = 3221225472;
  *(void *)&buf[16] = __nw_endpoint_get_description_block_invoke;
  BOOL v30 = &unk_1E524B978;
  unint64_t v9 = v7;
  uint64_t v31 = v9;
  id v32 = type;
  os_unfair_lock_lock(v8);
  (*(void (**)(unsigned char *))&buf[16])(buf);
  os_unfair_lock_unlock(v8);
  uint64_t v10 = (const char *)*((void *)v26 + 3);

  _Block_object_dispose(type, 8);
  if (v10)
  {
LABEL_4:
    nw_endpoint_t v11 = strdup(v10);
    if (v11)
    {
LABEL_29:

      return (BOOL)v11;
    }
    nw_endpoint_t v12 = __nwlog_obj();
    os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_strdup";
    unsigned int v13 = (char *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v13);
    if (result) {
      goto LABEL_30;
    }
    goto LABEL_27;
  }
  BOOL v21 = __nwlog_obj();
  os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "strict_strdup";
  os_log_type_t v22 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v22);
  if (!result)
  {
    free(v22);
    goto LABEL_4;
  }
LABEL_30:
  __break(1u);
  return result;
}

void sub_183A27AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_dns_cache_storage_canvas_remove(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (void *)*((void *)v1 + 1);
    *((void *)v1 + 1) = 0;

    v2[16] = 1;
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
        int v8 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
            __int16 v15 = 2082;
            os_log_type_t v16 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v10) {
          goto LABEL_18;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
        int v8 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v14 = "nw_dns_cache_storage_canvas_remove";
        int v8 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void nw_dns_cache_storage_canvas_store(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  os_log_type_t v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (!v7)
  {
    char v11 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v24 = "nw_dns_cache_storage_canvas_store";
    nw_endpoint_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v24 = "nw_dns_cache_storage_canvas_store";
        __int16 v15 = "%{public}s called with null canvas";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)long long buf = 136446466;
          char v24 = "nw_dns_cache_storage_canvas_store";
          __int16 v25 = 2082;
          id v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v12) {
          goto LABEL_4;
        }
LABEL_35:
        free(v12);
        goto LABEL_4;
      }
      if (v18)
      {
        *(_DWORD *)long long buf = 136446210;
        char v24 = "nw_dns_cache_storage_canvas_store";
        __int16 v15 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_32;
      }
    }
    else
    {
      unsigned int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v24 = "nw_dns_cache_storage_canvas_store";
        __int16 v15 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_32;
      }
    }
LABEL_33:

    goto LABEL_34;
  }
  if (v8)
  {
    objc_storeStrong(v7 + 1, a2);
    *((unsigned char *)v7 + 16) = 1;
    goto LABEL_4;
  }
  os_log_type_t v16 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v24 = "nw_dns_cache_storage_canvas_store";
  nw_endpoint_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (!__nwlog_fault(v12, &type, &v21)) {
    goto LABEL_34;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)long long buf = 136446210;
      char v24 = "nw_dns_cache_storage_canvas_store";
      __int16 v15 = "%{public}s called with null item";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (!v21)
  {
    unsigned int v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      *(_DWORD *)long long buf = 136446210;
      char v24 = "nw_dns_cache_storage_canvas_store";
      __int16 v15 = "%{public}s called with null item, backtrace limit exceeded";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  os_log_type_t v19 = (char *)__nw_create_backtrace_string();
  unsigned int v13 = __nwlog_obj();
  os_log_type_t v14 = type;
  BOOL v20 = os_log_type_enabled(v13, type);
  if (!v19)
  {
    if (v20)
    {
      *(_DWORD *)long long buf = 136446210;
      char v24 = "nw_dns_cache_storage_canvas_store";
      __int16 v15 = "%{public}s called with null item, no backtrace";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (v20)
  {
    *(_DWORD *)long long buf = 136446466;
    char v24 = "nw_dns_cache_storage_canvas_store";
    __int16 v25 = 2082;
    id v26 = v19;
    _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null item, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v19);
  if (v12) {
    goto LABEL_35;
  }
LABEL_4:
}

BOOL nw_dns_cache_storage_canvas_lookup(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    BOOL v2 = nw_array_create();
    BOOL v3 = v2;
    id v4 = (void *)v1[1];
    if (v4) {
      nw_array_append(v2, v4);
    }
    goto LABEL_4;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v16 = "nw_dns_cache_storage_canvas_lookup";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v16 = "nw_dns_cache_storage_canvas_lookup";
        id v10 = "%{public}s called with null canvas";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
      }
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v16 = "nw_dns_cache_storage_canvas_lookup";
            __int16 v17 = 2082;
            BOOL v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v12) {
          goto LABEL_19;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v16 = "nw_dns_cache_storage_canvas_lookup";
        id v10 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_18;
      }
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v16 = "nw_dns_cache_storage_canvas_lookup";
        id v10 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
LABEL_19:
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  BOOL v3 = 0;
LABEL_4:

  return v3;
}

void nw_h3_0rtt_storage_canvas_remove_past(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    id v1 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v11 = "nw_h3_0rtt_storage_canvas_remove_past";
    BOOL v2 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v8 = 0;
    if (!__nwlog_fault(v2, &type, &v8)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v11 = "nw_h3_0rtt_storage_canvas_remove_past";
        id v5 = "%{public}s called with null canvas";
LABEL_16:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else
    {
      if (v8)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        BOOL v7 = os_log_type_enabled(v3, type);
        if (backtrace_string)
        {
          if (v7)
          {
            *(_DWORD *)long long buf = 136446466;
            char v11 = "nw_h3_0rtt_storage_canvas_remove_past";
            __int16 v12 = 2082;
            char v13 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_18;
        }
        if (!v7) {
          goto LABEL_17;
        }
        *(_DWORD *)long long buf = 136446210;
        char v11 = "nw_h3_0rtt_storage_canvas_remove_past";
        id v5 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_16;
      }
      BOOL v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v11 = "nw_h3_0rtt_storage_canvas_remove_past";
        id v5 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
LABEL_17:

LABEL_18:
    if (v2) {
      free(v2);
    }
  }
}

uint64_t nw_h3_0rtt_storage_needs_canvas_destroy()
{
  return 0;
}

size_t nw_h3_0rtt_storage_canvas_memory_size(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = *((void *)v1 + 1);
    if (v3)
    {
      size_t size = dispatch_data_get_size(v3);
      id v5 = v2[2];
      if (!v5) {
        goto LABEL_5;
      }
    }
    else
    {
      size_t size = 0;
      id v5 = v2[2];
      if (!v5)
      {
LABEL_5:
        int v6 = v2[3];
        if (v6) {
          size += dispatch_data_get_size(v6);
        }
        goto LABEL_7;
      }
    }
    size += dispatch_data_get_size(v5);
    goto LABEL_5;
  }
  char v8 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v18 = "nw_h3_0rtt_storage_canvas_memory_size";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v9, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v18 = "nw_h3_0rtt_storage_canvas_memory_size";
        __int16 v12 = "%{public}s called with null canvas";
LABEL_23:
        _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
      }
    }
    else
    {
      if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v18 = "nw_h3_0rtt_storage_canvas_memory_size";
            __int16 v19 = 2082;
            BOOL v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (!v14) {
          goto LABEL_24;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v18 = "nw_h3_0rtt_storage_canvas_memory_size";
        __int16 v12 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_23;
      }
      id v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v18 = "nw_h3_0rtt_storage_canvas_memory_size";
        __int16 v12 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_23;
      }
    }
LABEL_24:
  }
LABEL_25:
  if (v9) {
    free(v9);
  }
  size_t size = 0;
LABEL_7:

  return size;
}

uint64_t nw_h3_0rtt_storage_canvas_can_evict()
{
  return 1;
}

BOOL nw_h3_0rtt_storage_canvas_dirty(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = *((unsigned char *)v1 + 32) != 0;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v15 = "nw_h3_0rtt_storage_canvas_dirty";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v15 = "nw_h3_0rtt_storage_canvas_dirty";
        os_log_type_t v9 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)long long buf = 136446466;
            char v15 = "nw_h3_0rtt_storage_canvas_dirty";
            __int16 v16 = 2082;
            __int16 v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v11) {
          goto LABEL_18;
        }
        *(_DWORD *)long long buf = 136446210;
        char v15 = "nw_h3_0rtt_storage_canvas_dirty";
        os_log_type_t v9 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v15 = "nw_h3_0rtt_storage_canvas_dirty";
        os_log_type_t v9 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_h3_0rtt_storage_canvas_serialize(void *a1, size_t *a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  os_log_type_t v4 = v3;
  if (!v3)
  {
    uint64_t v21 = __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v35) = 0;
    if (__nwlog_fault(v22, type, &v35))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          __int16 v25 = "%{public}s called with null canvas";
LABEL_47:
          _os_log_impl(&dword_1830D4000, v23, v24, v25, applier, 0xCu);
        }
LABEL_48:

        goto LABEL_49;
      }
      if (!(_BYTE)v35)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          __int16 v25 = "%{public}s called with null canvas, backtrace limit exceeded";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      BOOL v28 = os_log_type_enabled(v23, type[0]);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          __int16 v25 = "%{public}s called with null canvas, no backtrace";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (!v28) {
        goto LABEL_36;
      }
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
      *(_WORD *)&applier[12] = 2082;
      *(void *)&applier[14] = backtrace_string;
      BOOL v29 = "%{public}s called with null canvas, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
LABEL_49:
    if (v22) {
      free(v22);
    }
    os_log_type_t v8 = 0;
    goto LABEL_18;
  }
  if (!a2)
  {
    id v26 = __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v35) = 0;
    if (__nwlog_fault(v22, type, &v35))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          __int16 v25 = "%{public}s called with null size";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (!(_BYTE)v35)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          __int16 v25 = "%{public}s called with null size, backtrace limit exceeded";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      BOOL v30 = os_log_type_enabled(v23, type[0]);
      if (!backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
          __int16 v25 = "%{public}s called with null size, no backtrace";
          goto LABEL_47;
        }
        goto LABEL_48;
      }
      if (!v30) {
        goto LABEL_36;
      }
      *(_DWORD *)applier = 136446466;
      *(void *)&applier[4] = "nw_h3_0rtt_storage_canvas_serialize";
      *(_WORD *)&applier[12] = 2082;
      *(void *)&applier[14] = backtrace_string;
      BOOL v29 = "%{public}s called with null size, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_1830D4000, v23, v24, v29, applier, 0x16u);
LABEL_36:

      free(backtrace_string);
      goto LABEL_49;
    }
    goto LABEL_49;
  }
  id v5 = v3;
  *((unsigned char *)v5 + 32) = 0;
  int v6 = *((void *)v5 + 1);
  if (!v6 || (BOOL v7 = *((void *)v5 + 2)) == 0)
  {
    os_log_type_t v8 = 0;
    goto LABEL_17;
  }
  os_log_type_t v8 = *((void *)v5 + 3);
  if (!v8)
  {
LABEL_17:

LABEL_18:
    return (BOOL)v8;
  }
  unsigned __int16 size = dispatch_data_get_size(v6);
  unsigned __int16 v10 = dispatch_data_get_size(v7);
  unsigned __int16 v11 = dispatch_data_get_size(v8);
  uint64_t v33 = v11;
  unsigned __int16 v34 = v11;
  size_t v12 = size + (unint64_t)v10 + v11 + 6;
  *a2 = v12;
  os_log_type_t v8 = malloc_type_malloc(v12, 0xF2B69DE5uLL);
  if (v8)
  {
LABEL_7:
    LOWORD(v8->isa) = size;
    char v13 = *((void *)v5 + 1);
    *(void *)os_log_type_t type = 0;
    uint64_t v40 = type;
    uint64_t v41 = 0x2000000000;
    uint64_t v42 = 0;
    uint64_t v35 = 0;
    __int16 v36 = &v35;
    uint64_t v37 = 0x2000000000;
    uint64_t v38 = (uint64_t)&v8->isa + 2;
    if (v13)
    {
      *(void *)applier = MEMORY[0x1E4F143A8];
      *(void *)&applier[8] = 0x40000000;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      long long v44 = &unk_1E5242B60;
      long long v46 = &v35;
      uint64_t v47 = size;
      BOOL v45 = type;
      dispatch_data_apply(v13, applier);
      uint64_t v14 = *((void *)v40 + 3);
    }
    else
    {
      uint64_t v14 = 0;
    }
    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(type, 8);
    char v15 = (unsigned __int16 *)((char *)&v8->isa + v14 + 2);
    *char v15 = v10;
    __int16 v16 = v15 + 1;
    __int16 v17 = *((void *)v5 + 2);
    *(void *)os_log_type_t type = 0;
    uint64_t v40 = type;
    uint64_t v41 = 0x2000000000;
    uint64_t v42 = 0;
    uint64_t v35 = 0;
    __int16 v36 = &v35;
    uint64_t v37 = 0x2000000000;
    uint64_t v38 = (uint64_t)v16;
    if (v17)
    {
      *(void *)applier = MEMORY[0x1E4F143A8];
      *(void *)&applier[8] = 0x40000000;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      long long v44 = &unk_1E5242B60;
      long long v46 = &v35;
      uint64_t v47 = v10;
      BOOL v45 = type;
      dispatch_data_apply(v17, applier);
      uint64_t v18 = *((void *)v40 + 3);
    }
    else
    {
      uint64_t v18 = 0;
    }
    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(type, 8);
    *(_WORD *)((char *)v16 + v1_Block_object_dispose(&a9, 8) = v34;
    __int16 v19 = *((void *)v5 + 3);
    *(void *)os_log_type_t type = 0;
    uint64_t v40 = type;
    uint64_t v41 = 0x2000000000;
    uint64_t v42 = 0;
    uint64_t v35 = 0;
    __int16 v36 = &v35;
    uint64_t v37 = 0x2000000000;
    uint64_t v38 = (uint64_t)v16 + v18 + 2;
    if (v19)
    {
      *(void *)applier = MEMORY[0x1E4F143A8];
      *(void *)&applier[8] = 0x40000000;
      *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
      long long v44 = &unk_1E5242B60;
      long long v46 = &v35;
      uint64_t v47 = v33;
      BOOL v45 = type;
      dispatch_data_apply(v19, applier);
    }
    _Block_object_dispose(&v35, 8);
    _Block_object_dispose(type, 8);
    goto LABEL_17;
  }
  uint64_t v31 = __nwlog_obj();
  os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446466;
  *(void *)&applier[4] = "strict_malloc";
  *(_WORD *)&applier[12] = 2048;
  *(void *)&applier[14] = v12;
  id v32 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v32);
  if (!result)
  {
    free(v32);
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

NWConcrete_nw_h3_0rtt_storage_canvas *nw_h3_0rtt_storage_canvas_deserialize(unsigned __int16 *a1, unint64_t a2)
{
  os_log_type_t v4 = objc_alloc_init(NWConcrete_nw_h3_0rtt_storage_canvas);
  unint64_t v5 = a2 - 2;
  if (a2 < 2) {
    goto LABEL_7;
  }
  unint64_t v6 = *a1;
  unint64_t v7 = v5 - v6;
  if (v5 < v6) {
    goto LABEL_7;
  }
  os_log_type_t v8 = a1 + 1;
  dispatch_data_t v9 = dispatch_data_create(a1 + 1, *a1, 0, 0);
  settings_data = v4->settings_data;
  v4->settings_data = (OS_dispatch_data *)v9;

  unsigned __int16 v11 = 0;
  unint64_t v12 = v7 - 2;
  if (v7 < 2) {
    goto LABEL_8;
  }
  char v13 = (char *)v8 + v6;
  size_t v14 = *(unsigned __int16 *)((char *)v8 + v6);
  unint64_t v15 = v12 - v14;
  if (v12 < v14)
  {
LABEL_7:
    unsigned __int16 v11 = 0;
    goto LABEL_8;
  }
  __int16 v16 = v13 + 2;
  dispatch_data_t v17 = dispatch_data_create(v13 + 2, v14, 0, 0);
  quic_state = v4->quic_state;
  v4->quic_state = (OS_dispatch_data *)v17;

  unsigned __int16 v11 = 0;
  if (v15 >= 2)
  {
    size_t v19 = *(unsigned __int16 *)&v16[v14];
    if (v15 - 2 >= v19)
    {
      dispatch_data_t v21 = dispatch_data_create(&v16[v14 + 2], v19, 0, 0);
      tls_state = v4->tls_state;
      v4->tls_state = (OS_dispatch_data *)v21;

      unsigned __int16 v11 = v4;
      goto LABEL_8;
    }
    goto LABEL_7;
  }
LABEL_8:

  return v11;
}

NWConcrete_nw_h3_0rtt_storage_canvas *nw_h3_0rtt_storage_canvas_create()
{
  return objc_alloc_init(NWConcrete_nw_h3_0rtt_storage_canvas);
}

char *nw_h3_0rtt_storage_key(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    size_t v14 = __nwlog_obj();
    int v24 = 136446210;
    *(_DWORD *)long long buf = 136446210;
    unsigned __int16 v10 = "nw_h3_0rtt_storage_key";
    *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
    unint64_t v12 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v12, type, &v25)) {
      goto LABEL_28;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null endpoint", buf, 0xCu);
      }
LABEL_27:

LABEL_28:
      if (!v12)
      {
LABEL_30:
        unint64_t v7 = 0;
        goto LABEL_6;
      }
LABEL_29:
      free(v12);
      goto LABEL_30;
    }
LABEL_16:
    if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v15 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      BOOL v22 = os_log_type_enabled(v15, type[0]);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v21, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v12) {
          goto LABEL_30;
        }
        goto LABEL_29;
      }
      if (v22)
      {
        *(_DWORD *)long long buf = v24;
        *(void *)&uint8_t buf[4] = "nw_h3_0rtt_storage_key";
        _os_log_impl(&dword_1830D4000, v15, v21, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v15 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (os_log_type_enabled(v15, type[0]))
      {
        *(_DWORD *)long long buf = v24;
        *(void *)&uint8_t buf[4] = v10;
        _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_27;
  }
  id v5 = v3;
  unsigned int v6 = [v5 type];

  unint64_t v7 = 0;
  if (v6 <= 4 && ((1 << v6) & 0x16) != 0)
  {
    os_log_type_t v8 = (os_unfair_lock_s *)v5;
    *(void *)os_log_type_t type = 0;
    uint64_t v27 = type;
    uint64_t v28 = 0x2020000000;
    dispatch_data_t v9 = v8 + 45;
    uint64_t v29 = 0;
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    unsigned __int16 v10 = &buf[16];
    *(void *)&buf[16] = __nw_endpoint_get_description_block_invoke;
    uint64_t v31 = &unk_1E524B978;
    unsigned __int16 v11 = v8;
    id v32 = v11;
    uint64_t v33 = type;
    os_unfair_lock_lock(v9);
    (*(void (**)(unsigned char *))&buf[16])(buf);
    os_unfair_lock_unlock(v9);
    unint64_t v12 = (char *)*((void *)v27 + 3);

    _Block_object_dispose(type, 8);
    if (!v12)
    {
      dispatch_data_t v17 = __nwlog_obj();
      os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "strict_strdup";
      uint64_t v18 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v18))
      {
LABEL_15:
        __break(1u);
        goto LABEL_16;
      }
      free(v18);
    }
    unint64_t v7 = strdup(v12);
    if (v7) {
      goto LABEL_6;
    }
    size_t v19 = __nwlog_obj();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "strict_strdup";
    unint64_t v12 = (char *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v12)) {
      goto LABEL_29;
    }
    goto LABEL_15;
  }
LABEL_6:

  return v7;
}

void sub_183A29B70(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_h3_0rtt_storage_canvas_remove(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    id v3 = (void *)v1[1];
    v1[1] = 0;

    id v4 = (void *)v2[2];
    v2[2] = 0;

    id v5 = (void *)v2[3];
    v2[3] = 0;

    *((unsigned char *)v2 + 32) = 1;
    goto LABEL_3;
  }
  unsigned int v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v16 = "nw_h3_0rtt_storage_canvas_remove";
  unint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v16 = "nw_h3_0rtt_storage_canvas_remove";
        unsigned __int16 v10 = "%{public}s called with null canvas";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
      }
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v16 = "nw_h3_0rtt_storage_canvas_remove";
            __int16 v17 = 2082;
            uint64_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_19;
        }
        if (!v12) {
          goto LABEL_18;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v16 = "nw_h3_0rtt_storage_canvas_remove";
        unsigned __int16 v10 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_17;
      }
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v16 = "nw_h3_0rtt_storage_canvas_remove";
        unsigned __int16 v10 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
LABEL_18:
  }
LABEL_19:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void nw_h3_0rtt_storage_canvas_store(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unint64_t v7 = a1;
  id v8 = a2;
  id v9 = a3;
  id v10 = a4;
  if (!v7)
  {
    __int16 v17 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v18, &type, &v27)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
        os_log_type_t v21 = "%{public}s called with null canvas";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v24 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
          __int16 v31 = 2082;
          id v32 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_34:
        if (!v18) {
          goto LABEL_4;
        }
LABEL_35:
        free(v18);
        goto LABEL_4;
      }
      if (v24)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
        os_log_type_t v21 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_32;
      }
    }
    else
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
        os_log_type_t v21 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_32;
      }
    }
LABEL_33:

    goto LABEL_34;
  }
  if (v8)
  {
    uint64_t v11 = nw_array_get_object_at_index((uint64_t)v8, 0);
    BOOL v12 = (void *)v7[1];
    v7[1] = v11;

    uint64_t v13 = nw_array_get_object_at_index((uint64_t)v8, 1uLL);
    size_t v14 = (void *)v7[2];
    v7[2] = v13;

    uint64_t v15 = nw_array_get_object_at_index((uint64_t)v8, 2uLL);
    os_log_type_t v16 = (void *)v7[3];
    v7[3] = v15;

    *((unsigned char *)v7 + 32) = 1;
    goto LABEL_4;
  }
  BOOL v22 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
  uint64_t v18 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (!__nwlog_fault(v18, &type, &v27)) {
    goto LABEL_34;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v19, type))
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
      os_log_type_t v21 = "%{public}s called with null item";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (!v27)
  {
    uint64_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v19, type))
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
      os_log_type_t v21 = "%{public}s called with null item, backtrace limit exceeded";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  char v25 = (char *)__nw_create_backtrace_string();
  uint64_t v19 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v26 = os_log_type_enabled(v19, type);
  if (!v25)
  {
    if (v26)
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
      os_log_type_t v21 = "%{public}s called with null item, no backtrace";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (v26)
  {
    *(_DWORD *)long long buf = 136446466;
    BOOL v30 = "nw_h3_0rtt_storage_canvas_store";
    __int16 v31 = 2082;
    id v32 = v25;
    _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null item, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v25);
  if (v18) {
    goto LABEL_35;
  }
LABEL_4:
}

BOOL nw_h3_0rtt_storage_canvas_lookup(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    id v3 = (void **)v1;
    BOOL v4 = nw_array_create();
    if (v3[1] && v3[2] && v3[3])
    {
      BOOL v5 = nw_array_create();
      nw_array_append(v5, v3[1]);
      nw_array_append(v5, v3[2]);
      nw_array_append(v5, v3[3]);
      nw_array_append(v4, (void *)v5);
    }
    goto LABEL_7;
  }
  unint64_t v7 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v17 = "nw_h3_0rtt_storage_canvas_lookup";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v17 = "nw_h3_0rtt_storage_canvas_lookup";
        uint64_t v11 = "%{public}s called with null canvas";
LABEL_21:
        _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
      }
    }
    else
    {
      if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)long long buf = 136446466;
            __int16 v17 = "nw_h3_0rtt_storage_canvas_lookup";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null canvas, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (!v13) {
          goto LABEL_22;
        }
        *(_DWORD *)long long buf = 136446210;
        __int16 v17 = "nw_h3_0rtt_storage_canvas_lookup";
        uint64_t v11 = "%{public}s called with null canvas, no backtrace";
        goto LABEL_21;
      }
      id v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v17 = "nw_h3_0rtt_storage_canvas_lookup";
        uint64_t v11 = "%{public}s called with null canvas, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_22:
  }
LABEL_23:
  if (v8) {
    free(v8);
  }
  BOOL v4 = 0;
LABEL_7:

  return v4;
}

id nw_storage_copy_shared()
{
  if (nw_storage_copy_shared_token[0] != -1) {
    dispatch_once(nw_storage_copy_shared_token, &__block_literal_global_45557);
  }
  uint64_t v0 = (void *)nw_storage_copy_shared_storage;

  return v0;
}

void __nw_storage_copy_shared_block_invoke()
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  bzero(__s1, 0x400uLL);
  uint64_t v0 = getenv("HOME");
  if (!v0)
  {
LABEL_50:
    char v27 = objc_alloc_init(NWConcrete_nw_storage);
LABEL_51:
    uint64_t v29 = (void *)nw_storage_copy_shared_storage;
    nw_storage_copy_shared_storage = (uint64_t)v27;

    return;
  }
  uint64_t v1 = 0;
  while (1)
  {
    int v2 = v0[v1];
    __s1[v1] = v2;
    if (!v2) {
      break;
    }
    if (++v1 == 1023)
    {
      char v37 = 0;
      break;
    }
  }
  uint64_t v3 = 0;
  unint64_t v4 = 1024;
  while (1)
  {
    BOOL v5 = &__s1[v3];
    if (!__s1[v3]) {
      break;
    }
    ++v3;
    if (!--v4) {
      goto LABEL_17;
    }
  }
  if (v4 < 2)
  {
LABEL_16:
    char *v5 = 0;
  }
  else
  {
    unint64_t v6 = v4 - 2;
    uint64_t v7 = 1023 - v3;
    unint64_t v8 = 1022 - v3;
    if (v8 >= 0x16) {
      unint64_t v8 = 22;
    }
    memcpy(v5, "/Library/HTTPStorages/", v8 + 1);
    BOOL v5 = &v37;
    while (v6 <= 0x15)
    {
      if (!--v7) {
        goto LABEL_16;
      }
    }
  }
LABEL_17:
  mkdir(__s1, 0x1C0u);
  MainBundle = CFBundleGetMainBundle();
  if (MainBundle
    && (CFStringRef Identifier = CFBundleGetIdentifier(MainBundle)) != 0
    && (CStringPtr = CFStringGetCStringPtr(Identifier, 0x600u)) != 0)
  {
    BOOL v12 = CStringPtr;
  }
  else
  {
    BOOL v12 = *(const char **)_CFGetProgname();
    if (!v12)
    {
      BOOL v30 = __nwlog_obj();
      os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
      int v38 = 136446210;
      int v39 = "_strict_strlcat";
      __int16 v31 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v31)) {
        goto LABEL_59;
      }
      free(v31);
      BOOL v12 = 0;
      int v13 = 1;
      goto LABEL_23;
    }
  }
  int v13 = 0;
LABEL_23:
  uint64_t v14 = 0;
  unint64_t v15 = 1024;
  do
  {
    if (!__s1[v14])
    {
      if (v13)
      {
        uint64_t v34 = __nwlog_obj();
        os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
        int v38 = 136446210;
        int v39 = "_strict_strlcpy";
        uint64_t v35 = (void *)_os_log_send_and_compose_impl();

        if (__nwlog_abort((uint64_t)v35)) {
          goto LABEL_59;
        }
        free(v35);
        if (v15 >= 2)
        {
LABEL_31:
          uint64_t v18 = 0;
          while (1)
          {
            int v19 = v12[v18];
            __s1[v18 + v14] = v19;
            if (!v19) {
              goto LABEL_36;
            }
            uint64_t v20 = v14 + v18++;
            if (v20 == 1022)
            {
              uint64_t v14 = 1023;
              break;
            }
          }
        }
      }
      else if (v15 >= 2)
      {
        goto LABEL_31;
      }
      __s1[v14] = 0;
      goto LABEL_36;
    }
    ++v14;
    --v15;
  }
  while (v15);
  if (v13)
  {
    os_log_type_t v16 = __nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    int v38 = 136446210;
    int v39 = "_strict_strlcpy";
    __int16 v17 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v17)) {
      goto LABEL_59;
    }
    free(v17);
  }
LABEL_36:
  mkdir(__s1, 0x1C0u);
  uint64_t v21 = 0;
  unint64_t v22 = 1024;
  while (1)
  {
    os_log_type_t v23 = &__s1[v21];
    if (!__s1[v21]) {
      break;
    }
    ++v21;
    if (!--v22) {
      goto LABEL_47;
    }
  }
  if (v22 < 2)
  {
LABEL_46:
    char *v23 = 0;
  }
  else
  {
    unint64_t v24 = v22 - 2;
    uint64_t v25 = 1023 - v21;
    unint64_t v26 = 1022 - v21;
    if (v26 >= 0x17) {
      unint64_t v26 = 23;
    }
    memcpy(v23, "/network_storage.sqlite", v26 + 1);
    os_log_type_t v23 = &v37;
    while (v24 <= 0x16)
    {
      if (!--v25) {
        goto LABEL_46;
      }
    }
  }
LABEL_47:
  if (!__s1[0]) {
    goto LABEL_50;
  }
  char v27 = objc_alloc_init(NWConcrete_nw_storage);
  uint64_t v28 = strdup(__s1);
  if (v28)
  {
LABEL_49:
    v27->path = v28;
    goto LABEL_51;
  }
  id v32 = __nwlog_obj();
  os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
  int v38 = 136446210;
  int v39 = "strict_strdup";
  uint64_t v33 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v33))
  {
    free(v33);
    goto LABEL_49;
  }
LABEL_59:
  __break(1u);
}

void nw_storage_lookup_items(void *a1, uint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  int v13 = v12;
  if (!v9)
  {
    unint64_t v15 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v16, &v40, &v39)) {
      goto LABEL_74;
    }
    if (v40 != OS_LOG_TYPE_FAULT)
    {
      if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = v40;
        BOOL v25 = os_log_type_enabled(v17, v40);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v42 = "nw_storage_lookup_items";
            __int16 v43 = 2082;
            long long v44 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null storage, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_74:
          if (!v16) {
            goto LABEL_7;
          }
LABEL_75:
          free(v16);
          goto LABEL_7;
        }
        if (v25)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null storage, no backtrace";
          goto LABEL_72;
        }
      }
      else
      {
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = v40;
        if (os_log_type_enabled(v17, v40))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_72;
        }
      }
      goto LABEL_73;
    }
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = v40;
    if (!os_log_type_enabled(v17, v40)) {
      goto LABEL_73;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    int v19 = "%{public}s called with null storage";
    goto LABEL_72;
  }
  if (!a2)
  {
    uint64_t v20 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v16, &v40, &v39)) {
      goto LABEL_74;
    }
    if (v40 != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = v40;
        if (os_log_type_enabled(v17, v40))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_72;
        }
        goto LABEL_73;
      }
      unint64_t v26 = (char *)__nw_create_backtrace_string();
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = v40;
      BOOL v27 = os_log_type_enabled(v17, v40);
      if (!v26)
      {
        if (v27)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null type, no backtrace";
          goto LABEL_72;
        }
        goto LABEL_73;
      }
      if (!v27) {
        goto LABEL_50;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v42 = "nw_storage_lookup_items";
      __int16 v43 = 2082;
      long long v44 = v26;
      uint64_t v28 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = v40;
    if (!os_log_type_enabled(v17, v40)) {
      goto LABEL_73;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    int v19 = "%{public}s called with null type";
LABEL_72:
    _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
    goto LABEL_73;
  }
  if (!v10)
  {
    uint64_t v21 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v16, &v40, &v39)) {
      goto LABEL_74;
    }
    if (v40 != OS_LOG_TYPE_FAULT)
    {
      if (!v39)
      {
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = v40;
        if (os_log_type_enabled(v17, v40))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null endpoint, backtrace limit exceeded";
          goto LABEL_72;
        }
        goto LABEL_73;
      }
      unint64_t v26 = (char *)__nw_create_backtrace_string();
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = v40;
      BOOL v29 = os_log_type_enabled(v17, v40);
      if (!v26)
      {
        if (v29)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v42 = "nw_storage_lookup_items";
          int v19 = "%{public}s called with null endpoint, no backtrace";
          goto LABEL_72;
        }
        goto LABEL_73;
      }
      if (!v29) {
        goto LABEL_50;
      }
      *(_DWORD *)long long buf = 136446466;
      uint64_t v42 = "nw_storage_lookup_items";
      __int16 v43 = 2082;
      long long v44 = v26;
      uint64_t v28 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = v40;
    if (!os_log_type_enabled(v17, v40)) {
      goto LABEL_73;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    int v19 = "%{public}s called with null endpoint";
    goto LABEL_72;
  }
  if (!v11)
  {
    unint64_t v22 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v16, &v40, &v39)) {
      goto LABEL_74;
    }
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = v40;
      if (!os_log_type_enabled(v17, v40)) {
        goto LABEL_73;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v42 = "nw_storage_lookup_items";
      int v19 = "%{public}s called with null context";
      goto LABEL_72;
    }
    if (!v39)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = v40;
      if (os_log_type_enabled(v17, v40))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    unint64_t v26 = (char *)__nw_create_backtrace_string();
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = v40;
    BOOL v30 = os_log_type_enabled(v17, v40);
    if (!v26)
    {
      if (v30)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null context, no backtrace";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    if (!v30) {
      goto LABEL_50;
    }
    *(_DWORD *)long long buf = 136446466;
    uint64_t v42 = "nw_storage_lookup_items";
    __int16 v43 = 2082;
    long long v44 = v26;
    uint64_t v28 = "%{public}s called with null context, dumping backtrace:%{public}s";
LABEL_49:
    _os_log_impl(&dword_1830D4000, v17, v18, v28, buf, 0x16u);
    goto LABEL_50;
  }
  if (!v12)
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v42 = "nw_storage_lookup_items";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v16, &v40, &v39)) {
      goto LABEL_74;
    }
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = v40;
      if (os_log_type_enabled(v17, v40))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null completion";
        goto LABEL_72;
      }
LABEL_73:

      goto LABEL_74;
    }
    if (!v39)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = v40;
      if (os_log_type_enabled(v17, v40))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null completion, backtrace limit exceeded";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    unint64_t v26 = (char *)__nw_create_backtrace_string();
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = v40;
    BOOL v31 = os_log_type_enabled(v17, v40);
    if (!v26)
    {
      if (v31)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v42 = "nw_storage_lookup_items";
        int v19 = "%{public}s called with null completion, no backtrace";
        goto LABEL_72;
      }
      goto LABEL_73;
    }
    if (v31)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v42 = "nw_storage_lookup_items";
      __int16 v43 = 2082;
      long long v44 = v26;
      uint64_t v28 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_49;
    }
LABEL_50:

    free(v26);
    if (!v16) {
      goto LABEL_7;
    }
    goto LABEL_75;
  }
  uint64_t v14 = v9[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __nw_storage_lookup_items_block_invoke;
  block[3] = &unk_1E5242480;
  uint64_t v33 = v9;
  uint64_t v38 = a2;
  id v34 = v10;
  id v35 = 0;
  id v36 = v11;
  id v37 = v13;
  dispatch_async(v14, block);

LABEL_7:
}

void __nw_storage_lookup_items_block_invoke(uint64_t a1)
{
  int v2 = nw_storage_provider_for_type(*(void **)(a1 + 32), *(void *)(a1 + 72));
  uint64_t v3 = (const char *)(*((uint64_t (**)(void, void))v2 + 3))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  if (v3)
  {
    unint64_t v4 = (char *)v3;
    BOOL v5 = nw_storage_fault_in_canvas(*(void **)(a1 + 32), v3, *(const char **)(a1 + 72), (uint64_t)v2);
    uint64_t v6 = (*(uint64_t (**)(void *, void, void))v2)(v5, *(void *)(a1 + 40), *(void *)(a1 + 48));
    if ((*((unsigned int (**)(void *))v2 + 7))(v5)) {
      nw_storage_enqueue_flush_and_free_key(*(void **)(a1 + 32), (uint64_t)v4, *(void *)(a1 + 72));
    }
    else {
      free(v4);
    }
  }
  else
  {
    uint64_t v6 = nw_array_create();
  }
  v10[0] = MEMORY[0x1E4F143A8];
  v10[1] = 3221225472;
  v10[2] = __nw_storage_lookup_items_block_invoke_2;
  v10[3] = &unk_1E524B950;
  uint64_t v7 = *(void **)(a1 + 56);
  id v8 = *(id *)(a1 + 64);
  id v11 = (id)v6;
  id v12 = v8;
  id v9 = (id)v6;
  nw_queue_context_async(v7, v10);
}

id nw_storage_fault_in_canvas(void *a1, const char *a2, const char *a3, uint64_t a4)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  id v8 = v7;
  if (!v7)
  {
    id v37 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v52 = "nw_storage_fault_in_canvas";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (!__nwlog_fault(v38, &type, &v49)) {
      goto LABEL_97;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_96;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v52 = "nw_storage_fault_in_canvas";
      uint64_t v41 = "%{public}s called with null storage";
LABEL_95:
      _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, 0xCu);
      goto LABEL_96;
    }
    if (!v49)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v39 = __nwlog_obj();
    os_log_type_t v40 = type;
    BOOL v45 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (v45)
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null storage, no backtrace";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
    if (!v45) {
      goto LABEL_82;
    }
    *(_DWORD *)long long buf = 136446466;
    long long v52 = "nw_storage_fault_in_canvas";
    __int16 v53 = 2082;
    __int16 v54 = backtrace_string;
    long long v46 = "%{public}s called with null storage, dumping backtrace:%{public}s";
LABEL_81:
    _os_log_impl(&dword_1830D4000, v39, v40, v46, buf, 0x16u);
LABEL_82:

    free(backtrace_string);
    goto LABEL_97;
  }
  if (!a3)
  {
    uint64_t v42 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v52 = "nw_storage_fault_in_canvas";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (!__nwlog_fault(v38, &type, &v49)) {
      goto LABEL_97;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (!os_log_type_enabled(v39, type)) {
        goto LABEL_96;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v52 = "nw_storage_fault_in_canvas";
      uint64_t v41 = "%{public}s called with null type";
      goto LABEL_95;
    }
    if (!v49)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null type, backtrace limit exceeded";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v39 = __nwlog_obj();
    os_log_type_t v40 = type;
    BOOL v47 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (v47)
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null type, no backtrace";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
    if (!v47) {
      goto LABEL_82;
    }
    *(_DWORD *)long long buf = 136446466;
    long long v52 = "nw_storage_fault_in_canvas";
    __int16 v53 = 2082;
    __int16 v54 = backtrace_string;
    long long v46 = "%{public}s called with null type, dumping backtrace:%{public}s";
    goto LABEL_81;
  }
  if (a4)
  {
    id v9 = nw_dictionary_copy_value(v7[8], (uint64_t)a2);
    if (v9)
    {
LABEL_48:
      id v35 = nw_dictionary_copy_value((uint64_t)v9, (uint64_t)a3);
      if (!v35)
      {
        id v35 = (void *)(*(uint64_t (**)(void, uint64_t))(a4 + 32))(0, v34);
        nw_dictionary_set_value((uint64_t)v9, a3, v35);
      }

      goto LABEL_51;
    }
    if ((nw_storage_open_db(v8) & 1) == 0)
    {
      id v10 = (void *)v8[1];
      if (v10)
      {
        free(v10);
        v8[1] = 0;
      }
      nw_storage_open_db(v8);
    }
    id v11 = v8;
    int v13 = (sqlite3_stmt **)(v11 + 32);
    id v12 = (sqlite3_stmt *)*((void *)v11 + 4);
    if (!v12)
    {
      if (sqlite3_prepare_v2(*((sqlite3 **)v11 + 3), "SELECT type, canvas FROM network_storage WHERE key = ?", -1, v13, 0))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v19 = (id)gLogObj;
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_load_canvases_for_key";
        unint64_t v15 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v49 = 0;
        if (__nwlog_fault(v15, &type, &v49))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v16 = (id)gLogObj;
            os_log_type_t v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              *(_DWORD *)long long buf = 136446210;
              long long v52 = "nw_storage_load_canvases_for_key";
              os_log_type_t v18 = "%{public}s Failed to prepare statement";
              goto LABEL_41;
            }
LABEL_43:

            goto LABEL_44;
          }
          if (!v49)
          {
            os_log_type_t v16 = __nwlog_obj();
            os_log_type_t v17 = type;
            if (os_log_type_enabled(v16, type))
            {
              *(_DWORD *)long long buf = 136446210;
              long long v52 = "nw_storage_load_canvases_for_key";
              os_log_type_t v18 = "%{public}s Failed to prepare statement, backtrace limit exceeded";
              goto LABEL_41;
            }
            goto LABEL_43;
          }
          BOOL v27 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v16 = (id)gLogObj;
          os_log_type_t v28 = type;
          BOOL v31 = os_log_type_enabled(v16, type);
          if (v27)
          {
            if (v31)
            {
              *(_DWORD *)long long buf = 136446466;
              long long v52 = "nw_storage_load_canvases_for_key";
              __int16 v53 = 2082;
              __int16 v54 = v27;
              BOOL v30 = "%{public}s Failed to prepare statement, dumping backtrace:%{public}s";
              goto LABEL_33;
            }
LABEL_34:

            free(v27);
            goto LABEL_44;
          }
          if (!v31) {
            goto LABEL_43;
          }
          *(_DWORD *)long long buf = 136446210;
          long long v52 = "nw_storage_load_canvases_for_key";
          os_log_type_t v18 = "%{public}s Failed to prepare statement, no backtrace";
LABEL_56:
          id v32 = v16;
          os_log_type_t v33 = v28;
          goto LABEL_42;
        }
LABEL_44:
        if (v15) {
          free(v15);
        }
        id v9 = 0;
        goto LABEL_47;
      }
      id v12 = *v13;
    }
    if (!sqlite3_bind_text(v12, 1, a2, -1, 0))
    {
      id v9 = nw_dictionary_create();
      while (1)
      {
        int v20 = sqlite3_step(*v13);
        uint64_t v21 = *v13;
        if (v20 != 100) {
          break;
        }
        unint64_t v22 = sqlite3_column_text(v21, 0);
        os_log_type_t v23 = *(uint64_t (**)(const void *, void))(a4 + 40);
        unint64_t v24 = sqlite3_column_blob(*v13, 1);
        int v25 = sqlite3_column_bytes(*v13, 1);
        unint64_t v26 = (void *)v23(v24, v25);
        nw_dictionary_set_value((uint64_t)v9, (const char *)v22, v26);
      }
      sqlite3_reset(v21);
LABEL_47:

      nw_dictionary_set_value(v8[8], a2, v9);
      goto LABEL_48;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    long long v52 = "nw_storage_load_canvases_for_key";
    unint64_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (__nwlog_fault(v15, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)long long buf = 136446210;
          long long v52 = "nw_storage_load_canvases_for_key";
          os_log_type_t v18 = "%{public}s Failed to bind variable";
LABEL_41:
          id v32 = v16;
          os_log_type_t v33 = v17;
LABEL_42:
          _os_log_impl(&dword_1830D4000, v32, v33, v18, buf, 0xCu);
          goto LABEL_43;
        }
        goto LABEL_43;
      }
      if (!v49)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)long long buf = 136446210;
          long long v52 = "nw_storage_load_canvases_for_key";
          os_log_type_t v18 = "%{public}s Failed to bind variable, backtrace limit exceeded";
          goto LABEL_41;
        }
        goto LABEL_43;
      }
      BOOL v27 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v16 = (id)gLogObj;
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v16, type);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)long long buf = 136446466;
          long long v52 = "nw_storage_load_canvases_for_key";
          __int16 v53 = 2082;
          __int16 v54 = v27;
          BOOL v30 = "%{public}s Failed to bind variable, dumping backtrace:%{public}s";
LABEL_33:
          _os_log_impl(&dword_1830D4000, v16, v28, v30, buf, 0x16u);
          goto LABEL_34;
        }
        goto LABEL_34;
      }
      if (!v29) {
        goto LABEL_43;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v52 = "nw_storage_load_canvases_for_key";
      os_log_type_t v18 = "%{public}s Failed to bind variable, no backtrace";
      goto LABEL_56;
    }
    goto LABEL_44;
  }
  __int16 v43 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  long long v52 = "nw_storage_fault_in_canvas";
  uint64_t v38 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v49 = 0;
  if (__nwlog_fault(v38, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null provider";
        goto LABEL_95;
      }
LABEL_96:

      goto LABEL_97;
    }
    if (!v49)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v39, type))
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null provider, backtrace limit exceeded";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v39 = __nwlog_obj();
    os_log_type_t v40 = type;
    BOOL v48 = os_log_type_enabled(v39, type);
    if (!backtrace_string)
    {
      if (v48)
      {
        *(_DWORD *)long long buf = 136446210;
        long long v52 = "nw_storage_fault_in_canvas";
        uint64_t v41 = "%{public}s called with null provider, no backtrace";
        goto LABEL_95;
      }
      goto LABEL_96;
    }
    if (!v48) {
      goto LABEL_82;
    }
    *(_DWORD *)long long buf = 136446466;
    long long v52 = "nw_storage_fault_in_canvas";
    __int16 v53 = 2082;
    __int16 v54 = backtrace_string;
    long long v46 = "%{public}s called with null provider, dumping backtrace:%{public}s";
    goto LABEL_81;
  }
LABEL_97:
  if (v38) {
    free(v38);
  }
  id v35 = 0;
LABEL_51:

  return v35;
}

void nw_storage_enqueue_flush_and_free_key(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  if (!v5)
  {
    id v11 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
    id v12 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v32.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v12, &v32, &type)) {
      goto LABEL_50;
    }
    if (LOBYTE(v32.receiver) == 17)
    {
      int v13 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v32.receiver;
      if (os_log_type_enabled(v13, (os_log_type_t)v32.receiver))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
        unint64_t v15 = "%{public}s called with null storage";
LABEL_48:
        _os_log_impl(&dword_1830D4000, v13, receiver, v15, buf, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v13 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v32.receiver;
      BOOL v23 = os_log_type_enabled(v13, (os_log_type_t)v32.receiver);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
          __int16 v35 = 2082;
          id v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, receiver, "%{public}s called with null storage, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_50:
        if (!v12) {
          goto LABEL_9;
        }
LABEL_51:
        free(v12);
        goto LABEL_9;
      }
      if (v23)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
        unint64_t v15 = "%{public}s called with null storage, no backtrace";
        goto LABEL_48;
      }
    }
    else
    {
      int v13 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v32.receiver;
      if (os_log_type_enabled(v13, (os_log_type_t)v32.receiver))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
        unint64_t v15 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_48;
      }
    }
LABEL_49:

    goto LABEL_50;
  }
  if (a3)
  {
    uint64_t v6 = [NWConcrete_nw_storage_flush_item alloc];
    if (!v6)
    {
LABEL_58:
      id v8 = 0;
      goto LABEL_6;
    }
    v32.os_log_type_t receiver = v6;
    v32.super_class = (Class)NWConcrete_nw_storage_flush_item;
    id v7 = objc_msgSendSuper2(&v32, sel_init);
    if (v7)
    {
      id v8 = v7;
      *((void *)v7 + 1) = a3;
      *((void *)v7 + 2) = a2;
LABEL_6:
      nw_array_append(*((void *)v5 + 9), v8);
      if ((*((unsigned char *)v5 + 96) & 1) == 0)
      {
        *((unsigned char *)v5 + 96) |= 1u;
        dispatch_time_t v9 = dispatch_walltime(0, 5000000000);
        id v10 = *((void *)v5 + 2);
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = __nw_storage_enqueue_flush_and_free_key_block_invoke;
        block[3] = &unk_1E524BAA8;
        id v29 = v5;
        dispatch_after(v9, v10, block);
      }
      goto LABEL_9;
    }
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v34 = "-[NWConcrete_nw_storage_flush_item initWithType:key:]";
    os_log_type_t v18 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault((const char *)v18, &type, &v30))
    {
LABEL_56:
      if (v18) {
        free(v18);
      }
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v34 = "-[NWConcrete_nw_storage_flush_item initWithType:key:]";
        uint64_t v21 = "%{public}s [super init] failed";
LABEL_54:
        _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
      }
    }
    else
    {
      if (v30)
      {
        unint64_t v26 = (char *)__nw_create_backtrace_string();
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v27 = os_log_type_enabled(v19, type);
        if (v26)
        {
          if (v27)
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v34 = "-[NWConcrete_nw_storage_flush_item initWithType:key:]";
            __int16 v35 = 2082;
            id v36 = v26;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v26);
          goto LABEL_56;
        }
        if (!v27) {
          goto LABEL_55;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v34 = "-[NWConcrete_nw_storage_flush_item initWithType:key:]";
        uint64_t v21 = "%{public}s [super init] failed, no backtrace";
        goto LABEL_54;
      }
      id v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v34 = "-[NWConcrete_nw_storage_flush_item initWithType:key:]";
        uint64_t v21 = "%{public}s [super init] failed, backtrace limit exceeded";
        goto LABEL_54;
      }
    }
LABEL_55:

    goto LABEL_56;
  }
  os_log_type_t v16 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
  id v12 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v32.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v12, &v32, &type)) {
    goto LABEL_50;
  }
  if (LOBYTE(v32.receiver) == 17)
  {
    int v13 = __nwlog_obj();
    os_log_type_t receiver = (os_log_type_t)v32.receiver;
    if (os_log_type_enabled(v13, (os_log_type_t)v32.receiver))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
      unint64_t v15 = "%{public}s called with null type";
      goto LABEL_48;
    }
    goto LABEL_49;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    int v13 = __nwlog_obj();
    os_log_type_t receiver = (os_log_type_t)v32.receiver;
    if (os_log_type_enabled(v13, (os_log_type_t)v32.receiver))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
      unint64_t v15 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_48;
    }
    goto LABEL_49;
  }
  unint64_t v24 = (char *)__nw_create_backtrace_string();
  int v13 = __nwlog_obj();
  os_log_type_t receiver = (os_log_type_t)v32.receiver;
  BOOL v25 = os_log_type_enabled(v13, (os_log_type_t)v32.receiver);
  if (!v24)
  {
    if (v25)
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
      unint64_t v15 = "%{public}s called with null type, no backtrace";
      goto LABEL_48;
    }
    goto LABEL_49;
  }
  if (v25)
  {
    *(_DWORD *)long long buf = 136446466;
    uint64_t v34 = "nw_storage_enqueue_flush_and_free_key";
    __int16 v35 = 2082;
    id v36 = v24;
    _os_log_impl(&dword_1830D4000, v13, receiver, "%{public}s called with null type, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v24);
  if (v12) {
    goto LABEL_51;
  }
LABEL_9:
}

uint64_t __nw_storage_lookup_items_block_invoke_2(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void __nw_storage_enqueue_flush_and_free_key_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 96) &= ~1u;
  nw_storage_flush(*(void **)(a1 + 32));
}

uint64_t nw_storage_open_db(void *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  uint64_t v3 = (sqlite3 **)(v1 + 24);
  if (*((void *)v1 + 3)) {
    goto LABEL_2;
  }
  if (*((void *)v1 + 1)) {
    id v5 = (const char *)*((void *)v1 + 1);
  }
  else {
    id v5 = ":memory:";
  }
  if (sqlite3_open_v2(v5, v3, 3145734, 0)) {
    goto LABEL_56;
  }
  errmsg = 0;
  sqlite3_busy_timeout(*v3, 1000);
  if (sqlite3_exec(*v3, "PRAGMA journal_mode=WAL;", 0, 0, &errmsg))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    BOOL v27 = "nw_storage_open_db";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to enable WAL mode";
LABEL_51:
        os_log_type_t v18 = v8;
        os_log_type_t v19 = v9;
LABEL_52:
        _os_log_impl(&dword_1830D4000, v18, v19, v10, buf, 0xCu);
        goto LABEL_53;
      }
    }
    else
    {
      if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v8 = (id)gLogObj;
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v27 = "nw_storage_open_db";
            __int16 v28 = 2082;
            id v29 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s Failed to enable WAL mode, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v7) {
            goto LABEL_56;
          }
          goto LABEL_55;
        }
        if (!v14) {
          goto LABEL_53;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to enable WAL mode, no backtrace";
        os_log_type_t v18 = v8;
        os_log_type_t v19 = v13;
        goto LABEL_52;
      }
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to enable WAL mode, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
    goto LABEL_53;
  }
  if (sqlite3_exec(*v3, "PRAGMA auto_vacuum = 2;", 0, 0, &errmsg))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    BOOL v27 = "nw_storage_open_db";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to set vacuum policy";
        goto LABEL_51;
      }
    }
    else
    {
      if (v23)
      {
        os_log_type_t v16 = (char *)__nw_create_backtrace_string();
        id v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v17 = os_log_type_enabled(v8, type);
        if (v16)
        {
          if (v17)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v27 = "nw_storage_open_db";
            __int16 v28 = 2082;
            id v29 = v16;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Failed to set vacuum policy, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v16);
          if (!v7) {
            goto LABEL_56;
          }
          goto LABEL_55;
        }
        if (!v17) {
          goto LABEL_53;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to set vacuum policy, no backtrace";
        goto LABEL_51;
      }
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to set vacuum policy, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
LABEL_53:

    goto LABEL_54;
  }
  if (sqlite3_exec(*v3, "CREATE TABLE IF NOT EXISTS network_storage (\t\tkey TEXT NOT NULL,\t\ttype TEXT NOT NULL,\t\tcanvas BLOB NOT NULL,\t\ttime INTEGER,\t\tPRIMARY KEY(key, type)\t\t);",
         0,
         0,
         &errmsg))
  {
    unint64_t v15 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v27 = "nw_storage_open_db";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to create tables";
        goto LABEL_51;
      }
    }
    else if (v23)
    {
      os_log_type_t v20 = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v21 = os_log_type_enabled(v8, type);
      if (v20)
      {
        if (v21)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v27 = "nw_storage_open_db";
          __int16 v28 = 2082;
          id v29 = v20;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Failed to create tables, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
LABEL_54:
        if (v7) {
LABEL_55:
        }
          free(v7);
LABEL_56:
        sqlite3_close(*v3);
        uint64_t v4 = 0;
        *uint64_t v3 = 0;
        goto LABEL_57;
      }
      if (v21)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to create tables, no backtrace";
        goto LABEL_51;
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v27 = "nw_storage_open_db";
        id v10 = "%{public}s Failed to create tables, backtrace limit exceeded";
        goto LABEL_51;
      }
    }
    goto LABEL_53;
  }
LABEL_2:
  uint64_t v4 = 1;
LABEL_57:

  return v4;
}

void nw_storage_store_items(void *a1, uint64_t a2, void *a3, void *a4, void *a5, void *a6)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id v11 = a1;
  id v12 = a3;
  id v13 = a4;
  id v14 = a5;
  id v15 = a6;
  os_log_type_t v16 = v15;
  if (!v11)
  {
    os_log_type_t v18 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v19, &v46, &v45)) {
      goto LABEL_87;
    }
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (v45)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = v46;
        BOOL v29 = os_log_type_enabled(v20, v46);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v48 = "nw_storage_store_items";
            __int16 v49 = 2082;
            long long v50 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null storage, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
LABEL_87:
          if (!v19) {
            goto LABEL_8;
          }
LABEL_88:
          free(v19);
          goto LABEL_8;
        }
        if (v29)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null storage, no backtrace";
          goto LABEL_85;
        }
      }
      else
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null storage, backtrace limit exceeded";
          goto LABEL_85;
        }
      }
      goto LABEL_86;
    }
    os_log_type_t v20 = __nwlog_obj();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null storage";
    goto LABEL_85;
  }
  if (!a2)
  {
    char v23 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v19, &v46, &v45)) {
      goto LABEL_87;
    }
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null type, backtrace limit exceeded";
          goto LABEL_85;
        }
        goto LABEL_86;
      }
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      BOOL v31 = os_log_type_enabled(v20, v46);
      if (!v30)
      {
        if (v31)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null type, no backtrace";
          goto LABEL_85;
        }
        goto LABEL_86;
      }
      if (!v31) {
        goto LABEL_59;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      long long v50 = v30;
      objc_super v32 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_58;
    }
    os_log_type_t v20 = __nwlog_obj();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null type";
LABEL_85:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_86;
  }
  if (!v12)
  {
    unint64_t v24 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v19, &v46, &v45)) {
      goto LABEL_87;
    }
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null items, backtrace limit exceeded";
          goto LABEL_85;
        }
        goto LABEL_86;
      }
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      BOOL v33 = os_log_type_enabled(v20, v46);
      if (!v30)
      {
        if (v33)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null items, no backtrace";
          goto LABEL_85;
        }
        goto LABEL_86;
      }
      if (!v33) {
        goto LABEL_59;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      long long v50 = v30;
      objc_super v32 = "%{public}s called with null items, dumping backtrace:%{public}s";
      goto LABEL_58;
    }
    os_log_type_t v20 = __nwlog_obj();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null items";
    goto LABEL_85;
  }
  if (!v13)
  {
    BOOL v25 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v19, &v46, &v45)) {
      goto LABEL_87;
    }
    if (v46 != OS_LOG_TYPE_FAULT)
    {
      if (!v45)
      {
        os_log_type_t v20 = __nwlog_obj();
        os_log_type_t v21 = v46;
        if (os_log_type_enabled(v20, v46))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null endpoint, backtrace limit exceeded";
          goto LABEL_85;
        }
        goto LABEL_86;
      }
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      BOOL v34 = os_log_type_enabled(v20, v46);
      if (!v30)
      {
        if (v34)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v48 = "nw_storage_store_items";
          unint64_t v22 = "%{public}s called with null endpoint, no backtrace";
          goto LABEL_85;
        }
        goto LABEL_86;
      }
      if (!v34) {
        goto LABEL_59;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      long long v50 = v30;
      objc_super v32 = "%{public}s called with null endpoint, dumping backtrace:%{public}s";
      goto LABEL_58;
    }
    os_log_type_t v20 = __nwlog_obj();
    os_log_type_t v21 = v46;
    if (!os_log_type_enabled(v20, v46)) {
      goto LABEL_86;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    unint64_t v22 = "%{public}s called with null endpoint";
    goto LABEL_85;
  }
  if (!v14)
  {
    unint64_t v26 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v19, &v46, &v45)) {
      goto LABEL_87;
    }
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      if (!os_log_type_enabled(v20, v46)) {
        goto LABEL_86;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v48 = "nw_storage_store_items";
      unint64_t v22 = "%{public}s called with null context";
      goto LABEL_85;
    }
    if (!v45)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      if (os_log_type_enabled(v20, v46))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_85;
      }
      goto LABEL_86;
    }
    uint64_t v30 = (char *)__nw_create_backtrace_string();
    os_log_type_t v20 = __nwlog_obj();
    os_log_type_t v21 = v46;
    BOOL v35 = os_log_type_enabled(v20, v46);
    if (!v30)
    {
      if (v35)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null context, no backtrace";
        goto LABEL_85;
      }
      goto LABEL_86;
    }
    if (!v35) {
      goto LABEL_59;
    }
    *(_DWORD *)long long buf = 136446466;
    BOOL v48 = "nw_storage_store_items";
    __int16 v49 = 2082;
    long long v50 = v30;
    objc_super v32 = "%{public}s called with null context, dumping backtrace:%{public}s";
LABEL_58:
    _os_log_impl(&dword_1830D4000, v20, v21, v32, buf, 0x16u);
    goto LABEL_59;
  }
  if (!v15)
  {
    BOOL v27 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v48 = "nw_storage_store_items";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v19, &v46, &v45)) {
      goto LABEL_87;
    }
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      if (os_log_type_enabled(v20, v46))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null completion";
        goto LABEL_85;
      }
LABEL_86:

      goto LABEL_87;
    }
    if (!v45)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = v46;
      if (os_log_type_enabled(v20, v46))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null completion, backtrace limit exceeded";
        goto LABEL_85;
      }
      goto LABEL_86;
    }
    uint64_t v30 = (char *)__nw_create_backtrace_string();
    os_log_type_t v20 = __nwlog_obj();
    os_log_type_t v21 = v46;
    BOOL v36 = os_log_type_enabled(v20, v46);
    if (!v30)
    {
      if (v36)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v48 = "nw_storage_store_items";
        unint64_t v22 = "%{public}s called with null completion, no backtrace";
        goto LABEL_85;
      }
      goto LABEL_86;
    }
    if (v36)
    {
      *(_DWORD *)long long buf = 136446466;
      BOOL v48 = "nw_storage_store_items";
      __int16 v49 = 2082;
      long long v50 = v30;
      objc_super v32 = "%{public}s called with null completion, dumping backtrace:%{public}s";
      goto LABEL_58;
    }
LABEL_59:

    free(v30);
    if (!v19) {
      goto LABEL_8;
    }
    goto LABEL_88;
  }
  BOOL v17 = v11[2];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __nw_storage_store_items_block_invoke;
  block[3] = &unk_1E52499D0;
  uint64_t v38 = v11;
  uint64_t v44 = a2;
  id v39 = v13;
  id v40 = 0;
  id v41 = v12;
  id v42 = v14;
  id v43 = v16;
  dispatch_async(v17, block);

LABEL_8:
}

void __nw_storage_store_items_block_invoke(uint64_t a1)
{
  int v2 = nw_storage_provider_for_type(*(void **)(a1 + 32), *(void *)(a1 + 80));
  uint64_t v3 = (const char *)(*((uint64_t (**)(void, void))v2 + 3))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  if (v3)
  {
    uint64_t v4 = (char *)v3;
    id v5 = nw_storage_fault_in_canvas(*(void **)(a1 + 32), v3, *(const char **)(a1 + 80), (uint64_t)v2);
    id v6 = *(atomic_uchar **)(a1 + 56);
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    v8[2] = __nw_storage_store_items_block_invoke_2;
    v8[3] = &unk_1E52424A8;
    id v12 = v2;
    id v7 = v5;
    id v9 = v7;
    id v10 = *(id *)(a1 + 40);
    id v11 = *(id *)(a1 + 48);
    nw_array_apply(v6, (uint64_t)v8);
    if ((*((unsigned int (**)(id))v2 + 7))(v7)) {
      nw_storage_enqueue_flush_and_free_key(*(void **)(a1 + 32), (uint64_t)v4, *(void *)(a1 + 80));
    }
    else {
      free(v4);
    }
  }
  nw_queue_context_async(*(void **)(a1 + 64), *(void **)(a1 + 72));
}

uint64_t __nw_storage_store_items_block_invoke_2(void *a1, uint64_t a2, uint64_t a3)
{
  return 1;
}

void __nw_storage_remove_items_block_invoke(uint64_t a1)
{
  int v2 = nw_storage_provider_for_type(*(void **)(a1 + 32), *(void *)(a1 + 80));
  uint64_t v3 = (const char *)(*((uint64_t (**)(void, void))v2 + 3))(*(void *)(a1 + 40), *(void *)(a1 + 48));
  if (v3)
  {
    uint64_t v4 = (char *)v3;
    id v5 = nw_storage_fault_in_canvas(*(void **)(a1 + 32), v3, *(const char **)(a1 + 80), (uint64_t)v2);
    id v6 = v5;
    id v7 = *(atomic_uchar **)(a1 + 56);
    if (v7)
    {
      v8[0] = MEMORY[0x1E4F143A8];
      v8[1] = 3221225472;
      v8[2] = __nw_storage_remove_items_block_invoke_2;
      v8[3] = &unk_1E52424A8;
      id v12 = v2;
      id v9 = v5;
      id v10 = *(id *)(a1 + 40);
      id v11 = *(id *)(a1 + 48);
      nw_array_apply(v7, (uint64_t)v8);
    }
    else
    {
      (*((void (**)(void *, void, void, void))v2 + 2))(v5, 0, *(void *)(a1 + 40), *(void *)(a1 + 48));
    }
    if ((*((unsigned int (**)(void *))v2 + 7))(v6)) {
      nw_storage_enqueue_flush_and_free_key(*(void **)(a1 + 32), (uint64_t)v4, *(void *)(a1 + 80));
    }
    else {
      free(v4);
    }
  }
  nw_queue_context_async(*(void **)(a1 + 64), *(void **)(a1 + 72));
}

uint64_t __nw_storage_remove_items_block_invoke_2(void *a1, uint64_t a2, uint64_t a3)
{
  return 1;
}

void sub_183A2EACC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,id location)
{
  objc_destroyWeak(v26);
  objc_destroyWeak(v25);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void nw_udp_deallocate_metadata(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_udp_allocate_metadata(void *a1)
{
  id v1 = a1;
  int v2 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    _OWORD *v2 = 0u;
    v2[1] = 0u;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183A2EF68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_deserialize_options(void *a1, _DWORD *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (a2)
  {
    if (a3 == 4)
    {
      BOOL v7 = nw_udp_copy_options(v5, a2);
      goto LABEL_4;
    }
    id v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v25 = "nw_udp_deserialize_options";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_udp_options))", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v22)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_udp_options)), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_udp_options)), no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v19)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v25 = "nw_udp_deserialize_options";
        __int16 v26 = 2082;
        BOOL v27 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_udp_options)), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    id v9 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v25 = "nw_udp_deserialize_options";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null serialized_bytes", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v22)
      {
        id v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null serialized_bytes, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v25 = "nw_udp_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null serialized_bytes, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v25 = "nw_udp_deserialize_options";
        __int16 v26 = 2082;
        BOOL v27 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v10) {
    free(v10);
  }
  BOOL v7 = 0;
LABEL_4:

  return v7;
}

void sub_183A2F434(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_serialize_options(void *a1, _DWORD *a2, void *a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (a2)
  {
    BOOL v7 = nw_udp_copy_options(v5, a2);
    *a3 = 4;
    goto LABEL_3;
  }
  id v9 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v20 = "nw_udp_serialize_options";
  id v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v20 = "nw_udp_serialize_options";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null existing_handle", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v20 = "nw_udp_serialize_options";
          __int16 v21 = 2082;
          char v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v15)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v20 = "nw_udp_serialize_options";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v20 = "nw_udp_serialize_options";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v10) {
    free(v10);
  }
  BOOL v7 = 0;
LABEL_3:

  return v7;
}

void sub_183A2F6F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_option_is_equal(uint64_t a1, _DWORD *a2, _DWORD *a3)
{
  return *a2 == *a3;
}

void nw_udp_options_set_prefer_no_checksum(nw_protocol_options_t options, BOOL prefer_no_checksum)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = options;
  if (nw_protocol_options_is_udp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_udp_options_set_prefer_no_checksum_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = prefer_no_checksum;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_udp_options_set_prefer_no_checksum";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_udp_options_set_prefer_no_checksum";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_udp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_udp_options_set_prefer_no_checksum";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_udp_options_set_prefer_no_checksum";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_udp_options_set_prefer_no_checksum";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A2FA00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_set_prefer_no_checksum_block_invoke(uint64_t a1, unsigned char *a2)
{
  *a2 = *a2 & 0xFE | *(unsigned char *)(a1 + 32);
  return 1;
}

uint64_t __nw_udp_options_set_ignore_inbound_checksum_block_invoke(uint64_t a1, unsigned char *a2)
{
  *a2 = *a2 & 0xFB | (4 * *(unsigned char *)(a1 + 32));
  return 1;
}

void nw_udp_options_set_use_quic_stats(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_udp(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_udp_options_set_use_quic_stats_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_udp_options_set_use_quic_stats";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_udp_options_set_use_quic_stats";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_udp(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_udp_options_set_use_quic_stats";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_udp_options_set_use_quic_stats";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_udp_options_set_use_quic_stats";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A2FD34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_udp_options_set_use_quic_stats_block_invoke(uint64_t a1, unsigned char *a2)
{
  *a2 = *a2 & 0xF7 | (8 * *(unsigned char *)(a1 + 32));
  return 1;
}

nw_protocol_metadata_t nw_udp_create_metadata(void)
{
  if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
    dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
  }
  uint64_t v0 = (void *)g_udp_definition;

  return (nw_protocol_metadata_t)nw_protocol_metadata_create_singleton(v0);
}

BOOL nw_protocol_metadata_is_udp(nw_protocol_metadata_t metadata)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  if (v1)
  {
    if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
      dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
    }
    BOOL v2 = nw_protocol_metadata_matches_definition((uint64_t)v1, g_udp_definition);
    goto LABEL_5;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v15 = "nw_protocol_metadata_is_udp";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_protocol_metadata_is_udp";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v15 = "nw_protocol_metadata_is_udp";
          __int16 v16 = 2082;
          char v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_protocol_metadata_is_udp";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_protocol_metadata_is_udp";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_5:

  return v2;
}

void sub_183A30088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A30A50(_Unwind_Exception *a1)
{
  objc_destroyWeak(v4);
  objc_destroyWeak(v3);
  objc_destroyWeak(v2);
  objc_destroyWeak((id *)(v5 - 72));
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

void sub_183A36B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,char a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26,uint64_t a27,uint64_t a28,uint64_t a29,char a30)
{
}

void sub_183A36C5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id obj)
{
}

void sub_183A39CC4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,char a26)
{
}

uint64_t __Block_byref_object_copy__46156(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__46157(uint64_t a1)
{
}

void sub_183A3A45C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v17);
  objc_destroyWeak(&location);
  _Unwind_Resume(a1);
}

void sub_183A3A8BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A4218C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A45600(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A46634(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_frame_reclassify(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && (id v3 = (void (*)(uint64_t, uint64_t, uint64_t))g_channel_reclassifier) != 0)
    {
      uint64_t v4 = *(void *)(a1 + 88);
      v3(a1, a2, v4);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v15 = "nw_frame_reclassify";
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s frame does not support reclassify", buf, 0xCu);
      }
      nw_frame_finalize(a1);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v15 = "nw_frame_reclassify";
  id v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v15 = "nw_frame_reclassify";
      os_log_type_t v9 = "%{public}s called with null frame";
      goto LABEL_24;
    }
    if (!v12)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v15 = "nw_frame_reclassify";
      os_log_type_t v9 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v15 = "nw_frame_reclassify";
        __int16 v16 = 2082;
        char v17 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v11)
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v15 = "nw_frame_reclassify";
      os_log_type_t v9 = "%{public}s called with null frame, no backtrace";
LABEL_24:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_25:
  if (v6) {
    free(v6);
  }
}

void nw_frame_set_is_channel_frame(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v3 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v2 = a1 + 204;
    int v4 = v3 | (*(unsigned __int8 *)(v2 + 2) << 16);
    if (a2) {
      __int16 v5 = 256;
    }
    else {
      __int16 v5 = 0;
    }
    unsigned int v6 = v4 & 0xFFFFFEFF;
    *(_WORD *)uint64_t v2 = v6 | v5;
    *(unsigned char *)(v2 + 2) = BYTE2(v6);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v16 = "__nw_frame_set_is_channel_frame";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_channel_frame";
      BOOL v10 = "%{public}s called with null frame";
      goto LABEL_20;
    }
    if (!v13)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_channel_frame";
      BOOL v10 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)long long buf = 136446466;
        __int16 v16 = "__nw_frame_set_is_channel_frame";
        __int16 v17 = 2082;
        uint64_t v18 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v12)
    {
      *(_DWORD *)long long buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_channel_frame";
      BOOL v10 = "%{public}s called with null frame, no backtrace";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
}

void nw_frame_set_flow_id(uint64_t a1, uint64_t a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v14 = "nw_frame_set_flow_id";
    int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)long long buf = 136446210;
      char v14 = "nw_frame_set_flow_id";
      unsigned int v6 = "%{public}s called with null frame";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)long long buf = 136446466;
          char v14 = "nw_frame_set_flow_id";
          __int16 v15 = 2082;
          __int16 v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v3) {
          return;
        }
        goto LABEL_37;
      }
      if (!v8) {
        goto LABEL_36;
      }
      *(_DWORD *)long long buf = 136446210;
      char v14 = "nw_frame_set_flow_id";
      unsigned int v6 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)long long buf = 136446210;
      char v14 = "nw_frame_set_flow_id";
      unsigned int v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_36;
  }
  if (a2)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
    {
      uint64_t v2 = (void (*)(void))g_channel_set_flow_handler;
      if (g_channel_set_flow_handler)
      {
        v2();
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v14 = "nw_frame_set_flow_id";
  int v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_36;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)long long buf = 136446210;
    char v14 = "nw_frame_set_flow_id";
    unsigned int v6 = "%{public}s called with null flow_id";
    goto LABEL_35;
  }
  if (!v11)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)long long buf = 136446210;
    char v14 = "nw_frame_set_flow_id";
    unsigned int v6 = "%{public}s called with null flow_id, backtrace limit exceeded";
    goto LABEL_35;
  }
  os_log_type_t v9 = (char *)__nw_create_backtrace_string();
  int v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v10 = os_log_type_enabled(v4, type);
  if (!v9)
  {
    if (!v10) {
      goto LABEL_36;
    }
    *(_DWORD *)long long buf = 136446210;
    char v14 = "nw_frame_set_flow_id";
    unsigned int v6 = "%{public}s called with null flow_id, no backtrace";
    goto LABEL_35;
  }
  if (v10)
  {
    *(_DWORD *)long long buf = 136446466;
    char v14 = "nw_frame_set_flow_id";
    __int16 v15 = 2082;
    __int16 v16 = v9;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null flow_id, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v9);
  if (v3) {
LABEL_37:
  }
    free(v3);
}

uint64_t nw_frame_get_flow_id(uint64_t a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      uint64_t result = 0;
      if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
      {
        if (g_channel_get_flow_handler)
        {
          g_channel_get_flow_handler(a1, a2);
          return 1;
        }
      }
      return result;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v15 = "nw_frame_get_flow_id";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v15 = "nw_frame_get_flow_id";
        os_log_type_t v7 = "%{public}s called with null out_flow_id";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if (!v12)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v15 = "nw_frame_get_flow_id";
        os_log_type_t v7 = "%{public}s called with null out_flow_id, backtrace limit exceeded";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v11 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v15 = "nw_frame_get_flow_id";
        os_log_type_t v7 = "%{public}s called with null out_flow_id, no backtrace";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if (v11)
    {
      *(_DWORD *)long long buf = 136446466;
      __int16 v15 = "nw_frame_get_flow_id";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null out_flow_id, dumping backtrace:%{public}s";
      goto LABEL_23;
    }
    goto LABEL_24;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v15 = "nw_frame_get_flow_id";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12)) {
    goto LABEL_34;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v12)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v15 = "nw_frame_get_flow_id";
        os_log_type_t v7 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v15 = "nw_frame_get_flow_id";
        os_log_type_t v7 = "%{public}s called with null frame, no backtrace";
        goto LABEL_33;
      }
      goto LABEL_34;
    }
    if (v9)
    {
      *(_DWORD *)long long buf = 136446466;
      __int16 v15 = "nw_frame_get_flow_id";
      __int16 v16 = 2082;
      uint64_t v17 = backtrace_string;
      BOOL v10 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_23:
      _os_log_impl(&dword_1830D4000, v5, v6, v10, buf, 0x16u);
    }
LABEL_24:
    free(backtrace_string);
    goto LABEL_34;
  }
  os_log_type_t v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  if (os_log_type_enabled(v5, type))
  {
    *(_DWORD *)long long buf = 136446210;
    __int16 v15 = "nw_frame_get_flow_id";
    os_log_type_t v7 = "%{public}s called with null frame";
LABEL_33:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
  }
LABEL_34:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t nw_frame_set_internet_checksum(uint64_t a1, char a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v14 = "__nw_frame_set_internet_checksum";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v5, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v14 = "__nw_frame_set_internet_checksum";
          BOOL v8 = "%{public}s called with null frame";
LABEL_20:
          _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
        }
      }
      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)long long buf = 136446466;
            char v14 = "__nw_frame_set_internet_checksum";
            __int16 v15 = 2082;
            __int16 v16 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_21;
        }
        if (v10)
        {
          *(_DWORD *)long long buf = 136446210;
          char v14 = "__nw_frame_set_internet_checksum";
          BOOL v8 = "%{public}s called with null frame, no backtrace";
          goto LABEL_20;
        }
      }
      else
      {
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v14 = "__nw_frame_set_internet_checksum";
          BOOL v8 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_20;
        }
      }
    }
LABEL_21:
    if (v5) {
      free(v5);
    }
    return 22;
  }
  uint64_t v2 = 45;
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0) {
    return v2;
  }
  int v3 = (uint64_t (*)(void))g_channel_set_internet_checksum_handler;
  if (!g_channel_set_internet_checksum_handler) {
    return v2;
  }
  *(unsigned char *)(a1 + 203) |= a2;

  return v3();
}

uint64_t nw_frame_get_internet_checksum(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v13 = "__nw_frame_get_internet_checksum";
    int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v4, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v13 = "__nw_frame_get_internet_checksum";
          os_log_type_t v7 = "%{public}s called with null frame";
LABEL_20:
          _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
        }
      }
      else if (v10)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)long long buf = 136446466;
            char v13 = "__nw_frame_get_internet_checksum";
            __int16 v14 = 2082;
            __int16 v15 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_21;
        }
        if (v9)
        {
          *(_DWORD *)long long buf = 136446210;
          char v13 = "__nw_frame_get_internet_checksum";
          os_log_type_t v7 = "%{public}s called with null frame, no backtrace";
          goto LABEL_20;
        }
      }
      else
      {
        os_log_type_t v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v13 = "__nw_frame_get_internet_checksum";
          os_log_type_t v7 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_20;
        }
      }
    }
LABEL_21:
    if (v4) {
      free(v4);
    }
    return 22;
  }
  uint64_t v1 = 45;
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0) {
    return v1;
  }
  uint64_t v2 = (uint64_t (*)(void))g_channel_get_internet_checksum_handler;
  if (!g_channel_get_internet_checksum_handler) {
    return v1;
  }

  return v2();
}

void nw_frame_set_departure_time(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)(a1 + 160) = a2;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v11 = "__nw_frame_set_departure_time";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      char v11 = "__nw_frame_set_departure_time";
      os_log_type_t v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }
    if (!v8)
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      char v11 = "__nw_frame_set_departure_time";
      os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)long long buf = 136446466;
        char v11 = "__nw_frame_set_departure_time";
        __int16 v12 = 2082;
        char v13 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v7)
    {
      *(_DWORD *)long long buf = 136446210;
      char v11 = "__nw_frame_set_departure_time";
      os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
}

uint64_t nw_frame_get_departure_time(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 160);
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v11 = "__nw_frame_get_departure_time";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v11 = "__nw_frame_get_departure_time";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 136446466;
          char v11 = "__nw_frame_get_departure_time";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)long long buf = 136446210;
        char v11 = "__nw_frame_get_departure_time";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v11 = "__nw_frame_get_departure_time";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t nw_frame_get_manager_for_size(unsigned int a1)
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  id v2 = (id)nw_context_copy_implicit_context::implicit_context;

  return nw_frame_get_buffer_manager_with_context(v2, a1);
}

dispatch_data_t nw_frame_copy_unclaimed_data(unsigned int *object, int a2, unsigned char *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v30 = "nw_frame_copy_unclaimed_data";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v19, &v28, &v27)) {
      goto LABEL_43;
    }
    if (v28 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = v28;
      if (!os_log_type_enabled(v20, v28)) {
        goto LABEL_43;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v30 = "nw_frame_copy_unclaimed_data";
      char v22 = "%{public}s called with null frame";
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = v28;
      BOOL v24 = os_log_type_enabled(v20, v28);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v30 = "nw_frame_copy_unclaimed_data";
          __int16 v31 = 2082;
          objc_super v32 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_43;
      }
      if (!v24)
      {
LABEL_43:
        if (v19) {
          free(v19);
        }
        return 0;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v30 = "nw_frame_copy_unclaimed_data";
      char v22 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = v28;
      if (!os_log_type_enabled(v20, v28)) {
        goto LABEL_43;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v30 = "nw_frame_copy_unclaimed_data";
      char v22 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_43;
  }
  if (a3) {
    *a3 = 0;
  }
  if (!*((void *)object + 14)
    || (object[51] & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(object, *((void *)object + 11)))
  {
    return 0;
  }
  unsigned int v6 = object[13];
  if (!v6) {
    return 0;
  }
  uint64_t v7 = 0;
  uint64_t v8 = object[14];
  int v9 = object[15] + v8;
  size_t v10 = v6 - v9;
  if (v6 == v9) {
    return (dispatch_data_t)v7;
  }
  char v11 = (char *)*((void *)object + 14);
  if (!v11) {
    return (dispatch_data_t)v7;
  }
  if ((object[51] & 2) != 0)
  {
    uint64_t v7 = *((void *)object + 12);
    if (v7) {
      dispatch_retain(*((dispatch_object_t *)object + 12));
    }
    return (dispatch_data_t)v7;
  }
  if ((object[51] & 1) == 0 || v8)
  {
    uint64_t v15 = *((void *)object + 13);
    if (!v15 || v8)
    {
      v11 += v8;
      if (!a2)
      {
        char v13 = v11;
        size_t v14 = v6 - v9;
        __int16 v12 = 0;
        goto LABEL_26;
      }
      if (a3) {
        *a3 = 1;
      }
      os_retain(object);
      BOOL v16 = nw_queue_copy_current_workloop();
      destructor[0] = MEMORY[0x1E4F143A8];
      destructor[1] = 0x40000000;
      destructor[2] = __nw_frame_copy_unclaimed_data_block_invoke_2;
      destructor[3] = &__block_descriptor_tmp_5_47033;
      destructor[4] = object;
      uint64_t v17 = destructor;
    }
    else
    {
      nw_frame_will_free_buffer_externally((uint64_t)object);
      BOOL v16 = nw_queue_copy_current_workloop();
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 0x40000000;
      v26[2] = __nw_frame_copy_unclaimed_data_block_invoke;
      v26[3] = &__block_descriptor_tmp_47032;
      v26[4] = v15;
      void v26[5] = v11;
      uint64_t v17 = v26;
    }
    return dispatch_data_create(v11, v10, (dispatch_queue_t)v16, v17);
  }
  nw_frame_will_free_buffer_externally((uint64_t)object);
  __int16 v12 = (void *)*MEMORY[0x1E4F143F0];
  char v13 = v11;
  size_t v14 = v10;
LABEL_26:

  return dispatch_data_create(v13, v14, 0, v12);
}

void __nw_frame_copy_unclaimed_data_block_invoke(uint64_t a1)
{
}

void __nw_frame_copy_unclaimed_data_block_invoke_2(uint64_t a1)
{
  nw_frame_finalize(*(void *)(a1 + 32));
  id v2 = *(void **)(a1 + 32);
  if (v2)
  {
    os_release(v2);
  }
}

uint64_t nw_frame_copy_metadata_uuid(uint64_t a1, _OWORD *a2, BOOL *a3)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    size_t v14 = "__nw_frame_copy_metadata_uuid";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v5, &type, &v11)) {
      goto LABEL_21;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      size_t v14 = "__nw_frame_copy_metadata_uuid";
      uint64_t v8 = "%{public}s called with null frame";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          size_t v14 = "__nw_frame_copy_metadata_uuid";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v10)
      {
LABEL_21:
        if (v5) {
          free(v5);
        }
        return 0;
      }
      *(_DWORD *)long long buf = 136446210;
      size_t v14 = "__nw_frame_copy_metadata_uuid";
      uint64_t v8 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      size_t v14 = "__nw_frame_copy_metadata_uuid";
      uint64_t v8 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_21;
  }
  uint64_t v3 = *(void *)(a1 + 64);
  if (v3)
  {
    if (a3) {
      *a3 = (*(unsigned char *)(v3 + 66) & 0x40) != 0;
    }
    if (*(void *)(v3 + 48))
    {
      *a2 = *(_OWORD *)(v3 + 16);
      return 1;
    }
  }
  return 0;
}

uint64_t nw_frame_is_connection_complete(uint64_t a1)
{
  return *(unsigned __int8 *)(a1 + 186) >> 7;
}

uint64_t nw_frame_set_connection_complete(uint64_t result, int a2)
{
  if (a2) {
    char v2 = 0x80;
  }
  else {
    char v2 = 0;
  }
  *(unsigned char *)(result + 186) = v2 & 0x80 | *(unsigned char *)(result + 186) & 0x7F;
  return result;
}

void nw_frame_set_expire_time(uint64_t a1, uint64_t a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    __int16 v3 = *(_WORD *)(a1 + 204);
    char v2 = (_WORD *)(a1 + 204);
    _WORD *v2 = v3 | 0x10;
    *(void *)(v2 - 26) = a2;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v13 = "__nw_frame_set_expire_time";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      char v13 = "__nw_frame_set_expire_time";
      os_log_type_t v7 = "%{public}s called with null frame";
      goto LABEL_17;
    }
    if (!v10)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      char v13 = "__nw_frame_set_expire_time";
      os_log_type_t v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)long long buf = 136446466;
        char v13 = "__nw_frame_set_expire_time";
        __int16 v14 = 2082;
        __int16 v15 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v9)
    {
      *(_DWORD *)long long buf = 136446210;
      char v13 = "__nw_frame_set_expire_time";
      os_log_type_t v7 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_18:
  if (v4) {
    free(v4);
  }
}

uint64_t nw_frame_get_expire_time(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v11 = "__nw_frame_get_expire_time";
    char v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v8 = 0;
    if (!__nwlog_fault(v2, &type, &v8)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      char v11 = "__nw_frame_get_expire_time";
      os_log_type_t v5 = "%{public}s called with null frame";
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 136446466;
          char v11 = "__nw_frame_get_expire_time";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v7)
      {
LABEL_20:
        if (v2) {
          free(v2);
        }
        return 0;
      }
      *(_DWORD *)long long buf = 136446210;
      char v11 = "__nw_frame_get_expire_time";
      os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      __int16 v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      char v11 = "__nw_frame_get_expire_time";
      os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
    goto LABEL_20;
  }
  if ((*(_WORD *)(a1 + 204) & 0x10) == 0) {
    return 0;
  }
  return *(void *)(a1 + 152);
}

void nw_frame_set_packet_id(uint64_t a1, _OWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v15 = "__nw_frame_set_packet_id";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v15 = "__nw_frame_set_packet_id";
      BOOL v7 = "%{public}s called with null frame";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v15 = "__nw_frame_set_packet_id";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v4) {
          return;
        }
LABEL_35:
        free(v4);
        return;
      }
      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v15 = "__nw_frame_set_packet_id";
      BOOL v7 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      os_log_type_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v15 = "__nw_frame_set_packet_id";
      BOOL v7 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }
  if (a2)
  {
    int v2 = *(unsigned __int16 *)(a1 + 204);
    int v3 = v2 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v2 & 8) == 0)
    {
      *(_OWORD *)(a1 + 136) = *a2;
      *(unsigned char *)(a1 + 206) = BYTE2(v3);
      *(_WORD *)(a1 + 204) = v3 | 0x20;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v15 = "__nw_frame_set_packet_id";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12)) {
    goto LABEL_34;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v15 = "__nw_frame_set_packet_id";
    BOOL v7 = "%{public}s called with null packet_id";
    goto LABEL_33;
  }
  if (!v12)
  {
    os_log_type_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v15 = "__nw_frame_set_packet_id";
    BOOL v7 = "%{public}s called with null packet_id, backtrace limit exceeded";
    goto LABEL_33;
  }
  char v10 = (char *)__nw_create_backtrace_string();
  os_log_type_t v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v15 = "__nw_frame_set_packet_id";
    BOOL v7 = "%{public}s called with null packet_id, no backtrace";
    goto LABEL_33;
  }
  if (v11)
  {
    *(_DWORD *)long long buf = 136446466;
    __int16 v15 = "__nw_frame_set_packet_id";
    __int16 v16 = 2082;
    uint64_t v17 = v10;
    _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null packet_id, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}

uint64_t nw_frame_get_packet_id(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x20) != 0) {
      return a1 + 136;
    }
    else {
      return 0;
    }
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v11 = "__nw_frame_get_packet_id";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v11 = "__nw_frame_get_packet_id";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_19:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v11 = "__nw_frame_get_packet_id";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (v7)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v11 = "__nw_frame_get_packet_id";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_19;
      }
    }
    else
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v11 = "__nw_frame_get_packet_id";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }
LABEL_20:
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_frame_set_is_wake_packet(uint64_t a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v3 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v2 = a1 + 204;
    int v4 = v3 | (*(unsigned __int8 *)(v2 + 2) << 16);
    if (a2) {
      __int16 v5 = 0x4000;
    }
    else {
      __int16 v5 = 0;
    }
    unsigned int v6 = v4 & 0xFFFFBFFF;
    *(_WORD *)uint64_t v2 = v6 | v5;
    *(unsigned char *)(v2 + 2) = BYTE2(v6);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v16 = "__nw_frame_set_is_wake_packet";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_wake_packet";
      char v10 = "%{public}s called with null frame";
      goto LABEL_20;
    }
    if (!v13)
    {
      char v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_wake_packet";
      char v10 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)long long buf = 136446466;
        __int16 v16 = "__nw_frame_set_is_wake_packet";
        __int16 v17 = 2082;
        uint64_t v18 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v12)
    {
      *(_DWORD *)long long buf = 136446210;
      __int16 v16 = "__nw_frame_set_is_wake_packet";
      char v10 = "%{public}s called with null frame, no backtrace";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
}

void nw_frame_set_app_metadata(uint64_t a1, char a2, char a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v3 = *(unsigned __int16 *)(a1 + 204) | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v3 & 0x10000) == 0)
    {
      *(unsigned char *)(a1 + 201) = a2;
      *(unsigned char *)(a1 + 202) = a3;
      *(_WORD *)(a1 + 204) = v3;
      *(unsigned char *)(a1 + 206) = (v3 | 0x10000u) >> 16;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v13 = "__nw_frame_set_app_metadata";
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446210;
      char v13 = "__nw_frame_set_app_metadata";
      BOOL v7 = "%{public}s called with null frame";
      goto LABEL_18;
    }
    if (!v10)
    {
      __int16 v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446210;
      char v13 = "__nw_frame_set_app_metadata";
      BOOL v7 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v9 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (v9)
      {
        *(_DWORD *)long long buf = 136446466;
        char v13 = "__nw_frame_set_app_metadata";
        __int16 v14 = 2082;
        __int16 v15 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_19;
    }
    if (v9)
    {
      *(_DWORD *)long long buf = 136446210;
      char v13 = "__nw_frame_set_app_metadata";
      BOOL v7 = "%{public}s called with null frame, no backtrace";
LABEL_18:
      _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    }
  }
LABEL_19:
  if (v4) {
    free(v4);
  }
}

BOOL nw_frame_is_in_array(void *a1, int a2)
{
  if (a2)
  {
    if (a1[4]) {
      return 1;
    }
    int v3 = a1 + 5;
  }
  else
  {
    if (a1[2]) {
      return 1;
    }
    int v3 = a1 + 3;
  }
  return *v3 != 0;
}

uint64_t nw_frame_array_last(uint64_t a1)
{
  return **(void **)(*(void *)(a1 + 8) + 8);
}

uint64_t nw_frame_array_previous(int a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a2 + 40);
    if (*(_OWORD *)(a2 + 32) == 0) {
      return 0;
    }
  }
  else
  {
    uint64_t v2 = *(void *)(a2 + 24);
    if (*(_OWORD *)(a2 + 16) == 0) {
      return 0;
    }
  }
  return **(void **)(v2 + 8);
}

uint64_t nw_frame_array_insert_after(uint64_t result, int a2, void *a3, uint64_t a4)
{
  int v4 = (void *)(result + 8);
  if (a2)
  {
    uint64_t v6 = *(void *)(a4 + 32);
    __int16 v5 = (void *)(a4 + 32);
    a3[4] = v6;
    BOOL v7 = (void *)(v6 + 40);
    if (v6) {
      int v4 = v7;
    }
    *int v4 = a3 + 4;
    void *v5 = a3;
    a3[5] = v5;
  }
  else
  {
    uint64_t v9 = *(void *)(a4 + 16);
    char v8 = (void *)(a4 + 16);
    a3[2] = v9;
    char v10 = (void *)(v9 + 24);
    if (v9) {
      int v4 = v10;
    }
    *int v4 = a3 + 2;
    void *v8 = a3;
    a3[3] = v8;
  }
  return result;
}

uint64_t nw_frame_array_remove_each(uint64_t result, char a2, uint64_t a3)
{
  int v4 = (uint64_t *)result;
  if (a2)
  {
    do
    {
      uint64_t v6 = *v4;
      if (!*v4) {
        break;
      }
      uint64_t v7 = *(void *)(v6 + 32);
      __int16 v5 = *(void **)(v6 + 40);
      if (v7)
      {
        *(void *)(v7 + 40) = v5;
        __int16 v5 = *(void **)(v6 + 40);
      }
      else
      {
        v4[1] = (uint64_t)v5;
      }
      void *v5 = v7;
      *(void *)(v6 + 32) = 0;
      *(void *)(v6 + 40) = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }
    while ((result & 1) != 0);
  }
  else
  {
    do
    {
      uint64_t v9 = *v4;
      if (!*v4) {
        break;
      }
      uint64_t v10 = *(void *)(v9 + 16);
      char v8 = *(void **)(v9 + 24);
      if (v10)
      {
        *(void *)(v10 + 24) = v8;
        char v8 = *(void **)(v9 + 24);
      }
      else
      {
        v4[1] = (uint64_t)v8;
      }
      void *v8 = v10;
      *(void *)(v9 + 16) = 0;
      *(void *)(v9 + 24) = 0;
      uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
    }
    while ((result & 1) != 0);
  }
  return result;
}

void *nw_frame_array_prepend_array(void *result, void **a2, int a3)
{
  uint64_t v3 = *result;
  if (a3)
  {
    if (v3)
    {
      *a2[1] = v3;
      int v4 = (void *)result[1];
      *(void *)(*result + 40) = a2[1];
      a2[1] = v4;
      *uint64_t result = 0;
      result[1] = result;
    }
    if (*a2)
    {
      __int16 v5 = (void *)result[1];
      ++result;
      void *v5 = *a2;
      (*a2)[5] = *result;
LABEL_10:
      *uint64_t result = a2[1];
      *a2 = 0;
      a2[1] = a2;
    }
  }
  else
  {
    if (v3)
    {
      *a2[1] = v3;
      uint64_t v6 = (void *)result[1];
      *(void *)(*result + 24) = a2[1];
      a2[1] = v6;
      *uint64_t result = 0;
      result[1] = result;
    }
    if (*a2)
    {
      uint64_t v7 = (void *)result[1];
      ++result;
      *uint64_t v7 = *a2;
      (*a2)[3] = *result;
      goto LABEL_10;
    }
  }
  return result;
}

uint64_t nw_frame_array_unclaimed_length(uint64_t *a1, int a2)
{
  unsigned int v3 = 0;
  nw_frame_array_get_frame_count(a1, a2, &v3);
  return v3;
}

BOOL nw_frame_array_check_length(uint64_t *a1, char a2, unsigned int a3)
{
  uint64_t v3 = *a1;
  unsigned int v4 = 0;
  if (a2)
  {
    while (v3)
    {
      int v8 = *(_DWORD *)(v3 + 52);
      if (v8) {
        v8 -= *(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60);
      }
      uint64_t v3 = *(void *)(v3 + 32);
      BOOL v5 = __CFADD__(v4, v8);
      unsigned int v6 = v4 + v8;
      v4 += v8;
      if (v5) {
        unsigned int v7 = -1;
      }
      else {
        unsigned int v7 = v6;
      }
      if (v7 >= a3) {
        return 1;
      }
    }
  }
  else
  {
    while (v3)
    {
      int v11 = *(_DWORD *)(v3 + 52);
      if (v11) {
        v11 -= *(_DWORD *)(v3 + 56) + *(_DWORD *)(v3 + 60);
      }
      uint64_t v3 = *(void *)(v3 + 16);
      BOOL v5 = __CFADD__(v4, v11);
      unsigned int v9 = v4 + v11;
      v4 += v11;
      if (v5) {
        unsigned int v10 = -1;
      }
      else {
        unsigned int v10 = v9;
      }
      if (v10 >= a3) {
        return 1;
      }
    }
  }
  return v4 >= a3;
}

uint64_t nw_frame_array_fill_from_pending_array(void *a1, uint64_t a2, int a3, int a4)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v9, type, &v31)) {
      goto LABEL_35;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v31)
      {
        unsigned int v10 = __nwlog_obj();
        os_log_type_t v11 = type[0];
        if (!os_log_type_enabled(v10, type[0])) {
          goto LABEL_35;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        BOOL v12 = "%{public}s called with null from_array, backtrace limit exceeded";
        goto LABEL_34;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type[0];
      BOOL v14 = os_log_type_enabled(v10, type[0]);
      if (!backtrace_string)
      {
        if (!v14) {
          goto LABEL_35;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        BOOL v12 = "%{public}s called with null from_array, no backtrace";
        goto LABEL_34;
      }
      if (v14)
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        __int16 v15 = "%{public}s called with null from_array, dumping backtrace:%{public}s";
LABEL_24:
        _os_log_impl(&dword_1830D4000, v10, v11, v15, buf, 0x16u);
      }
LABEL_25:
      free(backtrace_string);
      goto LABEL_35;
    }
    unsigned int v10 = __nwlog_obj();
    os_log_type_t v11 = type[0];
    if (!os_log_type_enabled(v10, type[0])) {
      goto LABEL_35;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    BOOL v12 = "%{public}s called with null from_array";
LABEL_34:
    _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
LABEL_35:
    if (v9) {
      free(v9);
    }
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v9, type, &v31)) {
      goto LABEL_35;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type[0];
      if (!os_log_type_enabled(v10, type[0])) {
        goto LABEL_35;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
      BOOL v12 = "%{public}s called with null to_array";
      goto LABEL_34;
    }
    if (!v31)
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type[0];
      if (!os_log_type_enabled(v10, type[0])) {
        goto LABEL_35;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
      BOOL v12 = "%{public}s called with null to_array, backtrace limit exceeded";
      goto LABEL_34;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v10 = __nwlog_obj();
    os_log_type_t v11 = type[0];
    BOOL v16 = os_log_type_enabled(v10, type[0]);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        __int16 v15 = "%{public}s called with null to_array, dumping backtrace:%{public}s";
        goto LABEL_24;
      }
      goto LABEL_25;
    }
    if (!v16) {
      goto LABEL_35;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_frame_array_fill_from_pending_array";
    BOOL v12 = "%{public}s called with null to_array, no backtrace";
    goto LABEL_34;
  }
  uint64_t v5 = *a1;
  if (!*a1) {
    return 0;
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  int v33 = 0;
  *(void *)&buf[16] = 0x2000000000;
  *(void *)os_log_type_t type = 0;
  os_log_type_t v28 = type;
  int v30 = 0;
  uint64_t v29 = 0x2000000000;
  v18[0] = MEMORY[0x1E4F143A8];
  v18[1] = 0x40000000;
  uint64_t v19 = __nw_frame_array_fill_from_pending_array_block_invoke;
  uint64_t v20 = &unk_1E5242878;
  os_log_type_t v21 = buf;
  char v22 = type;
  int v25 = a4;
  int v26 = a3;
  uint64_t v23 = a1;
  uint64_t v24 = a2;
  do
  {
    if (!v5) {
      break;
    }
    uint64_t v6 = *(void *)(v5 + 32);
    char v7 = ((uint64_t (*)(void *))v19)(v18);
    uint64_t v5 = v6;
  }
  while ((v7 & 1) != 0);
  uint64_t v8 = *(unsigned int *)(*(void *)&buf[8] + 24);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v8;
}

uint64_t __nw_frame_array_fill_from_pending_array_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) >= *(_DWORD *)(a1 + 64)) {
    return 0;
  }
  int v4 = *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (a2)
  {
    int v5 = *(_DWORD *)(a2 + 52);
    if (v5) {
      v5 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
    }
    goto LABEL_5;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v29 = "__nw_frame_unclaimed_length";
  char v13 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v13, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v29 = "__nw_frame_unclaimed_length";
        BOOL v16 = "%{public}s called with null frame";
LABEL_37:
        _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
      }
    }
    else
    {
      int v21 = v4;
      if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v23 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v29 = "__nw_frame_unclaimed_length";
            __int16 v30 = 2082;
            char v31 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          int v4 = v21;
          goto LABEL_38;
        }
        int v4 = v21;
        if (v23)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          BOOL v16 = "%{public}s called with null frame, no backtrace";
          goto LABEL_37;
        }
      }
      else
      {
        BOOL v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          BOOL v16 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_37;
        }
      }
    }
  }
LABEL_38:
  if (v13) {
    free(v13);
  }
  int v5 = 0;
LABEL_5:
  if ((v5 + v4) > *(_DWORD *)(a1 + 68)) {
    return 0;
  }
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v29 = "__nw_frame_unclaimed_length";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v17, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          uint64_t v20 = "%{public}s called with null frame";
LABEL_45:
          _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0xCu);
        }
      }
      else if (v26)
      {
        uint64_t v24 = (char *)__nw_create_backtrace_string();
        uint64_t v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v25 = os_log_type_enabled(v18, type);
        if (v24)
        {
          if (v25)
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v29 = "__nw_frame_unclaimed_length";
            __int16 v30 = 2082;
            char v31 = v24;
            _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v24);
          goto LABEL_46;
        }
        if (v25)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          uint64_t v20 = "%{public}s called with null frame, no backtrace";
          goto LABEL_45;
        }
      }
      else
      {
        uint64_t v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v29 = "__nw_frame_unclaimed_length";
          uint64_t v20 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_45;
        }
      }
    }
LABEL_46:
    if (v17) {
      free(v17);
    }
    int v7 = 0;
    goto LABEL_10;
  }
  int v7 = *(_DWORD *)(a2 + 52);
  if (v7) {
    v7 -= *(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60);
  }
LABEL_10:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v7;
  uint64_t v8 = (void *)(a2 + 32);
  uint64_t v9 = *(void *)(a2 + 32);
  if (v9)
  {
    *(void *)(v9 + 40) = *(void *)(a2 + 40);
    unsigned int v10 = *(void **)(a2 + 40);
  }
  else
  {
    unsigned int v10 = *(void **)(a2 + 40);
    *(void *)(*(void *)(a1 + 48) + _Block_object_dispose(&a9, 8) = v10;
  }
  *unsigned int v10 = v9;
  void *v8 = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v11 = *(void *)(a1 + 56);
  BOOL v12 = *(void **)(v11 + 8);
  *(void *)(a2 + 40) = v12;
  *BOOL v12 = a2;
  *(void *)(v11 + _Block_object_dispose(&a9, 8) = v8;
  return 1;
}

uint64_t nw_frame_get_ecn_flag(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(unsigned char *)(a1 + 186) & 3;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v11 = "nw_frame_get_ecn_flag";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v11 = "nw_frame_get_ecn_flag";
        int v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v11 = "nw_frame_get_ecn_flag";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v11 = "nw_frame_get_ecn_flag";
        int v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v11 = "nw_frame_get_ecn_flag";
        int v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_frame_set_ecn_flag(uint64_t a1, char a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(unsigned char *)(a1 + 186) = *(unsigned char *)(a1 + 186) & 0xFC | a2 & 3;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v11 = "nw_frame_set_ecn_flag";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v11 = "nw_frame_set_ecn_flag";
      int v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }
    if (!v8)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v11 = "nw_frame_set_ecn_flag";
      int v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v11 = "nw_frame_set_ecn_flag";
        __int16 v12 = 2082;
        char v13 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v7)
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v11 = "nw_frame_set_ecn_flag";
      int v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
}

uint64_t nw_frame_split(uint64_t *a1, unsigned int a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v67 = "nw_frame_split";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (__nwlog_fault(v20, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null frame";
LABEL_66:
          os_log_type_t v46 = v21;
          os_log_type_t v47 = v22;
          uint32_t v48 = 12;
LABEL_106:
          _os_log_impl(&dword_1830D4000, v46, v47, v23, buf, v48);
        }
      }
      else if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v53 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (!v53) {
            goto LABEL_38;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2082;
          uint64_t v69 = (uint64_t)backtrace_string;
          char v26 = "%{public}s called with null frame, dumping backtrace:%{public}s";
          goto LABEL_36;
        }
        if (v53)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null frame, no backtrace";
          goto LABEL_66;
        }
      }
      else
      {
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_66;
        }
      }
    }
LABEL_107:
    if (v20) {
      free(v20);
    }
    return 0;
  }
  uint64_t v3 = *a1;
  if (!*a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v67 = "nw_frame_split";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (__nwlog_fault(v20, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null *frame";
          goto LABEL_66;
        }
      }
      else if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v54 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (!v54) {
            goto LABEL_38;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2082;
          uint64_t v69 = (uint64_t)backtrace_string;
          char v26 = "%{public}s called with null *frame, dumping backtrace:%{public}s";
          goto LABEL_36;
        }
        if (v54)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null *frame, no backtrace";
          goto LABEL_66;
        }
      }
      else
      {
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v67 = "nw_frame_split";
          BOOL v23 = "%{public}s called with null *frame, backtrace limit exceeded";
          goto LABEL_66;
        }
      }
    }
    goto LABEL_107;
  }
  if (a2)
  {
    if (!*(void *)(v3 + 112)
      || (*(_WORD *)(v3 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(*a1, *(void *)(v3 + 88))
      || (int v5 = *(_DWORD *)(v3 + 52)) == 0
      || ((uint64_t v6 = *(unsigned int *)(v3 + 56),
           int v7 = *(_DWORD *)(v3 + 60) + v6,
           unsigned int v8 = v5 - v7,
           BOOL v10 = v5 == v7,
           uint64_t v9 = *(void *)(v3 + 112),
           !v10)
        ? (BOOL v10 = v9 == 0)
        : (BOOL v10 = 1),
          v10))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v67 = "nw_frame_split";
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s there are no unclaimed bytes from which to create a subframe", buf, 0xCu);
      }
      return 0;
    }
    if (v8 > a2)
    {
      uint64_t v16 = v9 + v6;
      if (*(void *)(v3 + 88) == 16435934)
      {
        uint64_t v17 = v3;
      }
      else
      {
        uint64_t v17 = nw_frame_create(16, v16, a2, (uint64_t)__nw_frame_split_finalizer, 16435934);
        uint64_t metadata = nw_frame_get_metadata(v17);
        if (!metadata)
        {
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v17;
          uint64_t v20 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v64 = 0;
          if (!__nwlog_fault(v20, &type, &v64)) {
            goto LABEL_107;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            id v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (!os_log_type_enabled(v40, type)) {
              goto LABEL_107;
            }
LABEL_52:
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v67 = "nw_frame_split";
            __int16 v68 = 2048;
            uint64_t v69 = v17;
            BOOL v23 = "%{public}s frame %p has no split metadata";
LABEL_104:
            os_log_type_t v46 = v40;
            os_log_type_t v47 = v41;
            goto LABEL_105;
          }
          if (v64)
          {
            __int16 v49 = (char *)__nw_create_backtrace_string();
            id v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            BOOL v50 = os_log_type_enabled(v40, type);
            if (v49)
            {
              if (v50) {
                goto LABEL_82;
              }
              goto LABEL_83;
            }
            if (!v50) {
              goto LABEL_107;
            }
LABEL_103:
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v67 = "nw_frame_split";
            __int16 v68 = 2048;
            uint64_t v69 = v17;
            BOOL v23 = "%{public}s frame %p has no split metadata, no backtrace";
            goto LABEL_104;
          }
          id v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          if (!os_log_type_enabled(v40, type)) {
            goto LABEL_107;
          }
LABEL_87:
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v17;
          BOOL v23 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
          goto LABEL_104;
        }
        *(void *)uint64_t metadata = v3;
        *(unsigned char *)(metadata + _Block_object_dispose(&a9, 8) = 3;
        nw_frame_inherit_metadata(v3, v17, 1);
        if (gLogDatapath)
        {
          os_log_type_t v19 = __nwlog_obj();
          if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)long long buf = 136446722;
            os_log_type_t v67 = "nw_frame_split";
            __int16 v68 = 2048;
            uint64_t v69 = v17;
            __int16 v70 = 2048;
            *(void *)__int16 v71 = v3;
            _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s inserted top of tree split frame %p with parent %p", buf, 0x20u);
          }
        }
      }
      uint64_t v12 = nw_frame_create(16, v16, a2, (uint64_t)__nw_frame_split_finalizer, 16435934);
      uint64_t v30 = nw_frame_create(16, v16 + a2, v8 - a2, (uint64_t)__nw_frame_split_finalizer, 16435934);
      nw_frame_inherit_metadata(v17, v12, 0);
      nw_frame_inherit_metadata(v17, v30, 1);
      uint64_t v31 = nw_frame_get_metadata(v12);
      if (v31)
      {
        uint64_t v32 = v31;
        uint64_t v33 = nw_frame_get_metadata(v30);
        if (v33)
        {
          uint64_t v34 = v33;
          uint64_t v35 = nw_frame_get_metadata(v17);
          if (v35)
          {
            *(unsigned char *)(v32 + _Block_object_dispose(&a9, 8) = 1;
            *(unsigned char *)(v34 + _Block_object_dispose(&a9, 8) = 2;
            *(void *)uint64_t v32 = v17;
            *(void *)uint64_t v34 = v17;
            *(unsigned char *)(v35 + 9) |= 3u;
            if (gLogDatapath)
            {
              BOOL v62 = __nwlog_obj();
              if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v63 = *a1;
                *(_DWORD *)long long buf = 136447746;
                os_log_type_t v67 = "nw_frame_split";
                __int16 v68 = 2048;
                uint64_t v69 = v63;
                __int16 v70 = 1024;
                *(_DWORD *)__int16 v71 = v8;
                *(_WORD *)&v71[4] = 2048;
                *(void *)&v71[6] = v12;
                __int16 v72 = 1024;
                unsigned int v73 = a2;
                __int16 v74 = 2048;
                uint64_t v75 = v30;
                __int16 v76 = 1024;
                int v77 = v8 - a2;
                _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEBUG, "%{public}s split frame %p (%u bytes) into start child %p (%u bytes) and end child %p (%u bytes)", buf, 0x3Cu);
              }
            }
            *a1 = v30;
            return v12;
          }
          __nwlog_obj();
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v17;
          uint64_t v20 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v64 = 0;
          if (!__nwlog_fault(v20, &type, &v64)) {
            goto LABEL_107;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            id v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (!os_log_type_enabled(v40, type)) {
              goto LABEL_107;
            }
            goto LABEL_52;
          }
          if (v64)
          {
            __int16 v49 = (char *)__nw_create_backtrace_string();
            id v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            BOOL v52 = os_log_type_enabled(v40, type);
            if (v49)
            {
              if (v52)
              {
LABEL_82:
                *(_DWORD *)long long buf = 136446722;
                os_log_type_t v67 = "nw_frame_split";
                __int16 v68 = 2048;
                uint64_t v69 = v17;
                __int16 v70 = 2082;
                *(void *)__int16 v71 = v49;
                _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s", buf, 0x20u);
              }
LABEL_83:
              free(v49);
              goto LABEL_107;
            }
            if (!v52) {
              goto LABEL_107;
            }
            goto LABEL_103;
          }
          id v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          if (!os_log_type_enabled(v40, type)) {
            goto LABEL_107;
          }
          goto LABEL_87;
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v67 = "nw_frame_split";
        __int16 v68 = 2048;
        uint64_t v69 = v30;
        uint64_t v20 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v64 = 0;
        if (!__nwlog_fault(v20, &type, &v64)) {
          goto LABEL_107;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          id v42 = __nwlog_obj();
          os_log_type_t v43 = type;
          if (!os_log_type_enabled(v42, type)) {
            goto LABEL_107;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v30;
          BOOL v23 = "%{public}s frame %p has no split metadata";
LABEL_99:
          os_log_type_t v46 = v42;
          os_log_type_t v47 = v43;
LABEL_105:
          uint32_t v48 = 22;
          goto LABEL_106;
        }
        if (!v64)
        {
          id v42 = __nwlog_obj();
          os_log_type_t v43 = type;
          if (!os_log_type_enabled(v42, type)) {
            goto LABEL_107;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v30;
          BOOL v23 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
          goto LABEL_99;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        BOOL v51 = os_log_type_enabled(v42, type);
        if (!backtrace_string)
        {
          if (!v51) {
            goto LABEL_107;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v30;
          BOOL v23 = "%{public}s frame %p has no split metadata, no backtrace";
          goto LABEL_99;
        }
        if (v51)
        {
          *(_DWORD *)long long buf = 136446722;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v30;
          __int16 v70 = 2082;
          *(void *)__int16 v71 = backtrace_string;
          char v26 = "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s";
          char v27 = v42;
          os_log_type_t v28 = v43;
          uint32_t v29 = 32;
          goto LABEL_37;
        }
LABEL_38:
        free(backtrace_string);
        goto LABEL_107;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446466;
      os_log_type_t v67 = "nw_frame_split";
      __int16 v68 = 2048;
      uint64_t v69 = v12;
      BOOL v36 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v64 = 0;
      if (__nwlog_fault(v36, &type, &v64))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v37 = __nwlog_obj();
          os_log_type_t v38 = type;
          if (!os_log_type_enabled(v37, type)) {
            goto LABEL_91;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v12;
          id v39 = "%{public}s frame %p has no split metadata";
          goto LABEL_90;
        }
        if (!v64)
        {
          uint64_t v37 = __nwlog_obj();
          os_log_type_t v38 = type;
          if (!os_log_type_enabled(v37, type)) {
            goto LABEL_91;
          }
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v12;
          id v39 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
          goto LABEL_90;
        }
        uint64_t v44 = (char *)__nw_create_backtrace_string();
        uint64_t v37 = __nwlog_obj();
        os_log_type_t v38 = type;
        BOOL v45 = os_log_type_enabled(v37, type);
        if (v44)
        {
          if (v45)
          {
            *(_DWORD *)long long buf = 136446722;
            os_log_type_t v67 = "nw_frame_split";
            __int16 v68 = 2048;
            uint64_t v69 = v12;
            __int16 v70 = 2082;
            *(void *)__int16 v71 = v44;
            _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v44);
          goto LABEL_91;
        }
        if (v45)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "nw_frame_split";
          __int16 v68 = 2048;
          uint64_t v69 = v12;
          id v39 = "%{public}s frame %p has no split metadata, no backtrace";
LABEL_90:
          _os_log_impl(&dword_1830D4000, v37, v38, v39, buf, 0x16u);
        }
      }
LABEL_91:
      if (v36) {
        free(v36);
      }
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v67 = "nw_frame_split";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (!__nwlog_fault(v20, &type, &v64)) {
      goto LABEL_107;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v21 = gLogObj;
      os_log_type_t v22 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_107;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v67 = "nw_frame_split";
      BOOL v23 = "%{public}s split_offset is beyond the unclaimed region of the frame";
      goto LABEL_66;
    }
    if (!v64)
    {
      int v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_107;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v67 = "nw_frame_split";
      BOOL v23 = "%{public}s split_offset is beyond the unclaimed region of the frame, backtrace limit exceeded";
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v25 = os_log_type_enabled(v21, type);
    if (!backtrace_string)
    {
      if (!v25) {
        goto LABEL_107;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v67 = "nw_frame_split";
      BOOL v23 = "%{public}s split_offset is beyond the unclaimed region of the frame, no backtrace";
      goto LABEL_66;
    }
    if (!v25) {
      goto LABEL_38;
    }
    *(_DWORD *)long long buf = 136446466;
    os_log_type_t v67 = "nw_frame_split";
    __int16 v68 = 2082;
    uint64_t v69 = (uint64_t)backtrace_string;
    char v26 = "%{public}s split_offset is beyond the unclaimed region of the frame, dumping backtrace:%{public}s";
LABEL_36:
    char v27 = v21;
    os_log_type_t v28 = v22;
    uint32_t v29 = 22;
LABEL_37:
    _os_log_impl(&dword_1830D4000, v27, v28, v26, buf, v29);
    goto LABEL_38;
  }
  uint64_t v12 = nw_frame_create(0, 0, 0, (uint64_t)__nw_frame_empty_finalizer, 16435934);
  if (!v12)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v67 = "__nw_frame_create_empty_frame_with_original";
    uint64_t v55 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (!__nwlog_fault(v55, &type, &v64)) {
      goto LABEL_149;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_149;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v67 = "__nw_frame_create_empty_frame_with_original";
      uint64_t v58 = "%{public}s called with null empty_frame";
    }
    else if (v64)
    {
      BOOL v60 = (char *)__nw_create_backtrace_string();
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      BOOL v61 = os_log_type_enabled(v56, type);
      if (v60)
      {
        if (v61)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v67 = "__nw_frame_create_empty_frame_with_original";
          __int16 v68 = 2082;
          uint64_t v69 = (uint64_t)v60;
          _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null empty_frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v60);
        goto LABEL_149;
      }
      if (!v61)
      {
LABEL_149:
        if (v55) {
          free(v55);
        }
        goto LABEL_19;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v67 = "__nw_frame_create_empty_frame_with_original";
      uint64_t v58 = "%{public}s called with null empty_frame, no backtrace";
    }
    else
    {
      uint64_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (!os_log_type_enabled(v56, type)) {
        goto LABEL_149;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v67 = "__nw_frame_create_empty_frame_with_original";
      uint64_t v58 = "%{public}s called with null empty_frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v56, v57, v58, buf, 0xCu);
    goto LABEL_149;
  }
  nw_frame_inherit_metadata(v3, v12, 0);
  if (gLogDatapath)
  {
    os_log_type_t v59 = __nwlog_obj();
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446722;
      os_log_type_t v67 = "__nw_frame_create_empty_frame_with_original";
      __int16 v68 = 2048;
      uint64_t v69 = v12;
      __int16 v70 = 2048;
      *(void *)__int16 v71 = v3;
      _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_DEBUG, "%{public}s created empty frame %p from original frame %p", buf, 0x20u);
    }
  }
LABEL_19:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v13 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v14 = *a1;
    *(_DWORD *)long long buf = 136446722;
    os_log_type_t v67 = "nw_frame_split";
    __int16 v68 = 2048;
    uint64_t v69 = v12;
    __int16 v70 = 2048;
    *(void *)__int16 v71 = v14;
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s split_offset of 0 passed, created empty frame %p from %p", buf, 0x20u);
  }
  return v12;
}

void __nw_frame_split_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v50 = "__nw_frame_split_finalizer";
    uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (__nwlog_fault(v3, &type, &v47))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s called with null frame";
          goto LABEL_56;
        }
      }
      else if (v47)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v42 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v42)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v50 = "__nw_frame_split_finalizer";
            __int16 v51 = 2082;
            uint64_t v52 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v42)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_56;
        }
      }
      else
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_56;
        }
      }
    }
    goto LABEL_59;
  }
  if (a3 != (void *)16435934)
  {
    if (a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)long long buf = 136446210;
      BOOL v50 = "__nw_frame_split_finalizer";
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (!__nwlog_fault(v3, &type, &v47)) {
        goto LABEL_59;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v4 = gLogObj;
        os_log_type_t v5 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s trying to finalize non-split frame";
          goto LABEL_56;
        }
        goto LABEL_59;
      }
      if (!v47)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v4 = gLogObj;
        os_log_type_t v5 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s trying to finalize non-split frame, backtrace limit exceeded";
          goto LABEL_56;
        }
        goto LABEL_59;
      }
      uint64_t v18 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v19 = gLogObj;
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (!v18)
      {
        if (v21)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s trying to finalize non-split frame, no backtrace";
          BOOL v25 = v19;
          os_log_type_t v26 = v20;
          goto LABEL_57;
        }
        goto LABEL_59;
      }
      if (v21)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2082;
        uint64_t v52 = (uint64_t)v18;
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s trying to finalize non-split frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v18);
      if (!v3) {
        return;
      }
LABEL_60:
      os_log_type_t v28 = (char *)v3;
LABEL_139:
      free(v28);
      return;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v50 = "__nw_frame_split_finalizer";
    uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v3, &type, &v47)) {
      goto LABEL_59;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s called with null context";
        goto LABEL_56;
      }
      goto LABEL_59;
    }
    if (!v47)
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s called with null context, backtrace limit exceeded";
        goto LABEL_56;
      }
      goto LABEL_59;
    }
    uint64_t v33 = (char *)__nw_create_backtrace_string();
    os_log_type_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v43 = os_log_type_enabled(v4, type);
    if (!v33)
    {
      if (v43)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s called with null context, no backtrace";
        goto LABEL_56;
      }
      goto LABEL_59;
    }
    if (v43)
    {
      *(_DWORD *)long long buf = 136446466;
      BOOL v50 = "__nw_frame_split_finalizer";
      __int16 v51 = 2082;
      uint64_t v52 = (uint64_t)v33;
      uint64_t v35 = "%{public}s called with null context, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
LABEL_132:
    free(v33);
    if (v3) {
      goto LABEL_60;
    }
    return;
  }
  int v7 = a1;
  LOBYTE(v_Block_object_dispose(&a9, 8) = *((_WORD *)a1 + 102);
  if ((*((_WORD *)a1 + 102) & 4) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446466;
    BOOL v50 = "__nw_frame_split_finalizer";
    __int16 v51 = 2048;
    uint64_t v52 = (uint64_t)v7;
    uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v9, &type, &v47)) {
      goto LABEL_137;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = gLogObj;
      os_log_type_t v11 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_137;
      }
      goto LABEL_12;
    }
    if (v47)
    {
      BOOL v23 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = gLogObj;
      os_log_type_t v11 = type;
      BOOL v24 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v23)
      {
        if (v24)
        {
          *(_DWORD *)long long buf = 136446722;
          BOOL v50 = "__nw_frame_split_finalizer";
          __int16 v51 = 2048;
          uint64_t v52 = (uint64_t)v7;
          __int16 v53 = 2082;
          uint64_t v54 = (uint64_t)v23;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v23);
LABEL_137:
        if (!v9) {
          return;
        }
LABEL_138:
        os_log_type_t v28 = (char *)v9;
        goto LABEL_139;
      }
      if (!v24) {
        goto LABEL_137;
      }
      goto LABEL_135;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v10 = gLogObj;
    os_log_type_t v11 = type;
    if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
      goto LABEL_137;
    }
    goto LABEL_64;
  }
  if ((*((unsigned char *)a1 + 217) & 4) != 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v22 = __nwlog_obj();
      if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2048;
        uint64_t v52 = (uint64_t)v7;
        _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s frame %p processed in loop, stopping", buf, 0x16u);
      }
    }
    return;
  }
  while (1)
  {
    if ((v8 & 4) != 0) {
      char v13 = (char *)v7 + 208;
    }
    else {
      char v13 = 0;
    }
    if ((v8 & 4) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)long long buf = 136446466;
      BOOL v50 = "__nw_frame_split_finalizer";
      __int16 v51 = 2048;
      uint64_t v52 = (uint64_t)v7;
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (!__nwlog_fault(v9, &type, &v47)) {
        goto LABEL_137;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (!os_log_type_enabled(v10, type)) {
          goto LABEL_137;
        }
LABEL_12:
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2048;
        uint64_t v52 = (uint64_t)v7;
        uint64_t v12 = "%{public}s frame %p has no split metadata";
LABEL_136:
        _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0x16u);
        goto LABEL_137;
      }
      if (v47)
      {
        uint64_t v31 = (char *)__nw_create_backtrace_string();
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v32 = os_log_type_enabled(v10, type);
        if (v31)
        {
          if (v32)
          {
            *(_DWORD *)long long buf = 136446722;
            BOOL v50 = "__nw_frame_split_finalizer";
            __int16 v51 = 2048;
            uint64_t v52 = (uint64_t)v7;
            __int16 v53 = 2082;
            uint64_t v54 = (uint64_t)v31;
            _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v31);
          if (!v9) {
            return;
          }
          goto LABEL_138;
        }
        if (!v32) {
          goto LABEL_137;
        }
LABEL_135:
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2048;
        uint64_t v52 = (uint64_t)v7;
        uint64_t v12 = "%{public}s frame %p has no split metadata, no backtrace";
        goto LABEL_136;
      }
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_137;
      }
LABEL_64:
      *(_DWORD *)long long buf = 136446466;
      BOOL v50 = "__nw_frame_split_finalizer";
      __int16 v51 = 2048;
      uint64_t v52 = (uint64_t)v7;
      uint64_t v12 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
      goto LABEL_136;
    }
    uint64_t v14 = *(void *)v13;
    if (!*(void *)v13)
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      BOOL v50 = "__nw_frame_split_finalizer";
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (!__nwlog_fault(v3, &type, &v47)) {
        goto LABEL_59;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s called with null parent_frame";
          goto LABEL_56;
        }
        goto LABEL_59;
      }
      if (!v47)
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, type))
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s called with null parent_frame, backtrace limit exceeded";
          goto LABEL_56;
        }
        goto LABEL_59;
      }
      uint64_t v33 = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v44 = os_log_type_enabled(v4, type);
      if (!v33)
      {
        if (v44)
        {
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s called with null parent_frame, no backtrace";
          goto LABEL_56;
        }
        goto LABEL_59;
      }
      if (v44)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2082;
        uint64_t v52 = (uint64_t)v33;
        uint64_t v35 = "%{public}s called with null parent_frame, dumping backtrace:%{public}s";
        goto LABEL_131;
      }
      goto LABEL_132;
    }
    if (gLogDatapath)
    {
      os_log_t log = __nwlog_obj();
      if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446722;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2048;
        uint64_t v52 = (uint64_t)v7;
        __int16 v53 = 2048;
        uint64_t v54 = v14;
        _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s processing finalize for frame %p with parent_frame %p", buf, 0x20u);
      }
    }
    int v15 = v13[8];
    if (!v13[8])
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      BOOL v50 = "__nw_frame_split_finalizer";
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (!__nwlog_fault(v3, &type, &v47)) {
        goto LABEL_59;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s processing finalize for split frame that isn't a child";
        goto LABEL_56;
      }
      if (v47)
      {
        uint64_t v33 = (char *)__nw_create_backtrace_string();
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v34 = os_log_type_enabled(v4, type);
        if (v33)
        {
          if (!v34) {
            goto LABEL_132;
          }
          *(_DWORD *)long long buf = 136446466;
          BOOL v50 = "__nw_frame_split_finalizer";
          __int16 v51 = 2082;
          uint64_t v52 = (uint64_t)v33;
          uint64_t v35 = "%{public}s processing finalize for split frame that isn't a child, dumping backtrace:%{public}s";
          goto LABEL_131;
        }
        if (!v34) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s processing finalize for split frame that isn't a child, no backtrace";
      }
      else
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s processing finalize for split frame that isn't a child, backtrace limit exceeded";
      }
LABEL_56:
      BOOL v25 = v4;
      os_log_type_t v26 = v5;
LABEL_57:
      uint32_t v27 = 12;
LABEL_58:
      _os_log_impl(&dword_1830D4000, v25, v26, v6, buf, v27);
LABEL_59:
      if (v3) {
        goto LABEL_60;
      }
      return;
    }
    if (v15 == 3)
    {
      if (gLogDatapath)
      {
        BOOL v45 = __nwlog_obj();
        if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446722;
          BOOL v50 = "__nw_frame_split_finalizer";
          __int16 v51 = 2048;
          uint64_t v52 = (uint64_t)v7;
          __int16 v53 = 2048;
          uint64_t v54 = v14;
          _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_DEBUG, "%{public}s finalizing top of tree frame %p, finalizing parent immediately (%p)", buf, 0x20u);
        }
      }
      nw_frame_finalize(v14);
      if ((v13[9] & 4) != 0) {
        nw_frame_finalize((uint64_t)v7);
      }
      nw_frame_reset((uint64_t)v7, 0, 0, 0, 0);
      os_release(v7);
      return;
    }
    if (*(void *)(v14 + 88) != 16435934)
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      BOOL v50 = "__nw_frame_split_finalizer";
      uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v47 = 0;
      if (!__nwlog_fault(v3, &type, &v47)) {
        goto LABEL_59;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s processing finalize for split frame that has parent missing sentinel";
        goto LABEL_56;
      }
      if (!v47)
      {
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (!os_log_type_enabled(v4, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s processing finalize for split frame that has parent missing sentinel, backtrace limit exceeded";
        goto LABEL_56;
      }
      uint64_t v33 = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v36 = os_log_type_enabled(v4, type);
      if (!v33)
      {
        if (!v36) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v6 = "%{public}s processing finalize for split frame that has parent missing sentinel, no backtrace";
        goto LABEL_56;
      }
      if (!v36) {
        goto LABEL_132;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v50 = "__nw_frame_split_finalizer";
      __int16 v51 = 2082;
      uint64_t v52 = (uint64_t)v33;
      uint64_t v35 = "%{public}s processing finalize for split frame that has parent missing sentinel, dumping backtrace:%{public}s";
      goto LABEL_131;
    }
    if ((*(_WORD *)(v14 + 204) & 4) == 0) {
      break;
    }
    if (v15 == 2)
    {
      if ((*(unsigned char *)(v14 + 217) & 2) == 0)
      {
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (!__nwlog_fault(v3, &type, &v47)) {
          goto LABEL_59;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (!os_log_type_enabled(v4, type)) {
            goto LABEL_59;
          }
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s parent frame is not waiting for our end child finalizer";
          goto LABEL_56;
        }
        if (!v47)
        {
          os_log_type_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, type))
          {
            *(_DWORD *)long long buf = 136446210;
            BOOL v50 = "__nw_frame_split_finalizer";
            uint64_t v6 = "%{public}s parent frame is not waiting for our end child finalizer, backtrace limit exceeded";
            goto LABEL_56;
          }
          goto LABEL_59;
        }
        uint64_t v33 = (char *)__nw_create_backtrace_string();
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v40 = os_log_type_enabled(v4, type);
        if (!v33)
        {
          if (v40)
          {
            *(_DWORD *)long long buf = 136446210;
            BOOL v50 = "__nw_frame_split_finalizer";
            uint64_t v6 = "%{public}s parent frame is not waiting for our end child finalizer, no backtrace";
            goto LABEL_56;
          }
          goto LABEL_59;
        }
        if (!v40) {
          goto LABEL_132;
        }
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2082;
        uint64_t v52 = (uint64_t)v33;
        uint64_t v35 = "%{public}s parent frame is not waiting for our end child finalizer, dumping backtrace:%{public}s";
        goto LABEL_131;
      }
      char v16 = *(unsigned char *)(v14 + 217) & 0xFD;
    }
    else
    {
      if (v15 != 1) {
        goto LABEL_31;
      }
      if ((*(unsigned char *)(v14 + 217) & 1) == 0)
      {
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        BOOL v50 = "__nw_frame_split_finalizer";
        uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (!__nwlog_fault(v3, &type, &v47)) {
          goto LABEL_59;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (!os_log_type_enabled(v4, type)) {
            goto LABEL_59;
          }
          *(_DWORD *)long long buf = 136446210;
          BOOL v50 = "__nw_frame_split_finalizer";
          uint64_t v6 = "%{public}s parent frame is not waiting for our start child finalizer";
          goto LABEL_56;
        }
        if (!v47)
        {
          os_log_type_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, type))
          {
            *(_DWORD *)long long buf = 136446210;
            BOOL v50 = "__nw_frame_split_finalizer";
            uint64_t v6 = "%{public}s parent frame is not waiting for our start child finalizer, backtrace limit exceeded";
            goto LABEL_56;
          }
          goto LABEL_59;
        }
        uint64_t v33 = (char *)__nw_create_backtrace_string();
        os_log_type_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v39 = os_log_type_enabled(v4, type);
        if (!v33)
        {
          if (v39)
          {
            *(_DWORD *)long long buf = 136446210;
            BOOL v50 = "__nw_frame_split_finalizer";
            uint64_t v6 = "%{public}s parent frame is not waiting for our start child finalizer, no backtrace";
            goto LABEL_56;
          }
          goto LABEL_59;
        }
        if (!v39) {
          goto LABEL_132;
        }
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2082;
        uint64_t v52 = (uint64_t)v33;
        uint64_t v35 = "%{public}s parent frame is not waiting for our start child finalizer, dumping backtrace:%{public}s";
LABEL_131:
        _os_log_impl(&dword_1830D4000, v4, v5, v35, buf, 0x16u);
        goto LABEL_132;
      }
      char v16 = *(unsigned char *)(v14 + 217) & 0xFE;
    }
    *(unsigned char *)(v14 + 217) = v16;
LABEL_31:
    *(void *)char v13 = 0;
    if ((v13[9] & 4) != 0) {
      nw_frame_finalize((uint64_t)v7);
    }
    nw_frame_reset((uint64_t)v7, 0, 0, 0, 0);
    os_release(v7);
    if ((*(unsigned char *)(v14 + 217) & 3) != 0) {
      return;
    }
    if (gLogDatapath)
    {
      uint64_t v17 = __nwlog_obj();
      if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v50 = "__nw_frame_split_finalizer";
        __int16 v51 = 2048;
        uint64_t v52 = v14;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s continuing to parent frame %p because both children have been finalized", buf, 0x16u);
      }
    }
    *(unsigned char *)(v14 + 217) |= 4u;
    __int16 v8 = *(_WORD *)(v14 + 204);
    int v7 = (nw_frame *)v14;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446466;
  BOOL v50 = "__nw_frame_split_finalizer";
  __int16 v51 = 2048;
  uint64_t v52 = v14;
  uint64_t v3 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v47 = 0;
  if (!__nwlog_fault(v3, &type, &v47)) {
    goto LABEL_59;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint32_t v29 = __nwlog_obj();
    os_log_type_t v30 = type;
    if (!os_log_type_enabled(v29, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)long long buf = 136446466;
    BOOL v50 = "__nw_frame_split_finalizer";
    __int16 v51 = 2048;
    uint64_t v52 = v14;
    uint64_t v6 = "%{public}s frame %p has no split metadata";
LABEL_147:
    BOOL v25 = v29;
    os_log_type_t v26 = v30;
    uint32_t v27 = 22;
    goto LABEL_58;
  }
  if (!v47)
  {
    uint32_t v29 = __nwlog_obj();
    os_log_type_t v30 = type;
    if (!os_log_type_enabled(v29, type)) {
      goto LABEL_59;
    }
    *(_DWORD *)long long buf = 136446466;
    BOOL v50 = "__nw_frame_split_finalizer";
    __int16 v51 = 2048;
    uint64_t v52 = v14;
    uint64_t v6 = "%{public}s frame %p has no split metadata, backtrace limit exceeded";
    goto LABEL_147;
  }
  uint64_t v37 = (char *)__nw_create_backtrace_string();
  uint32_t v29 = __nwlog_obj();
  os_log_type_t v30 = type;
  BOOL v38 = os_log_type_enabled(v29, type);
  if (!v37)
  {
    if (!v38) {
      goto LABEL_59;
    }
    *(_DWORD *)long long buf = 136446466;
    BOOL v50 = "__nw_frame_split_finalizer";
    __int16 v51 = 2048;
    uint64_t v52 = v14;
    uint64_t v6 = "%{public}s frame %p has no split metadata, no backtrace";
    goto LABEL_147;
  }
  if (v38)
  {
    *(_DWORD *)long long buf = 136446722;
    BOOL v50 = "__nw_frame_split_finalizer";
    __int16 v51 = 2048;
    uint64_t v52 = v14;
    __int16 v53 = 2082;
    uint64_t v54 = (uint64_t)v37;
    _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s frame %p has no split metadata, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v37);
  if (v3) {
    goto LABEL_60;
  }
}

void __nw_frame_empty_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v22 = "__nw_frame_empty_finalizer";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v3, &type, &v19)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v22 = "__nw_frame_empty_finalizer";
      uint64_t v6 = "%{public}s called with null frame";
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v15 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v22 = "__nw_frame_empty_finalizer";
          __int16 v23 = 2082;
          BOOL v24 = (nw_frame *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v15) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v22 = "__nw_frame_empty_finalizer";
      uint64_t v6 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v22 = "__nw_frame_empty_finalizer";
      uint64_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_18:
    uint64_t v12 = v4;
    os_log_type_t v13 = v5;
LABEL_19:
    _os_log_impl(&dword_1830D4000, v12, v13, v6, buf, 0xCu);
    goto LABEL_20;
  }
  if (a3 == (void *)16435934)
  {
    if (gLogDatapath)
    {
      char v16 = __nwlog_obj();
      if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v22 = "__nw_frame_empty_finalizer";
        __int16 v23 = 2048;
        BOOL v24 = a1;
        _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s finalizing empty frame %p", buf, 0x16u);
      }
    }
    nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
    os_release(a1);
    return;
  }
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v22 = "__nw_frame_empty_finalizer";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v3, &type, &v19)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v4 = gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v22 = "__nw_frame_empty_finalizer";
      uint64_t v6 = "%{public}s trying to finalize non-split frame";
      goto LABEL_18;
    }
    if (!v19)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v4 = gLogObj;
      os_log_type_t v5 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v22 = "__nw_frame_empty_finalizer";
      uint64_t v6 = "%{public}s trying to finalize non-split frame, backtrace limit exceeded";
      goto LABEL_18;
    }
    __int16 v8 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = gLogObj;
    os_log_type_t v10 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v8)
    {
      if (v11)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v22 = "__nw_frame_empty_finalizer";
        __int16 v23 = 2082;
        BOOL v24 = (nw_frame *)v8;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s trying to finalize non-split frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v8);
      if (!v3) {
        return;
      }
LABEL_21:
      free(v3);
      return;
    }
    if (v11)
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v22 = "__nw_frame_empty_finalizer";
      uint64_t v6 = "%{public}s trying to finalize non-split frame, no backtrace";
      uint64_t v12 = v9;
      os_log_type_t v13 = v10;
      goto LABEL_19;
    }
LABEL_20:
    if (!v3) {
      return;
    }
    goto LABEL_21;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v22 = "__nw_frame_empty_finalizer";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v3, &type, &v19)) {
    goto LABEL_20;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_20;
    }
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v22 = "__nw_frame_empty_finalizer";
    uint64_t v6 = "%{public}s called with null context";
    goto LABEL_18;
  }
  if (!v19)
  {
    os_log_type_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_20;
    }
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v22 = "__nw_frame_empty_finalizer";
    uint64_t v6 = "%{public}s called with null context, backtrace limit exceeded";
    goto LABEL_18;
  }
  uint64_t v17 = (char *)__nw_create_backtrace_string();
  os_log_type_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v18 = os_log_type_enabled(v4, type);
  if (!v17)
  {
    if (!v18) {
      goto LABEL_20;
    }
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v22 = "__nw_frame_empty_finalizer";
    uint64_t v6 = "%{public}s called with null context, no backtrace";
    goto LABEL_18;
  }
  if (v18)
  {
    *(_DWORD *)long long buf = 136446466;
    os_log_type_t v22 = "__nw_frame_empty_finalizer";
    __int16 v23 = 2082;
    BOOL v24 = (nw_frame *)v17;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v17);
  if (v3) {
    goto LABEL_21;
  }
}

void __nw_frame_custom_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  buffer = (void *)nw_frame_get_buffer((uint64_t)a1, 0);
  if (buffer) {
    free(buffer);
  }
  nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
  if (a1)
  {
    os_release(a1);
  }
}

uint64_t nw_frame_get_tso_segment_size(uint64_t a1, BOOL *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *a2 = (*(unsigned char *)(a1 + 206) & 2) != 0;
      return *(unsigned __int16 *)(a1 + 198);
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v14 = "__nw_frame_get_tso_segment_size";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null tso_ipv6";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null tso_ipv6, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null tso_ipv6, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v14 = "__nw_frame_get_tso_segment_size";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      uint64_t v9 = "%{public}s called with null tso_ipv6, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v14 = "__nw_frame_get_tso_segment_size";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      os_log_type_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v14 = "__nw_frame_get_tso_segment_size";
        uint64_t v6 = "%{public}s called with null frame, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v14 = "__nw_frame_get_tso_segment_size";
      __int16 v15 = 2082;
      char v16 = backtrace_string;
      uint64_t v9 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  os_log_type_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)long long buf = 136446210;
    uint64_t v14 = "__nw_frame_get_tso_segment_size";
    uint64_t v6 = "%{public}s called with null frame";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3) {
    free(v3);
  }
  return 0;
}

void nw_frame_set_tso_segment_size(uint64_t a1, __int16 a2, int a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v4 = *(unsigned __int16 *)(a1 + 204);
    uint64_t v3 = a1 + 204;
    *(_WORD *)(v3 - 6) = a2;
    int v5 = v4 | (*(unsigned __int8 *)(v3 + 2) << 16);
    if (a3) {
      int v6 = 0x20000;
    }
    else {
      int v6 = 0;
    }
    unsigned int v7 = v5 & 0xFFFDFFFF;
    *(_WORD *)uint64_t v3 = v7;
    *(unsigned char *)(v3 + 2) = (v7 | v6) >> 16;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "__nw_frame_set_tso_segment_size";
  BOOL v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v8, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v17 = "__nw_frame_set_tso_segment_size";
      char v11 = "%{public}s called with null frame";
      goto LABEL_20;
    }
    if (!v14)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v17 = "__nw_frame_set_tso_segment_size";
      char v11 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_20;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v17 = "__nw_frame_set_tso_segment_size";
        __int16 v18 = 2082;
        char v19 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_21;
    }
    if (v13)
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v17 = "__nw_frame_set_tso_segment_size";
      char v11 = "%{public}s called with null frame, no backtrace";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
    }
  }
LABEL_21:
  if (v8) {
    free(v8);
  }
}

uint64_t NWPBAddressEndpointReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int)*MEMORY[0x1E4F940E8];
  unint64_t v5 = *(void *)(a2 + v4);
  int v6 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v7 = *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]);
  BOOL v8 = (int *)MEMORY[0x1E4F940C8];
  if (v5 < v7)
  {
    os_log_type_t v10 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      BOOL v13 = (unsigned char *)(a2 + *v8);
      if (*v13) {
        return *(unsigned char *)(a2 + *v8) == 0;
      }
      if (v5 >= v7) {
        break;
      }
      char v14 = *(unsigned char *)(*(void *)(a2 + *v10) + v5);
      *(void *)(a2 + (int)v4) = v5 + 1;
      unint64_t v15 = v14 & 0x7F;
      if ((v14 & 0x80) == 0) {
        goto LABEL_39;
      }
      uint64_t v16 = *v3;
      unint64_t v17 = *(void *)(a2 + v16);
      if (v17 == -1 || v17 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v18 = v17 + 1;
      int v19 = *(char *)(*(void *)(a2 + *v10) + v17);
      *(void *)(a2 + v16) = v18;
      v15 |= (unint64_t)(v19 & 0x7F) << 7;
      if ((v19 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v20 = *v3;
      unint64_t v21 = *(void *)(a2 + v20);
      if (v21 == -1 || v21 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v22 = v21 + 1;
      int v23 = *(char *)(*(void *)(a2 + *v10) + v21);
      *(void *)(a2 + v20) = v22;
      v15 |= (unint64_t)(v23 & 0x7F) << 14;
      if ((v23 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v24 = *v3;
      unint64_t v25 = *(void *)(a2 + v24);
      if (v25 == -1 || v25 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v26 = v25 + 1;
      int v27 = *(char *)(*(void *)(a2 + *v10) + v25);
      *(void *)(a2 + v24) = v26;
      v15 |= (unint64_t)(v27 & 0x7F) << 21;
      if ((v27 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v28 = *v3;
      unint64_t v29 = *(void *)(a2 + v28);
      if (v29 == -1 || v29 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v30 = v29 + 1;
      int v31 = *(char *)(*(void *)(a2 + *v10) + v29);
      *(void *)(a2 + v2_Block_object_dispose(&a9, 8) = v30;
      v15 |= (unint64_t)(v31 & 0x7F) << 28;
      if ((v31 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v32 = *v3;
      unint64_t v33 = *(void *)(a2 + v32);
      if (v33 == -1 || v33 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v34 = v33 + 1;
      int v35 = *(char *)(*(void *)(a2 + *v10) + v33);
      *(void *)(a2 + v32) = v34;
      if ((v35 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v36 = *v3;
      unint64_t v37 = *(void *)(a2 + v36);
      if (v37 == -1 || v37 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v38 = v37 + 1;
      int v39 = *(char *)(*(void *)(a2 + *v10) + v37);
      *(void *)(a2 + v36) = v38;
      if ((v39 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v40 = *v3;
      unint64_t v41 = *(void *)(a2 + v40);
      if (v41 == -1 || v41 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v42 = v41 + 1;
      int v43 = *(char *)(*(void *)(a2 + *v10) + v41);
      *(void *)(a2 + v40) = v42;
      if ((v43 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v44 = *v3;
      unint64_t v45 = *(void *)(a2 + v44);
      if (v45 == -1 || v45 >= *(void *)(a2 + *v6)) {
        goto LABEL_37;
      }
      unint64_t v46 = v45 + 1;
      int v47 = *(char *)(*(void *)(a2 + *v10) + v45);
      *(void *)(a2 + v44) = v46;
      if ((v47 & 0x80000000) == 0) {
        goto LABEL_39;
      }
      uint64_t v48 = *v3;
      unint64_t v49 = *(void *)(a2 + v48);
      if (v49 == -1 || v49 >= *(void *)(a2 + *v6))
      {
LABEL_37:
        BOOL v13 = (unsigned char *)(a2 + *v8);
        goto LABEL_38;
      }
      unint64_t v50 = v49 + 1;
      int v51 = *(char *)(*(void *)(a2 + *v10) + v49);
      *(void *)(a2 + v4_Block_object_dispose(&a9, 8) = v50;
      if (v51 < 0)
      {
        unint64_t v15 = 0;
        int v52 = *(unsigned __int8 *)(a2 + *v8);
        goto LABEL_41;
      }
LABEL_39:
      int v52 = *(unsigned __int8 *)(a2 + *v8);
      if (*(unsigned char *)(a2 + *v8)) {
        unint64_t v15 = 0;
      }
LABEL_41:
      if (v52) {
        BOOL v53 = 1;
      }
      else {
        BOOL v53 = (v15 & 7) == 4;
      }
      if (v53) {
        return *(unsigned char *)(a2 + *v8) == 0;
      }
      if ((v15 >> 3) == 1)
      {
        uint64_t v11 = PBReaderReadData();
        uint64_t v12 = *(void **)(a1 + 8);
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = v11;
      }
      else
      {
        uint64_t result = PBReaderSkipValueWithTag();
        if (!result) {
          return result;
        }
      }
      uint64_t v4 = *v3;
      unint64_t v5 = *(void *)(a2 + v4);
      unint64_t v7 = *(void *)(a2 + *v6);
      if (v5 >= v7) {
        return *(unsigned char *)(a2 + *v8) == 0;
      }
    }
    unint64_t v15 = 0;
LABEL_38:
    *BOOL v13 = 1;
    goto LABEL_39;
  }
  return *(unsigned char *)(a2 + *v8) == 0;
}

uint64_t llhttp__internal__run(uint64_t a1, unsigned __int8 *a2, unsigned __int8 *a3)
{
  uint64_t result = *(unsigned int *)(a1 + 56);
  switch((int)result)
  {
    case 1:
      goto LABEL_1917;
    case 2:
      goto LABEL_1910;
    case 3:
      goto LABEL_1931;
    case 4:
      goto LABEL_1930;
    case 5:
      goto LABEL_1933;
    case 6:
      goto LABEL_1653;
    case 7:
      goto LABEL_1646;
    case 8:
      goto LABEL_1640;
    case 9:
      goto LABEL_1638;
    case 10:
      goto LABEL_1637;
    case 11:
      goto LABEL_1630;
    case 12:
      goto LABEL_1492;
    case 13:
LABEL_1489:
      uint64_t v433 = *(void *)(a1 + 88);
      if (!v433 || (v434 = *(uint64_t (**)(uint64_t))(v433 + 144)) == 0 || (int v435 = v434(a1)) == 0)
      {
LABEL_1492:
        if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
        {
          uint64_t result = 0;
          *(_DWORD *)(a1 + 24) = 25;
          unint64_t v7 = "Missing expected CR after chunk extension name";
          goto LABEL_2263;
        }
        goto LABEL_1630;
      }
      if (v435 == 21)
      {
        uint64_t result = 0;
        *(_DWORD *)(a1 + 24) = 21;
        *(void *)(a1 + 32) = "on_chunk_extension_name pause";
        *(void *)(a1 + 40) = a2;
        *(void *)(a1 + 56) = 12;
        return result;
      }
      goto LABEL_1579;
    case 14:
      goto LABEL_1498;
    case 15:
      goto LABEL_1507;
    case 16:
      goto LABEL_1629;
    case 17:
LABEL_1530:
      uint64_t v463 = *(void *)(a1 + 88);
      if (!v463) {
        goto LABEL_1629;
      }
      v464 = *(uint64_t (**)(uint64_t))(v463 + 152);
      if (!v464) {
        goto LABEL_1629;
      }
      int v465 = v464(a1);
      if (!v465) {
        goto LABEL_1629;
      }
      if (v465 != 21) {
        goto LABEL_1687;
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = 21;
      *(void *)(a1 + 32) = "on_chunk_extension_value pause";
      *(void *)(a1 + 40) = a2;
      *(void *)(a1 + 56) = 16;
      return result;
    case 18:
      goto LABEL_1539;
    case 19:
      goto LABEL_1624;
    case 20:
      goto LABEL_1621;
    case 21:
      goto LABEL_1694;
    case 22:
      goto LABEL_1610;
    case 23:
      goto LABEL_1671;
    case 24:
      while (2)
      {
        if (a2 == a3) {
          return 24;
        }
        uint64_t result = 24;
        while (1)
        {
          int v497 = llhttp__internal__run_lookup_table_3[*a2];
          if (v497 != 1) {
            break;
          }
          if (++a2 == a3) {
            return result;
          }
        }
        if (v497 != 2)
        {
          if (v497 == 3)
          {
            ++a2;
LABEL_1610:
            if (a2 == a3) {
              return 22;
            }
            if (llhttp__internal__run_lookup_table_14[*a2] == 1)
            {
LABEL_1601:
              ++a2;
              continue;
            }
            uint64_t v498 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
            uint64_t v499 = *(void *)(a1 + 88);
            if (v499)
            {
              v500 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v499 + 64);
              if (v500)
              {
                int v501 = v500(a1, v498, &a2[-v498]);
                if (v501)
                {
                  int v502 = v501;
                  if (v501 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v502 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v502;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 21;
                  return result;
                }
              }
            }
            ++a2;
LABEL_1694:
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 2;
            unint64_t v7 = "Invalid quoted-pair in chunk extensions quoted value";
          }
          else
          {
            uint64_t v525 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
            uint64_t v526 = *(void *)(a1 + 88);
            if (v526)
            {
              v527 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v526 + 64);
              if (v527)
              {
                int v528 = v527(a1, v525, &a2[-v525]);
                if (v528)
                {
                  int v529 = v528;
                  if (v528 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v529 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v529;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 23;
                  return result;
                }
              }
            }
            ++a2;
LABEL_1671:
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 2;
            unint64_t v7 = "Invalid character in chunk extensions quoted value";
          }
          goto LABEL_2263;
        }
        break;
      }
      ++a2;
      uint64_t v503 = *(void *)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
      uint64_t v504 = *(void *)(a1 + 88);
      if (v504)
      {
        v505 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v504 + 64);
        if (v505)
        {
          int v506 = v505(a1, v503, &a2[-v503]);
          if (v506)
          {
            int v531 = v506;
            if (v506 == -1)
            {
              *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
              int v531 = 24;
            }
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = v531;
            *(void *)(a1 + 40) = a2;
            *(void *)(a1 + 56) = 20;
            return result;
          }
        }
      }
LABEL_1621:
      uint64_t v507 = *(void *)(a1 + 88);
      if (v507 && (v508 = *(uint64_t (**)(uint64_t))(v507 + 152)) != 0 && (int v509 = v508(a1)) != 0)
      {
        if (v509 == 21)
        {
          uint64_t result = 0;
          *(_DWORD *)(a1 + 24) = 21;
          *(void *)(a1 + 32) = "on_chunk_extension_value pause";
          *(void *)(a1 + 40) = a2;
          *(void *)(a1 + 56) = 19;
          return result;
        }
      }
      else
      {
LABEL_1624:
        if (a2 == a3) {
          return 19;
        }
        int v510 = *a2;
        if (v510 == 10)
        {
LABEL_1629:
          if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 25;
            unint64_t v7 = "Missing expected CR after chunk extension value";
            goto LABEL_2263;
          }
          goto LABEL_1630;
        }
        if (v510 != 59)
        {
          if (v510 != 13)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 2;
            unint64_t v7 = "Invalid character in chunk extensions quote value";
            goto LABEL_2263;
          }
LABEL_1628:
          ++a2;
LABEL_1630:
          if (a2 == a3) {
            return 11;
          }
          if (*a2 == 10)
          {
            ++a2;
          }
          else if ((*(_WORD *)(a1 + 78) & 0x40) == 0)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 2;
            unint64_t v7 = "Expected LF after chunk size";
            goto LABEL_2263;
          }
          uint64_t v511 = *(void *)(a1 + 88);
          if (v511)
          {
            v512 = *(uint64_t (**)(uint64_t))(v511 + 160);
            if (v512)
            {
              int v513 = v512(a1);
              if (v513)
              {
                if (v513 != 21)
                {
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 19;
                  goto LABEL_2263;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = 21;
                *(void *)(a1 + 32) = "on_chunk_header pause";
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 10;
                return result;
              }
            }
          }
LABEL_1637:
          if (!*(void *)(a1 + 64))
          {
            *(_WORD *)(a1 + 82) |= 0x80u;
            goto LABEL_1938;
          }
LABEL_1638:
          if (a2 == a3) {
            return 9;
          }
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
          *(void *)(a1 + 16) = llhttp__on_body;
LABEL_1640:
          unint64_t v514 = *(void *)(a1 + 64);
          unint64_t v515 = v514 - (a3 - a2);
          if (v514 < a3 - a2) {
            unint64_t v515 = 0;
          }
          *(void *)(a1 + 64) = v515;
          if (a3 - a2 < v514) {
            return 8;
          }
          a2 += v514;
          uint64_t v516 = *(void *)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
          uint64_t v517 = *(void *)(a1 + 88);
          if (v517)
          {
            v518 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v517 + 80);
            if (v518)
            {
              int v519 = v518(a1, v516, &a2[-v516]);
              if (v519)
              {
                int v530 = v519;
                if (v519 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_body";
                  int v530 = 24;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = v530;
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 7;
                return result;
              }
            }
          }
LABEL_1646:
          if (a2 == a3) {
            return 7;
          }
          int v520 = *a2;
          if (v520 == 13)
          {
            ++a2;
LABEL_1653:
            if (a2 == a3) {
              return 6;
            }
            if (*a2 == 10)
            {
              ++a2;
LABEL_1657:
              int v521 = 0;
              uint64_t v522 = *(void *)(a1 + 88);
              if (v522)
              {
                int v521 = 0;
                v523 = *(uint64_t (**)(uint64_t))(v522 + 168);
                if (v523) {
                  int v521 = v523(a1);
                }
              }
              if (v521)
              {
                if (v521 == 21)
                {
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 21;
                  *(void *)(a1 + 32) = "on_chunk_complete pause";
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 36;
                  return result;
                }
                goto LABEL_2150;
              }
LABEL_1661:
              *(void *)(a1 + 64) = 0;
LABEL_1662:
              if (a2 == a3) {
                return 35;
              }
              uint64_t v524 = 0;
              switch(*a2)
              {
                case '0':
                  break;
                case '1':
LABEL_2212:
                  uint64_t v524 = 1;
                  break;
                case '2':
LABEL_2213:
                  uint64_t v524 = 2;
                  break;
                case '3':
LABEL_2214:
                  uint64_t v524 = 3;
                  break;
                case '4':
LABEL_2215:
                  uint64_t v524 = 4;
                  break;
                case '5':
LABEL_2216:
                  uint64_t v524 = 5;
                  break;
                case '6':
LABEL_2217:
                  uint64_t v524 = 6;
                  break;
                case '7':
LABEL_2218:
                  uint64_t v524 = 7;
                  break;
                case '8':
LABEL_2219:
                  uint64_t v524 = 8;
                  break;
                case '9':
LABEL_2220:
                  uint64_t v524 = 9;
                  break;
                case 'A':
                case 'a':
LABEL_2206:
                  uint64_t v524 = 10;
                  break;
                case 'B':
                case 'b':
LABEL_2207:
                  uint64_t v524 = 11;
                  break;
                case 'C':
                case 'c':
LABEL_2208:
                  uint64_t v524 = 12;
                  break;
                case 'D':
                case 'd':
LABEL_2209:
                  uint64_t v524 = 13;
                  break;
                case 'E':
                case 'e':
LABEL_2210:
                  uint64_t v524 = 14;
                  break;
                case 'F':
                case 'f':
LABEL_2211:
                  uint64_t v524 = 15;
                  break;
                default:
LABEL_2201:
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 12;
                  unint64_t v7 = "Invalid character in chunk size";
                  goto LABEL_2263;
              }
              while (2)
              {
                ++a2;
                unint64_t v686 = *(void *)(a1 + 64);
                if (!(v686 >> 60))
                {
                  *(void *)(a1 + 64) = v524 | (16 * v686);
LABEL_2204:
                  if (a2 != a3)
                  {
                    uint64_t v524 = 0;
                    switch(*a2)
                    {
                      case '0':
                        continue;
                      case '1':
                        goto LABEL_2212;
                      case '2':
                        goto LABEL_2213;
                      case '3':
                        goto LABEL_2214;
                      case '4':
                        goto LABEL_2215;
                      case '5':
                        goto LABEL_2216;
                      case '6':
                        goto LABEL_2217;
                      case '7':
                        goto LABEL_2218;
                      case '8':
                        goto LABEL_2219;
                      case '9':
                        goto LABEL_2220;
                      case 'A':
                      case 'a':
                        goto LABEL_2206;
                      case 'B':
                      case 'b':
                        goto LABEL_2207;
                      case 'C':
                      case 'c':
                        goto LABEL_2208;
                      case 'D':
                      case 'd':
                        goto LABEL_2209;
                      case 'E':
                      case 'e':
                        goto LABEL_2210;
                      case 'F':
                      case 'f':
                        goto LABEL_2211;
                      default:
                        goto LABEL_2198;
                    }
                  }
                  return 34;
                }
                break;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 12;
              unint64_t v7 = "Chunk size overflow";
LABEL_2263:
              *(void *)(a1 + 32) = v7;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 0;
              return result;
            }
          }
          else if (v520 == 10)
          {
            ++a2;
            if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 25;
              unint64_t v7 = "Missing expected CR after chunk data";
              goto LABEL_2263;
            }
            goto LABEL_1657;
          }
          if ((*(_WORD *)(a1 + 78) & 0x80) == 0)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 2;
            unint64_t v7 = "Expected LF after chunk data";
            goto LABEL_2263;
          }
          goto LABEL_1657;
        }
LABEL_2189:
        ++a2;
LABEL_2190:
        while (2)
        {
          if (a2 == a3) {
            return 32;
          }
          int v685 = *a2;
          if (v685 == 32 || v685 == 13)
          {
            uint64_t result = 0;
            v319 = a2 + 1;
            *(_DWORD *)(a1 + 24) = 2;
            v321 = "Invalid character in chunk extensions";
            goto LABEL_2194;
          }
LABEL_2187:
          if (a2 == a3) {
            return 31;
          }
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
          *(void *)(a1 + 16) = llhttp__on_chunk_extension_name;
LABEL_1480:
          if (a2 == a3) {
            return 30;
          }
          uint64_t result = 30;
          while (llhttp__internal__run_lookup_table_7[*a2] == 3)
          {
            if (++a2 == a3) {
              return result;
            }
          }
          switch(*a2)
          {
            case 0xAu:
              uint64_t v429 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v430 = *(void *)(a1 + 88);
              if (!v430) {
                goto LABEL_1489;
              }
              v431 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v430 + 56);
              if (!v431) {
                goto LABEL_1489;
              }
              int v432 = v431(a1, v429, &a2[-v429]);
              if (!v432) {
                goto LABEL_1489;
              }
              int v490 = v432;
              if (v432 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                int v490 = 24;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = v490;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 13;
              return result;
            case 0xDu:
              uint64_t v436 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v437 = *(void *)(a1 + 88);
              if (v437)
              {
                v438 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v437 + 56);
                if (v438)
                {
                  int v439 = v438(a1, v436, &a2[-v436]);
                  if (v439)
                  {
                    int v491 = v439;
                    if (v439 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                      int v491 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v491;
                    *(void *)(a1 + 40) = a2 + 1;
                    *(void *)(a1 + 56) = 14;
                    return result;
                  }
                }
              }
              ++a2;
LABEL_1498:
              uint64_t v440 = *(void *)(a1 + 88);
              if (!v440) {
                goto LABEL_1630;
              }
              v441 = *(uint64_t (**)(uint64_t))(v440 + 144);
              if (!v441) {
                goto LABEL_1630;
              }
              int v442 = v441(a1);
              if (!v442) {
                goto LABEL_1630;
              }
              if (v442 != 21) {
                goto LABEL_1579;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 21;
              v443 = "on_chunk_extension_name pause";
              goto LABEL_1544;
            case 0x3Bu:
              uint64_t v444 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v445 = *(void *)(a1 + 88);
              if (v445)
              {
                v446 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v445 + 56);
                if (v446)
                {
                  int v447 = v446(a1, v444, &a2[-v444]);
                  if (v447)
                  {
                    int v492 = v447;
                    if (v447 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                      int v492 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v492;
                    *(void *)(a1 + 40) = a2 + 1;
                    *(void *)(a1 + 56) = 15;
                    return result;
                  }
                }
              }
              ++a2;
LABEL_1507:
              int v448 = 0;
              uint64_t v449 = *(void *)(a1 + 88);
              if (v449)
              {
                int v448 = 0;
                v450 = *(uint64_t (**)(uint64_t))(v449 + 144);
                if (v450) {
                  int v448 = v450(a1);
                }
              }
              if (!v448) {
                continue;
              }
              if (v448 != 21) {
                goto LABEL_1579;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 21;
              v451 = "on_chunk_extension_name pause";
              goto LABEL_1555;
            case 0x3Du:
              uint64_t v452 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v453 = *(void *)(a1 + 88);
              if (v453)
              {
                v454 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v453 + 56);
                if (v454)
                {
                  int v455 = v454(a1, v452, &a2[-v452]);
                  if (v455)
                  {
                    int v493 = v455;
                    if (v455 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                      int v493 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v493;
                    *(void *)(a1 + 40) = a2 + 1;
                    *(void *)(a1 + 56) = 28;
                    return result;
                  }
                }
              }
              ++a2;
LABEL_1517:
              if (a2 == a3) {
                return 28;
              }
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
              *(void *)(a1 + 16) = llhttp__on_chunk_extension_value;
              uint64_t v456 = *(void *)(a1 + 88);
              if (v456)
              {
                v457 = *(uint64_t (**)(uint64_t))(v456 + 144);
                if (v457)
                {
                  int v458 = v457(a1);
                  if (v458)
                  {
                    if (v458 == 21)
                    {
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = 21;
                      *(void *)(a1 + 32) = "on_chunk_extension_name pause";
                      *(void *)(a1 + 40) = a2;
                      *(void *)(a1 + 56) = 27;
                      return result;
                    }
LABEL_1579:
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = 34;
                    goto LABEL_2263;
                  }
                }
              }
LABEL_1521:
              if (a2 == a3) {
                return 27;
              }
              uint64_t result = 27;
              while (llhttp__internal__run_lookup_table_5[*a2] == 3)
              {
                if (++a2 == a3) {
                  return result;
                }
              }
              switch((unint64_t)*a2)
              {
                case 0xAuLL:
                case 0x10AuLL:
                  uint64_t v459 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                  uint64_t v460 = *(void *)(a1 + 88);
                  if (!v460) {
                    goto LABEL_1530;
                  }
                  v461 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v460 + 64);
                  if (!v461) {
                    goto LABEL_1530;
                  }
                  int v462 = v461(a1, v459, &a2[-v459]);
                  if (!v462) {
                    goto LABEL_1530;
                  }
                  int v494 = v462;
                  if (v462 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v494 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v494;
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 17;
                  return result;
                case 0xDuLL:
                case 0x10DuLL:
                  uint64_t v466 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                  uint64_t v467 = *(void *)(a1 + 88);
                  if (v467)
                  {
                    v468 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v467 + 64);
                    if (v468)
                    {
                      int v469 = v468(a1, v466, &a2[-v466]);
                      if (v469)
                      {
                        int v495 = v469;
                        if (v469 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                          int v495 = 24;
                        }
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = v495;
                        *(void *)(a1 + 40) = a2 + 1;
                        *(void *)(a1 + 56) = 18;
                        return result;
                      }
                    }
                  }
                  ++a2;
LABEL_1539:
                  uint64_t v470 = *(void *)(a1 + 88);
                  if (!v470) {
                    goto LABEL_1630;
                  }
                  v471 = *(uint64_t (**)(uint64_t))(v470 + 152);
                  if (!v471) {
                    goto LABEL_1630;
                  }
                  int v472 = v471(a1);
                  if (!v472) {
                    goto LABEL_1630;
                  }
                  if (v472 == 21)
                  {
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = 21;
                    v443 = "on_chunk_extension_value pause";
LABEL_1544:
                    *(void *)(a1 + 32) = v443;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 11;
                    return result;
                  }
                  goto LABEL_1687;
                case 0x22uLL:
                case 0x13BuLL:
                  goto LABEL_1601;
                case 0x3BuLL:
                case 0x13DuLL:
                  uint64_t v473 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                  uint64_t v474 = *(void *)(a1 + 88);
                  if (v474)
                  {
                    v475 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v474 + 64);
                    if (v475)
                    {
                      int v476 = v475(a1, v473, &a2[-v473]);
                      if (v476)
                      {
                        int v496 = v476;
                        if (v476 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                          int v496 = 24;
                        }
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = v496;
                        *(void *)(a1 + 40) = a2 + 1;
                        *(void *)(a1 + 56) = 25;
                        return result;
                      }
                    }
                  }
                  ++a2;
LABEL_1549:
                  int v477 = 0;
                  uint64_t v478 = *(void *)(a1 + 88);
                  if (v478)
                  {
                    int v477 = 0;
                    v479 = *(uint64_t (**)(uint64_t))(v478 + 152);
                    if (v479) {
                      int v477 = v479(a1);
                    }
                  }
                  if (!v477) {
                    continue;
                  }
                  if (v477 == 21)
                  {
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = 21;
                    v451 = "on_chunk_extension_value pause";
LABEL_1555:
                    *(void *)(a1 + 32) = v451;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 32;
                    return result;
                  }
                  break;
                default:
                  uint64_t v485 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                  uint64_t v486 = *(void *)(a1 + 88);
                  if (!v486
                    || (v487 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v486 + 64)) == 0
                    || (int v488 = v487(a1, v485, &a2[-v485])) == 0)
                  {
                    ++a2;
                    goto LABEL_1571;
                  }
                  int v489 = v488;
                  if (v488 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_value";
                    int v489 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v489;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 26;
                  return result;
              }
              break;
            default:
              uint64_t v480 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v481 = *(void *)(a1 + 88);
              if (!v481
                || (v482 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v481 + 56)) == 0
                || (int v483 = v482(a1, v480, &a2[-v480])) == 0)
              {
                ++a2;
                goto LABEL_1569;
              }
              int v484 = v483;
              if (v483 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_chunk_extension_name";
                int v484 = 24;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = v484;
              *(void *)(a1 + 40) = a2 + 1;
              *(void *)(a1 + 56) = 29;
              return result;
          }
          break;
        }
      }
LABEL_1687:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = 35;
      goto LABEL_2263;
    case 25:
      goto LABEL_1549;
    case 26:
LABEL_1571:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = 2;
      unint64_t v7 = "Invalid character in chunk extensions value";
      goto LABEL_2263;
    case 27:
      goto LABEL_1521;
    case 28:
      goto LABEL_1517;
    case 29:
LABEL_1569:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = 2;
      unint64_t v7 = "Invalid character in chunk extensions name";
      goto LABEL_2263;
    case 30:
      goto LABEL_1480;
    case 31:
      goto LABEL_2187;
    case 32:
      goto LABEL_2190;
    case 33:
LABEL_2198:
      while (2)
      {
        if (a2 == a3) {
          return 33;
        }
        switch(*a2)
        {
          case 9u:
          case 0x20u:
            ++a2;
            if ((*(_WORD *)(a1 + 78) & 0x200) != 0) {
              continue;
            }
            goto LABEL_2201;
          case 0xAu:
            ++a2;
            if ((*(_WORD *)(a1 + 78) & 0x100) != 0) {
              goto LABEL_1630;
            }
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 25;
            unint64_t v7 = "Missing expected CR after chunk size";
            break;
          case 0xBu:
          case 0xCu:
          case 0xEu:
          case 0xFu:
          case 0x10u:
          case 0x11u:
          case 0x12u:
          case 0x13u:
          case 0x14u:
          case 0x15u:
          case 0x16u:
          case 0x17u:
          case 0x18u:
          case 0x19u:
          case 0x1Au:
          case 0x1Bu:
          case 0x1Cu:
          case 0x1Du:
          case 0x1Eu:
          case 0x1Fu:
            goto LABEL_2201;
          case 0xDu:
            goto LABEL_1628;
          default:
            if (*a2 != 59) {
              goto LABEL_2201;
            }
            goto LABEL_2189;
        }
        goto LABEL_2263;
      }
    case 34:
      goto LABEL_2204;
    case 35:
      goto LABEL_1662;
    case 36:
      goto LABEL_1661;
    case 37:
      goto LABEL_2134;
    case 38:
LABEL_2132:
      if (a2 == a3) {
        return 38;
      }
      *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
      *(void *)(a1 + 16) = llhttp__on_body;
LABEL_2134:
      unint64_t v666 = *(void *)(a1 + 64);
      unint64_t v667 = v666 - (a3 - a2);
      if (v666 < a3 - a2) {
        unint64_t v667 = 0;
      }
      *(void *)(a1 + 64) = v667;
      if (a3 - a2 < v666) {
        return 37;
      }
      a2 += v666;
      uint64_t v668 = *(void *)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
      uint64_t v669 = *(void *)(a1 + 88);
      if (!v669) {
        goto LABEL_1933;
      }
      v670 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v669 + 80);
      if (!v670) {
        goto LABEL_1933;
      }
      int v671 = v670(a1, v668, &a2[-v668]);
      if (!v671) {
        goto LABEL_1933;
      }
      int v672 = v671;
      if (v671 == -1)
      {
        *(void *)(a1 + 32) = "Span callback error in on_body";
        int v672 = 24;
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = v672;
      goto LABEL_2143;
    case 39:
      return result;
    case 40:
LABEL_2173:
      if (a2 == a3) {
        return 40;
      }
      *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
      *(void *)(a1 + 16) = llhttp__on_body;
      return 39;
    case 41:
      goto LABEL_2131;
    case 42:
      goto LABEL_2184;
    case 43:
      goto LABEL_2017;
    case 44:
      goto LABEL_2111;
    case 45:
      goto LABEL_2225;
    case 46:
      goto LABEL_2233;
    case 47:
      goto LABEL_2242;
    case 48:
LABEL_2255:
      while (2)
      {
        if (a2 == a3) {
          return 48;
        }
        int v696 = *a2;
        if (v696 == 13)
        {
          ++a2;
          if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
            goto LABEL_1772;
          }
          continue;
        }
        break;
      }
      if (v696 == 10)
      {
        ++a2;
LABEL_2242:
        if (a2 == a3) {
          return 47;
        }
      }
      else if ((*(_WORD *)(a1 + 78) & 1) == 0)
      {
        goto LABEL_1772;
      }
      int v694 = *a2;
      if (v694 != 9 && v694 != 32)
      {
        __int16 v695 = 1;
        switch(*(unsigned char *)(a1 + 76))
        {
          case 2:
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 11;
            unint64_t v7 = "Empty Content-Length";
            goto LABEL_2263;
          case 5:
            goto LABEL_2266;
          case 6:
            __int16 v695 = 2;
            goto LABEL_2266;
          case 7:
            __int16 v695 = 4;
LABEL_2266:
            *(_WORD *)(a1 + 82) |= v695;
            *(unsigned char *)(a1 + 76) = 1;
            break;
          case 8:
            *(_WORD *)(a1 + 82) |= 8u;
            break;
          default:
            break;
        }
LABEL_2233:
        if (a2 == a3) {
          return 46;
        }
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
        *(void *)(a1 + 16) = llhttp__on_header_value;
        uint64_t v690 = *(void *)(a1 + 88);
        if (v690)
        {
          v691 = *(uint64_t (**)(uint64_t, unsigned __int8 *, void))(v690 + 48);
          if (v691)
          {
            int v692 = v691(a1, a2, 0);
            if (v692)
            {
              int v693 = v692;
              if (v692 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_header_value";
                int v693 = 24;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = v693;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 45;
              return result;
            }
          }
        }
        goto LABEL_2225;
      }
      ++a2;
      if (*(_WORD *)(a1 + 78)) {
        goto LABEL_2248;
      }
      goto LABEL_2262;
    case 49:
      goto LABEL_1775;
    case 50:
      goto LABEL_1769;
    case 51:
    case 52:
      goto LABEL_1768;
    case 53:
      goto LABEL_1760;
    case 54:
      goto LABEL_2262;
    case 55:
      goto LABEL_1746;
    case 56:
      goto LABEL_2342;
    case 57:
      goto LABEL_1889;
    case 58:
      goto LABEL_2306;
    case 59:
      goto LABEL_2325;
    case 60:
      goto LABEL_2287;
    case 61:
LABEL_2273:
      while (2)
      {
        uint64_t result = 61;
        if (a2 == a3) {
          return result;
        }
        while (2)
        {
          int v698 = *a2;
          if ((v698 - 65) < 0x1A) {
            v698 |= 0x20u;
          }
          if (v698 <= 31)
          {
            if (v698 != 9) {
              goto LABEL_2342;
            }
            goto LABEL_2276;
          }
          if (v698 <= 98)
          {
            if (v698 != 32) {
              goto LABEL_2342;
            }
LABEL_2276:
            if (++a2 == a3) {
              return result;
            }
            continue;
          }
          break;
        }
        if (v698 != 99)
        {
          if (v698 != 107)
          {
            if (v698 != 117) {
              goto LABEL_2342;
            }
            ++a2;
LABEL_2287:
            if (a2 == a3) {
              return 60;
            }
            int v699 = 0;
            unsigned int v700 = *(_DWORD *)a1;
            while (1)
            {
              int v701 = *a2;
              if ((v701 - 65) < 0x1A) {
                v701 |= 0x20u;
              }
              int v702 = llparse_blob4[v700];
              if (v700 == 5)
              {
                int v699 = 0;
                int v703 = 5;
              }
              else
              {
                int v703 = 0;
              }
              if (v701 != v702)
              {
                int v699 = 2;
                int v703 = 5;
              }
              if (v703) {
                break;
              }
              if (v701 == v702) {
                ++v700;
              }
              if (++a2 == a3)
              {
                int v699 = 1;
                a2 = a3;
                *(_DWORD *)a1 = v700;
                goto LABEL_2302;
              }
            }
            *(_DWORD *)a1 = 0;
LABEL_2302:
            char v704 = 7;
            if (v699)
            {
              if (v699 == 2) {
                goto LABEL_2342;
              }
              return 60;
            }
            goto LABEL_1888;
          }
          ++a2;
LABEL_2325:
          if (a2 == a3) {
            return 59;
          }
          int v710 = 0;
          unsigned int v711 = *(_DWORD *)a1;
          while (1)
          {
            int v712 = *a2;
            if ((v712 - 65) < 0x1A) {
              v712 |= 0x20u;
            }
            int v713 = llparse_blob3[v711];
            if (v711 == 8)
            {
              int v710 = 0;
              int v714 = 5;
            }
            else
            {
              int v714 = 0;
            }
            if (v712 != v713)
            {
              int v710 = 2;
              int v714 = 5;
            }
            if (v714) {
              break;
            }
            if (v712 == v713) {
              ++v711;
            }
            if (++a2 == a3)
            {
              int v710 = 1;
              a2 = a3;
              *(_DWORD *)a1 = v711;
              goto LABEL_2340;
            }
          }
          *(_DWORD *)a1 = 0;
LABEL_2340:
          char v704 = 5;
          if (v710)
          {
            if (v710 == 2) {
              goto LABEL_2342;
            }
            return 59;
          }
LABEL_1888:
          ++a2;
          *(unsigned char *)(a1 + 76) = v704;
LABEL_1889:
          uint64_t result = 57;
          if (a2 == a3) {
            return result;
          }
          while (1)
          {
            int v598 = *a2;
            if (v598 != 32) {
              break;
            }
            if (++a2 == a3) {
              return result;
            }
          }
          if (v598 != 10 && v598 != 13)
          {
            if (v598 == 44)
            {
              ++a2;
              __int16 v600 = 1;
              switch(*(unsigned char *)(a1 + 76))
              {
                case 5:
                  goto LABEL_1902;
                case 6:
                  __int16 v600 = 2;
                  goto LABEL_1902;
                case 7:
                  __int16 v600 = 4;
LABEL_1902:
                  *(_WORD *)(a1 + 82) |= v600;
                  *(unsigned char *)(a1 + 76) = 1;
                  break;
                case 8:
                  *(_WORD *)(a1 + 82) |= 8u;
                  break;
                default:
                  continue;
              }
              continue;
            }
            *(unsigned char *)(a1 + 76) = 0;
LABEL_2342:
            if (a2 == a3) {
              return 56;
            }
            uint64_t result = 56;
            while (1)
            {
              int v697 = llhttp__internal__run_lookup_table_15[*a2];
              if (v697 != 1) {
                break;
              }
              if (++a2 == a3) {
                return result;
              }
            }
            if (v697 == 2)
            {
              ++a2;
              continue;
            }
            goto LABEL_1746;
          }
          while (1)
          {
LABEL_1746:
            if (a2 == a3) {
              return 55;
            }
            int v546 = *a2;
            if (v546 == 10) {
              break;
            }
            if (v546 != 13)
            {
              if ((*(_WORD *)(a1 + 78) & 1) == 0)
              {
                uint64_t v588 = *(void *)(a1 + 8);
                *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                uint64_t v589 = *(void *)(a1 + 88);
                if (v589)
                {
                  v590 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v589 + 48);
                  if (v590)
                  {
                    int v591 = v590(a1, v588, &a2[-v588]);
                    if (v591)
                    {
                      int v592 = v591;
                      if (v591 == -1)
                      {
                        *(void *)(a1 + 32) = "Span callback error in on_header_value";
                        int v592 = 24;
                      }
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = v592;
                      *(void *)(a1 + 40) = a2;
                      *(void *)(a1 + 56) = 54;
                      return result;
                    }
                  }
                }
LABEL_2262:
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = 10;
                unint64_t v7 = "Invalid header value char";
                goto LABEL_2263;
              }
LABEL_1760:
              uint64_t result = 53;
              if (a2 == a3) {
                return result;
              }
              while (1)
              {
                int v556 = *a2;
                if (v556 == 10) {
                  break;
                }
                if (v556 == 13) {
                  goto LABEL_1749;
                }
                if (++a2 == a3) {
                  return result;
                }
              }
              uint64_t v557 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v558 = *(void *)(a1 + 88);
              if (v558)
              {
                v559 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v558 + 48);
                if (v559)
                {
                  int v560 = v559(a1, v557, &a2[-v557]);
                  if (v560)
                  {
                    int v593 = v560;
                    if (v560 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_header_value";
                      int v593 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v593;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 52;
                    return result;
                  }
                }
              }
              goto LABEL_1768;
            }
LABEL_1749:
            uint64_t v547 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
            uint64_t v548 = *(void *)(a1 + 88);
            if (v548)
            {
              v549 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v548 + 48);
              if (v549)
              {
                int v550 = v549(a1, v547, &a2[-v547]);
                if (v550)
                {
                  int v587 = v550;
                  if (v550 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_value";
                    int v587 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v587;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 50;
                  return result;
                }
              }
            }
            ++a2;
            while (1)
            {
LABEL_1769:
              if (a2 == a3) {
                return 50;
              }
              int v561 = *a2;
              if (v561 != 13) {
                break;
              }
              ++a2;
              if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
                goto LABEL_1772;
              }
            }
            if (v561 != 10)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 3;
              unint64_t v7 = "Missing expected LF after header value";
              goto LABEL_2263;
            }
            ++a2;
LABEL_1775:
            if (a2 == a3) {
              return 49;
            }
            int v562 = *a2;
            if (v562 != 9 && v562 != 32)
            {
              __int16 v567 = 1;
              switch(*(unsigned char *)(a1 + 76))
              {
                case 5:
                  goto LABEL_1857;
                case 6:
                  __int16 v567 = 2;
                  goto LABEL_1857;
                case 7:
                  __int16 v567 = 4;
LABEL_1857:
                  *(_WORD *)(a1 + 82) |= v567;
                  *(unsigned char *)(a1 + 76) = 1;
                  break;
                case 8:
                  *(_WORD *)(a1 + 82) |= 8u;
                  break;
                default:
                  break;
              }
LABEL_2225:
              int v687 = 0;
              uint64_t v688 = *(void *)(a1 + 88);
              if (v688)
              {
                int v687 = 0;
                v689 = *(uint64_t (**)(uint64_t))(v688 + 136);
                if (v689) {
                  int v687 = v689(a1);
                }
              }
              if (v687)
              {
                if (v687 == 21)
                {
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 21;
                  *(void *)(a1 + 32) = "on_header_value_complete pause";
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 90;
                  return result;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = 29;
                goto LABEL_2263;
              }
LABEL_1938:
              while (2)
              {
                if (a2 == a3) {
                  return 90;
                }
                int v608 = *a2;
                switch(v608)
                {
                  case 10:
                    ++a2;
                    if ((*(_WORD *)(a1 + 78) & 0x100) == 0) {
                      goto LABEL_2184;
                    }
                    v628 = (_WORD *)(a1 + 82);
                    int v627 = *(unsigned __int16 *)(a1 + 82);
                    if ((v627 & 0x80) == 0)
                    {
                      if ((~v627 & 0x14) != 0)
                      {
                        BOOL v630 = *(unsigned char *)(a1 + 73) == 5;
                        goto LABEL_2123;
                      }
                      char v629 = 1;
                      if (*(unsigned char *)(a1 + 72) != 1)
                      {
                        BOOL v630 = *(unsigned __int16 *)(a1 + 84) == 101;
LABEL_2123:
                        char v629 = v630;
                      }
                      *(unsigned char *)(a1 + 80) = v629;
                      uint64_t v664 = *(void *)(a1 + 88);
                      if (v664)
                      {
                        v665 = *(unsigned int (**)(uint64_t))(v664 + 72);
                        if (v665)
                        {
                          switch(v665(a1))
                          {
                            case 0u:
                              break;
                            case 1u:
                              goto LABEL_2130;
                            case 2u:
LABEL_2129:
                              *(unsigned char *)(a1 + 80) = 1;
LABEL_2130:
                              *v628 |= 0x40u;
                              break;
                            case 0x15u:
LABEL_2186:
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = 21;
                              *(void *)(a1 + 32) = "Paused by on_headers_complete";
                              *(void *)(a1 + 40) = a2;
                              *(void *)(a1 + 56) = 41;
                              return result;
                            default:
LABEL_2185:
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = 17;
                              unint64_t v7 = "User callback error";
                              goto LABEL_2263;
                          }
                        }
                      }
LABEL_2131:
                      switch(llhttp__after_headers_complete(a1))
                      {
                        case 1u:
                          uint64_t v677 = *(void *)(a1 + 88);
                          if (!v677) {
                            goto LABEL_1931;
                          }
                          v678 = *(uint64_t (**)(uint64_t))(v677 + 88);
                          if (!v678) {
                            goto LABEL_1931;
                          }
                          int v679 = v678(a1);
                          if (!v679) {
                            goto LABEL_1931;
                          }
                          if (v679 != 21) {
                            goto LABEL_2171;
                          }
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 21;
                          *(void *)(a1 + 32) = "on_message_complete pause";
                          *(void *)(a1 + 40) = a2;
                          *(void *)(a1 + 56) = 3;
                          return result;
                        case 2u:
                          goto LABEL_1661;
                        case 3u:
                          goto LABEL_2132;
                        case 4u:
                          *(unsigned char *)(a1 + 81) = 1;
                          goto LABEL_2173;
                        case 5u:
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 15;
                          goto LABEL_2263;
                        default:
                          int v673 = 0;
                          uint64_t v674 = *(void *)(a1 + 88);
                          if (v674)
                          {
                            int v673 = 0;
                            v675 = *(uint64_t (**)(uint64_t))(v674 + 88);
                            if (v675) {
                              int v673 = v675(a1);
                            }
                          }
                          if (!v673) {
                            goto LABEL_1910;
                          }
                          if (v673 != 21) {
                            goto LABEL_2171;
                          }
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 21;
                          v604 = "on_message_complete pause";
                          goto LABEL_1932;
                      }
                    }
                    break;
                  case 13:
                    ++a2;
                    while (1)
                    {
LABEL_2017:
                      if (a2 == a3) {
                        return 43;
                      }
                      int v631 = *a2;
                      if (v631 != 13) {
                        break;
                      }
                      ++a2;
                      if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
                        goto LABEL_2020;
                      }
                    }
                    if (v631 == 10)
                    {
                      ++a2;
                    }
                    else if ((*(_WORD *)(a1 + 78) & 0x40) == 0)
                    {
LABEL_2020:
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = 2;
                      unint64_t v7 = "Expected LF after headers";
                      goto LABEL_2263;
                    }
                    v628 = (_WORD *)(a1 + 82);
                    int v632 = *(unsigned __int16 *)(a1 + 82);
                    if ((v632 & 0x80) == 0)
                    {
                      if ((~v632 & 0x14) == 0)
                      {
                        char v633 = 1;
                        if (*(unsigned char *)(a1 + 72) != 1)
                        {
                          BOOL v634 = *(unsigned __int16 *)(a1 + 84) == 101;
LABEL_2116:
                          char v633 = v634;
                        }
                        *(unsigned char *)(a1 + 80) = v633;
                        uint64_t v662 = *(void *)(a1 + 88);
                        if (v662)
                        {
                          v663 = *(unsigned int (**)(uint64_t))(v662 + 72);
                          if (v663)
                          {
                            switch(v663(a1))
                            {
                              case 0u:
                                goto LABEL_2131;
                              case 1u:
                                goto LABEL_2130;
                              case 2u:
                                goto LABEL_2129;
                              case 0x15u:
                                goto LABEL_2186;
                              default:
                                goto LABEL_2185;
                            }
                          }
                        }
                        goto LABEL_2131;
                      }
                      BOOL v634 = *(unsigned char *)(a1 + 73) == 5;
                      goto LABEL_2116;
                    }
                    break;
                  case 58:
                    goto LABEL_2158;
                  default:
LABEL_1942:
                    if (a2 == a3) {
                      return 89;
                    }
                    *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
                    *(void *)(a1 + 16) = llhttp__on_header_field;
LABEL_1944:
                    if (a2 != a3)
                    {
                      int v609 = *a2;
                      if ((v609 - 65) < 0x1A) {
                        v609 |= 0x20u;
                      }
                      switch(v609)
                      {
                        case 'c':
                          ++a2;
                          goto LABEL_1949;
                        case 'p':
                          ++a2;
                          goto LABEL_2035;
                        case 't':
                          ++a2;
                          goto LABEL_2054;
                        case 'u':
                          ++a2;
                          goto LABEL_2073;
                        default:
                          goto LABEL_1701;
                      }
                    }
                    return 88;
                }
                uint64_t v635 = *(void *)(a1 + 88);
                if (v635)
                {
                  v636 = *(uint64_t (**)(uint64_t))(v635 + 168);
                  if (v636)
                  {
                    int v637 = v636(a1);
                    if (v637)
                    {
                      if (v637 == 21)
                      {
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = 21;
                        *(void *)(a1 + 32) = "on_chunk_complete pause";
LABEL_2143:
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 5;
                        return result;
                      }
LABEL_2150:
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = 20;
                      goto LABEL_2263;
                    }
                  }
                }
LABEL_1933:
                uint64_t v605 = *(void *)(a1 + 88);
                if (v605)
                {
                  v606 = *(uint64_t (**)(uint64_t))(v605 + 88);
                  if (v606)
                  {
                    int v607 = v606(a1);
                    if (v607)
                    {
                      if (v607 == 21)
                      {
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = 21;
                        *(void *)(a1 + 32) = "on_message_complete pause";
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 4;
                        return result;
                      }
LABEL_2171:
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = 18;
                      goto LABEL_2263;
                    }
                  }
                }
LABEL_1930:
                if (*(unsigned char *)(a1 + 80) == 1)
                {
LABEL_1931:
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 22;
                  v604 = "Pause on CONNECT/Upgrade";
LABEL_1932:
                  *(void *)(a1 + 32) = v604;
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 2;
                  return result;
                }
LABEL_1910:
                if (*(unsigned char *)(a1 + 74) && *(unsigned char *)(a1 + 75))
                {
                  __int16 v602 = *(_WORD *)(a1 + 82);
                  if ((v602 & 2) == 0) {
                    goto LABEL_1919;
                  }
LABEL_1915:
                  *(_WORD *)(a1 + 82) = 0;
                  goto LABEL_1916;
                }
                __int16 v602 = *(_WORD *)(a1 + 82);
                if ((v602 & 1) == 0) {
                  goto LABEL_1915;
                }
LABEL_1919:
                if (*(unsigned char *)(a1 + 72) == 1
                  || (int v603 = *(unsigned __int16 *)(a1 + 84), (v603 - 100) < 0x64)
                  || v603 == 204
                  || v603 == 304
                  || (v602 & 0x40) != 0)
                {
                  *(_WORD *)(a1 + 82) = 0;
                }
                else
                {
                  if ((v602 & 0x208) == 0x200) {
                    goto LABEL_1915;
                  }
                  *(unsigned char *)(a1 + 81) = 0;
                  *(_WORD *)(a1 + 82) = 0;
                  if ((v602 & 0x28) == 0)
                  {
LABEL_1916:
                    *(unsigned char *)(a1 + 81) = 0;
                    if ((*(_WORD *)(a1 + 78) & 4) == 0)
                    {
LABEL_1917:
                      uint64_t result = 1;
                      if (a2 != a3)
                      {
                        while (1)
                        {
                          int v601 = *a2;
                          if (v601 == 13 || v601 == 10)
                          {
                            ++a2;
                          }
                          else
                          {
                            ++a2;
                            if ((*(_WORD *)(a1 + 78) & 0x20) == 0)
                            {
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = 5;
                              goto LABEL_2263;
                            }
                          }
                          if (a2 == a3) {
                            return result;
                          }
                        }
                      }
                      return result;
                    }
LABEL_1929:
                    *(unsigned char *)(a1 + 86) = 1;
                    *(unsigned char *)(a1 + 81) = 0;
LABEL_3:
                    uint64_t result = 238;
                    if (a2 == a3) {
                      return result;
                    }
                    while (1)
                    {
                      int v8 = *a2;
                      if (v8 != 13 && v8 != 10) {
                        break;
                      }
                      if (++a2 == a3) {
                        return result;
                      }
                    }
                    if (*(unsigned char *)(a1 + 86) == 1)
                    {
                      uint64_t v10 = *(void *)(a1 + 88);
                      if (v10)
                      {
                        uint64_t v11 = *(uint64_t (**)(uint64_t))(v10 + 176);
                        if (v11)
                        {
                          int v12 = v11(a1);
                          if (v12)
                          {
                            if (v12 != 21)
                            {
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = 31;
                              goto LABEL_2263;
                            }
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = 21;
                            *(void *)(a1 + 32) = "on_reset pause";
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 237;
                            return result;
                          }
                        }
                      }
                    }
LABEL_15:
                    *(unsigned char *)(a1 + 81) = 2;
                    BOOL v13 = *(uint64_t (***)(uint64_t))(a1 + 88);
                    if (v13)
                    {
                      char v14 = *v13;
                      if (v14)
                      {
                        int v15 = v14(a1);
                        if (v15)
                        {
                          if (v15 != 21)
                          {
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = 16;
                            goto LABEL_2263;
                          }
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 21;
                          *(void *)(a1 + 32) = "on_message_begin pause";
                          *(void *)(a1 + 40) = a2;
                          *(void *)(a1 + 56) = 236;
                          return result;
                        }
                      }
                    }
LABEL_18:
                    int v16 = *(unsigned __int8 *)(a1 + 72);
                    if (v16 == 1) {
                      goto LABEL_58;
                    }
                    if (v16 == 2)
                    {
LABEL_20:
                      if (a2 == a3) {
                        return 227;
                      }
                      int v17 = 0;
                      unsigned int v18 = *(_DWORD *)a1;
                      while (1)
                      {
                        int v19 = *a2;
                        int v20 = llparse_blob58[v18];
                        if (v18 == 4)
                        {
                          int v17 = 0;
                          int v21 = 5;
                        }
                        else
                        {
                          int v21 = 0;
                        }
                        if (v19 != v20)
                        {
                          int v17 = 2;
                          int v21 = 5;
                        }
                        if (v21) {
                          break;
                        }
                        if (v19 == v20) {
                          ++v18;
                        }
                        if (++a2 == a3)
                        {
                          int v17 = 1;
                          a2 = a3;
                          *(_DWORD *)a1 = v18;
                          goto LABEL_98;
                        }
                      }
                      *(_DWORD *)a1 = 0;
LABEL_98:
                      if (v17)
                      {
                        if (v17 == 1) {
                          return 227;
                        }
LABEL_1308:
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = 8;
                        unint64_t v7 = "Expected HTTP/";
                        goto LABEL_2263;
                      }
                      ++a2;
                    }
                    else
                    {
LABEL_33:
                      if (a2 == a3) {
                        return 235;
                      }
                      if (*a2 != 72)
                      {
                        *(unsigned char *)(a1 + 72) = 1;
LABEL_58:
                        if (a2 == a3) {
                          return 209;
                        }
                        *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
                        *(void *)(a1 + 16) = llhttp__on_method;
LABEL_60:
                        if (a2 != a3)
                        {
                          switch(*a2)
                          {
                            case 'A':
                              ++a2;
                              goto LABEL_63;
                            case 'B':
                              ++a2;
                              goto LABEL_211;
                            case 'C':
                              ++a2;
                              goto LABEL_229;
                            case 'D':
                              ++a2;
                              goto LABEL_277;
                            case 'F':
                              ++a2;
                              goto LABEL_320;
                            case 'G':
                              ++a2;
                              goto LABEL_338;
                            case 'H':
                              ++a2;
                              goto LABEL_376;
                            case 'L':
                              ++a2;
                              goto LABEL_394;
                            case 'M':
                              ++a2;
                              goto LABEL_434;
                            case 'N':
                              ++a2;
                              goto LABEL_539;
                            case 'O':
                              ++a2;
                              goto LABEL_557;
                            case 'P':
                              ++a2;
                              goto LABEL_575;
                            case 'Q':
                              ++a2;
                              goto LABEL_725;
                            case 'R':
                              ++a2;
                              goto LABEL_743;
                            case 'S':
                              ++a2;
                              goto LABEL_821;
                            case 'T':
                              ++a2;
                              goto LABEL_910;
                            case 'U':
                              ++a2;
                              goto LABEL_950;
                            default:
                              goto LABEL_1301;
                          }
                        }
                        return 208;
                      }
LABEL_35:
                      if (a2 == a3) {
                        return 234;
                      }
                      *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
                      *(void *)(a1 + 16) = llhttp__on_method;
LABEL_37:
                      if (a2 == a3) {
                        return 233;
                      }
                      if (*a2 != 72) {
                        goto LABEL_206;
                      }
                      ++a2;
LABEL_40:
                      if (a2 == a3) {
                        return 232;
                      }
                      int v22 = *a2;
                      if (v22 != 84)
                      {
                        if (v22 == 69)
                        {
                          ++a2;
LABEL_44:
                          if (a2 == a3) {
                            return 229;
                          }
                          int v23 = 0;
                          unsigned int v24 = *(_DWORD *)a1;
                          while (1)
                          {
                            int v25 = *a2;
                            int v26 = llparse_blob59[v24];
                            if (v24 == 1)
                            {
                              int v23 = 0;
                              int v27 = 5;
                            }
                            else
                            {
                              int v27 = 0;
                            }
                            if (v25 != v26)
                            {
                              int v23 = 2;
                              int v27 = 5;
                            }
                            if (v27) {
                              break;
                            }
                            if (v25 == v26) {
                              ++v24;
                            }
                            if (++a2 == a3)
                            {
                              int v23 = 1;
                              a2 = a3;
                              *(_DWORD *)a1 = v24;
                              goto LABEL_100;
                            }
                          }
                          *(_DWORD *)a1 = 0;
LABEL_100:
                          if (!v23)
                          {
                            ++a2;
                            *(_WORD *)(a1 + 72) = 513;
                            uint64_t v40 = *(void *)(a1 + 8);
                            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                            uint64_t v41 = *(void *)(a1 + 88);
                            if (v41)
                            {
                              unint64_t v42 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v41 + 24);
                              if (v42)
                              {
                                int v43 = v42(a1, v40, &a2[-v40]);
                                if (v43)
                                {
                                  int v44 = v43;
                                  if (v43 == -1)
                                  {
                                    *(void *)(a1 + 32) = "Span callback error in on_method";
                                    int v44 = 24;
                                  }
                                  uint64_t result = 0;
                                  *(_DWORD *)(a1 + 24) = v44;
                                  *(void *)(a1 + 40) = a2;
                                  *(void *)(a1 + 56) = 228;
                                  return result;
                                }
                              }
                            }
                            goto LABEL_1028;
                          }
                          if (v23 == 1) {
                            return 229;
                          }
                        }
LABEL_206:
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = 8;
                        unint64_t v7 = "Invalid word encountered";
                        goto LABEL_2263;
                      }
                      ++a2;
LABEL_71:
                      if (a2 == a3) {
                        return 231;
                      }
                      int v30 = 0;
                      unsigned int v31 = *(_DWORD *)a1;
                      while (1)
                      {
                        int v32 = *a2;
                        int v33 = llparse_blob60[v31];
                        if (v31 == 2)
                        {
                          int v30 = 0;
                          int v34 = 5;
                        }
                        else
                        {
                          int v34 = 0;
                        }
                        if (v32 != v33)
                        {
                          int v30 = 2;
                          int v34 = 5;
                        }
                        if (v34) {
                          break;
                        }
                        if (v32 == v33) {
                          ++v31;
                        }
                        if (++a2 == a3)
                        {
                          int v30 = 1;
                          a2 = a3;
                          *(_DWORD *)a1 = v31;
                          goto LABEL_107;
                        }
                      }
                      *(_DWORD *)a1 = 0;
LABEL_107:
                      if (v30)
                      {
                        if (v30 == 1) {
                          return 231;
                        }
                        goto LABEL_206;
                      }
                      ++a2;
                      uint64_t v45 = *(void *)(a1 + 8);
                      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                      uint64_t v46 = *(void *)(a1 + 88);
                      if (v46)
                      {
                        int v47 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v46 + 24);
                        if (v47)
                        {
                          int v48 = v47(a1, v45, &a2[-v45]);
                          if (v48)
                          {
                            int v413 = v48;
                            if (v48 == -1)
                            {
                              *(void *)(a1 + 32) = "Span callback error in on_method";
                              int v413 = 24;
                            }
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = v413;
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 230;
                            return result;
                          }
                        }
                      }
LABEL_111:
                      *(unsigned char *)(a1 + 72) = 2;
                    }
LABEL_112:
                    if (a2 == a3) {
                      return 226;
                    }
                    *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
                    *(void *)(a1 + 16) = llhttp__on_version;
LABEL_114:
                    if (a2 == a3) {
                      return 225;
                    }
                    unsigned int v49 = *a2 - 48;
                    if (v49 >= 0xA)
                    {
                      uint64_t v390 = *(void *)(a1 + 8);
                      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                      uint64_t v391 = *(void *)(a1 + 88);
                      if (v391)
                      {
                        v392 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v391 + 32);
                        if (v392)
                        {
                          int v393 = v392(a1, v390, &a2[-v390]);
                          if (v393)
                          {
                            int v394 = v393;
                            if (v393 == -1)
                            {
                              *(void *)(a1 + 32) = "Span callback error in on_version";
                              int v394 = 24;
                            }
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = v394;
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 224;
                            return result;
                          }
                        }
                      }
                      goto LABEL_1409;
                    }
                    ++a2;
                    *(unsigned char *)(a1 + 74) = v49;
LABEL_117:
                    if (a2 == a3) {
                      return 223;
                    }
                    if (*a2 != 46)
                    {
                      uint64_t v395 = *(void *)(a1 + 8);
                      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                      uint64_t v396 = *(void *)(a1 + 88);
                      if (v396)
                      {
                        v397 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v396 + 32);
                        if (v397)
                        {
                          int v398 = v397(a1, v395, &a2[-v395]);
                          if (v398)
                          {
                            int v399 = v398;
                            if (v398 == -1)
                            {
                              *(void *)(a1 + 32) = "Span callback error in on_version";
                              int v399 = 24;
                            }
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = v399;
                            *(void *)(a1 + 40) = a2;
                            *(void *)(a1 + 56) = 222;
                            return result;
                          }
                        }
                      }
                      goto LABEL_1416;
                    }
                    ++a2;
LABEL_120:
                    if (a2 == a3) {
                      return 221;
                    }
                    char v50 = 0;
                    char v51 = 0;
                    char v52 = 1;
                    char v53 = 1;
                    switch(*a2)
                    {
                      case '0':
                        goto LABEL_133;
                      case '1':
                        char v52 = 0;
                        char v50 = 0;
                        char v51 = 1;
                        goto LABEL_133;
                      case '2':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 2;
                        goto LABEL_133;
                      case '3':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 3;
                        goto LABEL_133;
                      case '4':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 4;
                        goto LABEL_133;
                      case '5':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 5;
                        goto LABEL_133;
                      case '6':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 6;
                        goto LABEL_133;
                      case '7':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 7;
                        goto LABEL_133;
                      case '8':
                        char v52 = 0;
                        char v53 = 0;
                        char v50 = 0;
                        char v51 = 8;
                        goto LABEL_133;
                      case '9':
                        char v52 = 0;
                        char v53 = 0;
                        char v51 = 9;
                        char v50 = 1;
LABEL_133:
                        ++a2;
                        *(unsigned char *)(a1 + 75) = v51;
                        if ((*(_WORD *)(a1 + 78) & 0x10) != 0) {
                          goto LABEL_138;
                        }
                        int v54 = *(unsigned __int8 *)(a1 + 74);
                        if (*(unsigned char *)(a1 + 74))
                        {
                          if (v54 == 1)
                          {
                            if ((v53 & 1) == 0) {
                              goto LABEL_195;
                            }
                          }
                          else if (v54 != 2 || (v52 & 1) == 0)
                          {
LABEL_195:
                            uint64_t v85 = *(void *)(a1 + 8);
                            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                            uint64_t v86 = *(void *)(a1 + 88);
                            if (v86)
                            {
                              v87 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v86 + 32);
                              if (v87)
                              {
                                int v88 = v87(a1, v85, &a2[-v85]);
                                if (v88)
                                {
                                  int v89 = v88;
                                  if (v88 == -1)
                                  {
                                    *(void *)(a1 + 32) = "Span callback error in on_version";
                                    int v89 = 24;
                                  }
                                  uint64_t result = 0;
                                  *(_DWORD *)(a1 + 24) = v89;
                                  *(void *)(a1 + 40) = a2;
                                  *(void *)(a1 + 56) = 219;
                                  return result;
                                }
                              }
                            }
                            goto LABEL_1282;
                          }
                        }
                        else if ((v50 & 1) == 0)
                        {
                          goto LABEL_195;
                        }
LABEL_138:
                        uint64_t v55 = *(void *)(a1 + 8);
                        *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                        uint64_t v56 = *(void *)(a1 + 88);
                        if (v56)
                        {
                          os_log_type_t v57 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v56 + 32);
                          if (v57)
                          {
                            int v58 = v57(a1, v55, &a2[-v55]);
                            if (v58)
                            {
                              int v411 = v58;
                              if (v58 == -1)
                              {
                                *(void *)(a1 + 32) = "Span callback error in on_version";
                                int v411 = 24;
                              }
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = v411;
                              *(void *)(a1 + 40) = a2;
                              *(void *)(a1 + 56) = 218;
                              return result;
                            }
                          }
                        }
LABEL_141:
                        uint64_t v59 = *(void *)(a1 + 88);
                        if (v59)
                        {
                          BOOL v60 = *(uint64_t (**)(uint64_t))(v59 + 120);
                          if (v60)
                          {
                            int v61 = v60(a1);
                            if (v61)
                            {
                              if (v61 == 21)
                              {
                                uint64_t result = 0;
                                *(_DWORD *)(a1 + 24) = 21;
                                *(void *)(a1 + 32) = "on_version_complete pause";
                                *(void *)(a1 + 40) = a2;
                                *(void *)(a1 + 56) = 217;
                                return result;
                              }
                              goto LABEL_1427;
                            }
                          }
                        }
LABEL_144:
                        if (a2 == a3) {
                          return 217;
                        }
                        if (*a2 != 32)
                        {
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 9;
                          unint64_t v7 = "Expected space after version";
                          goto LABEL_2263;
                        }
                        ++a2;
                        *(_WORD *)(a1 + 84) = 0;
LABEL_147:
                        if (a2 == a3) {
                          return 216;
                        }
                        unsigned int v62 = *a2 - 48;
                        if (v62 >= 0xA
                          || (++a2, unsigned int v63 = *(unsigned __int16 *)(a1 + 84), v63 >> 1 > 0xCCC)
                          || (unsigned int v64 = 10 * v63, *(_WORD *)(a1 + 84) = v64, (v62 ^ 0xFFFFu) < v64))
                        {
LABEL_191:
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 13;
                          unint64_t v7 = "Invalid status code";
                          goto LABEL_2263;
                        }
                        *(_WORD *)(a1 + 84) = v64 + v62;
LABEL_152:
                        if (a2 == a3) {
                          return 215;
                        }
                        unsigned int v65 = *a2 - 48;
                        if (v65 >= 0xA) {
                          goto LABEL_162;
                        }
                        ++a2;
                        unsigned int v66 = *(unsigned __int16 *)(a1 + 84);
                        if (v66 >> 1 > 0xCCC) {
                          goto LABEL_191;
                        }
                        unsigned int v67 = 10 * v66;
                        *(_WORD *)(a1 + 84) = v67;
                        if ((v65 ^ 0xFFFFu) < v67) {
                          goto LABEL_191;
                        }
                        *(_WORD *)(a1 + 84) = v67 + v65;
LABEL_157:
                        if (a2 == a3) {
                          return 214;
                        }
                        unsigned int v68 = *a2 - 48;
                        if (v68 >= 0xA)
                        {
LABEL_162:
                          if ((*(_WORD *)(a1 + 78) & 0x2000) == 0) {
                            goto LABEL_191;
                          }
                        }
                        else
                        {
                          ++a2;
                          unsigned int v69 = *(unsigned __int16 *)(a1 + 84);
                          if (v69 >> 1 > 0xCCC) {
                            goto LABEL_191;
                          }
                          unsigned int v70 = 10 * v69;
                          *(_WORD *)(a1 + 84) = v70;
                          if ((v68 ^ 0xFFFFu) < v70) {
                            goto LABEL_191;
                          }
                          *(_WORD *)(a1 + 84) = v70 + v68;
                        }
LABEL_163:
                        if (a2 == a3) {
                          return 213;
                        }
                        int v71 = *a2;
                        if (v71 == 32)
                        {
                          ++a2;
LABEL_170:
                          if (a2 == a3) {
                            return 212;
                          }
                          *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
                          *(void *)(a1 + 16) = llhttp__on_status;
LABEL_172:
                          uint64_t result = 211;
                          if (a2 == a3) {
                            return result;
                          }
                          while (1)
                          {
                            int v72 = *a2;
                            if (v72 == 10) {
                              break;
                            }
                            if (v72 == 13)
                            {
                              uint64_t v81 = *(void *)(a1 + 8);
                              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                              uint64_t v82 = *(void *)(a1 + 88);
                              if (!v82) {
                                goto LABEL_190;
                              }
                              uint64_t v83 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v82 + 16);
                              if (!v83) {
                                goto LABEL_190;
                              }
                              int v84 = v83(a1, v81, &a2[-v81]);
                              if (!v84) {
                                goto LABEL_190;
                              }
                              int v418 = v84;
                              if (v84 == -1)
                              {
                                *(void *)(a1 + 32) = "Span callback error in on_status";
                                int v418 = 24;
                              }
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = v418;
                              *(void *)(a1 + 40) = a2 + 1;
                              *(void *)(a1 + 56) = 97;
                              return result;
                            }
                            if (++a2 == a3) {
                              return result;
                            }
                          }
                          uint64_t v73 = *(void *)(a1 + 8);
                          *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                          uint64_t v74 = *(void *)(a1 + 88);
                          if (v74)
                          {
                            uint64_t v75 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v74 + 16);
                            if (v75)
                            {
                              int v76 = v75(a1, v73, &a2[-v73]);
                              if (v76)
                              {
                                int v417 = v76;
                                if (v76 == -1)
                                {
                                  *(void *)(a1 + 32) = "Span callback error in on_status";
                                  int v417 = 24;
                                }
                                uint64_t result = 0;
                                *(_DWORD *)(a1 + 24) = v417;
                                *(void *)(a1 + 40) = a2 + 1;
                                *(void *)(a1 + 56) = 210;
                                return result;
                              }
                            }
                          }
                          ++a2;
LABEL_181:
                          if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
                          {
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = 25;
                            unint64_t v7 = "Missing expected CR after response line";
                            goto LABEL_2263;
                          }
                        }
                        else
                        {
                          if (v71 == 13)
                          {
LABEL_190:
                            ++a2;
LABEL_2348:
                            while (a2 != a3)
                            {
                              int v715 = *a2;
                              if (v715 != 13)
                              {
                                if (v715 == 10)
                                {
                                  ++a2;
                                  goto LABEL_182;
                                }
                                if ((*(_WORD *)(a1 + 78) & 0x40) != 0) {
                                  goto LABEL_182;
                                }
LABEL_1772:
                                uint64_t result = 0;
                                *(_DWORD *)(a1 + 24) = 2;
                                unint64_t v7 = "Expected LF after CR";
                                goto LABEL_2263;
                              }
LABEL_2347:
                              ++a2;
                              if ((*(_WORD *)(a1 + 78) & 0x1000) == 0) {
                                goto LABEL_1772;
                              }
                            }
                            return 97;
                          }
                          if (v71 != 10 || (++a2, (*(_WORD *)(a1 + 78) & 0x100) == 0))
                          {
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = 13;
                            unint64_t v7 = "Invalid response status";
                            goto LABEL_2263;
                          }
                        }
LABEL_182:
                        uint64_t v77 = *(void *)(a1 + 88);
                        if (v77)
                        {
                          uint64_t v78 = *(uint64_t (**)(uint64_t))(v77 + 104);
                          if (v78)
                          {
                            int v79 = v78(a1);
                            if (v79)
                            {
                              if (v79 != 21)
                              {
                                uint64_t result = 0;
                                *(_DWORD *)(a1 + 24) = 27;
                                goto LABEL_2263;
                              }
                              uint64_t result = 0;
                              *(_DWORD *)(a1 + 24) = 21;
                              uint64_t v80 = "on_status_complete pause";
                              goto LABEL_1147;
                            }
                          }
                        }
LABEL_1269:
                        if (a2 == a3) {
                          return 91;
                        }
                        if (*a2 == 32)
                        {
                          ++a2;
                          if ((*(_WORD *)(a1 + 78) & 1) == 0)
                          {
                            uint64_t result = 0;
                            *(_DWORD *)(a1 + 24) = 30;
                            unint64_t v7 = "Unexpected space after start line";
                            goto LABEL_2263;
                          }
                        }
                        break;
                      default:
                        uint64_t v419 = *(void *)(a1 + 8);
                        *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                        uint64_t v420 = *(void *)(a1 + 88);
                        if (!v420) {
                          goto LABEL_1477;
                        }
                        v421 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v420 + 32);
                        if (!v421) {
                          goto LABEL_1477;
                        }
                        int v422 = v421(a1, v419, &a2[-v419]);
                        if (!v422) {
                          goto LABEL_1477;
                        }
                        int v423 = v422;
                        if (v422 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_version";
                          int v423 = 24;
                        }
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = v423;
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 220;
                        return result;
                    }
                    continue;
                  }
                }
                break;
              }
              *(void *)(a1 + 64) = 0;
              goto LABEL_1929;
            }
            if ((*(_WORD *)(a1 + 78) & 1) == 0)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 10;
              unint64_t v7 = "Unexpected whitespace after header value";
              goto LABEL_2263;
            }
            if (*(unsigned char *)(a1 + 76) == 8) {
              *(unsigned char *)(a1 + 76) = 0;
            }
LABEL_1781:
            if (a2 == a3) {
              return 73;
            }
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
            *(void *)(a1 + 16) = llhttp__on_header_value;
            switch(*(unsigned char *)(a1 + 76))
            {
              case 1:
                goto LABEL_2273;
              case 2:
                if ((*(_WORD *)(a1 + 82) & 0x20) == 0) {
                  goto LABEL_1786;
                }
                if ((*(_WORD *)(a1 + 78) & 0x800) == 0)
                {
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 4;
                  unint64_t v7 = "Duplicate Content-Length";
                  goto LABEL_2263;
                }
                *(void *)(a1 + 64) = 0;
LABEL_1786:
                if (a2 == a3) {
                  return 65;
                }
                v563 = a2;
                uint64_t result = 65;
                while (2)
                {
                  if (*v563 - 48 < 0xA)
                  {
                    a2 = v563 + 1;
                    unint64_t v564 = *(void *)(a1 + 64);
                    if (v564 <= 0x1999999999999999)
                    {
                      uint64_t v565 = (*v563 - 48);
                      uint64_t v566 = 10 * v564;
                      *(void *)(a1 + 64) = v566;
                      if (!__CFADD__(v565, v566))
                      {
                        *(void *)(a1 + 64) = v566 + v565;
                        ++v563;
                        if (a2 == a3) {
                          return result;
                        }
                        continue;
                      }
                      a2 = v563 + 1;
                    }
                    uint64_t v575 = *(void *)(a1 + 8);
                    *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                    uint64_t v576 = *(void *)(a1 + 88);
                    if (!v576
                      || (v577 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v576 + 48)) == 0
                      || (int v578 = v577(a1, v575, &a2[-v575])) == 0)
                    {
LABEL_1822:
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = 11;
                      unint64_t v7 = "Content-Length overflow";
                      goto LABEL_2263;
                    }
                    int v579 = v578;
                    if (v578 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_header_value";
                      int v579 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v579;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 62;
                    return result;
                  }
                  break;
                }
                a2 = v563;
LABEL_1797:
                uint64_t result = 64;
                if (a2 == a3) {
                  return result;
                }
                while (1)
                {
                  int v568 = *a2;
                  if (v568 != 32) {
                    break;
                  }
                  if (++a2 == a3) {
                    return result;
                  }
                }
                if (v568 != 10 && v568 != 13)
                {
                  uint64_t v570 = *(void *)(a1 + 8);
                  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                  uint64_t v571 = *(void *)(a1 + 88);
                  if (!v571
                    || (v572 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v571 + 48)) == 0
                    || (int v573 = v572(a1, v570, &a2[-v570])) == 0)
                  {
LABEL_1814:
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = 11;
                    unint64_t v7 = "Invalid character in Content-Length";
                    goto LABEL_2263;
                  }
                  int v574 = v573;
                  if (v573 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_value";
                    int v574 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v574;
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 63;
                  return result;
                }
                *(_WORD *)(a1 + 82) |= 0x20u;
                break;
              case 3:
                __int16 v580 = *(_WORD *)(a1 + 82);
                if ((v580 & 8) != 0 && *(unsigned char *)(a1 + 72) == 1 && (*(_WORD *)(a1 + 78) & 8) == 0)
                {
                  *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                  uint64_t v594 = *(void *)(a1 + 88);
                  if (v594)
                  {
                    v595 = *(uint64_t (**)(uint64_t, unsigned __int8 *, void))(v594 + 48);
                    if (v595)
                    {
                      int v596 = v595(a1, a2, 0);
                      if (v596)
                      {
                        int v597 = v596;
                        if (v596 == -1)
                        {
                          *(void *)(a1 + 32) = "Span callback error in on_header_value";
                          int v597 = 24;
                        }
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = v597;
                        *(void *)(a1 + 40) = a2 + 1;
                        *(void *)(a1 + 56) = 66;
                        return result;
                      }
                    }
                  }
                  goto LABEL_1887;
                }
                *(_WORD *)(a1 + 82) = v580 & 0xFDF7 | 0x200;
LABEL_1827:
                while (2)
                {
                  if (a2 == a3) {
                    return 72;
                  }
                  unsigned int v581 = *(_DWORD *)a1;
                  v582 = &a2[6 - *(_DWORD *)a1];
                  int v583 = *(_DWORD *)a1 + a3 - a2;
                  while (2)
                  {
                    if ((*a2 | 0x20) == llparse_blob5[v581])
                    {
                      if (v581 != 6)
                      {
                        ++a2;
                        ++v581;
                        if (a2 == a3)
                        {
                          *(_DWORD *)a1 = v583;
                          return 72;
                        }
                        continue;
                      }
                      *(_DWORD *)a1 = 0;
                      a2 = v582 + 1;
LABEL_1727:
                      uint64_t result = 71;
                      if (a2 == a3) {
                        return result;
                      }
                      while (1)
                      {
                        int v539 = *a2;
                        if (v539 != 32) {
                          break;
                        }
                        if (++a2 == a3) {
                          return result;
                        }
                      }
                      if (v539 == 10 || v539 == 13)
                      {
                        *(unsigned char *)(a1 + 76) = 8;
                        goto LABEL_1746;
                      }
                      if (v539 == 44)
                      {
                        if (*(unsigned char *)(a1 + 72) == 1 && (*(_WORD *)(a1 + 78) & 8) == 0)
                        {
                          uint64_t v541 = *(void *)(a1 + 8);
                          *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                          uint64_t v542 = *(void *)(a1 + 88);
                          if (v542)
                          {
                            v543 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v542 + 48);
                            if (v543)
                            {
                              int v544 = v543(a1, v541, &a2[-v541]);
                              if (v544)
                              {
                                int v545 = v544;
                                if (v544 == -1)
                                {
                                  *(void *)(a1 + 32) = "Span callback error in on_header_value";
                                  int v545 = 24;
                                }
                                uint64_t result = 0;
                                *(_DWORD *)(a1 + 24) = v545;
                                *(void *)(a1 + 40) = a2 + 1;
                                *(void *)(a1 + 56) = 67;
                                return result;
                              }
                            }
                          }
LABEL_1887:
                          ++a2;
LABEL_2:
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = 15;
                          goto LABEL_2263;
                        }
                        goto LABEL_1827;
                      }
                    }
                    else
                    {
                      *(_DWORD *)a1 = 0;
                    }
                    break;
                  }
LABEL_1834:
                  if (a2 == a3) {
                    return 70;
                  }
                  uint64_t result = 70;
                  while (1)
                  {
                    int v584 = llhttp__internal__run_lookup_table_15[*a2];
                    if (v584 != 1) {
                      break;
                    }
                    if (++a2 == a3) {
                      return result;
                    }
                  }
                  if (v584 == 2)
                  {
                    ++a2;
LABEL_1841:
                    uint64_t result = 68;
                    if (a2 == a3) {
                      return result;
                    }
                    while (1)
                    {
                      int v585 = *a2;
                      if (v585 != 32 && v585 != 9) {
                        break;
                      }
                      if (++a2 == a3) {
                        return result;
                      }
                    }
                    continue;
                  }
                  break;
                }
LABEL_1850:
                *(unsigned char *)(a1 + 76) = 0;
LABEL_1851:
                if (a2 == a3) {
                  return 69;
                }
                uint64_t result = 69;
                while (llhttp__internal__run_lookup_table_14[*a2] == 1)
                {
                  if (++a2 == a3) {
                    return result;
                  }
                }
                continue;
              case 4:
                *(_WORD *)(a1 + 82) |= 0x10u;
                goto LABEL_1850;
              default:
                goto LABEL_1851;
            }
          }
          uint64_t v551 = *(void *)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
          uint64_t v552 = *(void *)(a1 + 88);
          if (v552)
          {
            v553 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v552 + 48);
            if (v553)
            {
              int v554 = v553(a1, v551, &a2[-v551]);
              if (v554)
              {
                int v555 = v554;
                if (v554 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_header_value";
                  int v555 = 24;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = v555;
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 51;
                return result;
              }
            }
          }
LABEL_1768:
          if ((*(_WORD *)(a1 + 78) & 0x100) == 0)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 25;
            unint64_t v7 = "Missing expected CR after header value";
            goto LABEL_2263;
          }
          goto LABEL_1769;
        }
        break;
      }
      ++a2;
LABEL_2306:
      if (a2 != a3)
      {
        int v705 = 0;
        unsigned int v706 = *(_DWORD *)a1;
        while (1)
        {
          int v707 = *a2;
          if ((v707 - 65) < 0x1A) {
            v707 |= 0x20u;
          }
          int v708 = llparse_blob2[v706];
          if (v706 == 3)
          {
            int v705 = 0;
            int v709 = 5;
          }
          else
          {
            int v709 = 0;
          }
          if (v707 != v708)
          {
            int v705 = 2;
            int v709 = 5;
          }
          if (v709) {
            break;
          }
          if (v707 == v708) {
            ++v706;
          }
          if (++a2 == a3)
          {
            int v705 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v706;
            goto LABEL_2321;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_2321:
        char v704 = 6;
        if (!v705) {
          goto LABEL_1888;
        }
        if (v705 == 2) {
          goto LABEL_2342;
        }
      }
      return 58;
    case 62:
      goto LABEL_1822;
    case 63:
      goto LABEL_1814;
    case 64:
      goto LABEL_1797;
    case 65:
      goto LABEL_1786;
    case 66:
    case 67:
      goto LABEL_2;
    case 68:
      goto LABEL_1841;
    case 69:
      goto LABEL_1851;
    case 70:
      goto LABEL_1834;
    case 71:
      goto LABEL_1727;
    case 72:
      goto LABEL_1827;
    case 73:
      goto LABEL_1781;
    case 74:
      goto LABEL_2248;
    case 75:
      goto LABEL_2102;
    case 76:
      goto LABEL_2099;
    case 77:
      goto LABEL_1710;
    case 78:
      goto LABEL_1707;
    case 79:
      goto LABEL_1702;
    case 80:
      goto LABEL_2092;
    case 81:
      goto LABEL_1974;
    case 82:
      goto LABEL_1993;
    case 83:
      goto LABEL_1968;
    case 84:
LABEL_1949:
      if (a2 == a3) {
        return 84;
      }
      int v610 = 0;
      unsigned int v611 = *(_DWORD *)a1;
      while (1)
      {
        int v612 = *a2;
        if ((v612 - 65) < 0x1A) {
          v612 |= 0x20u;
        }
        int v613 = llparse_blob0[v611];
        if (v611 == 1)
        {
          int v610 = 0;
          int v614 = 5;
        }
        else
        {
          int v614 = 0;
        }
        if (v612 != v613)
        {
          int v610 = 2;
          int v614 = 5;
        }
        if (v614) {
          break;
        }
        if (v612 == v613) {
          ++v611;
        }
        if (++a2 == a3)
        {
          int v610 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v611;
          goto LABEL_1964;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_1964:
      if (v610)
      {
        if (v610 != 2) {
          return 84;
        }
        goto LABEL_1701;
      }
      ++a2;
LABEL_1968:
      if (a2 == a3) {
        return 83;
      }
      int v615 = *a2;
      if ((v615 - 65) < 0x1A) {
        v615 |= 0x20u;
      }
      if (v615 != 116)
      {
        if (v615 != 110) {
          goto LABEL_1701;
        }
        ++a2;
LABEL_1974:
        if (a2 == a3) {
          return 81;
        }
        int v616 = 0;
        unsigned int v617 = *(_DWORD *)a1;
        while (1)
        {
          int v618 = *a2;
          if ((v618 - 65) < 0x1A) {
            v618 |= 0x20u;
          }
          int v619 = llparse_blob1[v617];
          if (v617 == 5)
          {
            int v616 = 0;
            int v620 = 5;
          }
          else
          {
            int v620 = 0;
          }
          if (v618 != v619)
          {
            int v616 = 2;
            int v620 = 5;
          }
          if (v620) {
            break;
          }
          if (v618 == v619) {
            ++v617;
          }
          if (++a2 == a3)
          {
            int v616 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v617;
            goto LABEL_1989;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_1989:
        char v621 = 1;
        if (v616)
        {
          if (v616 != 2) {
            return 81;
          }
LABEL_1701:
          *(unsigned char *)(a1 + 76) = 0;
LABEL_1702:
          if (a2 == a3) {
            return 79;
          }
          uint64_t result = 79;
          while (llhttp__internal__run_lookup_table_16[*a2] == 1)
          {
            if (++a2 == a3) {
              return result;
            }
          }
LABEL_1707:
          if (a2 == a3) {
            return 78;
          }
          if (*a2 != 58)
          {
            if ((*(_WORD *)(a1 + 78) & 0x400) == 0)
            {
LABEL_2158:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 10;
              unint64_t v7 = "Invalid header token";
              goto LABEL_2263;
            }
LABEL_1710:
            uint64_t result = 77;
            if (a2 == a3) {
              return result;
            }
            while (1)
            {
              int v532 = *a2;
              if (v532 == 10 || v532 == 13) {
                break;
              }
              if (v532 == 58) {
                goto LABEL_2095;
              }
              if (++a2 == a3) {
                return result;
              }
            }
            uint64_t v534 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
            uint64_t v535 = *(void *)(a1 + 88);
            if (v535)
            {
              v536 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v535 + 40);
              if (v536)
              {
                int v537 = v536(a1, v534, &a2[-v534]);
                if (v537)
                {
                  int v538 = v537;
                  if (v537 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_field";
                    int v538 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v538;
                  *(void *)(a1 + 40) = a2;
                  goto LABEL_2162;
                }
              }
            }
            goto LABEL_2099;
          }
LABEL_2095:
          uint64_t v654 = *(void *)(a1 + 8);
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
          uint64_t v655 = *(void *)(a1 + 88);
          if (v655)
          {
            v656 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v655 + 40);
            if (v656)
            {
              int v657 = v656(a1, v654, &a2[-v654]);
              if (v657)
              {
                int v676 = v657;
                if (v657 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_header_field";
                  int v676 = 24;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = v676;
                *(void *)(a1 + 40) = a2 + 1;
LABEL_2162:
                *(void *)(a1 + 56) = 76;
                return result;
              }
            }
          }
          ++a2;
LABEL_2099:
          uint64_t v658 = *(void *)(a1 + 88);
          if (v658)
          {
            v659 = *(uint64_t (**)(uint64_t))(v658 + 128);
            if (v659)
            {
              int v660 = v659(a1);
              if (v660)
              {
                if (v660 == 21)
                {
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 21;
                  *(void *)(a1 + 32) = "on_header_field_complete pause";
                  *(void *)(a1 + 40) = a2;
                  *(void *)(a1 + 56) = 75;
                  return result;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = 28;
                goto LABEL_2263;
              }
            }
          }
LABEL_2102:
          int v661 = *(unsigned __int8 *)(a1 + 76);
          if (v661 == 2)
          {
            if ((*(_WORD *)(a1 + 82) & 0x200) != 0 && (*(_WORD *)(a1 + 78) & 2) == 0)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 11;
              unint64_t v7 = "Content-Length can't be present with Transfer-Encoding";
              goto LABEL_2263;
            }
          }
          else if (v661 == 3 && (*(_WORD *)(a1 + 82) & 0x20) != 0 && (*(_WORD *)(a1 + 78) & 2) == 0)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 15;
            unint64_t v7 = "Transfer-Encoding can't be present with Content-Length";
            goto LABEL_2263;
          }
LABEL_2248:
          uint64_t result = 74;
          if (a2 != a3)
          {
            while (2)
            {
              switch(*a2)
              {
                case 9u:
                case 0x20u:
                  if (++a2 == a3) {
                    return result;
                  }
                  continue;
                case 0xAu:
                  ++a2;
                  if ((*(_WORD *)(a1 + 78) & 0x100) != 0) {
                    goto LABEL_2242;
                  }
                  goto LABEL_2262;
                case 0xDu:
                  ++a2;
                  goto LABEL_2255;
                default:
                  goto LABEL_1781;
              }
            }
          }
          return result;
        }
LABEL_2091:
        ++a2;
        *(unsigned char *)(a1 + 76) = v621;
        while (1)
        {
LABEL_2092:
          if (a2 == a3) {
            return 80;
          }
          int v653 = *a2;
          if (v653 != 32) {
            break;
          }
          if ((*(_WORD *)(a1 + 78) & 1) == 0)
          {
            uint64_t v680 = *(void *)(a1 + 8);
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
            uint64_t v681 = *(void *)(a1 + 88);
            if (v681)
            {
              v682 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v681 + 40);
              if (v682)
              {
                int v683 = v682(a1, v680, &a2[-v680]);
                if (v683)
                {
                  int v684 = v683;
                  if (v683 == -1)
                  {
                    *(void *)(a1 + 32) = "Span callback error in on_header_field";
                    int v684 = 24;
                  }
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = v684;
                  *(void *)(a1 + 40) = a2 + 1;
                  *(void *)(a1 + 56) = 42;
                  return result;
                }
              }
            }
            ++a2;
LABEL_2184:
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 10;
            unint64_t v7 = "Invalid header field char";
            goto LABEL_2263;
          }
LABEL_2111:
          uint64_t result = 44;
          if (a2 == a3) {
            return result;
          }
          while (*a2 == 32)
          {
            if (++a2 == a3) {
              return result;
            }
          }
        }
        if (v653 == 58) {
          goto LABEL_2095;
        }
        goto LABEL_1701;
      }
      ++a2;
LABEL_1993:
      if (a2 != a3)
      {
        int v622 = 0;
        unsigned int v623 = *(_DWORD *)a1;
        while (1)
        {
          int v624 = *a2;
          if ((v624 - 65) < 0x1A) {
            v624 |= 0x20u;
          }
          int v625 = llparse_blob9[v623];
          if (v623 == 9)
          {
            int v622 = 0;
            int v626 = 5;
          }
          else
          {
            int v626 = 0;
          }
          if (v624 != v625)
          {
            int v622 = 2;
            int v626 = 5;
          }
          if (v626) {
            break;
          }
          if (v624 == v625) {
            ++v623;
          }
          if (++a2 == a3)
          {
            int v622 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v623;
            goto LABEL_2008;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_2008:
        char v621 = 2;
        if (!v622) {
          goto LABEL_2091;
        }
        if (v622 == 2) {
          goto LABEL_1701;
        }
      }
      return 82;
    case 85:
LABEL_2035:
      if (a2 == a3) {
        return 85;
      }
      int v638 = 0;
      unsigned int v639 = *(_DWORD *)a1;
      while (1)
      {
        int v640 = *a2;
        if ((v640 - 65) < 0x1A) {
          v640 |= 0x20u;
        }
        int v641 = llparse_blob10[v639];
        if (v639 == 14)
        {
          int v638 = 0;
          int v642 = 5;
        }
        else
        {
          int v642 = 0;
        }
        if (v640 != v641)
        {
          int v638 = 2;
          int v642 = 5;
        }
        if (v642) {
          break;
        }
        if (v640 == v641) {
          ++v639;
        }
        if (++a2 == a3)
        {
          int v638 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v639;
          goto LABEL_2050;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_2050:
      char v621 = 1;
      if (!v638) {
        goto LABEL_2091;
      }
      if (v638 != 2) {
        return 85;
      }
      goto LABEL_1701;
    case 86:
LABEL_2054:
      if (a2 == a3) {
        return 86;
      }
      int v643 = 0;
      unsigned int v644 = *(_DWORD *)a1;
      while (1)
      {
        int v645 = *a2;
        if ((v645 - 65) < 0x1A) {
          v645 |= 0x20u;
        }
        int v646 = llparse_blob11[v644];
        if (v644 == 15)
        {
          int v643 = 0;
          int v647 = 5;
        }
        else
        {
          int v647 = 0;
        }
        if (v645 != v646)
        {
          int v643 = 2;
          int v647 = 5;
        }
        if (v647) {
          break;
        }
        if (v645 == v646) {
          ++v644;
        }
        if (++a2 == a3)
        {
          int v643 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v644;
          goto LABEL_2069;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_2069:
      char v621 = 3;
      if (!v643) {
        goto LABEL_2091;
      }
      if (v643 != 2) {
        return 86;
      }
      goto LABEL_1701;
    case 87:
LABEL_2073:
      if (a2 == a3) {
        return 87;
      }
      int v648 = 0;
      unsigned int v649 = *(_DWORD *)a1;
      while (1)
      {
        int v650 = *a2;
        if ((v650 - 65) < 0x1A) {
          v650 |= 0x20u;
        }
        int v651 = llparse_blob12[v649];
        if (v649 == 5)
        {
          int v648 = 0;
          int v652 = 5;
        }
        else
        {
          int v652 = 0;
        }
        if (v650 != v651)
        {
          int v648 = 2;
          int v652 = 5;
        }
        if (v652) {
          break;
        }
        if (v650 == v651) {
          ++v649;
        }
        if (++a2 == a3)
        {
          int v648 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v649;
          goto LABEL_2088;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_2088:
      char v621 = 4;
      if (!v648) {
        goto LABEL_2091;
      }
      if (v648 != 2) {
        return 87;
      }
      goto LABEL_1701;
    case 88:
      goto LABEL_1944;
    case 89:
      goto LABEL_1942;
    case 90:
      goto LABEL_1938;
    case 91:
      goto LABEL_1269;
    case 92:
      goto LABEL_1137;
    case 93:
LABEL_1122:
      if (a2 == a3) {
        return 93;
      }
      int v327 = *a2;
      if (v327 == 9 || v327 == 12) {
        goto LABEL_1402;
      }
      ++a2;
      goto LABEL_1137;
    case 94:
      goto LABEL_1134;
    case 95:
LABEL_1131:
      if (a2 == a3) {
        return 95;
      }
      int v333 = *a2;
      if (v333 == 13)
      {
        ++a2;
LABEL_1134:
        if (a2 == a3) {
          return 94;
        }
        v319 = a2;
        if (*a2 == 10)
        {
          ++a2;
LABEL_1137:
          if (a2 == a3) {
            return 92;
          }
          int v334 = *a2;
          if (v334 != 9 && v334 != 12)
          {
            *(_WORD *)(a1 + 74) = 2304;
            uint64_t v336 = *(void *)(a1 + 88);
            if (!v336) {
              goto LABEL_1269;
            }
            v337 = *(uint64_t (**)(uint64_t))(v336 + 96);
            if (!v337) {
              goto LABEL_1269;
            }
            int v338 = v337(a1);
            if (!v338) {
              goto LABEL_1269;
            }
            if (v338 == 21)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 21;
              uint64_t v80 = "on_url_complete pause";
LABEL_1147:
              *(void *)(a1 + 32) = v80;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 91;
              return result;
            }
LABEL_1439:
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 26;
            goto LABEL_2263;
          }
          goto LABEL_1402;
        }
      }
      else
      {
        BOOL v389 = v333 == 9 || v333 == 12;
        v319 = a2;
        if (v389) {
          goto LABEL_1402;
        }
      }
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = 7;
      v321 = "Expected CRLF";
      goto LABEL_2194;
    case 96:
      goto LABEL_1283;
    case 97:
      goto LABEL_2348;
    case 98:
      goto LABEL_1264;
    case 99:
      goto LABEL_1259;
    case 100:
      goto LABEL_1258;
    case 101:
      goto LABEL_1255;
    case 102:
    case 219:
      goto LABEL_1282;
    case 103:
    case 220:
LABEL_1477:
      uint64_t result = 0;
      *(_DWORD *)(a1 + 24) = 9;
      unint64_t v7 = "Invalid minor version";
      goto LABEL_2263;
    case 104:
      goto LABEL_1233;
    case 105:
    case 222:
      goto LABEL_1416;
    case 106:
      goto LABEL_1230;
    case 107:
    case 224:
      goto LABEL_1409;
    case 108:
      goto LABEL_1227;
    case 109:
      goto LABEL_1225;
    case 110:
      goto LABEL_1192;
    case 111:
      goto LABEL_1210;
    case 112:
      goto LABEL_1173;
    case 113:
      goto LABEL_1165;
    case 114:
      goto LABEL_1157;
    case 115:
LABEL_1151:
      if (a2 == a3) {
        return 115;
      }
      int v343 = *a2;
      if (v343 == 9 || v343 == 12) {
        goto LABEL_1402;
      }
      ++a2;
LABEL_1157:
      if (a2 == a3) {
        return 114;
      }
      int v345 = *a2;
      if (v345 == 9 || v345 == 12) {
        goto LABEL_1402;
      }
      uint64_t v347 = *(void *)(a1 + 88);
      if (v347)
      {
        v348 = *(uint64_t (**)(uint64_t))(v347 + 96);
        if (v348)
        {
          int v349 = v348(a1);
          if (v349)
          {
            if (v349 == 21)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 21;
              *(void *)(a1 + 32) = "on_url_complete pause";
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 113;
              return result;
            }
            goto LABEL_1439;
          }
        }
      }
LABEL_1165:
      uint64_t result = 113;
      if (a2 == a3) {
        return result;
      }
      while (1)
      {
        int v350 = *a2;
        if (v350 != 32) {
          break;
        }
        if (++a2 == a3) {
          return result;
        }
      }
      if (v350 != 72)
      {
        if (v350 == 73)
        {
          ++a2;
LABEL_1210:
          if (a2 != a3)
          {
            int v363 = 0;
            unsigned int v364 = *(_DWORD *)a1;
            while (1)
            {
              int v365 = *a2;
              int v366 = llparse_blob15[v364];
              if (v364 == 2)
              {
                int v363 = 0;
                int v367 = 5;
              }
              else
              {
                int v367 = 0;
              }
              if (v365 != v366)
              {
                int v363 = 2;
                int v367 = 5;
              }
              if (v367) {
                break;
              }
              if (v365 == v366) {
                ++v364;
              }
              if (++a2 == a3)
              {
                int v363 = 1;
                a2 = a3;
                *(_DWORD *)a1 = v364;
                goto LABEL_1223;
              }
            }
            *(_DWORD *)a1 = 0;
LABEL_1223:
            if (!v363)
            {
              ++a2;
              if (*(unsigned char *)(a1 + 73) != 33)
              {
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = 8;
                unint64_t v7 = "Expected SOURCE method for ICE/x.x request";
                goto LABEL_2263;
              }
              goto LABEL_1225;
            }
            if (v363 != 1) {
              goto LABEL_1308;
            }
          }
          return 111;
        }
        if (v350 != 82) {
          goto LABEL_1308;
        }
        ++a2;
LABEL_1173:
        if (a2 != a3)
        {
          int v351 = 0;
          unsigned int v352 = *(_DWORD *)a1;
          while (1)
          {
            int v353 = *a2;
            int v354 = llparse_blob16[v352];
            if (v352 == 3)
            {
              int v351 = 0;
              int v355 = 5;
            }
            else
            {
              int v355 = 0;
            }
            if (v353 != v354)
            {
              int v351 = 2;
              int v355 = 5;
            }
            if (v355) {
              break;
            }
            if (v353 == v354) {
              ++v352;
            }
            if (++a2 == a3)
            {
              int v351 = 1;
              a2 = a3;
              *(_DWORD *)a1 = v352;
              goto LABEL_1186;
            }
          }
          *(_DWORD *)a1 = 0;
LABEL_1186:
          if (!v351)
          {
            ++a2;
            unsigned int v356 = *(unsigned __int8 *)(a1 + 73);
            if (v356 - 35 >= 0xB && (v356 > 6 || ((1 << v356) & 0x4A) == 0))
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 8;
              unint64_t v7 = "Invalid method for RTSP/x.x request";
              goto LABEL_2263;
            }
LABEL_1225:
            if (a2 == a3) {
              return 109;
            }
            *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
            *(void *)(a1 + 16) = llhttp__on_version;
LABEL_1227:
            if (a2 == a3) {
              return 108;
            }
            unsigned int v368 = *a2 - 48;
            if (v368 >= 0xA)
            {
              uint64_t v400 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v401 = *(void *)(a1 + 88);
              if (v401)
              {
                v402 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v401 + 32);
                if (v402)
                {
                  int v403 = v402(a1, v400, &a2[-v400]);
                  if (v403)
                  {
                    int v404 = v403;
                    if (v403 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_version";
                      int v404 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v404;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 107;
                    return result;
                  }
                }
              }
LABEL_1409:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 9;
              unint64_t v7 = "Invalid major version";
              goto LABEL_2263;
            }
            ++a2;
            *(unsigned char *)(a1 + 74) = v368;
LABEL_1230:
            if (a2 == a3) {
              return 106;
            }
            if (*a2 != 46)
            {
              uint64_t v405 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v406 = *(void *)(a1 + 88);
              if (v406)
              {
                v407 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v406 + 32);
                if (v407)
                {
                  int v408 = v407(a1, v405, &a2[-v405]);
                  if (v408)
                  {
                    int v409 = v408;
                    if (v408 == -1)
                    {
                      *(void *)(a1 + 32) = "Span callback error in on_version";
                      int v409 = 24;
                    }
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = v409;
                    *(void *)(a1 + 40) = a2;
                    *(void *)(a1 + 56) = 105;
                    return result;
                  }
                }
              }
LABEL_1416:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 9;
              unint64_t v7 = "Expected dot";
              goto LABEL_2263;
            }
            ++a2;
LABEL_1233:
            if (a2 == a3) {
              return 104;
            }
            char v369 = 0;
            char v370 = 0;
            char v371 = 1;
            char v372 = 1;
            switch(*a2)
            {
              case '0':
                goto LABEL_1247;
              case '1':
                char v371 = 0;
                char v369 = 0;
                char v370 = 1;
                goto LABEL_1247;
              case '2':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 2;
                goto LABEL_1247;
              case '3':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 3;
                goto LABEL_1247;
              case '4':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 4;
                goto LABEL_1247;
              case '5':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 5;
                goto LABEL_1247;
              case '6':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 6;
                goto LABEL_1247;
              case '7':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 7;
                goto LABEL_1247;
              case '8':
                char v371 = 0;
                char v369 = 0;
                char v372 = 0;
                char v370 = 8;
                goto LABEL_1247;
              case '9':
                char v371 = 0;
                char v372 = 0;
                char v370 = 9;
                char v369 = 1;
LABEL_1247:
                ++a2;
                *(unsigned char *)(a1 + 75) = v370;
                if ((*(_WORD *)(a1 + 78) & 0x10) != 0) {
                  goto LABEL_1252;
                }
                int v373 = *(unsigned __int8 *)(a1 + 74);
                if (*(unsigned char *)(a1 + 74))
                {
                  if (v373 != 1)
                  {
                    if (v373 == 2 && (v371 & 1) != 0) {
                      goto LABEL_1252;
                    }
LABEL_1276:
                    uint64_t v383 = *(void *)(a1 + 8);
                    *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                    uint64_t v384 = *(void *)(a1 + 88);
                    if (v384)
                    {
                      v385 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v384 + 32);
                      if (v385)
                      {
                        int v386 = v385(a1, v383, &a2[-v383]);
                        if (v386)
                        {
                          int v387 = v386;
                          if (v386 == -1)
                          {
                            *(void *)(a1 + 32) = "Span callback error in on_version";
                            int v387 = 24;
                          }
                          uint64_t result = 0;
                          *(_DWORD *)(a1 + 24) = v387;
                          *(void *)(a1 + 40) = a2;
                          *(void *)(a1 + 56) = 102;
                          return result;
                        }
                      }
                    }
LABEL_1282:
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = 9;
                    unint64_t v7 = "Invalid HTTP version";
                    goto LABEL_2263;
                  }
                  if ((v372 & 1) == 0) {
                    goto LABEL_1276;
                  }
                }
                else if ((v369 & 1) == 0)
                {
                  goto LABEL_1276;
                }
LABEL_1252:
                uint64_t v374 = *(void *)(a1 + 8);
                *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                uint64_t v375 = *(void *)(a1 + 88);
                if (v375)
                {
                  v376 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v375 + 32);
                  if (v376)
                  {
                    int v377 = v376(a1, v374, &a2[-v374]);
                    if (v377)
                    {
                      int v412 = v377;
                      if (v377 == -1)
                      {
                        *(void *)(a1 + 32) = "Span callback error in on_version";
                        int v412 = 24;
                      }
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = v412;
                      *(void *)(a1 + 40) = a2;
                      *(void *)(a1 + 56) = 101;
                      return result;
                    }
                  }
                }
LABEL_1255:
                uint64_t v378 = *(void *)(a1 + 88);
                if (v378)
                {
                  v379 = *(uint64_t (**)(uint64_t))(v378 + 120);
                  if (v379)
                  {
                    int v380 = v379(a1);
                    if (v380)
                    {
                      if (v380 == 21)
                      {
                        uint64_t result = 0;
                        *(_DWORD *)(a1 + 24) = 21;
                        *(void *)(a1 + 32) = "on_version_complete pause";
                        *(void *)(a1 + 40) = a2;
                        *(void *)(a1 + 56) = 100;
                        return result;
                      }
LABEL_1427:
                      uint64_t result = 0;
                      *(_DWORD *)(a1 + 24) = 33;
                      goto LABEL_2263;
                    }
                  }
                }
LABEL_1258:
                if (*(unsigned char *)(a1 + 73) != 34)
                {
LABEL_1259:
                  if (a2 == a3) {
                    return 99;
                  }
                  int v381 = *a2;
                  if (v381 == 10)
                  {
                    if ((*(_WORD *)(a1 + 78) & 0x100) != 0) {
                      goto LABEL_1264;
                    }
                  }
                  else if (v381 == 13)
                  {
                    ++a2;
LABEL_1264:
                    if (a2 == a3) {
                      return 98;
                    }
                    int v382 = *a2;
                    if (v382 == 13) {
                      goto LABEL_2347;
                    }
                    if (v382 == 10)
                    {
                      ++a2;
                      goto LABEL_1269;
                    }
                    if ((*(_WORD *)(a1 + 78) & 0x40) != 0) {
                      goto LABEL_1269;
                    }
                    uint64_t result = 0;
                    int v410 = 2;
LABEL_1454:
                    *(_DWORD *)(a1 + 24) = v410;
                    unint64_t v7 = "Expected CRLF after version";
                    goto LABEL_2263;
                  }
                  uint64_t result = 0;
                  int v410 = 9;
                  goto LABEL_1454;
                }
LABEL_1283:
                if (a2 == a3) {
                  return 96;
                }
                uint64_t result = llparse__match_sequence_id((unsigned int *)a1, a2, a3, (uint64_t)&llparse_blob14, 10);
                if (result)
                {
                  if (result != 1)
                  {
                    if (result != 2) {
LABEL_2346:
                    }
                      abort();
                    uint64_t result = 0;
                    *(_DWORD *)(a1 + 24) = 9;
                    *(void *)(a1 + 32) = "Expected HTTP/2 Connection Preface";
                    *(void *)(a1 + 40) = v388;
                    *(void *)(a1 + 56) = 0;
                    return result;
                  }
                  return 96;
                }
                v319 = (unsigned __int8 *)(v388 + 1);
                *(_DWORD *)(a1 + 24) = 23;
                v321 = "Pause on PRI/Upgrade";
LABEL_2194:
                *(void *)(a1 + 32) = v321;
                *(void *)(a1 + 40) = v319;
                *(void *)(a1 + 56) = 0;
                return result;
              default:
                uint64_t v424 = *(void *)(a1 + 8);
                *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
                uint64_t v425 = *(void *)(a1 + 88);
                if (!v425) {
                  goto LABEL_1477;
                }
                v426 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v425 + 32);
                if (!v426) {
                  goto LABEL_1477;
                }
                int v427 = v426(a1, v424, &a2[-v424]);
                if (!v427) {
                  goto LABEL_1477;
                }
                int v428 = v427;
                if (v427 == -1)
                {
                  *(void *)(a1 + 32) = "Span callback error in on_version";
                  int v428 = 24;
                }
                uint64_t result = 0;
                *(_DWORD *)(a1 + 24) = v428;
                *(void *)(a1 + 40) = a2;
                *(void *)(a1 + 56) = 103;
                return result;
            }
          }
          if (v351 != 1) {
            goto LABEL_1308;
          }
        }
        return 112;
      }
      ++a2;
LABEL_1192:
      if (a2 != a3)
      {
        int v357 = 0;
        unsigned int v358 = *(_DWORD *)a1;
        while (1)
        {
          int v359 = *a2;
          int v360 = llparse_blob13[v358];
          if (v358 == 3)
          {
            int v357 = 0;
            int v361 = 5;
          }
          else
          {
            int v361 = 0;
          }
          if (v359 != v360)
          {
            int v357 = 2;
            int v361 = 5;
          }
          if (v361) {
            break;
          }
          if (v359 == v360) {
            ++v358;
          }
          if (++a2 == a3)
          {
            int v357 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v358;
            goto LABEL_1205;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_1205:
        if (!v357)
        {
          ++a2;
          unsigned int v362 = *(unsigned __int8 *)(a1 + 73);
          if (v362 >= 0x23 && v362 != 46)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 8;
            unint64_t v7 = "Invalid method for HTTP/x.x request";
            goto LABEL_2263;
          }
          goto LABEL_1225;
        }
        if (v357 != 1) {
          goto LABEL_1308;
        }
      }
      return 110;
    case 116:
      goto LABEL_1113;
    case 117:
LABEL_1111:
      if (a2 == a3) {
        return 117;
      }
LABEL_1112:
      ++a2;
LABEL_1113:
      if (a2 == a3) {
        return 116;
      }
      uint64_t result = 116;
      do
      {
        if (llhttp__internal__run_lookup_table_21[*a2] != 5)
        {
          switch(*a2)
          {
            case 9u:
            case 0xCu:
              goto LABEL_1402;
            case 0xAu:
              goto LABEL_1119;
            case 0xDu:
              goto LABEL_1128;
            case 0x20u:
              goto LABEL_1148;
            default:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 7;
              unint64_t v7 = "Invalid char in url fragment start";
              goto LABEL_2263;
          }
        }
        ++a2;
      }
      while (a2 != a3);
      return result;
    case 118:
LABEL_1105:
      if (a2 == a3) {
        return 118;
      }
      uint64_t result = 118;
      do
      {
        if (llhttp__internal__run_lookup_table_22[*a2] != 5)
        {
          switch((unint64_t)*a2)
          {
            case 9uLL:
            case 0xCuLL:
            case 0x109uLL:
            case 0x10CuLL:
            case 0x209uLL:
            case 0x20CuLL:
              goto LABEL_1402;
            case 0xAuLL:
            case 0x121uLL:
            case 0x122uLL:
            case 0x124uLL:
            case 0x125uLL:
            case 0x126uLL:
            case 0x127uLL:
            case 0x128uLL:
            case 0x129uLL:
            case 0x12AuLL:
            case 0x12BuLL:
            case 0x12CuLL:
            case 0x12DuLL:
            case 0x12EuLL:
            case 0x12FuLL:
            case 0x130uLL:
            case 0x131uLL:
            case 0x132uLL:
            case 0x133uLL:
            case 0x134uLL:
            case 0x135uLL:
            case 0x136uLL:
            case 0x137uLL:
            case 0x138uLL:
            case 0x139uLL:
            case 0x13AuLL:
            case 0x13BuLL:
            case 0x13CuLL:
            case 0x13DuLL:
            case 0x13EuLL:
            case 0x140uLL:
            case 0x141uLL:
            case 0x142uLL:
            case 0x143uLL:
            case 0x144uLL:
            case 0x145uLL:
            case 0x146uLL:
            case 0x147uLL:
            case 0x148uLL:
            case 0x149uLL:
            case 0x14AuLL:
            case 0x14BuLL:
            case 0x14CuLL:
            case 0x14DuLL:
            case 0x14EuLL:
            case 0x14FuLL:
            case 0x150uLL:
            case 0x151uLL:
            case 0x152uLL:
            case 0x153uLL:
            case 0x154uLL:
            case 0x155uLL:
            case 0x156uLL:
            case 0x157uLL:
            case 0x158uLL:
            case 0x159uLL:
            case 0x15AuLL:
            case 0x15BuLL:
            case 0x15CuLL:
            case 0x15DuLL:
            case 0x15EuLL:
            case 0x15FuLL:
            case 0x160uLL:
            case 0x161uLL:
            case 0x162uLL:
            case 0x163uLL:
            case 0x164uLL:
            case 0x165uLL:
            case 0x166uLL:
            case 0x167uLL:
            case 0x168uLL:
            case 0x169uLL:
            case 0x16AuLL:
            case 0x16BuLL:
            case 0x16CuLL:
            case 0x16DuLL:
            case 0x16EuLL:
            case 0x16FuLL:
            case 0x170uLL:
            case 0x171uLL:
            case 0x172uLL:
            case 0x173uLL:
            case 0x174uLL:
            case 0x175uLL:
            case 0x176uLL:
            case 0x177uLL:
            case 0x178uLL:
            case 0x179uLL:
            case 0x17AuLL:
            case 0x17BuLL:
            case 0x17CuLL:
            case 0x17DuLL:
            case 0x17EuLL:
            case 0x20AuLL:
              goto LABEL_1119;
            case 0xDuLL:
            case 0x20DuLL:
              goto LABEL_1128;
            case 0x20uLL:
            case 0x220uLL:
              goto LABEL_1148;
            case 0x23uLL:
            case 0x22FuLL:
              goto LABEL_1111;
            default:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 7;
              unint64_t v7 = "Invalid char in url query";
              goto LABEL_2263;
          }
        }
        ++a2;
      }
      while (a2 != a3);
      return result;
    case 119:
      goto LABEL_1102;
    case 120:
      goto LABEL_1096;
    case 121:
      goto LABEL_1083;
    case 122:
LABEL_1081:
      if (a2 != a3) {
        goto LABEL_1095;
      }
      return 122;
    case 123:
LABEL_1094:
      if (a2 != a3) {
        goto LABEL_1095;
      }
      return 123;
    case 124:
LABEL_1090:
      if (a2 != a3)
      {
        switch((unint64_t)*a2)
        {
          case 9uLL:
          case 0xCuLL:
          case 0x109uLL:
          case 0x10AuLL:
          case 0x10CuLL:
          case 0x10DuLL:
          case 0x120uLL:
          case 0x209uLL:
          case 0x20AuLL:
          case 0x20CuLL:
          case 0x20DuLL:
          case 0x220uLL:
            goto LABEL_1402;
          case 0xAuLL:
          case 0x13AuLL:
          case 0x22AuLL:
          case 0x22FuLL:
            goto LABEL_1119;
          case 0xDuLL:
          case 0x141uLL:
          case 0x142uLL:
          case 0x143uLL:
          case 0x144uLL:
          case 0x145uLL:
          case 0x146uLL:
          case 0x147uLL:
          case 0x148uLL:
          case 0x149uLL:
          case 0x14AuLL:
          case 0x14BuLL:
          case 0x14CuLL:
          case 0x14DuLL:
          case 0x14EuLL:
          case 0x14FuLL:
          case 0x150uLL:
          case 0x151uLL:
          case 0x152uLL:
          case 0x153uLL:
          case 0x154uLL:
          case 0x155uLL:
          case 0x156uLL:
          case 0x157uLL:
          case 0x158uLL:
          case 0x159uLL:
          case 0x15AuLL:
          case 0x161uLL:
          case 0x162uLL:
          case 0x163uLL:
          case 0x164uLL:
          case 0x165uLL:
          case 0x166uLL:
          case 0x167uLL:
          case 0x168uLL:
          case 0x169uLL:
          case 0x16AuLL:
          case 0x16BuLL:
          case 0x16CuLL:
          case 0x16DuLL:
          case 0x16EuLL:
          case 0x16FuLL:
          case 0x170uLL:
          case 0x171uLL:
          case 0x172uLL:
          case 0x173uLL:
          case 0x174uLL:
          case 0x175uLL:
          case 0x176uLL:
          case 0x177uLL:
          case 0x178uLL:
          case 0x179uLL:
          case 0x17AuLL:
          case 0x241uLL:
          case 0x242uLL:
          case 0x243uLL:
          case 0x244uLL:
          case 0x245uLL:
          case 0x246uLL:
          case 0x247uLL:
          case 0x248uLL:
          case 0x249uLL:
          case 0x24AuLL:
          case 0x24BuLL:
          case 0x24CuLL:
          case 0x24DuLL:
          case 0x24EuLL:
          case 0x24FuLL:
          case 0x250uLL:
          case 0x251uLL:
          case 0x252uLL:
          case 0x253uLL:
          case 0x254uLL:
          case 0x255uLL:
          case 0x256uLL:
          case 0x257uLL:
          case 0x258uLL:
          case 0x259uLL:
          case 0x25AuLL:
          case 0x261uLL:
          case 0x262uLL:
          case 0x263uLL:
          case 0x264uLL:
          case 0x265uLL:
          case 0x266uLL:
          case 0x267uLL:
          case 0x268uLL:
          case 0x269uLL:
          case 0x26AuLL:
          case 0x26BuLL:
          case 0x26CuLL:
          case 0x26DuLL:
          case 0x26EuLL:
          case 0x26FuLL:
          case 0x270uLL:
          case 0x271uLL:
          case 0x272uLL:
          case 0x273uLL:
          case 0x274uLL:
          case 0x275uLL:
          case 0x276uLL:
          case 0x277uLL:
          case 0x278uLL:
          case 0x279uLL:
          case 0x27AuLL:
            goto LABEL_1128;
          case 0x20uLL:
            goto LABEL_1148;
          case 0x21uLL:
          case 0x24uLL:
          case 0x25uLL:
          case 0x26uLL:
          case 0x27uLL:
          case 0x28uLL:
          case 0x29uLL:
          case 0x2AuLL:
          case 0x2BuLL:
          case 0x2CuLL:
          case 0x2DuLL:
          case 0x2EuLL:
          case 0x30uLL:
          case 0x31uLL:
          case 0x32uLL:
          case 0x33uLL:
          case 0x34uLL:
          case 0x35uLL:
          case 0x36uLL:
          case 0x37uLL:
          case 0x38uLL:
          case 0x39uLL:
          case 0x3AuLL:
          case 0x3BuLL:
          case 0x3DuLL:
          case 0x41uLL:
          case 0x42uLL:
          case 0x43uLL:
          case 0x44uLL:
          case 0x45uLL:
          case 0x46uLL:
          case 0x47uLL:
          case 0x48uLL:
          case 0x49uLL:
          case 0x4AuLL:
          case 0x4BuLL:
          case 0x4CuLL:
          case 0x4DuLL:
          case 0x4EuLL:
          case 0x4FuLL:
          case 0x50uLL:
          case 0x51uLL:
          case 0x52uLL:
          case 0x53uLL:
          case 0x54uLL:
          case 0x55uLL:
          case 0x56uLL:
          case 0x57uLL:
          case 0x58uLL:
          case 0x59uLL:
          case 0x5AuLL:
          case 0x5BuLL:
          case 0x5DuLL:
          case 0x5FuLL:
          case 0x61uLL:
          case 0x62uLL:
          case 0x63uLL:
          case 0x64uLL:
          case 0x65uLL:
          case 0x66uLL:
          case 0x67uLL:
          case 0x68uLL:
          case 0x69uLL:
          case 0x6AuLL:
          case 0x6BuLL:
          case 0x6CuLL:
          case 0x6DuLL:
          case 0x6EuLL:
          case 0x6FuLL:
          case 0x70uLL:
          case 0x71uLL:
          case 0x72uLL:
          case 0x73uLL:
          case 0x74uLL:
          case 0x75uLL:
          case 0x76uLL:
          case 0x77uLL:
          case 0x78uLL:
          case 0x79uLL:
          case 0x7AuLL:
          case 0x7EuLL:
            if (++a2 == a3) {
              return 125;
            }
            goto LABEL_1076;
          case 0x2FuLL:
            goto LABEL_1094;
          case 0x3FuLL:
            goto LABEL_1104;
          case 0x40uLL:
            uint64_t result = 0;
            v319 = a2 + 1;
            *(_DWORD *)(a1 + 24) = 7;
            v321 = "Double @ in url";
            goto LABEL_2194;
          default:
            goto LABEL_1238;
        }
      }
      return 124;
    case 125:
      goto LABEL_1075;
    case 126:
      goto LABEL_1072;
    case 127:
      goto LABEL_1069;
    case 128:
      goto LABEL_1067;
    case 129:
      goto LABEL_1060;
    case 130:
      goto LABEL_1057;
    case 131:
      goto LABEL_1055;
    case 132:
      goto LABEL_1050;
    case 133:
      goto LABEL_1047;
    case 134:
      goto LABEL_1042;
    case 135:
      goto LABEL_1034;
    case 136:
      goto LABEL_1031;
    case 137:
    case 228:
      goto LABEL_1028;
    case 138:
      goto LABEL_67;
    case 139:
      goto LABEL_85;
    case 140:
LABEL_63:
      if (a2 == a3) {
        return 140;
      }
      int v28 = *a2;
      if (v28 != 78)
      {
        if (v28 != 67) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_67:
        if (a2 == a3) {
          return 138;
        }
        if (*a2 != 76) {
          goto LABEL_1301;
        }
        ++a2;
        LOBYTE(v29) = 19;
        goto LABEL_1025;
      }
      ++a2;
LABEL_85:
      if (a2 == a3) {
        return 139;
      }
      int v35 = 0;
      unsigned int v36 = *(_DWORD *)a1;
      while (1)
      {
        int v37 = *a2;
        int v38 = llparse_blob17[v36];
        if (v36 == 5)
        {
          int v35 = 0;
          int v39 = 5;
        }
        else
        {
          int v39 = 0;
        }
        if (v37 != v38)
        {
          int v35 = 2;
          int v39 = 5;
        }
        if (v39) {
          break;
        }
        if (v37 == v38) {
          ++v36;
        }
        if (++a2 == a3)
        {
          int v35 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v36;
          goto LABEL_123;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_123:
      if (!v35)
      {
        ++a2;
        LOBYTE(v29) = 36;
        goto LABEL_1025;
      }
      if (v35 == 1) {
        return 139;
      }
      goto LABEL_1301;
    case 141:
LABEL_211:
      if (a2 == a3) {
        return 141;
      }
      int v90 = 0;
      unsigned int v91 = *(_DWORD *)a1;
      while (1)
      {
        int v92 = *a2;
        int v93 = llparse_blob18[v91];
        if (v91 == 2)
        {
          int v90 = 0;
          int v94 = 5;
        }
        else
        {
          int v94 = 0;
        }
        if (v92 != v93)
        {
          int v90 = 2;
          int v94 = 5;
        }
        if (v94) {
          break;
        }
        if (v92 == v93) {
          ++v91;
        }
        if (++a2 == a3)
        {
          int v90 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v91;
          goto LABEL_224;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_224:
      if (!v90)
      {
        ++a2;
        LOBYTE(v29) = 16;
        goto LABEL_1025;
      }
      if (v90 == 1) {
        return 141;
      }
      goto LABEL_1301;
    case 142:
      goto LABEL_233;
    case 143:
      goto LABEL_251;
    case 144:
      goto LABEL_265;
    case 145:
      goto LABEL_247;
    case 146:
LABEL_229:
      if (a2 == a3) {
        return 146;
      }
      int v95 = *a2;
      if (v95 != 79)
      {
        if (v95 != 72) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_233:
        if (a2 == a3) {
          return 142;
        }
        int v96 = 0;
        unsigned int v97 = *(_DWORD *)a1;
        while (1)
        {
          int v98 = *a2;
          int v99 = llparse_blob19[v97];
          if (v97 == 5)
          {
            int v96 = 0;
            int v100 = 5;
          }
          else
          {
            int v100 = 0;
          }
          if (v98 != v99)
          {
            int v96 = 2;
            int v100 = 5;
          }
          if (v100) {
            break;
          }
          if (v98 == v99) {
            ++v97;
          }
          if (++a2 == a3)
          {
            int v96 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v97;
            goto LABEL_268;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_268:
        if (!v96)
        {
          ++a2;
          LOBYTE(v29) = 22;
          goto LABEL_1025;
        }
        if (v96 == 1) {
          return 142;
        }
        goto LABEL_1301;
      }
      ++a2;
LABEL_247:
      if (a2 == a3) {
        return 145;
      }
      int v101 = *a2;
      if (v101 != 80)
      {
        if (v101 != 78) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_251:
        if (a2 == a3) {
          return 143;
        }
        int v102 = 0;
        unsigned int v103 = *(_DWORD *)a1;
        while (1)
        {
          int v104 = *a2;
          int v105 = llparse_blob20[v103];
          if (v103 == 3)
          {
            int v102 = 0;
            int v106 = 5;
          }
          else
          {
            int v106 = 0;
          }
          if (v104 != v105)
          {
            int v102 = 2;
            int v106 = 5;
          }
          if (v106) {
            break;
          }
          if (v104 == v105) {
            ++v103;
          }
          if (++a2 == a3)
          {
            int v102 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v103;
            goto LABEL_270;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_270:
        if (!v102)
        {
          ++a2;
          LOBYTE(v29) = 5;
          goto LABEL_1025;
        }
        if (v102 == 1) {
          return 143;
        }
        goto LABEL_1301;
      }
      ++a2;
LABEL_265:
      if (a2 == a3) {
        return 144;
      }
      if (*a2 != 89) {
        goto LABEL_1301;
      }
      ++a2;
      LOBYTE(v29) = 8;
      goto LABEL_1025;
    case 147:
      goto LABEL_284;
    case 148:
      goto LABEL_298;
    case 149:
      goto LABEL_280;
    case 150:
LABEL_277:
      if (a2 == a3) {
        return 150;
      }
      if (*a2 != 69) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_280:
      if (a2 == a3) {
        return 149;
      }
      int v107 = *a2;
      if (v107 == 83)
      {
        ++a2;
LABEL_298:
        if (a2 == a3) {
          return 148;
        }
        int v112 = 0;
        unsigned int v113 = *(_DWORD *)a1;
        while (1)
        {
          int v114 = *a2;
          int v115 = llparse_blob22[v113];
          if (v113 == 4)
          {
            int v112 = 0;
            int v116 = 5;
          }
          else
          {
            int v116 = 0;
          }
          if (v114 != v115)
          {
            int v112 = 2;
            int v116 = 5;
          }
          if (v116) {
            break;
          }
          if (v114 == v115) {
            ++v113;
          }
          if (++a2 == a3)
          {
            int v112 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v113;
            goto LABEL_313;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_313:
        if (!v112)
        {
          ++a2;
          LOBYTE(v29) = 35;
          goto LABEL_1025;
        }
        if (v112 == 1) {
          return 148;
        }
      }
      else
      {
        if (v107 != 76) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_284:
        if (a2 == a3) {
          return 147;
        }
        int v29 = 0;
        unsigned int v108 = *(_DWORD *)a1;
        while (1)
        {
          int v109 = *a2;
          int v110 = llparse_blob21[v108];
          if (v108 == 2)
          {
            int v29 = 0;
            int v111 = 5;
          }
          else
          {
            int v111 = 0;
          }
          if (v109 != v110)
          {
            int v29 = 2;
            int v111 = 5;
          }
          if (v111) {
            break;
          }
          if (v109 == v110) {
            ++v108;
          }
          if (++a2 == a3)
          {
            int v29 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v108;
            goto LABEL_311;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_311:
        if (!v29)
        {
          ++a2;
          goto LABEL_1025;
        }
        if (v29 == 1) {
          return 147;
        }
      }
      goto LABEL_1301;
    case 151:
LABEL_320:
      if (a2 == a3) {
        return 151;
      }
      int v117 = 0;
      unsigned int v118 = *(_DWORD *)a1;
      while (1)
      {
        int v119 = *a2;
        int v120 = llparse_blob23[v118];
        if (v118 == 3)
        {
          int v117 = 0;
          int v121 = 5;
        }
        else
        {
          int v121 = 0;
        }
        if (v119 != v120)
        {
          int v117 = 2;
          int v121 = 5;
        }
        if (v121) {
          break;
        }
        if (v119 == v120) {
          ++v118;
        }
        if (++a2 == a3)
        {
          int v117 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v118;
          goto LABEL_333;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_333:
      if (!v117)
      {
        ++a2;
        LOBYTE(v29) = 45;
        goto LABEL_1025;
      }
      if (v117 == 1) {
        return 151;
      }
      goto LABEL_1301;
    case 152:
      goto LABEL_356;
    case 153:
      goto LABEL_353;
    case 154:
LABEL_338:
      if (a2 == a3) {
        return 154;
      }
      int v122 = 0;
      unsigned int v123 = *(_DWORD *)a1;
      while (1)
      {
        int v124 = *a2;
        int v125 = llparse_blob24[v123];
        if (v123 == 1)
        {
          int v122 = 0;
          int v126 = 5;
        }
        else
        {
          int v126 = 0;
        }
        if (v124 != v125)
        {
          int v122 = 2;
          int v126 = 5;
        }
        if (v126) {
          break;
        }
        if (v124 == v125) {
          ++v123;
        }
        if (++a2 == a3)
        {
          int v122 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v123;
          goto LABEL_351;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_351:
      if (v122)
      {
        if (v122 == 1) {
          return 154;
        }
        goto LABEL_1301;
      }
      ++a2;
LABEL_353:
      if (a2 == a3) {
        return 153;
      }
      LOBYTE(v29) = 1;
      if (*a2 != 95) {
        goto LABEL_1025;
      }
      ++a2;
LABEL_356:
      if (a2 == a3) {
        return 152;
      }
      int v127 = 0;
      unsigned int v128 = *(_DWORD *)a1;
      while (1)
      {
        int v129 = *a2;
        int v130 = llparse_blob25[v128];
        if (v128 == 8)
        {
          int v127 = 0;
          int v131 = 5;
        }
        else
        {
          int v131 = 0;
        }
        if (v129 != v130)
        {
          int v127 = 2;
          int v131 = 5;
        }
        if (v131) {
          break;
        }
        if (v129 == v130) {
          ++v128;
        }
        if (++a2 == a3)
        {
          int v127 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v128;
          goto LABEL_369;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_369:
      if (!v127)
      {
        ++a2;
        LOBYTE(v29) = 41;
        goto LABEL_1025;
      }
      if (v127 == 1) {
        return 152;
      }
      goto LABEL_1301;
    case 155:
LABEL_376:
      if (a2 == a3) {
        return 155;
      }
      int v132 = 0;
      unsigned int v133 = *(_DWORD *)a1;
      while (1)
      {
        int v134 = *a2;
        int v135 = llparse_blob26[v133];
        if (v133 == 2)
        {
          int v132 = 0;
          int v136 = 5;
        }
        else
        {
          int v136 = 0;
        }
        if (v134 != v135)
        {
          int v132 = 2;
          int v136 = 5;
        }
        if (v136) {
          break;
        }
        if (v134 == v135) {
          ++v133;
        }
        if (++a2 == a3)
        {
          int v132 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v133;
          goto LABEL_389;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_389:
      if (!v132)
      {
        ++a2;
        LOBYTE(v29) = 2;
        goto LABEL_1025;
      }
      if (v132 == 1) {
        return 155;
      }
      goto LABEL_1301;
    case 156:
      goto LABEL_398;
    case 157:
      goto LABEL_412;
    case 158:
LABEL_394:
      if (a2 == a3) {
        return 158;
      }
      int v137 = *a2;
      if (v137 == 79)
      {
        ++a2;
LABEL_412:
        if (a2 == a3) {
          return 157;
        }
        int v143 = 0;
        unsigned int v144 = *(_DWORD *)a1;
        while (1)
        {
          int v145 = *a2;
          int v146 = llparse_blob28[v144];
          if (v144 == 1)
          {
            int v143 = 0;
            int v147 = 5;
          }
          else
          {
            int v147 = 0;
          }
          if (v145 != v146)
          {
            int v143 = 2;
            int v147 = 5;
          }
          if (v147) {
            break;
          }
          if (v145 == v146) {
            ++v144;
          }
          if (++a2 == a3)
          {
            int v143 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v144;
            goto LABEL_427;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_427:
        if (!v143)
        {
          ++a2;
          LOBYTE(v29) = 9;
          goto LABEL_1025;
        }
        if (v143 == 1) {
          return 157;
        }
      }
      else
      {
        if (v137 != 73) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_398:
        if (a2 == a3) {
          return 156;
        }
        int v138 = 0;
        unsigned int v139 = *(_DWORD *)a1;
        while (1)
        {
          int v140 = *a2;
          int v141 = llparse_blob27[v139];
          if (v139 == 1)
          {
            int v138 = 0;
            int v142 = 5;
          }
          else
          {
            int v142 = 0;
          }
          if (v140 != v141)
          {
            int v138 = 2;
            int v142 = 5;
          }
          if (v142) {
            break;
          }
          if (v140 == v141) {
            ++v139;
          }
          if (++a2 == a3)
          {
            int v138 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v139;
            goto LABEL_425;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_425:
        if (!v138)
        {
          ++a2;
          LOBYTE(v29) = 31;
          goto LABEL_1025;
        }
        if (v138 == 1) {
          return 156;
        }
      }
      goto LABEL_1301;
    case 159:
LABEL_437:
      if (a2 == a3) {
        return 159;
      }
      int v148 = 0;
      unsigned int v149 = *(_DWORD *)a1;
      while (1)
      {
        int v150 = *a2;
        int v151 = llparse_blob29[v149];
        if (v149 == 5)
        {
          int v148 = 0;
          int v152 = 5;
        }
        else
        {
          int v152 = 0;
        }
        if (v150 != v151)
        {
          int v148 = 2;
          int v152 = 5;
        }
        if (v152) {
          break;
        }
        if (v150 == v151) {
          ++v149;
        }
        if (++a2 == a3)
        {
          int v148 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v149;
          goto LABEL_450;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_450:
      if (!v148)
      {
        ++a2;
        LOBYTE(v29) = 24;
        goto LABEL_1025;
      }
      if (v148 == 1) {
        return 159;
      }
      goto LABEL_1301;
    case 160:
LABEL_453:
      if (a2 == a3) {
        return 160;
      }
      int v153 = 0;
      unsigned int v154 = *(_DWORD *)a1;
      while (1)
      {
        int v155 = *a2;
        int v156 = llparse_blob30[v154];
        if (v154 == 2)
        {
          int v153 = 0;
          int v157 = 5;
        }
        else
        {
          int v157 = 0;
        }
        if (v155 != v156)
        {
          int v153 = 2;
          int v157 = 5;
        }
        if (v157) {
          break;
        }
        if (v155 == v156) {
          ++v154;
        }
        if (++a2 == a3)
        {
          int v153 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v154;
          goto LABEL_466;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_466:
      if (!v153)
      {
        ++a2;
        LOBYTE(v29) = 23;
        goto LABEL_1025;
      }
      if (v153 == 1) {
        return 160;
      }
      goto LABEL_1301;
    case 161:
      goto LABEL_473;
    case 162:
      goto LABEL_491;
    case 163:
      goto LABEL_505;
    case 164:
      goto LABEL_487;
    case 165:
LABEL_469:
      if (a2 == a3) {
        return 165;
      }
      int v158 = *a2;
      if (v158 != 67)
      {
        if (v158 != 65) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_473:
        if (a2 == a3) {
          return 161;
        }
        int v159 = 0;
        unsigned int v160 = *(_DWORD *)a1;
        while (1)
        {
          int v161 = *a2;
          int v162 = llparse_blob31[v160];
          if (v160 == 6)
          {
            int v159 = 0;
            int v163 = 5;
          }
          else
          {
            int v163 = 0;
          }
          if (v161 != v162)
          {
            int v159 = 2;
            int v163 = 5;
          }
          if (v163) {
            break;
          }
          if (v161 == v162) {
            ++v160;
          }
          if (++a2 == a3)
          {
            int v159 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v160;
            goto LABEL_508;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_508:
        if (!v159)
        {
          ++a2;
          LOBYTE(v29) = 21;
          goto LABEL_1025;
        }
        if (v159 == 1) {
          return 161;
        }
        goto LABEL_1301;
      }
      ++a2;
LABEL_487:
      if (a2 == a3) {
        return 164;
      }
      int v164 = *a2;
      if (v164 != 79)
      {
        if (v164 != 65) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_491:
        if (a2 == a3) {
          return 162;
        }
        int v165 = 0;
        unsigned int v166 = *(_DWORD *)a1;
        while (1)
        {
          int v167 = *a2;
          int v168 = llparse_blob32[v166];
          if (v166 == 5)
          {
            int v165 = 0;
            int v169 = 5;
          }
          else
          {
            int v169 = 0;
          }
          if (v167 != v168)
          {
            int v165 = 2;
            int v169 = 5;
          }
          if (v169) {
            break;
          }
          if (v167 == v168) {
            ++v166;
          }
          if (++a2 == a3)
          {
            int v165 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v166;
            goto LABEL_510;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_510:
        if (!v165)
        {
          ++a2;
          LOBYTE(v29) = 30;
          goto LABEL_1025;
        }
        if (v165 == 1) {
          return 162;
        }
        goto LABEL_1301;
      }
      ++a2;
LABEL_505:
      if (a2 == a3) {
        return 163;
      }
      if (*a2 != 76) {
        goto LABEL_1301;
      }
      ++a2;
      LOBYTE(v29) = 10;
      goto LABEL_1025;
    case 166:
LABEL_513:
      if (a2 == a3) {
        return 166;
      }
      int v170 = 0;
      unsigned int v171 = *(_DWORD *)a1;
      while (1)
      {
        int v172 = *a2;
        int v173 = llparse_blob33[v171];
        if (v171 == 1)
        {
          int v170 = 0;
          int v174 = 5;
        }
        else
        {
          int v174 = 0;
        }
        if (v172 != v173)
        {
          int v170 = 2;
          int v174 = 5;
        }
        if (v174) {
          break;
        }
        if (v172 == v173) {
          ++v171;
        }
        if (++a2 == a3)
        {
          int v170 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v171;
          goto LABEL_526;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_526:
      if (!v170)
      {
        ++a2;
        LOBYTE(v29) = 11;
        goto LABEL_1025;
      }
      if (v170 == 1) {
        return 166;
      }
      goto LABEL_1301;
    case 167:
LABEL_434:
      if (a2 != a3)
      {
        switch(*a2)
        {
          case '-':
            ++a2;
            goto LABEL_437;
          case 'E':
            ++a2;
            goto LABEL_453;
          case 'K':
            ++a2;
            goto LABEL_469;
          case 'O':
            ++a2;
            goto LABEL_513;
          default:
            goto LABEL_1301;
        }
      }
      return 167;
    case 168:
LABEL_539:
      if (a2 == a3) {
        return 168;
      }
      int v175 = 0;
      unsigned int v176 = *(_DWORD *)a1;
      while (1)
      {
        int v177 = *a2;
        int v178 = llparse_blob34[v176];
        if (v176 == 4)
        {
          int v175 = 0;
          int v179 = 5;
        }
        else
        {
          int v179 = 0;
        }
        if (v177 != v178)
        {
          int v175 = 2;
          int v179 = 5;
        }
        if (v179) {
          break;
        }
        if (v177 == v178) {
          ++v176;
        }
        if (++a2 == a3)
        {
          int v175 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v176;
          goto LABEL_552;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_552:
      if (!v175)
      {
        ++a2;
        LOBYTE(v29) = 25;
        goto LABEL_1025;
      }
      if (v175 == 1) {
        return 168;
      }
      goto LABEL_1301;
    case 169:
LABEL_557:
      if (a2 == a3) {
        return 169;
      }
      int v180 = 0;
      unsigned int v181 = *(_DWORD *)a1;
      while (1)
      {
        int v182 = *a2;
        int v183 = llparse_blob35[v181];
        if (v181 == 5)
        {
          int v180 = 0;
          int v184 = 5;
        }
        else
        {
          int v184 = 0;
        }
        if (v182 != v183)
        {
          int v180 = 2;
          int v184 = 5;
        }
        if (v184) {
          break;
        }
        if (v182 == v183) {
          ++v181;
        }
        if (++a2 == a3)
        {
          int v180 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v181;
          goto LABEL_570;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_570:
      if (!v180)
      {
        ++a2;
        LOBYTE(v29) = 6;
        goto LABEL_1025;
      }
      if (v180 == 1) {
        return 169;
      }
      goto LABEL_1301;
    case 170:
      goto LABEL_582;
    case 171:
      goto LABEL_596;
    case 172:
LABEL_578:
      if (a2 == a3) {
        return 172;
      }
      int v185 = *a2;
      if (v185 == 85)
      {
        ++a2;
LABEL_596:
        if (a2 == a3) {
          return 171;
        }
        int v191 = 0;
        unsigned int v192 = *(_DWORD *)a1;
        while (1)
        {
          int v193 = *a2;
          int v194 = llparse_blob37[v192];
          if (v192 == 1)
          {
            int v191 = 0;
            int v195 = 5;
          }
          else
          {
            int v195 = 0;
          }
          if (v193 != v194)
          {
            int v191 = 2;
            int v195 = 5;
          }
          if (v195) {
            break;
          }
          if (v193 == v194) {
            ++v192;
          }
          if (++a2 == a3)
          {
            int v191 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v192;
            goto LABEL_611;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_611:
        if (!v191)
        {
          ++a2;
          LOBYTE(v29) = 39;
          goto LABEL_1025;
        }
        if (v191 == 1) {
          return 171;
        }
      }
      else
      {
        if (v185 != 84) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_582:
        if (a2 == a3) {
          return 170;
        }
        int v186 = 0;
        unsigned int v187 = *(_DWORD *)a1;
        while (1)
        {
          int v188 = *a2;
          int v189 = llparse_blob36[v187];
          if (v187 == 1)
          {
            int v186 = 0;
            int v190 = 5;
          }
          else
          {
            int v190 = 0;
          }
          if (v188 != v189)
          {
            int v186 = 2;
            int v190 = 5;
          }
          if (v190) {
            break;
          }
          if (v188 == v189) {
            ++v187;
          }
          if (++a2 == a3)
          {
            int v186 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v187;
            goto LABEL_609;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_609:
        if (!v186)
        {
          ++a2;
          LOBYTE(v29) = 28;
          goto LABEL_1025;
        }
        if (v186 == 1) {
          return 170;
        }
      }
      goto LABEL_1301;
    case 173:
LABEL_614:
      if (a2 == a3) {
        return 173;
      }
      int v196 = 0;
      unsigned int v197 = *(_DWORD *)a1;
      while (1)
      {
        int v198 = *a2;
        int v199 = llparse_blob38[v197];
        if (v197 == 1)
        {
          int v196 = 0;
          int v200 = 5;
        }
        else
        {
          int v200 = 0;
        }
        if (v198 != v199)
        {
          int v196 = 2;
          int v200 = 5;
        }
        if (v200) {
          break;
        }
        if (v198 == v199) {
          ++v197;
        }
        if (++a2 == a3)
        {
          int v196 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v197;
          goto LABEL_627;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_627:
      if (!v196)
      {
        ++a2;
        LOBYTE(v29) = 38;
        goto LABEL_1025;
      }
      if (v196 == 1) {
        return 173;
      }
      goto LABEL_1301;
    case 174:
LABEL_630:
      if (a2 == a3) {
        return 174;
      }
      int v201 = 0;
      unsigned int v202 = *(_DWORD *)a1;
      while (1)
      {
        int v203 = *a2;
        int v204 = llparse_blob39[v202];
        if (v202 == 1)
        {
          int v201 = 0;
          int v205 = 5;
        }
        else
        {
          int v205 = 0;
        }
        if (v203 != v204)
        {
          int v201 = 2;
          int v205 = 5;
        }
        if (v205) {
          break;
        }
        if (v203 == v204) {
          ++v202;
        }
        if (++a2 == a3)
        {
          int v201 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v202;
          goto LABEL_643;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_643:
      if (!v201)
      {
        ++a2;
        LOBYTE(v29) = 3;
        goto LABEL_1025;
      }
      if (v201 == 1) {
        return 174;
      }
      goto LABEL_1301;
    case 175:
      goto LABEL_658;
    case 176:
      goto LABEL_672;
    case 177:
      goto LABEL_654;
    case 178:
      goto LABEL_651;
    case 179:
LABEL_646:
      if (a2 == a3) {
        return 179;
      }
      int v206 = *a2;
      if (v206 != 79)
      {
        if (v206 != 73) {
          goto LABEL_1301;
        }
        ++a2;
        LOBYTE(v29) = 34;
        goto LABEL_1025;
      }
      ++a2;
LABEL_651:
      if (a2 == a3) {
        return 178;
      }
      if (*a2 != 80) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_654:
      if (a2 == a3) {
        return 177;
      }
      int v207 = *a2;
      if (v207 == 80)
      {
        ++a2;
LABEL_672:
        if (a2 == a3) {
          return 176;
        }
        int v213 = 0;
        unsigned int v214 = *(_DWORD *)a1;
        while (1)
        {
          int v215 = *a2;
          int v216 = llparse_blob41[v214];
          if (v214 == 3)
          {
            int v213 = 0;
            int v217 = 5;
          }
          else
          {
            int v217 = 0;
          }
          if (v215 != v216)
          {
            int v213 = 2;
            int v217 = 5;
          }
          if (v217) {
            break;
          }
          if (v215 == v216) {
            ++v214;
          }
          if (++a2 == a3)
          {
            int v213 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v214;
            goto LABEL_687;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_687:
        if (!v213)
        {
          ++a2;
          LOBYTE(v29) = 13;
          goto LABEL_1025;
        }
        if (v213 == 1) {
          return 176;
        }
      }
      else
      {
        if (v207 != 70) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_658:
        if (a2 == a3) {
          return 175;
        }
        int v208 = 0;
        unsigned int v209 = *(_DWORD *)a1;
        while (1)
        {
          int v210 = *a2;
          int v211 = llparse_blob40[v209];
          if (v209 == 2)
          {
            int v208 = 0;
            int v212 = 5;
          }
          else
          {
            int v212 = 0;
          }
          if (v210 != v211)
          {
            int v208 = 2;
            int v212 = 5;
          }
          if (v212) {
            break;
          }
          if (v210 == v211) {
            ++v209;
          }
          if (++a2 == a3)
          {
            int v208 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v209;
            goto LABEL_685;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_685:
        if (!v208)
        {
          ++a2;
          LOBYTE(v29) = 12;
          goto LABEL_1025;
        }
        if (v208 == 1) {
          return 175;
        }
      }
      goto LABEL_1301;
    case 180:
      goto LABEL_694;
    case 181:
LABEL_690:
      if (a2 == a3) {
        return 181;
      }
      int v218 = *a2;
      if (v218 == 84)
      {
        ++a2;
        LOBYTE(v29) = 4;
        goto LABEL_1025;
      }
      if (v218 != 82) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_694:
      if (a2 == a3) {
        return 180;
      }
      int v219 = 0;
      unsigned int v220 = *(_DWORD *)a1;
      do
      {
        int v221 = *a2;
        int v222 = llparse_blob42[v220];
        if (v220 == 1)
        {
          int v219 = 0;
          int v223 = 5;
        }
        else
        {
          int v223 = 0;
        }
        if (v221 != v222)
        {
          int v219 = 2;
          int v223 = 5;
        }
        if (v223)
        {
          *(_DWORD *)a1 = 0;
          goto LABEL_708;
        }
        if (v221 == v222) {
          ++v220;
        }
        ++a2;
      }
      while (a2 != a3);
      int v219 = 1;
      a2 = a3;
      *(_DWORD *)a1 = v220;
LABEL_708:
      if (!v219)
      {
        ++a2;
        LOBYTE(v29) = 29;
        goto LABEL_1025;
      }
      if (v219 == 1) {
        return 180;
      }
      goto LABEL_1301;
    case 182:
LABEL_575:
      if (a2 != a3)
      {
        switch(*a2)
        {
          case 'A':
            ++a2;
            goto LABEL_578;
          case 'L':
            ++a2;
            goto LABEL_614;
          case 'O':
            ++a2;
            goto LABEL_630;
          case 'R':
            ++a2;
            goto LABEL_646;
          case 'U':
            ++a2;
            goto LABEL_690;
          default:
            goto LABEL_1301;
        }
      }
      return 182;
    case 183:
LABEL_725:
      if (a2 == a3) {
        return 183;
      }
      int v224 = 0;
      unsigned int v225 = *(_DWORD *)a1;
      while (1)
      {
        int v226 = *a2;
        int v227 = llparse_blob43[v225];
        if (v225 == 3)
        {
          int v224 = 0;
          int v228 = 5;
        }
        else
        {
          int v228 = 0;
        }
        if (v226 != v227)
        {
          int v224 = 2;
          int v228 = 5;
        }
        if (v228) {
          break;
        }
        if (v226 == v227) {
          ++v225;
        }
        if (++a2 == a3)
        {
          int v224 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v225;
          goto LABEL_738;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_738:
      if (!v224)
      {
        ++a2;
        LOBYTE(v29) = 46;
        goto LABEL_1025;
      }
      if (v224 == 1) {
        return 183;
      }
      goto LABEL_1301;
    case 184:
LABEL_749:
      if (a2 == a3) {
        return 184;
      }
      int v229 = 0;
      unsigned int v230 = *(_DWORD *)a1;
      while (1)
      {
        int v231 = *a2;
        int v232 = llparse_blob44[v230];
        if (v230 == 2)
        {
          int v229 = 0;
          int v233 = 5;
        }
        else
        {
          int v233 = 0;
        }
        if (v231 != v232)
        {
          int v229 = 2;
          int v233 = 5;
        }
        if (v233) {
          break;
        }
        if (v231 == v232) {
          ++v230;
        }
        if (++a2 == a3)
        {
          int v229 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v230;
          goto LABEL_762;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_762:
      if (!v229)
      {
        ++a2;
        LOBYTE(v29) = 17;
        goto LABEL_1025;
      }
      if (v229 == 1) {
        return 184;
      }
      goto LABEL_1301;
    case 185:
LABEL_765:
      if (a2 == a3) {
        return 185;
      }
      int v234 = 0;
      unsigned int v235 = *(_DWORD *)a1;
      while (1)
      {
        int v236 = *a2;
        int v237 = llparse_blob45[v235];
        if (v235 == 2)
        {
          int v234 = 0;
          int v238 = 5;
        }
        else
        {
          int v238 = 0;
        }
        if (v236 != v237)
        {
          int v234 = 2;
          int v238 = 5;
        }
        if (v238) {
          break;
        }
        if (v236 == v237) {
          ++v235;
        }
        if (++a2 == a3)
        {
          int v234 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v235;
          goto LABEL_778;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_778:
      if (!v234)
      {
        ++a2;
        LOBYTE(v29) = 44;
        goto LABEL_1025;
      }
      if (v234 == 1) {
        return 185;
      }
      goto LABEL_1301;
    case 186:
LABEL_781:
      if (a2 == a3) {
        return 186;
      }
      int v239 = 0;
      unsigned int v240 = *(_DWORD *)a1;
      while (1)
      {
        int v241 = *a2;
        int v242 = llparse_blob46[v240];
        if (v240 == 4)
        {
          int v239 = 0;
          int v243 = 5;
        }
        else
        {
          int v243 = 0;
        }
        if (v241 != v242)
        {
          int v239 = 2;
          int v243 = 5;
        }
        if (v243) {
          break;
        }
        if (v241 == v242) {
          ++v240;
        }
        if (++a2 == a3)
        {
          int v239 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v240;
          goto LABEL_794;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_794:
      if (!v239)
      {
        ++a2;
        LOBYTE(v29) = 43;
        goto LABEL_1025;
      }
      if (v239 == 1) {
        return 186;
      }
      goto LABEL_1301;
    case 187:
LABEL_797:
      if (a2 == a3) {
        return 187;
      }
      int v244 = 0;
      unsigned int v245 = *(_DWORD *)a1;
      while (1)
      {
        int v246 = *a2;
        int v247 = llparse_blob47[v245];
        if (v245 == 2)
        {
          int v244 = 0;
          int v248 = 5;
        }
        else
        {
          int v248 = 0;
        }
        if (v246 != v247)
        {
          int v244 = 2;
          int v248 = 5;
        }
        if (v248) {
          break;
        }
        if (v246 == v247) {
          ++v245;
        }
        if (++a2 == a3)
        {
          int v244 = 1;
          a2 = a3;
          *(_DWORD *)a1 = v245;
          goto LABEL_810;
        }
      }
      *(_DWORD *)a1 = 0;
LABEL_810:
      if (!v244)
      {
        ++a2;
        LOBYTE(v29) = 20;
        goto LABEL_1025;
      }
      if (v244 == 1) {
        return 187;
      }
      goto LABEL_1301;
    case 188:
      goto LABEL_746;
    case 189:
LABEL_743:
      if (a2 == a3) {
        return 189;
      }
      if (*a2 != 69) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_746:
      if (a2 != a3)
      {
        switch(*a2)
        {
          case 'B':
            ++a2;
            goto LABEL_749;
          case 'C':
            ++a2;
            goto LABEL_765;
          case 'D':
            ++a2;
            goto LABEL_781;
          case 'P':
            ++a2;
            goto LABEL_797;
          default:
            goto LABEL_1301;
        }
      }
      return 188;
    case 190:
      goto LABEL_830;
    case 191:
      goto LABEL_848;
    case 192:
      goto LABEL_852;
    case 193:
      goto LABEL_844;
    case 194:
      goto LABEL_826;
    case 195:
      goto LABEL_886;
    case 196:
      goto LABEL_870;
    case 197:
LABEL_821:
      if (a2 == a3) {
        return 197;
      }
      int v249 = *a2;
      if (v249 == 85)
      {
        ++a2;
LABEL_870:
        if (a2 == a3) {
          return 196;
        }
        int v262 = 0;
        unsigned int v263 = *(_DWORD *)a1;
        while (1)
        {
          int v264 = *a2;
          int v265 = llparse_blob51[v263];
          if (v263 == 6)
          {
            int v262 = 0;
            int v266 = 5;
          }
          else
          {
            int v266 = 0;
          }
          if (v264 != v265)
          {
            int v262 = 2;
            int v266 = 5;
          }
          if (v266) {
            break;
          }
          if (v264 == v265) {
            ++v263;
          }
          if (++a2 == a3)
          {
            int v262 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v263;
            goto LABEL_883;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_883:
        if (!v262)
        {
          ++a2;
          LOBYTE(v29) = 26;
          goto LABEL_1025;
        }
        if (v262 == 1) {
          return 196;
        }
LABEL_1301:
        uint64_t result = 0;
        *(_DWORD *)(a1 + 24) = 6;
        unint64_t v7 = "Invalid method encountered";
        goto LABEL_2263;
      }
      if (v249 == 79)
      {
        ++a2;
LABEL_886:
        if (a2 == a3) {
          return 195;
        }
        int v267 = 0;
        unsigned int v268 = *(_DWORD *)a1;
        while (1)
        {
          int v269 = *a2;
          int v270 = llparse_blob50[v268];
          if (v268 == 3)
          {
            int v267 = 0;
            int v271 = 5;
          }
          else
          {
            int v271 = 0;
          }
          if (v269 != v270)
          {
            int v267 = 2;
            int v271 = 5;
          }
          if (v271) {
            break;
          }
          if (v269 == v270) {
            ++v268;
          }
          if (++a2 == a3)
          {
            int v267 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v268;
            goto LABEL_899;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_899:
        if (!v267)
        {
          ++a2;
          LOBYTE(v29) = 33;
          goto LABEL_1025;
        }
        if (v267 == 1) {
          return 195;
        }
        goto LABEL_1301;
      }
      if (v249 != 69) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_826:
      if (a2 == a3) {
        return 194;
      }
      int v250 = *a2;
      if (v250 != 84)
      {
        if (v250 != 65) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_830:
        if (a2 == a3) {
          return 190;
        }
        int v251 = 0;
        unsigned int v252 = *(_DWORD *)a1;
        while (1)
        {
          int v253 = *a2;
          int v254 = llparse_blob48[v252];
          if (v252 == 2)
          {
            int v251 = 0;
            int v255 = 5;
          }
          else
          {
            int v255 = 0;
          }
          if (v253 != v254)
          {
            int v251 = 2;
            int v255 = 5;
          }
          if (v255) {
            break;
          }
          if (v253 == v254) {
            ++v252;
          }
          if (++a2 == a3)
          {
            int v251 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v252;
            goto LABEL_865;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_865:
        if (!v251)
        {
          ++a2;
          LOBYTE(v29) = 14;
          goto LABEL_1025;
        }
        if (v251 == 1) {
          return 190;
        }
        goto LABEL_1301;
      }
      ++a2;
LABEL_844:
      if (a2 == a3) {
        return 193;
      }
      int v256 = *a2;
      if (v256 == 95)
      {
        ++a2;
LABEL_852:
        if (a2 == a3) {
          return 192;
        }
        int v257 = 0;
        unsigned int v258 = *(_DWORD *)a1;
        while (1)
        {
          int v259 = *a2;
          int v260 = llparse_blob49[v258];
          if (v258 == 8)
          {
            int v257 = 0;
            int v261 = 5;
          }
          else
          {
            int v261 = 0;
          }
          if (v259 != v260)
          {
            int v257 = 2;
            int v261 = 5;
          }
          if (v261) {
            break;
          }
          if (v259 == v260) {
            ++v258;
          }
          if (++a2 == a3)
          {
            int v257 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v258;
            goto LABEL_867;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_867:
        if (!v257)
        {
          ++a2;
          LOBYTE(v29) = 42;
          goto LABEL_1025;
        }
        if (v257 == 1) {
          return 192;
        }
        goto LABEL_1301;
      }
      if (v256 != 85) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_848:
      if (a2 == a3) {
        return 191;
      }
      if (*a2 != 80) {
        goto LABEL_1301;
      }
      ++a2;
      LOBYTE(v29) = 37;
LABEL_1025:
      *(unsigned char *)(a1 + 73) = v29;
      uint64_t v305 = *(void *)(a1 + 8);
      *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
      uint64_t v306 = *(void *)(a1 + 88);
      if (v306)
      {
        v307 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v306 + 24);
        if (v307)
        {
          int v308 = v307(a1, v305, &a2[-v305]);
          if (v308)
          {
            int v312 = v308;
            if (v308 == -1)
            {
              *(void *)(a1 + 32) = "Span callback error in on_method";
              int v312 = 24;
            }
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = v312;
            *(void *)(a1 + 40) = a2;
            *(void *)(a1 + 56) = 137;
            return result;
          }
        }
      }
LABEL_1028:
      uint64_t v309 = *(void *)(a1 + 88);
      if (v309)
      {
        v310 = *(uint64_t (**)(uint64_t))(v309 + 112);
        if (v310)
        {
          int v311 = v310(a1);
          if (v311)
          {
            if (v311 != 21)
            {
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 32;
              goto LABEL_2263;
            }
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 21;
            *(void *)(a1 + 32) = "on_method_complete pause";
            *(void *)(a1 + 40) = a2;
            *(void *)(a1 + 56) = 136;
            return result;
          }
        }
      }
LABEL_1031:
      if (a2 == a3) {
        return 136;
      }
      if (*a2 != 32)
      {
        uint64_t result = 0;
        *(_DWORD *)(a1 + 24) = 6;
        unint64_t v7 = "Expected space after method";
        goto LABEL_2263;
      }
      ++a2;
LABEL_1034:
      uint64_t result = 135;
      if (a2 != a3)
      {
        while (*a2 == 32)
        {
          if (++a2 == a3) {
            return result;
          }
        }
        if (*(unsigned char *)(a1 + 73) == 5)
        {
LABEL_1042:
          if (a2 == a3) {
            return 134;
          }
          int v313 = *a2;
          if (v313 == 9 || v313 == 12) {
            goto LABEL_1402;
          }
LABEL_1047:
          if (a2 == a3) {
            return 133;
          }
          *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
          *(void *)(a1 + 16) = llhttp__on_url;
LABEL_1076:
          uint64_t result = 125;
          while (llhttp__internal__run_lookup_table_25[*a2] == 5)
          {
            if (++a2 == a3) {
              return result;
            }
          }
          switch((unint64_t)*a2)
          {
            case 9uLL:
            case 0xCuLL:
            case 0x109uLL:
            case 0x10AuLL:
            case 0x10CuLL:
            case 0x10DuLL:
            case 0x120uLL:
            case 0x209uLL:
            case 0x20AuLL:
            case 0x20CuLL:
            case 0x20DuLL:
            case 0x220uLL:
              goto LABEL_1402;
            case 0xAuLL:
            case 0x13AuLL:
            case 0x22AuLL:
            case 0x22FuLL:
LABEL_1119:
              uint64_t v323 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v324 = *(void *)(a1 + 88);
              if (!v324) {
                goto LABEL_1122;
              }
              v325 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v324 + 8);
              if (!v325) {
                goto LABEL_1122;
              }
              int v326 = v325(a1, v323, &a2[-v323]);
              if (!v326) {
                goto LABEL_1122;
              }
              int v414 = v326;
              if (v326 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_url";
                int v414 = 24;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = v414;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 93;
              break;
            case 0xDuLL:
            case 0x141uLL:
            case 0x142uLL:
            case 0x143uLL:
            case 0x144uLL:
            case 0x145uLL:
            case 0x146uLL:
            case 0x147uLL:
            case 0x148uLL:
            case 0x149uLL:
            case 0x14AuLL:
            case 0x14BuLL:
            case 0x14CuLL:
            case 0x14DuLL:
            case 0x14EuLL:
            case 0x14FuLL:
            case 0x150uLL:
            case 0x151uLL:
            case 0x152uLL:
            case 0x153uLL:
            case 0x154uLL:
            case 0x155uLL:
            case 0x156uLL:
            case 0x157uLL:
            case 0x158uLL:
            case 0x159uLL:
            case 0x15AuLL:
            case 0x161uLL:
            case 0x162uLL:
            case 0x163uLL:
            case 0x164uLL:
            case 0x165uLL:
            case 0x166uLL:
            case 0x167uLL:
            case 0x168uLL:
            case 0x169uLL:
            case 0x16AuLL:
            case 0x16BuLL:
            case 0x16CuLL:
            case 0x16DuLL:
            case 0x16EuLL:
            case 0x16FuLL:
            case 0x170uLL:
            case 0x171uLL:
            case 0x172uLL:
            case 0x173uLL:
            case 0x174uLL:
            case 0x175uLL:
            case 0x176uLL:
            case 0x177uLL:
            case 0x178uLL:
            case 0x179uLL:
            case 0x17AuLL:
            case 0x241uLL:
            case 0x242uLL:
            case 0x243uLL:
            case 0x244uLL:
            case 0x245uLL:
            case 0x246uLL:
            case 0x247uLL:
            case 0x248uLL:
            case 0x249uLL:
            case 0x24AuLL:
            case 0x24BuLL:
            case 0x24CuLL:
            case 0x24DuLL:
            case 0x24EuLL:
            case 0x24FuLL:
            case 0x250uLL:
            case 0x251uLL:
            case 0x252uLL:
            case 0x253uLL:
            case 0x254uLL:
            case 0x255uLL:
            case 0x256uLL:
            case 0x257uLL:
            case 0x258uLL:
            case 0x259uLL:
            case 0x25AuLL:
            case 0x261uLL:
            case 0x262uLL:
            case 0x263uLL:
            case 0x264uLL:
            case 0x265uLL:
            case 0x266uLL:
            case 0x267uLL:
            case 0x268uLL:
            case 0x269uLL:
            case 0x26AuLL:
            case 0x26BuLL:
            case 0x26CuLL:
            case 0x26DuLL:
            case 0x26EuLL:
            case 0x26FuLL:
            case 0x270uLL:
            case 0x271uLL:
            case 0x272uLL:
            case 0x273uLL:
            case 0x274uLL:
            case 0x275uLL:
            case 0x276uLL:
            case 0x277uLL:
            case 0x278uLL:
            case 0x279uLL:
            case 0x27AuLL:
LABEL_1128:
              uint64_t v329 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v330 = *(void *)(a1 + 88);
              if (!v330) {
                goto LABEL_1131;
              }
              v331 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v330 + 8);
              if (!v331) {
                goto LABEL_1131;
              }
              int v332 = v331(a1, v329, &a2[-v329]);
              if (!v332) {
                goto LABEL_1131;
              }
              int v415 = v332;
              if (v332 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_url";
                int v415 = 24;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = v415;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 95;
              break;
            case 0x20uLL:
LABEL_1148:
              uint64_t v339 = *(void *)(a1 + 8);
              *(void *)(a1 + _Block_object_dispose(&a9, 8) = 0;
              uint64_t v340 = *(void *)(a1 + 88);
              if (!v340) {
                goto LABEL_1151;
              }
              v341 = *(uint64_t (**)(uint64_t, uint64_t, unsigned __int8 *))(v340 + 8);
              if (!v341) {
                goto LABEL_1151;
              }
              int v342 = v341(a1, v339, &a2[-v339]);
              if (!v342) {
                goto LABEL_1151;
              }
              int v416 = v342;
              if (v342 == -1)
              {
                *(void *)(a1 + 32) = "Span callback error in on_url";
                int v416 = 24;
              }
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = v416;
              *(void *)(a1 + 40) = a2;
              *(void *)(a1 + 56) = 115;
              break;
            case 0x2FuLL:
              goto LABEL_1081;
            case 0x3FuLL:
LABEL_1104:
              ++a2;
              goto LABEL_1105;
            case 0x40uLL:
              ++a2;
              goto LABEL_1090;
            default:
LABEL_1238:
              uint64_t result = 0;
              *(_DWORD *)(a1 + 24) = 7;
              unint64_t v7 = "Unexpected char in url server";
              goto LABEL_2263;
          }
          return result;
        }
LABEL_1050:
        if (a2 == a3) {
          return 132;
        }
        int v315 = *a2;
        if (v315 == 9 || v315 == 12) {
          goto LABEL_1402;
        }
LABEL_1055:
        if (a2 == a3) {
          return 131;
        }
        *(void *)(a1 + _Block_object_dispose(&a9, 8) = a2;
        *(void *)(a1 + 16) = llhttp__on_url;
LABEL_1057:
        if (a2 == a3) {
          return 130;
        }
        int v317 = llhttp__internal__run_lookup_table_27[*a2];
        if (v317 == 2)
        {
LABEL_1083:
          if (a2 == a3) {
            return 121;
          }
LABEL_1095:
          ++a2;
LABEL_1096:
          if (a2 == a3) {
            return 120;
          }
          uint64_t result = 120;
          while (1)
          {
            int v322 = llhttp__internal__run_lookup_table_23[*a2];
            if (v322 != 2) {
              break;
            }
            if (++a2 == a3) {
              return result;
            }
          }
          if (v322 != 1)
          {
LABEL_1102:
            if (a2 != a3)
            {
              switch(*a2)
              {
                case 9u:
                case 0xCu:
                  goto LABEL_1402;
                case 0xAu:
                  goto LABEL_1119;
                case 0xDu:
                  goto LABEL_1128;
                case 0x20u:
                  goto LABEL_1148;
                case 0x23u:
                  goto LABEL_1112;
                case 0x3Fu:
                  goto LABEL_1104;
                default:
                  uint64_t result = 0;
                  *(_DWORD *)(a1 + 24) = 7;
                  unint64_t v7 = "Invalid char in url path";
                  goto LABEL_2263;
              }
            }
            return 119;
          }
          goto LABEL_1402;
        }
        if (v317 != 3)
        {
          if (v317 != 1)
          {
            uint64_t result = 0;
            *(_DWORD *)(a1 + 24) = 7;
            unint64_t v7 = "Unexpected start char in url";
            goto LABEL_2263;
          }
          goto LABEL_1402;
        }
LABEL_1060:
        if (a2 == a3) {
          return 129;
        }
        uint64_t result = 129;
        while (1)
        {
          int v318 = llhttp__internal__run_lookup_table_26[*a2];
          if (v318 != 3) {
            break;
          }
          if (++a2 == a3) {
            return result;
          }
        }
        if (v318 == 1)
        {
LABEL_1402:
          uint64_t result = 0;
          *(_DWORD *)(a1 + 24) = 7;
          *(void *)(a1 + 32) = "Invalid characters in url";
          *(void *)(a1 + 40) = a2 + 1;
          *(void *)(a1 + 56) = 0;
          return result;
        }
        if (v318 != 2)
        {
          uint64_t result = 0;
          *(_DWORD *)(a1 + 24) = 7;
          unint64_t v7 = "Unexpected char in url schema";
          goto LABEL_2263;
        }
LABEL_1067:
        if (a2 == a3) {
          return 128;
        }
        ++a2;
LABEL_1069:
        if (a2 == a3) {
          return 127;
        }
        v319 = a2;
        unsigned int v320 = *a2;
        if (v320 == 47)
        {
          ++a2;
LABEL_1072:
          if (a2 == a3) {
            return 126;
          }
          v319 = a2;
          if (*a2 == 47)
          {
            ++a2;
LABEL_1075:
            if (a2 == a3) {
              return 125;
            }
            goto LABEL_1076;
          }
        }
        else if (v320 <= 0x20 && ((1 << v320) & 0x100003600) != 0)
        {
          goto LABEL_1402;
        }
        uint64_t result = 0;
        *(_DWORD *)(a1 + 24) = 7;
        v321 = "Unexpected char in url schema";
        goto LABEL_2194;
      }
      return result;
    case 198:
      goto LABEL_914;
    case 199:
      goto LABEL_928;
    case 200:
LABEL_910:
      if (a2 == a3) {
        return 200;
      }
      int v272 = *a2;
      if (v272 == 82)
      {
        ++a2;
LABEL_928:
        if (a2 == a3) {
          return 199;
        }
        int v278 = 0;
        unsigned int v279 = *(_DWORD *)a1;
        while (1)
        {
          int v280 = *a2;
          int v281 = llparse_blob53[v279];
          if (v279 == 2)
          {
            int v278 = 0;
            int v282 = 5;
          }
          else
          {
            int v282 = 0;
          }
          if (v280 != v281)
          {
            int v278 = 2;
            int v282 = 5;
          }
          if (v282) {
            break;
          }
          if (v280 == v281) {
            ++v279;
          }
          if (++a2 == a3)
          {
            int v278 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v279;
            goto LABEL_943;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_943:
        if (!v278)
        {
          ++a2;
          LOBYTE(v29) = 7;
          goto LABEL_1025;
        }
        if (v278 == 1) {
          return 199;
        }
      }
      else
      {
        if (v272 != 69) {
          goto LABEL_1301;
        }
        ++a2;
LABEL_914:
        if (a2 == a3) {
          return 198;
        }
        int v273 = 0;
        unsigned int v274 = *(_DWORD *)a1;
        while (1)
        {
          int v275 = *a2;
          int v276 = llparse_blob52[v274];
          if (v274 == 5)
          {
            int v273 = 0;
            int v277 = 5;
          }
          else
          {
            int v277 = 0;
          }
          if (v275 != v276)
          {
            int v273 = 2;
            int v277 = 5;
          }
          if (v277) {
            break;
          }
          if (v275 == v276) {
            ++v274;
          }
          if (++a2 == a3)
          {
            int v273 = 1;
            a2 = a3;
            *(_DWORD *)a1 = v274;
            goto LABEL_941;
          }
        }
        *(_DWORD *)a1 = 0;
LABEL_941:
        if (!v273)
        {
          ++a2;
          LOBYTE(v29) = 40;
          goto LABEL_1025;
        }
        if (v273 == 1) {
          return 198;
        }
      }
      goto LABEL_1301;
    case 201:
      goto LABEL_958;
    case 202:
      goto LABEL_994;
    case 203:
      goto LABEL_1008;
    case 204:
      goto LABEL_990;
    case 205:
      goto LABEL_974;
    case 206:
      goto LABEL_953;
    case 207:
LABEL_950:
      if (a2 == a3) {
        return 207;
      }
      if (*a2 != 78) {
        goto LABEL_1301;
      }
      ++a2;
LABEL_953:
      if (a2 == a3) {
        return 206;
      }
      int v283 = *a2;
      switch(v283)
      {
        case 'S':
          ++a2;
LABEL_974:
          if (a2 == a3) {
            return 205;
          }
          int v289 = 0;
          unsigned int v290 = *(_DWORD *)a1;
          while (1)
          {
            int v291 = *a2;
            int v292 = llparse_blob57[v290];
            if (v290 == 7)
            {
              int v289 = 0;
              int v293 = 5;
            }
            else
            {
              int v293 = 0;
            }
            if (v291 != v292)
            {
              int v289 = 2;
              int v293 = 5;
            }
            if (v293) {
              break;
            }
            if (v291 == v292) {
              ++v290;
            }
            if (++a2 == a3)
            {
              int v289 = 1;
              a2 = a3;
              *(_DWORD *)a1 = v290;
              goto LABEL_987;
            }
          }
          *(_DWORD *)a1 = 0;
LABEL_987:
          if (!v289)
          {
            ++a2;
            LOBYTE(v29) = 27;
            goto LABEL_1025;
          }
          if (v289 == 1) {
            return 205;
          }
          break;
        case 'L':
          ++a2;
LABEL_990:
          if (a2 == a3) {
            return 204;
          }
          int v294 = *a2;
          if (v294 == 79)
          {
            ++a2;
LABEL_1008:
            if (a2 == a3) {
              return 203;
            }
            int v300 = 0;
            unsigned int v301 = *(_DWORD *)a1;
            while (1)
            {
              int v302 = *a2;
              int v303 = llparse_blob56[v301];
              if (v301 == 1)
              {
                int v300 = 0;
                int v304 = 5;
              }
              else
              {
                int v304 = 0;
              }
              if (v302 != v303)
              {
                int v300 = 2;
                int v304 = 5;
              }
              if (v304) {
                break;
              }
              if (v302 == v303) {
                ++v301;
              }
              if (++a2 == a3)
              {
                int v300 = 1;
                a2 = a3;
                *(_DWORD *)a1 = v301;
                goto LABEL_1023;
              }
            }
            *(_DWORD *)a1 = 0;
LABEL_1023:
            if (!v300)
            {
              ++a2;
              LOBYTE(v29) = 15;
              goto LABEL_1025;
            }
            if (v300 == 1) {
              return 203;
            }
          }
          else
          {
            if (v294 != 73) {
              goto LABEL_1301;
            }
            ++a2;
LABEL_994:
            if (a2 == a3) {
              return 202;
            }
            int v295 = 0;
            unsigned int v296 = *(_DWORD *)a1;
            while (1)
            {
              int v297 = *a2;
              int v298 = llparse_blob55[v296];
              if (v296 == 1)
              {
                int v295 = 0;
                int v299 = 5;
              }
              else
              {
                int v299 = 0;
              }
              if (v297 != v298)
              {
                int v295 = 2;
                int v299 = 5;
              }
              if (v299) {
                break;
              }
              if (v297 == v298) {
                ++v296;
              }
              if (++a2 == a3)
              {
                int v295 = 1;
                a2 = a3;
                *(_DWORD *)a1 = v296;
                goto LABEL_1021;
              }
            }
            *(_DWORD *)a1 = 0;
LABEL_1021:
            if (!v295)
            {
              ++a2;
              LOBYTE(v29) = 32;
              goto LABEL_1025;
            }
            if (v295 == 1) {
              return 202;
            }
          }
          break;
        case 'B':
          ++a2;
LABEL_958:
          if (a2 == a3) {
            return 201;
          }
          int v284 = 0;
          unsigned int v285 = *(_DWORD *)a1;
          while (1)
          {
            int v286 = *a2;
            int v287 = llparse_blob54[v285];
            if (v285 == 2)
            {
              int v284 = 0;
              int v288 = 5;
            }
            else
            {
              int v288 = 0;
            }
            if (v286 != v287)
            {
              int v284 = 2;
              int v288 = 5;
            }
            if (v288) {
              break;
            }
            if (v286 == v287) {
              ++v285;
            }
            if (++a2 == a3)
            {
              int v284 = 1;
              a2 = a3;
              *(_DWORD *)a1 = v285;
              goto LABEL_971;
            }
          }
          *(_DWORD *)a1 = 0;
LABEL_971:
          if (!v284)
          {
            ++a2;
            LOBYTE(v29) = 18;
            goto LABEL_1025;
          }
          if (v284 == 1) {
            return 201;
          }
          break;
        default:
          goto LABEL_1301;
      }
      goto LABEL_1301;
    case 208:
      goto LABEL_60;
    case 209:
      goto LABEL_58;
    case 210:
      goto LABEL_181;
    case 211:
      goto LABEL_172;
    case 212:
      goto LABEL_170;
    case 213:
      goto LABEL_163;
    case 214:
      goto LABEL_157;
    case 215:
      goto LABEL_152;
    case 216:
      goto LABEL_147;
    case 217:
      goto LABEL_144;
    case 218:
      goto LABEL_141;
    case 221:
      goto LABEL_120;
    case 223:
      goto LABEL_117;
    case 225:
      goto LABEL_114;
    case 226:
      goto LABEL_112;
    case 227:
      goto LABEL_20;
    case 229:
      goto LABEL_44;
    case 230:
      goto LABEL_111;
    case 231:
      goto LABEL_71;
    case 232:
      goto LABEL_40;
    case 233:
      goto LABEL_37;
    case 234:
      goto LABEL_35;
    case 235:
      goto LABEL_33;
    case 236:
      goto LABEL_18;
    case 237:
      goto LABEL_15;
    case 238:
      goto LABEL_3;
    default:
      goto LABEL_2346;
  }
}

uint64_t llparse__match_sequence_id(unsigned int *a1, unsigned __int8 *a2, unsigned __int8 *a3, uint64_t a4, int a5)
{
  unsigned int v5 = *a1;
  if (a2 == a3)
  {
LABEL_14:
    *a1 = v5;
    return 1;
  }
  else
  {
    unsigned int v6 = 0;
    while (1)
    {
      int v7 = *a2;
      int v8 = *(unsigned __int8 *)(a4 + v5);
      if (v5 + 1 == a5)
      {
        unsigned int v6 = 0;
        int v9 = 5;
      }
      else
      {
        int v9 = 0;
      }
      if (v7 != v8)
      {
        unsigned int v6 = 2;
        int v9 = 5;
      }
      if (v9) {
        break;
      }
      if (v7 == v8) {
        ++v5;
      }
      if (++a2 == a3) {
        goto LABEL_14;
      }
    }
    *a1 = 0;
    return v6;
  }
}

void sub_183A5602C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A57190(_Unwind_Exception *exception_object)
{
}

void sub_183A57234(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A57344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A573E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_create_srv(const char *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = [NWConcrete_nw_srv_endpoint alloc];
    return -[NWConcrete_nw_srv_endpoint initWithName:](v2, a1);
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v14 = "nw_endpoint_create_srv";
  unsigned int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v14 = "nw_endpoint_create_srv";
        int v8 = "%{public}s called with null name";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)long long buf = 136446466;
            char v14 = "nw_endpoint_create_srv";
            __int16 v15 = 2082;
            int v16 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v10) {
          goto LABEL_19;
        }
        *(_DWORD *)long long buf = 136446210;
        char v14 = "nw_endpoint_create_srv";
        int v8 = "%{public}s called with null name, no backtrace";
        goto LABEL_18;
      }
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v14 = "nw_endpoint_create_srv";
        int v8 = "%{public}s called with null name, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
LABEL_19:
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  return 0;
}

uint64_t nw_endpoint_get_srv_name(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    int v26 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v38 = "nw_endpoint_get_srv_name";
    int v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v38 = "nw_endpoint_get_srv_name";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)long long buf = 136446466;
            int v38 = "nw_endpoint_get_srv_name";
            __int16 v39 = 2082;
            *(void *)uint64_t v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)long long buf = 136446210;
          int v38 = "nw_endpoint_get_srv_name";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v38 = "nw_endpoint_get_srv_name";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v27) {
      goto LABEL_24;
    }
    unsigned int v24 = (char *)v27;
    goto LABEL_23;
  }
  uint64_t v3 = v1;
  int v4 = [v3 type];

  if (v4 != 5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    os_log_type_t v7 = v3;
    int v8 = [v7 type];

    *(_DWORD *)long long buf = 136446466;
    int v38 = "nw_endpoint_get_srv_name";
    __int16 v39 = 1024;
    *(_DWORD *)uint64_t v40 = v8;
    LODWORD(v34) = 18;
    int v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)long long buf = 136446466;
          int v38 = "nw_endpoint_get_srv_name";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v13;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        char v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            int v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)long long buf = 136446722;
            int v38 = "nw_endpoint_get_srv_name";
            __int16 v39 = 1024;
            *(_DWORD *)uint64_t v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          unsigned int v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          int v22 = v7;
          int v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)long long buf = 136446466;
          int v38 = "nw_endpoint_get_srv_name";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v23;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          int v20 = v7;
          int v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)long long buf = 136446466;
          int v38 = "nw_endpoint_get_srv_name";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v21;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  uint64_t v5 = v3[29];
LABEL_25:

  return v5;
}

void sub_183A57CD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A5AC38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__48061(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__48062(uint64_t a1)
{
}

void sub_183A5B05C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);
  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void sub_183A5D4D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A61160(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, id *location, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,char a50)
{
  _Block_object_dispose(&a50, 8);
  objc_destroyWeak(location);
  _Block_object_dispose((const void *)(v50 - 184), 8);
  _Block_object_dispose((const void *)(v50 - 136), 8);
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__48519(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__48520(uint64_t a1)
{
}

void __Block_byref_object_copy__66(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__67(uint64_t a1)
{
}

void sub_183A61B30(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va1, a9);
  va_start(va, a9);
  uint64_t v10 = va_arg(va1, void);
  uint64_t v12 = va_arg(va1, void);
  uint64_t v13 = va_arg(va1, void);
  uint64_t v14 = va_arg(va1, void);
  _Block_object_dispose(va, 8);
  _Block_object_dispose(va1, 8);
  _Unwind_Resume(a1);
}

void *network_retain(void *object)
{
  if (object) {
    return os_retain(object);
  }
  return object;
}

xpc_object_t nw_xpc_array_get_value_of_type(void *a1, size_t a2, objc_class *a3)
{
  if (!a1 || object_getClass(a1) != (Class)MEMORY[0x1E4F14568] || xpc_array_get_count(a1) <= a2) {
    return 0;
  }
  xpc_object_t value = xpc_array_get_value(a1, a2);
  xpc_object_t v7 = value;
  if (a3 && value && object_getClass(value) != a3) {
    return 0;
  }
  return v7;
}

xpc_object_t nw_xpc_dictionary_get_value_of_type(void *a1, const char *a2, objc_class *a3)
{
  if (!a1) {
    return 0;
  }
  Class Class = object_getClass(a1);
  xpc_object_t v7 = 0;
  if (a2)
  {
    if (Class == (Class)MEMORY[0x1E4F14590])
    {
      xpc_object_t value = xpc_dictionary_get_value(a1, a2);
      xpc_object_t v7 = value;
      if (a3)
      {
        if (value && object_getClass(value) != a3) {
          return 0;
        }
      }
    }
  }
  return v7;
}

uint64_t nw_dispatch_data_copyout(NSObject *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v7 = 0;
  int v8 = &v7;
  uint64_t v9 = 0x2000000000;
  uint64_t v10 = 0;
  v6[0] = 0;
  v6[1] = v6;
  void v6[2] = 0x2000000000;
  v6[3] = a2;
  if (a1)
  {
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 0x40000000;
    applier[2] = __nw_dispatch_data_copyout_block_invoke;
    applier[3] = &unk_1E5242B60;
    applier[5] = v6;
    void applier[6] = a3;
    applier[4] = &v7;
    dispatch_data_apply(a1, applier);
    uint64_t v3 = v8[3];
  }
  else
  {
    uint64_t v3 = 0;
  }
  _Block_object_dispose(v6, 8);
  _Block_object_dispose(&v7, 8);
  return v3;
}

uint64_t nw_dispatch_data_copyout_from_offset(NSObject *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2000000000;
    uint64_t v19 = 0;
    *(void *)os_log_type_t type = 0;
    uint64_t v14 = type;
    uint64_t v15 = 0x2000000000;
    uint64_t v16 = a4;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 0x40000000;
    applier[2] = __nw_dispatch_data_copyout_from_offset_block_invoke;
    applier[3] = &unk_1E5242B88;
    applier[4] = type;
    applier[5] = buf;
    void applier[6] = a3;
    void applier[7] = a2;
    dispatch_data_apply(a1, applier);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);
    return v4;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
  id v6 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v6, type, &v17))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
        uint64_t v9 = "%{public}s called with null data";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      BOOL v11 = os_log_type_enabled(v7, type[0]);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v11)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
        uint64_t v9 = "%{public}s called with null data, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_dispatch_data_copyout_from_offset";
        uint64_t v9 = "%{public}s called with null data, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v6) {
    free(v6);
  }
  return 0;
}

BOOL __nw_dispatch_data_copyout_from_offset_block_invoke(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v5 = *(void *)(*(void *)(a1[4] + 8) + 24);
  if (a5 + a3 <= v5) {
    return 1;
  }
  unint64_t v7 = a1[6];
  unint64_t v8 = *(void *)(*(void *)(a1[5] + 8) + 24);
  BOOL v9 = v7 > v8;
  size_t v10 = v7 - v8;
  if (!v9) {
    return 0;
  }
  BOOL v11 = v5 >= a3;
  unint64_t v12 = v5 - a3;
  if (!v11) {
    unint64_t v12 = 0;
  }
  if (v10 >= a5 - v12) {
    size_t v13 = a5 - v12;
  }
  else {
    size_t v13 = v10;
  }
  memcpy((void *)(a1[7] + v8), (const void *)(a4 + v12), v13);
  *(void *)(*(void *)(a1[4] + 8) + 24) += v13;
  *(void *)(*(void *)(a1[5] + 8) + 24) += v13;
  return *(void *)(*(void *)(a1[5] + 8) + 24) < a1[6];
}

const char *nw_create_buffer_str_slow(unsigned __int8 *a1, uint64_t a2)
{
  if (a1 && (uint64_t v2 = a2) != 0)
  {
    uint64_t v3 = a1;
    id v6 = 0;
    do
    {
      int v4 = *v3++;
      nw_append_format(&v6, "%02x", v4);
      --v2;
    }
    while (v2);
    return v6;
  }
  else
  {
    return (const char *)nw_calloc_type<unsigned char>(1uLL);
  }
}

unint64_t nw_convert_to_timebase(uint64_t a1)
{
  unsigned int v2 = dword_1EB267624;
  if (!dword_1EB267624)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v2 = dword_1EB267624;
  }
  return (unint64_t)time_base * a1 / v2;
}

uint64_t nw_delta_ms(uint64_t a1, uint64_t a2)
{
  unint64_t v2 = nw_delta_nanos(a1, a2);
  if (v2 > 0xF423FFFFFFFFFLL) {
    return 0xFFFFFFFFLL;
  }
  else {
    return (v2 / 0xF4240);
  }
}

uint64_t nw_get_future_time_from(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = dword_1EB267624;
  if (!dword_1EB267624)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v4 = dword_1EB267624;
  }
  return (unint64_t)v4 * a2 / time_base + a1;
}

unint64_t nw_get_time_before(unint64_t a1, uint64_t a2)
{
  unsigned int v4 = dword_1EB267624;
  if (!dword_1EB267624)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v4 = dword_1EB267624;
  }
  unint64_t v5 = (unint64_t)v4 * a2 / time_base;
  BOOL v6 = a1 >= v5;
  unint64_t v7 = a1 - v5;
  if (v6) {
    return v7;
  }
  else {
    return 0;
  }
}

uint64_t nw_get_future_continuous_time(uint64_t a1)
{
  unsigned int v2 = dword_1EB267624;
  if (!dword_1EB267624)
  {
    mach_timebase_info((mach_timebase_info_t)&time_base);
    unsigned int v2 = dword_1EB267624;
  }
  unint64_t v3 = (unint64_t)v2 * a1 / time_base;
  return mach_continuous_time() + v3;
}

uint64_t nw_mach_continuous_time()
{
  uint64_t result = mach_continuous_time();
  if (result <= 1) {
    return 1;
  }
  return result;
}

uint64_t nw_mach_continuous_approximate_time()
{
  uint64_t result = mach_continuous_approximate_time();
  if (result <= 1) {
    return 1;
  }
  return result;
}

uint64_t nw_mach_continuous_time_with_timespec()
{
  return 1;
}

__uint64_t nw_gettime_nanoseconds()
{
  return clock_gettime_nsec_np(_CLOCK_REALTIME);
}

uint64_t nw_unordered_xpc_array_is_equal(xpc_object_t object1, xpc_object_t object2)
{
  BOOL v3 = object1 == object2;
  uint64_t result = object1 == object2;
  if (!v3 && object1 && object2)
  {
    if (xpc_equal(object1, object2))
    {
      return 1;
    }
    else
    {
      Class Class = object_getClass(object1);
      unint64_t v7 = (objc_class *)MEMORY[0x1E4F14568];
      if (Class == (Class)MEMORY[0x1E4F14568]
        && object_getClass(object2) == v7
        && (size_t count = xpc_array_get_count(object1), xpc_array_get_count(object2) == count))
      {
        return nw_unordered_xpc_array_is_equal_inner(object1, object2, count);
      }
      else
      {
        return 0;
      }
    }
  }
  return result;
}

uint64_t nw_unordered_xpc_array_is_equal_inner(xpc_object_t xarray, void *a2, size_t a3)
{
  if (!a3) {
    return 1;
  }
  size_t v6 = 0;
  while (2)
  {
    xpc_object_t value = xpc_array_get_value(xarray, v6);
    size_t v8 = 0;
    while (1)
    {
      xpc_object_t v9 = xpc_array_get_value(a2, v8);
      if (v9)
      {
        if (xpc_equal(value, v9)) {
          break;
        }
      }
      if (a3 == ++v8)
      {
        char v15 = 0;
        return v15 & 1;
      }
    }
    if (++v6 != a3) {
      continue;
    }
    break;
  }
  BOOL v10 = 0;
  size_t v11 = 0;
  while (2)
  {
    xpc_object_t v12 = xpc_array_get_value(a2, v11);
    size_t v13 = 0;
    while (1)
    {
      xpc_object_t v14 = xpc_array_get_value(xarray, v13);
      if (v14)
      {
        if (xpc_equal(v12, v14)) {
          break;
        }
      }
      if (a3 == ++v13)
      {
        char v15 = v10;
        return v15 & 1;
      }
    }
    ++v11;
    char v15 = 1;
    BOOL v10 = v11 >= a3;
    if (v11 != a3) {
      continue;
    }
    break;
  }
  return v15 & 1;
}

uint64_t __nw_dispatch_data_is_equal_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  size_t v6 = *(NSObject **)(a1 + 40);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  v8[2] = __nw_dispatch_data_is_equal_block_invoke_2;
  v8[3] = &unk_1E5242BD0;
  void v8[4] = *(void *)(a1 + 32);
  v8[5] = a3;
  v8[6] = a5;
  v8[7] = a4;
  dispatch_data_apply(v6, v8);
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

BOOL __nw_dispatch_data_is_equal_block_invoke_2(void *a1, uint64_t a2, unint64_t a3, uint64_t a4, uint64_t a5)
{
  unint64_t v7 = a1[5];
  uint64_t v6 = a1[6];
  if (v7 <= a3) {
    unint64_t v8 = a3;
  }
  else {
    unint64_t v8 = a1[5];
  }
  unint64_t v9 = v6 + v7;
  if (v6 + v7 >= a5 + a3) {
    unint64_t v10 = a5 + a3;
  }
  else {
    unint64_t v10 = v6 + v7;
  }
  BOOL v11 = v10 > v8;
  size_t v12 = v10 - v8;
  if (v11)
  {
    *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = memcmp((const void *)(a4 + v8 - a3), (const void *)(a1[7] + v8 - v7), v12) == 0;
  }
  else
  {
    if (v9 < a3) {
      return 0;
    }
    if (a5 + a3 < v7) {
      return 1;
    }
  }
  return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) != 0;
}

uint64_t __nw_dictionary_dispose_block_invoke()
{
  pointer = (void *)xpc_dictionary_get_pointer();
  if (pointer) {
    os_release(pointer);
  }
  return 1;
}

uint64_t nw_dictionary_copy(uint64_t a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v22 = "nw_dictionary_copy";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v4, &type, &v19)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      int v22 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary";
      goto LABEL_16;
    }
    if (!v19)
    {
      unint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      int v22 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v16 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v16) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      int v22 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary, no backtrace";
      goto LABEL_16;
    }
    if (v16)
    {
      *(_DWORD *)long long buf = 136446466;
      int v22 = "nw_dictionary_copy";
      __int16 v23 = 2082;
      unsigned int v24 = backtrace_string;
      char v17 = "%{public}s called with null dictionary, dumping backtrace:%{public}s";
LABEL_40:
      _os_log_impl(&dword_1830D4000, v5, v6, v17, buf, 0x16u);
    }
LABEL_41:
    free(backtrace_string);
    goto LABEL_18;
  }
  if (!*(void *)(a1 + 16))
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v22 = "nw_dictionary_copy";
    unsigned int v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v4, &type, &v19)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      int v22 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary->xpc_object";
      goto LABEL_16;
    }
    if (!v19)
    {
      unint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      int v22 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v18 = os_log_type_enabled(v5, type);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_18;
      }
      *(_DWORD *)long long buf = 136446210;
      int v22 = "nw_dictionary_copy";
      unint64_t v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
      goto LABEL_16;
    }
    if (v18)
    {
      *(_DWORD *)long long buf = 136446466;
      int v22 = "nw_dictionary_copy";
      __int16 v23 = 2082;
      unsigned int v24 = backtrace_string;
      char v17 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
      goto LABEL_40;
    }
    goto LABEL_41;
  }
  objc_opt_class();
  uint64_t v2 = _os_object_alloc();
  if (v2)
  {
    uint64_t v3 = v2;
    *(void *)(v2 + 16) = xpc_copy(*(xpc_object_t *)(a1 + 16));
    xpc_dictionary_apply(*(xpc_object_t *)(a1 + 16), &__block_literal_global_48798);
    return v3;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)long long buf = 136446210;
  int v22 = "nw_dictionary_copy";
  unsigned int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v4, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "nw_dictionary_copy";
        unint64_t v7 = "%{public}s nw_dictionary_obj_alloc failed";
LABEL_16:
        size_t v12 = v5;
        os_log_type_t v13 = v6;
LABEL_17:
        _os_log_impl(&dword_1830D4000, v12, v13, v7, buf, 0xCu);
      }
    }
    else if (v19)
    {
      unint64_t v8 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v9 = gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v8)
      {
        if (v11)
        {
          *(_DWORD *)long long buf = 136446466;
          int v22 = "nw_dictionary_copy";
          __int16 v23 = 2082;
          unsigned int v24 = v8;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s nw_dictionary_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v8);
        goto LABEL_18;
      }
      if (v11)
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "nw_dictionary_copy";
        unint64_t v7 = "%{public}s nw_dictionary_obj_alloc failed, no backtrace";
        size_t v12 = v9;
        os_log_type_t v13 = v10;
        goto LABEL_17;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)long long buf = 136446210;
        int v22 = "nw_dictionary_copy";
        unint64_t v7 = "%{public}s nw_dictionary_obj_alloc failed, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_18:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t __nw_dictionary_copy_block_invoke()
{
  xpc_object_t value = (void *)xpc_pointer_get_value();
  if (value) {
    os_retain(value);
  }
  return 1;
}

BOOL NWPBHostEndpointReadFrom(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = (int *)MEMORY[0x1E4F940E8];
  uint64_t v4 = (int)*MEMORY[0x1E4F940E8];
  unint64_t v5 = *(void *)(a2 + v4);
  os_log_type_t v6 = (int *)MEMORY[0x1E4F940E0];
  unint64_t v7 = *(void *)(a2 + (int)*MEMORY[0x1E4F940E0]);
  unint64_t v8 = (int *)MEMORY[0x1E4F940C8];
  if (v5 < v7)
  {
    os_log_type_t v10 = (int *)MEMORY[0x1E4F940B8];
    while (1)
    {
      xpc_object_t v14 = (unsigned char *)(a2 + *v8);
      if (*v14) {
        return *(unsigned char *)(a2 + *v8) == 0;
      }
      if (v5 >= v7) {
        break;
      }
      char v15 = *(unsigned char *)(*(void *)(a2 + *v10) + v5);
      *(void *)(a2 + (int)v4) = v5 + 1;
      unint64_t v16 = v15 & 0x7F;
      if ((v15 & 0x80) == 0) {
        goto LABEL_40;
      }
      uint64_t v17 = *v3;
      unint64_t v18 = *(void *)(a2 + v17);
      if (v18 == -1 || v18 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v19 = v18 + 1;
      int v20 = *(char *)(*(void *)(a2 + *v10) + v18);
      *(void *)(a2 + v17) = v19;
      v16 |= (unint64_t)(v20 & 0x7F) << 7;
      if ((v20 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v21 = *v3;
      unint64_t v22 = *(void *)(a2 + v21);
      if (v22 == -1 || v22 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v23 = v22 + 1;
      int v24 = *(char *)(*(void *)(a2 + *v10) + v22);
      *(void *)(a2 + v21) = v23;
      v16 |= (unint64_t)(v24 & 0x7F) << 14;
      if ((v24 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v25 = *v3;
      unint64_t v26 = *(void *)(a2 + v25);
      if (v26 == -1 || v26 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v27 = v26 + 1;
      int v28 = *(char *)(*(void *)(a2 + *v10) + v26);
      *(void *)(a2 + v25) = v27;
      v16 |= (unint64_t)(v28 & 0x7F) << 21;
      if ((v28 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v29 = *v3;
      unint64_t v30 = *(void *)(a2 + v29);
      if (v30 == -1 || v30 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v31 = v30 + 1;
      int v32 = *(char *)(*(void *)(a2 + *v10) + v30);
      *(void *)(a2 + v29) = v31;
      v16 |= (unint64_t)(v32 & 0x7F) << 28;
      if ((v32 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v33 = *v3;
      unint64_t v34 = *(void *)(a2 + v33);
      if (v34 == -1 || v34 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v35 = v34 + 1;
      int v36 = *(char *)(*(void *)(a2 + *v10) + v34);
      *(void *)(a2 + v33) = v35;
      if ((v36 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v37 = *v3;
      unint64_t v38 = *(void *)(a2 + v37);
      if (v38 == -1 || v38 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v39 = v38 + 1;
      int v40 = *(char *)(*(void *)(a2 + *v10) + v38);
      *(void *)(a2 + v37) = v39;
      if ((v40 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v41 = *v3;
      unint64_t v42 = *(void *)(a2 + v41);
      if (v42 == -1 || v42 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v43 = v42 + 1;
      int v44 = *(char *)(*(void *)(a2 + *v10) + v42);
      *(void *)(a2 + v41) = v43;
      if ((v44 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v45 = *v3;
      unint64_t v46 = *(void *)(a2 + v45);
      if (v46 == -1 || v46 >= *(void *)(a2 + *v6)) {
        goto LABEL_38;
      }
      unint64_t v47 = v46 + 1;
      int v48 = *(char *)(*(void *)(a2 + *v10) + v46);
      *(void *)(a2 + v45) = v47;
      if ((v48 & 0x80000000) == 0) {
        goto LABEL_40;
      }
      uint64_t v49 = *v3;
      unint64_t v50 = *(void *)(a2 + v49);
      if (v50 == -1 || v50 >= *(void *)(a2 + *v6))
      {
LABEL_38:
        xpc_object_t v14 = (unsigned char *)(a2 + *v8);
        goto LABEL_39;
      }
      unint64_t v51 = v50 + 1;
      int v52 = *(char *)(*(void *)(a2 + *v10) + v50);
      *(void *)(a2 + v49) = v51;
      if (v52 < 0)
      {
        unint64_t v16 = 0;
        int v53 = *(unsigned __int8 *)(a2 + *v8);
        goto LABEL_42;
      }
LABEL_40:
      int v53 = *(unsigned __int8 *)(a2 + *v8);
      if (*(unsigned char *)(a2 + *v8)) {
        unint64_t v16 = 0;
      }
LABEL_42:
      if (v53) {
        BOOL v54 = 1;
      }
      else {
        BOOL v54 = (v16 & 7) == 4;
      }
      if (v54) {
        return *(unsigned char *)(a2 + *v8) == 0;
      }
      if ((v16 >> 3) == 2)
      {
        uint64_t v11 = PBReaderReadString();
        uint64_t v12 = 16;
LABEL_4:
        os_log_type_t v13 = *(void **)(a1 + v12);
        *(void *)(a1 + v12) = v11;

        goto LABEL_5;
      }
      if ((v16 >> 3) == 1)
      {
        uint64_t v11 = PBReaderReadString();
        uint64_t v12 = 8;
        goto LABEL_4;
      }
      if ((PBReaderSkipValueWithTag() & 1) == 0) {
        return 0;
      }
LABEL_5:
      uint64_t v4 = *v3;
      unint64_t v5 = *(void *)(a2 + v4);
      unint64_t v7 = *(void *)(a2 + *v6);
      if (v5 >= v7) {
        return *(unsigned char *)(a2 + *v8) == 0;
      }
    }
    unint64_t v16 = 0;
LABEL_39:
    unsigned char *v14 = 1;
    goto LABEL_40;
  }
  return *(unsigned char *)(a2 + *v8) == 0;
}

BOOL nw_http_get_binary_message_length(nw_protocol_metadata *a1, unint64_t a2)
{
  return nw_http_get_binary_message_length_inner(a1, 0, a2);
}

BOOL nw_http_get_binary_message_length_inner(nw_protocol_metadata *a1, int a2, unint64_t a3)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
    unint64_t v42 = (char *)_os_log_send_and_compose_impl();
    v64[0] = 16;
    v62[0] = 0;
    if (!__nwlog_fault(v42, v64, v62)) {
      goto LABEL_90;
    }
    if (v64[0] == 17)
    {
      unint64_t v43 = __nwlog_obj();
      os_log_type_t v44 = v64[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v64[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        uint64_t v45 = "%{public}s called with null metadata";
LABEL_89:
        _os_log_impl(&dword_1830D4000, v43, v44, v45, buf, 0xCu);
      }
LABEL_90:
      if (v42) {
        free(v42);
      }
      return 0;
    }
    if (!v62[0])
    {
      unint64_t v43 = __nwlog_obj();
      os_log_type_t v44 = v64[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v64[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        uint64_t v45 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v43 = __nwlog_obj();
    os_log_type_t v44 = v64[0];
    BOOL v47 = os_log_type_enabled(v43, (os_log_type_t)v64[0]);
    if (!backtrace_string)
    {
      if (v47)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        uint64_t v45 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (v47)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v48 = "%{public}s called with null metadata, dumping backtrace:%{public}s";
LABEL_74:
      _os_log_impl(&dword_1830D4000, v43, v44, v48, buf, 0x16u);
    }
LABEL_75:
    free(backtrace_string);
    goto LABEL_90;
  }
  if (a3 && a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
    unint64_t v42 = (char *)_os_log_send_and_compose_impl();
    v64[0] = 16;
    v62[0] = 0;
    if (!__nwlog_fault(v42, v64, v62)) {
      goto LABEL_90;
    }
    if (v64[0] == 17)
    {
      unint64_t v43 = __nwlog_obj();
      os_log_type_t v44 = v64[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v64[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        uint64_t v45 = "%{public}s called with null (!(indeterminate && body_length > 0))";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v62[0])
    {
      unint64_t v43 = __nwlog_obj();
      os_log_type_t v44 = v64[0];
      if (os_log_type_enabled(v43, (os_log_type_t)v64[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        uint64_t v45 = "%{public}s called with null (!(indeterminate && body_length > 0)), backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unint64_t v43 = __nwlog_obj();
    os_log_type_t v44 = v64[0];
    BOOL v53 = os_log_type_enabled(v43, (os_log_type_t)v64[0]);
    if (!backtrace_string)
    {
      if (v53)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
        uint64_t v45 = "%{public}s called with null (!(indeterminate && body_length > 0)), no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (v53)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http_get_binary_message_length_inner";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v48 = "%{public}s called with null (!(indeterminate && body_length > 0)), dumping backtrace:%{public}s";
      goto LABEL_74;
    }
    goto LABEL_75;
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2000000000;
  uint64_t v67 = 0;
  int type = nw_http_metadata_get_type(a1);
  ++*(void *)(*(void *)&buf[8] + 24);
  if (type == 1)
  {
    id v7 = nw_http_metadata_copy_request(a1);
    if (v7)
    {
      v61[0] = MEMORY[0x1E4F143A8];
      v61[1] = 0x40000000;
      v61[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke;
      v61[3] = &unk_1E5242D28;
      v61[4] = buf;
      id v8 = v7;
      unint64_t v9 = v61;
      _nw_http_request_access_method((uint64_t)v8, v9);

      v60[0] = MEMORY[0x1E4F143A8];
      v60[1] = 0x40000000;
      v60[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_2;
      v60[3] = &unk_1E5242D50;
      v60[4] = buf;
      id v10 = v8;
      uint64_t v11 = v60;
      _nw_http_request_access_scheme((uint64_t)v10, v11);

      v59[0] = MEMORY[0x1E4F143A8];
      v59[1] = 0x40000000;
      v59[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_3;
      v59[3] = &unk_1E5242D78;
      v59[4] = buf;
      id v12 = v10;
      os_log_type_t v13 = v59;
      _nw_http_request_access_authority((uint64_t)v12, v13);

      v58[0] = MEMORY[0x1E4F143A8];
      v58[1] = 0x40000000;
      v58[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_4;
      v58[3] = &unk_1E5242DA0;
      v58[4] = buf;
      id v14 = v12;
      char v15 = v58;
      _nw_http_request_access_path((uint64_t)v14, v15);

LABEL_12:
      os_release(v14);
      goto LABEL_13;
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int v64 = 136446210;
    *(void *)&v64[4] = "nw_http_get_binary_message_length_inner";
    uint64_t v49 = (char *)_os_log_send_and_compose_impl();
    v62[0] = 16;
    LOBYTE(v6_Block_object_dispose(&a9, 8) = 0;
    if (__nwlog_fault(v49, v62, &v68))
    {
      if (v62[0] == 17)
      {
        unint64_t v50 = __nwlog_obj();
        os_log_type_t v51 = v62[0];
        if (os_log_type_enabled(v50, (os_log_type_t)v62[0]))
        {
          *(_DWORD *)unsigned int v64 = 136446210;
          *(void *)&v64[4] = "nw_http_get_binary_message_length_inner";
          int v52 = "%{public}s called with null request";
LABEL_97:
          _os_log_impl(&dword_1830D4000, v50, v51, v52, v64, 0xCu);
        }
      }
      else if ((_BYTE)v68)
      {
        BOOL v54 = (char *)__nw_create_backtrace_string();
        unint64_t v50 = __nwlog_obj();
        os_log_type_t v51 = v62[0];
        BOOL v55 = os_log_type_enabled(v50, (os_log_type_t)v62[0]);
        if (v54)
        {
          if (v55)
          {
            *(_DWORD *)unsigned int v64 = 136446466;
            *(void *)&v64[4] = "nw_http_get_binary_message_length_inner";
            *(_WORD *)&v64[12] = 2082;
            *(void *)&v64[14] = v54;
            _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s called with null request, dumping backtrace:%{public}s", v64, 0x16u);
          }
          free(v54);
          goto LABEL_98;
        }
        if (v55)
        {
          *(_DWORD *)unsigned int v64 = 136446210;
          *(void *)&v64[4] = "nw_http_get_binary_message_length_inner";
          int v52 = "%{public}s called with null request, no backtrace";
          goto LABEL_97;
        }
      }
      else
      {
        unint64_t v50 = __nwlog_obj();
        os_log_type_t v51 = v62[0];
        if (os_log_type_enabled(v50, (os_log_type_t)v62[0]))
        {
          *(_DWORD *)unsigned int v64 = 136446210;
          *(void *)&v64[4] = "nw_http_get_binary_message_length_inner";
          int v52 = "%{public}s called with null request, backtrace limit exceeded";
          goto LABEL_97;
        }
      }
    }
LABEL_98:
    if (v49) {
      free(v49);
    }
    unint64_t v37 = 0;
    goto LABEL_42;
  }
  id v14 = nw_http_metadata_copy_response(a1);
  unsigned int status_code = nw_http_response_get_status_code(v14);
  uint64_t v17 = 4;
  if (status_code < 0x4000) {
    uint64_t v17 = 2;
  }
  if (status_code < 0x40) {
    uint64_t v17 = 1;
  }
  *(void *)(*(void *)&buf[8] + 24) += v17;
  if (v14) {
    goto LABEL_12;
  }
LABEL_13:
  *(void *)unsigned int v64 = 0;
  *(void *)&os_log_type_t v64[8] = v64;
  *(void *)&v64[16] = 0x2000000000;
  uint64_t v65 = 0;
  id v18 = nw_http_metadata_copy_header_fields(a1);
  v57[0] = MEMORY[0x1E4F143A8];
  v57[1] = 0x40000000;
  v57[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_5;
  v57[3] = &unk_1E5242DC8;
  v57[4] = v64;
  nw_http_fields_enumerate(v18, v57);
  uint64_t v19 = *(void *)&v64[8];
  unint64_t v20 = *(void *)(*(void *)&v64[8] + 24);
  if (a2)
  {
    uint64_t v21 = *(void *)&buf[8];
    unint64_t v22 = v20 + *(void *)(*(void *)&buf[8] + 24);
    goto LABEL_39;
  }
  if (v20 >= 0x40)
  {
    if (v20 >= 0x4000)
    {
      if (v20 >> 30)
      {
        if (v20 >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unsigned int v62 = 136446466;
          *(void *)&v62[4] = "_http_vle_length";
          *(_WORD *)&v62[12] = 2048;
          *(void *)&v62[14] = v20;
          int v24 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v24);
          if (result) {
            goto LABEL_101;
          }
          free(v24);
          uint64_t v23 = 0;
          uint64_t v19 = *(void *)&v64[8];
        }
        else
        {
          uint64_t v23 = 8;
        }
      }
      else
      {
        uint64_t v23 = 4;
      }
    }
    else
    {
      uint64_t v23 = 2;
    }
  }
  else
  {
    uint64_t v23 = 1;
  }
  uint64_t v26 = *(void *)&buf[8];
  uint64_t v27 = *(void *)(*(void *)&buf[8] + 24) + v23;
  *(void *)(*(void *)&buf[8] + 24) = v27;
  uint64_t v28 = *(void *)(v19 + 24) + v27;
  *(void *)(v26 + 24) = v28;
  if (a3 >= 0x40)
  {
    if (a3 >= 0x4000)
    {
      if (a3 >> 30)
      {
        if (a3 >> 62)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
          *(_DWORD *)unsigned int v62 = 136446466;
          *(void *)&v62[4] = "_http_vle_length";
          *(_WORD *)&v62[12] = 2048;
          *(void *)&v62[14] = a3;
          unint64_t v30 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v30);
          if (result) {
            goto LABEL_101;
          }
          free(v30);
          uint64_t v29 = 0;
          uint64_t v26 = *(void *)&buf[8];
          uint64_t v28 = *(void *)(*(void *)&buf[8] + 24);
        }
        else
        {
          uint64_t v29 = 8;
        }
      }
      else
      {
        uint64_t v29 = 4;
      }
    }
    else
    {
      uint64_t v29 = 2;
    }
  }
  else
  {
    uint64_t v29 = 1;
  }
  *(void *)(v26 + 24) = v29 + a3 + v28;
  id v31 = nw_http_metadata_copy_trailer_fields(a1);
  if (!v31)
  {
    uint64_t v21 = *(void *)&buf[8];
    unint64_t v22 = *(void *)(*(void *)&buf[8] + 24);
LABEL_39:
    unint64_t v37 = v22 + 1;
    *(void *)(v21 + 24) = v22 + 1;
    if (!v18)
    {
LABEL_41:
      _Block_object_dispose(v64, 8);
LABEL_42:
      _Block_object_dispose(buf, 8);
      return v37;
    }
LABEL_40:
    os_release(v18);
    goto LABEL_41;
  }
  *(void *)unsigned int v62 = 0;
  *(void *)&v62[8] = v62;
  *(void *)&v62[16] = 0x2000000000;
  uint64_t v63 = 0;
  v56[0] = MEMORY[0x1E4F143A8];
  v56[1] = 0x40000000;
  v56[2] = ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_6;
  v56[3] = &unk_1E5242DF0;
  v56[4] = v62;
  id v32 = v31;
  uint64_t v33 = v56;
  _nw_http_fields_enumerate((uint64_t)v32, v33);

  uint64_t v34 = *(void *)&v62[8];
  unint64_t v35 = *(void *)(*(void *)&v62[8] + 24);
  if (v35 < 0x40)
  {
    uint64_t v36 = 1;
    goto LABEL_52;
  }
  if (v35 < 0x4000)
  {
    uint64_t v36 = 2;
    goto LABEL_52;
  }
  if (!(v35 >> 30))
  {
    uint64_t v36 = 4;
    goto LABEL_52;
  }
  if (!(v35 >> 62))
  {
    uint64_t v36 = 8;
    goto LABEL_52;
  }
  unint64_t v38 = __nwlog_obj();
  os_log_type_enabled(v38, OS_LOG_TYPE_ERROR);
  int v68 = 136446466;
  unsigned int v69 = "_http_vle_length";
  __int16 v70 = 2048;
  unint64_t v71 = v35;
  unint64_t v39 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v39);
  if (!result)
  {
    free(v39);
    uint64_t v36 = 0;
    uint64_t v34 = *(void *)&v62[8];
LABEL_52:
    uint64_t v40 = *(void *)&buf[8];
    uint64_t v41 = *(void *)(*(void *)&buf[8] + 24) + v36;
    *(void *)(*(void *)&buf[8] + 24) = v41;
    *(void *)(v40 + 24) = *(void *)(v34 + 24) + v41;
    _Block_object_dispose(v62, 8);
    os_release(v32);
    unint64_t v37 = *(void *)(*(void *)&buf[8] + 24);
    if (!v18) {
      goto LABEL_41;
    }
    goto LABEL_40;
  }
LABEL_101:
  __break(1u);
  return result;
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke(uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0;
    uint64_t v5 = 1;
    goto LABEL_13;
  }
  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v4;
    return;
  }
  if (v3 < 0x4000)
  {
    uint64_t v5 = 2;
    goto LABEL_13;
  }
  if (!(v3 >> 30))
  {
    uint64_t v5 = 4;
    goto LABEL_13;
  }
  if (!(v3 >> 62))
  {
    uint64_t v5 = 8;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0;
    goto LABEL_13;
  }
  __break(1u);
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_2(uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0;
    uint64_t v5 = 1;
    goto LABEL_13;
  }
  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v4;
    return;
  }
  if (v3 < 0x4000)
  {
    uint64_t v5 = 2;
    goto LABEL_13;
  }
  if (!(v3 >> 30))
  {
    uint64_t v5 = 4;
    goto LABEL_13;
  }
  if (!(v3 >> 62))
  {
    uint64_t v5 = 8;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0;
    goto LABEL_13;
  }
  __break(1u);
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_3(uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0;
    uint64_t v5 = 1;
    goto LABEL_13;
  }
  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v4;
    return;
  }
  if (v3 < 0x4000)
  {
    uint64_t v5 = 2;
    goto LABEL_13;
  }
  if (!(v3 >> 30))
  {
    uint64_t v5 = 4;
    goto LABEL_13;
  }
  if (!(v3 >> 62))
  {
    uint64_t v5 = 8;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0;
    goto LABEL_13;
  }
  __break(1u);
}

void ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_4(uint64_t a1, char *__s)
{
  if (!__s)
  {
    size_t v4 = 0;
    uint64_t v5 = 1;
    goto LABEL_13;
  }
  size_t v3 = strlen(__s);
  size_t v4 = v3;
  if (v3 < 0x40)
  {
    uint64_t v5 = 1;
LABEL_13:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v4;
    return;
  }
  if (v3 < 0x4000)
  {
    uint64_t v5 = 2;
    goto LABEL_13;
  }
  if (!(v3 >> 30))
  {
    uint64_t v5 = 4;
    goto LABEL_13;
  }
  if (!(v3 >> 62))
  {
    uint64_t v5 = 8;
    goto LABEL_13;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  os_log_type_t v6 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v6))
  {
    free(v6);
    uint64_t v5 = 0;
    goto LABEL_13;
  }
  __break(1u);
}

BOOL ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_5(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += a5 + a3 + v8 + v9;
    return 1;
  }
  if (a3 < 0x4000)
  {
    uint64_t v8 = 2;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (!(a3 >> 30))
  {
    uint64_t v8 = 4;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    id v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v8 = 8;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
LABEL_15:
  if (a5 < 0x4000)
  {
    uint64_t v9 = 2;
    goto LABEL_23;
  }
  if (!(a5 >> 30))
  {
    uint64_t v9 = 4;
    goto LABEL_23;
  }
  if (!(a5 >> 62))
  {
    uint64_t v9 = 8;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  id v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v9 = 0;
    goto LABEL_23;
  }
LABEL_24:
  __break(1u);
  return result;
}

BOOL ___ZL39nw_http_get_binary_message_length_innerP20nw_protocol_metadatabm_block_invoke_6(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += a5 + a3 + v8 + v9;
    return 1;
  }
  if (a3 < 0x4000)
  {
    uint64_t v8 = 2;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (!(a3 >> 30))
  {
    uint64_t v8 = 4;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    id v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v8 = 8;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
LABEL_15:
  if (a5 < 0x4000)
  {
    uint64_t v9 = 2;
    goto LABEL_23;
  }
  if (!(a5 >> 30))
  {
    uint64_t v9 = 4;
    goto LABEL_23;
  }
  if (!(a5 >> 62))
  {
    uint64_t v9 = 8;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  id v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v9 = 0;
    goto LABEL_23;
  }
LABEL_24:
  __break(1u);
  return result;
}

BOOL nw_http_get_indeterminate_binary_message_header_length(nw_protocol_metadata *a1)
{
  return nw_http_get_binary_message_length_inner(a1, 1, 0);
}

BOOL __nw_http_get_indeterminate_binary_message_chunk_length_block_invoke(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += a5 + a3 + v8 + v9;
    return 1;
  }
  if (a3 < 0x4000)
  {
    uint64_t v8 = 2;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (!(a3 >> 30))
  {
    uint64_t v8 = 4;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    id v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v8 = 8;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
LABEL_15:
  if (a5 < 0x4000)
  {
    uint64_t v9 = 2;
    goto LABEL_23;
  }
  if (!(a5 >> 30))
  {
    uint64_t v9 = 4;
    goto LABEL_23;
  }
  if (!(a5 >> 62))
  {
    uint64_t v9 = 8;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  id v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v9 = 0;
    goto LABEL_23;
  }
LABEL_24:
  __break(1u);
  return result;
}

BOOL nw_http_fillout_binary_message(nw_protocol_metadata *a1, unsigned __int8 *a2, size_t a3, unsigned __int8 *a4, uint64_t a5)
{
  return nw_http_fillout_binary_message_inner(a1, 0, a2, a3, a4, a5);
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke(uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!__s)
  {
    size_t v5 = 0;
    goto LABEL_6;
  }
  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1;
    goto LABEL_7;
  }
  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2;
    goto LABEL_7;
  }
  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4;
    goto LABEL_7;
  }
  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000);
    size_t v6 = 8;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    id v7 = (void *)(a1 + 32);
    uint64_t v9 = *(char **)(*(void *)(v8 + 8) + 24);
    id v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            unint64_t v38 = __nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)long long buf = 136446978;
              os_log_type_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              BOOL v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v11 + 24) = 0;
        }
        os_log_type_t v13 = &v9[v6];
        goto LABEL_13;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (!v48)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v40)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = backtrace_string;
        unint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
        }
LABEL_112:
        if (v23) {
          free(v23);
        }
        os_log_type_t v13 = 0;
        goto LABEL_13;
      }
      if (!v48)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v36)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = backtrace_string;
        unint64_t v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_1830D4000, v24, v25, v37, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_112;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  os_log_type_t v51 = "_http_vle_encode";
  __int16 v52 = 2048;
  BOOL v53 = (const char *)v5;
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }
  free(v17);
  uint64_t v18 = *(void *)(a1 + 32);
  id v7 = (void *)(a1 + 32);
  os_log_type_t v13 = *(char **)(*(void *)(v18 + 8) + 24);
  id v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8) + 24) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8) + 24);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v19, &type, &v48)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor";
    }
    else
    {
      if (!v48)
      {
        unint64_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        unint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }
      id v31 = (char *)__nw_create_backtrace_string();
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          __int16 v52 = 2082;
          BOOL v53 = v31;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }
      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor, no backtrace";
    }
LABEL_100:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }
  if (v5)
  {
    if (__s)
    {
      uint64_t v15 = *(void *)(*v10 + 8);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        unint64_t v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = __nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v45 = *(void *)(v15 + 24);
              *(_DWORD *)long long buf = 136446978;
              os_log_type_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              BOOL v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v5;
              __int16 v56 = 2048;
              uint64_t v57 = v45;
              _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v15 + 24) = 0;
        }
        v14 += v5;
        goto LABEL_21;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      uint64_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v46)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = v41;
        unint64_t v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
        }
LABEL_120:
        if (v27) {
          free(v27);
        }
        id v14 = 0;
        goto LABEL_21;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      uint64_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v42)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = v41;
        unint64_t v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_1830D4000, v28, v29, v43, buf, 0x16u);
      }
    }
    free(v41);
    goto LABEL_120;
  }
LABEL_21:
  *(void *)(*(void *)(*v7 + 8) + 24) = v14;
  if (*(void *)(*(void *)(*v7 + 8) + 24)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }
    uint64_t v33 = (char *)__nw_create_backtrace_string();
    unint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = __src;
    BOOL v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }
    if (v34)
    {
      *(_DWORD *)long long buf = 136446466;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      __int16 v52 = 2082;
      BOOL v53 = v33;
      _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v33);
  }
LABEL_101:
  if (v19) {
LABEL_102:
  }
    free(v19);
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_20(uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!__s)
  {
    size_t v5 = 0;
    goto LABEL_6;
  }
  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    unint64_t __src = v5;
    size_t v6 = 1;
    goto LABEL_7;
  }
  if (!(v4 >> 14))
  {
    unint64_t __src = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2;
    goto LABEL_7;
  }
  if (!(v4 >> 30))
  {
    unint64_t __src = bswap32(v4 | 0x80000000);
    size_t v6 = 4;
    goto LABEL_7;
  }
  if (!(v4 >> 62))
  {
    unint64_t __src = bswap64(v4 | 0xC000000000000000);
    size_t v6 = 8;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    id v7 = (void *)(a1 + 32);
    uint64_t v9 = *(char **)(*(void *)(v8 + 8) + 24);
    id v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            unint64_t v38 = __nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)long long buf = 136446978;
              os_log_type_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              BOOL v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v11 + 24) = 0;
        }
        os_log_type_t v13 = &v9[v6];
        goto LABEL_13;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (!v48)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v40)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = backtrace_string;
        unint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
        }
LABEL_112:
        if (v23) {
          free(v23);
        }
        os_log_type_t v13 = 0;
        goto LABEL_13;
      }
      if (!v48)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          uint64_t v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v36)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = backtrace_string;
        unint64_t v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_1830D4000, v24, v25, v37, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_112;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  os_log_type_t v51 = "_http_vle_encode";
  __int16 v52 = 2048;
  BOOL v53 = (const char *)v5;
  uint64_t v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }
  free(v17);
  uint64_t v18 = *(void *)(a1 + 32);
  id v7 = (void *)(a1 + 32);
  os_log_type_t v13 = *(char **)(*(void *)(v18 + 8) + 24);
  id v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8) + 24) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8) + 24);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v19, &type, &v48)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor";
    }
    else
    {
      if (!v48)
      {
        unint64_t v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        unint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }
      id v31 = (char *)__nw_create_backtrace_string();
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          __int16 v52 = 2082;
          BOOL v53 = v31;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }
      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor, no backtrace";
    }
LABEL_100:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }
  if (v5)
  {
    if (__s)
    {
      uint64_t v15 = *(void *)(*v10 + 8);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        unint64_t v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            os_log_type_t v44 = __nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v45 = *(void *)(v15 + 24);
              *(_DWORD *)long long buf = 136446978;
              os_log_type_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              BOOL v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v5;
              __int16 v56 = 2048;
              uint64_t v57 = v45;
              _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v15 + 24) = 0;
        }
        v14 += v5;
        goto LABEL_21;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      uint64_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v46)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = v41;
        unint64_t v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "_http_safe_append";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
        }
LABEL_120:
        if (v27) {
          free(v27);
        }
        id v14 = 0;
        goto LABEL_21;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      uint64_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v51 = "_http_safe_append";
          unint64_t v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v42)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        BOOL v53 = v41;
        unint64_t v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_1830D4000, v28, v29, v43, buf, 0x16u);
      }
    }
    free(v41);
    goto LABEL_120;
  }
LABEL_21:
  *(void *)(*(void *)(*v7 + 8) + 24) = v14;
  if (*(void *)(*(void *)(*v7 + 8) + 24)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      unint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }
    uint64_t v33 = (char *)__nw_create_backtrace_string();
    unint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = __src;
    BOOL v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      unint64_t v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }
    if (v34)
    {
      *(_DWORD *)long long buf = 136446466;
      os_log_type_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      __int16 v52 = 2082;
      BOOL v53 = v33;
      _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v33);
  }
LABEL_101:
  if (v19) {
LABEL_102:
  }
    free(v19);
}

BOOL ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_22(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += a5 + a3 + v8 + v9;
    return 1;
  }
  if (a3 < 0x4000)
  {
    uint64_t v8 = 2;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (!(a3 >> 30))
  {
    uint64_t v8 = 4;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    id v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v8 = 8;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
LABEL_15:
  if (a5 < 0x4000)
  {
    uint64_t v9 = 2;
    goto LABEL_23;
  }
  if (!(a5 >> 30))
  {
    uint64_t v9 = 4;
    goto LABEL_23;
  }
  if (!(a5 >> 62))
  {
    uint64_t v9 = 8;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  unint64_t v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v9 = 0;
    goto LABEL_23;
  }
LABEL_24:
  __break(1u);
  return result;
}

uint64_t ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_24(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2;
  v4[3] = &unk_1E5242EE0;
  long long v5 = *(_OWORD *)(a1 + 32);
  nw_http_field_access_canonical(a3, v4);
  return 1;
}

BOOL ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_27(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, unint64_t a5)
{
  if (a3 < 0x40)
  {
    uint64_t v8 = 1;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
LABEL_12:
    uint64_t v9 = 1;
LABEL_23:
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += a5 + a3 + v8 + v9;
    return 1;
  }
  if (a3 < 0x4000)
  {
    uint64_t v8 = 2;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (!(a3 >> 30))
  {
    uint64_t v8 = 4;
    if (a5 >= 0x40) {
      goto LABEL_15;
    }
    goto LABEL_12;
  }
  if (a3 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    id v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (result) {
      goto LABEL_24;
    }
    free(v10);
    uint64_t v8 = 0;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
  else
  {
    uint64_t v8 = 8;
    if (a5 < 0x40) {
      goto LABEL_12;
    }
  }
LABEL_15:
  if (a5 < 0x4000)
  {
    uint64_t v9 = 2;
    goto LABEL_23;
  }
  if (!(a5 >> 30))
  {
    uint64_t v9 = 4;
    goto LABEL_23;
  }
  if (!(a5 >> 62))
  {
    uint64_t v9 = 8;
    goto LABEL_23;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  unint64_t v12 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v9 = 0;
    goto LABEL_23;
  }
LABEL_24:
  __break(1u);
  return result;
}

uint64_t ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_29(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_2_30;
  v4[3] = &unk_1E5242F58;
  long long v5 = *(_OWORD *)(a1 + 32);
  nw_http_field_access_canonical(a3, v4);
  return 1;
}

BOOL nw_http_fillout_indeterminate_binary_message_header(nw_protocol_metadata *a1, unsigned __int8 *a2, uint64_t a3)
{
  return nw_http_fillout_binary_message_inner(a1, 1, 0, 0, a2, a3);
}

uint64_t __nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 0x40000000;
  v4[2] = __nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke_2;
  v4[3] = &unk_1E5242CD8;
  long long v5 = *(_OWORD *)(a1 + 32);
  nw_http_field_access_canonical(a3, v4);
  return 1;
}

void __nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke_2(uint64_t a1, const void *a2, size_t a3, const void *a4, size_t a5)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  if (a3 <= 0x3F)
  {
    unint64_t __src = a3;
    size_t v10 = 1;
    goto LABEL_9;
  }
  if (!(a3 >> 14))
  {
    unint64_t __src = bswap32(a3 | 0x4000) >> 16;
    size_t v10 = 2;
    goto LABEL_9;
  }
  if (!(a3 >> 30))
  {
    unint64_t __src = bswap32(a3 | 0x80000000);
    size_t v10 = 4;
    goto LABEL_9;
  }
  if (!(a3 >> 62))
  {
    unint64_t __src = bswap64(a3 | 0xC000000000000000);
    size_t v10 = 8;
LABEL_9:
    uint64_t v11 = a1 + 32;
    unint64_t v12 = *(char **)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    uint64_t v13 = a1 + 40;
    if (v12)
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 8);
      if (*(void *)(v14 + 24) >= v10)
      {
        memcpy(v12, &__src, v10);
        unint64_t v15 = *(void *)(v14 + 24);
        *(void *)(v14 + 24) = v15 - v10;
        if (v15 < v10)
        {
          if (gLogDatapath)
          {
            BOOL v60 = __nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v61 = *(void *)(v14 + 24);
              *(_DWORD *)long long buf = 136446978;
              uint64_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              uint64_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = v10;
              __int16 v88 = 2048;
              uint64_t v89 = v61;
              _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v14 + 24) = 0;
        }
        unint64_t v16 = &v12[v10];
        goto LABEL_15;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (!__nwlog_fault(v35, &type, &v80)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (!v80)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v62 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (v62)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        uint64_t v85 = backtrace_string;
        uint64_t v59 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_124;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "_http_safe_append";
      unint64_t v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v80 = 0;
      if (!__nwlog_fault(v35, &type, &v80)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null buffer";
LABEL_194:
          _os_log_impl(&dword_1830D4000, v36, v37, v38, buf, 0xCu);
        }
LABEL_195:
        if (v35) {
          free(v35);
        }
        unint64_t v16 = 0;
        goto LABEL_15;
      }
      if (!v80)
      {
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v36 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v58 = os_log_type_enabled(v36, type);
      if (!backtrace_string)
      {
        if (v58)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v38 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_194;
        }
        goto LABEL_195;
      }
      if (v58)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        uint64_t v85 = backtrace_string;
        uint64_t v59 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_124:
        _os_log_impl(&dword_1830D4000, v36, v37, v59, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_195;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  uint64_t v83 = "_http_vle_encode";
  __int16 v84 = 2048;
  uint64_t v85 = (const char *)a3;
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v28)) {
    goto LABEL_220;
  }
  free(v28);
  uint64_t v29 = *(void *)(a1 + 32);
  uint64_t v11 = a1 + 32;
  unint64_t v16 = *(char **)(*(void *)(v29 + 8) + 24);
  uint64_t v13 = v11 + 8;
LABEL_15:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v16;
  uint64_t v17 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (!v17)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke_2";
    id v31 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v80 = 0;
    if (!__nwlog_fault(v31, &type, &v80)) {
      goto LABEL_184;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor";
LABEL_183:
      _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0xCu);
      goto LABEL_184;
    }
    if (!v80)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (!os_log_type_enabled(v32, type)) {
        goto LABEL_184;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }
    os_log_type_t v51 = (char *)__nw_create_backtrace_string();
    BOOL v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v52 = os_log_type_enabled(v32, type);
    if (!v51)
    {
      if (!v52) {
        goto LABEL_184;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }
    if (!v52) {
      goto LABEL_107;
    }
LABEL_106:
    *(_DWORD *)long long buf = 136446466;
    uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    __int16 v84 = 2082;
    uint64_t v85 = v51;
    _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    goto LABEL_107;
  }
  if (a3)
  {
    if (a2)
    {
      uint64_t v18 = *(void *)(*(void *)v13 + 8);
      if (*(void *)(v18 + 24) >= a3)
      {
        memcpy(v17, a2, a3);
        unint64_t v19 = *(void *)(v18 + 24);
        *(void *)(v18 + 24) = v19 - a3;
        if (v19 < a3)
        {
          if (gLogDatapath)
          {
            __int16 v70 = __nwlog_obj();
            if (os_log_type_enabled(v70, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v71 = *(void *)(v18 + 24);
              *(_DWORD *)long long buf = 136446978;
              uint64_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              uint64_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = a3;
              __int16 v88 = 2048;
              uint64_t v89 = v71;
              _os_log_impl(&dword_1830D4000, v70, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v18 + 24) = 0;
        }
        v17 += a3;
        goto LABEL_23;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "_http_safe_append";
      unint64_t v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v43, &__src, &type)) {
        goto LABEL_209;
      }
      if (__src == 17)
      {
        os_log_type_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          BOOL v46 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          BOOL v46 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      uint64_t v67 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v45 = __src;
      BOOL v72 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v72)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          BOOL v46 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (v72)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        uint64_t v85 = v67;
        unsigned int v69 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_143;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "_http_safe_append";
      unint64_t v43 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v43, &__src, &type)) {
        goto LABEL_209;
      }
      if (__src == 17)
      {
        os_log_type_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          BOOL v46 = "%{public}s called with null data";
LABEL_208:
          _os_log_impl(&dword_1830D4000, v44, v45, v46, buf, 0xCu);
        }
LABEL_209:
        if (v43) {
          free(v43);
        }
        uint64_t v17 = 0;
        goto LABEL_23;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v44 = __nwlog_obj();
        os_log_type_t v45 = __src;
        if (os_log_type_enabled(v44, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          BOOL v46 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      uint64_t v67 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v45 = __src;
      BOOL v68 = os_log_type_enabled(v44, (os_log_type_t)__src);
      if (!v67)
      {
        if (v68)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          BOOL v46 = "%{public}s called with null data, no backtrace";
          goto LABEL_208;
        }
        goto LABEL_209;
      }
      if (v68)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        uint64_t v85 = v67;
        unsigned int v69 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_143:
        _os_log_impl(&dword_1830D4000, v44, v45, v69, buf, 0x16u);
      }
    }
    free(v67);
    goto LABEL_209;
  }
LABEL_23:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v17;
  unint64_t v20 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    id v31 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(__src) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v31, &__src, &type)) {
      goto LABEL_184;
    }
    if (__src == 17)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor";
      goto LABEL_183;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      BOOL v32 = __nwlog_obj();
      os_log_type_t v33 = __src;
      if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
        goto LABEL_184;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_183;
    }
    os_log_type_t v51 = (char *)__nw_create_backtrace_string();
    BOOL v32 = __nwlog_obj();
    os_log_type_t v33 = __src;
    BOOL v53 = os_log_type_enabled(v32, (os_log_type_t)__src);
    if (!v51)
    {
      if (!v53) {
        goto LABEL_184;
      }
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
      BOOL v34 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_183;
    }
    if (!v53) {
      goto LABEL_107;
    }
    goto LABEL_106;
  }
  if (a5 <= 0x3F)
  {
    unint64_t __src = a5;
    size_t v21 = 1;
    goto LABEL_32;
  }
  if (!(a5 >> 14))
  {
    unint64_t __src = bswap32(a5 | 0x4000) >> 16;
    size_t v21 = 2;
    goto LABEL_32;
  }
  if (!(a5 >> 30))
  {
    unint64_t __src = bswap32(a5 | 0x80000000);
    size_t v21 = 4;
    goto LABEL_32;
  }
  if (a5 >> 62)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446466;
    uint64_t v83 = "_http_vle_encode";
    __int16 v84 = 2048;
    uint64_t v85 = (const char *)a5;
    unint64_t v30 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v30))
    {
      free(v30);
      int v24 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
      goto LABEL_37;
    }
LABEL_220:
    __break(1u);
    return;
  }
  unint64_t __src = bswap64(a5 | 0xC000000000000000);
  size_t v21 = 8;
LABEL_32:
  uint64_t v22 = *(void *)(*(void *)v13 + 8);
  if (*(void *)(v22 + 24) >= v21)
  {
    memcpy(v20, &__src, v21);
    unint64_t v23 = *(void *)(v22 + 24);
    *(void *)(v22 + 24) = v23 - v21;
    if (v23 < v21)
    {
      if (gLogDatapath)
      {
        uint64_t v63 = __nwlog_obj();
        if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v64 = *(void *)(v22 + 24);
          *(_DWORD *)long long buf = 136446978;
          uint64_t v83 = "_http_safe_append";
          __int16 v84 = 2082;
          uint64_t v85 = "*remaining";
          __int16 v86 = 2048;
          size_t v87 = v21;
          __int16 v88 = 2048;
          uint64_t v89 = v64;
          _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
        }
      }
      *(void *)(v22 + 24) = 0;
    }
    int v24 = &v20[v21];
    goto LABEL_37;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v83 = "_http_safe_append";
  uint64_t v39 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v80 = 0;
  if (__nwlog_fault(v39, &type, &v80))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v83 = "_http_safe_append";
        BOOL v42 = "%{public}s called with null (*remaining >= length)";
LABEL_200:
        _os_log_impl(&dword_1830D4000, v40, v41, v42, buf, 0xCu);
      }
    }
    else if (v80)
    {
      uint64_t v65 = (char *)__nw_create_backtrace_string();
      BOOL v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      BOOL v66 = os_log_type_enabled(v40, type);
      if (v65)
      {
        if (v66)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v83 = "_http_safe_append";
          __int16 v84 = 2082;
          uint64_t v85 = v65;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v65);
        goto LABEL_201;
      }
      if (v66)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v83 = "_http_safe_append";
        BOOL v42 = "%{public}s called with null (*remaining >= length), no backtrace";
        goto LABEL_200;
      }
    }
    else
    {
      BOOL v40 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v83 = "_http_safe_append";
        BOOL v42 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
        goto LABEL_200;
      }
    }
  }
LABEL_201:
  if (v39) {
    free(v39);
  }
  int v24 = 0;
LABEL_37:
  *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v24;
  os_log_type_t v25 = *(char **)(*(void *)(*(void *)v11 + 8) + 24);
  if (v25)
  {
    if (!a5) {
      goto LABEL_45;
    }
    if (a4)
    {
      uint64_t v26 = *(void *)(*(void *)v13 + 8);
      if (*(void *)(v26 + 24) >= a5)
      {
        memcpy(v25, a4, a5);
        unint64_t v27 = *(void *)(v26 + 24);
        *(void *)(v26 + 24) = v27 - a5;
        if (v27 < a5)
        {
          if (gLogDatapath)
          {
            int v76 = __nwlog_obj();
            if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v77 = *(void *)(v26 + 24);
              *(_DWORD *)long long buf = 136446978;
              uint64_t v83 = "_http_safe_append";
              __int16 v84 = 2082;
              uint64_t v85 = "*remaining";
              __int16 v86 = 2048;
              size_t v87 = a5;
              __int16 v88 = 2048;
              uint64_t v89 = v77;
              _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v26 + 24) = 0;
        }
        v25 += a5;
        goto LABEL_45;
      }
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "_http_safe_append";
      BOOL v47 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v47, &__src, &type)) {
        goto LABEL_217;
      }
      if (__src == 17)
      {
        char v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v50 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        char v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v50 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      uint64_t v73 = (char *)__nw_create_backtrace_string();
      char v48 = __nwlog_obj();
      os_log_type_t v49 = __src;
      BOOL v78 = os_log_type_enabled(v48, (os_log_type_t)__src);
      if (!v73)
      {
        if (v78)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v50 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (v78)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        uint64_t v85 = v73;
        uint64_t v75 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_155;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      uint64_t v83 = "_http_safe_append";
      BOOL v47 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v47, &__src, &type)) {
        goto LABEL_217;
      }
      if (__src == 17)
      {
        char v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v50 = "%{public}s called with null data";
LABEL_216:
          _os_log_impl(&dword_1830D4000, v48, v49, v50, buf, 0xCu);
        }
LABEL_217:
        if (v47) {
          free(v47);
        }
        os_log_type_t v25 = 0;
LABEL_45:
        *(void *)(*(void *)(*(void *)v11 + 8) + 24) = v25;
        if (*(void *)(*(void *)(*(void *)v11 + 8) + 24)) {
          return;
        }
        __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
        id v31 = (char *)_os_log_send_and_compose_impl();
        LOBYTE(__src) = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v31, &__src, &type))
        {
          if (__src == 17)
          {
            BOOL v32 = __nwlog_obj();
            os_log_type_t v33 = __src;
            if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
              goto LABEL_184;
            }
            *(_DWORD *)long long buf = 136446210;
            uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
            BOOL v34 = "%{public}s called with null cursor";
            goto LABEL_183;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            BOOL v32 = __nwlog_obj();
            os_log_type_t v33 = __src;
            if (!os_log_type_enabled(v32, (os_log_type_t)__src)) {
              goto LABEL_184;
            }
            *(_DWORD *)long long buf = 136446210;
            uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
            BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
            goto LABEL_183;
          }
          size_t v55 = (char *)__nw_create_backtrace_string();
          BOOL v32 = __nwlog_obj();
          os_log_type_t v33 = __src;
          BOOL v56 = os_log_type_enabled(v32, (os_log_type_t)__src);
          if (!v55)
          {
            if (!v56) {
              goto LABEL_184;
            }
            *(_DWORD *)long long buf = 136446210;
            uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
            BOOL v34 = "%{public}s called with null cursor, no backtrace";
            goto LABEL_183;
          }
          if (v56)
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
            __int16 v84 = 2082;
            uint64_t v85 = v55;
            _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v55);
        }
LABEL_184:
        if (v31) {
          goto LABEL_185;
        }
        return;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        char v48 = __nwlog_obj();
        os_log_type_t v49 = __src;
        if (os_log_type_enabled(v48, (os_log_type_t)__src))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v50 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      uint64_t v73 = (char *)__nw_create_backtrace_string();
      char v48 = __nwlog_obj();
      os_log_type_t v49 = __src;
      BOOL v74 = os_log_type_enabled(v48, (os_log_type_t)__src);
      if (!v73)
      {
        if (v74)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v83 = "_http_safe_append";
          unint64_t v50 = "%{public}s called with null data, no backtrace";
          goto LABEL_216;
        }
        goto LABEL_217;
      }
      if (v74)
      {
        *(_DWORD *)long long buf = 136446466;
        uint64_t v83 = "_http_safe_append";
        __int16 v84 = 2082;
        uint64_t v85 = v73;
        uint64_t v75 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_155:
        _os_log_impl(&dword_1830D4000, v48, v49, v75, buf, 0x16u);
      }
    }
    free(v73);
    goto LABEL_217;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
  id v31 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v80 = 0;
  if (!__nwlog_fault(v31, &type, &v80)) {
    goto LABEL_184;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_184;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    BOOL v34 = "%{public}s called with null cursor";
    goto LABEL_183;
  }
  if (!v80)
  {
    BOOL v32 = __nwlog_obj();
    os_log_type_t v33 = type;
    if (!os_log_type_enabled(v32, type)) {
      goto LABEL_184;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    BOOL v34 = "%{public}s called with null cursor, backtrace limit exceeded";
    goto LABEL_183;
  }
  os_log_type_t v51 = (char *)__nw_create_backtrace_string();
  BOOL v32 = __nwlog_obj();
  os_log_type_t v33 = type;
  BOOL v54 = os_log_type_enabled(v32, type);
  if (!v51)
  {
    if (!v54) {
      goto LABEL_184;
    }
    *(_DWORD *)long long buf = 136446210;
    uint64_t v83 = "nw_http_fillout_indeterminate_binary_message_body_chunk_block_invoke";
    BOOL v34 = "%{public}s called with null cursor, no backtrace";
    goto LABEL_183;
  }
  if (v54) {
    goto LABEL_106;
  }
LABEL_107:
  free(v51);
  if (v31) {
LABEL_185:
  }
    free(v31);
}

BOOL nw_http_fillout_body_from_binary_message(_DWORD *a1, unint64_t a2, char *__dst, size_t a4, size_t *a5)
{
  uint64_t v87 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v70, &type, &v81)) {
      goto LABEL_231;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null buffer";
      goto LABEL_230;
    }
    if (!v81)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_230;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = __nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v75 = os_log_type_enabled(v71, type);
    if (!backtrace_string)
    {
      if (!v75) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null buffer, no backtrace";
      goto LABEL_230;
    }
    if (!v75) {
      goto LABEL_205;
    }
    *(_DWORD *)long long buf = 136446466;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2082;
    unint64_t v86 = (unint64_t)backtrace_string;
    int v76 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_204:
    _os_log_impl(&dword_1830D4000, v71, v72, v76, buf, 0x16u);
    goto LABEL_205;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v70, &type, &v81)) {
      goto LABEL_231;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null buffer_length";
      goto LABEL_230;
    }
    if (!v81)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null buffer_length, backtrace limit exceeded";
      goto LABEL_230;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = __nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v77 = os_log_type_enabled(v71, type);
    if (!backtrace_string)
    {
      if (!v77) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null buffer_length, no backtrace";
      goto LABEL_230;
    }
    if (!v77) {
      goto LABEL_205;
    }
    *(_DWORD *)long long buf = 136446466;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2082;
    unint64_t v86 = (unint64_t)backtrace_string;
    int v76 = "%{public}s called with null buffer_length, dumping backtrace:%{public}s";
    goto LABEL_204;
  }
  if (!__dst)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v70, &type, &v81)) {
      goto LABEL_231;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null body_buffer";
      goto LABEL_230;
    }
    if (!v81)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null body_buffer, backtrace limit exceeded";
      goto LABEL_230;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = __nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v78 = os_log_type_enabled(v71, type);
    if (!backtrace_string)
    {
      if (!v78) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null body_buffer, no backtrace";
      goto LABEL_230;
    }
    if (!v78) {
      goto LABEL_205;
    }
    *(_DWORD *)long long buf = 136446466;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2082;
    unint64_t v86 = (unint64_t)backtrace_string;
    int v76 = "%{public}s called with null body_buffer, dumping backtrace:%{public}s";
    goto LABEL_204;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v70 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v70, &type, &v81)) {
      goto LABEL_231;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null body_buffer_length";
      goto LABEL_230;
    }
    if (!v81)
    {
      uint64_t v71 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (!os_log_type_enabled(v71, type)) {
        goto LABEL_231;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v84 = "nw_http_fillout_body_from_binary_message";
      uint64_t v73 = "%{public}s called with null body_buffer_length, backtrace limit exceeded";
      goto LABEL_230;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v71 = __nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v79 = os_log_type_enabled(v71, type);
    if (backtrace_string)
    {
      if (v79)
      {
        *(_DWORD *)long long buf = 136446466;
        __int16 v84 = "nw_http_fillout_body_from_binary_message";
        __int16 v85 = 2082;
        unint64_t v86 = (unint64_t)backtrace_string;
        int v76 = "%{public}s called with null body_buffer_length, dumping backtrace:%{public}s";
        goto LABEL_204;
      }
LABEL_205:
      free(backtrace_string);
      goto LABEL_231;
    }
    if (!v79) {
      goto LABEL_231;
    }
    *(_DWORD *)long long buf = 136446210;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    uint64_t v73 = "%{public}s called with null body_buffer_length, no backtrace";
LABEL_230:
    _os_log_impl(&dword_1830D4000, v71, v72, v73, buf, 0xCu);
LABEL_231:
    if (v70) {
      free(v70);
    }
    return 0;
  }
  unint64_t v8 = *(unsigned __int8 *)a1;
  if (v8 > 0x3F)
  {
    unsigned int v15 = v8 >> 6;
    if (v15 == 2)
    {
      if (a2 < 4) {
        return 0;
      }
      unint64_t v8 = bswap32(*a1 & 0xFFFFFF7F);
      uint64_t v9 = 4;
    }
    else if (v15 == 1)
    {
      if (a2 < 2) {
        return 0;
      }
      unint64_t v8 = bswap32(*(_WORD *)a1 & 0xFFBF) >> 16;
      uint64_t v9 = 2;
    }
    else
    {
      if (a2 < 8) {
        return 0;
      }
      unint64_t v8 = bswap64(*(void *)a1 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v9 = 8;
    }
  }
  else
  {
    uint64_t v9 = 1;
  }
  if (v8 > 3) {
    return 0;
  }
  size_t v10 = (_DWORD *)((char *)a1 + v9);
  unint64_t v11 = a2 - v9;
  if ((v8 & 0xFFFFFFFFFFFFFFFDLL) == 0)
  {
    if (a2 != v9)
    {
      unint64_t v16 = *(unsigned __int8 *)v10;
      if (v16 > 0x3F)
      {
        unsigned int v38 = v16 >> 6;
        if (v38 == 2)
        {
          if (v11 < 4) {
            return 0;
          }
          unint64_t v16 = bswap32(*v10 & 0xFFFFFF7F);
          uint64_t v17 = 4;
        }
        else if (v38 == 1)
        {
          if (v11 < 2) {
            return 0;
          }
          unint64_t v16 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
          uint64_t v17 = 2;
        }
        else
        {
          if (v11 < 8) {
            return 0;
          }
          unint64_t v16 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
          uint64_t v17 = 8;
        }
      }
      else
      {
        uint64_t v17 = 1;
      }
      BOOL result = 0;
      if (v16 >> 16) {
        return result;
      }
      unint64_t v19 = v11 - v17;
      if (v19 < v16) {
        return result;
      }
      unint64_t v20 = v19 - v16;
      if (v20)
      {
        size_t v21 = (_DWORD *)((char *)v10 + v17 + v16);
        unint64_t v22 = *(unsigned __int8 *)v21;
        if (v22 > 0x3F)
        {
          unsigned int v59 = v22 >> 6;
          if (v59 == 2)
          {
            if (v20 < 4) {
              return 0;
            }
            unint64_t v22 = bswap32(*v21 & 0xFFFFFF7F);
            uint64_t v23 = 4;
          }
          else if (v59 == 1)
          {
            if (v20 < 2) {
              return 0;
            }
            unint64_t v22 = bswap32(*(_WORD *)v21 & 0xFFBF) >> 16;
            uint64_t v23 = 2;
          }
          else
          {
            if (v20 < 8) {
              return 0;
            }
            unint64_t v22 = bswap64(*(void *)v21 & 0xFFFFFFFFFFFFFF3FLL);
            uint64_t v23 = 8;
          }
        }
        else
        {
          uint64_t v23 = 1;
        }
        BOOL result = 0;
        if (v22 >> 16) {
          return result;
        }
        unint64_t v24 = v20 - v23;
        if (v24 < v22) {
          return result;
        }
        unint64_t v25 = v24 - v22;
        if (v25)
        {
          uint64_t v26 = (_DWORD *)((char *)v21 + v23 + v22);
          unint64_t v27 = *(unsigned __int8 *)v26;
          if (v27 > 0x3F)
          {
            unsigned int v69 = v27 >> 6;
            if (v69 == 2)
            {
              if (v25 < 4) {
                return 0;
              }
              unint64_t v27 = bswap32(*v26 & 0xFFFFFF7F);
              uint64_t v28 = 4;
            }
            else if (v69 == 1)
            {
              if (v25 < 2) {
                return 0;
              }
              unint64_t v27 = bswap32(*(_WORD *)v26 & 0xFFBF) >> 16;
              uint64_t v28 = 2;
            }
            else
            {
              if (v25 < 8) {
                return 0;
              }
              unint64_t v27 = bswap64(*(void *)v26 & 0xFFFFFFFFFFFFFF3FLL);
              uint64_t v28 = 8;
            }
          }
          else
          {
            uint64_t v28 = 1;
          }
          unint64_t v29 = v25 - v28;
          if (v27 >> 16) {
            BOOL v30 = 0;
          }
          else {
            BOOL v30 = v29 >= v27;
          }
          if (!v30) {
            return 0;
          }
          unint64_t v31 = v29 - v27;
          if (!v31) {
            return 0;
          }
          BOOL v32 = (_DWORD *)((char *)v26 + v28 + v27);
          unint64_t v33 = *(unsigned __int8 *)v32;
          if (v33 > 0x3F)
          {
            unsigned int v80 = v33 >> 6;
            if (v80 == 2)
            {
              if (v31 < 4) {
                return 0;
              }
              unint64_t v33 = bswap32(*v32 & 0xFFFFFF7F);
              uint64_t v34 = 4;
            }
            else if (v80 == 1)
            {
              if (v31 < 2) {
                return 0;
              }
              unint64_t v33 = bswap32(*(_WORD *)v32 & 0xFFBF) >> 16;
              uint64_t v34 = 2;
            }
            else
            {
              if (v31 < 8) {
                return 0;
              }
              unint64_t v33 = bswap64(*(void *)v32 & 0xFFFFFFFFFFFFFF3FLL);
              uint64_t v34 = 8;
            }
          }
          else
          {
            uint64_t v34 = 1;
          }
          unint64_t v35 = v31 - v34;
          if (v33 >> 16) {
            BOOL v36 = 0;
          }
          else {
            BOOL v36 = v35 >= v33;
          }
          if (!v36) {
            return 0;
          }
          uint64_t v13 = (char *)v32 + v34 + v33;
          unint64_t v14 = v35 - v33;
          goto LABEL_64;
        }
      }
    }
    return 0;
  }
  if (a2 == v9) {
    return 0;
  }
  unint64_t v12 = *(unsigned __int8 *)v10;
  if (v12 > 0x3F)
  {
    if (v12 >> 6 == 2)
    {
      if (v11 < 4) {
        return 0;
      }
      unint64_t v12 = bswap32(*v10 & 0xFFFFFF7F);
      uint64_t v37 = 4;
    }
    else if (v12 >> 6 == 1)
    {
      if (v11 < 2) {
        return 0;
      }
      unint64_t v12 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
      uint64_t v37 = 2;
    }
    else
    {
      if (v11 < 8) {
        return 0;
      }
      unint64_t v12 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v37 = 8;
    }
    if (v12 > 0x3E8) {
      return 0;
    }
    uint64_t v13 = (char *)v10 + v37;
    unint64_t v14 = v11 - v37;
  }
  else
  {
    uint64_t v13 = (char *)v10 + 1;
    unint64_t v14 = v11 - 1;
  }
  if (v12 - 601 <= 0xFFFFFFFFFFFFFE6ELL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v39 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    *(_DWORD *)long long buf = 136446466;
    __int16 v84 = "nw_http_fillout_body_from_binary_message";
    __int16 v85 = 2048;
    unint64_t v86 = v12;
    _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_ERROR, "%{public}s Informational statuses not supported: %llu", buf, 0x16u);
    return 0;
  }
LABEL_64:
  if ((v8 & 0x3FFFFFFFFFFFFFFELL) == 2)
  {
    if (!v14) {
      goto LABEL_148;
    }
    while (1)
    {
      unint64_t v40 = *v13;
      if (v40 <= 0x3F)
      {
        uint64_t v41 = 1;
        goto LABEL_74;
      }
      if (v40 >> 6 == 2)
      {
        if (v14 < 4) {
          return 0;
        }
        unint64_t v40 = bswap32(*(_DWORD *)v13 & 0xFFFFFF7F);
        uint64_t v41 = 4;
LABEL_74:
        BOOL v42 = &v13[v41];
        unint64_t v43 = v14 - v41;
        if (!v40) {
          break;
        }
        goto LABEL_75;
      }
      if (v40 >> 6 == 1)
      {
        if (v14 < 2) {
          return 0;
        }
        unint64_t v40 = bswap32(*(_WORD *)v13 & 0xFFBF) >> 16;
        uint64_t v41 = 2;
        goto LABEL_74;
      }
      if (v14 < 8) {
        return 0;
      }
      uint64_t v49 = *(void *)v13;
      BOOL v42 = v13 + 8;
      unint64_t v40 = bswap64(v49 & 0xFFFFFFFFFFFFFF3FLL);
      if (HIDWORD(v40)) {
        return 0;
      }
      unint64_t v43 = v14 - 8;
      if (!v40) {
        break;
      }
LABEL_75:
      unint64_t v44 = v43 - v40;
      if (v43 <= v40) {
        return 0;
      }
      os_log_type_t v45 = &v42[v40];
      unint64_t v46 = v42[v40];
      if (v46 > 0x3F)
      {
        unsigned int v48 = v46 >> 6;
        if (v48 == 2)
        {
          if (v44 < 4) {
            return 0;
          }
          unint64_t v46 = bswap32(*(_DWORD *)v45 & 0xFFFFFF7F);
          uint64_t v47 = 4;
        }
        else if (v48 == 1)
        {
          if (v44 < 2) {
            return 0;
          }
          unint64_t v46 = bswap32(*(_WORD *)v45 & 0xFFBF) >> 16;
          uint64_t v47 = 2;
        }
        else
        {
          if (v44 < 8) {
            return 0;
          }
          unint64_t v46 = bswap64(*(void *)v45 & 0xFFFFFFFFFFFFFF3FLL);
          uint64_t v47 = 8;
        }
      }
      else
      {
        uint64_t v47 = 1;
      }
      unint64_t v50 = v44 - v47;
      if (HIDWORD(v46)) {
        BOOL v51 = 0;
      }
      else {
        BOOL v51 = v50 >= v46;
      }
      if (!v51) {
        return 0;
      }
      uint64_t v13 = &v45[v47 + v46];
      unint64_t v14 = v50 - v46;
      if (!v14) {
        goto LABEL_148;
      }
    }
    if (!v43)
    {
LABEL_148:
      size_t v66 = 0;
      goto LABEL_149;
    }
    size_t v61 = 0;
    while (1)
    {
      size_t v62 = *v42;
      if (v62 <= 0x3F)
      {
        uint64_t v63 = 1;
        goto LABEL_137;
      }
      if (v62 >> 6 == 2) {
        break;
      }
      if (v62 >> 6 == 1)
      {
        if (v43 < 2) {
          return 0;
        }
        size_t v62 = bswap32(*(_WORD *)v42 & 0xFFBF) >> 16;
        uint64_t v63 = 2;
        goto LABEL_137;
      }
      if (v43 < 8) {
        return 0;
      }
      uint64_t v68 = *(void *)v42;
      uint64_t v64 = v42 + 8;
      size_t v62 = bswap64(v68 & 0xFFFFFFFFFFFFFF3FLL);
      if (HIDWORD(v62)) {
        return 0;
      }
      uint64_t v63 = 8;
      if (!v62)
      {
LABEL_147:
        size_t v66 = v61;
LABEL_149:
        if (a5) {
          *a5 = v66;
        }
        return 1;
      }
LABEL_138:
      unint64_t v65 = v43 - v63;
      size_t v66 = v62 + v61;
      if (v43 - v63 < v62 || v66 > a4) {
        return 0;
      }
      memcpy(&__dst[v61], v64, v62);
      BOOL v42 = &v64[v62];
      size_t v61 = v66;
      unint64_t v43 = v65 - v62;
      if (v65 == v62) {
        goto LABEL_149;
      }
    }
    if (v43 < 4) {
      return 0;
    }
    size_t v62 = bswap32(*(_DWORD *)v42 & 0xFFFFFF7F);
    uint64_t v63 = 4;
LABEL_137:
    uint64_t v64 = &v42[v63];
    if (!v62) {
      goto LABEL_147;
    }
    goto LABEL_138;
  }
  if (!v14) {
    return 0;
  }
  unint64_t v52 = *v13;
  if (v52 > 0x3F)
  {
    unsigned int v60 = v52 >> 6;
    if (v60 == 2)
    {
      if (v14 < 4) {
        return 0;
      }
      unint64_t v52 = bswap32(*(_DWORD *)v13 & 0xFFFFFF7F);
      uint64_t v53 = 4;
    }
    else if (v60 == 1)
    {
      if (v14 < 2) {
        return 0;
      }
      unint64_t v52 = bswap32(*(_WORD *)v13 & 0xFFBF) >> 16;
      uint64_t v53 = 2;
    }
    else
    {
      if (v14 < 8) {
        return 0;
      }
      unint64_t v52 = bswap64(*(void *)v13 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v53 = 8;
    }
  }
  else
  {
    uint64_t v53 = 1;
  }
  BOOL result = 0;
  if (HIDWORD(v52)) {
    return result;
  }
  unint64_t v54 = v14 - v53;
  if (v54 < v52) {
    return result;
  }
  unint64_t v55 = v54 - v52;
  if (!v55) {
    return 0;
  }
  BOOL v56 = &v13[v53 + v52];
  size_t v57 = *v56;
  if (v57 > 0x3F)
  {
    if (v57 >> 6 == 2)
    {
      if (v55 >= 4)
      {
        size_t v57 = bswap32(*(_DWORD *)v56 & 0xFFFFFF7F);
        uint64_t v58 = 4;
        goto LABEL_105;
      }
    }
    else if (v57 >> 6 == 1)
    {
      if (v55 >= 2)
      {
        size_t v57 = bswap32(*(_WORD *)v56 & 0xFFBF) >> 16;
        uint64_t v58 = 2;
        goto LABEL_105;
      }
    }
    else if (v55 >= 8)
    {
      size_t v57 = bswap64(*(void *)v56 & 0xFFFFFFFFFFFFFF3FLL);
      uint64_t v58 = 8;
      goto LABEL_105;
    }
    return 0;
  }
  uint64_t v58 = 1;
LABEL_105:
  BOOL result = 0;
  if (v57 <= a4 && v57 <= v55 - v58)
  {
    memcpy(__dst, &v56[v58], v57);
    if (a5) {
      *a5 = v57;
    }
    return 1;
  }
  return result;
}

nw_protocol_definition_t __nw_protocol_tcpconverter_copy_definition_block_invoke()
{
  nw_protocol_definition_t result = nw_framer_create_definition("TCP-Converter", 0, &__block_literal_global_9_49308);
  nw_protocol_tcpconverter_copy_definition::nw_protocol_definition_t definition = (uint64_t)result;
  return result;
}

BOOL __nw_protocol_tcpconverter_copy_definition_block_invoke_10(uint64_t a1, NSObject *a2)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  size_t v3 = *(_DWORD **)(a1 + 32);
  int v4 = *v3;
  if (*v3 == 2)
  {
    *(void *)temp_buffer = 0;
    *(void *)&uint8_t temp_buffer[8] = temp_buffer;
    *(void *)&temp_buffer[16] = 0x2000000000;
    uint64_t v61 = 0;
    uint64_t v33 = 0;
    uint64_t v34 = (uint64_t)&v33;
    uint64_t v35 = 0x2000000000;
    LOBYTE(v36) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v6 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      if (v7) {
        unint64_t v8 = (const char *)(v7 + 4);
      }
      else {
        unint64_t v8 = "";
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_tcpconverter_copy_definition_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v8;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %s Received incoming data while connected", buf, 0x16u);
    }
    parse[0] = MEMORY[0x1E4F143A8];
    parse[1] = 0x40000000;
    parse[2] = __nw_protocol_tcpconverter_copy_definition_block_invoke_12;
    parse[3] = &unk_1E5242FE8;
    parse[4] = temp_buffer;
    parse[5] = &v33;
    nw_framer_parse_input(a2, 1uLL, 0xFFFFFFFFuLL, 0, parse);
    uint64_t v9 = nw_framer_message_create(*(nw_framer_t *)(a1 + 40));
    nw_framer_deliver_input_no_copy(a2, *(void *)(*(void *)&temp_buffer[8] + 24), v9, *(unsigned char *)(v34 + 24));
    if (v9) {
      os_release(v9);
    }
    _Block_object_dispose(&v33, 8);
    size_t v10 = (uint64_t *)temp_buffer;
    goto LABEL_22;
  }
  unint64_t v11 = *(NSObject **)(a1 + 40);
  uint64_t v46 = 0;
  uint64_t v47 = &v46;
  uint64_t v48 = 0x2000000000;
  uint64_t v49 = 0;
  uint64_t v42 = 0;
  unint64_t v43 = &v42;
  uint64_t v44 = 0x2000000000;
  char v45 = 0;
  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)temp_buffer = 136446466;
      *(void *)&temp_buffer[4] = "nw_tcpconverter_parse_response";
      *(_WORD *)&temp_buffer[12] = 2080;
      *(void *)&temp_buffer[14] = v3 + 1;
      unint64_t v19 = "%{public}s %s Received response although we haven't yet sent a connect-message";
      unint64_t v20 = temp_buffer;
LABEL_19:
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, v19, v20, 0x16u);
    }
LABEL_20:
    nw_framer_mark_failed_with_error(v11, 22);
    goto LABEL_21;
  }
  uint64_t v33 = MEMORY[0x1E4F143A8];
  uint64_t v34 = 0x40000000;
  uint64_t v35 = (uint64_t)___ZL30nw_tcpconverter_parse_responseP9nw_framerP15nw_tcpconverter_block_invoke;
  BOOL v36 = &unk_1E5243090;
  uint64_t v39 = v3;
  unint64_t v40 = v11;
  uint64_t v41 = 4;
  uint64_t v37 = &v46;
  unsigned int v38 = &v42;
  if (!nw_framer_parse_input(v11, 4uLL, 4uLL, temp_buffer, &v33) || !*((unsigned char *)v43 + 24)) {
    goto LABEL_21;
  }
  unint64_t v12 = v47[3];
  if (v12 < 0x81)
  {
    unint64_t v14 = 0;
    uint64_t v13 = temp_buffer;
LABEL_24:
    *((unsigned char *)v43 + 24) = 0;
    size_t v21 = v47[3];
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = ___ZL30nw_tcpconverter_parse_responseP9nw_framerP15nw_tcpconverter_block_invoke_33;
    unint64_t v55 = &unk_1E52430B8;
    uint64_t v58 = v3;
    unsigned int v59 = v11;
    BOOL v56 = &v46;
    size_t v57 = &v42;
    BOOL v22 = nw_framer_parse_input(v11, v21, v21, v13, buf);
    if (v14) {
      free(v14);
    }
    if (!v22 || !*((unsigned char *)v43 + 24)) {
      goto LABEL_21;
    }
    int v23 = *v3;
    if (*v3 == 2)
    {
      nw_framer_pass_through_input(v11);
      nw_framer_pass_through_output(v11);
      nw_framer_mark_ready(v11);
      goto LABEL_21;
    }
    if (v23 != 1)
    {
      if (!v23)
      {
        __nwlog_obj();
        *(_DWORD *)unint64_t v50 = 136446210;
        BOOL v51 = "nw_tcpconverter_parse_response";
        unint64_t v24 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v31 = 0;
        if (!__nwlog_fault(v24, &type, &v31)) {
          goto LABEL_48;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          unint64_t v25 = __nwlog_obj();
          os_log_type_t v26 = type;
          if (!os_log_type_enabled(v25, type)) {
            goto LABEL_48;
          }
          *(_DWORD *)unint64_t v50 = 136446210;
          BOOL v51 = "nw_tcpconverter_parse_response";
          unint64_t v27 = "%{public}s Can't be in initial after parsing response";
        }
        else if (v31)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          unint64_t v25 = __nwlog_obj();
          os_log_type_t v26 = type;
          BOOL v29 = os_log_type_enabled(v25, type);
          if (backtrace_string)
          {
            if (v29)
            {
              *(_DWORD *)unint64_t v50 = 136446466;
              BOOL v51 = "nw_tcpconverter_parse_response";
              __int16 v52 = 2082;
              uint64_t v53 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s Can't be in initial after parsing response, dumping backtrace:%{public}s", v50, 0x16u);
            }
            free(backtrace_string);
            goto LABEL_48;
          }
          if (!v29)
          {
LABEL_48:
            if (v24) {
              free(v24);
            }
            goto LABEL_21;
          }
          *(_DWORD *)unint64_t v50 = 136446210;
          BOOL v51 = "nw_tcpconverter_parse_response";
          unint64_t v27 = "%{public}s Can't be in initial after parsing response, no backtrace";
        }
        else
        {
          unint64_t v25 = __nwlog_obj();
          os_log_type_t v26 = type;
          if (!os_log_type_enabled(v25, type)) {
            goto LABEL_48;
          }
          *(_DWORD *)unint64_t v50 = 136446210;
          BOOL v51 = "nw_tcpconverter_parse_response";
          unint64_t v27 = "%{public}s Can't be in initial after parsing response, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v25, v26, v27, v50, 0xCu);
        goto LABEL_48;
      }
LABEL_21:
      _Block_object_dispose(&v42, 8);
      size_t v10 = &v46;
LABEL_22:
      _Block_object_dispose(v10, 8);
      return 0;
    }
    uint64_t v18 = __nwlog_obj();
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unint64_t v50 = 136446466;
      BOOL v51 = "nw_tcpconverter_parse_response";
      __int16 v52 = 2080;
      uint64_t v53 = (char *)(v3 + 1);
      unint64_t v19 = "%{public}s %s Received unexpected response - we remained in 'connect_sent' state";
      unint64_t v20 = v50;
      goto LABEL_19;
    }
    goto LABEL_20;
  }
  uint64_t v13 = (uint8_t *)malloc_type_malloc(v47[3], 0xF2B69DE5uLL);
  unint64_t v14 = v13;
  if (v13) {
    goto LABEL_24;
  }
  unsigned int v15 = __nwlog_obj();
  os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  *(void *)&uint8_t buf[4] = "strict_malloc";
  *(_WORD *)&unsigned char buf[12] = 2048;
  *(void *)&buf[14] = v12;
  unint64_t v16 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v16);
  if (!result)
  {
    free(v16);
    uint64_t v13 = 0;
    unint64_t v14 = 0;
    goto LABEL_24;
  }
  __break(1u);
  return result;
}

BOOL __nw_protocol_tcpconverter_copy_definition_block_invoke_2_17(BOOL result, NSObject *a2, uint64_t a3, size_t a4)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (**(_DWORD **)(result + 32) == 2)
  {
    uint64_t v6 = result;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v8 = *(void *)(v6 + 32);
      if (v8) {
        uint64_t v9 = (const char *)(v8 + 4);
      }
      else {
        uint64_t v9 = "";
      }
      int v10 = 136446466;
      unint64_t v11 = "nw_protocol_tcpconverter_copy_definition_block_invoke_2";
      __int16 v12 = 2080;
      uint64_t v13 = v9;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %s Received outgoing data while connected", (uint8_t *)&v10, 0x16u);
    }
    return nw_framer_write_output_no_copy(a2, a4);
  }
  return result;
}

void __nw_protocol_tcpconverter_copy_definition_block_invoke_20(uint64_t a1)
{
  id v1 = *(void **)(a1 + 32);
  if (v1) {
    free(v1);
  }
}

uint64_t __nw_protocol_tcpconverter_copy_definition_block_invoke_2_23(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    if (v3) {
      int v4 = (const char *)(v3 + 4);
    }
    else {
      int v4 = "";
    }
    int v6 = 136446466;
    uint64_t v7 = "nw_protocol_tcpconverter_copy_definition_block_invoke_2";
    __int16 v8 = 2080;
    uint64_t v9 = v4;
    _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s %s Got stop indication", (uint8_t *)&v6, 0x16u);
  }
  return 1;
}

uint64_t __nw_protocol_tcpconverter_copy_definition_block_invoke_12(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a4;
  return 0;
}

uint64_t ___ZL30nw_tcpconverter_parse_responseP9nw_framerP15nw_tcpconverter_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v11 = *(void *)(a1 + 48);
      if (v11) {
        __int16 v12 = (const char *)(v11 + 4);
      }
      else {
        __int16 v12 = "";
      }
      int v28 = 136446466;
      BOOL v29 = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v30 = 2080;
      char v31 = v12;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s %s Received NULL header", (uint8_t *)&v28, 0x16u);
    }
    return 0;
  }
  if (*a2 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v14 = *(void *)(a1 + 48);
      unsigned int v15 = (const char *)(v14 + 4);
      BOOL v16 = v14 == 0;
      int v17 = *a2;
      if (v16) {
        unsigned int v15 = "";
      }
      int v28 = 136446722;
      BOOL v29 = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v30 = 2080;
      char v31 = v15;
      __int16 v32 = 1024;
      LODWORD(v33) = v17;
      uint64_t v18 = "%{public}s %s Received invalid TCP Converter version %d";
      goto LABEL_20;
    }
LABEL_21:
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 56), 22);
    return 0;
  }
  if (*((_WORD *)a2 + 1) != 25378)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v13 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v19 = *(void *)(a1 + 48);
      unint64_t v20 = "";
      size_t v21 = (const char *)(v19 + 4);
      BOOL v16 = v19 == 0;
      unsigned int v22 = *((unsigned __int16 *)a2 + 1);
      if (!v16) {
        unint64_t v20 = v21;
      }
      int v28 = 136446722;
      BOOL v29 = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v30 = 2080;
      char v31 = v20;
      __int16 v32 = 1024;
      LODWORD(v33) = bswap32(v22) >> 16;
      uint64_t v18 = "%{public}s %s Invalid magic number received: %u";
LABEL_20:
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_INFO, v18, (uint8_t *)&v28, 0x1Cu);
      goto LABEL_21;
    }
    goto LABEL_21;
  }
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 4 * a2[1];
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 8);
  unint64_t v5 = *(void *)(v4 + 24);
  unint64_t v6 = *(void *)(a1 + 64);
  BOOL v7 = v5 > v6;
  unint64_t v8 = v5 - v6;
  if (v7)
  {
    *(void *)(v4 + 24) = v8;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
    return *(void *)(a1 + 64);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v23 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      uint64_t v25 = *(void *)(a1 + 48);
      if (v25) {
        os_log_type_t v26 = (const char *)(v25 + 4);
      }
      else {
        os_log_type_t v26 = "";
      }
      uint64_t v27 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      int v28 = 136446722;
      BOOL v29 = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v30 = 2080;
      char v31 = v26;
      __int16 v32 = 2048;
      uint64_t v33 = v27;
      _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, "%{public}s %s Received too small total_length in the fixed header: %ld", (uint8_t *)&v28, 0x20u);
    }
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 56), 22);
    return 4;
  }
}

uint64_t ___ZL30nw_tcpconverter_parse_responseP9nw_framerP15nw_tcpconverter_block_invoke_33(void *a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = *(void *)(*(void *)(a1[4] + 8) + 24);
  if (v3 < 2)
  {
LABEL_23:
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
    return *(void *)(*(void *)(a1[4] + 8) + 24);
  }
  else
  {
    unsigned int v5 = 0;
    unint64_t v6 = 1;
    while (1)
    {
      int v7 = *(unsigned __int8 *)(a2 + v5);
      int v8 = 4 * *(unsigned __int8 *)(a2 + v6);
      unint64_t v9 = v8 + v5;
      if (v3 < v9) {
        break;
      }
      if (v7 == 20)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v17 = a1[6];
          uint64_t v18 = (const char *)(v17 + 4);
          BOOL v13 = v17 == 0;
          uint64_t v19 = "";
          if (!v13) {
            uint64_t v19 = v18;
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
          __int16 v40 = 2080;
          uint64_t v41 = v19;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEFAULT, "%{public}s %s Connection successfully established", buf, 0x16u);
        }
        *(_DWORD *)a1[6] = 2;
      }
      else
      {
        if (v7 == 30)
        {
          int v28 = (unsigned __int8 *)(a2 + v5);
          int v29 = v28[1];
          *(void *)long long buf = 0;
          unsigned int v30 = v28[2];
          if (v30 >= 0x20)
          {
            if (v30 >= 0x40)
            {
              char v31 = "Converter-side error";
              if ((v30 & 0x80u) != 0) {
                __int16 v32 = "Unknown error class";
              }
              else {
                __int16 v32 = "Destination-server side error";
              }
              if (v30 >= 0x60) {
                char v31 = v32;
              }
            }
            else
            {
              char v31 = "Client-side error";
            }
          }
          else
          {
            char v31 = "Message validation and processing error";
          }
          uint64_t v33 = "Unsupported Version";
          switch(*(unsigned char *)(a2 + v5 + 2))
          {
            case 0:
              break;
            case 1:
              uint64_t v33 = "Malformed Message";
              break;
            case 2:
              uint64_t v33 = "Unsupported Message";
              break;
            case 3:
              uint64_t v33 = "Missing Cookie";
              break;
            case 0x20:
              uint64_t v33 = "Not Authorized";
              break;
            case 0x21:
              uint64_t v33 = "Unsupported TCP Option";
              break;
            case 0x40:
              uint64_t v33 = "Resource Exceeded";
              break;
            case 0x41:
              uint64_t v33 = "Network Failure";
              break;
            case 0x60:
              uint64_t v33 = "Connection Reset";
              break;
            case 0x61:
              uint64_t v33 = "Destination Unreachable";
              break;
            default:
              uint64_t v33 = "Unknown error code";
              break;
          }
          asprintf((char **)buf, "Error class %s (%u), type %s (%u), length %u, value %u", v31, v30, v33, v30, 4 * v29, v28[3]);
          uint64_t v34 = *(void **)buf;
          if (*(void *)buf)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v35 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
            {
              uint64_t v36 = a1[6];
              uint64_t v37 = (const char *)(v36 + 4);
              BOOL v13 = v36 == 0;
              unsigned int v38 = "";
              if (!v13) {
                unsigned int v38 = v37;
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
              __int16 v40 = 2080;
              uint64_t v41 = v38;
              __int16 v42 = 2080;
              *(void *)unint64_t v43 = v34;
              _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEFAULT, "%{public}s %s Received ERROR: %s", buf, 0x20u);
            }
            free(v34);
          }
          int v27 = 22;
          switch(v28[2])
          {
            case '@':
              int v27 = 35;
              break;
            case 'A':
              int v27 = 51;
              break;
            case 'B':
            case 'C':
            case 'D':
            case 'E':
            case 'F':
            case 'G':
            case 'H':
            case 'I':
            case 'J':
            case 'K':
            case 'L':
            case 'M':
            case 'N':
            case 'O':
            case 'P':
            case 'Q':
            case 'R':
            case 'S':
            case 'T':
            case 'U':
            case 'V':
            case 'W':
            case 'X':
            case 'Y':
            case 'Z':
            case '[':
            case '\\':
            case ']':
            case '^':
            case '_':
              break;
              int v27 = 61;
              break;
            case 'a':
              int v27 = 65;
              break;
            default:
              if (v28[2] == 32) {
                int v27 = 1;
              }
              break;
          }
          *(_DWORD *)a1[6] = 3;
          os_log_type_t v26 = a1[7];
          goto LABEL_63;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          uint64_t v11 = a1[6];
          __int16 v12 = (const char *)(v11 + 4);
          BOOL v13 = v11 == 0;
          uint64_t v14 = "";
          if (!v13) {
            uint64_t v14 = v12;
          }
          unsigned int v15 = "RESERVED";
          switch(v7)
          {
            case 0:
              break;
            case 1:
              unsigned int v15 = "INFO";
              break;
            case 10:
              unsigned int v15 = "CONNECT";
              break;
            case 20:
              unsigned int v15 = "EXTENDED";
              break;
            case 21:
              unsigned int v15 = "EXTENSIONS";
              break;
            case 22:
              unsigned int v15 = "COOKIE";
              break;
            default:
              unsigned int v15 = "UNKNOWN";
              break;
          }
          *(_DWORD *)long long buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
          __int16 v40 = 2080;
          uint64_t v41 = v14;
          __int16 v42 = 2080;
          *(void *)unint64_t v43 = v15;
          *(_WORD *)&v43[8] = 1024;
          *(_DWORD *)uint64_t v44 = v7;
          *(_WORD *)&v44[4] = 1024;
          *(_DWORD *)&v44[6] = v8;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s %s Received unexpected Converter-type %s(%u) with length %u -> Skipping", buf, 0x2Cu);
        }
      }
      unint64_t v6 = v9 | 1;
      unint64_t v3 = *(void *)(*(void *)(a1[4] + 8) + 24);
      unsigned int v5 = v9;
      if (v3 <= v6) {
        goto LABEL_23;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v21 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v22 = a1[6];
      int v23 = (const char *)(v22 + 4);
      BOOL v13 = v22 == 0;
      unint64_t v24 = "";
      if (!v13) {
        unint64_t v24 = v23;
      }
      uint64_t v25 = *(void *)(*(void *)(a1[4] + 8) + 24);
      *(_DWORD *)long long buf = 136447490;
      *(void *)&uint8_t buf[4] = "nw_tcpconverter_parse_response_block_invoke";
      __int16 v40 = 2080;
      uint64_t v41 = v24;
      __int16 v42 = 1024;
      *(_DWORD *)unint64_t v43 = v7;
      *(_WORD *)&v43[4] = 1024;
      *(_DWORD *)&v43[6] = v8;
      *(_WORD *)uint64_t v44 = 2048;
      *(void *)&v44[2] = v25;
      __int16 v45 = 1024;
      unsigned int v46 = v5;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s %s Insufficient data for TLV of type %u, length %d, total_length %ld, index %u", buf, 0x32u);
    }
    os_log_type_t v26 = a1[7];
    int v27 = 22;
LABEL_63:
    nw_framer_mark_failed_with_error(v26, v27);
    return 0;
  }
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_49408(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  unint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    unint64_t v3 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 32) + _Block_object_dispose(&a9, 8) = v3;
  }
  *unint64_t v3 = v2;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t __nw_http_capsule_framer_cleanup_block_invoke_1(uint64_t a1, _DWORD *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    uint64_t v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v5 = 136446722;
      unint64_t v6 = "nw_http_capsule_framer_cleanup_block_invoke";
      __int16 v7 = 2048;
      int v8 = a2;
      __int16 v9 = 1024;
      int v10 = nw_frame_unclaimed_length(a2);
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s processed_frames still has frames in it: frame %p (%u bytes)", (uint8_t *)&v5, 0x1Cu);
    }
  }
  return 1;
}

uint64_t __nw_http_capsule_framer_cleanup_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    uint64_t v4 = __nwlog_obj();
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v5 = 136446722;
      unint64_t v6 = "nw_http_capsule_framer_cleanup_block_invoke";
      __int16 v7 = 2048;
      int v8 = a2;
      __int16 v9 = 1024;
      int v10 = nw_frame_unclaimed_length(a2);
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s unprocessed_frames still has frames in it: frame %p (%u bytes)", (uint8_t *)&v5, 0x1Cu);
    }
  }
  return 1;
}

uint64_t __nw_http_capsule_framer_read_capsule_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  unsigned int v28 = 0;
  uint64_t v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v28);
  uint64_t v5 = a1[5];
  if (!v4)
  {
LABEL_30:
    uint64_t v25 = *(void *)(a2 + 32);
    os_log_type_t v26 = *(void **)(a2 + 40);
    if (v25)
    {
      *(void *)(v25 + 40) = v26;
      os_log_type_t v26 = *(void **)(a2 + 40);
    }
    else
    {
      *(void *)(v5 + _Block_object_dispose(&a9, 8) = v26;
    }
    void *v26 = v25;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    uint64_t v24 = 1;
    nw_frame_finalize(a2);
    return v24;
  }
  uint64_t v6 = *(unsigned __int16 *)(v5 + 72);
  if (16 - v6 >= (unint64_t)v28) {
    size_t v7 = v28;
  }
  else {
    size_t v7 = 16 - v6;
  }
  memcpy((void *)(v5 + v6 + 56), v4, v7);
  uint64_t v5 = a1[5];
  unsigned __int16 v8 = *(_WORD *)(v5 + 72) + v7;
  *(_WORD *)(v5 + 72) = v8;
  if (!v8) {
    goto LABEL_23;
  }
  __int16 v9 = (_DWORD *)(v5 + 56);
  unint64_t v10 = *(unsigned __int8 *)(v5 + 56);
  if (v10 <= 0x3F)
  {
    unsigned int v11 = 1;
    goto LABEL_8;
  }
  unsigned int v16 = v10 >> 6;
  if (v16 == 2)
  {
    if (v8 < 4u) {
      goto LABEL_23;
    }
    unint64_t v10 = bswap32(*v9 & 0xFFFFFF7F);
    unsigned int v11 = 4;
  }
  else
  {
    if (v16 == 1)
    {
      if (v8 >= 2u)
      {
        unint64_t v10 = bswap32(*(_WORD *)v9 & 0xFFBF) >> 16;
        unsigned int v11 = 2;
        goto LABEL_8;
      }
LABEL_23:
      unsigned int v11 = 0;
      goto LABEL_24;
    }
    if (v8 < 8u) {
      goto LABEL_23;
    }
    unint64_t v10 = bswap64(*(void *)v9 & 0xFFFFFFFFFFFFFF3FLL);
    unsigned int v11 = 8;
  }
LABEL_8:
  *(void *)(v5 + 4_Block_object_dispose(&a9, 8) = v10;
  unint64_t v12 = v8 - (unint64_t)v11;
  if (v8 != (unint64_t)v11)
  {
    unint64_t v13 = *((unsigned __int8 *)v9 + v11);
    if (v13 <= 0x3F)
    {
      int v14 = 1;
LABEL_11:
      v11 += v14;
      *(_WORD *)(v5 + 72) = 0;
      char v15 = 1;
      *(void *)(v5 + 32) = v13;
      *(void *)(v5 + 40) = v13;
      goto LABEL_25;
    }
    unsigned int v17 = v13 >> 6;
    if (v17 == 2)
    {
      if (v12 >= 4)
      {
        unint64_t v13 = bswap32(*(_DWORD *)((char *)v9 + v11) & 0xFFFFFF7F);
        int v14 = 4;
        goto LABEL_11;
      }
    }
    else if (v17 == 1)
    {
      if (v12 >= 2)
      {
        unint64_t v13 = bswap32(*(_WORD *)((unsigned char *)v9 + v11) & 0xFFBF) >> 16;
        int v14 = 2;
        goto LABEL_11;
      }
    }
    else if (v12 >= 8)
    {
      unint64_t v13 = bswap64(*(void *)((unsigned char *)v9 + v11) & 0xFFFFFFFFFFFFFF3FLL);
      int v14 = 8;
      goto LABEL_11;
    }
  }
LABEL_24:
  char v15 = 0;
LABEL_25:
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = v15;
  if (!*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
    goto LABEL_30;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v18 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v20 = a1[5];
    uint64_t v21 = *(void *)(v20 + 48);
    uint64_t v22 = *(void *)(v20 + 32);
    *(_DWORD *)long long buf = 136446722;
    unsigned int v30 = "nw_http_capsule_framer_read_capsule_block_invoke";
    __int16 v31 = 2048;
    uint64_t v32 = v21;
    __int16 v33 = 2048;
    uint64_t v34 = v22;
    _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s Parsed capsule header for type %llx, length %lld", buf, 0x20u);
  }
  nw_frame_claim(a2, v19, v11 - v6, 0);
  int v23 = (unsigned int *)a1[7];
  uint64_t v24 = 0;
  if (v23) {
    unsigned int *v23 = v11;
  }
  return v24;
}

uint64_t ___ZL43nw_http_capsule_framer_process_capsule_bodyP22nw_http_capsule_framerP11nw_protocolPb_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += nw_frame_unclaimed_length(a2);
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return 1;
}

uint64_t ___ZL43nw_http_capsule_framer_process_capsule_bodyP22nw_http_capsule_framerP11nw_protocolPb_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  uint64_t v6 = (void *)(a2 + 32);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 48) + _Block_object_dispose(&a9, 8) = v5;
  }
  void *v5 = v4;
  void *v6 = 0;
  *(void *)(a2 + 40) = 0;
  unsigned int v7 = nw_frame_unclaimed_length((_DWORD *)a2);
  uint64_t v8 = *(void *)(a1 + 48);
  unint64_t v9 = *(void *)(v8 + 40);
  uint64_t v10 = v7;
  if (v9 < v7)
  {
    uint64_t v33 = a2;
    uint64_t v11 = nw_frame_split(&v33, v9);
    uint64_t v12 = *(void *)(a1 + 48);
    unint64_t v13 = *(void *)(v12 + 40) - v9;
    *(void *)(v12 + 40) = v13;
    if (!v13) {
      **(unsigned char **)(a1 + 56) = 1;
    }
    if (v11)
    {
      *(void *)(v11 + 32) = 0;
      int v14 = *(uint64_t **)(v12 + 24);
      *(void *)(v11 + 40) = v14;
      uint64_t *v14 = v11;
      *(void *)(v12 + 24) = v11 + 32;
      ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
      char v15 = *(uint64_t **)(a1 + 48);
      uint64_t v16 = v33;
      uint64_t v17 = *v15;
      uint64_t v18 = v33;
      *(void *)(v33 + 32) = *v15;
      uint64_t v19 = v18 + 32;
      if (v17) {
        uint64_t v20 = (uint64_t *)(v17 + 40);
      }
      else {
        uint64_t v20 = v15 + 1;
      }
      *uint64_t v20 = v19;
      *char v15 = v16;
      *(void *)(v16 + 40) = v15;
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke_2";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v25, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v26 = gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
        unsigned int v28 = "%{public}s nw_frame_split returned NULL frame";
        goto LABEL_27;
      }
      if (!v31)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v26 = gLogObj;
        os_log_type_t v27 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_28;
        }
        *(_DWORD *)long long buf = 136446210;
        uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
        unsigned int v28 = "%{public}s nw_frame_split returned NULL frame, backtrace limit exceeded";
        goto LABEL_27;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v26 = gLogObj;
      os_log_type_t v27 = type;
      BOOL v30 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
          __int16 v36 = 2082;
          uint64_t v37 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s nw_frame_split returned NULL frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_28;
      }
      if (v30)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v35 = "nw_http_capsule_framer_process_capsule_body_block_invoke";
        unsigned int v28 = "%{public}s nw_frame_split returned NULL frame, no backtrace";
LABEL_27:
        _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
      }
    }
LABEL_28:
    if (v25) {
      free(v25);
    }
    return 0;
  }
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v7;
  *(void *)(a2 + 32) = 0;
  uint64_t v21 = *(uint64_t **)(v8 + 24);
  *(void *)(a2 + 40) = v21;
  uint64_t *v21 = a2;
  *(void *)(v8 + 24) = v6;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v22 = *(void *)(a1 + 48);
  uint64_t result = 1;
  uint64_t v24 = *(void *)(v22 + 40) - v10;
  *(void *)(v22 + 40) = v24;
  if (v24) {
    return result;
  }
  **(unsigned char **)(a1 + 56) = 1;
  return 0;
}

uint64_t __nw_http_capsule_framer_get_output_frames_block_invoke(uint64_t a1, _DWORD *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  unsigned int v23 = 0;
  nw_frame_get_buffer((uint64_t)a2, &v23);
  int v4 = *(_DWORD *)(a1 + 48);
  if (v23 >> 30) {
    int v5 = 8;
  }
  else {
    int v5 = 4;
  }
  if (v23 >= 0x4000) {
    int v6 = v5;
  }
  else {
    int v6 = 2;
  }
  if (v23 >= 0x40) {
    int v7 = v6;
  }
  else {
    int v7 = 1;
  }
  int v8 = v7 + v4;
  if (v7 + v4 < nw_frame_unclaimed_length(a2))
  {
    nw_frame_claim((uint64_t)a2, v9, v8, 0);
    return 1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v25 = "nw_http_capsule_framer_get_output_frames_block_invoke";
  uint64_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v10, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v25 = "nw_http_capsule_framer_get_output_frames_block_invoke";
        unint64_t v13 = "%{public}s Received frame contains less than minimum unclaimed bytes";
LABEL_23:
        uint64_t v18 = v11;
        os_log_type_t v19 = v12;
LABEL_24:
        _os_log_impl(&dword_1830D4000, v18, v19, v13, buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v15 = gLogObj;
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v25 = "nw_http_capsule_framer_get_output_frames_block_invoke";
          __int16 v26 = 2082;
          os_log_type_t v27 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s Received frame contains less than minimum unclaimed bytes, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_25;
      }
      if (v17)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v25 = "nw_http_capsule_framer_get_output_frames_block_invoke";
        unint64_t v13 = "%{public}s Received frame contains less than minimum unclaimed bytes, no backtrace";
        uint64_t v18 = v15;
        os_log_type_t v19 = v16;
        goto LABEL_24;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v25 = "nw_http_capsule_framer_get_output_frames_block_invoke";
        unint64_t v13 = "%{public}s Received frame contains less than minimum unclaimed bytes, backtrace limit exceeded";
        goto LABEL_23;
      }
    }
  }
LABEL_25:
  if (v10) {
    free(v10);
  }
  nw_frame_finalize((uint64_t)a2);
  --*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  return 1;
}

uint64_t nw_http_capsule_framer_parse_vle_value(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v24[1] = *MEMORY[0x1E4F143B8];
  v23[0] = 0;
  v23[1] = v23;
  v23[2] = 0x2000000000;
  v23[3] = v24;
  v24[0] = 0;
  v21[0] = 0;
  v21[1] = v21;
  v21[2] = 0x2000000000;
  char v22 = 0;
  uint64_t v17 = 0;
  uint64_t v18 = &v17;
  uint64_t v19 = 0x2000000000;
  char v20 = 0;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 0x40000000;
  uint64_t v9 = (uint64_t (*)(void *))__nw_http_capsule_framer_parse_vle_value_block_invoke;
  uint64_t v10 = &unk_1E5243190;
  uint64_t v11 = v21;
  os_log_type_t v12 = v23;
  unint64_t v13 = &v17;
  uint64_t v14 = a3;
  uint64_t v15 = a2;
  uint64_t v16 = a1;
  uint64_t v3 = *(void *)(a1 + 16);
  do
  {
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(v3 + 32);
    char v5 = v9(v8);
    uint64_t v3 = v4;
  }
  while ((v5 & 1) != 0);
  uint64_t v6 = *((unsigned __int8 *)v18 + 24);
  _Block_object_dispose(&v17, 8);
  _Block_object_dispose(v21, 8);
  _Block_object_dispose(v23, 8);
  return v6;
}

BOOL __nw_http_capsule_framer_parse_vle_value_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  unsigned int v26 = 0;
  uint64_t v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v26);
  if (!v4) {
    goto LABEL_11;
  }
  uint64_t v5 = *(unsigned __int8 *)(*(void *)(a1[4] + 8) + 24);
  if (8 - v5 <= (unint64_t)v26) {
    size_t v6 = (8 - v5);
  }
  else {
    size_t v6 = v26;
  }
  memcpy(*(void **)(*(void *)(a1[5] + 8) + 24), v4, v6);
  *(unsigned char *)(*(void *)(a1[4] + 8) + 24) += v6;
  int v8 = *(_DWORD **)(*(void *)(a1[5] + 8) + 24);
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v30 = "_http_vle_decode";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v18, &type, &v27)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "_http_vle_decode";
      char v21 = "%{public}s called with null *buffer";
      goto LABEL_52;
    }
    if (!v27)
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "_http_vle_decode";
      char v21 = "%{public}s called with null *buffer, backtrace limit exceeded";
      goto LABEL_52;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v23 = os_log_type_enabled(v19, type);
    if (!backtrace_string)
    {
      if (!v23) {
        goto LABEL_53;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "_http_vle_decode";
      char v21 = "%{public}s called with null *buffer, no backtrace";
      goto LABEL_52;
    }
    if (v23)
    {
      *(_DWORD *)long long buf = 136446466;
      BOOL v30 = "_http_vle_decode";
      __int16 v31 = 2082;
      uint64_t v32 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_53:
    if (!v18) {
      goto LABEL_11;
    }
    goto LABEL_54;
  }
  uint64_t v9 = (unint64_t *)a1[7];
  if (!v9)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v30 = "_http_vle_decode";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v18, &type, &v27)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "_http_vle_decode";
      char v21 = "%{public}s called with null decoded_val";
      goto LABEL_52;
    }
    if (!v27)
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "_http_vle_decode";
      char v21 = "%{public}s called with null decoded_val, backtrace limit exceeded";
      goto LABEL_52;
    }
    uint64_t v24 = (char *)__nw_create_backtrace_string();
    uint64_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v25 = os_log_type_enabled(v19, type);
    if (v24)
    {
      if (v25)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v30 = "_http_vle_decode";
        __int16 v31 = 2082;
        uint64_t v32 = v24;
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null decoded_val, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v24);
      if (!v18) {
        goto LABEL_11;
      }
LABEL_54:
      free(v18);
      goto LABEL_11;
    }
    if (v25)
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v30 = "_http_vle_decode";
      char v21 = "%{public}s called with null decoded_val, no backtrace";
LABEL_52:
      _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
      goto LABEL_53;
    }
    goto LABEL_53;
  }
  uint64_t v10 = *(void *)(a1[4] + 8);
  unsigned int v11 = *(unsigned __int8 *)(v10 + 24);
  if (!*(unsigned char *)(v10 + 24)) {
    goto LABEL_11;
  }
  unint64_t v12 = *(unsigned __int8 *)v8;
  if (v12 <= 0x3F)
  {
    int v13 = 1;
LABEL_10:
    unint64_t *v9 = v12;
    *(unsigned char *)(*(void *)(a1[6] + 8) + 24) = 1;
    nw_frame_claim(a2, v7, v13 - v5, 0);
    goto LABEL_11;
  }
  unsigned int v17 = v12 >> 6;
  if (v17 == 2)
  {
    if (v11 >= 4)
    {
      unint64_t v12 = bswap32(*v8 & 0xFFFFFF7F);
      int v13 = 4;
      goto LABEL_10;
    }
  }
  else if (v17 == 1)
  {
    if (v11 >= 2)
    {
      unint64_t v12 = bswap32(*(_WORD *)v8 & 0xFFBF) >> 16;
      int v13 = 2;
      goto LABEL_10;
    }
  }
  else if (v11 >= 8)
  {
    unint64_t v12 = bswap64(*(void *)v8 & 0xFFFFFFFFFFFFFF3FLL);
    int v13 = 8;
    goto LABEL_10;
  }
LABEL_11:
  if (*(unsigned char *)(*(void *)(a1[6] + 8) + 24)) {
    return 0;
  }
  uint64_t v15 = *(void *)(a2 + 32);
  uint64_t v16 = *(void **)(a2 + 40);
  if (v15)
  {
    *(void *)(v15 + 40) = v16;
    uint64_t v16 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(a1[9] + 24) = v16;
  }
  void *v16 = v15;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return *(unsigned char *)(*(void *)(a1[6] + 8) + 24) == 0;
}

void sub_183A6D628(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_service_connector_copy_connection_description(NWConcrete_nw_connection *a1)
{
  id v1 = a1;
  uint64_t v2 = nw_connection_copy_description(&v1->super);
  if (v2)
  {
    uint64_t v3 = nw_connection_copy_current_path(&v1->super);
    uint64_t v4 = v3;
    if (v3)
    {
      nw_endpoint_t v5 = nw_path_copy_effective_local_endpoint(v3);
      nw_endpoint_t v6 = v5;
      if (v5)
      {
        logging_description = nw_endpoint_get_logging_description(v5);
        if (logging_description)
        {
          uint64_t v9 = 0;
          asprintf(&v9, "%s local %s", v2, logging_description);
          free(v2);
          uint64_t v2 = v9;
        }
      }
    }
    else
    {
      nw_endpoint_t v6 = 0;
    }
  }
  else
  {
    nw_endpoint_t v6 = 0;
  }

  return v2;
}

void sub_183A6D6F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A6DAA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)NWConcrete_nw_unique_connection_request;
  [(_Unwind_Exception *)&a14 dealloc];
  _Unwind_Resume(a1);
}

void sub_183A6DEA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A6E228(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)NWConcrete_nw_unique_connection;
  [(_Unwind_Exception *)&a14 dealloc];
  _Unwind_Resume(a1);
}

void sub_183A6E92C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_service_connector;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

id nw_service_connector_create(int a1, void *a2, void *a3)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  uint64_t v7 = v6;
  if (a1)
  {
    if (v6)
    {
      int v8 = objc_alloc_init(NWConcrete_nw_service_connector);
      uint64_t v9 = v8;
      if (v8)
      {
        v8->uniqueID = atomic_fetch_add(nw_service_connector_create::sNWSCUniqueID, 1uLL);
        v8->state = 1;
        v8->localPortHBO = a1;
        objc_storeStrong((id *)&v8->serviceConnectorQueue, a3);
        if (v5)
        {
          id v10 = v5;
          BOOL v11 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v10, 0, 0);

          clientParameters = v9->clientParameters;
          v9->clientParameters = (OS_nw_parameters *)v11;
        }
        else
        {
          clientParameters = v9->clientParameters;
          v9->clientParameters = 0;
        }

        BOOL v17 = nw_array_create();
        pendingUnverifiedIncomingRequests = v9->pendingUnverifiedIncomingRequests;
        v9->pendingUnverifiedIncomingRequests = (OS_nw_array *)v17;

        uint64_t v19 = (OS_nw_dictionary *)nw_dictionary_create();
        pendingIncomingRequests = v9->pendingIncomingRequests;
        v9->pendingIncomingRequests = v19;

        if (v9->pendingIncomingRequests)
        {
          char v21 = (OS_nw_dictionary *)nw_dictionary_create();
          activeConnections = v9->activeConnections;
          v9->activeConnections = v21;

          if (!v9->activeConnections)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v43 = (id)gLogObj;
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            uint64_t v14 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v90[0] = 0;
            if (!__nwlog_fault(v14, type, v90)) {
              goto LABEL_96;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v15 = (id)gLogObj;
              os_log_type_t v44 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v44, "%{public}s nw_dictionary_create failed", buf, 0xCu);
              }
            }
            else if (v90[0])
            {
              backtrace_string = __nw_create_backtrace_string();
              if (backtrace_string)
              {
                unint64_t v50 = (char *)backtrace_string;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                BOOL v51 = (id)gLogObj;
                os_log_type_t v52 = type[0];
                if (os_log_type_enabled(v51, type[0]))
                {
                  *(_DWORD *)long long buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v50;
                  _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v50);
                if (!v14) {
                  goto LABEL_98;
                }
                goto LABEL_97;
              }
              uint64_t v15 = __nwlog_obj();
              os_log_type_t v62 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v62, "%{public}s nw_dictionary_create failed, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v15 = (id)gLogObj;
              os_log_type_t v61 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v61, "%{public}s nw_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
              }
            }
            goto LABEL_95;
          }
          BOOL v23 = (OS_nw_dictionary *)nw_dictionary_create();
          activeOutgoingRequests = v9->activeOutgoingRequests;
          v9->activeOutgoingRequests = v23;

          if (v9->activeOutgoingRequests)
          {
            BOOL v25 = (OS_xpc_object *)xpc_dictionary_create(0, 0, 0);
            remotePubKeys = v9->remotePubKeys;
            v9->remotePubKeys = v25;

            if (v9->remotePubKeys)
            {
              char v27 = v9;
              CFErrorRef error = 0;
              SecAccessControlRef v28 = SecAccessControlCreateWithFlags((CFAllocatorRef)*MEMORY[0x1E4F1CF80], (CFTypeRef)*MEMORY[0x1E4F3B5A0], 0x40000000uLL, &error);
              SecAccessControlRef v29 = v28;
              if (v28)
              {
                uint64_t v30 = *MEMORY[0x1E4F3B750];
                uint64_t v31 = *MEMORY[0x1E4F3B890];
                *(void *)os_log_type_t type = *MEMORY[0x1E4F3B718];
                uint64_t v88 = v31;
                uint64_t v32 = *MEMORY[0x1E4F3B898];
                *(void *)long long buf = v30;
                *(void *)&uint8_t buf[8] = v32;
                uint64_t v89 = *MEMORY[0x1E4F3BC18];
                uint64_t v33 = *MEMORY[0x1E4F3B548];
                v85[0] = *MEMORY[0x1E4F3B6B0];
                v85[1] = v33;
                v86[0] = MEMORY[0x1E4F1CC28];
                v86[1] = v28;
                uint64_t v34 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v86 forKeys:v85 count:2];
                *(void *)&buf[16] = v34;
                CFDictionaryRef v35 = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:buf forKeys:type count:3];

                CFRelease(v29);
                SecKeyRef v36 = SecKeyCreateRandomKey(v35, &error);
                v27->localPrivKey = v36;
                if (v36)
                {
                  int v37 = SecKeyCopyPublicBytes();
                  char v81 = __nwlog_obj();
                  if (os_log_type_enabled(v81, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)uint64_t v90 = 136446466;
                    unsigned int v91 = "nwsc_generate_keys";
                    __int16 v92 = 1024;
                    LODWORD(v93) = v37;
                    _os_log_impl(&dword_1830D4000, v81, OS_LOG_TYPE_ERROR, "%{public}s SecKeyCopyPublicBytes failed with error %d", v90, 0x12u);
                  }

                  localPrivKey = v27->localPrivKey;
                  if (localPrivKey)
                  {
                    CFRelease(localPrivKey);
                    v27->localPrivKey = 0;
                  }
                }
                else
                {
                  unsigned int v80 = __nwlog_obj();
                  if (os_log_type_enabled(v80, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)uint64_t v90 = 136446466;
                    unsigned int v91 = "nwsc_generate_keys";
                    __int16 v92 = 2112;
                    CFErrorRef v93 = error;
                    _os_log_impl(&dword_1830D4000, v80, OS_LOG_TYPE_ERROR, "%{public}s SecKeyCreateRandomKey failed with error %@", v90, 0x16u);
                  }
                }
              }
              else
              {
                __nwlog_obj();
                CFDictionaryRef v35 = (const __CFDictionary *)objc_claimAutoreleasedReturnValue();
                if (os_log_type_enabled((os_log_t)v35, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)uint64_t v90 = 136446466;
                  unsigned int v91 = "nwsc_generate_keys";
                  __int16 v92 = 2112;
                  CFErrorRef v93 = error;
                  _os_log_impl(&dword_1830D4000, (os_log_t)v35, OS_LOG_TYPE_ERROR, "%{public}s SecAccessControlCreateWithFlags failed with error %@", v90, 0x16u);
                }
              }

              goto LABEL_98;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v54 = (id)gLogObj;
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            uint64_t v14 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v90[0] = 0;
            if (!__nwlog_fault(v14, type, v90))
            {
LABEL_96:
              if (!v14)
              {
LABEL_98:

                goto LABEL_99;
              }
LABEL_97:
              free(v14);
              goto LABEL_98;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v15 = (id)gLogObj;
              os_log_type_t v55 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v55, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
              }
LABEL_95:

              goto LABEL_96;
            }
            if (!v90[0])
            {
              uint64_t v15 = __nwlog_obj();
              os_log_type_t v64 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v64, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_95;
            }
            __int16 v40 = (char *)__nw_create_backtrace_string();
            uint64_t v15 = __nwlog_obj();
            os_log_type_t v59 = type[0];
            BOOL v60 = os_log_type_enabled(v15, type[0]);
            if (!v40)
            {
              if (v60)
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v59, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
              }
              goto LABEL_95;
            }
            if (v60)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v40;
              _os_log_impl(&dword_1830D4000, v15, v59, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v47 = (id)gLogObj;
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            uint64_t v14 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v90[0] = 0;
            if (!__nwlog_fault(v14, type, v90)) {
              goto LABEL_96;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v15 = (id)gLogObj;
              os_log_type_t v48 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v48, "%{public}s nw_dictionary_create failed", buf, 0xCu);
              }
              goto LABEL_95;
            }
            if (!v90[0])
            {
              uint64_t v15 = __nwlog_obj();
              os_log_type_t v63 = type[0];
              if (os_log_type_enabled(v15, type[0]))
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v63, "%{public}s nw_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_95;
            }
            __int16 v40 = (char *)__nw_create_backtrace_string();
            uint64_t v15 = __nwlog_obj();
            os_log_type_t v56 = type[0];
            BOOL v57 = os_log_type_enabled(v15, type[0]);
            if (!v40)
            {
              if (v57)
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_service_connector_create";
                _os_log_impl(&dword_1830D4000, v15, v56, "%{public}s nw_dictionary_create failed, no backtrace", buf, 0xCu);
              }
              goto LABEL_95;
            }
            if (v57)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v40;
              _os_log_impl(&dword_1830D4000, v15, v56, "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v38 = (id)gLogObj;
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          uint64_t v14 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v90[0] = 0;
          if (!__nwlog_fault(v14, type, v90)) {
            goto LABEL_96;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v15 = (id)gLogObj;
            os_log_type_t v39 = type[0];
            if (os_log_type_enabled(v15, type[0]))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              _os_log_impl(&dword_1830D4000, v15, v39, "%{public}s nw_dictionary_create failed", buf, 0xCu);
            }
            goto LABEL_95;
          }
          if (!v90[0])
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v15 = (id)gLogObj;
            os_log_type_t v58 = type[0];
            if (os_log_type_enabled(v15, type[0]))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              _os_log_impl(&dword_1830D4000, v15, v58, "%{public}s nw_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_95;
          }
          __int16 v40 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v15 = (id)gLogObj;
          os_log_type_t v45 = type[0];
          BOOL v46 = os_log_type_enabled(v15, type[0]);
          if (!v40)
          {
            if (v46)
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_create";
              _os_log_impl(&dword_1830D4000, v15, v45, "%{public}s nw_dictionary_create failed, no backtrace", buf, 0xCu);
            }
            goto LABEL_95;
          }
          if (v46)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v40;
            _os_log_impl(&dword_1830D4000, v15, v45, "%{public}s nw_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (id)gLogObj;
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_create";
        uint64_t v14 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v90[0] = 0;
        if (!__nwlog_fault(v14, type, v90)) {
          goto LABEL_96;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v15 = (id)gLogObj;
          os_log_type_t v16 = type[0];
          if (os_log_type_enabled(v15, type[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s [nw_service_connector_t init:] failed", buf, 0xCu);
          }
          goto LABEL_95;
        }
        if (!v90[0])
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v15 = (id)gLogObj;
          os_log_type_t v53 = type[0];
          if (os_log_type_enabled(v15, type[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            _os_log_impl(&dword_1830D4000, v15, v53, "%{public}s [nw_service_connector_t init:] failed, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_95;
        }
        __int16 v40 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v15 = (id)gLogObj;
        os_log_type_t v41 = type[0];
        BOOL v42 = os_log_type_enabled(v15, type[0]);
        if (!v40)
        {
          if (v42)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_create";
            _os_log_impl(&dword_1830D4000, v15, v41, "%{public}s [nw_service_connector_t init:] failed, no backtrace", buf, 0xCu);
          }
          goto LABEL_95;
        }
        if (v42)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v40;
          _os_log_impl(&dword_1830D4000, v15, v41, "%{public}s [nw_service_connector_t init:] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }

      free(v40);
      if (!v14) {
        goto LABEL_98;
      }
      goto LABEL_97;
    }
    __int16 v70 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_create";
    uint64_t v67 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v90[0] = 0;
    if (__nwlog_fault(v67, type, v90))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v68 = __nwlog_obj();
        os_log_type_t v71 = type[0];
        if (os_log_type_enabled(v68, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          _os_log_impl(&dword_1830D4000, v68, v71, "%{public}s called with null queue", buf, 0xCu);
        }
LABEL_134:

        goto LABEL_135;
      }
      if (!v90[0])
      {
        uint64_t v68 = __nwlog_obj();
        os_log_type_t v79 = type[0];
        if (os_log_type_enabled(v68, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          _os_log_impl(&dword_1830D4000, v68, v79, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_134;
      }
      BOOL v75 = (char *)__nw_create_backtrace_string();
      uint64_t v68 = __nwlog_obj();
      os_log_type_t v76 = type[0];
      BOOL v77 = os_log_type_enabled(v68, type[0]);
      if (!v75)
      {
        if (v77)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_create";
          _os_log_impl(&dword_1830D4000, v68, v76, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
        goto LABEL_134;
      }
      if (v77)
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_service_connector_create";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v75;
        _os_log_impl(&dword_1830D4000, v68, v76, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v75);
    }
LABEL_135:
    if (!v67) {
      goto LABEL_99;
    }
    goto LABEL_136;
  }
  size_t v66 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_service_connector_create";
  uint64_t v67 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v90[0] = 0;
  if (!__nwlog_fault(v67, type, v90)) {
    goto LABEL_135;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    uint64_t v68 = __nwlog_obj();
    os_log_type_t v69 = type[0];
    if (os_log_type_enabled(v68, type[0]))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_create";
      _os_log_impl(&dword_1830D4000, v68, v69, "%{public}s called with null (localPort != 0)", buf, 0xCu);
    }
    goto LABEL_134;
  }
  if (!v90[0])
  {
    uint64_t v68 = __nwlog_obj();
    os_log_type_t v78 = type[0];
    if (os_log_type_enabled(v68, type[0]))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_create";
      _os_log_impl(&dword_1830D4000, v68, v78, "%{public}s called with null (localPort != 0), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_134;
  }
  os_log_type_t v72 = (char *)__nw_create_backtrace_string();
  uint64_t v68 = __nwlog_obj();
  os_log_type_t v73 = type[0];
  BOOL v74 = os_log_type_enabled(v68, type[0]);
  if (!v72)
  {
    if (v74)
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_create";
      _os_log_impl(&dword_1830D4000, v68, v73, "%{public}s called with null (localPort != 0), no backtrace", buf, 0xCu);
    }
    goto LABEL_134;
  }
  if (v74)
  {
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_service_connector_create";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v72;
    _os_log_impl(&dword_1830D4000, v68, v73, "%{public}s called with null (localPort != 0), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v72);
  if (v67) {
LABEL_136:
  }
    free(v67);
LABEL_99:

  return 0;
}

void sub_183A70110(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_set_service_available_block(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v27 = "nw_service_connector_set_service_available_block";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)long long buf = 136446210;
        char v27 = "nw_service_connector_set_service_available_block";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446466;
          char v27 = "nw_service_connector_set_service_available_block";
          __int16 v28 = 2082;
          SecAccessControlRef v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)long long buf = 136446210;
        char v27 = "nw_service_connector_set_service_available_block";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)long long buf = 136446210;
        char v27 = "nw_service_connector_set_service_available_block";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    id v6 = v3[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_set_service_available_block_block_invoke;
    block[3] = &unk_1E524B950;
    char v22 = v3;
    id v23 = v5;
    dispatch_async(v6, block);

    goto LABEL_4;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v27 = "nw_service_connector_set_service_available_block";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)long long buf = 136446210;
      char v27 = "nw_service_connector_set_service_available_block";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null serviceAvailableBlock", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)long long buf = 136446210;
      char v27 = "nw_service_connector_set_service_available_block";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null serviceAvailableBlock, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  uint64_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)long long buf = 136446210;
      char v27 = "nw_service_connector_set_service_available_block";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null serviceAvailableBlock, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)long long buf = 136446466;
    char v27 = "nw_service_connector_set_service_available_block";
    __int16 v28 = 2082;
    SecAccessControlRef v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null serviceAvailableBlock, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

void __nw_service_connector_set_service_available_block_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 64);
  *(void *)(v3 + 64) = v2;
}

void nw_service_connector_start(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_start_block_invoke;
    block[3] = &unk_1E524BAA8;
    id v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v17 = "nw_service_connector_start";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v17 = "nw_service_connector_start";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v17 = "nw_service_connector_start";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v17 = "nw_service_connector_start";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v17 = "nw_service_connector_start";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void __nw_service_connector_start_block_invoke_102(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a2;
  id v4 = (NWConcrete_nw_connection *)v3;
  uint64_t v5 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v5 + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      uint64_t v7 = *(void *)(a1 + 32);
      int v15 = 136446722;
      os_log_type_t v16 = "nw_service_connector_start_block_invoke";
      __int16 v17 = 2114;
      uint64_t v18 = v7;
      __int16 v19 = 2114;
      uint64_t v20 = v4;
      int v8 = "%{public}s %{public}@ already cancelled, ignoring new connection %{public}@";
      os_log_type_t v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_ERROR;
      uint32_t v11 = 32;
LABEL_7:
      _os_log_impl(&dword_1830D4000, v9, v10, v8, (uint8_t *)&v15, v11);
    }
  }
  else
  {
    if (*(void *)(v5 + 8) == *(void *)(a1 + 40))
    {
      nw_connection_set_state_changed_handler(v3, 0);
      nw_connection_set_queue(&v4->super, *(dispatch_queue_t *)(*(void *)(a1 + 32) + 32));
      nw_connection_start(&v4->super);
      nw_service_connector_should_accept_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), v4, 1);
      goto LABEL_9;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      uint64_t v13 = *(void *)(a1 + 40);
      uint64_t v14 = *(void *)(v12 + 8);
      int v15 = 136447234;
      os_log_type_t v16 = "nw_service_connector_start_block_invoke";
      __int16 v17 = 2114;
      uint64_t v18 = v12;
      __int16 v19 = 2114;
      uint64_t v20 = v4;
      __int16 v21 = 2048;
      uint64_t v22 = v14;
      __int16 v23 = 2048;
      uint64_t v24 = v13;
      int v8 = "%{public}s %{public}@ Ignoring new connection %{public}@ for stale listener (%p != %p)";
      os_log_type_t v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_DEFAULT;
      uint32_t v11 = 52;
      goto LABEL_7;
    }
  }

  nw_connection_cancel(&v4->super);
LABEL_9:
}

void sub_183A70BD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_block_invoke_104(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a3;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
  if (v5)
  {
    if (!v7) {
      goto LABEL_13;
    }
    if (a2 > 4) {
      int v8 = "<unknown>";
    }
    else {
      int v8 = off_1E523D0E0[a2];
    }
    uint64_t v11 = *(void *)(a1 + 32);
    os_log_type_t v10 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 40);
    *(_DWORD *)long long buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v11;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v82 = v10;
    *(_WORD *)uint64_t v83 = 2082;
    *(void *)&v83[2] = v8;
    *(_WORD *)&v83[10] = 2114;
    *(void *)&v83[12] = v5;
    uint64_t v12 = "%{public}s %{public}@ Listener(%p) entered state %{public}s with error %{public}@";
    uint64_t v13 = v6;
    uint32_t v14 = 52;
  }
  else
  {
    if (!v7) {
      goto LABEL_13;
    }
    if (a2 > 4) {
      os_log_type_t v9 = "<unknown>";
    }
    else {
      os_log_type_t v9 = off_1E523D0E0[a2];
    }
    uint64_t v16 = *(void *)(a1 + 32);
    int v15 = *(uint64_t (**)(uint64_t, uint64_t))(a1 + 40);
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v16;
    *(_WORD *)&buf[22] = 2048;
    uint64_t v82 = v15;
    *(_WORD *)uint64_t v83 = 2082;
    *(void *)&v83[2] = v9;
    uint64_t v12 = "%{public}s %{public}@ Listener(%p) entered state %{public}s";
    uint64_t v13 = v6;
    uint32_t v14 = 42;
  }
  _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, v12, buf, v14);
LABEL_13:

  uint64_t v17 = *(void *)(a1 + 32);
  int v18 = *(_DWORD *)(v17 + 16);
  if (v18 == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      uint64_t v20 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v20;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring listener state change", buf, 0x16u);
    }
LABEL_16:

    goto LABEL_60;
  }
  if (*(void *)(v17 + 8) != *(void *)(a1 + 40))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v21 = *(void *)(a1 + 32);
      uint64_t v22 = *(void *)(a1 + 40);
      __int16 v23 = *(uint64_t (**)(uint64_t, uint64_t))(v21 + 8);
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v21;
      *(_WORD *)&buf[22] = 2048;
      uint64_t v82 = v23;
      *(_WORD *)uint64_t v83 = 2048;
      *(void *)&v83[2] = v22;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ Ignoring state update for stale listener (%p != %p)", buf, 0x2Au);
    }
    goto LABEL_16;
  }
  if (a2 == 4)
  {
    int v29 = 4;
LABEL_59:
    *(_DWORD *)(v17 + 16) = v29;
    goto LABEL_60;
  }
  if (a2 == 3)
  {
    int error_code = nw_error_get_error_code(v5);
    uint64_t v17 = *(void *)(a1 + 32);
    if (error_code != 48)
    {
LABEL_58:
      int v29 = 3;
      goto LABEL_59;
    }
    unsigned int v31 = *(unsigned __int8 *)(v17 + 50);
    if (v31 <= 4)
    {
      *(unsigned char *)(v17 + 50) = v31 + 1;
      uint64_t v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v33 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v33;
        _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ scheduling a retry as the address is in use", buf, 0x16u);
      }

      uint64_t v34 = *(void **)(a1 + 32);
      uint64_t v35 = v34[7];
      if (v35)
      {
        nw_queue_cancel_source(v35);
        *(void *)(*(void *)(a1 + 32) + 56) = 0;
        uint64_t v34 = *(void **)(a1 + 32);
      }
      v71[0] = MEMORY[0x1E4F143A8];
      v71[1] = 3221225472;
      v71[2] = __nw_service_connector_start_block_invoke_105;
      v71[3] = &unk_1E524BAA8;
      os_log_type_t v72 = v34;
      *(void *)(*(void *)(a1 + 32) + 56) = nw_queue_context_create_source(0, 2, 3, 0, v71, 0);
      uint64_t v36 = *(void *)(a1 + 32);
      uint64_t v37 = *(void *)(v36 + 56);
      dispatch_time_t v38 = dispatch_time(0x8000000000000000, 200000000 * *(unsigned __int8 *)(v36 + 50));
      nw_queue_set_timer_values(v37, v38, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
      nw_queue_activate_source(*(void *)(*(void *)(a1 + 32) + 56));

      goto LABEL_60;
    }
    os_log_type_t v39 = __nwlog_obj();
    uint64_t v40 = *(void *)(a1 + 32);
    int v41 = *(unsigned __int8 *)(v40 + 50);
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke_2";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v40;
    *(_WORD *)&buf[22] = 2114;
    uint64_t v82 = (uint64_t (*)(uint64_t, uint64_t))v5;
    *(_WORD *)uint64_t v83 = 1024;
    *(_DWORD *)&v83[2] = v41;
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v73[0]) = 0;
    if (__nwlog_fault(v42, type, v73))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v43 = __nwlog_obj();
        os_log_type_t v44 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          uint64_t v45 = *(void *)(a1 + 32);
          int v46 = *(unsigned __int8 *)(v45 + 50);
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v45;
          *(_WORD *)&buf[22] = 2114;
          uint64_t v82 = (uint64_t (*)(uint64_t, uint64_t))v5;
          *(_WORD *)uint64_t v83 = 1024;
          *(_DWORD *)&v83[2] = v46;
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries", buf, 0x26u);
        }
      }
      else if (LOBYTE(v73[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v43 = __nwlog_obj();
        os_log_type_t v48 = type[0];
        BOOL v49 = os_log_type_enabled(v43, type[0]);
        if (backtrace_string)
        {
          if (v49)
          {
            uint64_t v50 = *(void *)(a1 + 32);
            int v51 = *(unsigned __int8 *)(v50 + 50);
            *(_DWORD *)long long buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v50;
            *(_WORD *)&buf[22] = 2114;
            uint64_t v82 = (uint64_t (*)(uint64_t, uint64_t))v5;
            *(_WORD *)uint64_t v83 = 1024;
            *(_DWORD *)&v83[2] = v51;
            *(_WORD *)&v83[6] = 2082;
            *(void *)&v83[8] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v43, v48, "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries, dumping backtrace:%{public}s", buf, 0x30u);
          }

          free(backtrace_string);
          goto LABEL_55;
        }
        if (v49)
        {
          uint64_t v55 = *(void *)(a1 + 32);
          int v56 = *(unsigned __int8 *)(v55 + 50);
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v55;
          *(_WORD *)&buf[22] = 2114;
          uint64_t v82 = (uint64_t (*)(uint64_t, uint64_t))v5;
          *(_WORD *)uint64_t v83 = 1024;
          *(_DWORD *)&v83[2] = v56;
          _os_log_impl(&dword_1830D4000, v43, v48, "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries, no backtrace", buf, 0x26u);
        }
      }
      else
      {
        id v43 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          uint64_t v53 = *(void *)(a1 + 32);
          int v54 = *(unsigned __int8 *)(v53 + 50);
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_start_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v53;
          *(_WORD *)&buf[22] = 2114;
          uint64_t v82 = (uint64_t (*)(uint64_t, uint64_t))v5;
          *(_WORD *)uint64_t v83 = 1024;
          *(_DWORD *)&v83[2] = v54;
          _os_log_impl(&dword_1830D4000, v43, v52, "%{public}s %{public}@ Listener failed to become ready due to error %{public}@ after %d retries, backtrace limit exceeded", buf, 0x26u);
        }
      }
    }
LABEL_55:
    if (v42) {
      free(v42);
    }
    uint64_t v17 = *(void *)(a1 + 32);
    goto LABEL_58;
  }
  if (a2 == 2 && v18 != 2)
  {
    *(_DWORD *)(v17 + 16) = 2;
    uint64_t v24 = *(id *)(a1 + 32);
    uint64_t v25 = v24;
    if (v24)
    {
      uint64_t v26 = v24[12];
      if (v26)
      {
        *(void *)long long buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000;
        uint64_t v82 = __Block_byref_object_copy__49805;
        *(void *)uint64_t v83 = __Block_byref_object_dispose__49806;
        *(void *)&v83[8] = 0;
        *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
        uint64_t v76 = 3221225472;
        BOOL v77 = ___ZL49nwsc_start_outgoing_requests_waiting_for_listenerP31NWConcrete_nw_service_connector_block_invoke;
        os_log_type_t v78 = &unk_1E524A1A8;
        char v27 = v24;
        id v79 = v27;
        unsigned int v80 = buf;
        nw_dictionary_apply(v26, (uint64_t)type);
        __int16 v28 = *(atomic_uchar **)(*(void *)&buf[8] + 40);
        if (v28)
        {
          v73[0] = MEMORY[0x1E4F143A8];
          v73[1] = 3221225472;
          v73[2] = ___ZL49nwsc_start_outgoing_requests_waiting_for_listenerP31NWConcrete_nw_service_connector_block_invoke_177;
          v73[3] = &unk_1E524AE18;
          BOOL v74 = v27;
          nw_array_apply(v28, (uint64_t)v73);
        }
        _Block_object_dispose(buf, 8);

        goto LABEL_30;
      }
      os_log_type_t v61 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
      os_log_type_t v58 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v73[0]) = 0;
      if (__nwlog_fault(v58, type, v73))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v59 = __nwlog_obj();
          os_log_type_t v62 = type[0];
          if (os_log_type_enabled(v59, type[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
            _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null serviceConnector->activeOutgoingRequests", buf, 0xCu);
          }
        }
        else if (LOBYTE(v73[0]))
        {
          size_t v66 = (char *)__nw_create_backtrace_string();
          os_log_type_t v59 = __nwlog_obj();
          os_log_type_t v67 = type[0];
          BOOL v68 = os_log_type_enabled(v59, type[0]);
          if (v66)
          {
            if (v68)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v66;
              _os_log_impl(&dword_1830D4000, v59, v67, "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v66);
            if (!v58) {
              goto LABEL_30;
            }
            goto LABEL_95;
          }
          if (v68)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
            _os_log_impl(&dword_1830D4000, v59, v67, "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          os_log_type_t v59 = __nwlog_obj();
          os_log_type_t v70 = type[0];
          if (os_log_type_enabled(v59, type[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
            _os_log_impl(&dword_1830D4000, v59, v70, "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded", buf, 0xCu);
          }
        }
        goto LABEL_93;
      }
LABEL_94:
      if (!v58)
      {
LABEL_30:

        goto LABEL_60;
      }
LABEL_95:
      free(v58);
      goto LABEL_30;
    }
    BOOL v57 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
    os_log_type_t v58 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v73[0]) = 0;
    if (!__nwlog_fault(v58, type, v73)) {
      goto LABEL_94;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
        _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (LOBYTE(v73[0]))
    {
      os_log_type_t v63 = (char *)__nw_create_backtrace_string();
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v64 = type[0];
      BOOL v65 = os_log_type_enabled(v59, type[0]);
      if (v63)
      {
        if (v65)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v63;
          _os_log_impl(&dword_1830D4000, v59, v64, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v63);
        goto LABEL_94;
      }
      if (v65)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
        _os_log_impl(&dword_1830D4000, v59, v64, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v69 = type[0];
      if (os_log_type_enabled(v59, type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwsc_start_outgoing_requests_waiting_for_listener";
        _os_log_impl(&dword_1830D4000, v59, v69, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_93:

    goto LABEL_94;
  }
LABEL_60:
}

void sub_183A718F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__49805(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__49806(uint64_t a1)
{
}

uint64_t ___ZL49nwsc_start_outgoing_requests_waiting_for_listenerP31NWConcrete_nw_service_connector_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  v4[616] &= ~8u;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v6 = *(void *)(a1 + 32);
    int v14 = 136446722;
    int v15 = "nwsc_start_outgoing_requests_waiting_for_listener_block_invoke";
    __int16 v16 = 2114;
    uint64_t v17 = v6;
    __int16 v18 = 2114;
    __int16 v19 = v4;
    _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ starting connection for request %{public}@ due to listener ready", (uint8_t *)&v14, 0x20u);
  }

  BOOL v7 = nwsc_request_create_and_start_connection_inner(*(void **)(a1 + 32), v4, 0);
  BOOL v8 = v7 == 0;

  if (v8)
  {
    uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    if (!v9)
    {
      BOOL v10 = nw_array_create();
      uint64_t v11 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v12 = *(void **)(v11 + 40);
      *(void *)(v11 + 40) = v10;

      uint64_t v9 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40);
    }
    nw_array_append(v9, v4);
  }

  return 1;
}

void sub_183A71ABC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL49nwsc_start_outgoing_requests_waiting_for_listenerP31NWConcrete_nw_service_connector_block_invoke_177(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v4, 0, 0, 12);
  nw_service_connector_remove_active_outgoing_request(*(NWConcrete_nw_service_connector **)(a1 + 32), v4);

  return 1;
}

void sub_183A71B34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_block_invoke_105(uint64_t a1)
{
}

void nw_service_connector_trigger_request_complete_block_inner(void *a1, void *a2, void *a3, void *a4, int a5)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  BOOL v10 = a2;
  id v11 = a3;
  id v12 = a4;
  if (v10 && v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v13 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446722;
    BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
    __int16 v50 = 2114;
    *(void *)int v51 = v9;
    *(_WORD *)&v51[8] = 2114;
    *(void *)&v51[10] = v10;
    int v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v14, &type, &v46)) {
      goto LABEL_52;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)long long buf = 136446722;
        BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)int v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock", buf, 0x20u);
      }
    }
    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)long long buf = 136446978;
          BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
          __int16 v50 = 2114;
          *(void *)int v51 = v9;
          *(_WORD *)&v51[8] = 2114;
          *(void *)&v51[10] = v10;
          __int16 v52 = 2082;
          uint64_t v53 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(backtrace_string);
        if (v14) {
          goto LABEL_53;
        }
        goto LABEL_64;
      }
      if (v24)
      {
        *(_DWORD *)long long buf = 136446722;
        BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)int v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)long long buf = 136446722;
        BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)int v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        _os_log_impl(&dword_1830D4000, v15, v27, "%{public}s %{public}@ cannot call this with both request %{public}@ and otherRequestBlock, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_51;
  }
  if (!v10 || (v10[616] & 1) == 0)
  {
    if (a5)
    {
      posix_CFErrorRef error = nw_error_create_posix_error(a5);
      if (posix_error)
      {
LABEL_63:
        dispatch_time_t v38 = v9[4];
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZL57nw_service_connector_trigger_request_complete_block_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestU13block_pointerFvP24NWConcrete_nw_connectionP9__CFErrorES4_i_block_invoke;
        block[3] = &unk_1E5243390;
        id v45 = v11;
        int v41 = v10;
        id v42 = posix_error;
        id v43 = v12;
        os_log_type_t v44 = v9;
        os_log_type_t v39 = posix_error;
        dispatch_async(v38, block);

        goto LABEL_64;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v18 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446466;
      BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
      __int16 v50 = 1024;
      *(_DWORD *)int v51 = a5;
      __int16 v19 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v46 = 0;
      if (__nwlog_fault(v19, &type, &v46))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v20 = (id)gLogObj;
          os_log_type_t v21 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
            __int16 v50 = 1024;
            *(_DWORD *)int v51 = a5;
            _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s nw_error_create_posix_error(%d) failed", buf, 0x12u);
          }
        }
        else if (v46)
        {
          uint64_t v32 = (char *)__nw_create_backtrace_string();
          uint64_t v20 = __nwlog_obj();
          os_log_type_t v33 = type;
          BOOL v34 = os_log_type_enabled(v20, type);
          if (v32)
          {
            if (v34)
            {
              *(_DWORD *)long long buf = 136446722;
              BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
              __int16 v50 = 1024;
              *(_DWORD *)int v51 = a5;
              *(_WORD *)&v51[4] = 2082;
              *(void *)&v51[6] = v32;
              _os_log_impl(&dword_1830D4000, v20, v33, "%{public}s nw_error_create_posix_error(%d) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
            }

            free(v32);
            if (!v19) {
              goto LABEL_62;
            }
            goto LABEL_61;
          }
          if (v34)
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
            __int16 v50 = 1024;
            *(_DWORD *)int v51 = a5;
            _os_log_impl(&dword_1830D4000, v20, v33, "%{public}s nw_error_create_posix_error(%d) failed, no backtrace", buf, 0x12u);
          }
        }
        else
        {
          uint64_t v20 = __nwlog_obj();
          os_log_type_t v37 = type;
          if (os_log_type_enabled(v20, type))
          {
            *(_DWORD *)long long buf = 136446466;
            BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
            __int16 v50 = 1024;
            *(_DWORD *)int v51 = a5;
            _os_log_impl(&dword_1830D4000, v20, v37, "%{public}s nw_error_create_posix_error(%d) failed, backtrace limit exceeded", buf, 0x12u);
          }
        }
      }
      if (v19) {
LABEL_61:
      }
        free(v19);
    }
LABEL_62:
    posix_CFErrorRef error = 0;
    goto LABEL_63;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v25 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446722;
  BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
  __int16 v50 = 2114;
  *(void *)int v51 = v9;
  *(_WORD *)&v51[8] = 2114;
  *(void *)&v51[10] = v10;
  int v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v46 = 0;
  if (!__nwlog_fault(v14, &type, &v46)) {
    goto LABEL_52;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v15 = (id)gLogObj;
    os_log_type_t v26 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)long long buf = 136446722;
      BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
      __int16 v50 = 2114;
      *(void *)int v51 = v9;
      *(_WORD *)&v51[8] = 2114;
      *(void *)&v51[10] = v10;
      _os_log_impl(&dword_1830D4000, v15, v26, "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@", buf, 0x20u);
    }
  }
  else if (v46)
  {
    __int16 v28 = __nw_create_backtrace_string();
    if (v28)
    {
      int v29 = (char *)v28;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v30 = (id)gLogObj;
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446978;
        BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
        __int16 v50 = 2114;
        *(void *)int v51 = v9;
        *(_WORD *)&v51[8] = 2114;
        *(void *)&v51[10] = v10;
        __int16 v52 = 2082;
        uint64_t v53 = v29;
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v29);
      if (v14) {
        goto LABEL_53;
      }
      goto LABEL_64;
    }
    int v15 = __nwlog_obj();
    os_log_type_t v36 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)long long buf = 136446722;
      BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
      __int16 v50 = 2114;
      *(void *)int v51 = v9;
      *(_WORD *)&v51[8] = 2114;
      *(void *)&v51[10] = v10;
      _os_log_impl(&dword_1830D4000, v15, v36, "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@, no backtrace", buf, 0x20u);
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v15 = (id)gLogObj;
    os_log_type_t v35 = type;
    if (os_log_type_enabled(v15, type))
    {
      *(_DWORD *)long long buf = 136446722;
      BOOL v49 = "nw_service_connector_trigger_request_complete_block_inner";
      __int16 v50 = 2114;
      *(void *)int v51 = v9;
      *(_WORD *)&v51[8] = 2114;
      *(void *)&v51[10] = v10;
      _os_log_impl(&dword_1830D4000, v15, v35, "%{public}s %{public}@ Cannot trigger request complete block on incoming request %{public}@, backtrace limit exceeded", buf, 0x20u);
    }
  }
LABEL_51:

LABEL_52:
  if (v14) {
LABEL_53:
  }
    free(v14);
LABEL_64:
}

void sub_183A72560(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_remove_active_outgoing_request(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __int16 v19 = __nwlog_obj();
    *(_DWORD *)id v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, buf, &type)) {
      goto LABEL_23;
    }
    if (buf[0] == 17)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null serviceConnector", v47, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v27 = buf[0];
      BOOL v28 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)id v47 = 136446466;
          *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
          *(_WORD *)&v47[12] = 2082;
          *(void *)&v47[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", v47, 0x16u);
        }

        free(backtrace_string);
LABEL_23:
        if (!v8) {
          goto LABEL_25;
        }
LABEL_24:
        free(v8);
        goto LABEL_25;
      }
      if (v28)
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null serviceConnector, no backtrace", v47, 0xCu);
      }
    }
    else
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v34 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v34, "%{public}s called with null serviceConnector, backtrace limit exceeded", v47, 0xCu);
      }
    }
LABEL_74:

    goto LABEL_23;
  }
  if (!v3->activeOutgoingRequests)
  {
    uint64_t v22 = __nwlog_obj();
    *(_DWORD *)id v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, buf, &type)) {
      goto LABEL_23;
    }
    if (buf[0] == 17)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v23 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null serviceConnector->activeOutgoingRequests", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v35 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v35, "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded", v47, 0xCu);
      }
      goto LABEL_74;
    }
    int v29 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
    if (!v29)
    {
      if (v31)
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)id v47 = 136446466;
      *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
      *(_WORD *)&v47[12] = 2082;
      *(void *)&v47[14] = v29;
      _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s", v47, 0x16u);
    }
    goto LABEL_55;
  }
  if (!v4)
  {
    BOOL v24 = __nwlog_obj();
    *(_DWORD *)id v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, buf, &type)) {
      goto LABEL_23;
    }
    if (buf[0] == 17)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v25 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null request", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v36 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v36, "%{public}s called with null request, backtrace limit exceeded", v47, 0xCu);
      }
      goto LABEL_74;
    }
    int v29 = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v32 = buf[0];
    BOOL v33 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
    if (!v29)
    {
      if (v33)
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
        _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s called with null request, no backtrace", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (v33)
    {
      *(_DWORD *)id v47 = 136446466;
      *(void *)&v47[4] = "nw_service_connector_remove_active_outgoing_request";
      *(_WORD *)&v47[12] = 2082;
      *(void *)&v47[14] = v29;
      _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s called with null request, dumping backtrace:%{public}s", v47, 0x16u);
    }
LABEL_55:

    free(v29);
    if (!v8) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  nwsc_request_stop_path_watcher(v4);
  *((unsigned char *)v5 + 616) &= 0xE7u;
  int v73 = 0;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v48 = 0u;
  memset(v47, 0, sizeof(v47));
  if (nwsc_get_identifier(v5->endpoint, (uint64_t)v5->service, v47))
  {
    nw_dictionary_set_value((uint64_t)v3->activeOutgoingRequests, (const char *)v47, 0);
    goto LABEL_25;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  endpoint = v5->endpoint;
  *(_DWORD *)long long buf = 136446722;
  uint64_t v40 = "nw_service_connector_remove_active_outgoing_request";
  __int16 v41 = 2114;
  id v42 = endpoint;
  __int16 v43 = 2082;
  service = v5->service;
  BOOL v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (!__nwlog_fault(v8, &type, &v37)) {
    goto LABEL_23;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      id v11 = v5->endpoint;
      *(_DWORD *)long long buf = 136446722;
      uint64_t v40 = "nw_service_connector_remove_active_outgoing_request";
      __int16 v41 = 2114;
      id v42 = v11;
      __int16 v43 = 2082;
      service = v5->service;
      _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", buf, 0x20u);
    }
LABEL_22:

    goto LABEL_23;
  }
  if (!v37)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    os_log_type_t v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      uint64_t v17 = v5->endpoint;
      *(_DWORD *)long long buf = 136446722;
      uint64_t v40 = "nw_service_connector_remove_active_outgoing_request";
      __int16 v41 = 2114;
      id v42 = v17;
      __int16 v43 = 2082;
      service = v5->service;
      _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_22;
  }
  id v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v9 = (id)gLogObj;
  os_log_type_t v13 = type;
  BOOL v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      id v18 = v5->endpoint;
      *(_DWORD *)long long buf = 136446722;
      uint64_t v40 = "nw_service_connector_remove_active_outgoing_request";
      __int16 v41 = 2114;
      id v42 = v18;
      __int16 v43 = 2082;
      service = v5->service;
      _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_22;
  }
  if (v14)
  {
    int v15 = v5->endpoint;
    *(_DWORD *)long long buf = 136446978;
    uint64_t v40 = "nw_service_connector_remove_active_outgoing_request";
    __int16 v41 = 2114;
    id v42 = v15;
    __int16 v43 = 2082;
    service = v5->service;
    __int16 v45 = 2082;
    char v46 = v12;
    _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_24;
  }
LABEL_25:
}

void sub_183A72FA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_request_stop_path_watcher(NWConcrete_nw_unique_connection_request *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_DEFAULT))
  {
    int v5 = 136446466;
    id v6 = "nwsc_request_stop_path_watcher";
    __int16 v7 = 2114;
    BOOL v8 = v1;
    _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s stopping path watcher request %{public}@", (uint8_t *)&v5, 0x16u);
  }

  pathEvaluator = v1->pathEvaluator;
  if (pathEvaluator)
  {
    nw_path_evaluator_cancel(pathEvaluator);
    id v4 = v1->pathEvaluator;
    v1->pathEvaluator = 0;
  }
  *((unsigned char *)v1 + 616) &= ~0x80u;
}

void sub_183A730C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_should_accept_connection(NWConcrete_nw_service_connector *a1, NWConcrete_nw_connection *a2, int a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v5 = a1;
  id v6 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v7 = (id)gLogObj;
  if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
  {
    BOOL v8 = "outgoing";
    *(_DWORD *)long long buf = 136446978;
    os_log_type_t v16 = "nw_service_connector_should_accept_connection";
    __int16 v17 = 2114;
    id v18 = v5;
    if (a3) {
      BOOL v8 = "incoming";
    }
    __int16 v19 = 2082;
    uint64_t v20 = v8;
    __int16 v21 = 2114;
    uint64_t v22 = v6;
    _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ performing first read on %{public}s connection %{public}@", buf, 0x2Au);
  }

  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke;
  v11[3] = &unk_1E52432C8;
  uint64_t v9 = v5;
  id v12 = v9;
  os_log_type_t v10 = v6;
  os_log_type_t v13 = v10;
  char v14 = a3;
  nw_connection_receive_internal(v10, 0, 2u, 2u, v11);
}

void sub_183A73290(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t nwsc_is_error_allowlisted(void *a1, char a2)
{
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    int v5 = v3;
    int v6 = v5[3];

    if ((a2 & 1) != 0 || v6 != 60)
    {
      uint64_t v7 = 1;
      switch(v6)
      {
        case 0:
        case 5:
        case 6:
        case 12:
        case 32:
        case 48:
        case 49:
        case 50:
        case 51:
        case 52:
        case 53:
        case 54:
        case 55:
        case 60:
        case 61:
        case 64:
        case 65:
        case 96:
          break;
        default:
          goto LABEL_4;
      }
    }
    else
    {
LABEL_4:
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

void nwsc_request_start_path_watcher(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, NWConcrete_nw_connection *a3, int a4)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  BOOL v8 = a2;
  uint64_t v9 = a3;
  p_super = &v9->super;
  if ((*((unsigned char *)v8 + 616) & 1) == 0)
  {
    if (v8->pathEvaluator)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446722;
        id v47 = "nwsc_request_start_path_watcher";
        __int16 v48 = 2114;
        long long v49 = v7;
        __int16 v50 = 2114;
        long long v51 = v8;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ path watcher already started for request %{public}@", buf, 0x20u);
      }

      goto LABEL_40;
    }
    nw_endpoint_t v19 = nw_connection_copy_endpoint(&v9->super);
    nw_parameters_t v20 = nw_connection_copy_parameters(p_super);
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(v19, v20);

    if (evaluator_for_endpoint)
    {
      objc_storeStrong((id *)&v8->pathEvaluator, evaluator_for_endpoint);
      *((unsigned char *)v8 + 616) |= 0x80u;
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 3221225472;
      aBlock[2] = ___ZL31nwsc_request_start_path_watcherP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP24NWConcrete_nw_connectionb_block_invoke;
      aBlock[3] = &unk_1E5243368;
      uint64_t v22 = v7;
      __int16 v41 = v22;
      uint64_t v23 = v8;
      id v42 = v23;
      BOOL v24 = evaluator_for_endpoint;
      __int16 v43 = v24;
      os_log_type_t v25 = _Block_copy(aBlock);
      nw_path_evaluator_set_update_handler(v24, v22[4], v25);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v26 = (id)gLogObj;
      if (os_log_type_enabled(v26, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446722;
        id v47 = "nwsc_request_start_path_watcher";
        __int16 v48 = 2114;
        long long v49 = v22;
        __int16 v50 = 2114;
        long long v51 = v23;
        _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ registered for path updates for request %{public}@", buf, 0x20u);
      }

      if (a4)
      {
        os_log_type_t v27 = nw_connection_copy_current_path(p_super);
        if (nw_path_get_status(v27) == nw_path_status_unsatisfied)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v28 = (id)gLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136446722;
            id v47 = "nwsc_request_start_path_watcher";
            __int16 v48 = 2114;
            long long v49 = v22;
            __int16 v50 = 2114;
            long long v51 = v23;
            _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ forcing a path update for request %{public}@", buf, 0x20u);
          }

          int v29 = v24;
          os_unfair_lock_lock(v24 + 24);
          id v30 = v29[6];
          os_unfair_lock_unlock(v24 + 24);

          (*((void (**)(void *, id))v25 + 2))(v25, v30);
        }
      }
      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v32 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    id v47 = "nwsc_request_start_path_watcher";
    BOOL v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (__nwlog_fault(v33, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v34 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)long long buf = 136446210;
          id v47 = "nwsc_request_start_path_watcher";
          _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s nw_path_create_evaluator_for_endpoint failed", buf, 0xCu);
        }
      }
      else if (v44)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v34 = __nwlog_obj();
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v34, type);
        if (backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)long long buf = 136446466;
            id v47 = "nwsc_request_start_path_watcher";
            __int16 v48 = 2082;
            long long v49 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s nw_path_create_evaluator_for_endpoint failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v33) {
            goto LABEL_39;
          }
          goto LABEL_38;
        }
        if (v38)
        {
          *(_DWORD *)long long buf = 136446210;
          id v47 = "nwsc_request_start_path_watcher";
          _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s nw_path_create_evaluator_for_endpoint failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v34 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)long long buf = 136446210;
          id v47 = "nwsc_request_start_path_watcher";
          _os_log_impl(&dword_1830D4000, v34, v39, "%{public}s nw_path_create_evaluator_for_endpoint failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v33)
    {
LABEL_39:

      goto LABEL_40;
    }
LABEL_38:
    free(v33);
    goto LABEL_39;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v12 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446722;
  id v47 = "nwsc_request_start_path_watcher";
  __int16 v48 = 2114;
  long long v49 = v7;
  __int16 v50 = 2114;
  long long v51 = v8;
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v44 = 0;
  if (!__nwlog_fault(v13, &type, &v44)) {
    goto LABEL_11;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v14 = (id)gLogObj;
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)long long buf = 136446722;
      id v47 = "nwsc_request_start_path_watcher";
      __int16 v48 = 2114;
      long long v49 = v7;
      __int16 v50 = 2114;
      long long v51 = v8;
      _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s %{public}@ tried to start path watcher on incoming request %{public}@", buf, 0x20u);
    }
LABEL_10:

LABEL_11:
    if (!v13) {
      goto LABEL_40;
    }
LABEL_12:
    free(v13);
    goto LABEL_40;
  }
  if (!v44)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v14 = (id)gLogObj;
    os_log_type_t v31 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)long long buf = 136446722;
      id v47 = "nwsc_request_start_path_watcher";
      __int16 v48 = 2114;
      long long v49 = v7;
      __int16 v50 = 2114;
      long long v51 = v8;
      _os_log_impl(&dword_1830D4000, v14, v31, "%{public}s %{public}@ tried to start path watcher on incoming request %{public}@, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_10;
  }
  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v14 = (id)gLogObj;
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v14, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)long long buf = 136446722;
      id v47 = "nwsc_request_start_path_watcher";
      __int16 v48 = 2114;
      long long v49 = v7;
      __int16 v50 = 2114;
      long long v51 = v8;
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s %{public}@ tried to start path watcher on incoming request %{public}@, no backtrace", buf, 0x20u);
    }
    goto LABEL_10;
  }
  if (v18)
  {
    *(_DWORD *)long long buf = 136446978;
    id v47 = "nwsc_request_start_path_watcher";
    __int16 v48 = 2114;
    long long v49 = v7;
    __int16 v50 = 2114;
    long long v51 = v8;
    __int16 v52 = 2082;
    long long v53 = v16;
    _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s %{public}@ tried to start path watcher on incoming request %{public}@, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v16);
  if (v13) {
    goto LABEL_12;
  }
LABEL_40:
}

void sub_183A73DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL58nw_service_connector_copy_active_connection_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  int v5 = a3;
  uint64_t v6 = v5[61];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v6 == v7) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return v6 != v7;
}

void nw_service_connector_remove_active_connection(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection *a2)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  p_uint64_t isa = (void **)&v4->super.isa;
  if (!v3)
  {
    nw_endpoint_t v19 = __nwlog_obj();
    *(_DWORD *)id v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, buf, &type)) {
      goto LABEL_23;
    }
    if (buf[0] == 17)
    {
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v21 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null serviceConnector", v47, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v27 = buf[0];
      BOOL v28 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)id v47 = 136446466;
          *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
          *(_WORD *)&v47[12] = 2082;
          *(void *)&v47[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", v47, 0x16u);
        }

        free(backtrace_string);
LABEL_23:
        if (!v8) {
          goto LABEL_25;
        }
LABEL_24:
        free(v8);
        goto LABEL_25;
      }
      if (v28)
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s called with null serviceConnector, no backtrace", v47, 0xCu);
      }
    }
    else
    {
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v34 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v34, "%{public}s called with null serviceConnector, backtrace limit exceeded", v47, 0xCu);
      }
    }
LABEL_74:

    goto LABEL_23;
  }
  if (!v3->activeConnections)
  {
    uint64_t v22 = __nwlog_obj();
    *(_DWORD *)id v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, buf, &type)) {
      goto LABEL_23;
    }
    if (buf[0] == 17)
    {
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v23 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null serviceConnector->activeConnections", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v35 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v35, "%{public}s called with null serviceConnector->activeConnections, backtrace limit exceeded", v47, 0xCu);
      }
      goto LABEL_74;
    }
    int v29 = (char *)__nw_create_backtrace_string();
    nw_parameters_t v20 = __nwlog_obj();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
    if (!v29)
    {
      if (v31)
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null serviceConnector->activeConnections, no backtrace", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)id v47 = 136446466;
      *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
      *(_WORD *)&v47[12] = 2082;
      *(void *)&v47[14] = v29;
      _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null serviceConnector->activeConnections, dumping backtrace:%{public}s", v47, 0x16u);
    }
    goto LABEL_55;
  }
  if (!v4)
  {
    BOOL v24 = __nwlog_obj();
    *(_DWORD *)id v47 = 136446210;
    *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v8, buf, &type)) {
      goto LABEL_23;
    }
    if (buf[0] == 17)
    {
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v25 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null activeConnection", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      nw_parameters_t v20 = __nwlog_obj();
      os_log_type_t v36 = buf[0];
      if (os_log_type_enabled(v20, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v36, "%{public}s called with null activeConnection, backtrace limit exceeded", v47, 0xCu);
      }
      goto LABEL_74;
    }
    int v29 = (char *)__nw_create_backtrace_string();
    nw_parameters_t v20 = __nwlog_obj();
    os_log_type_t v32 = buf[0];
    BOOL v33 = os_log_type_enabled(v20, (os_log_type_t)buf[0]);
    if (!v29)
    {
      if (v33)
      {
        *(_DWORD *)id v47 = 136446210;
        *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
        _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s called with null activeConnection, no backtrace", v47, 0xCu);
      }
      goto LABEL_74;
    }
    if (v33)
    {
      *(_DWORD *)id v47 = 136446466;
      *(void *)&v47[4] = "nw_service_connector_remove_active_connection";
      *(_WORD *)&v47[12] = 2082;
      *(void *)&v47[14] = v29;
      _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s called with null activeConnection, dumping backtrace:%{public}s", v47, 0x16u);
    }
LABEL_55:

    free(v29);
    if (!v8) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  nwsc_unique_connection_shutdown_socket(v3, v4);
  int v73 = 0;
  long long v71 = 0u;
  long long v72 = 0u;
  long long v69 = 0u;
  long long v70 = 0u;
  long long v67 = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  long long v63 = 0u;
  long long v64 = 0u;
  long long v61 = 0u;
  long long v62 = 0u;
  long long v59 = 0u;
  long long v60 = 0u;
  long long v57 = 0u;
  long long v58 = 0u;
  long long v55 = 0u;
  long long v56 = 0u;
  long long v53 = 0u;
  long long v54 = 0u;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v48 = 0u;
  memset(v47, 0, sizeof(v47));
  if (nwsc_get_identifier(p_isa[1], (uint64_t)(p_isa + 2), v47))
  {
    nw_dictionary_set_value((uint64_t)v3->activeConnections, (const char *)v47, 0);
    goto LABEL_25;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  uint64_t v7 = p_isa[1];
  *(_DWORD *)long long buf = 136446722;
  uint64_t v40 = "nw_service_connector_remove_active_connection";
  __int16 v41 = 2114;
  id v42 = v7;
  __int16 v43 = 2082;
  char v44 = p_isa + 2;
  BOOL v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (!__nwlog_fault(v8, &type, &v37)) {
    goto LABEL_23;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      id v11 = p_isa[1];
      *(_DWORD *)long long buf = 136446722;
      uint64_t v40 = "nw_service_connector_remove_active_connection";
      __int16 v41 = 2114;
      id v42 = v11;
      __int16 v43 = 2082;
      char v44 = p_isa + 2;
      _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", buf, 0x20u);
    }
LABEL_22:

    goto LABEL_23;
  }
  if (!v37)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    os_log_type_t v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      os_log_type_t v17 = p_isa[1];
      *(_DWORD *)long long buf = 136446722;
      uint64_t v40 = "nw_service_connector_remove_active_connection";
      __int16 v41 = 2114;
      id v42 = v17;
      __int16 v43 = 2082;
      char v44 = p_isa + 2;
      _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_22;
  }
  id v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v9 = (id)gLogObj;
  os_log_type_t v13 = type;
  BOOL v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      BOOL v18 = p_isa[1];
      *(_DWORD *)long long buf = 136446722;
      uint64_t v40 = "nw_service_connector_remove_active_connection";
      __int16 v41 = 2114;
      id v42 = v18;
      __int16 v43 = 2082;
      char v44 = p_isa + 2;
      _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_22;
  }
  if (v14)
  {
    os_log_type_t v15 = p_isa[1];
    *(_DWORD *)long long buf = 136446978;
    uint64_t v40 = "nw_service_connector_remove_active_connection";
    __int16 v41 = 2114;
    id v42 = v15;
    __int16 v43 = 2082;
    char v44 = p_isa + 2;
    __int16 v45 = 2082;
    char v46 = v12;
    _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_24;
  }
LABEL_25:
}

void sub_183A748C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_service_connector_copy_active_connection_with_endpoint_and_service(void *a1, void *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  int v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (!v5)
  {
    nw_endpoint_t v19 = __nwlog_obj();
    *(_DWORD *)long long v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
    nw_parameters_t v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v20, buf, &type)) {
      goto LABEL_69;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null serviceConnector", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v38, "%{public}s called with null serviceConnector, backtrace limit exceeded", v52, 0xCu);
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s called with null serviceConnector, no backtrace", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (v31)
    {
      *(_DWORD *)long long v52 = 136446466;
      *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", v52, 0x16u);
    }
LABEL_68:

    free(backtrace_string);
    goto LABEL_69;
  }
  if (!v5[11])
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)long long v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
    nw_parameters_t v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v20, buf, &type)) {
      goto LABEL_69;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v24 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null serviceConnector->activeConnections", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v39 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v39, "%{public}s called with null serviceConnector->activeConnections, backtrace limit exceeded", v52, 0xCu);
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v32 = buf[0];
    BOOL v33 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null serviceConnector->activeConnections, no backtrace", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (v33)
    {
      *(_DWORD *)long long v52 = 136446466;
      *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null serviceConnector->activeConnections, dumping backtrace:%{public}s", v52, 0x16u);
    }
    goto LABEL_68;
  }
  if (!v6)
  {
    os_log_type_t v25 = __nwlog_obj();
    *(_DWORD *)long long v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
    nw_parameters_t v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v20, buf, &type)) {
      goto LABEL_69;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null endpoint", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v40 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v40, "%{public}s called with null endpoint, backtrace limit exceeded", v52, 0xCu);
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v34 = buf[0];
    BOOL v35 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)long long v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null endpoint, no backtrace", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (v35)
    {
      *(_DWORD *)long long v52 = 136446466;
      *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null endpoint, dumping backtrace:%{public}s", v52, 0x16u);
    }
    goto LABEL_68;
  }
  if (!a3)
  {
    os_log_type_t v27 = __nwlog_obj();
    *(_DWORD *)long long v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
    nw_parameters_t v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v20, buf, &type))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v21 = __nwlog_obj();
        os_log_type_t v28 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)long long v52 = 136446210;
          *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
          _os_log_impl(&dword_1830D4000, v21, v28, "%{public}s called with null service", v52, 0xCu);
        }
LABEL_94:

        goto LABEL_69;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v21 = __nwlog_obj();
        os_log_type_t v41 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)long long v52 = 136446210;
          *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
          _os_log_impl(&dword_1830D4000, v21, v41, "%{public}s called with null service, backtrace limit exceeded", v52, 0xCu);
        }
        goto LABEL_94;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v36 = buf[0];
      BOOL v37 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)long long v52 = 136446210;
          *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
          _os_log_impl(&dword_1830D4000, v21, v36, "%{public}s called with null service, no backtrace", v52, 0xCu);
        }
        goto LABEL_94;
      }
      if (v37)
      {
        *(_DWORD *)long long v52 = 136446466;
        *(void *)&v52[4] = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
        *(_WORD *)&v52[12] = 2082;
        *(void *)&v52[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v21, v36, "%{public}s called with null service, dumping backtrace:%{public}s", v52, 0x16u);
      }
      goto LABEL_68;
    }
LABEL_69:
    if (!v20) {
      goto LABEL_27;
    }
    os_log_type_t v17 = (char *)v20;
    goto LABEL_26;
  }
  int v78 = 0;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v53 = 0u;
  memset(v52, 0, sizeof(v52));
  if (!nwsc_get_identifier(v6, a3, v52))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446722;
    __int16 v45 = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
    __int16 v46 = 2114;
    id v47 = v7;
    __int16 v48 = 2082;
    uint64_t v49 = a3;
    os_log_type_t v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v10, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446722;
          __int16 v45 = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
          __int16 v46 = 2114;
          id v47 = v7;
          __int16 v48 = 2082;
          uint64_t v49 = a3;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", buf, 0x20u);
        }
      }
      else if (v42)
      {
        os_log_type_t v13 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (v13)
        {
          if (v15)
          {
            *(_DWORD *)long long buf = 136446978;
            __int16 v45 = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
            __int16 v46 = 2114;
            id v47 = v7;
            __int16 v48 = 2082;
            uint64_t v49 = a3;
            __int16 v50 = 2082;
            long long v51 = v13;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v13);
          if (!v10) {
            goto LABEL_27;
          }
LABEL_25:
          os_log_type_t v17 = (char *)v10;
LABEL_26:
          free(v17);
          goto LABEL_27;
        }
        if (v15)
        {
          *(_DWORD *)long long buf = 136446722;
          __int16 v45 = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
          __int16 v46 = 2114;
          id v47 = v7;
          __int16 v48 = 2082;
          uint64_t v49 = a3;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446722;
          __int16 v45 = "nw_service_connector_copy_active_connection_with_endpoint_and_service";
          __int16 v46 = 2114;
          id v47 = v7;
          __int16 v48 = 2082;
          uint64_t v49 = a3;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v10)
    {
LABEL_27:
      BOOL v8 = 0;
      goto LABEL_28;
    }
    goto LABEL_25;
  }
  BOOL v8 = nw_dictionary_copy_value(v5[11], (uint64_t)v52);
LABEL_28:

  return v8;
}

void sub_183A754D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_unique_connection_shutdown_socket(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  int v5 = (int *)v4;
  if (!v3)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v14, &type, &v27)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v15 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
          __int16 v31 = 2082;
          os_log_type_t v32 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v14) {
          goto LABEL_11;
        }
        goto LABEL_46;
      }
      if (v21)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v15 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_1830D4000, v15, v25, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_44:

    goto LABEL_45;
  }
  if (!v4)
  {
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v14, &type, &v27)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null uniqueConnection", buf, 0xCu);
      }
    }
    else if (v27)
    {
      os_log_type_t v22 = (char *)__nw_create_backtrace_string();
      BOOL v15 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v15, type);
      if (v22)
      {
        if (v24)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
          __int16 v31 = 2082;
          os_log_type_t v32 = v22;
          _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s called with null uniqueConnection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v22);
        if (!v14) {
          goto LABEL_11;
        }
LABEL_46:
        free(v14);
        goto LABEL_11;
      }
      if (v24)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s called with null uniqueConnection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v15 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        _os_log_impl(&dword_1830D4000, v15, v26, "%{public}s called with null uniqueConnection, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_44;
  }
  int dupedSocketFD = v4->dupedSocketFD;
  if ((dupedSocketFD & 0x80000000) == 0)
  {
    if (shutdown(dupedSocketFD, 2))
    {
      int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136446978;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        __int16 v31 = 2114;
        os_log_type_t v32 = v3;
        __int16 v33 = 2114;
        os_log_type_t v34 = v5;
        __int16 v35 = 1024;
        int v36 = v7;
        id v9 = "%{public}s %{public}@ failed to shutdown socket on %{public}@ %{darwin.errno}d";
        os_log_type_t v10 = v8;
        os_log_type_t v11 = OS_LOG_TYPE_ERROR;
        uint32_t v12 = 38;
LABEL_9:
        _os_log_impl(&dword_1830D4000, v10, v11, v9, buf, v12);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136446722;
        os_log_type_t v30 = "nwsc_unique_connection_shutdown_socket";
        __int16 v31 = 2114;
        os_log_type_t v32 = v3;
        __int16 v33 = 2114;
        os_log_type_t v34 = v5;
        id v9 = "%{public}s %{public}@ shutdown socket on %{public}@";
        os_log_type_t v10 = v8;
        os_log_type_t v11 = OS_LOG_TYPE_DEFAULT;
        uint32_t v12 = 32;
        goto LABEL_9;
      }
    }

    close(v5[124]);
    v5[124] = -1;
  }
LABEL_11:
}

void sub_183A75AF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL31nwsc_request_start_path_watcherP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP24NWConcrete_nw_connectionb_block_invoke(void *a1, void *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (*(_DWORD *)(a1[4] + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = a1[4];
      id v6 = a1[5];
      int v20 = 136446978;
      BOOL v21 = "nwsc_request_start_path_watcher_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v5;
      __int16 v24 = 2114;
      os_log_type_t v25 = v3;
      __int16 v26 = 2114;
      char v27 = v6;
      int v7 = "%{public}s %{public}@ already cancelled, ignoring received path update %{public}@ for request %{public}@";
      BOOL v8 = v4;
      os_log_type_t v9 = OS_LOG_TYPE_ERROR;
LABEL_7:
      _os_log_impl(&dword_1830D4000, v8, v9, v7, (uint8_t *)&v20, 0x2Au);
      goto LABEL_8;
    }
    goto LABEL_8;
  }
  uint64_t v10 = a1[6];
  uint64_t v11 = *(void *)(a1[5] + 584);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (id)gLogObj;
  BOOL v12 = os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT);
  if (v11 != v10)
  {
    if (v12)
    {
      uint64_t v13 = a1[4];
      os_log_type_t v14 = a1[5];
      int v20 = 136446978;
      BOOL v21 = "nwsc_request_start_path_watcher_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v13;
      __int16 v24 = 2114;
      os_log_type_t v25 = v3;
      __int16 v26 = 2114;
      char v27 = v14;
      int v7 = "%{public}s %{public}@ ignoring received path update %{public}@ for request %{public}@";
      BOOL v8 = v4;
      os_log_type_t v9 = OS_LOG_TYPE_DEFAULT;
      goto LABEL_7;
    }
LABEL_8:

    goto LABEL_9;
  }
  if (v12)
  {
    uint64_t v15 = a1[4];
    os_log_type_t v16 = a1[5];
    int v20 = 136446978;
    BOOL v21 = "nwsc_request_start_path_watcher_block_invoke";
    __int16 v22 = 2114;
    uint64_t v23 = v15;
    __int16 v24 = 2114;
    os_log_type_t v25 = v3;
    __int16 v26 = 2114;
    char v27 = v16;
    _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ received path update %{public}@ for request %{public}@", (uint8_t *)&v20, 0x2Au);
  }

  if ((nw_path_get_status(v3) & 0xFFFFFFFD) == 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v18 = a1[4];
      nw_endpoint_t v19 = a1[5];
      int v20 = 136446978;
      BOOL v21 = "nwsc_request_start_path_watcher_block_invoke";
      __int16 v22 = 2114;
      uint64_t v23 = v18;
      __int16 v24 = 2114;
      os_log_type_t v25 = v19;
      __int16 v26 = 2114;
      char v27 = v3;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ restarting connection for request %{public}@ due to path update %{public}@", (uint8_t *)&v20, 0x2Au);
    }

    id v4 = nwsc_request_create_and_start_connection_inner(a1[4], a1[5], 0);
    goto LABEL_8;
  }
LABEL_9:
}

void sub_183A75DFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke(uint64_t a1, void *a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  BOOL v8 = a2;
  if ((nw_service_connector_verify_read_succeeded(*(void **)(a1 + 32), *(void **)(a1 + 40), *(unsigned __int8 *)(a1 + 48), 2, v8, a4, a5, "first") & 1) == 0)goto LABEL_42; {
  unsigned __int16 v38 = 0;
  }
  *(void *)os_log_type_t type = 0;
  os_log_type_t v41 = type;
  uint64_t v42 = 0x2000000000;
  uint64_t v43 = 0;
  v39[0] = 0;
  v39[1] = v39;
  v39[2] = 0x2000000000;
  v39[3] = &v38;
  if (v8)
  {
    *(void *)applier = MEMORY[0x1E4F143A8];
    *(void *)&void applier[8] = 0x40000000;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    *(void *)__int16 v45 = &unk_1E5242B60;
    *(void *)&v45[16] = v39;
    *(void *)&v45[24] = 2;
    *(void *)&v45[8] = type;
    dispatch_data_apply(v8, applier);
    uint64_t v9 = *((void *)v41 + 3);
  }
  else
  {
    uint64_t v9 = 0;
  }
  _Block_object_dispose(v39, 8);
  _Block_object_dispose(type, 8);
  if (v9 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_ERROR))
    {
      uint64_t v18 = *(void *)(a1 + 32);
      uint64_t v19 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v18;
      *(_WORD *)&applier[22] = 2048;
      *(void *)__int16 v45 = v9;
      *(_WORD *)&v45[8] = 2114;
      *(void *)&v45[10] = v19;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ first read copyout had insufficient length %zu, cancelling %{public}@", applier, 0x2Au);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v20 = (id)gLogObj;
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    BOOL v21 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v39[0]) = 0;
    if (__nwlog_fault(v21, type, v39))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (id)gLogObj;
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s first nw_dispatch_data_copyout failed", applier, 0xCu);
        }
      }
      else if (LOBYTE(v39[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (id)gLogObj;
        os_log_type_t v29 = type[0];
        BOOL v30 = os_log_type_enabled(v22, type[0]);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s first nw_dispatch_data_copyout failed, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(backtrace_string);
          if (!v21) {
            goto LABEL_41;
          }
          goto LABEL_40;
        }
        if (v30)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s first nw_dispatch_data_copyout failed, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v22 = (id)gLogObj;
        os_log_type_t v31 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v22, v31, "%{public}s first nw_dispatch_data_copyout failed, backtrace limit exceeded", applier, 0xCu);
        }
      }
    }
    if (!v21)
    {
LABEL_41:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      goto LABEL_42;
    }
LABEL_40:
    free(v21);
    goto LABEL_41;
  }
  unsigned int v10 = bswap32(v38) >> 16;
  if (*(unsigned char *)(a1 + 48)) {
    unsigned int v11 = 79;
  }
  else {
    unsigned int v11 = 42;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v12 = (id)gLogObj;
  uint64_t v13 = v12;
  if (v11 <= v10)
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_DEFAULT))
    {
      __int16 v24 = "incoming";
      if (!*(unsigned char *)(a1 + 48)) {
        __int16 v24 = "outgoing";
      }
      uint64_t v25 = *(void *)(a1 + 32);
      uint64_t v26 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136447234;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v25;
      *(_WORD *)&applier[22] = 1024;
      *(_DWORD *)__int16 v45 = v10;
      *(_WORD *)&v45[4] = 2082;
      *(void *)&v45[6] = v24;
      *(_WORD *)&v45[14] = 2114;
      *(void *)&v45[16] = v26;
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ performing second read of length %u on %{public}s connection %{public}@", applier, 0x30u);
    }

    v32[0] = MEMORY[0x1E4F143A8];
    v32[1] = 3221225472;
    v32[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_183;
    v32[3] = &unk_1E52432A0;
    char v27 = *(void **)(a1 + 40);
    id v33 = *(id *)(a1 + 32);
    id v34 = *(id *)(a1 + 40);
    char v37 = *(unsigned char *)(a1 + 48);
    __int16 v35 = v10;
    unsigned __int16 v36 = v38;
    nw_connection_receive_internal(v27, 0, v10, v10, v32);
  }
  else
  {
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v14 = "incoming";
      uint64_t v15 = *(void *)(a1 + 32);
      uint64_t v16 = *(void *)(a1 + 40);
      if (!*(unsigned char *)(a1 + 48)) {
        os_log_type_t v14 = "outgoing";
      }
      *(_DWORD *)applier = 136447490;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v15;
      *(_WORD *)&applier[22] = 1024;
      *(_DWORD *)__int16 v45 = v10;
      *(_WORD *)&v45[4] = 1024;
      *(_DWORD *)&v45[6] = v11;
      *(_WORD *)&v45[10] = 2082;
      *(void *)&v45[12] = v14;
      *(_WORD *)&v45[20] = 2114;
      *(void *)&v45[22] = v16;
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ message length %u < %u on %{public}s connection %{public}@", applier, 0x36u);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
  }
LABEL_42:
}

void sub_183A764E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t nw_service_connector_verify_read_succeeded(void *a1, void *a2, int a3, int a4, void *a5, int a6, void *a7, void *a8)
{
  uint64_t v96 = *MEMORY[0x1E4F143B8];
  uint64_t v15 = a1;
  uint64_t v16 = a2;
  data = a5;
  id v17 = a7;
  uint64_t v18 = v17;
  if (!v15)
  {
    long long v72 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned int v91 = "nw_service_connector_verify_read_succeeded";
    long long v73 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (!__nwlog_fault(v73, &type, &v88)) {
      goto LABEL_177;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v74 = __nwlog_obj();
      os_log_type_t v75 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
      goto LABEL_176;
    }
    if (!v88)
    {
      long long v74 = __nwlog_obj();
      os_log_type_t v83 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_1830D4000, v74, v83, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_176;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    long long v74 = __nwlog_obj();
    os_log_type_t v79 = type;
    BOOL v80 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v80)
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_1830D4000, v74, v79, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
      goto LABEL_176;
    }
    if (v80)
    {
      *(_DWORD *)long long buf = 136446466;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2082;
      CFErrorRef v93 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v74, v79, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_164;
  }
  if (!v16)
  {
    long long v76 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned int v91 = "nw_service_connector_verify_read_succeeded";
    long long v73 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (!__nwlog_fault(v73, &type, &v88)) {
      goto LABEL_177;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v74 = __nwlog_obj();
      os_log_type_t v77 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_1830D4000, v74, v77, "%{public}s called with null connection", buf, 0xCu);
      }
LABEL_176:

LABEL_177:
      if (v73) {
        free(v73);
      }
      goto LABEL_92;
    }
    if (!v88)
    {
      long long v74 = __nwlog_obj();
      os_log_type_t v84 = type;
      if (os_log_type_enabled(v74, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_1830D4000, v74, v84, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_176;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    long long v74 = __nwlog_obj();
    os_log_type_t v81 = type;
    BOOL v82 = os_log_type_enabled(v74, type);
    if (!backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        _os_log_impl(&dword_1830D4000, v74, v81, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_176;
    }
    if (v82)
    {
      *(_DWORD *)long long buf = 136446466;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2082;
      CFErrorRef v93 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v74, v81, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_164:

    free(backtrace_string);
    goto LABEL_177;
  }
  if (v15->state == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446722;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2114;
      CFErrorRef v93 = v15;
      __int16 v94 = 2082;
      *(void *)int v95 = a8;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring %{public}s read data", buf, 0x20u);
    }

    nw_connection_cancel(&v16->super);
    goto LABEL_92;
  }
  if (!v17)
  {
    int v21 = 0;
    if (data) {
      goto LABEL_27;
    }
LABEL_11:
    if (v21) {
      goto LABEL_27;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v22 = (id)gLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v23 = "in";
      *(_DWORD *)long long buf = 136447490;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2114;
      CFErrorRef v93 = v15;
      if (a6) {
        os_log_type_t v23 = "";
      }
      __int16 v94 = 2082;
      *(void *)int v95 = v23;
      __int16 v24 = "incoming";
      *(_WORD *)&v95[8] = 2082;
      if (!a3) {
        __int16 v24 = "outgoing";
      }
      *(void *)&v95[10] = a8;
      *(_WORD *)&v95[18] = 2082;
      *(void *)&v95[20] = v24;
      *(_WORD *)&v95[28] = 2114;
      *(void *)&v95[30] = v16;
      _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ received %{public}scomplete empty %{public}s read on %{public}s %{public}@", buf, 0x3Eu);
    }

    if ((a6 & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v25 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446722;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      if (a3) {
        uint64_t v26 = "incoming";
      }
      else {
        uint64_t v26 = "outgoing";
      }
      __int16 v92 = 2082;
      CFErrorRef v93 = (void *)v26;
      __int16 v94 = 2082;
      *(void *)int v95 = a8;
      char v27 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v88 = 0;
      if (!__nwlog_fault(v27, &type, &v88))
      {
LABEL_70:
        if (!v27) {
          goto LABEL_72;
        }
        goto LABEL_71;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v28 = (id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446722;
          unsigned int v91 = "nw_service_connector_verify_read_succeeded";
          __int16 v92 = 2082;
          CFErrorRef v93 = (void *)v26;
          __int16 v94 = 2082;
          *(void *)int v95 = a8;
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s %{public}s %{public}s read got no error no data but not complete failed", buf, 0x20u);
        }
LABEL_69:

        goto LABEL_70;
      }
      if (!v88)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v28 = (id)gLogObj;
        os_log_type_t v46 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446722;
          unsigned int v91 = "nw_service_connector_verify_read_succeeded";
          __int16 v92 = 2082;
          CFErrorRef v93 = (void *)v26;
          __int16 v94 = 2082;
          *(void *)int v95 = a8;
          _os_log_impl(&dword_1830D4000, v28, v46, "%{public}s %{public}s %{public}s read got no error no data but not complete failed, backtrace limit exceeded", buf, 0x20u);
        }
        goto LABEL_69;
      }
      id v33 = __nw_create_backtrace_string();
      if (!v33)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446722;
          unsigned int v91 = "nw_service_connector_verify_read_succeeded";
          __int16 v92 = 2082;
          CFErrorRef v93 = (void *)v26;
          __int16 v94 = 2082;
          *(void *)int v95 = a8;
          _os_log_impl(&dword_1830D4000, v28, v47, "%{public}s %{public}s %{public}s read got no error no data but not complete failed, no backtrace", buf, 0x20u);
        }
        goto LABEL_69;
      }
      id v34 = (char *)v33;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v35 = (id)gLogObj;
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v35, type))
      {
        *(_DWORD *)long long buf = 136446978;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        __int16 v92 = 2082;
        CFErrorRef v93 = (void *)v26;
        __int16 v94 = 2082;
        *(void *)int v95 = a8;
        *(_WORD *)&v95[8] = 2082;
        *(void *)&v95[10] = v34;
        _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s %{public}s %{public}s read got no error no data but not complete failed, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v34);
      if (v27) {
LABEL_71:
      }
        free(v27);
    }
LABEL_72:
    int v21 = 5;
    if (a3)
    {
LABEL_29:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v30 = (id)gLogObj;
      if (os_log_type_enabled(v30, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)long long buf = 136447234;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        __int16 v92 = 2114;
        CFErrorRef v93 = v15;
        __int16 v94 = 2082;
        *(void *)int v95 = a8;
        *(_WORD *)&v95[8] = 2114;
        *(void *)&v95[10] = v16;
        *(_WORD *)&v95[18] = 1024;
        *(_DWORD *)&v95[20] = v21;
        _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ failed %{public}s read for incoming request on %{public}@ %{darwin.errno}d", buf, 0x30u);
      }

      if ((v21 - 32) <= 0x39 && ((1 << (v21 - 32)) & 0x200000212420001) != 0
        || v21 == 5)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v31 = (id)gLogObj;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446722;
          unsigned int v91 = "nw_service_connector_verify_read_succeeded";
          __int16 v92 = 2082;
          CFErrorRef v93 = a8;
          __int16 v94 = 1024;
          *(_DWORD *)int v95 = v21;
          _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s Failed %{public}s read of incoming request %{darwin.errno}d", buf, 0x1Cu);
        }

        goto LABEL_36;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v37 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446722;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2082;
      CFErrorRef v93 = a8;
      __int16 v94 = 1024;
      *(_DWORD *)int v95 = v21;
      unsigned __int16 v38 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v88 = 0;
      if (__nwlog_fault(v38, &type, &v88))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v39 = __nwlog_obj();
          os_log_type_t v40 = type;
          if (os_log_type_enabled(v39, type))
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s Failed %{public}s read of incoming request %{darwin.errno}d", buf, 0x1Cu);
          }
        }
        else if (v88)
        {
          long long v62 = (char *)__nw_create_backtrace_string();
          os_log_type_t v39 = __nwlog_obj();
          os_log_type_t v63 = type;
          BOOL v64 = os_log_type_enabled(v39, type);
          if (v62)
          {
            if (v64)
            {
              *(_DWORD *)long long buf = 136446978;
              unsigned int v91 = "nw_service_connector_verify_read_succeeded";
              __int16 v92 = 2082;
              CFErrorRef v93 = a8;
              __int16 v94 = 1024;
              *(_DWORD *)int v95 = v21;
              *(_WORD *)&v95[4] = 2082;
              *(void *)&v95[6] = v62;
              _os_log_impl(&dword_1830D4000, v39, v63, "%{public}s Failed %{public}s read of incoming request %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
            }

            free(v62);
            goto LABEL_130;
          }
          if (v64)
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v39, v63, "%{public}s Failed %{public}s read of incoming request %{darwin.errno}d, no backtrace", buf, 0x1Cu);
          }
        }
        else
        {
          os_log_type_t v39 = __nwlog_obj();
          os_log_type_t v69 = type;
          if (os_log_type_enabled(v39, type))
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v39, v69, "%{public}s Failed %{public}s read of incoming request %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
          }
        }
      }
LABEL_130:
      if (v38) {
        free(v38);
      }
LABEL_36:
      if (v21 != 89) {
        nw_connection_cancel(&v16->super);
      }
      goto LABEL_92;
    }
LABEL_73:
    __int16 v48 = (NWConcrete_nw_unique_connection_request *)nw_service_connector_copy_active_request_for_connection(v15, v16);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v49 = (id)gLogObj;
    BOOL v50 = os_log_type_enabled(v49, OS_LOG_TYPE_ERROR);
    if (v48)
    {
      if (v50)
      {
        *(_DWORD *)long long buf = 136447234;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        __int16 v92 = 2114;
        CFErrorRef v93 = v15;
        __int16 v94 = 2082;
        *(void *)int v95 = a8;
        *(_WORD *)&v95[8] = 2114;
        *(void *)&v95[10] = v48;
        *(_WORD *)&v95[18] = 1024;
        *(_DWORD *)&v95[20] = v21;
        _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ failed %{public}s read of reply to %{public}@ %{darwin.errno}d", buf, 0x30u);
      }

      switch(v21)
      {
        case ' ':
        case '1':
        case '6':
        case '9':
        case '<':
        case 'A':
        case 'Y':
          goto LABEL_77;
        case '!':
        case '""':
        case '#':
        case '$':
        case '%':
        case '&':
        case '\'':
        case '(':
        case ')':
        case '*':
        case '+':
        case ',':
        case '-':
        case '.':
        case '/':
        case '0':
        case '2':
        case '3':
        case '4':
        case '5':
        case '7':
        case '8':
        case ':':
        case ';':
        case '=':
        case '>':
        case '?':
        case '@':
        case 'B':
        case 'C':
        case 'D':
        case 'E':
        case 'F':
        case 'G':
        case 'H':
        case 'I':
        case 'J':
        case 'K':
        case 'L':
        case 'M':
        case 'N':
        case 'O':
        case 'P':
        case 'Q':
        case 'R':
        case 'S':
        case 'T':
        case 'U':
        case 'V':
        case 'W':
        case 'X':
        case 'Z':
        case '[':
        case '\\':
        case ']':
        case '^':
        case '_':
          goto LABEL_95;
        default:
          if (v21 == 5)
          {
LABEL_77:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            long long v51 = (id)gLogObj;
            if (os_log_type_enabled(v51, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)long long buf = 136446722;
              unsigned int v91 = "nw_service_connector_verify_read_succeeded";
              __int16 v92 = 2082;
              CFErrorRef v93 = a8;
              __int16 v94 = 1024;
              *(_DWORD *)int v95 = v21;
              _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_ERROR, "%{public}s Failed %{public}s read of reply (with known request) %{darwin.errno}d", buf, 0x1Cu);
            }

            goto LABEL_80;
          }
LABEL_95:
          long long v54 = __nwlog_obj();
          *(_DWORD *)long long buf = 136446722;
          unsigned int v91 = "nw_service_connector_verify_read_succeeded";
          __int16 v92 = 2082;
          CFErrorRef v93 = a8;
          __int16 v94 = 1024;
          *(_DWORD *)int v95 = v21;
          long long v55 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v88 = 0;
          if (!__nwlog_fault(v55, &type, &v88)) {
            goto LABEL_135;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            long long v56 = __nwlog_obj();
            os_log_type_t v57 = type;
            if (os_log_type_enabled(v56, type))
            {
              *(_DWORD *)long long buf = 136446722;
              unsigned int v91 = "nw_service_connector_verify_read_succeeded";
              __int16 v92 = 2082;
              CFErrorRef v93 = a8;
              __int16 v94 = 1024;
              *(_DWORD *)int v95 = v21;
              _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s Failed %{public}s read of reply (with known request) %{darwin.errno}d", buf, 0x1Cu);
            }
LABEL_134:

            goto LABEL_135;
          }
          if (!v88)
          {
            long long v56 = __nwlog_obj();
            os_log_type_t v70 = type;
            if (os_log_type_enabled(v56, type))
            {
              *(_DWORD *)long long buf = 136446722;
              unsigned int v91 = "nw_service_connector_verify_read_succeeded";
              __int16 v92 = 2082;
              CFErrorRef v93 = a8;
              __int16 v94 = 1024;
              *(_DWORD *)int v95 = v21;
              _os_log_impl(&dword_1830D4000, v56, v70, "%{public}s Failed %{public}s read of reply (with known request) %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
            }
            goto LABEL_134;
          }
          long long v65 = (char *)__nw_create_backtrace_string();
          long long v56 = __nwlog_obj();
          os_log_type_t v85 = type;
          BOOL v66 = os_log_type_enabled(v56, type);
          if (!v65)
          {
            if (v66)
            {
              *(_DWORD *)long long buf = 136446722;
              unsigned int v91 = "nw_service_connector_verify_read_succeeded";
              __int16 v92 = 2082;
              CFErrorRef v93 = a8;
              __int16 v94 = 1024;
              *(_DWORD *)int v95 = v21;
              _os_log_impl(&dword_1830D4000, v56, v85, "%{public}s Failed %{public}s read of reply (with known request) %{darwin.errno}d, no backtrace", buf, 0x1Cu);
            }
            goto LABEL_134;
          }
          if (v66)
          {
            *(_DWORD *)long long buf = 136446978;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            *(_WORD *)&v95[4] = 2082;
            *(void *)&v95[6] = v65;
            _os_log_impl(&dword_1830D4000, v56, v85, "%{public}s Failed %{public}s read of reply (with known request) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(v65);
LABEL_135:
          if (v55) {
            free(v55);
          }
LABEL_80:
          if (nwsc_is_error_allowlisted(v18, 0))
          {
            nwsc_request_start_path_watcher(v15, v48, v16, 0);
          }
          else
          {
            nw_service_connector_cancel_request_inner(v15, v48->endpoint, (uint64_t)v48->service, v16, 0);
            nw_service_connector_trigger_request_complete_block_inner(v15, v48, 0, 0, v21);
          }
          break;
      }
LABEL_91:

LABEL_92:
      uint64_t v44 = 0;
      goto LABEL_93;
    }
    if (v50)
    {
      *(_DWORD *)long long buf = 136447234;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2114;
      CFErrorRef v93 = v15;
      __int16 v94 = 2082;
      *(void *)int v95 = a8;
      *(_WORD *)&v95[8] = 2114;
      *(void *)&v95[10] = v16;
      *(_WORD *)&v95[18] = 1024;
      *(_DWORD *)&v95[20] = v21;
      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ failed %{public}s read reply on %{public}@ %{darwin.errno}d", buf, 0x30u);
    }

    switch(v21)
    {
      case ' ':
      case '1':
      case '6':
      case '9':
      case '<':
      case 'A':
      case 'Y':
        goto LABEL_85;
      case '!':
      case '""':
      case '#':
      case '$':
      case '%':
      case '&':
      case '\'':
      case '(':
      case ')':
      case '*':
      case '+':
      case ',':
      case '-':
      case '.':
      case '/':
      case '0':
      case '2':
      case '3':
      case '4':
      case '5':
      case '7':
      case '8':
      case ':':
      case ';':
      case '=':
      case '>':
      case '?':
      case '@':
      case 'B':
      case 'C':
      case 'D':
      case 'E':
      case 'F':
      case 'G':
      case 'H':
      case 'I':
      case 'J':
      case 'K':
      case 'L':
      case 'M':
      case 'N':
      case 'O':
      case 'P':
      case 'Q':
      case 'R':
      case 'S':
      case 'T':
      case 'U':
      case 'V':
      case 'W':
      case 'X':
      case 'Z':
      case '[':
      case '\\':
      case ']':
      case '^':
      case '_':
        goto LABEL_101;
      default:
        if (v21 == 5)
        {
LABEL_85:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          long long v52 = (id)gLogObj;
          if (os_log_type_enabled(v52, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_ERROR, "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d", buf, 0x1Cu);
          }

          goto LABEL_88;
        }
LABEL_101:
        long long v58 = __nwlog_obj();
        *(_DWORD *)long long buf = 136446722;
        unsigned int v91 = "nw_service_connector_verify_read_succeeded";
        __int16 v92 = 2082;
        CFErrorRef v93 = a8;
        __int16 v94 = 1024;
        *(_DWORD *)int v95 = v21;
        long long v59 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v88 = 0;
        if (!__nwlog_fault(v59, &type, &v88)) {
          goto LABEL_143;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          long long v60 = __nwlog_obj();
          os_log_type_t v61 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d", buf, 0x1Cu);
          }
        }
        else if (v88)
        {
          long long v67 = (char *)__nw_create_backtrace_string();
          long long v60 = __nwlog_obj();
          os_log_type_t v86 = type;
          BOOL v68 = os_log_type_enabled(v60, type);
          if (v67)
          {
            if (v68)
            {
              *(_DWORD *)long long buf = 136446978;
              unsigned int v91 = "nw_service_connector_verify_read_succeeded";
              __int16 v92 = 2082;
              CFErrorRef v93 = a8;
              __int16 v94 = 1024;
              *(_DWORD *)int v95 = v21;
              *(_WORD *)&v95[4] = 2082;
              *(void *)&v95[6] = v67;
              _os_log_impl(&dword_1830D4000, v60, v86, "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
            }

            free(v67);
LABEL_143:
            if (v59) {
              free(v59);
            }
LABEL_88:
            if (v21 != 89) {
              nw_connection_cancel(&v16->super);
            }
            goto LABEL_91;
          }
          if (v68)
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v60, v86, "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d, no backtrace", buf, 0x1Cu);
          }
        }
        else
        {
          long long v60 = __nwlog_obj();
          os_log_type_t v71 = type;
          if (os_log_type_enabled(v60, type))
          {
            *(_DWORD *)long long buf = 136446722;
            unsigned int v91 = "nw_service_connector_verify_read_succeeded";
            __int16 v92 = 2082;
            CFErrorRef v93 = a8;
            __int16 v94 = 1024;
            *(_DWORD *)int v95 = v21;
            _os_log_impl(&dword_1830D4000, v60, v71, "%{public}s Failed %{public}s read of reply (did not find request) %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
          }
        }

        goto LABEL_143;
    }
  }
  id v20 = v17;
  int v21 = v20[3];

  if (!data) {
    goto LABEL_11;
  }
LABEL_27:
  if (v21)
  {
    if (a3) {
      goto LABEL_29;
    }
    goto LABEL_73;
  }
  if (data) {
    int size = dispatch_data_get_size(data);
  }
  else {
    int size = 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v41 = (id)gLogObj;
  uint64_t v42 = v41;
  if (size != a4)
  {
    if (os_log_type_enabled(v41, OS_LOG_TYPE_ERROR))
    {
      __int16 v45 = "outgoing";
      *(_DWORD *)long long buf = 136447746;
      unsigned int v91 = "nw_service_connector_verify_read_succeeded";
      __int16 v92 = 2114;
      CFErrorRef v93 = v15;
      if (a3) {
        __int16 v45 = "incoming";
      }
      __int16 v94 = 2082;
      *(void *)int v95 = a8;
      *(_WORD *)&v95[8] = 1024;
      *(_DWORD *)&v95[10] = size;
      *(_WORD *)&v95[14] = 1024;
      *(_DWORD *)&v95[16] = a4;
      *(_WORD *)&v95[20] = 2082;
      *(void *)&v95[22] = v45;
      *(_WORD *)&v95[30] = 2114;
      *(void *)&v95[32] = v16;
      _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ received %{public}s read with length %u but expected %u on %{public}s %{public}@", buf, 0x40u);
    }

    goto LABEL_72;
  }
  if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v43 = "outgoing";
    *(_DWORD *)long long buf = 136447490;
    unsigned int v91 = "nw_service_connector_verify_read_succeeded";
    __int16 v92 = 2114;
    CFErrorRef v93 = v15;
    if (a3) {
      uint64_t v43 = "incoming";
    }
    __int16 v94 = 2082;
    *(void *)int v95 = a8;
    *(_WORD *)&v95[8] = 1024;
    *(_DWORD *)&v95[10] = a4;
    *(_WORD *)&v95[14] = 2082;
    *(void *)&v95[16] = v43;
    *(_WORD *)&v95[24] = 2114;
    *(void *)&v95[26] = v16;
    _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ received %{public}s read with length %u on %{public}s %{public}@", buf, 0x3Au);
  }

  uint64_t v44 = 1;
LABEL_93:

  return v44;
}

void sub_183A77CB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_183(uint64_t a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v269 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a2;
  id v220 = a3;
  id v10 = a5;
  if ((nw_service_connector_verify_read_succeeded(*(void **)(a1 + 32), *(void **)(a1 + 40), *(unsigned __int8 *)(a1 + 52), *(unsigned __int16 *)(a1 + 48), v9, a4, v10, "second") & 1) == 0)goto LABEL_271; {
  if (!*(unsigned char *)(a1 + 52))
  }
  {
    int v219 = (char *)nw_service_connector_copy_active_request_for_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), *(NWConcrete_nw_connection **)(a1 + 40));
    memset(__dst, 0, 44);
    *(void *)applier = 0;
    *(void *)&void applier[8] = applier;
    *(void *)&applier[16] = 0x2000000000;
    *(void *)&unsigned char applier[24] = 0;
    *(void *)&long long buffer = 0;
    *((void *)&buffer + 1) = &buffer;
    *(void *)&long long v247 = 0x2000000000;
    *((void *)&v247 + 1) = __dst[0].sa_data;
    if (v9)
    {
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 0x40000000;
      *(void *)&buf[16] = __nw_dispatch_data_copyout_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E5242B60;
      v250[2] = 42;
      v250[0] = applier;
      v250[1] = &buffer;
      dispatch_data_apply(v9, buf);
      unint64_t v13 = *(void *)(*(void *)&applier[8] + 24);
    }
    else
    {
      unint64_t v13 = 0;
    }
    _Block_object_dispose(&buffer, 8);
    _Block_object_dispose(applier, 8);
    if (*(unsigned __int16 *)(a1 + 48) >= 0x2Au) {
      uint64_t v29 = 42;
    }
    else {
      uint64_t v29 = *(unsigned __int16 *)(a1 + 48);
    }
    if (v13 == v29)
    {
      char v216 = __dst[0].sa_data[0];
      unint64_t v30 = bswap64(*(unint64_t *)&__dst[0].sa_data[2]);
      long long v231 = 0u;
      long long v230 = 0u;
      if (v13 >= 0x2A)
      {
        long long v230 = *(_OWORD *)&__dst[0].sa_data[10];
        long long v231 = *(_OWORD *)&__dst[1].sa_data[10];
      }
      os_log_type_t v31 = *(void **)(a1 + 32);
      nw_endpoint_t v32 = nw_connection_copy_endpoint(*(nw_connection_t *)(a1 + 40));
      id v33 = v31;
      id v34 = v32;
      __int16 v35 = v34;
      unint64_t v218 = v30;
      if (v33)
      {
        if (*((void *)v33 + 13))
        {
          if (v34)
          {
            int v268 = 0;
            long long v266 = 0u;
            memset(v267, 0, sizeof(v267));
            long long v264 = 0u;
            long long v265 = 0u;
            long long v262 = 0u;
            long long v263 = 0u;
            long long v260 = 0u;
            long long v261 = 0u;
            long long v258 = 0u;
            long long v259 = 0u;
            long long v256 = 0u;
            long long v257 = 0u;
            long long v254 = 0u;
            long long v255 = 0u;
            long long v252 = 0u;
            long long v253 = 0u;
            long long v251 = 0u;
            memset(v250, 0, sizeof(v250));
            memset(buf, 0, sizeof(buf));
            if (nwsc_get_endpoint_identifier(v34, (uint64_t)buf))
            {
              os_log_type_t v36 = xpc_dictionary_get_value(*((xpc_object_t *)v33 + 13), (const char *)buf);
              id v37 = v36;
              uint64_t v248 = 0;
              long long buffer = 0u;
              long long v247 = 0u;
              if (!v36 || xpc_data_get_bytes(v36, &buffer, 0, 0x28uLL) >= 0x28) {
                goto LABEL_188;
              }
              __nwlog_obj();
              os_log_type_t v39 = v38 = v35;
              *(_DWORD *)applier = 136446210;
              *(void *)&applier[4] = "nwsc_save_remote_pub_key";
              os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();

              __int16 v35 = v38;
              type[0] = OS_LOG_TYPE_ERROR;
              char v229 = 0;
              if (__nwlog_fault(v40, type, &v229))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  os_log_type_t v41 = __nwlog_obj();
                  os_log_type_t v42 = type[0];
                  if (os_log_type_enabled(v41, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s Insufficient length in remotePubKeys", applier, 0xCu);
                  }
                }
                else
                {
                  if (v229)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    int v104 = __nwlog_obj();
                    os_log_type_t v214 = type[0];
                    BOOL v105 = os_log_type_enabled(v104, type[0]);
                    if (backtrace_string)
                    {
                      if (v105)
                      {
                        *(_DWORD *)applier = 136446466;
                        *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                        *(_WORD *)&applier[12] = 2082;
                        *(void *)&applier[14] = backtrace_string;
                        _os_log_impl(&dword_1830D4000, v104, v214, "%{public}s Insufficient length in remotePubKeys, dumping backtrace:%{public}s", applier, 0x16u);
                      }

                      free(backtrace_string);
                    }
                    else
                    {
                      if (v105)
                      {
                        *(_DWORD *)applier = 136446210;
                        *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                        _os_log_impl(&dword_1830D4000, v104, v214, "%{public}s Insufficient length in remotePubKeys, no backtrace", applier, 0xCu);
                      }
                    }
                    goto LABEL_185;
                  }
                  os_log_type_t v41 = __nwlog_obj();
                  os_log_type_t v128 = type[0];
                  if (os_log_type_enabled(v41, type[0]))
                  {
                    *(_DWORD *)applier = 136446210;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    _os_log_impl(&dword_1830D4000, v41, v128, "%{public}s Insufficient length in remotePubKeys, backtrace limit exceeded", applier, 0xCu);
                  }
                }
              }
LABEL_185:
              if (v40) {
                free(v40);
              }
              *(void *)&long long buffer = 0;
LABEL_188:
              int v138 = cc_cmp_safe();
              int v139 = v138;
              if ((unint64_t)buffer > v218)
              {
                if (v138)
                {
                  int v140 = __nwlog_obj();
                  if (os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)applier = 136449282;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    *(_WORD *)&applier[12] = 2114;
                    *(void *)&applier[14] = v33;
                    *(_WORD *)&applier[22] = 2048;
                    *(void *)&unsigned char applier[24] = v218;
                    *(_WORD *)&applier[32] = 1024;
                    *(_DWORD *)&applier[34] = v230;
                    *(_WORD *)&applier[38] = 1024;
                    *(_DWORD *)&applier[40] = BYTE1(v230);
                    *(_WORD *)&applier[44] = 1024;
                    *(_DWORD *)&applier[46] = BYTE2(v230);
                    *(_WORD *)&applier[50] = 1024;
                    *(_DWORD *)&applier[52] = BYTE3(v230);
                    *(_WORD *)&applier[56] = 2048;
                    uint64_t v237 = buffer;
                    __int16 v238 = 1024;
                    *(_DWORD *)int v239 = BYTE8(buffer);
                    *(_WORD *)&v239[4] = 1024;
                    *(_DWORD *)&v239[6] = BYTE9(buffer);
                    __int16 v240 = 1024;
                    int v241 = BYTE10(buffer);
                    __int16 v242 = 1024;
                    int v243 = BYTE11(buffer);
                    __int16 v244 = 2114;
                    unsigned int v245 = v35;
                    _os_log_impl(&dword_1830D4000, v140, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ ignoring received seq %llu pubKey %02x%02x%02x%02x previous seq %llu %02x%02x%02x%02x for %{public}@", applier, 0x64u);
                  }
                }
                goto LABEL_200;
              }
              int v141 = __nwlog_obj();
              BOOL v142 = os_log_type_enabled(v141, OS_LOG_TYPE_DEFAULT);
              if (v139)
              {
                if (v142)
                {
                  *(_DWORD *)applier = 136449282;
                  *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                  *(_WORD *)&applier[12] = 2114;
                  *(void *)&applier[14] = v33;
                  *(_WORD *)&applier[22] = 2048;
                  *(void *)&unsigned char applier[24] = v218;
                  *(_WORD *)&applier[32] = 1024;
                  *(_DWORD *)&applier[34] = v230;
                  *(_WORD *)&applier[38] = 1024;
                  *(_DWORD *)&applier[40] = BYTE1(v230);
                  *(_WORD *)&applier[44] = 1024;
                  *(_DWORD *)&applier[46] = BYTE2(v230);
                  *(_WORD *)&applier[50] = 1024;
                  *(_DWORD *)&applier[52] = BYTE3(v230);
                  *(_WORD *)&applier[56] = 2048;
                  uint64_t v237 = buffer;
                  __int16 v238 = 1024;
                  *(_DWORD *)int v239 = BYTE8(buffer);
                  *(_WORD *)&v239[4] = 1024;
                  *(_DWORD *)&v239[6] = BYTE9(buffer);
                  __int16 v240 = 1024;
                  int v241 = BYTE10(buffer);
                  __int16 v242 = 1024;
                  int v243 = BYTE11(buffer);
                  __int16 v244 = 2114;
                  unsigned int v245 = v35;
                  int v143 = "%{public}s %{public}@ saving different received seq %llu pubKey %02x%02x%02x%02x previous seq %"
                         "llu %02x%02x%02x%02x for %{public}@";
                  unsigned int v144 = v141;
                  uint32_t v145 = 100;
LABEL_198:
                  _os_log_impl(&dword_1830D4000, v144, OS_LOG_TYPE_DEFAULT, v143, applier, v145);
                }
              }
              else if (v142)
              {
                *(_DWORD *)applier = 136448258;
                *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                *(_WORD *)&applier[12] = 2114;
                *(void *)&applier[14] = v33;
                *(_WORD *)&applier[22] = 2048;
                *(void *)&unsigned char applier[24] = v218;
                *(_WORD *)&applier[32] = 1024;
                *(_DWORD *)&applier[34] = v230;
                *(_WORD *)&applier[38] = 1024;
                *(_DWORD *)&applier[40] = BYTE1(v230);
                *(_WORD *)&applier[44] = 1024;
                *(_DWORD *)&applier[46] = BYTE2(v230);
                *(_WORD *)&applier[50] = 1024;
                *(_DWORD *)&applier[52] = BYTE3(v230);
                *(_WORD *)&applier[56] = 2048;
                uint64_t v237 = buffer;
                __int16 v238 = 2114;
                *(void *)int v239 = v35;
                int v143 = "%{public}s %{public}@ saving same pubKey received seq %llu pubKey %02x%02x%02x%02x previous seq %"
                       "llu for %{public}@";
                unsigned int v144 = v141;
                uint32_t v145 = 76;
                goto LABEL_198;
              }

              int v146 = v35;
              *(void *)os_log_type_t type = v218;
              long long v234 = v230;
              long long v235 = v231;
              xpc_dictionary_set_data(*((xpc_object_t *)v33 + 13), (const char *)buf, type, 0x28uLL);
              int v147 = (atomic_uchar *)*((void *)v33 + 9);
              *(void *)applier = MEMORY[0x1E4F143A8];
              *(void *)&void applier[8] = 3221225472;
              *(void *)&applier[16] = ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke;
              *(void *)&unsigned char applier[24] = &unk_1E5243340;
              *(void *)&applier[32] = v33;
              *(void *)&applier[40] = v218;
              nw_array_apply(v147, (uint64_t)applier);

              __int16 v35 = v146;
LABEL_200:

              goto LABEL_201;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            long long v65 = v35;
            id v66 = (id)gLogObj;
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nwsc_save_remote_pub_key";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v65;
            long long v67 = (char *)_os_log_send_and_compose_impl();

            __int16 v35 = v65;
            LOBYTE(buffer) = 16;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v67, &buffer, type)) {
              goto LABEL_144;
            }
            if (buffer == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v68 = (id)gLogObj;
              os_log_type_t v69 = buffer;
              if (os_log_type_enabled(v68, (os_log_type_t)buffer))
              {
                *(_DWORD *)applier = 136446466;
                *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                *(_WORD *)&applier[12] = 2114;
                *(void *)&applier[14] = v65;
                _os_log_impl(&dword_1830D4000, v68, v69, "%{public}s Could not get identifier for endpoint %{public}@", applier, 0x16u);
              }
            }
            else
            {
              if (type[0])
              {
                long long v76 = (char *)__nw_create_backtrace_string();
                os_log_type_t v77 = __nwlog_obj();
                os_log_type_t v78 = buffer;
                BOOL v79 = os_log_type_enabled(v77, (os_log_type_t)buffer);
                if (v76)
                {
                  if (v79)
                  {
                    *(_DWORD *)applier = 136446722;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    *(_WORD *)&applier[12] = 2114;
                    *(void *)&applier[14] = v35;
                    *(_WORD *)&applier[22] = 2082;
                    *(void *)&unsigned char applier[24] = v76;
                    _os_log_impl(&dword_1830D4000, v77, v78, "%{public}s Could not get identifier for endpoint %{public}@, dumping backtrace:%{public}s", applier, 0x20u);
                  }

                  free(v76);
                }
                else
                {
                  if (v79)
                  {
                    *(_DWORD *)applier = 136446466;
                    *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                    *(_WORD *)&applier[12] = 2114;
                    *(void *)&applier[14] = v35;
                    _os_log_impl(&dword_1830D4000, v77, v78, "%{public}s Could not get identifier for endpoint %{public}@, no backtrace", applier, 0x16u);
                  }
                }
                goto LABEL_144;
              }
              BOOL v68 = __nwlog_obj();
              os_log_type_t v98 = buffer;
              if (os_log_type_enabled(v68, (os_log_type_t)buffer))
              {
                *(_DWORD *)applier = 136446466;
                *(void *)&applier[4] = "nwsc_save_remote_pub_key";
                *(_WORD *)&applier[12] = 2114;
                *(void *)&applier[14] = v65;
                _os_log_impl(&dword_1830D4000, v68, v98, "%{public}s Could not get identifier for endpoint %{public}@, backtrace limit exceeded", applier, 0x16u);
              }
            }

LABEL_144:
            if (v67) {
              free(v67);
            }
LABEL_201:

            if (v219)
            {
              int v148 = *(NSObject **)(a1 + 40);
              if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
                dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
              }
              unsigned int v149 = (id)g_tcp_definition;
              nw_protocol_metadata_t v150 = nw_connection_copy_protocol_metadata(v148, v149);

              if (nw_context_copy_implicit_context::onceToken != -1) {
                dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
              }
              id v151 = (id)nw_context_copy_implicit_context::implicit_context;
              v225[0] = MEMORY[0x1E4F143A8];
              v225[1] = 3221225472;
              v225[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_185;
              v225[3] = &unk_1E5249868;
              id v226 = *(id *)(a1 + 32);
              int v152 = v219;
              int v227 = v152;
              int v153 = v150;
              int v228 = v153;
              nw_queue_context_async_if_needed(v151, v225);

              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              unsigned int v154 = (id)gLogObj;
              BOOL v155 = os_log_type_enabled(v154, OS_LOG_TYPE_DEFAULT);
              if (v216 < 0)
              {
                if (v155)
                {
                  uint64_t v163 = *(void *)(a1 + 32);
                  *(_DWORD *)long long buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2114;
                  *(void *)&buf[14] = v163;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&unsigned char buf[24] = v152;
                  LOWORD(v250[0]) = 2048;
                  *(void *)((char *)v250 + 2) = v218;
                  _os_log_impl(&dword_1830D4000, v154, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ outgoing request %{public}@ was accepted by peer with reply seq %llu", buf, 0x2Au);
                }

                v152->sequenceNumber = v218;
                int v164 = *(void **)(a1 + 32);
                int v165 = *(void **)(a1 + 40);
                v221[0] = MEMORY[0x1E4F143A8];
                v221[1] = 3221225472;
                v221[2] = ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_186;
                v221[3] = &unk_1E5243278;
                id v222 = v164;
                int v223 = v152;
                id v224 = *(id *)(a1 + 40);
                nw_service_connector_accept_connection_for_request(v222, v165, v223, v221);
              }
              else
              {
                if (v155)
                {
                  int v156 = "";
                  uint64_t v157 = *(void *)(a1 + 32);
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_DWORD *)long long buf = 136447234;
                  if ((v216 & 0x40) == 0) {
                    int v156 = "not ";
                  }
                  *(_WORD *)&unsigned char buf[12] = 2114;
                  *(void *)&buf[14] = v157;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&unsigned char buf[24] = v152;
                  LOWORD(v250[0]) = 2082;
                  *(void *)((char *)v250 + 2) = v156;
                  WORD1(v250[1]) = 2048;
                  *(void *)((char *)&v250[1] + 4) = v218;
                  _os_log_impl(&dword_1830D4000, v154, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ outgoing request %{public}@ was rejected (%{public}sby policy) by peer with reply seq %llu", buf, 0x34u);
                }

                int v158 = *(NWConcrete_nw_service_connector **)(a1 + 32);
                if ((v216 & 0x40) != 0)
                {
                  nw_service_connector_cancel_request_inner(v158, v152->endpoint, (uint64_t)v152->service, *(void **)(a1 + 40), 0);
                  nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v152, 0, 0, 61);
                }
                else
                {
                  nwsc_request_start_path_watcher(v158, v152, *(NWConcrete_nw_connection **)(a1 + 40), 0);
                }
              }

              goto LABEL_269;
            }
            int v159 = __nwlog_obj();
            unsigned int v160 = v159;
            if ((v216 & 0x80) == 0)
            {
              if (os_log_type_enabled(v159, OS_LOG_TYPE_DEFAULT))
              {
                uint64_t v161 = *(void *)(a1 + 32);
                uint64_t v162 = *(void *)(a1 + 40);
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                *(_WORD *)&unsigned char buf[12] = 2114;
                *(void *)&buf[14] = v161;
                *(_WORD *)&buf[22] = 2114;
                *(void *)&unsigned char buf[24] = v162;
                LOWORD(v250[0]) = 2048;
                *(void *)((char *)v250 + 2) = v218;
                _os_log_impl(&dword_1830D4000, v160, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, denied with seq %llu", buf, 0x2Au);
              }

LABEL_240:
              BOOL v64 = 0;
              nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
              goto LABEL_270;
            }
            uint64_t v166 = *(void *)(a1 + 32);
            uint64_t v167 = *(void *)(a1 + 40);
            *(_DWORD *)long long buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v166;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&unsigned char buf[24] = v167;
            LOWORD(v250[0]) = 2048;
            *(void *)((char *)v250 + 2) = v218;
            int v168 = (char *)_os_log_send_and_compose_impl();

            applier[0] = 16;
            LOBYTE(buffer) = 0;
            if (__nwlog_fault(v168, applier, &buffer))
            {
              if (applier[0] == 17)
              {
                int v169 = __nwlog_obj();
                os_log_type_t v170 = applier[0];
                if (os_log_type_enabled(v169, (os_log_type_t)applier[0]))
                {
                  uint64_t v171 = *(void *)(a1 + 32);
                  uint64_t v172 = *(void *)(a1 + 40);
                  *(_DWORD *)long long buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2114;
                  *(void *)&buf[14] = v171;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&unsigned char buf[24] = v172;
                  LOWORD(v250[0]) = 2048;
                  *(void *)((char *)v250 + 2) = v218;
                  _os_log_impl(&dword_1830D4000, v169, v170, "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %llu", buf, 0x2Au);
                }
              }
              else if ((_BYTE)buffer)
              {
                int v173 = (char *)__nw_create_backtrace_string();
                int v169 = __nwlog_obj();
                os_log_type_t v174 = applier[0];
                BOOL v175 = os_log_type_enabled(v169, (os_log_type_t)applier[0]);
                if (v173)
                {
                  if (v175)
                  {
                    uint64_t v176 = *(void *)(a1 + 32);
                    uint64_t v177 = *(void *)(a1 + 40);
                    *(_DWORD *)long long buf = 136447234;
                    *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 2114;
                    *(void *)&buf[14] = v176;
                    *(_WORD *)&buf[22] = 2114;
                    *(void *)&unsigned char buf[24] = v177;
                    LOWORD(v250[0]) = 2048;
                    *(void *)((char *)v250 + 2) = v218;
                    WORD1(v250[1]) = 2082;
                    *(void *)((char *)&v250[1] + 4) = v173;
                    _os_log_impl(&dword_1830D4000, v169, v174, "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %llu, dumping backtrace:%{public}s", buf, 0x34u);
                  }

                  free(v173);
                  goto LABEL_238;
                }
                if (v175)
                {
                  uint64_t v181 = *(void *)(a1 + 32);
                  uint64_t v182 = *(void *)(a1 + 40);
                  *(_DWORD *)long long buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2114;
                  *(void *)&buf[14] = v181;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&unsigned char buf[24] = v182;
                  LOWORD(v250[0]) = 2048;
                  *(void *)((char *)v250 + 2) = v218;
                  _os_log_impl(&dword_1830D4000, v169, v174, "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %llu, no backtrace", buf, 0x2Au);
                }
              }
              else
              {
                int v169 = __nwlog_obj();
                os_log_type_t v178 = applier[0];
                if (os_log_type_enabled(v169, (os_log_type_t)applier[0]))
                {
                  uint64_t v179 = *(void *)(a1 + 32);
                  uint64_t v180 = *(void *)(a1 + 40);
                  *(_DWORD *)long long buf = 136446978;
                  *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
                  *(_WORD *)&unsigned char buf[12] = 2114;
                  *(void *)&buf[14] = v179;
                  *(_WORD *)&buf[22] = 2114;
                  *(void *)&unsigned char buf[24] = v180;
                  LOWORD(v250[0]) = 2048;
                  *(void *)((char *)v250 + 2) = v218;
                  _os_log_impl(&dword_1830D4000, v169, v178, "%{public}s %{public}@ did not find a matching outgoing request for %{public}@, accepted with seq %llu, backtrace limit exceeded", buf, 0x2Au);
                }
              }
            }
LABEL_238:
            if (v168) {
              free(v168);
            }
            goto LABEL_240;
          }
          __nwlog_obj();
          int v198 = v215 = 0;
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
          int v193 = (void *)_os_log_send_and_compose_impl();

          applier[0] = 16;
          LOBYTE(buffer) = 0;
          if (!__nwlog_fault((const char *)v193, applier, &buffer))
          {
LABEL_321:
            if (!v193)
            {
LABEL_323:
              __int16 v35 = v215;
              goto LABEL_201;
            }
LABEL_322:
            free(v193);
            goto LABEL_323;
          }
          if (applier[0] == 17)
          {
            int v194 = __nwlog_obj();
            os_log_type_t v199 = applier[0];
            if (os_log_type_enabled(v194, (os_log_type_t)applier[0]))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
              _os_log_impl(&dword_1830D4000, v194, v199, "%{public}s called with null endpoint", buf, 0xCu);
            }
LABEL_311:

            goto LABEL_321;
          }
          if (!(_BYTE)buffer)
          {
            int v194 = __nwlog_obj();
            os_log_type_t v211 = applier[0];
            if (os_log_type_enabled(v194, (os_log_type_t)applier[0]))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
              _os_log_impl(&dword_1830D4000, v194, v211, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_311;
          }
          int v206 = (char *)__nw_create_backtrace_string();
          int v201 = __nwlog_obj();
          os_log_type_t v207 = applier[0];
          BOOL v208 = os_log_type_enabled(v201, (os_log_type_t)applier[0]);
          if (v206)
          {
            if (v208)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v206;
              _os_log_impl(&dword_1830D4000, v201, v207, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v206);
            goto LABEL_321;
          }
          if (v208)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v201, v207, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
          }
LABEL_320:

          goto LABEL_321;
        }
        __nwlog_obj();
        int v196 = v215 = v35;
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
        int v193 = (void *)_os_log_send_and_compose_impl();

        applier[0] = 16;
        LOBYTE(buffer) = 0;
        if (!__nwlog_fault((const char *)v193, applier, &buffer)) {
          goto LABEL_321;
        }
        if (applier[0] == 17)
        {
          int v194 = __nwlog_obj();
          os_log_type_t v197 = applier[0];
          if (os_log_type_enabled(v194, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v194, v197, "%{public}s called with null serviceConnector->remotePubKeys", buf, 0xCu);
          }
          goto LABEL_311;
        }
        if (!(_BYTE)buffer)
        {
          int v194 = __nwlog_obj();
          os_log_type_t v210 = applier[0];
          if (os_log_type_enabled(v194, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v194, v210, "%{public}s called with null serviceConnector->remotePubKeys, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_311;
        }
        int v200 = (char *)__nw_create_backtrace_string();
        int v201 = __nwlog_obj();
        os_log_type_t v204 = applier[0];
        BOOL v205 = os_log_type_enabled(v201, (os_log_type_t)applier[0]);
        if (!v200)
        {
          if (v205)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v201, v204, "%{public}s called with null serviceConnector->remotePubKeys, no backtrace", buf, 0xCu);
          }
          goto LABEL_320;
        }
        if (v205)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v200;
          _os_log_impl(&dword_1830D4000, v201, v204, "%{public}s called with null serviceConnector->remotePubKeys, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        __nwlog_obj();
        unsigned int v192 = v215 = v35;
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
        int v193 = (void *)_os_log_send_and_compose_impl();

        applier[0] = 16;
        LOBYTE(buffer) = 0;
        if (!__nwlog_fault((const char *)v193, applier, &buffer)) {
          goto LABEL_321;
        }
        if (applier[0] == 17)
        {
          int v194 = __nwlog_obj();
          os_log_type_t v195 = applier[0];
          if (os_log_type_enabled(v194, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v194, v195, "%{public}s called with null serviceConnector", buf, 0xCu);
          }
          goto LABEL_311;
        }
        if (!(_BYTE)buffer)
        {
          int v194 = __nwlog_obj();
          os_log_type_t v209 = applier[0];
          if (os_log_type_enabled(v194, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v194, v209, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_311;
        }
        int v200 = (char *)__nw_create_backtrace_string();
        int v201 = __nwlog_obj();
        os_log_type_t v202 = applier[0];
        BOOL v203 = os_log_type_enabled(v201, (os_log_type_t)applier[0]);
        if (!v200)
        {
          if (v203)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v201, v202, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
          }
          goto LABEL_320;
        }
        if (v203)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v200;
          _os_log_impl(&dword_1830D4000, v201, v202, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }

      free(v200);
      if (!v193) {
        goto LABEL_323;
      }
      goto LABEL_322;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v43 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
    uint64_t v44 = (char *)_os_log_send_and_compose_impl();

    applier[0] = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v44, applier, &buffer))
    {
      if (applier[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v45 = (id)gLogObj;
        os_log_type_t v46 = applier[0];
        if (os_log_type_enabled(v45, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s nw_dispatch_data_copyout failed", buf, 0xCu);
        }
      }
      else if ((_BYTE)buffer)
      {
        os_log_type_t v61 = (char *)__nw_create_backtrace_string();
        __int16 v45 = __nwlog_obj();
        os_log_type_t v62 = applier[0];
        BOOL v63 = os_log_type_enabled(v45, (os_log_type_t)applier[0]);
        if (v61)
        {
          if (v63)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v61;
            _os_log_impl(&dword_1830D4000, v45, v62, "%{public}s nw_dispatch_data_copyout failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v61);
          BOOL v64 = v219;
          if (!v44) {
            goto LABEL_108;
          }
          goto LABEL_107;
        }
        if (v63)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v45, v62, "%{public}s nw_dispatch_data_copyout failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v45 = __nwlog_obj();
        os_log_type_t v85 = applier[0];
        if (os_log_type_enabled(v45, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v45, v85, "%{public}s nw_dispatch_data_copyout failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    BOOL v64 = v219;
    if (!v44)
    {
LABEL_108:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      goto LABEL_270;
    }
LABEL_107:
    free(v44);
    goto LABEL_108;
  }
  unsigned int v11 = objc_alloc_init(NWConcrete_nw_unique_connection_request);
  int v219 = (char *)v11;
  if (!v11)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();

    applier[0] = 16;
    __dst[0].os_log_type_t sa_len = 0;
    if (__nwlog_fault(v15, applier, __dst))
    {
      if (applier[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v16 = (id)gLogObj;
        os_log_type_t v17 = applier[0];
        if (os_log_type_enabled(v16, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s [nw_unique_connection_request init:] failed", buf, 0xCu);
        }
      }
      else if (__dst[0].sa_len)
      {
        os_log_type_t v47 = __nw_create_backtrace_string();
        if (v47)
        {
          __int16 v48 = (char *)v47;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v49 = (id)gLogObj;
          os_log_type_t v50 = applier[0];
          if (os_log_type_enabled(v49, (os_log_type_t)applier[0]))
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v48;
            _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s [nw_unique_connection_request init:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v48);
          if (!v15) {
            goto LABEL_102;
          }
          goto LABEL_101;
        }
        uint64_t v16 = __nwlog_obj();
        os_log_type_t v86 = applier[0];
        if (os_log_type_enabled(v16, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v16, v86, "%{public}s [nw_unique_connection_request init:] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v16 = (id)gLogObj;
        os_log_type_t v80 = applier[0];
        if (os_log_type_enabled(v16, (os_log_type_t)applier[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v16, v80, "%{public}s [nw_unique_connection_request init:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v15)
    {
LABEL_102:
      nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
      BOOL v64 = 0;
LABEL_270:

LABEL_271:
      return;
    }
LABEL_101:
    free(v15);
    goto LABEL_102;
  }
  *((unsigned char *)v11 + 616) |= 1u;
  long long v266 = 0u;
  memset(v267, 0, 28);
  long long v264 = 0u;
  long long v265 = 0u;
  long long v262 = 0u;
  long long v263 = 0u;
  long long v260 = 0u;
  long long v261 = 0u;
  long long v258 = 0u;
  long long v259 = 0u;
  long long v256 = 0u;
  long long v257 = 0u;
  long long v254 = 0u;
  long long v255 = 0u;
  long long v252 = 0u;
  long long v253 = 0u;
  long long v251 = 0u;
  memset(v250, 0, sizeof(v250));
  memset(buf, 0, sizeof(buf));
  *(void *)&__dst[0].os_log_type_t sa_len = 0;
  *(void *)&__dst[0].sa_data[6] = __dst;
  *(void *)&__dst[1].os_log_type_t sa_len = 0x2000000000;
  *(void *)&__dst[1].sa_data[6] = 0;
  *(void *)&long long buffer = 0;
  *((void *)&buffer + 1) = &buffer;
  *(void *)&long long v247 = 0x2000000000;
  *((void *)&v247 + 1) = &buf[2];
  if (v9)
  {
    *(void *)applier = MEMORY[0x1E4F143A8];
    *(void *)&void applier[8] = 0x40000000;
    *(void *)&applier[16] = __nw_dispatch_data_copyout_block_invoke;
    *(void *)&unsigned char applier[24] = &unk_1E5242B60;
    *(void *)&applier[40] = &buffer;
    *(void *)&applier[48] = 346;
    *(void *)&applier[32] = __dst;
    dispatch_data_apply(v9, applier);
    unint64_t v12 = *(void *)(*(void *)&__dst[0].sa_data[6] + 24);
  }
  else
  {
    unint64_t v12 = 0;
  }
  _Block_object_dispose(&buffer, 8);
  _Block_object_dispose(__dst, 8);
  if (v12 <= 0x4E)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = (id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      uint64_t v19 = *(void *)(a1 + 32);
      uint64_t v20 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v19;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&unsigned char applier[24] = v12;
      *(_WORD *)&applier[32] = 2114;
      *(void *)&applier[34] = v20;
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ second read copyout insufficient req length %zu, cancelling %{public}@", applier, 0x2Au);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    goto LABEL_269;
  }
  __int16 v21 = *(_WORD *)&buf[2];
  __int16 v22 = nw_connection_copy_endpoint(*(nw_connection_t *)(a1 + 40));
  if (nw_endpoint_get_type(v22) != nw_endpoint_type_address)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v51 = (id)gLogObj;
    uint64_t v52 = *(void *)(a1 + 32);
    nw_endpoint_type_t v53 = nw_endpoint_get_type(v22);
    uint64_t v54 = *(void *)(a1 + 40);
    *(_DWORD *)applier = 136447234;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    *(_WORD *)&applier[12] = 2114;
    *(void *)&applier[14] = v52;
    *(_WORD *)&applier[22] = 2114;
    *(void *)&unsigned char applier[24] = v22;
    *(_WORD *)&applier[32] = 1024;
    *(_DWORD *)&applier[34] = v53;
    *(_WORD *)&applier[38] = 2114;
    *(void *)&applier[40] = v54;
    long long v55 = (char *)_os_log_send_and_compose_impl();

    __dst[0].os_log_type_t sa_len = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v55, __dst, &buffer))
    {
      if (__dst[0].sa_len == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v56 = (id)gLogObj;
        os_log_type_t sa_len = __dst[0].sa_len;
        if (os_log_type_enabled(v56, (os_log_type_t)__dst[0].sa_len))
        {
          uint64_t v58 = *(void *)(a1 + 32);
          nw_endpoint_type_t v59 = nw_endpoint_get_type(v22);
          uint64_t v60 = *(void *)(a1 + 40);
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v58;
          *(_WORD *)&applier[22] = 2114;
          *(void *)&unsigned char applier[24] = v22;
          *(_WORD *)&applier[32] = 1024;
          *(_DWORD *)&applier[34] = v59;
          *(_WORD *)&applier[38] = 2114;
          *(void *)&applier[40] = v60;
          _os_log_impl(&dword_1830D4000, v56, sa_len, "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@", applier, 0x30u);
        }
      }
      else if ((_BYTE)buffer)
      {
        os_log_type_t v70 = (char *)__nw_create_backtrace_string();
        long long v56 = __nwlog_obj();
        os_log_type_t v71 = __dst[0].sa_len;
        BOOL v72 = os_log_type_enabled(v56, (os_log_type_t)__dst[0].sa_len);
        if (v70)
        {
          if (v72)
          {
            uint64_t v73 = *(void *)(a1 + 32);
            nw_endpoint_type_t v74 = nw_endpoint_get_type(v22);
            uint64_t v75 = *(void *)(a1 + 40);
            *(_DWORD *)applier = 136447490;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2114;
            *(void *)&applier[14] = v73;
            *(_WORD *)&applier[22] = 2114;
            *(void *)&unsigned char applier[24] = v22;
            *(_WORD *)&applier[32] = 1024;
            *(_DWORD *)&applier[34] = v74;
            *(_WORD *)&applier[38] = 2114;
            *(void *)&applier[40] = v75;
            *(_WORD *)&applier[48] = 2082;
            *(void *)&applier[50] = v70;
            _os_log_impl(&dword_1830D4000, v56, v71, "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@, dumping backtrace:%{public}s", applier, 0x3Au);
          }

          free(v70);
          goto LABEL_138;
        }
        if (v72)
        {
          uint64_t v106 = *(void *)(a1 + 32);
          nw_endpoint_type_t v107 = nw_endpoint_get_type(v22);
          uint64_t v108 = *(void *)(a1 + 40);
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v106;
          *(_WORD *)&applier[22] = 2114;
          *(void *)&unsigned char applier[24] = v22;
          *(_WORD *)&applier[32] = 1024;
          *(_DWORD *)&applier[34] = v107;
          *(_WORD *)&applier[38] = 2114;
          *(void *)&applier[40] = v108;
          _os_log_impl(&dword_1830D4000, v56, v71, "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@, no backtrace", applier, 0x30u);
        }
      }
      else
      {
        long long v56 = __nwlog_obj();
        os_log_type_t v91 = __dst[0].sa_len;
        if (os_log_type_enabled(v56, (os_log_type_t)__dst[0].sa_len))
        {
          uint64_t v92 = *(void *)(a1 + 32);
          nw_endpoint_type_t v93 = nw_endpoint_get_type(v22);
          uint64_t v94 = *(void *)(a1 + 40);
          *(_DWORD *)applier = 136447234;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 2114;
          *(void *)&applier[14] = v92;
          *(_WORD *)&applier[22] = 2114;
          *(void *)&unsigned char applier[24] = v22;
          *(_WORD *)&applier[32] = 1024;
          *(_DWORD *)&applier[34] = v93;
          *(_WORD *)&applier[38] = 2114;
          *(void *)&applier[40] = v94;
          _os_log_impl(&dword_1830D4000, v56, v91, "%{public}s %{public}@ got bad endpoint %{public}@ type %u from %{public}@, backtrace limit exceeded", applier, 0x30u);
        }
      }
    }
LABEL_138:
    if (v55) {
      free(v55);
    }
    goto LABEL_257;
  }
  uint64_t address = nw_endpoint_get_address(v22);
  if (!address)
  {
    os_log_type_t v81 = __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    BOOL v82 = (char *)_os_log_send_and_compose_impl();

    __dst[0].os_log_type_t sa_len = 16;
    LOBYTE(buffer) = 0;
    if (__nwlog_fault(v82, __dst, &buffer))
    {
      if (__dst[0].sa_len == 17)
      {
        os_log_type_t v83 = __nwlog_obj();
        os_log_type_t v84 = __dst[0].sa_len;
        if (os_log_type_enabled(v83, (os_log_type_t)__dst[0].sa_len))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v83, v84, "%{public}s nw_endpoint_get_address failed", applier, 0xCu);
        }
      }
      else if ((_BYTE)buffer)
      {
        int v95 = (char *)__nw_create_backtrace_string();
        os_log_type_t v83 = __nwlog_obj();
        os_log_type_t v96 = __dst[0].sa_len;
        BOOL v97 = os_log_type_enabled(v83, (os_log_type_t)__dst[0].sa_len);
        if (v95)
        {
          if (v97)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = v95;
            _os_log_impl(&dword_1830D4000, v83, v96, "%{public}s nw_endpoint_get_address failed, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(v95);
          goto LABEL_173;
        }
        if (v97)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v83, v96, "%{public}s nw_endpoint_get_address failed, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        os_log_type_t v83 = __nwlog_obj();
        os_log_type_t v127 = __dst[0].sa_len;
        if (os_log_type_enabled(v83, (os_log_type_t)__dst[0].sa_len))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v83, v127, "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded", applier, 0xCu);
        }
      }
    }
LABEL_173:
    if (v82) {
      free(v82);
    }
    goto LABEL_257;
  }
  memset(__dst, 0, 28);
  if (address->sa_len >= 0x1Cu) {
    size_t v24 = 28;
  }
  else {
    size_t v24 = address->sa_len;
  }
  memcpy(__dst, address, v24);
  if (__dst[0].sa_family != 2 && __dst[0].sa_family != 30)
  {
    uint64_t v87 = __nwlog_obj();
    *(_DWORD *)applier = 136446466;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    *(_WORD *)&applier[12] = 1024;
    *(_DWORD *)&applier[14] = __dst[0].sa_family;
    char v88 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(buffer) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v88, &buffer, type))
    {
      if (buffer == 17)
      {
        uint64_t v89 = __nwlog_obj();
        os_log_type_t v90 = buffer;
        if (os_log_type_enabled(v89, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = __dst[0].sa_family;
          _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s Unsupported address family %u", applier, 0x12u);
        }
      }
      else if (type[0])
      {
        int v109 = (char *)__nw_create_backtrace_string();
        uint64_t v89 = __nwlog_obj();
        os_log_type_t v110 = buffer;
        BOOL v111 = os_log_type_enabled(v89, (os_log_type_t)buffer);
        if (v109)
        {
          if (v111)
          {
            *(_DWORD *)applier = 136446722;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 1024;
            *(_DWORD *)&applier[14] = __dst[0].sa_family;
            *(_WORD *)&applier[18] = 2082;
            *(void *)&applier[20] = v109;
            _os_log_impl(&dword_1830D4000, v89, v110, "%{public}s Unsupported address family %u, dumping backtrace:%{public}s", applier, 0x1Cu);
          }

          free(v109);
          goto LABEL_255;
        }
        if (v111)
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = __dst[0].sa_family;
          _os_log_impl(&dword_1830D4000, v89, v110, "%{public}s Unsupported address family %u, no backtrace", applier, 0x12u);
        }
      }
      else
      {
        uint64_t v89 = __nwlog_obj();
        os_log_type_t v137 = buffer;
        if (os_log_type_enabled(v89, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446466;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          *(_WORD *)&applier[12] = 1024;
          *(_DWORD *)&applier[14] = __dst[0].sa_family;
          _os_log_impl(&dword_1830D4000, v89, v137, "%{public}s Unsupported address family %u, backtrace limit exceeded", applier, 0x12u);
        }
      }
    }
LABEL_255:
    if (v88) {
      free(v88);
    }
LABEL_257:
    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
LABEL_268:

LABEL_269:
    BOOL v64 = v219;
    goto LABEL_270;
  }
  *(_WORD *)__dst[0].sa_data = v21;
  nw_endpoint_t v25 = nw_endpoint_create_address(__dst);
  nw_endpoint_t v217 = v25;
  if (!v25)
  {
    int v99 = __nwlog_obj();
    *(_DWORD *)applier = 136446210;
    *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
    int v100 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(buffer) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v100, &buffer, type))
    {
      if (buffer == 17)
      {
        int v101 = __nwlog_obj();
        os_log_type_t v102 = buffer;
        if (os_log_type_enabled(v101, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v101, v102, "%{public}s nw_endpoint_create_address failed", applier, 0xCu);
        }
      }
      else if (type[0])
      {
        int v124 = (char *)__nw_create_backtrace_string();
        int v101 = __nwlog_obj();
        os_log_type_t v125 = buffer;
        BOOL v126 = os_log_type_enabled(v101, (os_log_type_t)buffer);
        if (v124)
        {
          if (v126)
          {
            *(_DWORD *)applier = 136446466;
            *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
            *(_WORD *)&applier[12] = 2082;
            *(void *)&applier[14] = v124;
            _os_log_impl(&dword_1830D4000, v101, v125, "%{public}s nw_endpoint_create_address failed, dumping backtrace:%{public}s", applier, 0x16u);
          }

          free(v124);
          goto LABEL_264;
        }
        if (v126)
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v101, v125, "%{public}s nw_endpoint_create_address failed, no backtrace", applier, 0xCu);
        }
      }
      else
      {
        int v101 = __nwlog_obj();
        os_log_type_t v189 = buffer;
        if (os_log_type_enabled(v101, (os_log_type_t)buffer))
        {
          *(_DWORD *)applier = 136446210;
          *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
          _os_log_impl(&dword_1830D4000, v101, v189, "%{public}s nw_endpoint_create_address failed, backtrace limit exceeded", applier, 0xCu);
        }
      }
    }
LABEL_264:
    if (v100) {
      free(v100);
    }
    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    goto LABEL_267;
  }
  objc_storeStrong((id *)v219 + 1, v25);
  objc_storeStrong((id *)v219 + 72, *(id *)(a1 + 40));
  if (!*(_DWORD *)&buf[12])
  {
    int v112 = v252;
    if (v252 == 1)
    {
      int v183 = __nwlog_obj();
      if (os_log_type_enabled(v183, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v184 = *(void *)(a1 + 32);
        uint64_t v185 = *(void *)(a1 + 40);
        *(_DWORD *)applier = 136446978;
        *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v184;
        *(_WORD *)&applier[22] = 2114;
        *(void *)&unsigned char applier[24] = v217;
        *(_WORD *)&applier[32] = 2114;
        *(void *)&applier[34] = v185;
        _os_log_impl(&dword_1830D4000, v183, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ received operation code retry from %{public}@ on %{public}@", applier, 0x2Au);
      }

      nwsc_restart_outgoing_requests_waiting_for_path(*(void **)(a1 + 32), v217);
      goto LABEL_248;
    }
    if ((_BYTE)v252)
    {
      unsigned int v113 = __nwlog_obj();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_ERROR))
      {
        uint64_t v186 = *(void *)(a1 + 32);
        uint64_t v187 = *(void *)(a1 + 40);
        *(_DWORD *)applier = 136447234;
        *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v186;
        *(_WORD *)&applier[22] = 1024;
        *(_DWORD *)&unsigned char applier[24] = v112;
        *(_WORD *)&applier[28] = 2114;
        *(void *)&applier[30] = v217;
        *(_WORD *)&applier[38] = 2114;
        *(void *)&applier[40] = v187;
        int v116 = "%{public}s %{public}@ received unsupported operation code %u from %{public}@ on %{public}@";
        int v117 = v113;
        os_log_type_t v118 = OS_LOG_TYPE_ERROR;
        uint32_t v119 = 48;
        goto LABEL_246;
      }
    }
    else
    {
      unsigned int v113 = __nwlog_obj();
      if (os_log_type_enabled(v113, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v114 = *(void *)(a1 + 32);
        uint64_t v115 = *(void *)(a1 + 40);
        *(_DWORD *)applier = 136446978;
        *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
        *(_WORD *)&applier[12] = 2114;
        *(void *)&applier[14] = v114;
        *(_WORD *)&applier[22] = 2114;
        *(void *)&unsigned char applier[24] = v217;
        *(_WORD *)&applier[32] = 2114;
        *(void *)&applier[34] = v115;
        int v116 = "%{public}s %{public}@ received operation code no-op from %{public}@ on %{public}@";
        int v117 = v113;
        os_log_type_t v118 = OS_LOG_TYPE_DEFAULT;
        uint32_t v119 = 42;
LABEL_246:
        _os_log_impl(&dword_1830D4000, v117, v118, v116, applier, v119);
      }
    }

LABEL_248:
    unint64_t new_sequence_number = nw_service_connector_get_new_sequence_number();
    nwsc_send_feedback(*(void **)(a1 + 32), *(void **)(a1 + 40), new_sequence_number, 0, 0, 0);
    goto LABEL_267;
  }
  if (v12 <= 0x5A)
  {
    uint64_t v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v27 = *(void *)(a1 + 32);
      uint64_t v28 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v27;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&unsigned char applier[24] = v12;
      *(_WORD *)&applier[32] = 2114;
      *(void *)&applier[34] = v28;
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ second read copyout insufficient start req length %zu, cancelling %{public}@", applier, 0x2Au);
    }
    goto LABEL_30;
  }
  *((void *)v219 + 5_Block_object_dispose(&a9, 8) = bswap64(*(unint64_t *)&buf[4]);
  *((_OWORD *)v219 + 30) = *(_OWORD *)((unint64_t)buf | 0xC);
  size_t v120 = buf[28];
  if (v12 < (unint64_t)buf[28] + 91)
  {
    int v121 = __nwlog_obj();
    if (os_log_type_enabled(v121, OS_LOG_TYPE_ERROR))
    {
      uint64_t v122 = *(void *)(a1 + 32);
      uint64_t v123 = *(void *)(a1 + 40);
      *(_DWORD *)applier = 136447234;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v122;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&unsigned char applier[24] = v12;
      *(_WORD *)&applier[32] = 1024;
      *(_DWORD *)&applier[34] = v120;
      *(_WORD *)&applier[38] = 2114;
      *(void *)&applier[40] = v123;
      _os_log_impl(&dword_1830D4000, v121, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ second read copyout insufficient start req length %zu for service length %u, cancelling %{public}@", applier, 0x30u);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    goto LABEL_267;
  }
  *(_OWORD *)(v219 + 24) = 0u;
  *((_DWORD *)v219 + 114) = 0;
  *(_OWORD *)(v219 + 424) = 0u;
  *(_OWORD *)(v219 + 440) = 0u;
  *(_OWORD *)(v219 + 392) = 0u;
  *(_OWORD *)(v219 + 40_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(v219 + 360) = 0u;
  *(_OWORD *)(v219 + 376) = 0u;
  *(_OWORD *)(v219 + 32_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(v219 + 344) = 0u;
  *(_OWORD *)(v219 + 296) = 0u;
  *(_OWORD *)(v219 + 312) = 0u;
  *(_OWORD *)(v219 + 264) = 0u;
  *(_OWORD *)(v219 + 280) = 0u;
  *(_OWORD *)(v219 + 232) = 0u;
  *(_OWORD *)(v219 + 24_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(v219 + 200) = 0u;
  *(_OWORD *)(v219 + 216) = 0u;
  *(_OWORD *)(v219 + 16_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(v219 + 184) = 0u;
  *(_OWORD *)(v219 + 136) = 0u;
  *(_OWORD *)(v219 + 152) = 0u;
  *(_OWORD *)(v219 + 104) = 0u;
  *(_OWORD *)(v219 + 120) = 0u;
  *(_OWORD *)(v219 + 72) = 0u;
  *(_OWORD *)(v219 + 8_Block_object_dispose(&a9, 8) = 0u;
  *(_OWORD *)(v219 + 40) = 0u;
  *(_OWORD *)(v219 + 56) = 0u;
  memcpy(v219 + 24, &buf[29], v120);
  uint64_t v129 = *(unsigned __int16 *)(a1 + 48);
  uint64_t v130 = v129 + 2;
  *((_DWORD *)v219 + 142) = v129 + 2;
  int v131 = malloc_type_malloc(v129 + 2, 0xF2B69DE5uLL);
  if (v131)
  {
LABEL_177:
    *((void *)v219 + 70) = v131;
    *int v131 = *(_WORD *)(a1 + 50);
    uint64_t v132 = nw_dispatch_data_copyout(v9, *((void *)v219 + 70) + 2, *(unsigned __int16 *)(a1 + 48));
    if (v132 == *(unsigned __int16 *)(a1 + 48))
    {
      long long v133 = *(_OWORD *)&buf[v120 + 29];
      long long v134 = *(_OWORD *)((char *)&v250[1] + v120 + 5);
      long long v135 = *(long long *)((char *)&v251 + v120 + 13);
      *((_OWORD *)v219 + 33) = *(_OWORD *)((char *)&v250[3] + v120 + 5);
      *((_OWORD *)v219 + 34) = v135;
      *((_OWORD *)v219 + 31) = v133;
      *((_OWORD *)v219 + 32) = v134;
      size_t v136 = *((void *)v219 + 70) + v120;
      *(_OWORD *)(v136 + 45) = 0u;
      *(_OWORD *)(v136 + 61) = 0u;
      *(_OWORD *)(v136 + 77) = 0u;
      *(_OWORD *)(v136 + 29) = 0u;
      nwsc_process_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 32), (NWConcrete_nw_unique_connection_request *)v219);
      nwsc_restart_outgoing_requests_waiting_for_path(*(void **)(a1 + 32), v217);
      goto LABEL_267;
    }
    uint64_t v190 = v132;
    uint64_t v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
    {
      uint64_t v191 = *(void *)(a1 + 32);
      *(_DWORD *)applier = 136446978;
      *(void *)&applier[4] = "nw_service_connector_should_accept_connection_block_invoke";
      *(_WORD *)&applier[12] = 2114;
      *(void *)&applier[14] = v191;
      *(_WORD *)&applier[22] = 2048;
      *(void *)&unsigned char applier[24] = v190;
      *(_WORD *)&applier[32] = 2114;
      *(void *)&applier[34] = v219;
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ copyout for sig insufficient req length %zu, cancelling %{public}@", applier, 0x2Au);
    }
LABEL_30:

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
LABEL_267:

    goto LABEL_268;
  }
  int v212 = __nwlog_obj();
  os_log_type_enabled(v212, OS_LOG_TYPE_ERROR);
  *(_DWORD *)applier = 136446466;
  *(void *)&applier[4] = "strict_malloc";
  *(_WORD *)&applier[12] = 2048;
  *(void *)&applier[14] = v130;
  int v213 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v213))
  {
    free(v213);
    int v131 = 0;
    goto LABEL_177;
  }
  __break(1u);
}

void sub_183A7ADCC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, uint64_t a20,uint64_t a21,void *a22,void *a23)
{
  _Unwind_Resume(a1);
}

void nwsc_restart_outgoing_requests_waiting_for_path(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    int v7 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  uint64_t v6 = v3[12];
  if (v6)
  {
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = ___ZL47nwsc_restart_outgoing_requests_waiting_for_pathP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObject_block_invoke;
    void v21[3] = &unk_1E52445E8;
    id v22 = v4;
    os_log_type_t v23 = v3;
    nw_dictionary_apply(v6, (uint64_t)v21);

    goto LABEL_4;
  }
  unsigned int v11 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
  BOOL v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null serviceConnector->activeOutgoingRequests", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v16 = (char *)__nw_create_backtrace_string();
  uint64_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)long long buf = 136446210;
      uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)long long buf = 136446466;
    uint64_t v27 = "nwsc_restart_outgoing_requests_waiting_for_path";
    __int16 v28 = 2082;
    uint64_t v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

unint64_t nw_service_connector_get_new_sequence_number(void)
{
  if (nw_service_connector_get_new_sequence_number(void)::onceToken != -1) {
    dispatch_once(&nw_service_connector_get_new_sequence_number(void)::onceToken, &__block_literal_global_191);
  }
  for (unint64_t result = atomic_fetch_add(&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber, 1uLL);
        !result;
  return result;
}

void nwsc_send_feedback(void *a1, void *a2, unint64_t a3, int a4, int a5, void *a6)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  unsigned int v11 = a1;
  id v12 = a2;
  id v13 = a6;
  int buffer = 10752;
  if ((a4 & 1) != 0 || a5)
  {
    if (a4) {
      __int16 v14 = 128;
    }
    else {
      __int16 v14 = 64;
    }
    HIWORD(buffer) = v14;
  }
  unint64_t v40 = bswap64(a3);
  long long v41 = *(_OWORD *)(v11 + 120);
  long long v42 = *(_OWORD *)(v11 + 136);
  BOOL v15 = dispatch_data_create(&buffer, 0x2CuLL, 0, 0);
  if (v15)
  {
    if (a4) {
      uint64_t v16 = &__block_literal_global_42249;
    }
    else {
      uint64_t v16 = &__block_literal_global_6_42258;
    }
    completion[0] = MEMORY[0x1E4F143A8];
    completion[1] = 3221225472;
    completioint n[2] = ___ZL18nwsc_send_feedbackP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionybbU13block_pointerFviE_block_invoke;
    completion[3] = &unk_1E52432F0;
    uint64_t v27 = v11;
    __int16 v28 = v12;
    char v32 = a4;
    id v30 = v13;
    unint64_t v31 = a3;
    uint64_t v29 = v16;
    os_log_type_t v17 = v16;
    nw_connection_send(v28, v15, v17, 1, completion);

    goto LABEL_21;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v18 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v36 = "nwsc_send_feedback";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v33 = 0;
  if (!__nwlog_fault(v19, &type, &v33))
  {
LABEL_17:
    if (!v19) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v20 = (id)gLogObj;
    os_log_type_t v21 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v36 = "nwsc_send_feedback";
      _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s dispatch_data_create failed", buf, 0xCu);
    }
LABEL_16:

    goto LABEL_17;
  }
  if (!v33)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v20 = (id)gLogObj;
    os_log_type_t v25 = type;
    if (os_log_type_enabled(v20, type))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v36 = "nwsc_send_feedback";
      _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s dispatch_data_create failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_16;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v20 = (id)gLogObj;
  os_log_type_t v23 = type;
  BOOL v24 = os_log_type_enabled(v20, type);
  if (!backtrace_string)
  {
    if (v24)
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v36 = "nwsc_send_feedback";
      _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s dispatch_data_create failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_16;
  }
  if (v24)
  {
    *(_DWORD *)long long buf = 136446466;
    os_log_type_t v36 = "nwsc_send_feedback";
    __int16 v37 = 2082;
    unsigned __int16 v38 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s dispatch_data_create failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (!v19) {
    goto LABEL_19;
  }
LABEL_18:
  free(v19);
LABEL_19:
  if (v13) {
    (*((void (**)(id, uint64_t))v13 + 2))(v13, 12);
  }
LABEL_21:
}

void sub_183A7B914(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_process_incoming_request(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v174 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  uint64_t v130 = v3;
  if ((*((unsigned char *)v4 + 616) & 0x40) == 0)
  {
    long long v143 = 0u;
    long long v144 = 0u;
    endpoint = v4->endpoint;
    int v7 = v3;
    BOOL v8 = endpoint;
    uint64_t v9 = v8;
    if (v7)
    {
      if (v7->remotePubKeys)
      {
        if (v8)
        {
          int v173 = 0;
          long long v171 = 0u;
          long long v172 = 0u;
          long long v169 = 0u;
          long long v170 = 0u;
          long long v167 = 0u;
          long long v168 = 0u;
          long long v165 = 0u;
          long long v166 = 0u;
          long long v163 = 0u;
          long long v164 = 0u;
          long long v161 = 0u;
          long long v162 = 0u;
          long long v159 = 0u;
          long long v160 = 0u;
          long long v157 = 0u;
          long long v158 = 0u;
          long long v155 = 0u;
          long long v156 = 0u;
          long long v153 = 0u;
          long long v154 = 0u;
          long long v151 = 0u;
          long long v152 = 0u;
          long long v150 = 0u;
          memset(key, 0, sizeof(key));
          if (nwsc_get_endpoint_identifier(v8, (uint64_t)key))
          {
            os_log_type_t v10 = xpc_dictionary_get_value(v7->remotePubKeys, key);
            unsigned int v11 = v10;
            memset(buffer, 0, 40);
            if (!v10 || xpc_data_get_bytes(v10, buffer, 0, 0x28uLL) >= 0x28) {
              goto LABEL_51;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v12 = (id)gLogObj;
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
            id v13 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v139 = 0;
            if (__nwlog_fault(v13, &type, &v139))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v14 = (id)gLogObj;
                os_log_type_t v15 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                  _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s Insufficient length in remotePubKeys", buf, 0xCu);
                }
              }
              else if (v139)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __int16 v14 = __nwlog_obj();
                os_log_type_t v26 = type;
                BOOL v27 = os_log_type_enabled(v14, type);
                if (backtrace_string)
                {
                  if (v27)
                  {
                    *(_DWORD *)long long buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                    __int16 v146 = 2082;
                    int v147 = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s Insufficient length in remotePubKeys, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(backtrace_string);
                  if (!v13) {
                    goto LABEL_51;
                  }
                  goto LABEL_50;
                }
                if (v27)
                {
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                  _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s Insufficient length in remotePubKeys, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                __int16 v14 = __nwlog_obj();
                os_log_type_t v29 = type;
                if (os_log_type_enabled(v14, type))
                {
                  *(_DWORD *)long long buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nwsc_get_remote_pub_key";
                  _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s Insufficient length in remotePubKeys, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
            if (!v13)
            {
LABEL_51:
              long long v143 = *(_OWORD *)&buffer[1];
              long long v144 = *(_OWORD *)&buffer[3];
              unint64_t v28 = buffer[0];

LABEL_52:
              uint64_t v30 = *MEMORY[0x1E4F3B750];
              uint64_t v31 = *MEMORY[0x1E4F3B6D8];
              v141[0] = *MEMORY[0x1E4F3B718];
              v141[1] = v31;
              uint64_t v32 = *MEMORY[0x1E4F3B6F0];
              v142[0] = v30;
              v142[1] = v32;
              CFDictionaryRef attributes = [MEMORY[0x1E4F1C9E8] dictionaryWithObjects:v142 forKeys:v141 count:2];
              CFDataRef v33 = (const __CFData *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:&v143 length:32 freeWhenDone:0];
              *(void *)long long buf = 0;
              id v34 = SecKeyCreateWithData(v33, attributes, (CFErrorRef *)buf);
              if (v34)
              {
                CFDataRef v35 = (const __CFData *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:v5->incomingReqBytesToVerify length:v5->incomingReqBytesToVerifyLen freeWhenDone:0];
                CFDataRef v36 = (const __CFData *)[objc_alloc(MEMORY[0x1E4F1C9B8]) initWithBytesNoCopy:v5->signature length:64 freeWhenDone:0];
                int v37 = SecKeyVerifySignature(v34, (SecKeyAlgorithm)*MEMORY[0x1E4F3BAA0], v35, v36, (CFErrorRef *)buf);
                CFRelease(v34);

                if (v37)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  unsigned __int16 v38 = (id)gLogObj;
                  if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
                  {
                    int v39 = v5->signature[0];
                    int v40 = v5->signature[1];
                    int v41 = v5->signature[2];
                    int v42 = v5->signature[3];
                    *(_DWORD *)key = 136448770;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    *(_WORD *)&key[32] = 1024;
                    *(_DWORD *)&key[34] = v39;
                    *(_WORD *)&key[38] = 1024;
                    *(_DWORD *)&key[40] = v40;
                    *(_WORD *)&key[44] = 1024;
                    *(_DWORD *)&key[46] = v41;
                    *(_WORD *)&key[50] = 1024;
                    *(_DWORD *)&key[52] = v42;
                    *(_WORD *)&key[56] = 1024;
                    *(_DWORD *)&key[58] = v143;
                    *(_WORD *)&key[62] = 1024;
                    LODWORD(v150) = BYTE1(v143);
                    WORD2(v150) = 1024;
                    *(_DWORD *)((char *)&v150 + 6) = BYTE2(v143);
                    WORD5(v150) = 1024;
                    HIDWORD(v150) = BYTE3(v143);
                    _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ verified signature on incoming request %{public}@ sig %02x%02x%02x%02x remotePubKey %02x%02x%02x%02x", (uint8_t *)key, 0x50u);
                  }

                  *((unsigned char *)v5 + 616) |= 0x40u;
                  if ((*((unsigned char *)v7 + 152) & 4) != 0)
                  {
                    int v117 = __nwlog_obj();
                    if (os_log_type_enabled(v117, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)key = 136446722;
                      *(void *)&key[4] = "nwsc_process_incoming_request";
                      *(_WORD *)&key[12] = 2114;
                      *(void *)&key[14] = v7;
                      *(_WORD *)&key[22] = 2114;
                      *(void *)&key[24] = v5;
                      _os_log_impl(&dword_1830D4000, v117, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ failing incoming connection for testing: %{public}@", (uint8_t *)key, 0x20u);
                    }

                    nw_connection_cancel_current_endpoint(&v5->connection->super);
                  }
                  nw_service_connector_remove_pending_unverified_incoming_request(v7, v5);
                  uint64_t v43 = nw_service_connector_copy_active_connection_with_endpoint_and_service(v7, v5->endpoint, (uint64_t)v5->service);
                  id v44 = v43;
                  if (v43)
                  {
                    __int16 v45 = (void *)*((void *)v43 + 61);
                    if (!v45) {
                      goto LABEL_60;
                    }
                    os_log_type_t v46 = v45;
                    buffer[0] = 0;
                    buffer[1] = buffer;
                    buffer[2] = 0x2020000000;
                    LOBYTE(buffer[3]) = 0;
                    os_log_type_t v47 = v46 + 34;
                    *(void *)key = MEMORY[0x1E4F143A8];
                    *(void *)&key[8] = 3221225472;
                    *(void *)&key[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
                    *(void *)&key[24] = &unk_1E524B978;
                    *(void *)&key[40] = buffer;
                    __int16 v48 = v46;
                    *(void *)&key[32] = v48;
                    os_unfair_lock_lock(v47);
                    (*(void (**)(char *))&key[16])(key);
                    os_unfair_lock_unlock(v47);
                    int v49 = *(unsigned __int8 *)(buffer[1] + 24);

                    _Block_object_dispose(buffer, 8);
                    if (v49)
                    {
LABEL_60:
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v50 = (id)gLogObj;
                      if (os_log_type_enabled(v50, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ Cleaning up dead activeConnection %{public}@ due to receiving incoming request %{public}@", (uint8_t *)key, 0x2Au);
                      }

                      nw_service_connector_cancel_request_inner(v7, v5->endpoint, (uint64_t)v5->service, *((void **)v44 + 61), 0);
LABEL_74:
                      uint64_t v58 = (char *)nw_service_connector_copy_active_outgoing_request(v7, v5->endpoint, (uint64_t)v5->service);
                      long long v56 = v58;
                      if (!v58)
                      {
LABEL_81:
                        long long v56 = 0;
                        nw_service_connector_handle_unsolicited_requests(v7, v5);
                        id v44 = 0;
LABEL_112:

                        goto LABEL_113;
                      }
                      char v59 = v58[616];
                      if ((v59 & 0x10) == 0)
                      {
                        uint64_t v60 = (void *)*((void *)v58 + 72);
                        if (!v60 || nw_connection_is_cancelled(v60))
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          os_log_type_t v61 = (id)gLogObj;
                          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEFAULT))
                          {
                            *(_DWORD *)key = 136446978;
                            *(void *)&key[4] = "nwsc_process_incoming_request";
                            *(_WORD *)&key[12] = 2114;
                            *(void *)&key[14] = v7;
                            *(_WORD *)&key[22] = 2114;
                            *(void *)&key[24] = v56;
                            *(_WORD *)&key[32] = 2114;
                            *(void *)&key[34] = v5;
                            _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ Cleaning up dead outgoing request %{public}@ due to receiving incoming request %{public}@", (uint8_t *)key, 0x2Au);
                          }

                          nw_service_connector_cancel_request_inner(v7, v5->endpoint, (uint64_t)v5->service, *((void **)v56 + 72), 0);
                          goto LABEL_81;
                        }
                        char v59 = v56[616];
                      }
                      char v68 = v59 & 0xEF;
                      v56[616] = v68;
                      uint64_t v69 = *((void *)v56 + 76);
                      if (v69)
                      {
                        nw_queue_cancel_source(v69);
                        *((void *)v56 + 76) = 0;
                        char v68 = v56[616];
                      }
                      if ((v68 & 0x80) == 0 && nwsc_compare_uuid((unsigned __int8 *)v56 + 480, v5->uuid))
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        os_log_type_t v70 = (id)gLogObj;
                        if (os_log_type_enabled(v70, OS_LOG_TYPE_DEFAULT))
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v56;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl(&dword_1830D4000, v70, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ existing outgoing request %{public}@ has a larger UUID, rejecting incoming request %{public}@", (uint8_t *)key, 0x2Au);
                        }

                        nw_service_connector_reject_incoming_request(v7, v5, 0);
                        id v44 = 0;
                        goto LABEL_112;
                      }
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v71 = (id)gLogObj;
                      if (os_log_type_enabled(v71, OS_LOG_TYPE_DEFAULT))
                      {
                        int v72 = v56[616];
                        uint64_t v73 = "has a smaller UUID";
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_DWORD *)key = 136447234;
                        *(_WORD *)&key[12] = 2114;
                        if (v72 < 0) {
                          uint64_t v73 = "is waiting for path";
                        }
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v56;
                        *(_WORD *)&key[32] = 2082;
                        *(void *)&key[34] = v73;
                        *(_WORD *)&key[42] = 2114;
                        *(void *)&key[44] = v5;
                        _os_log_impl(&dword_1830D4000, v71, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ existing outgoing request %{public}@ %{public}s, cancelling our outgoing request and accepting incoming request %{public}@", (uint8_t *)key, 0x34u);
                      }

                      nw_service_connector_cancel_request_inner(v7, *((void **)v56 + 1), (uint64_t)(v56 + 24), *((void **)v56 + 72), 0);
                      connection = v5->connection;
                      v135[0] = MEMORY[0x1E4F143A8];
                      v135[1] = 3221225472;
                      v135[2] = ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke;
                      v135[3] = &unk_1E5243278;
                      size_t v136 = v7;
                      long long v56 = v56;
                      os_log_type_t v137 = v56;
                      int v138 = v5;
                      nw_service_connector_accept_connection_for_request(v136, connection, v138, v135);
                      id v44 = 0;
                      uint64_t v75 = (id *)&v136;
                      long long v76 = (id *)&v137;
                      os_log_type_t v77 = (id *)&v138;
LABEL_111:

                      goto LABEL_112;
                    }
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v51 = (id)gLogObj;
                  if (os_log_type_enabled(v51, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)key = 136446978;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    *(_WORD *)&key[32] = 2114;
                    *(void *)&key[34] = v44;
                    _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ Received incoming request %{public}@ activeConnection %{public}@", (uint8_t *)key, 0x2Au);
                  }

                  if (!v44) {
                    goto LABEL_74;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v52 = (id)gLogObj;
                  if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)key = 136446978;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    *(_WORD *)&key[32] = 2114;
                    *(void *)&key[34] = v44;
                    _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ received incoming request %{public}@ while we have activeConnection %{public}@", (uint8_t *)key, 0x2Au);
                  }

                  unint64_t v53 = *((void *)v44 + 57);
                  unint64_t sequenceNumber = v5->sequenceNumber;
                  if (v53 < sequenceNumber)
                  {
                    long long v55 = (char *)nw_service_connector_copy_active_outgoing_request(v7, v5->endpoint, (uint64_t)v5->service);
                    long long v56 = v55;
                    if (!v55 || (v55[616] & 0x10) == 0)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      os_log_type_t v57 = (id)gLogObj;
                      if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ active connection %{public}@ has a lower sequence number than incoming request %{public}@, accepting incoming request and cancelling active connection", (uint8_t *)key, 0x2Au);
                      }

                      nw_service_connector_cancel_request_inner(v7, *((void **)v44 + 1), (uint64_t)v44 + 16, *((void **)v44 + 61), 1);
                      nw_service_connector_handle_unsolicited_requests(v7, v5);
                      goto LABEL_112;
                    }
                    os_log_type_t v78 = __nwlog_obj();
                    if (os_log_type_enabled(v78, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)key = 136447234;
                      *(void *)&key[4] = "nwsc_process_incoming_request";
                      *(_WORD *)&key[12] = 2114;
                      *(void *)&key[14] = v7;
                      *(_WORD *)&key[22] = 2114;
                      *(void *)&key[24] = v44;
                      *(_WORD *)&key[32] = 2114;
                      *(void *)&key[34] = v5;
                      *(_WORD *)&key[42] = 2114;
                      *(void *)&key[44] = v56;
                      _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ active connection %{public}@ has a lower sequence number than incoming request %{public}@, accepting incoming request, cancelling active connection and using %{public}@", (uint8_t *)key, 0x34u);
                    }

                    v56[616] &= ~0x10u;
                    uint64_t v79 = *((void *)v56 + 76);
                    if (v79)
                    {
                      nw_queue_cancel_source(v79);
                      *((void *)v56 + 76) = 0;
                    }
                    nw_service_connector_cancel_request_inner(v7, *((void **)v44 + 1), (uint64_t)v44 + 16, *((void **)v44 + 61), 1);
                    os_log_type_t v80 = v5->connection;
                    v131[0] = MEMORY[0x1E4F143A8];
                    v131[1] = 3221225472;
                    v131[2] = ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_198;
                    v131[3] = &unk_1E5243278;
                    uint64_t v132 = v7;
                    os_log_type_t v81 = v56;
                    long long v133 = v81;
                    long long v134 = v5;
                    nw_service_connector_accept_connection_for_request(v132, v80, v134, v131);
                    uint64_t v75 = (id *)&v132;
                    long long v76 = (id *)&v133;
                    os_log_type_t v77 = (id *)&v134;
                    long long v56 = v81;
                    goto LABEL_111;
                  }
                  if (v53 > sequenceNumber)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    os_log_type_t v62 = (id)gLogObj;
                    if (os_log_type_enabled(v62, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)key = 136446978;
                      *(void *)&key[4] = "nwsc_process_incoming_request";
                      *(_WORD *)&key[12] = 2114;
                      *(void *)&key[14] = v7;
                      *(_WORD *)&key[22] = 2114;
                      *(void *)&key[24] = v44;
                      *(_WORD *)&key[32] = 2114;
                      *(void *)&key[34] = v5;
                      _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ active connection %{public}@ has a higher sequence number than incoming request %{public}@, rejecting incoming request", (uint8_t *)key, 0x2Au);
                    }

                    goto LABEL_140;
                  }
                  BOOL v63 = nwsc_compare_uuid((unsigned __int8 *)v44 + 472, v5->uuid);
                  BOOL v64 = __nwlog_obj();
                  if (v63)
                  {
                    *(_DWORD *)key = 136446978;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v44;
                    *(_WORD *)&key[32] = 2114;
                    *(void *)&key[34] = v5;
                    long long v65 = (char *)_os_log_send_and_compose_impl();

                    LOBYTE(buffer[0]) = 16;
                    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v65, buffer, &type))
                    {
                      if (LOBYTE(buffer[0]) == 17)
                      {
                        id v66 = __nwlog_obj();
                        os_log_type_t v67 = buffer[0];
                        if (os_log_type_enabled(v66, buffer[0]))
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl(&dword_1830D4000, v66, v67, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but higher UUID, rejecting incoming request", (uint8_t *)key, 0x2Au);
                        }
                      }
                      else if (type)
                      {
                        os_log_type_t v85 = (char *)__nw_create_backtrace_string();
                        id v66 = __nwlog_obj();
                        os_log_type_t v86 = buffer[0];
                        BOOL v87 = os_log_type_enabled(v66, buffer[0]);
                        if (v85)
                        {
                          if (v87)
                          {
                            *(_DWORD *)key = 136447234;
                            *(void *)&key[4] = "nwsc_process_incoming_request";
                            *(_WORD *)&key[12] = 2114;
                            *(void *)&key[14] = v7;
                            *(_WORD *)&key[22] = 2114;
                            *(void *)&key[24] = v44;
                            *(_WORD *)&key[32] = 2114;
                            *(void *)&key[34] = v5;
                            *(_WORD *)&key[42] = 2082;
                            *(void *)&key[44] = v85;
                            _os_log_impl(&dword_1830D4000, v66, v86, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but higher UUID, rejecting incoming request, dumping backtrace:%{public}s", (uint8_t *)key, 0x34u);
                          }

                          free(v85);
                          goto LABEL_138;
                        }
                        if (v87)
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl(&dword_1830D4000, v66, v86, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but higher UUID, rejecting incoming request, no backtrace", (uint8_t *)key, 0x2Au);
                        }
                      }
                      else
                      {
                        id v66 = __nwlog_obj();
                        os_log_type_t v91 = buffer[0];
                        if (os_log_type_enabled(v66, buffer[0]))
                        {
                          *(_DWORD *)key = 136446978;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          _os_log_impl(&dword_1830D4000, v66, v91, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but higher UUID, rejecting incoming request, backtrace limit exceeded", (uint8_t *)key, 0x2Au);
                        }
                      }
                    }
LABEL_138:
                    if (v65) {
                      free(v65);
                    }
LABEL_140:
                    nw_service_connector_reject_incoming_request(v7, v5, 0);
                    goto LABEL_113;
                  }
                  *(_DWORD *)key = 136446978;
                  *(void *)&key[4] = "nwsc_process_incoming_request";
                  *(_WORD *)&key[12] = 2114;
                  *(void *)&key[14] = v7;
                  *(_WORD *)&key[22] = 2114;
                  *(void *)&key[24] = v44;
                  *(_WORD *)&key[32] = 2114;
                  *(void *)&key[34] = v5;
                  BOOL v82 = (char *)_os_log_send_and_compose_impl();

                  LOBYTE(buffer[0]) = 16;
                  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v82, buffer, &type))
                  {
                    if (LOBYTE(buffer[0]) == 17)
                    {
                      os_log_type_t v83 = __nwlog_obj();
                      os_log_type_t v84 = buffer[0];
                      if (os_log_type_enabled(v83, buffer[0]))
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl(&dword_1830D4000, v83, v84, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but lower UUID, accepting incoming request and cancelling active connection", (uint8_t *)key, 0x2Au);
                      }
                    }
                    else if (type)
                    {
                      char v88 = (char *)__nw_create_backtrace_string();
                      os_log_type_t v83 = __nwlog_obj();
                      os_log_type_t v89 = buffer[0];
                      BOOL v90 = os_log_type_enabled(v83, buffer[0]);
                      if (v88)
                      {
                        if (v90)
                        {
                          *(_DWORD *)key = 136447234;
                          *(void *)&key[4] = "nwsc_process_incoming_request";
                          *(_WORD *)&key[12] = 2114;
                          *(void *)&key[14] = v7;
                          *(_WORD *)&key[22] = 2114;
                          *(void *)&key[24] = v44;
                          *(_WORD *)&key[32] = 2114;
                          *(void *)&key[34] = v5;
                          *(_WORD *)&key[42] = 2082;
                          *(void *)&key[44] = v88;
                          _os_log_impl(&dword_1830D4000, v83, v89, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but lower UUID, accepting incoming request and cancelling active connection, dumping backtrace:%{public}s", (uint8_t *)key, 0x34u);
                        }

                        free(v88);
                        goto LABEL_144;
                      }
                      if (v90)
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl(&dword_1830D4000, v83, v89, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but lower UUID, accepting incoming request and cancelling active connection, no backtrace", (uint8_t *)key, 0x2Au);
                      }
                    }
                    else
                    {
                      os_log_type_t v83 = __nwlog_obj();
                      os_log_type_t v92 = buffer[0];
                      if (os_log_type_enabled(v83, buffer[0]))
                      {
                        *(_DWORD *)key = 136446978;
                        *(void *)&key[4] = "nwsc_process_incoming_request";
                        *(_WORD *)&key[12] = 2114;
                        *(void *)&key[14] = v7;
                        *(_WORD *)&key[22] = 2114;
                        *(void *)&key[24] = v44;
                        *(_WORD *)&key[32] = 2114;
                        *(void *)&key[34] = v5;
                        _os_log_impl(&dword_1830D4000, v83, v92, "%{public}s %{public}@ active connection %{public}@ has same sequence number than incoming request %{public}@ but lower UUID, accepting incoming request and cancelling active connection, backtrace limit exceeded", (uint8_t *)key, 0x2Au);
                      }
                    }
                  }
LABEL_144:
                  if (v82) {
                    free(v82);
                  }
                  nw_service_connector_handle_unsolicited_requests(v7, v5);
                  nw_service_connector_cancel_request_inner(v7, *((void **)v44 + 1), (uint64_t)v44 + 16, *((void **)v44 + 61), 1);
                  goto LABEL_113;
                }
              }
              else
              {
                os_log_type_t v96 = __nwlog_obj();
                if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)key = 136446466;
                  *(void *)&key[4] = "nwsc_process_incoming_request";
                  *(_WORD *)&key[12] = 2112;
                  *(void *)&key[14] = *(void *)buf;
                  _os_log_impl(&dword_1830D4000, v96, OS_LOG_TYPE_ERROR, "%{public}s SecKeyCreateWithData failed with error %@", (uint8_t *)key, 0x16u);
                }

                if (*(void *)buf)
                {
                  CFRelease(*(CFTypeRef *)buf);
                  *(void *)long long buf = 0;
                }
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v97 = (id)gLogObj;
              if (os_log_type_enabled(v97, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)key = 136446722;
                *(void *)&key[4] = "nwsc_process_incoming_request";
                *(_WORD *)&key[12] = 2114;
                *(void *)&key[14] = v7;
                *(_WORD *)&key[22] = 2114;
                *(void *)&key[24] = *(void *)buf;
                _os_log_impl(&dword_1830D4000, v97, OS_LOG_TYPE_DEBUG, "%{public}s %{public}@ signature verification error: %{public}@", (uint8_t *)key, 0x20u);
              }

              if (*(void *)buf)
              {
                CFRelease(*(CFTypeRef *)buf);
                *(void *)long long buf = 0;
              }
              if (v28 >= v5->sequenceNumber)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                int v104 = (id)gLogObj;
                if (os_log_type_enabled(v104, OS_LOG_TYPE_ERROR))
                {
                  int v105 = v5->signature[0];
                  int v106 = v5->signature[1];
                  int v107 = v5->signature[2];
                  int v108 = v5->signature[3];
                  *(_DWORD *)key = 136449026;
                  *(void *)&key[4] = "nwsc_process_incoming_request";
                  *(_WORD *)&key[12] = 2114;
                  *(void *)&key[14] = v7;
                  *(_WORD *)&key[22] = 2114;
                  *(void *)&key[24] = v5;
                  *(_WORD *)&key[32] = 1024;
                  *(_DWORD *)&key[34] = v105;
                  *(_WORD *)&key[38] = 1024;
                  *(_DWORD *)&key[40] = v106;
                  *(_WORD *)&key[44] = 1024;
                  *(_DWORD *)&key[46] = v107;
                  *(_WORD *)&key[50] = 1024;
                  *(_DWORD *)&key[52] = v108;
                  *(_WORD *)&key[56] = 1024;
                  *(_DWORD *)&key[58] = v143;
                  *(_WORD *)&key[62] = 1024;
                  LODWORD(v150) = BYTE1(v143);
                  WORD2(v150) = 1024;
                  *(_DWORD *)((char *)&v150 + 6) = BYTE2(v143);
                  WORD5(v150) = 1024;
                  HIDWORD(v150) = BYTE3(v143);
                  LOWORD(v151) = 2048;
                  *(void *)((char *)&v151 + 2) = v28;
                  _os_log_impl(&dword_1830D4000, v104, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ cancelling due to bad signature on incoming request %{public}@ sig %02x%02x%02x%02x remotePubKey %02x%02x%02x%02x remotePubKeySeqNo %llu", (uint8_t *)key, 0x5Au);
                }

                *((unsigned char *)v5 + 616) |= 0x40u;
                nw_service_connector_reject_incoming_request(v7, v5, 0);
                goto LABEL_169;
              }
              if ((*((unsigned char *)v5 + 616) & 0x20) == 0)
              {
                *((unsigned char *)v5 + 616) |= 0x20u;
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v98 = (id)gLogObj;
                if (os_log_type_enabled(v98, OS_LOG_TYPE_DEFAULT))
                {
                  int v99 = v5->signature[0];
                  int v100 = v5->signature[1];
                  int v101 = v5->signature[2];
                  int v102 = v5->signature[3];
                  *(_DWORD *)key = 136448770;
                  *(void *)&key[4] = "nwsc_process_incoming_request";
                  *(_WORD *)&key[12] = 2114;
                  *(void *)&key[14] = v7;
                  *(_WORD *)&key[22] = 2114;
                  *(void *)&key[24] = v5;
                  *(_WORD *)&key[32] = 1024;
                  *(_DWORD *)&key[34] = v99;
                  *(_WORD *)&key[38] = 1024;
                  *(_DWORD *)&key[40] = v100;
                  *(_WORD *)&key[44] = 1024;
                  *(_DWORD *)&key[46] = v101;
                  *(_WORD *)&key[50] = 1024;
                  *(_DWORD *)&key[52] = v102;
                  *(_WORD *)&key[56] = 1024;
                  *(_DWORD *)&key[58] = v143;
                  *(_WORD *)&key[62] = 1024;
                  LODWORD(v150) = BYTE1(v143);
                  WORD2(v150) = 1024;
                  *(_DWORD *)((char *)&v150 + 6) = BYTE2(v143);
                  WORD5(v150) = 1024;
                  HIDWORD(v150) = BYTE3(v143);
                  _os_log_impl(&dword_1830D4000, v98, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ signature did not verify on incoming request %{public}@ sig %02x%02x%02x%02x remotePubKey %02x%02x%02x%02x requesting newer remotePubKey", (uint8_t *)key, 0x50u);
                }

                if ((*((unsigned char *)v7 + 152) & 2) != 0)
                {
                  os_log_type_t v128 = __nwlog_obj();
                  if (os_log_type_enabled(v128, OS_LOG_TYPE_DEFAULT))
                  {
                    *(_DWORD *)key = 136446722;
                    *(void *)&key[4] = "nwsc_process_incoming_request";
                    *(_WORD *)&key[12] = 2114;
                    *(void *)&key[14] = v7;
                    *(_WORD *)&key[22] = 2114;
                    *(void *)&key[24] = v5;
                    _os_log_impl(&dword_1830D4000, v128, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ failing incoming connection for testing: %{public}@", (uint8_t *)key, 0x20u);
                  }

                  nw_connection_cancel_current_endpoint(&v5->connection->super);
                }
                id v103 = (id)nwsc_request_create_and_start_connection_inner(v7, 0, v5->endpoint);
                nw_array_append((uint64_t)v7->pendingUnverifiedIncomingRequests, v5);
                goto LABEL_169;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v44 = (id)gLogObj;
              if (os_log_type_enabled((os_log_t)v44, OS_LOG_TYPE_DEFAULT))
              {
                int v109 = v5->signature[0];
                int v110 = v5->signature[1];
                int v111 = v5->signature[2];
                int v112 = v5->signature[3];
                *(_DWORD *)key = 136448770;
                *(void *)&key[4] = "nwsc_process_incoming_request";
                *(_WORD *)&key[12] = 2114;
                *(void *)&key[14] = v7;
                *(_WORD *)&key[22] = 2114;
                *(void *)&key[24] = v5;
                *(_WORD *)&key[32] = 1024;
                *(_DWORD *)&key[34] = v109;
                *(_WORD *)&key[38] = 1024;
                *(_DWORD *)&key[40] = v110;
                *(_WORD *)&key[44] = 1024;
                *(_DWORD *)&key[46] = v111;
                *(_WORD *)&key[50] = 1024;
                *(_DWORD *)&key[52] = v112;
                *(_WORD *)&key[56] = 1024;
                *(_DWORD *)&key[58] = v143;
                *(_WORD *)&key[62] = 1024;
                LODWORD(v150) = BYTE1(v143);
                WORD2(v150) = 1024;
                *(_DWORD *)((char *)&v150 + 6) = BYTE2(v143);
                WORD5(v150) = 1024;
                HIDWORD(v150) = BYTE3(v143);
                _os_log_impl(&dword_1830D4000, (os_log_t)v44, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ signature did not verify on incoming request %{public}@ sig %02x%02x%02x%02x remotePubKey %02x%02x%02x%02x not requesting newer remotePubKey", (uint8_t *)key, 0x50u);
              }
LABEL_113:

LABEL_169:
              goto LABEL_170;
            }
LABEL_50:
            free(v13);
            goto LABEL_51;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v17 = (id)gLogObj;
          LODWORD(buffer[0]) = 136446466;
          *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
          WORD2(buffer[1]) = 2114;
          *(void *)((char *)&buffer[1] + 6) = v9;
          id v18 = (char *)_os_log_send_and_compose_impl();

          buf[0] = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v18, buf, &type))
          {
            if (buf[0] == 17)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v19 = (id)gLogObj;
              os_log_type_t v20 = buf[0];
              if (os_log_type_enabled(v19, (os_log_type_t)buf[0]))
              {
                LODWORD(buffer[0]) = 136446466;
                *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
                WORD2(buffer[1]) = 2114;
                *(void *)((char *)&buffer[1] + 6) = v9;
                _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s Could not get identifier for endpoint %{public}@", (uint8_t *)buffer, 0x16u);
              }
LABEL_39:

              goto LABEL_40;
            }
            if (type == OS_LOG_TYPE_DEFAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v19 = (id)gLogObj;
              os_log_type_t v24 = buf[0];
              if (os_log_type_enabled(v19, (os_log_type_t)buf[0]))
              {
                LODWORD(buffer[0]) = 136446466;
                *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
                WORD2(buffer[1]) = 2114;
                *(void *)((char *)&buffer[1] + 6) = v9;
                _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s Could not get identifier for endpoint %{public}@, backtrace limit exceeded", (uint8_t *)buffer, 0x16u);
              }
              goto LABEL_39;
            }
            os_log_type_t v21 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v19 = (id)gLogObj;
            os_log_type_t v22 = buf[0];
            BOOL v23 = os_log_type_enabled(v19, (os_log_type_t)buf[0]);
            if (!v21)
            {
              if (v23)
              {
                LODWORD(buffer[0]) = 136446466;
                *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
                WORD2(buffer[1]) = 2114;
                *(void *)((char *)&buffer[1] + 6) = v9;
                _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s Could not get identifier for endpoint %{public}@, no backtrace", (uint8_t *)buffer, 0x16u);
              }
              goto LABEL_39;
            }
            if (v23)
            {
              LODWORD(buffer[0]) = 136446722;
              *(void *)((char *)buffer + 4) = "nwsc_get_remote_pub_key";
              WORD2(buffer[1]) = 2114;
              *(void *)((char *)&buffer[1] + 6) = v9;
              HIWORD(buffer[2]) = 2082;
              _OWORD buffer[3] = v21;
              _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s Could not get identifier for endpoint %{public}@, dumping backtrace:%{public}s", (uint8_t *)buffer, 0x20u);
            }

LABEL_26:
            free(v21);
            if (!v18) {
              goto LABEL_42;
            }
            goto LABEL_41;
          }
LABEL_40:
          if (!v18)
          {
LABEL_42:
            unint64_t v28 = 0;
            goto LABEL_52;
          }
LABEL_41:
          free(v18);
          goto LABEL_42;
        }
        uint64_t v115 = __nwlog_obj();
        *(_DWORD *)key = 136446210;
        *(void *)&key[4] = "nwsc_get_remote_pub_key";
        id v18 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(buffer[0]) = 16;
        buf[0] = 0;
        if (!__nwlog_fault(v18, buffer, buf)) {
          goto LABEL_40;
        }
        if (LOBYTE(buffer[0]) == 17)
        {
          uint64_t v94 = __nwlog_obj();
          os_log_type_t v116 = buffer[0];
          if (os_log_type_enabled(v94, buffer[0]))
          {
            *(_DWORD *)key = 136446210;
            *(void *)&key[4] = "nwsc_get_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v94, v116, "%{public}s called with null endpoint", (uint8_t *)key, 0xCu);
          }
        }
        else if (buf[0])
        {
          uint64_t v122 = (char *)__nw_create_backtrace_string();
          uint64_t v94 = __nwlog_obj();
          os_log_type_t v123 = buffer[0];
          BOOL v124 = os_log_type_enabled(v94, buffer[0]);
          if (v122)
          {
            if (v124)
            {
              *(_DWORD *)key = 136446466;
              *(void *)&key[4] = "nwsc_get_remote_pub_key";
              *(_WORD *)&key[12] = 2082;
              *(void *)&key[14] = v122;
              _os_log_impl(&dword_1830D4000, v94, v123, "%{public}s called with null endpoint, dumping backtrace:%{public}s", (uint8_t *)key, 0x16u);
            }

            free(v122);
            goto LABEL_40;
          }
          if (v124)
          {
            *(_DWORD *)key = 136446210;
            *(void *)&key[4] = "nwsc_get_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v94, v123, "%{public}s called with null endpoint, no backtrace", (uint8_t *)key, 0xCu);
          }
        }
        else
        {
          uint64_t v94 = __nwlog_obj();
          os_log_type_t v127 = buffer[0];
          if (os_log_type_enabled(v94, buffer[0]))
          {
            *(_DWORD *)key = 136446210;
            *(void *)&key[4] = "nwsc_get_remote_pub_key";
            _os_log_impl(&dword_1830D4000, v94, v127, "%{public}s called with null endpoint, backtrace limit exceeded", (uint8_t *)key, 0xCu);
          }
        }
LABEL_218:

        goto LABEL_40;
      }
      unsigned int v113 = __nwlog_obj();
      *(_DWORD *)key = 136446210;
      *(void *)&key[4] = "nwsc_get_remote_pub_key";
      id v18 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(buffer[0]) = 16;
      buf[0] = 0;
      if (!__nwlog_fault(v18, buffer, buf)) {
        goto LABEL_40;
      }
      if (LOBYTE(buffer[0]) == 17)
      {
        uint64_t v94 = __nwlog_obj();
        os_log_type_t v114 = buffer[0];
        if (os_log_type_enabled(v94, buffer[0]))
        {
          *(_DWORD *)key = 136446210;
          *(void *)&key[4] = "nwsc_get_remote_pub_key";
          _os_log_impl(&dword_1830D4000, v94, v114, "%{public}s called with null serviceConnector->remotePubKeys", (uint8_t *)key, 0xCu);
        }
        goto LABEL_218;
      }
      if (!buf[0])
      {
        uint64_t v94 = __nwlog_obj();
        os_log_type_t v126 = buffer[0];
        if (os_log_type_enabled(v94, buffer[0]))
        {
          *(_DWORD *)key = 136446210;
          *(void *)&key[4] = "nwsc_get_remote_pub_key";
          _os_log_impl(&dword_1830D4000, v94, v126, "%{public}s called with null serviceConnector->remotePubKeys, backtrace limit exceeded", (uint8_t *)key, 0xCu);
        }
        goto LABEL_218;
      }
      os_log_type_t v21 = (char *)__nw_create_backtrace_string();
      uint64_t v94 = __nwlog_obj();
      os_log_type_t v120 = buffer[0];
      BOOL v121 = os_log_type_enabled(v94, buffer[0]);
      if (!v21)
      {
        if (v121)
        {
          *(_DWORD *)key = 136446210;
          *(void *)&key[4] = "nwsc_get_remote_pub_key";
          _os_log_impl(&dword_1830D4000, v94, v120, "%{public}s called with null serviceConnector->remotePubKeys, no backtrace", (uint8_t *)key, 0xCu);
        }
        goto LABEL_218;
      }
      if (v121)
      {
        *(_DWORD *)key = 136446466;
        *(void *)&key[4] = "nwsc_get_remote_pub_key";
        *(_WORD *)&key[12] = 2082;
        *(void *)&key[14] = v21;
        _os_log_impl(&dword_1830D4000, v94, v120, "%{public}s called with null serviceConnector->remotePubKeys, dumping backtrace:%{public}s", (uint8_t *)key, 0x16u);
      }
    }
    else
    {
      nw_endpoint_type_t v93 = __nwlog_obj();
      *(_DWORD *)key = 136446210;
      *(void *)&key[4] = "nwsc_get_remote_pub_key";
      id v18 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(buffer[0]) = 16;
      buf[0] = 0;
      if (!__nwlog_fault(v18, buffer, buf)) {
        goto LABEL_40;
      }
      if (LOBYTE(buffer[0]) == 17)
      {
        uint64_t v94 = __nwlog_obj();
        os_log_type_t v95 = buffer[0];
        if (os_log_type_enabled(v94, buffer[0]))
        {
          *(_DWORD *)key = 136446210;
          *(void *)&key[4] = "nwsc_get_remote_pub_key";
          _os_log_impl(&dword_1830D4000, v94, v95, "%{public}s called with null serviceConnector", (uint8_t *)key, 0xCu);
        }
        goto LABEL_218;
      }
      if (!buf[0])
      {
        uint64_t v94 = __nwlog_obj();
        os_log_type_t v125 = buffer[0];
        if (os_log_type_enabled(v94, buffer[0]))
        {
          *(_DWORD *)key = 136446210;
          *(void *)&key[4] = "nwsc_get_remote_pub_key";
          _os_log_impl(&dword_1830D4000, v94, v125, "%{public}s called with null serviceConnector, backtrace limit exceeded", (uint8_t *)key, 0xCu);
        }
        goto LABEL_218;
      }
      os_log_type_t v21 = (char *)__nw_create_backtrace_string();
      uint64_t v94 = __nwlog_obj();
      os_log_type_t v118 = buffer[0];
      BOOL v119 = os_log_type_enabled(v94, buffer[0]);
      if (!v21)
      {
        if (v119)
        {
          *(_DWORD *)key = 136446210;
          *(void *)&key[4] = "nwsc_get_remote_pub_key";
          _os_log_impl(&dword_1830D4000, v94, v118, "%{public}s called with null serviceConnector, no backtrace", (uint8_t *)key, 0xCu);
        }
        goto LABEL_218;
      }
      if (v119)
      {
        *(_DWORD *)key = 136446466;
        *(void *)&key[4] = "nwsc_get_remote_pub_key";
        *(_WORD *)&key[12] = 2082;
        *(void *)&key[14] = v21;
        _os_log_impl(&dword_1830D4000, v94, v118, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", (uint8_t *)key, 0x16u);
      }
    }

    goto LABEL_26;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v16 = (id)gLogObj;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)key = 136446722;
    *(void *)&key[4] = "nwsc_process_incoming_request";
    *(_WORD *)&key[12] = 2114;
    *(void *)&key[14] = v130;
    *(_WORD *)&key[22] = 2114;
    *(void *)&key[24] = v5;
    _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ already processed incoming request %{public}@", (uint8_t *)key, 0x20u);
  }

LABEL_170:
}

void sub_183A7DC1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

id nw_service_connector_copy_active_request_for_connection(NWConcrete_nw_service_connector *a1, NWConcrete_nw_connection *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v10, &type, &v30)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (!v30)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v11 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (v19)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(backtrace_string);
    goto LABEL_54;
  }
  uint64_t activeOutgoingRequests = (uint64_t)v3->activeOutgoingRequests;
  if (!activeOutgoingRequests)
  {
    id v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v10, &type, &v30)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null serviceConnector->activeOutgoingRequests", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (!v30)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v11 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (v21)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (v4)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    CFDataRef v33 = __Block_byref_object_copy__49805;
    id v34 = __Block_byref_object_dispose__49806;
    id v35 = 0;
    v27[0] = MEMORY[0x1E4F143A8];
    v27[1] = 3221225472;
    v27[2] = ___ZL55nw_service_connector_copy_active_request_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke;
    v27[3] = &unk_1E524A1A8;
    unint64_t v28 = v4;
    os_log_type_t v29 = buf;
    nw_dictionary_apply(activeOutgoingRequests, (uint64_t)v27);
    id v7 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }
  os_log_type_t v15 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v30 = 0;
  if (__nwlog_fault(v10, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null connection", buf, 0xCu);
      }
LABEL_53:

      goto LABEL_54;
    }
    if (!v30)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
        _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_53;
    }
    if (v23)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_service_connector_copy_active_request_for_connection";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
LABEL_54:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_5:

  return v7;
}

uint64_t ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = *(void **)(a1 + 32);
  uint64_t v6 = v5[4];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke_2;
  block[3] = &unk_1E5249FB0;
  os_log_type_t v10 = v5;
  id v11 = v4;
  uint64_t v12 = *(void *)(a1 + 40);
  id v7 = v4;
  dispatch_async(v6, block);

  return 1;
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_185(uint64_t a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = (id)gLogObj;
  if (os_log_type_enabled(v2, OS_LOG_TYPE_INFO))
  {
    uint64_t v3 = *(void *)(a1 + 32);
    uint64_t v4 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 136446722;
    BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
    __int16 v28 = 2114;
    uint64_t v29 = v3;
    __int16 v30 = 2114;
    uint64_t v31 = v4;
    _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_INFO, "%{public}s %{public}@ disabling keep alives for request %{public}@", buf, 0x20u);
  }

  int v5 = nw_tcp_reset_keepalives(*(void **)(a1 + 48), 0, 0, 0, 0);
  if (v5)
  {
    int v6 = v5;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 136446978;
    BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
    __int16 v28 = 2114;
    uint64_t v29 = v8;
    __int16 v30 = 2114;
    uint64_t v31 = v9;
    __int16 v32 = 1024;
    int v33 = v6;
    os_log_type_t v10 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault((const char *)v10, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_21;
        }
        uint64_t v13 = *(void *)(a1 + 32);
        uint64_t v14 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 136446978;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v13;
        __int16 v30 = 2114;
        uint64_t v31 = v14;
        __int16 v32 = 1024;
        int v33 = v6;
        os_log_type_t v15 = "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d";
        goto LABEL_20;
      }
      if (!v24)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_21;
        }
        uint64_t v20 = *(void *)(a1 + 32);
        uint64_t v21 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 136446978;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v20;
        __int16 v30 = 2114;
        uint64_t v31 = v21;
        __int16 v32 = 1024;
        int v33 = v6;
        os_log_type_t v15 = "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v11 = (id)gLogObj;
      os_log_type_t v12 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v17) {
          goto LABEL_21;
        }
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 136446978;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v22;
        __int16 v30 = 2114;
        uint64_t v31 = v23;
        __int16 v32 = 1024;
        int v33 = v6;
        os_log_type_t v15 = "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d, no backtrace";
LABEL_20:
        _os_log_impl(&dword_1830D4000, v11, v12, v15, buf, 0x26u);
LABEL_21:

        if (!v10) {
          return;
        }
LABEL_14:
        free(v10);
        return;
      }
      if (v17)
      {
        uint64_t v18 = *(void *)(a1 + 32);
        uint64_t v19 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 136447234;
        BOOL v27 = "nw_service_connector_should_accept_connection_block_invoke";
        __int16 v28 = 2114;
        uint64_t v29 = v18;
        __int16 v30 = 2114;
        uint64_t v31 = v19;
        __int16 v32 = 1024;
        int v33 = v6;
        __int16 v34 = 2082;
        id v35 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s %{public}@ error disabling keep alives for request %{public}@ %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x30u);
      }

      free(backtrace_string);
    }
    if (!v10) {
      return;
    }
    goto LABEL_14;
  }
}

void ___ZL45nw_service_connector_should_accept_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke_186(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = a1[4];
      uint64_t v6 = a1[5];
      int v12 = 136446978;
      uint64_t v13 = "nw_service_connector_should_accept_connection_block_invoke";
      __int16 v14 = 2114;
      uint64_t v15 = v5;
      __int16 v16 = 2114;
      uint64_t v17 = v6;
      __int16 v18 = 1024;
      int v19 = a2;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d", (uint8_t *)&v12, 0x26u);
    }

    uint64_t v8 = (void *)a1[4];
    id v7 = (void **)(a1 + 4);
    nw_service_connector_cancel_request_inner(v8, *((void **)v7[1] + 1), (uint64_t)v7[1] + 24, v7[2], 0);
    nw_service_connector_trigger_request_complete_block_inner(*v7, v7[1], 0, 0, a2);
  }
  else
  {
    uint64_t v9 = (void *)a1[4];
    os_log_type_t v10 = (void *)a1[5];
    id v11 = (void *)a1[6];
    nw_service_connector_trigger_request_complete_block_inner(v9, v10, 0, v11, 0);
  }
}

void nw_service_connector_accept_connection_for_request(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v128 = *MEMORY[0x1E4F143B8];
  id v93 = a1;
  id v94 = a2;
  id v7 = a3;
  uint64_t v8 = a4;
  if (v8)
  {
    uint64_t v9 = objc_alloc_init(NWConcrete_nw_unique_connection);
    os_log_type_t v10 = v9;
    if (v9)
    {
      objc_storeStrong((id *)&v9->connection, a2);
      p_endpoint = (void **)&v10->endpoint;
      objc_storeStrong((id *)&v10->endpoint, v7->endpoint);
      unint64_t v12 = 436;
      service = v10->service;
      while (*service)
      {
        ++service;
        if (!--v12) {
          goto LABEL_13;
        }
      }
      if (v12 < 2)
      {
LABEL_12:
        char *service = 0;
      }
      else
      {
        uint64_t v14 = 0;
        while (1)
        {
          int v15 = v7->service[v14];
          service[v14] = v15;
          if (!v15) {
            break;
          }
          --v12;
          ++v14;
          if (v12 <= 1)
          {
            service += v14;
            goto LABEL_12;
          }
        }
      }
LABEL_13:
      *(_OWORD *)v10->uuid = *(_OWORD *)v7->uuid;
      v10->receivedSequenceNumber = v7->sequenceNumber;
      *((unsigned char *)v10 + 500) = *((unsigned char *)v10 + 500) & 0xFE | *((unsigned char *)v7 + 616) & 1;
      if (!v94) {
        goto LABEL_15;
      }
      __int16 v16 = (os_unfair_lock_s *)v94;
      *(void *)BOOL v97 = 0;
      *(void *)&v97[8] = v97;
      *(void *)&v97[16] = 0x2020000000;
      LOBYTE(v9_Block_object_dispose(&a9, 8) = 0;
      uint64_t v17 = v16 + 34;
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E524B978;
      *(void *)&buf[40] = v97;
      __int16 v18 = v16;
      *(void *)&uint8_t buf[32] = v18;
      os_unfair_lock_lock(v17);
      (*(void (**)(uint8_t *))&buf[16])(buf);
      os_unfair_lock_unlock(v17);
      LODWORD(v17) = *(unsigned __int8 *)(*(void *)&v97[8] + 24);

      _Block_object_dispose(v97, 8);
      if (v17)
      {
LABEL_15:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v19 = (id)gLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v93;
          *(_WORD *)&buf[22] = 2114;
          *(void *)&unsigned char buf[24] = v7;
          _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ Bad connection for request %{public}@", buf, 0x20u);
        }

        uint64_t v20 = 57;
LABEL_18:
        v8[2](v8, v20);
LABEL_19:

        goto LABEL_20;
      }
      int connected_socket = nw_connection_get_connected_socket(v18);
      int v22 = connected_socket;
      if (connected_socket < 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v34 = (id)gLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v93;
          *(_WORD *)&buf[22] = 2114;
          *(void *)&unsigned char buf[24] = v18;
          *(_WORD *)&uint8_t buf[32] = 2114;
          *(void *)&buf[34] = v10;
          _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ failed to extract socket of connection %{public}@ for activeConnection %{public}@", buf, 0x2Au);
        }

        uint64_t v35 = 57;
LABEL_79:
        v8[2](v8, v35);
        goto LABEL_19;
      }
      int v23 = dup(connected_socket);
      int v24 = v23;
      if (v23 < 0)
      {
        uint64_t v36 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v37 = (id)gLogObj;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)long long buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v93;
          *(_WORD *)&buf[22] = 1024;
          *(_DWORD *)&unsigned char buf[24] = v22;
          *(_WORD *)&unsigned char buf[28] = 2114;
          *(void *)&buf[30] = v18;
          *(_WORD *)&buf[38] = 2114;
          *(void *)&buf[40] = v10;
          *(_WORD *)&uint8_t buf[48] = 1024;
          *(_DWORD *)&buf[50] = v36;
          _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ failed to dup socket from internal [socket%d] of connection %{public}@ for activeConnection %{public}@ %{darwin.errno}d", buf, 0x36u);
        }

        v8[2](v8, v36);
        goto LABEL_19;
      }
      v10->int dupedSocketFD = v23;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v25 = (id)gLogObj;
      if (os_log_type_enabled(v25, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)long long buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v93;
        *(_WORD *)&buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v24;
        *(_WORD *)&unsigned char buf[28] = 1024;
        *(_DWORD *)&buf[30] = v22;
        *(_WORD *)&buf[34] = 2114;
        *(void *)&buf[36] = v18;
        *(_WORD *)&buf[44] = 2114;
        *(void *)&buf[46] = v10;
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ duped [socket%d] from internal [socket%d] of connection %{public}@ for activeConnection %{public}@", buf, 0x36u);
      }

      id v26 = v93;
      os_log_type_t v91 = v10;
      os_log_type_t v92 = (NWConcrete_nw_service_connector *)v26;
      if (v26)
      {
        if (*((void *)v26 + 11))
        {
          int v127 = 0;
          long long v125 = 0u;
          long long v126 = 0u;
          long long v123 = 0u;
          long long v124 = 0u;
          long long v121 = 0u;
          long long v122 = 0u;
          long long v119 = 0u;
          long long v120 = 0u;
          long long v117 = 0u;
          long long v118 = 0u;
          long long v115 = 0u;
          long long v116 = 0u;
          long long v113 = 0u;
          long long v114 = 0u;
          long long v111 = 0u;
          long long v112 = 0u;
          long long v109 = 0u;
          long long v110 = 0u;
          long long v107 = 0u;
          long long v108 = 0u;
          long long v105 = 0u;
          long long v106 = 0u;
          long long v104 = 0u;
          memset(buf, 0, sizeof(buf));
          if (nwsc_get_identifier(*p_endpoint, (uint64_t)v10->service, buf))
          {
            BOOL v27 = nw_dictionary_copy_value(*((void *)v26 + 11), (uint64_t)buf);
            __int16 v28 = v27;
            if (!v27 || (*((_DWORD *)v27 + 124) & 0x80000000) != 0)
            {
LABEL_74:
              nw_dictionary_set_value(*((void *)v26 + 11), (const char *)buf, v91);

              goto LABEL_75;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v29 = (id)gLogObj;
            *(_DWORD *)BOOL v97 = 136446978;
            *(void *)&v97[4] = "nw_service_connector_add_active_connection";
            *(_WORD *)&v97[12] = 2114;
            id v30 = v26;
            *(void *)&v97[14] = v26;
            *(_WORD *)&v97[22] = 2114;
            os_log_type_t v98 = (char *)v28;
            __int16 v99 = 2114;
            int v100 = (char *)v91;
            uint64_t v31 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v95 = 0;
            if (__nwlog_fault(v31, &type, &v95))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                __int16 v32 = __nwlog_obj();
                os_log_type_t v33 = type;
                if (os_log_type_enabled(v32, type))
                {
                  *(_DWORD *)BOOL v97 = 136446978;
                  *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                  *(_WORD *)&v97[12] = 2114;
                  *(void *)&v97[14] = v30;
                  *(_WORD *)&v97[22] = 2114;
                  os_log_type_t v98 = (char *)v28;
                  __int16 v99 = 2114;
                  int v100 = (char *)v91;
                  _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s %{public}@ previous %{public}@ has socket when adding new %{public}@", v97, 0x2Au);
                }
              }
              else
              {
                if (v95)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  __int16 v48 = __nwlog_obj();
                  os_log_type_t v49 = type;
                  BOOL v50 = os_log_type_enabled(v48, type);
                  if (backtrace_string)
                  {
                    if (v50)
                    {
                      *(_DWORD *)BOOL v97 = 136447234;
                      *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                      *(_WORD *)&v97[12] = 2114;
                      *(void *)&v97[14] = v30;
                      *(_WORD *)&v97[22] = 2114;
                      os_log_type_t v98 = (char *)v28;
                      __int16 v99 = 2114;
                      int v100 = (char *)v91;
                      __int16 v101 = 2082;
                      int v102 = backtrace_string;
                      _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s %{public}@ previous %{public}@ has socket when adding new %{public}@, dumping backtrace:%{public}s", v97, 0x34u);
                    }

                    free(backtrace_string);
                  }
                  else
                  {
                    if (v50)
                    {
                      *(_DWORD *)BOOL v97 = 136446978;
                      *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                      *(_WORD *)&v97[12] = 2114;
                      *(void *)&v97[14] = v30;
                      *(_WORD *)&v97[22] = 2114;
                      os_log_type_t v98 = (char *)v28;
                      __int16 v99 = 2114;
                      int v100 = (char *)v91;
                      _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s %{public}@ previous %{public}@ has socket when adding new %{public}@, no backtrace", v97, 0x2Au);
                    }
                  }
                  goto LABEL_71;
                }
                __int16 v32 = __nwlog_obj();
                os_log_type_t v54 = type;
                if (os_log_type_enabled(v32, type))
                {
                  *(_DWORD *)BOOL v97 = 136446978;
                  *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                  *(_WORD *)&v97[12] = 2114;
                  *(void *)&v97[14] = v30;
                  *(_WORD *)&v97[22] = 2114;
                  os_log_type_t v98 = (char *)v28;
                  __int16 v99 = 2114;
                  int v100 = (char *)v91;
                  _os_log_impl(&dword_1830D4000, v32, v54, "%{public}s %{public}@ previous %{public}@ has socket when adding new %{public}@, backtrace limit exceeded", v97, 0x2Au);
                }
              }
            }
LABEL_71:
            if (v31) {
              free(v31);
            }
            id v26 = v30;
            goto LABEL_74;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v38 = (id)gLogObj;
          int v39 = *p_endpoint;
          *(_DWORD *)BOOL v97 = 136446722;
          *(void *)&v97[4] = "nw_service_connector_add_active_connection";
          *(_WORD *)&v97[12] = 2114;
          *(void *)&v97[14] = v39;
          *(_WORD *)&v97[22] = 2082;
          os_log_type_t v98 = v10->service;
          int v40 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v95 = 0;
          if (__nwlog_fault(v40, &type, &v95))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v41 = (id)gLogObj;
              os_log_type_t v42 = type;
              if (os_log_type_enabled(v41, type))
              {
                uint64_t v43 = *p_endpoint;
                *(_DWORD *)BOOL v97 = 136446722;
                *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                *(_WORD *)&v97[12] = 2114;
                *(void *)&v97[14] = v43;
                *(_WORD *)&v97[22] = 2082;
                os_log_type_t v98 = v10->service;
                _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", v97, 0x20u);
              }
            }
            else if (v95)
            {
              id v44 = (char *)__nw_create_backtrace_string();
              int v41 = __nwlog_obj();
              os_log_type_t v90 = type;
              BOOL v45 = os_log_type_enabled(v41, type);
              if (v44)
              {
                if (v45)
                {
                  os_log_type_t v46 = *p_endpoint;
                  *(_DWORD *)BOOL v97 = 136446978;
                  *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                  *(_WORD *)&v97[12] = 2114;
                  *(void *)&v97[14] = v46;
                  *(_WORD *)&v97[22] = 2082;
                  os_log_type_t v98 = v10->service;
                  __int16 v99 = 2082;
                  int v100 = v44;
                  _os_log_impl(&dword_1830D4000, v41, v90, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", v97, 0x2Au);
                }

                free(v44);
                if (!v40) {
                  goto LABEL_75;
                }
                goto LABEL_64;
              }
              if (v45)
              {
                unint64_t v53 = *p_endpoint;
                *(_DWORD *)BOOL v97 = 136446722;
                *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                *(_WORD *)&v97[12] = 2114;
                *(void *)&v97[14] = v53;
                *(_WORD *)&v97[22] = 2082;
                os_log_type_t v98 = v10->service;
                _os_log_impl(&dword_1830D4000, v41, v90, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", v97, 0x20u);
              }
            }
            else
            {
              int v41 = __nwlog_obj();
              os_log_type_t v51 = type;
              if (os_log_type_enabled(v41, type))
              {
                uint64_t v52 = *p_endpoint;
                *(_DWORD *)BOOL v97 = 136446722;
                *(void *)&v97[4] = "nw_service_connector_add_active_connection";
                *(_WORD *)&v97[12] = 2114;
                *(void *)&v97[14] = v52;
                *(_WORD *)&v97[22] = 2082;
                os_log_type_t v98 = v10->service;
                _os_log_impl(&dword_1830D4000, v41, v51, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", v97, 0x20u);
              }
            }
          }
          goto LABEL_63;
        }
        uint64_t v79 = __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
        int v40 = (char *)_os_log_send_and_compose_impl();

        v97[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v40, v97, &type))
        {
          if (v97[0] == 17)
          {
            os_log_type_t v77 = __nwlog_obj();
            os_log_type_t v80 = v97[0];
            if (os_log_type_enabled(v77, (os_log_type_t)v97[0]))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
              _os_log_impl(&dword_1830D4000, v77, v80, "%{public}s called with null serviceConnector->activeConnections", buf, 0xCu);
            }
LABEL_150:

            goto LABEL_63;
          }
          if (type == OS_LOG_TYPE_DEFAULT)
          {
            os_log_type_t v77 = __nwlog_obj();
            os_log_type_t v89 = v97[0];
            if (os_log_type_enabled(v77, (os_log_type_t)v97[0]))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
              _os_log_impl(&dword_1830D4000, v77, v89, "%{public}s called with null serviceConnector->activeConnections, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_150;
          }
          os_log_type_t v85 = (char *)__nw_create_backtrace_string();
          BOOL v82 = __nwlog_obj();
          os_log_type_t v86 = v97[0];
          BOOL v87 = os_log_type_enabled(v82, (os_log_type_t)v97[0]);
          if (v85)
          {
            if (v87)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v85;
              _os_log_impl(&dword_1830D4000, v82, v86, "%{public}s called with null serviceConnector->activeConnections, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v85);
            if (!v40) {
              goto LABEL_75;
            }
            goto LABEL_64;
          }
          if (v87)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
            _os_log_impl(&dword_1830D4000, v82, v86, "%{public}s called with null serviceConnector->activeConnections, no backtrace", buf, 0xCu);
          }
          goto LABEL_153;
        }
      }
      else
      {
        long long v76 = __nwlog_obj();
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
        int v40 = (char *)_os_log_send_and_compose_impl();

        v97[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v40, v97, &type)) {
          goto LABEL_63;
        }
        if (v97[0] == 17)
        {
          os_log_type_t v77 = __nwlog_obj();
          os_log_type_t v78 = v97[0];
          if (os_log_type_enabled(v77, (os_log_type_t)v97[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
            _os_log_impl(&dword_1830D4000, v77, v78, "%{public}s called with null serviceConnector", buf, 0xCu);
          }
          goto LABEL_150;
        }
        if (type == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v77 = __nwlog_obj();
          os_log_type_t v88 = v97[0];
          if (os_log_type_enabled(v77, (os_log_type_t)v97[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
            _os_log_impl(&dword_1830D4000, v77, v88, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_150;
        }
        os_log_type_t v81 = (char *)__nw_create_backtrace_string();
        BOOL v82 = __nwlog_obj();
        os_log_type_t v83 = v97[0];
        BOOL v84 = os_log_type_enabled(v82, (os_log_type_t)v97[0]);
        if (!v81)
        {
          if (v84)
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
            _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
          }
LABEL_153:

          goto LABEL_63;
        }
        if (v84)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_active_connection";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v81;
          _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v81);
      }
LABEL_63:
      if (!v40)
      {
LABEL_75:

        if (*((unsigned char *)v7 + 616))
        {
          if (nw_service_connector_get_new_sequence_number(void)::onceToken != -1) {
            dispatch_once(&nw_service_connector_get_new_sequence_number(void)::onceToken, &__block_literal_global_191);
          }
          for (unint64_t i = atomic_fetch_add(&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber, 1uLL);
                !i;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v57 = (id)gLogObj;
          if (os_log_type_enabled(v57, OS_LOG_TYPE_DEFAULT))
          {
            *(_DWORD *)long long buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v92;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&unsigned char buf[24] = v7;
            *(_WORD *)&uint8_t buf[32] = 2114;
            *(void *)&buf[34] = v91;
            *(_WORD *)&buf[42] = 2048;
            *(void *)&buf[44] = i;
            _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ accepting incoming request %{public}@ activeConnection %{public}@ reply seq %llu", buf, 0x34u);
          }

          nwsc_send_feedback(v92, v18, i, 1, 0, v8);
          goto LABEL_19;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v55 = (id)gLogObj;
        if (os_log_type_enabled(v55, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v92;
          *(_WORD *)&buf[22] = 2114;
          *(void *)&unsigned char buf[24] = v18;
          *(_WORD *)&uint8_t buf[32] = 2114;
          *(void *)&buf[34] = v91;
          _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ outgoing connection %{public}@ was accepted activeConnection %{public}@", buf, 0x2Au);
        }

        nw_service_connector_remove_active_outgoing_request(v92, v7);
        uint64_t v35 = 0;
        goto LABEL_79;
      }
LABEL_64:
      free(v40);
      goto LABEL_75;
    }
    os_log_type_t v62 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
    BOOL v63 = (char *)_os_log_send_and_compose_impl();

    v97[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v63, v97, &type))
    {
      if (v97[0] == 17)
      {
        BOOL v64 = __nwlog_obj();
        os_log_type_t v65 = v97[0];
        if (os_log_type_enabled(v64, (os_log_type_t)v97[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
          _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s [nw_unique_connection init:] failed", buf, 0xCu);
        }
      }
      else
      {
        if (type)
        {
          os_log_type_t v70 = (char *)__nw_create_backtrace_string();
          os_log_type_t v71 = __nwlog_obj();
          os_log_type_t v72 = v97[0];
          BOOL v73 = os_log_type_enabled(v71, (os_log_type_t)v97[0]);
          if (v70)
          {
            if (v73)
            {
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v70;
              _os_log_impl(&dword_1830D4000, v71, v72, "%{public}s [nw_unique_connection init:] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v70);
          }
          else
          {
            if (v73)
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
              _os_log_impl(&dword_1830D4000, v71, v72, "%{public}s [nw_unique_connection init:] failed, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_121;
        }
        BOOL v64 = __nwlog_obj();
        os_log_type_t v75 = v97[0];
        if (os_log_type_enabled(v64, (os_log_type_t)v97[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
          _os_log_impl(&dword_1830D4000, v64, v75, "%{public}s [nw_unique_connection init:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_121:
    if (v63) {
      free(v63);
    }
    uint64_t v20 = 12;
    goto LABEL_18;
  }
  uint64_t v58 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
  *(_WORD *)&unsigned char buf[12] = 2114;
  *(void *)&buf[14] = v93;
  *(_WORD *)&buf[22] = 2114;
  *(void *)&unsigned char buf[24] = v7;
  char v59 = (char *)_os_log_send_and_compose_impl();

  v97[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v59, v97, &type))
  {
    if (v97[0] == 17)
    {
      uint64_t v60 = __nwlog_obj();
      os_log_type_t v61 = v97[0];
      if (os_log_type_enabled(v60, (os_log_type_t)v97[0]))
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v93;
        *(_WORD *)&buf[22] = 2114;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s %{public}@ Expected completion block %{public}@", buf, 0x20u);
      }
    }
    else
    {
      if (type)
      {
        id v66 = (char *)__nw_create_backtrace_string();
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v68 = v97[0];
        BOOL v69 = os_log_type_enabled(v67, (os_log_type_t)v97[0]);
        if (v66)
        {
          if (v69)
          {
            *(_DWORD *)long long buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v93;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&unsigned char buf[24] = v7;
            *(_WORD *)&uint8_t buf[32] = 2082;
            *(void *)&buf[34] = v66;
            _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s %{public}@ Expected completion block %{public}@, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v66);
        }
        else
        {
          if (v69)
          {
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
            *(_WORD *)&unsigned char buf[12] = 2114;
            *(void *)&buf[14] = v93;
            *(_WORD *)&buf[22] = 2114;
            *(void *)&unsigned char buf[24] = v7;
            _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s %{public}@ Expected completion block %{public}@, no backtrace", buf, 0x20u);
          }
        }
        goto LABEL_116;
      }
      uint64_t v60 = __nwlog_obj();
      os_log_type_t v74 = v97[0];
      if (os_log_type_enabled(v60, (os_log_type_t)v97[0]))
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_service_connector_accept_connection_for_request";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v93;
        *(_WORD *)&buf[22] = 2114;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl(&dword_1830D4000, v60, v74, "%{public}s %{public}@ Expected completion block %{public}@, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
LABEL_116:
  if (v59) {
    free(v59);
  }
LABEL_20:
}

void sub_183A800F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL24nwsc_save_remote_pub_keyP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObjectyPh_block_invoke_2(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)(*(void *)(a1 + 32) + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      uint64_t v3 = *(void *)(a1 + 32);
      uint64_t v4 = *(void **)(a1 + 40);
      uint64_t v5 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key_block_invoke_2";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v3;
      *(_WORD *)&buf[22] = 2114;
      int v24 = v4;
      LOWORD(v25) = 2048;
      *(void *)((char *)&v25 + 2) = v5;
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, not reevaluating %{public}@ due to received seq %llu", buf, 0x2Au);
    }
  }
  else
  {
    uint64_t v6 = *(void **)(*(void *)(a1 + 40) + 576);
    if (!v6) {
      goto LABEL_7;
    }
    id v7 = v6;
    uint64_t v19 = 0;
    uint64_t v20 = &v19;
    uint64_t v21 = 0x2020000000;
    char v22 = 0;
    uint64_t v8 = v7 + 34;
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 3221225472;
    *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
    int v24 = &unk_1E524B978;
    *((void *)&v25 + 1) = &v19;
    uint64_t v9 = v7;
    *(void *)&long long v25 = v9;
    os_unfair_lock_lock(v8);
    (*(void (**)(unsigned char *))&buf[16])(buf);
    os_unfair_lock_unlock(v8);
    LODWORD(v_Block_object_dispose(&a9, 8) = *((unsigned __int8 *)v20 + 24);

    _Block_object_dispose(&v19, 8);
    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v15 = (id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v16 = *(void *)(a1 + 32);
        uint64_t v17 = *(void **)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v16;
        *(_WORD *)&buf[22] = 2114;
        int v24 = v17;
        LOWORD(v25) = 2048;
        *(void *)((char *)&v25 + 2) = v18;
        _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ reevaluating %{public}@ due to received seq %llu", buf, 0x2Au);
      }

      nwsc_process_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 32), *(NWConcrete_nw_unique_connection_request **)(a1 + 40));
    }
    else
    {
LABEL_7:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v11 = *(void *)(a1 + 32);
        unint64_t v12 = *(void **)(a1 + 40);
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nwsc_save_remote_pub_key_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v11;
        *(_WORD *)&buf[22] = 2114;
        int v24 = v12;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ removing unverified incoming request %{public}@ with bad connection", buf, 0x20u);
      }

      uint64_t v13 = *(NWConcrete_nw_unique_connection_request **)(a1 + 40);
      p_super = &v13->connection->super;
      if (p_super)
      {
        nw_connection_cancel(p_super);
        uint64_t v13 = *(NWConcrete_nw_unique_connection_request **)(a1 + 40);
      }
      nw_service_connector_remove_pending_unverified_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 32), v13);
    }
  }
}

void nw_service_connector_remove_pending_unverified_incoming_request(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  uint64_t v4 = a2;
  uint64_t v5 = (uint64_t)v4;
  if (!v3)
  {
    id v7 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)long long buf = 136446466;
          id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
          __int16 v30 = 2082;
          uint64_t v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_57:
        if (!v8) {
          goto LABEL_7;
        }
LABEL_58:
        free(v8);
        goto LABEL_7;
      }
      if (v17)
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_56:

    goto LABEL_57;
  }
  if (!v3->pendingUnverifiedIncomingRequests)
  {
    uint64_t v11 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v26)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    uint64_t v18 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v20)
    {
      *(_DWORD *)long long buf = 136446466;
      id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null serviceConnector->pendingUnverifiedIncomingRequests, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_37;
  }
  if (!v4)
  {
    uint64_t v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v8, &type, &v26)) {
      goto LABEL_57;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null request", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (!v26)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_56;
    }
    uint64_t v18 = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)long long buf = 136446210;
        id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
      goto LABEL_56;
    }
    if (v22)
    {
      *(_DWORD *)long long buf = 136446466;
      id v29 = "nw_service_connector_remove_pending_unverified_incoming_request";
      __int16 v30 = 2082;
      uint64_t v31 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_37:

    free(v18);
    if (!v8) {
      goto LABEL_7;
    }
    goto LABEL_58;
  }
  incomingReqBytesToVerify = v4->incomingReqBytesToVerify;
  if (incomingReqBytesToVerify)
  {
    free(incomingReqBytesToVerify);
    *(void *)(v5 + 560) = 0;
  }
  *(_DWORD *)(v5 + 56_Block_object_dispose(&a9, 8) = 0;
  nw_array_remove_object((uint64_t)v3->pendingUnverifiedIncomingRequests, v5);
LABEL_7:
}

BOOL ___ZL55nw_service_connector_copy_active_request_for_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connection_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a3;
  uint64_t v6 = v5[72];
  uint64_t v7 = *(void *)(a1 + 32);
  if (v6 == v7) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return v6 != v7;
}

void nw_service_connector_reject_incoming_request(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, int a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  uint64_t v6 = a2;
  uint64_t v7 = v6;
  char v8 = *((unsigned char *)v6 + 616);
  if (v8)
  {
    uint64_t rejectTimer = (uint64_t)v6->rejectTimer;
    if (rejectTimer)
    {
      nw_queue_cancel_source(rejectTimer);
      v7->uint64_t rejectTimer = 0;
      char v8 = *((unsigned char *)v7 + 616);
    }
    if ((v8 & 2) == 0) {
      goto LABEL_49;
    }
    os_log_type_t v14 = v5;
    int v15 = v7;
    os_log_type_t v16 = v15;
    if (v14)
    {
      if (v14[10])
      {
        int v90 = 0;
        long long v88 = 0u;
        long long v89 = 0u;
        long long v86 = 0u;
        long long v87 = 0u;
        long long v84 = 0u;
        long long v85 = 0u;
        long long v82 = 0u;
        long long v83 = 0u;
        long long v80 = 0u;
        long long v81 = 0u;
        long long v78 = 0u;
        long long v79 = 0u;
        long long v76 = 0u;
        long long v77 = 0u;
        long long v74 = 0u;
        long long v75 = 0u;
        long long v72 = 0u;
        long long v73 = 0u;
        long long v70 = 0u;
        long long v71 = 0u;
        long long v68 = 0u;
        long long v69 = 0u;
        long long v66 = 0u;
        long long v67 = 0u;
        long long v65 = 0u;
        memset(buf, 0, sizeof(buf));
        if (nwsc_get_identifier(v15->endpoint, (uint64_t)v15->service, buf))
        {
          nw_dictionary_set_value(v14[10], (const char *)buf, 0);
          goto LABEL_48;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (id)gLogObj;
        endpoint = v16->endpoint;
        *(_DWORD *)os_log_type_t type = 136446722;
        os_log_type_t v57 = "nw_service_connector_remove_pending_incoming_request";
        __int16 v58 = 2114;
        char v59 = endpoint;
        __int16 v60 = 2082;
        service = v16->service;
        BOOL v22 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t v55 = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault((const char *)v22, &v55, &v54))
        {
          if (v55 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v23 = (id)gLogObj;
            os_log_type_t v24 = v55;
            if (os_log_type_enabled(v23, v55))
            {
              os_log_type_t v25 = v16->endpoint;
              *(_DWORD *)os_log_type_t type = 136446722;
              os_log_type_t v57 = "nw_service_connector_remove_pending_incoming_request";
              __int16 v58 = 2114;
              char v59 = v25;
              __int16 v60 = 2082;
              service = v16->service;
              _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", (uint8_t *)type, 0x20u);
            }
LABEL_45:

            goto LABEL_46;
          }
          if (!v54)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v23 = (id)gLogObj;
            os_log_type_t v32 = v55;
            if (os_log_type_enabled(v23, v55))
            {
              os_log_type_t v33 = v16->endpoint;
              *(_DWORD *)os_log_type_t type = 136446722;
              os_log_type_t v57 = "nw_service_connector_remove_pending_incoming_request";
              __int16 v58 = 2114;
              char v59 = v33;
              __int16 v60 = 2082;
              service = v16->service;
              _os_log_impl(&dword_1830D4000, v23, v32, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", (uint8_t *)type, 0x20u);
            }
            goto LABEL_45;
          }
          backtrace_string = __nw_create_backtrace_string();
          if (!backtrace_string)
          {
            os_log_type_t v23 = __nwlog_obj();
            os_log_type_t v34 = v55;
            if (os_log_type_enabled(v23, v55))
            {
              uint64_t v35 = v16->endpoint;
              *(_DWORD *)os_log_type_t type = 136446722;
              os_log_type_t v57 = "nw_service_connector_remove_pending_incoming_request";
              __int16 v58 = 2114;
              char v59 = v35;
              __int16 v60 = 2082;
              service = v16->service;
              _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", (uint8_t *)type, 0x20u);
            }
            goto LABEL_45;
          }
          __int16 v28 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v29 = (id)gLogObj;
          os_log_type_t v30 = v55;
          if (os_log_type_enabled(v29, v55))
          {
            uint64_t v31 = v16->endpoint;
            *(_DWORD *)os_log_type_t type = 136446978;
            os_log_type_t v57 = "nw_service_connector_remove_pending_incoming_request";
            __int16 v58 = 2114;
            char v59 = v31;
            __int16 v60 = 2082;
            service = v16->service;
            __int16 v62 = 2082;
            BOOL v63 = v28;
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", (uint8_t *)type, 0x2Au);
          }

LABEL_33:
          free(v28);
          if (!v22)
          {
LABEL_48:

            char v36 = *((unsigned char *)v7 + 616);
            *((unsigned char *)v7 + 616) = v36 & 0xFD;
            if ((v36 & 4) != 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              int v41 = (id)gLogObj;
              if (os_log_type_enabled(v41, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
                *(_WORD *)&unsigned char buf[12] = 2114;
                *(void *)&buf[14] = v14;
                *(_WORD *)&buf[22] = 2114;
                *(void *)&unsigned char buf[24] = v16;
                _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ not rejecting accepted incoming request %{public}@", buf, 0x20u);
              }

              goto LABEL_60;
            }
LABEL_49:
            if (v7->connection)
            {
              if (nw_service_connector_get_new_sequence_number(void)::onceToken != -1) {
                dispatch_once(&nw_service_connector_get_new_sequence_number(void)::onceToken, &__block_literal_global_191);
              }
              for (unint64_t i = atomic_fetch_add(&nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber, 1uLL);
                    !i;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              id v38 = (id)gLogObj;
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
                *(_WORD *)&unsigned char buf[12] = 2114;
                *(void *)&buf[14] = v5;
                *(_WORD *)&buf[22] = 2114;
                *(void *)&unsigned char buf[24] = v7;
                LOWORD(v65) = 2048;
                *(void *)((char *)&v65 + 2) = i;
                _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ rejecting incoming request %{public}@ reply seq %llu", buf, 0x2Au);
              }

              connection = v7->connection;
              v7->connection = 0;
              int v40 = connection;

              nwsc_send_feedback(v5, v40, i, 0, a3, 0);
            }
            goto LABEL_60;
          }
LABEL_47:
          free(v22);
          goto LABEL_48;
        }
LABEL_46:
        if (!v22) {
          goto LABEL_48;
        }
        goto LABEL_47;
      }
      BOOL v45 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
      BOOL v22 = (void *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault((const char *)v22, type, &v55)) {
        goto LABEL_46;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v43, v46, "%{public}s called with null serviceConnector->pendingIncomingRequests", buf, 0xCu);
        }
      }
      else if (v55)
      {
        __int16 v28 = (char *)__nw_create_backtrace_string();
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v50 = type[0];
        BOOL v51 = os_log_type_enabled(v43, type[0]);
        if (v28)
        {
          if (v51)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v28;
            _os_log_impl(&dword_1830D4000, v43, v50, "%{public}s called with null serviceConnector->pendingIncomingRequests, dumping backtrace:%{public}s", buf, 0x16u);
          }

          goto LABEL_33;
        }
        if (v51)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v43, v50, "%{public}s called with null serviceConnector->pendingIncomingRequests, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v53 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v43, v53, "%{public}s called with null serviceConnector->pendingIncomingRequests, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    else
    {
      os_log_type_t v42 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
      BOOL v22 = (void *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault((const char *)v22, type, &v55)) {
        goto LABEL_46;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v44 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s called with null serviceConnector", buf, 0xCu);
        }
      }
      else if (v55)
      {
        os_log_type_t v47 = (char *)__nw_create_backtrace_string();
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v48 = type[0];
        BOOL v49 = os_log_type_enabled(v43, type[0]);
        if (v47)
        {
          if (v49)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v47;
            _os_log_impl(&dword_1830D4000, v43, v48, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v47);
          goto LABEL_46;
        }
        if (v49)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v43, v48, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v43 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        if (os_log_type_enabled(v43, type[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_remove_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v43, v52, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_46;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v9 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
  *(_WORD *)&unsigned char buf[12] = 2114;
  *(void *)&buf[14] = v5;
  *(_WORD *)&buf[22] = 2114;
  *(void *)&unsigned char buf[24] = v7;
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v55 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v10, type, &v55))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&buf[22] = 2114;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s %{public}@ attempted to reject outgoing request %{public}@", buf, 0x20u);
      }
    }
    else if (v55)
    {
      BOOL v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v18 = type[0];
      BOOL v19 = os_log_type_enabled(v11, type[0]);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v5;
          *(_WORD *)&buf[22] = 2114;
          *(void *)&unsigned char buf[24] = v7;
          LOWORD(v65) = 2082;
          *(void *)((char *)&v65 + 2) = v17;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s %{public}@ attempted to reject outgoing request %{public}@, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v17);
        if (v10) {
          goto LABEL_39;
        }
        goto LABEL_60;
      }
      if (v19)
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&buf[22] = 2114;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s %{public}@ attempted to reject outgoing request %{public}@, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v26 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_service_connector_reject_incoming_request";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v5;
        *(_WORD *)&buf[22] = 2114;
        *(void *)&unsigned char buf[24] = v7;
        _os_log_impl(&dword_1830D4000, v11, v26, "%{public}s %{public}@ attempted to reject outgoing request %{public}@, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
  if (v10) {
LABEL_39:
  }
    free(v10);
LABEL_60:
}

void sub_183A8191C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 48);
      int v10 = 136446978;
      uint64_t v11 = "nwsc_process_incoming_request_block_invoke";
      __int16 v12 = 2114;
      uint64_t v13 = v5;
      __int16 v14 = 2114;
      uint64_t v15 = v6;
      __int16 v16 = 1024;
      int v17 = a2;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d", (uint8_t *)&v10, 0x26u);
    }

    nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), *(void **)(*(void *)(a1 + 48) + 8), *(void *)(a1 + 48) + 24, *(void **)(*(void *)(a1 + 48) + 576), 0);
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), *(void **)(a1 + 40), 0, 0, a2);
  }
  else
  {
    uint64_t v7 = *(void **)(a1 + 32);
    char v8 = *(void **)(a1 + 40);
    id v9 = *(void **)(*(void *)(a1 + 48) + 576);
    nw_service_connector_trigger_request_complete_block_inner(v7, v8, 0, v9, 0);
  }
}

void nw_service_connector_handle_unsolicited_requests(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  uint64_t v4 = a2;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_service_connector_handle_unsolicited_requests";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v3;
    *(_WORD *)&buf[22] = 2114;
    *(void *)&unsigned char buf[24] = v4;
    _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ handling unsolicited incoming request %{public}@", buf, 0x20u);
  }

  uint64_t v6 = (NWConcrete_nw_unique_connection_request *)nw_service_connector_copy_pending_incoming_request(v3, v4->endpoint, (uint64_t)v4->service);
  uint64_t v7 = v6;
  if (!v6)
  {
LABEL_11:

    __int16 v12 = v3;
    uint64_t v13 = v4;
    __int16 v14 = v13;
    if (v12)
    {
      if (v12->pendingIncomingRequests)
      {
        *((unsigned char *)v13 + 616) |= 2u;
        int v83 = 0;
        long long v81 = 0u;
        long long v82 = 0u;
        long long v79 = 0u;
        long long v80 = 0u;
        long long v77 = 0u;
        long long v78 = 0u;
        long long v75 = 0u;
        long long v76 = 0u;
        long long v73 = 0u;
        long long v74 = 0u;
        long long v71 = 0u;
        long long v72 = 0u;
        long long v69 = 0u;
        long long v70 = 0u;
        long long v67 = 0u;
        long long v68 = 0u;
        long long v65 = 0u;
        long long v66 = 0u;
        long long v63 = 0u;
        long long v64 = 0u;
        long long v61 = 0u;
        long long v62 = 0u;
        long long v59 = 0u;
        long long v60 = 0u;
        long long v58 = 0u;
        memset(buf, 0, sizeof(buf));
        if (nwsc_get_identifier(v4->endpoint, (uint64_t)v4->service, buf))
        {
          nw_dictionary_set_value((uint64_t)v12->pendingIncomingRequests, (const char *)buf, v14);
LABEL_35:

          serviceConnectorQueue = v12->serviceConnectorQueue;
          block[0] = MEMORY[0x1E4F143A8];
          block[1] = 3221225472;
          block[2] = ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke;
          block[3] = &unk_1E524B9A0;
          BOOL v45 = v12;
          os_log_type_t v46 = v14;
          dispatch_async(serviceConnectorQueue, block);

          uint64_t v7 = v45;
          goto LABEL_36;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v15 = (id)gLogObj;
        endpoint = v4->endpoint;
        *(_DWORD *)BOOL v49 = 136446722;
        os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
        __int16 v51 = 2114;
        os_log_type_t v52 = endpoint;
        __int16 v53 = 2082;
        service = v4->service;
        int v17 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v47 = 0;
        if (__nwlog_fault(v17, &type, &v47))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = (id)gLogObj;
            os_log_type_t v19 = type;
            if (os_log_type_enabled(v18, type))
            {
              id v20 = v4->endpoint;
              *(_DWORD *)BOOL v49 = 136446722;
              os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
              __int16 v51 = 2114;
              os_log_type_t v52 = v20;
              __int16 v53 = 2082;
              service = v4->service;
              _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", v49, 0x20u);
            }
          }
          else if (v47)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = (id)gLogObj;
            os_log_type_t v22 = type;
            BOOL v23 = os_log_type_enabled(v18, type);
            if (backtrace_string)
            {
              if (v23)
              {
                os_log_type_t v24 = v4->endpoint;
                *(_DWORD *)BOOL v49 = 136446978;
                os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
                __int16 v51 = 2114;
                os_log_type_t v52 = v24;
                __int16 v53 = 2082;
                service = v4->service;
                __int16 v55 = 2082;
                long long v56 = backtrace_string;
                _os_log_impl(&dword_1830D4000, v18, v22, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", v49, 0x2Au);
              }

              free(backtrace_string);
              if (!v17) {
                goto LABEL_35;
              }
LABEL_33:
              __int16 v28 = (char *)v17;
LABEL_34:
              free(v28);
              goto LABEL_35;
            }
            if (v23)
            {
              BOOL v27 = v4->endpoint;
              *(_DWORD *)BOOL v49 = 136446722;
              os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
              __int16 v51 = 2114;
              os_log_type_t v52 = v27;
              __int16 v53 = 2082;
              service = v4->service;
              _os_log_impl(&dword_1830D4000, v18, v22, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", v49, 0x20u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v18 = (id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v18, type))
            {
              os_log_type_t v26 = v4->endpoint;
              *(_DWORD *)BOOL v49 = 136446722;
              os_log_type_t v50 = "nw_service_connector_add_pending_incoming_request";
              __int16 v51 = 2114;
              os_log_type_t v52 = v26;
              __int16 v53 = 2082;
              service = v4->service;
              _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", v49, 0x20u);
            }
          }
        }
        if (!v17) {
          goto LABEL_35;
        }
        goto LABEL_33;
      }
      os_log_type_t v34 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
      uint64_t v31 = (const char *)_os_log_send_and_compose_impl();

      v49[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v31, v49, &type)) {
        goto LABEL_70;
      }
      if (v49[0] == 17)
      {
        os_log_type_t v32 = __nwlog_obj();
        os_log_type_t v35 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v32, v35, "%{public}s called with null serviceConnector->pendingIncomingRequests", buf, 0xCu);
        }
      }
      else if (type)
      {
        int v39 = (char *)__nw_create_backtrace_string();
        os_log_type_t v32 = __nwlog_obj();
        os_log_type_t v40 = v49[0];
        BOOL v41 = os_log_type_enabled(v32, (os_log_type_t)v49[0]);
        if (v39)
        {
          if (v41)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v39;
            _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null serviceConnector->pendingIncomingRequests, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v39);
          if (!v31) {
            goto LABEL_35;
          }
LABEL_71:
          __int16 v28 = (char *)v31;
          goto LABEL_34;
        }
        if (v41)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null serviceConnector->pendingIncomingRequests, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v32 = __nwlog_obj();
        os_log_type_t v43 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v32, v43, "%{public}s called with null serviceConnector->pendingIncomingRequests, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    else
    {
      os_log_type_t v30 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
      uint64_t v31 = (const char *)_os_log_send_and_compose_impl();

      v49[0] = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v31, v49, &type)) {
        goto LABEL_70;
      }
      if (v49[0] == 17)
      {
        os_log_type_t v32 = __nwlog_obj();
        os_log_type_t v33 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null serviceConnector", buf, 0xCu);
        }
      }
      else if (type)
      {
        char v36 = (char *)__nw_create_backtrace_string();
        os_log_type_t v32 = __nwlog_obj();
        os_log_type_t v37 = v49[0];
        BOOL v38 = os_log_type_enabled(v32, (os_log_type_t)v49[0]);
        if (v36)
        {
          if (v38)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v36;
            _os_log_impl(&dword_1830D4000, v32, v37, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v36);
LABEL_70:
          if (!v31) {
            goto LABEL_35;
          }
          goto LABEL_71;
        }
        if (v38)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v32, v37, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v32 = __nwlog_obj();
        os_log_type_t v42 = v49[0];
        if (os_log_type_enabled(v32, (os_log_type_t)v49[0]))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_service_connector_add_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v32, v42, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_70;
  }
  unint64_t sequenceNumber = v6->sequenceNumber;
  unint64_t v9 = v4->sequenceNumber;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v10 = (id)gLogObj;
  BOOL v11 = os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT);
  if (sequenceNumber <= v9)
  {
    if (v11)
    {
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_service_connector_handle_unsolicited_requests";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v3;
      *(_WORD *)&buf[22] = 2114;
      *(void *)&unsigned char buf[24] = v7;
      LOWORD(v5_Block_object_dispose(&a9, 8) = 2114;
      *(void *)((char *)&v58 + 2) = v4;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ rejecting %{public}@ in favor of %{public}@", buf, 0x2Au);
    }

    nw_service_connector_reject_incoming_request(v3, v7, 0);
    goto LABEL_11;
  }
  if (v11)
  {
    *(_DWORD *)long long buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_service_connector_handle_unsolicited_requests";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v3;
    *(_WORD *)&buf[22] = 2114;
    *(void *)&unsigned char buf[24] = v4;
    LOWORD(v5_Block_object_dispose(&a9, 8) = 2114;
    *(void *)((char *)&v58 + 2) = v7;
    _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ rejecting %{public}@ in favor of %{public}@", buf, 0x2Au);
  }

  nw_service_connector_reject_incoming_request(v3, v4, 0);
LABEL_36:
}

void sub_183A82574(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nwsc_process_incoming_requestP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_198(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 48);
      int v10 = 136446978;
      BOOL v11 = "nwsc_process_incoming_request_block_invoke";
      __int16 v12 = 2114;
      uint64_t v13 = v5;
      __int16 v14 = 2114;
      uint64_t v15 = v6;
      __int16 v16 = 1024;
      int v17 = a2;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d", (uint8_t *)&v10, 0x26u);
    }

    nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), *(void **)(*(void *)(a1 + 48) + 8), *(void *)(a1 + 48) + 24, *(void **)(*(void *)(a1 + 48) + 576), 0);
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), *(void **)(a1 + 40), 0, 0, a2);
  }
  else
  {
    uint64_t v7 = *(void **)(a1 + 32);
    char v8 = *(void **)(a1 + 40);
    unint64_t v9 = *(void **)(*(void *)(a1 + 48) + 576);
    nw_service_connector_trigger_request_complete_block_inner(v7, v8, 0, v9, 0);
  }
}

void *nw_service_connector_copy_pending_incoming_request(void *a1, void *a2, uint64_t a3)
{
  uint64_t v79 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (!v5)
  {
    os_log_type_t v19 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
    id v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v20, buf, &type)) {
      goto LABEL_69;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null serviceConnector", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v38 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v38, "%{public}s called with null serviceConnector, backtrace limit exceeded", v52, 0xCu);
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v30 = buf[0];
    BOOL v31 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s called with null serviceConnector, no backtrace", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (v31)
    {
      *(_DWORD *)os_log_type_t v52 = 136446466;
      *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", v52, 0x16u);
    }
LABEL_68:

    free(backtrace_string);
    goto LABEL_69;
  }
  if (!v5[10])
  {
    BOOL v23 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
    id v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v20, buf, &type)) {
      goto LABEL_69;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v24 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null serviceConnector->pendingIncomingRequests", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v39 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v39, "%{public}s called with null serviceConnector->pendingIncomingRequests, backtrace limit exceeded", v52, 0xCu);
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v32 = buf[0];
    BOOL v33 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v33)
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null serviceConnector->pendingIncomingRequests, no backtrace", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (v33)
    {
      *(_DWORD *)os_log_type_t v52 = 136446466;
      *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null serviceConnector->pendingIncomingRequests, dumping backtrace:%{public}s", v52, 0x16u);
    }
    goto LABEL_68;
  }
  if (!v6)
  {
    os_log_type_t v25 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
    id v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v20, buf, &type)) {
      goto LABEL_69;
    }
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null endpoint", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v40 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v40, "%{public}s called with null endpoint, backtrace limit exceeded", v52, 0xCu);
      }
      goto LABEL_94;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v21 = __nwlog_obj();
    os_log_type_t v34 = buf[0];
    BOOL v35 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)os_log_type_t v52 = 136446210;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null endpoint, no backtrace", v52, 0xCu);
      }
      goto LABEL_94;
    }
    if (v35)
    {
      *(_DWORD *)os_log_type_t v52 = 136446466;
      *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
      *(_WORD *)&v52[12] = 2082;
      *(void *)&v52[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v21, v34, "%{public}s called with null endpoint, dumping backtrace:%{public}s", v52, 0x16u);
    }
    goto LABEL_68;
  }
  if (!a3)
  {
    BOOL v27 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v52 = 136446210;
    *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
    id v20 = (const char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v20, buf, &type))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v21 = __nwlog_obj();
        os_log_type_t v28 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v52 = 136446210;
          *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v21, v28, "%{public}s called with null service", v52, 0xCu);
        }
LABEL_94:

        goto LABEL_69;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v21 = __nwlog_obj();
        os_log_type_t v41 = buf[0];
        if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v52 = 136446210;
          *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v21, v41, "%{public}s called with null service, backtrace limit exceeded", v52, 0xCu);
        }
        goto LABEL_94;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v36 = buf[0];
      BOOL v37 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (!backtrace_string)
      {
        if (v37)
        {
          *(_DWORD *)os_log_type_t v52 = 136446210;
          *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
          _os_log_impl(&dword_1830D4000, v21, v36, "%{public}s called with null service, no backtrace", v52, 0xCu);
        }
        goto LABEL_94;
      }
      if (v37)
      {
        *(_DWORD *)os_log_type_t v52 = 136446466;
        *(void *)&v52[4] = "nw_service_connector_copy_pending_incoming_request";
        *(_WORD *)&v52[12] = 2082;
        *(void *)&v52[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v21, v36, "%{public}s called with null service, dumping backtrace:%{public}s", v52, 0x16u);
      }
      goto LABEL_68;
    }
LABEL_69:
    if (!v20) {
      goto LABEL_27;
    }
    int v17 = (char *)v20;
    goto LABEL_26;
  }
  int v78 = 0;
  long long v76 = 0u;
  long long v77 = 0u;
  long long v74 = 0u;
  long long v75 = 0u;
  long long v72 = 0u;
  long long v73 = 0u;
  long long v70 = 0u;
  long long v71 = 0u;
  long long v68 = 0u;
  long long v69 = 0u;
  long long v66 = 0u;
  long long v67 = 0u;
  long long v64 = 0u;
  long long v65 = 0u;
  long long v62 = 0u;
  long long v63 = 0u;
  long long v60 = 0u;
  long long v61 = 0u;
  long long v58 = 0u;
  long long v59 = 0u;
  long long v56 = 0u;
  long long v57 = 0u;
  long long v54 = 0u;
  long long v55 = 0u;
  long long v53 = 0u;
  memset(v52, 0, sizeof(v52));
  if (!nwsc_get_identifier(v6, a3, v52))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446722;
    BOOL v45 = "nw_service_connector_copy_pending_incoming_request";
    __int16 v46 = 2114;
    char v47 = v7;
    __int16 v48 = 2082;
    uint64_t v49 = a3;
    int v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (__nwlog_fault(v10, &type, &v42))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446722;
          BOOL v45 = "nw_service_connector_copy_pending_incoming_request";
          __int16 v46 = 2114;
          char v47 = v7;
          __int16 v48 = 2082;
          uint64_t v49 = a3;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", buf, 0x20u);
        }
      }
      else if (v42)
      {
        uint64_t v13 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (v13)
        {
          if (v15)
          {
            *(_DWORD *)long long buf = 136446978;
            BOOL v45 = "nw_service_connector_copy_pending_incoming_request";
            __int16 v46 = 2114;
            char v47 = v7;
            __int16 v48 = 2082;
            uint64_t v49 = a3;
            __int16 v50 = 2082;
            __int16 v51 = v13;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v13);
          if (!v10) {
            goto LABEL_27;
          }
LABEL_25:
          int v17 = (char *)v10;
LABEL_26:
          free(v17);
          goto LABEL_27;
        }
        if (v15)
        {
          *(_DWORD *)long long buf = 136446722;
          BOOL v45 = "nw_service_connector_copy_pending_incoming_request";
          __int16 v46 = 2114;
          char v47 = v7;
          __int16 v48 = 2082;
          uint64_t v49 = a3;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446722;
          BOOL v45 = "nw_service_connector_copy_pending_incoming_request";
          __int16 v46 = 2114;
          char v47 = v7;
          __int16 v48 = 2082;
          uint64_t v49 = a3;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v10)
    {
LABEL_27:
      char v8 = 0;
      goto LABEL_28;
    }
    goto LABEL_25;
  }
  char v8 = nw_dictionary_copy_value(v5[10], (uint64_t)v52);
LABEL_28:

  return v8;
}

void sub_183A83334(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      uint64_t v4 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136446466;
      id v20 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
      __int16 v21 = 2114;
      uint64_t v22 = v4;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring unsolicited request", buf, 0x16u);
    }
  }
  else
  {
    uint64_t v5 = *(void *)(v2 + 64);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    BOOL v7 = os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT);
    if (v5)
    {
      if (v7)
      {
        uint64_t v8 = *(void *)(a1 + 32);
        uint64_t v9 = *(void *)(a1 + 40);
        uint64_t v10 = *(void *)(v9 + 8);
        *(_DWORD *)long long buf = 136447234;
        id v20 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
        __int16 v21 = 2114;
        uint64_t v22 = v8;
        __int16 v23 = 2114;
        uint64_t v24 = v10;
        __int16 v25 = 2082;
        uint64_t v26 = v9 + 24;
        __int16 v27 = 2114;
        uint64_t v28 = v9;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ calling client service available block with %{public}@ \"%{public}s\" for %{public}@", buf, 0x34u);
      }

      (*(void (**)(void))(*(void *)(*(void *)(a1 + 32) + 64) + 16))();
    }
    else
    {
      if (v7)
      {
        uint64_t v11 = *(void *)(a1 + 32);
        uint64_t v12 = *(void *)(a1 + 40);
        *(_DWORD *)long long buf = 136446722;
        id v20 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
        __int16 v21 = 2114;
        uint64_t v22 = v11;
        __int16 v23 = 2114;
        uint64_t v24 = v12;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ no client service available block to call for %{public}@", buf, 0x20u);
      }
    }
    objc_initWeak((id *)buf, *(id *)(a1 + 40));
    uint64_t v13 = *(void *)(*(void *)(a1 + 40) + 600);
    if (v13)
    {
      nw_queue_cancel_source(v13);
      *(void *)(*(void *)(a1 + 40) + 600) = 0;
    }
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_203;
    v16[3] = &unk_1E5249F88;
    id v17 = *(id *)(a1 + 32);
    objc_copyWeak(&v18, (id *)buf);
    *(void *)(*(void *)(a1 + 40) + 600) = nw_queue_context_create_source(0, 2, 3, 0, v16, 0);
    uint64_t v14 = *(void *)(*(void *)(a1 + 40) + 600);
    dispatch_time_t v15 = dispatch_time(0x8000000000000000, 20000000000);
    nw_queue_set_timer_values(v14, v15, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source(*(void *)(*(void *)(a1 + 40) + 600));
    objc_destroyWeak(&v18);

    objc_destroyWeak((id *)buf);
  }
}

void sub_183A83680(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, id location)
{
}

void ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_203(uint64_t a1)
{
  uint64_t v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_2;
  v3[3] = &unk_1E5249F88;
  objc_copyWeak(&v5, (id *)(a1 + 40));
  id v4 = *(id *)(a1 + 32);
  dispatch_async(v2, v3);

  objc_destroyWeak(&v5);
}

void ___ZL48nw_service_connector_handle_unsolicited_requestsP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_request_block_invoke_2(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  WeakRetained = (NWConcrete_nw_unique_connection_request *)objc_loadWeakRetained((id *)(a1 + 40));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(_DWORD *)(*(void *)(a1 + 32) + 16) == 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        int v9 = 136446466;
        uint64_t v10 = "nw_service_connector_handle_unsolicited_requests_block_invoke_2";
        __int16 v11 = 2114;
        uint64_t v12 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring unsolicited request timeout", (uint8_t *)&v9, 0x16u);
      }
    }
    else if ((*((unsigned char *)WeakRetained + 616) & 2) != 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v7 = *(void *)(a1 + 32);
        endpoint = v3->endpoint;
        int v9 = 136447490;
        uint64_t v10 = "nw_service_connector_handle_unsolicited_requests_block_invoke";
        __int16 v11 = 2114;
        uint64_t v12 = v7;
        __int16 v13 = 2114;
        uint64_t v14 = endpoint;
        __int16 v15 = 2082;
        service = v3->service;
        __int16 v17 = 2048;
        uint64_t v18 = 20;
        __int16 v19 = 2114;
        id v20 = v3;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client did not react to service available block for %{public}@ \"%{public}s\" after %llds, rejecting %{public}@", (uint8_t *)&v9, 0x3Eu);
      }

      nw_service_connector_reject_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 32), v3, 1);
    }
  }
}

void sub_183A83968(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL18nwsc_send_feedbackP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionybbU13block_pointerFviE_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  id v4 = v3;
  if (*(_DWORD *)(*(void *)(a1 + 32) + 16) == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      id v6 = *(const char **)(a1 + 32);
      uint64_t v7 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 136446722;
      char v42 = "nwsc_send_feedback_block_invoke";
      __int16 v43 = 2114;
      os_log_type_t v44 = v6;
      __int16 v45 = 2114;
      *(void *)__int16 v46 = v7;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring connection %{public}@ send callback", buf, 0x20u);
    }

    nw_connection_cancel(*(nw_connection_t *)(a1 + 40));
    uint64_t v8 = *(void *)(a1 + 56);
    if (v8) {
      (*(void (**)(uint64_t, uint64_t))(v8 + 16))(v8, 22);
    }
    goto LABEL_30;
  }
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v20 = *(void *)(a1 + 64);
      if (*(unsigned char *)(a1 + 72)) {
        uint64_t v21 = "accept";
      }
      else {
        uint64_t v21 = "deny";
      }
      uint64_t v22 = *(const char **)(a1 + 32);
      uint64_t v23 = *(void *)(a1 + 40);
      *(_DWORD *)long long buf = 136447234;
      char v42 = "nwsc_send_feedback_block_invoke";
      __int16 v43 = 2114;
      os_log_type_t v44 = v22;
      __int16 v45 = 2082;
      *(void *)__int16 v46 = v21;
      *(_WORD *)&v46[8] = 2048;
      *(void *)&v46[10] = v20;
      __int16 v47 = 2114;
      uint64_t v48 = v23;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ sent %{public}s feedback seq %llu on connection %{public}@", buf, 0x34u);
    }

    uint64_t v10 = 0;
    goto LABEL_26;
  }
  int v9 = (unsigned int *)v3;
  uint64_t v10 = v9[3];

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v11 = (id)gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    uint64_t v12 = *(void *)(a1 + 64);
    if (*(unsigned char *)(a1 + 72)) {
      __int16 v13 = "accept";
    }
    else {
      __int16 v13 = "deny";
    }
    uint64_t v14 = *(const char **)(a1 + 32);
    uint64_t v15 = *(void *)(a1 + 40);
    *(_DWORD *)long long buf = 136447490;
    char v42 = "nwsc_send_feedback_block_invoke";
    __int16 v43 = 2114;
    os_log_type_t v44 = v14;
    __int16 v45 = 2082;
    *(void *)__int16 v46 = v13;
    *(_WORD *)&v46[8] = 2048;
    *(void *)&v46[10] = v12;
    __int16 v47 = 2114;
    uint64_t v48 = v15;
    __int16 v49 = 1024;
    int v50 = v10;
    _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ failed to send %{public}s feedback seq %llu on %{public}@ %{darwin.errno}d", buf, 0x3Au);
  }

  if ((v10 - 32) > 0x39 || ((1 << (v10 - 32)) & 0x200000212420001) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    int v26 = *(unsigned __int8 *)(a1 + 72);
    *(_DWORD *)long long buf = 136446722;
    char v42 = "nwsc_send_feedback_block_invoke";
    if (v26) {
      __int16 v27 = "accept";
    }
    else {
      __int16 v27 = "deny";
    }
    __int16 v43 = 2082;
    os_log_type_t v44 = v27;
    __int16 v45 = 1024;
    *(_DWORD *)__int16 v46 = v10;
    uint64_t v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v28, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          if (*(unsigned char *)(a1 + 72)) {
            BOOL v31 = "accept";
          }
          else {
            BOOL v31 = "deny";
          }
          *(_DWORD *)long long buf = 136446722;
          char v42 = "nwsc_send_feedback_block_invoke";
          __int16 v43 = 2082;
          os_log_type_t v44 = v31;
          __int16 v45 = 1024;
          *(_DWORD *)__int16 v46 = v10;
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s Failed to send %{public}s feedback %{darwin.errno}d", buf, 0x1Cu);
        }
      }
      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v34)
          {
            if (*(unsigned char *)(a1 + 72)) {
              BOOL v35 = "accept";
            }
            else {
              BOOL v35 = "deny";
            }
            *(_DWORD *)long long buf = 136446978;
            char v42 = "nwsc_send_feedback_block_invoke";
            __int16 v43 = 2082;
            os_log_type_t v44 = v35;
            __int16 v45 = 1024;
            *(_DWORD *)__int16 v46 = v10;
            *(_WORD *)&v46[4] = 2082;
            *(void *)&v46[6] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v29, v33, "%{public}s Failed to send %{public}s feedback %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(backtrace_string);
          goto LABEL_62;
        }
        if (v34)
        {
          if (*(unsigned char *)(a1 + 72)) {
            os_log_type_t v38 = "accept";
          }
          else {
            os_log_type_t v38 = "deny";
          }
          *(_DWORD *)long long buf = 136446722;
          char v42 = "nwsc_send_feedback_block_invoke";
          __int16 v43 = 2082;
          os_log_type_t v44 = v38;
          __int16 v45 = 1024;
          *(_DWORD *)__int16 v46 = v10;
          _os_log_impl(&dword_1830D4000, v29, v33, "%{public}s Failed to send %{public}s feedback %{darwin.errno}d, no backtrace", buf, 0x1Cu);
        }
      }
      else
      {
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v29, type))
        {
          if (*(unsigned char *)(a1 + 72)) {
            BOOL v37 = "accept";
          }
          else {
            BOOL v37 = "deny";
          }
          *(_DWORD *)long long buf = 136446722;
          char v42 = "nwsc_send_feedback_block_invoke";
          __int16 v43 = 2082;
          os_log_type_t v44 = v37;
          __int16 v45 = 1024;
          *(_DWORD *)__int16 v46 = v10;
          _os_log_impl(&dword_1830D4000, v29, v36, "%{public}s Failed to send %{public}s feedback %{darwin.errno}d, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
    }
LABEL_62:
    if (v28) {
      free(v28);
    }
    goto LABEL_26;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v16 = (id)gLogObj;
  if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
  {
    int v17 = *(unsigned __int8 *)(a1 + 72);
    char v42 = "nwsc_send_feedback_block_invoke";
    *(_DWORD *)long long buf = 136446722;
    if (v17) {
      uint64_t v18 = "accept";
    }
    else {
      uint64_t v18 = "deny";
    }
    __int16 v43 = 2082;
    os_log_type_t v44 = v18;
    __int16 v45 = 1024;
    *(_DWORD *)__int16 v46 = v10;
    _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_ERROR, "%{public}s Failed to send %{public}s feedback %{darwin.errno}d", buf, 0x1Cu);
  }

LABEL_26:
  if (*(_UNKNOWN **)(a1 + 48) == &__block_literal_global_6_42258) {
    nwsc_drain_and_cancel_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), *(NWConcrete_nw_connection **)(a1 + 40), v4 == 0);
  }
  uint64_t v24 = *(void *)(a1 + 56);
  if (v24) {
    (*(void (**)(uint64_t, uint64_t))(v24 + 16))(v24, v10);
  }
LABEL_30:
}

void sub_183A84080(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nwsc_drain_and_cancel_connection(NWConcrete_nw_service_connector *a1, NWConcrete_nw_connection *a2, char a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (a3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)long long buf = 136446722;
      __int16 v13 = "nwsc_drain_and_cancel_connection";
      __int16 v14 = 2114;
      uint64_t v15 = v5;
      __int16 v16 = 2114;
      int v17 = v7;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ draining %{public}@", buf, 0x20u);
    }

    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZL32nwsc_drain_and_cancel_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke;
    v9[3] = &unk_1E5248D98;
    uint64_t v10 = v5;
    __int16 v11 = v7;
    nw_connection_receive_internal(v11, 0, 1u, 0xFFFFFFFF, v9);
  }
  else
  {
    nw_connection_cancel(&v6->super);
  }
}

void sub_183A8422C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL32nwsc_drain_and_cancel_connectionP31NWConcrete_nw_service_connectorP24NWConcrete_nw_connectionb_block_invoke(uint64_t a1, void *a2, uint64_t a3, int a4, void *a5)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a2;
  id v9 = a5;
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v10 = (id)gLogObj;
  if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
  {
    uint64_t v12 = *(void *)(a1 + 32);
    uint64_t v11 = *(void *)(a1 + 40);
    if (v8) {
      size_t size = dispatch_data_get_size(v8);
    }
    else {
      size_t size = 0;
    }
    __int16 v14 = "in";
    int v16 = 136447490;
    int v17 = "nwsc_drain_and_cancel_connection_block_invoke";
    uint64_t v19 = v12;
    __int16 v18 = 2114;
    if (a4) {
      __int16 v14 = "";
    }
    __int16 v20 = 2114;
    uint64_t v21 = v11;
    __int16 v22 = 2048;
    size_t v23 = size;
    __int16 v24 = 2082;
    id v25 = v14;
    __int16 v26 = 2114;
    id v27 = v9;
    _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ drained %{public}@ %zu bytes %{public}scomplete error %{public}@", (uint8_t *)&v16, 0x3Eu);
  }

  if (v9) {
    char v15 = 0;
  }
  else {
    char v15 = a4 ^ 1;
  }
  nwsc_drain_and_cancel_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), *(NWConcrete_nw_connection **)(a1 + 40), v15);
}

void sub_183A843E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL47nwsc_restart_outgoing_requests_waiting_for_pathP31NWConcrete_nw_service_connectorPU25objcproto14OS_nw_endpoint8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if ((char)v4[77] < 0 && nw_endpoint_is_equal(*(void **)(a1 + 32), v4[1], 0))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 40);
      int v8 = 136446722;
      id v9 = "nwsc_restart_outgoing_requests_waiting_for_path_block_invoke";
      __int16 v10 = 2114;
      uint64_t v11 = v6;
      __int16 v12 = 2114;
      __int16 v13 = v4;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ restarting connection for request %{public}@ due to external trigger", (uint8_t *)&v8, 0x20u);
    }

    nwsc_request_create_and_start_connection_inner(*(void *)(a1 + 40), v4, 0);
  }

  return 1;
}

void sub_183A84538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL46nwsc_request_create_and_start_connection_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestPU25objcproto14OS_nw_endpoint8NSObject21nwsc_operation_code_e_block_invoke(int a1, nw_protocol_options_t options)
{
}

uint64_t ___ZL44nw_service_connector_get_new_sequence_numberv_block_invoke()
{
  mach_timebase_info info = 0;
  mach_timebase_info(&info);
  uint64_t v0 = mach_boottime_usec();
  uint64_t result = mach_continuous_time();
  nw_service_connector_get_new_sequence_number(void)::sNWSCSequenceNumber = v0
                                                                          + ((result * info.numer / (1000 * info.denom)) >> 1);
  return result;
}

void __nw_service_connector_start_block_invoke_99(int a1, nw_protocol_options_t options)
{
}

void nw_service_connector_use_large_uuid_for_testing(void *a1, char a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = v3[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_use_large_uuid_for_testing_block_invoke;
    block[3] = &unk_1E5248D20;
    char v15 = v3;
    char v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_use_large_uuid_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

uint64_t __nw_service_connector_use_large_uuid_for_testing_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 152) = *(unsigned char *)(*(void *)(result + 32) + 152) & 0xFE | *(unsigned char *)(result + 40);
  return result;
}

void nw_service_connector_fail_connection_after_verification_fails_for_testing(void *a1, char a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = v3[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_fail_connection_after_verification_fails_for_testing_block_invoke;
    block[3] = &unk_1E5248D20;
    char v15 = v3;
    char v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_fails_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

uint64_t __nw_service_connector_fail_connection_after_verification_fails_for_testing_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 152) = *(unsigned char *)(*(void *)(result + 32) + 152) & 0xFD | (2 * *(unsigned char *)(result + 40));
  return result;
}

void nw_service_connector_fail_connection_after_verification_passes_for_testing(void *a1, char a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = v3[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_fail_connection_after_verification_passes_for_testing_block_invoke;
    block[3] = &unk_1E5248D20;
    char v15 = v3;
    char v16 = a2;
    dispatch_async(v5, block);

    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
          __int16 v21 = 2082;
          __int16 v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v20 = "nw_service_connector_fail_connection_after_verification_passes_for_testing";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

uint64_t __nw_service_connector_fail_connection_after_verification_passes_for_testing_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 152) = *(unsigned char *)(*(void *)(result + 32) + 152) & 0xFB | (4 * *(unsigned char *)(result + 40));
  return result;
}

void nw_service_connector_cancel(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[4];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_service_connector_cancel_block_invoke;
    block[3] = &unk_1E524BAA8;
    os_log_type_t v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_service_connector_cancel";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_service_connector_cancel";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_service_connector_cancel";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void __nw_service_connector_cancel_block_invoke(uint64_t a1)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  int v2 = *(_DWORD *)(*(void *)(a1 + 32) + 16);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  id v4 = v3;
  if (v2 != 4)
  {
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v10 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136446466;
      uint64_t v84 = "nw_service_connector_cancel_block_invoke";
      __int16 v85 = 2114;
      uint64_t v86 = v10;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEFAULT, "%{public}s Client cancelling %{public}@", buf, 0x16u);
    }

    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = *(void *)(v11 + 56);
    if (v12)
    {
      nw_queue_cancel_source(v12);
      *(void *)(*(void *)(a1 + 32) + 56) = 0;
      uint64_t v11 = *(void *)(a1 + 32);
    }
    *(_DWORD *)(v11 + 16) = 4;
    uint64_t v13 = *(void *)(a1 + 32);
    char v14 = *(NSObject **)(v13 + 8);
    if (v14)
    {
      nw_listener_cancel(v14);
      uint64_t v15 = *(void *)(a1 + 32);
      char v16 = *(void **)(v15 + 8);
      *(void *)(v15 + _Block_object_dispose(&a9, 8) = 0;

      uint64_t v13 = *(void *)(a1 + 32);
    }
    char v17 = *(void **)(v13 + 64);
    *(void *)(v13 + 64) = 0;

    __int16 v18 = *(void **)(a1 + 32);
    uint64_t v19 = v18[11];
    if (v19)
    {
      v79[0] = MEMORY[0x1E4F143A8];
      v79[1] = 3221225472;
      v79[2] = __nw_service_connector_cancel_block_invoke_107;
      v79[3] = &unk_1E5247FE0;
      long long v80 = v18;
      nw_dictionary_apply(v19, (uint64_t)v79);
      uint64_t v20 = *(void *)(a1 + 32);
      __int16 v21 = *(void **)(v20 + 88);
      *(void *)(v20 + 8_Block_object_dispose(&a9, 8) = 0;

      goto LABEL_15;
    }
    BOOL v37 = __nwlog_obj();
    uint64_t v38 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 136446466;
    uint64_t v84 = "nw_service_connector_cancel_block_invoke_2";
    __int16 v85 = 2114;
    uint64_t v86 = v38;
    char v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v82 = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (__nwlog_fault(v39, &v82, &v81))
    {
      if (v82 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v40 = __nwlog_obj();
        os_log_type_t v41 = v82;
        if (os_log_type_enabled(v40, v82))
        {
          uint64_t v42 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v42;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s %{public}@ trying to apply NULL activeConnections", buf, 0x16u);
        }
      }
      else if (v81)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v40 = __nwlog_obj();
        os_log_type_t v55 = v82;
        BOOL v56 = os_log_type_enabled(v40, v82);
        if (backtrace_string)
        {
          if (v56)
          {
            uint64_t v57 = *(void *)(a1 + 32);
            *(_DWORD *)long long buf = 136446722;
            uint64_t v84 = "nw_service_connector_cancel_block_invoke";
            __int16 v85 = 2114;
            uint64_t v86 = v57;
            __int16 v87 = 2082;
            long long v88 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v40, v55, "%{public}s %{public}@ trying to apply NULL activeConnections, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(backtrace_string);
          goto LABEL_76;
        }
        if (v56)
        {
          uint64_t v72 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v72;
          _os_log_impl(&dword_1830D4000, v40, v55, "%{public}s %{public}@ trying to apply NULL activeConnections, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        os_log_type_t v40 = __nwlog_obj();
        os_log_type_t v66 = v82;
        if (os_log_type_enabled(v40, v82))
        {
          uint64_t v67 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v67;
          _os_log_impl(&dword_1830D4000, v40, v66, "%{public}s %{public}@ trying to apply NULL activeConnections, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
LABEL_76:
    if (v39) {
      free(v39);
    }
LABEL_15:
    uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 96);
    if (v22)
    {
      uint64_t v23 = (void *)nw_dictionary_copy(v22);
      v77[0] = MEMORY[0x1E4F143A8];
      v77[1] = 3221225472;
      v77[2] = __nw_service_connector_cancel_block_invoke_110;
      v77[3] = &unk_1E5247FE0;
      id v78 = *(id *)(a1 + 32);
      nw_dictionary_apply((uint64_t)v23, (uint64_t)v77);

      __int16 v24 = *(void **)(*(void *)(a1 + 32) + 96);
      *(void *)(*(void *)(a1 + 32) + 96) = 0;

      goto LABEL_17;
    }
    __int16 v43 = __nwlog_obj();
    uint64_t v44 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 136446466;
    uint64_t v84 = "nw_service_connector_cancel_block_invoke_2";
    __int16 v85 = 2114;
    uint64_t v86 = v44;
    __int16 v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v82 = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (__nwlog_fault(v45, &v82, &v81))
    {
      if (v82 == OS_LOG_TYPE_FAULT)
      {
        __int16 v46 = __nwlog_obj();
        os_log_type_t v47 = v82;
        if (os_log_type_enabled(v46, v82))
        {
          uint64_t v48 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v48;
          _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests", buf, 0x16u);
        }
      }
      else if (v81)
      {
        long long v58 = (char *)__nw_create_backtrace_string();
        __int16 v46 = __nwlog_obj();
        os_log_type_t v59 = v82;
        BOOL v60 = os_log_type_enabled(v46, v82);
        if (v58)
        {
          if (v60)
          {
            uint64_t v61 = *(void *)(a1 + 32);
            *(_DWORD *)long long buf = 136446722;
            uint64_t v84 = "nw_service_connector_cancel_block_invoke";
            __int16 v85 = 2114;
            uint64_t v86 = v61;
            __int16 v87 = 2082;
            long long v88 = v58;
            _os_log_impl(&dword_1830D4000, v46, v59, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v58);
          goto LABEL_81;
        }
        if (v60)
        {
          uint64_t v73 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v73;
          _os_log_impl(&dword_1830D4000, v46, v59, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        __int16 v46 = __nwlog_obj();
        os_log_type_t v68 = v82;
        if (os_log_type_enabled(v46, v82))
        {
          uint64_t v69 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v69;
          _os_log_impl(&dword_1830D4000, v46, v68, "%{public}s %{public}@ trying to apply NULL activeOutgoingRequests, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
LABEL_81:
    if (v45) {
      free(v45);
    }
LABEL_17:
    uint64_t v25 = *(void *)(*(void *)(a1 + 32) + 80);
    if (v25)
    {
      __int16 v26 = (void *)nw_dictionary_copy(v25);
      v75[0] = MEMORY[0x1E4F143A8];
      v75[1] = 3221225472;
      v75[2] = __nw_service_connector_cancel_block_invoke_111;
      void v75[3] = &unk_1E5247FE0;
      uint64_t v28 = *(void **)(a1 + 32);
      uint64_t v27 = a1 + 32;
      id v76 = v28;
      nw_dictionary_apply((uint64_t)v26, (uint64_t)v75);

      uint64_t v29 = *(void **)(*(void *)v27 + 80);
      *(void *)(*(void *)v27 + 80) = 0;

      return;
    }
    __int16 v49 = __nwlog_obj();
    uint64_t v50 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 136446466;
    uint64_t v84 = "nw_service_connector_cancel_block_invoke_2";
    __int16 v85 = 2114;
    uint64_t v86 = v50;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v82 = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (__nwlog_fault(v6, &v82, &v81))
    {
      if (v82 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v51 = __nwlog_obj();
        os_log_type_t v52 = v82;
        if (os_log_type_enabled(v51, v82))
        {
          uint64_t v53 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v53;
          _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests", buf, 0x16u);
        }
LABEL_85:

        goto LABEL_31;
      }
      if (!v81)
      {
        uint64_t v51 = __nwlog_obj();
        os_log_type_t v70 = v82;
        if (os_log_type_enabled(v51, v82))
        {
          uint64_t v71 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v71;
          _os_log_impl(&dword_1830D4000, v51, v70, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, backtrace limit exceeded", buf, 0x16u);
        }
        goto LABEL_85;
      }
      long long v62 = (char *)__nw_create_backtrace_string();
      uint64_t v51 = __nwlog_obj();
      os_log_type_t v63 = v82;
      BOOL v64 = os_log_type_enabled(v51, v82);
      if (!v62)
      {
        if (v64)
        {
          uint64_t v74 = *(void *)(a1 + 32);
          *(_DWORD *)long long buf = 136446466;
          uint64_t v84 = "nw_service_connector_cancel_block_invoke";
          __int16 v85 = 2114;
          uint64_t v86 = v74;
          _os_log_impl(&dword_1830D4000, v51, v63, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, no backtrace", buf, 0x16u);
        }
        goto LABEL_85;
      }
      if (v64)
      {
        uint64_t v65 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 136446722;
        uint64_t v84 = "nw_service_connector_cancel_block_invoke";
        __int16 v85 = 2114;
        uint64_t v86 = v65;
        __int16 v87 = 2082;
        long long v88 = v62;
        _os_log_impl(&dword_1830D4000, v51, v63, "%{public}s %{public}@ trying to apply NULL pendingIncomingRequests, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(v62);
    }
LABEL_31:
    if (!v6) {
      return;
    }
    goto LABEL_32;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  *(_DWORD *)long long buf = 136446466;
  uint64_t v84 = "nw_service_connector_cancel_block_invoke";
  __int16 v85 = 2114;
  uint64_t v86 = v5;
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v82 = OS_LOG_TYPE_ERROR;
  char v81 = 0;
  if (!__nwlog_fault(v6, &v82, &v81)) {
    goto LABEL_31;
  }
  if (v82 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (id)gLogObj;
    os_log_type_t v8 = v82;
    if (os_log_type_enabled(v7, v82))
    {
      uint64_t v9 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136446466;
      uint64_t v84 = "nw_service_connector_cancel_block_invoke";
      __int16 v85 = 2114;
      uint64_t v86 = v9;
      _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s %{public}@ already cancelled", buf, 0x16u);
    }
LABEL_30:

    goto LABEL_31;
  }
  if (!v81)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (id)gLogObj;
    os_log_type_t v34 = v82;
    if (os_log_type_enabled(v7, v82))
    {
      uint64_t v35 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136446466;
      uint64_t v84 = "nw_service_connector_cancel_block_invoke";
      __int16 v85 = 2114;
      uint64_t v86 = v35;
      _os_log_impl(&dword_1830D4000, v7, v34, "%{public}s %{public}@ already cancelled, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_30;
  }
  os_log_type_t v30 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v7 = (id)gLogObj;
  os_log_type_t v31 = v82;
  BOOL v32 = os_log_type_enabled(v7, v82);
  if (!v30)
  {
    if (v32)
    {
      uint64_t v36 = *(void *)(a1 + 32);
      *(_DWORD *)long long buf = 136446466;
      uint64_t v84 = "nw_service_connector_cancel_block_invoke";
      __int16 v85 = 2114;
      uint64_t v86 = v36;
      _os_log_impl(&dword_1830D4000, v7, v31, "%{public}s %{public}@ already cancelled, no backtrace", buf, 0x16u);
    }
    goto LABEL_30;
  }
  if (v32)
  {
    uint64_t v33 = *(void *)(a1 + 32);
    *(_DWORD *)long long buf = 136446722;
    uint64_t v84 = "nw_service_connector_cancel_block_invoke";
    __int16 v85 = 2114;
    uint64_t v86 = v33;
    __int16 v87 = 2082;
    long long v88 = v30;
    _os_log_impl(&dword_1830D4000, v7, v31, "%{public}s %{public}@ already cancelled, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v30);
  if (v6) {
LABEL_32:
  }
    free(v6);
}

uint64_t __nw_service_connector_cancel_block_invoke_107(uint64_t a1, int a2, NWConcrete_nw_unique_connection *a3)
{
  return 1;
}

uint64_t __nw_service_connector_cancel_block_invoke_110(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), v4[1], (uint64_t)(v4 + 3), v4[72], 1);
  nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v4, 0, 0, 89);

  return 1;
}

void sub_183A85F88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_service_connector_cancel_block_invoke_111(uint64_t a1, int a2, NWConcrete_nw_unique_connection_request *a3)
{
  return 1;
}

void __nw_service_connector_start_request_block_invoke(uint64_t a1)
{
  uint64_t v138 = *MEMORY[0x1E4F143B8];
  string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 32));
  uint64_t v3 = *(void *)(a1 + 48);
  int v4 = *(_DWORD *)(*(void *)(a1 + 40) + 16);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v5 = (id)gLogObj;
  uint64_t v6 = v5;
  if (v4 == 4)
  {
    BOOL v7 = os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
    if (v3)
    {
      if (v7)
      {
        uint64_t v9 = *(void *)(a1 + 48);
        uint64_t v8 = *(void *)(a1 + 56);
        uint64_t v10 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v10;
        WORD3(buf[1]) = 2082;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
        LOWORD(buf[2]) = 2114;
        *(void *)((char *)&buf[2] + 2) = v8;
        WORD5(buf[2]) = 2114;
        *(void *)((char *)&buf[2] + 12) = v9;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client requesting service \"%{public}s\" to %{public}@ parameters %{public}@", (uint8_t *)buf, 0x34u);
      }
    }
    else if (v7)
    {
      uint64_t v18 = *(void *)(a1 + 40);
      uint64_t v19 = *(void *)(a1 + 56);
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
      WORD6(buf[0]) = 2114;
      *(void *)((char *)buf + 14) = v18;
      WORD3(buf[1]) = 2082;
      *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
      LOWORD(buf[2]) = 2114;
      *(void *)((char *)&buf[2] + 2) = v19;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client requesting service \"%{public}s\" to %{public}@", (uint8_t *)buf, 0x2Au);
    }
    goto LABEL_141;
  }
  BOOL v11 = os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT);
  if (v3)
  {
    if (v11)
    {
      uint64_t v13 = *(void *)(a1 + 48);
      uint64_t v12 = *(void *)(a1 + 56);
      uint64_t v14 = *(void *)(a1 + 40);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
      WORD6(buf[0]) = 2114;
      *(void *)((char *)buf + 14) = v14;
      WORD3(buf[1]) = 2082;
      *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
      LOWORD(buf[2]) = 2114;
      *(void *)((char *)&buf[2] + 2) = v12;
      WORD5(buf[2]) = 2114;
      *(void *)((char *)&buf[2] + 12) = v13;
      uint64_t v15 = "%{public}s %{public}@ client requesting service \"%{public}s\" to %{public}@ parameters %{public}@";
      char v16 = v6;
      uint32_t v17 = 52;
LABEL_12:
      _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEFAULT, v15, (uint8_t *)buf, v17);
    }
  }
  else if (v11)
  {
    uint64_t v20 = *(void *)(a1 + 40);
    uint64_t v21 = *(void *)(a1 + 56);
    LODWORD(buf[0]) = 136446978;
    *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
    WORD6(buf[0]) = 2114;
    *(void *)((char *)buf + 14) = v20;
    WORD3(buf[1]) = 2082;
    *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = string_ptr;
    LOWORD(buf[2]) = 2114;
    *(void *)((char *)&buf[2] + 2) = v21;
    uint64_t v15 = "%{public}s %{public}@ client requesting service \"%{public}s\" to %{public}@";
    char v16 = v6;
    uint32_t v17 = 42;
    goto LABEL_12;
  }

  uint64_t v22 = nw_service_connector_copy_pending_incoming_request(*(void **)(a1 + 40), *(void **)(a1 + 56), (uint64_t)string_ptr);
  uint64_t v6 = v22;
  if (v22 && ((uint64_t)v22[77].isa & 4) == 0)
  {
    LOBYTE(v22[77].isa) |= 4u;
    uint64_t v23 = *(void **)(a1 + 48);
    if (v23) {
      nw_service_connector_apply_user_parameters(*(void **)(a1 + 40), v22, v22[72].isa, v23);
    }
    __int16 v24 = *(void **)(a1 + 40);
    Class isa = v6[72].isa;
    v126[0] = MEMORY[0x1E4F143A8];
    v126[1] = 3221225472;
    v126[2] = __nw_service_connector_start_request_block_invoke_112;
    v126[3] = &unk_1E5243250;
    int v127 = v24;
    id v129 = *(id *)(a1 + 64);
    __int16 v26 = v6;
    uint64_t v128 = v26;
    nw_service_connector_accept_connection_for_request(v127, isa, v26, v126);
    nw_service_connector_reject_incoming_request(*(NWConcrete_nw_service_connector **)(a1 + 40), v26, 0);

    uint64_t v27 = v127;
    goto LABEL_140;
  }
  uint64_t v28 = (NWConcrete_nw_unique_connection *)nw_service_connector_copy_active_connection_with_endpoint_and_service(*(void **)(a1 + 40), *(void **)(a1 + 56), (uint64_t)string_ptr);
  long long v125 = v28;
  if (v28)
  {
    connection = v28->connection;
    if (!connection) {
      goto LABEL_21;
    }
    os_log_type_t v30 = connection;
    *(void *)os_log_type_t type = 0;
    *(void *)&os_log_type_t type[8] = type;
    *(void *)&os_log_type_t type[16] = 0x2020000000;
    LOBYTE(v133) = 0;
    os_log_type_t v31 = v30 + 34;
    *(void *)&buf[0] = MEMORY[0x1E4F143A8];
    *((void *)&buf[0] + nw_tcp_options_set_enable_fast_open(options, 1) = 3221225472;
    *(void *)&buf[1] = __nw_connection_is_cancelled_or_failed_block_invoke;
    *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = &unk_1E524B978;
    *((void *)&buf[2] + nw_tcp_options_set_enable_fast_open(options, 1) = type;
    BOOL v32 = v30;
    *(void *)&buf[2] = v32;
    os_unfair_lock_lock(v31);
    (*(void (**)(_OWORD *))&buf[1])(buf);
    os_unfair_lock_unlock(v31);
    int v33 = *(unsigned __int8 *)(*(void *)&type[8] + 24);

    _Block_object_dispose(type, 8);
    if (!v33)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v37 = (id)gLogObj;
      if (os_log_type_enabled(v37, OS_LOG_TYPE_ERROR))
      {
        uint64_t v38 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v38;
        WORD3(buf[1]) = 2114;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v125;
        _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ got request for already existing activeConnection %{public}@", (uint8_t *)buf, 0x20u);
      }

      int v36 = 1;
    }
    else
    {
LABEL_21:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v34 = (id)gLogObj;
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v35 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v35;
        WORD3(buf[1]) = 2114;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v125;
        _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cleaning up dead activeConnection %{public}@", (uint8_t *)buf, 0x20u);
      }

      nw_service_connector_cancel_request_inner(*(void **)(a1 + 40), *(void **)(a1 + 56), (uint64_t)string_ptr, v125->connection, 0);
      int v36 = 0;
    }
  }
  else
  {
    int v36 = 0;
  }
  char v39 = nw_service_connector_copy_active_outgoing_request(*(void **)(a1 + 40), *(void **)(a1 + 56), (uint64_t)string_ptr);
  os_log_type_t v40 = v39;
  long long v124 = v39;
  if (v39)
  {
    os_log_type_t v41 = (void *)v39[72];
    if (!v41 || nw_connection_is_cancelled(v41))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v42 = (id)gLogObj;
      if (os_log_type_enabled(v42, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v43 = *(void *)(a1 + 40);
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
        WORD6(buf[0]) = 2114;
        *(void *)((char *)buf + 14) = v43;
        WORD3(buf[1]) = 2114;
        *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v40;
        _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ cleaning up dead request %{public}@", (uint8_t *)buf, 0x20u);
      }

      nw_service_connector_cancel_request_inner(*(void **)(a1 + 40), *(void **)(a1 + 56), (uint64_t)string_ptr, *((void **)v124 + 72), 0);
      goto LABEL_34;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v65 = (id)gLogObj;
    if (os_log_type_enabled(v65, OS_LOG_TYPE_ERROR))
    {
      uint64_t v66 = *(void *)(a1 + 40);
      LODWORD(buf[0]) = 136446722;
      *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
      WORD6(buf[0]) = 2114;
      *(void *)((char *)buf + 14) = v66;
      WORD3(buf[1]) = 2114;
      *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v40;
      _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ we already have active request %{public}@", (uint8_t *)buf, 0x20u);
    }

    __int16 v45 = (char *)_Block_copy(*((const void **)v124 + 74));
    if (v45)
    {
      uint64_t v67 = _Block_copy(*(const void **)(a1 + 64));
      os_log_type_t v68 = (void *)*((void *)v124 + 74);
      *((void *)v124 + 74) = v67;

      nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), 0, v45, 0, 36);
LABEL_129:
      int v83 = v45;
      goto LABEL_139;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v73 = (id)gLogObj;
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
    uint64_t v74 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    os_log_type_t v131 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v74, type, &v131))
    {
      if (type[0] == 17)
      {
        long long v75 = __nwlog_obj();
        os_log_type_t v76 = type[0];
        if (os_log_type_enabled(v75, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s Found an old request without a request completion block", (uint8_t *)buf, 0xCu);
        }
      }
      else
      {
        if (v131)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v79 = __nwlog_obj();
          os_log_type_t v80 = type[0];
          BOOL v81 = os_log_type_enabled(v79, (os_log_type_t)type[0]);
          if (backtrace_string)
          {
            if (v81)
            {
              LODWORD(buf[0]) = 136446466;
              *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
              WORD6(buf[0]) = 2082;
              *(void *)((char *)buf + 14) = backtrace_string;
              _os_log_impl(&dword_1830D4000, v79, v80, "%{public}s Found an old request without a request completion block, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v81)
            {
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
              _os_log_impl(&dword_1830D4000, v79, v80, "%{public}s Found an old request without a request completion block, no backtrace", (uint8_t *)buf, 0xCu);
            }
          }
          goto LABEL_99;
        }
        long long v75 = __nwlog_obj();
        os_log_type_t v84 = type[0];
        if (os_log_type_enabled(v75, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl(&dword_1830D4000, v75, v84, "%{public}s Found an old request without a request completion block, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
        }
      }
    }
LABEL_99:
    if (v74) {
      free(v74);
    }
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), 0, *(void **)(a1 + 64), 0, 36);
    int v83 = 0;
    goto LABEL_139;
  }
LABEL_34:
  uint64_t v44 = objc_alloc_init(NWConcrete_nw_unique_connection_request);
  __int16 v45 = (char *)v44;
  if (!v44)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v58 = (id)gLogObj;
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
    os_log_type_t v59 = (char *)_os_log_send_and_compose_impl();

    type[0] = 16;
    os_log_type_t v131 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v59, type, &v131))
    {
      if (type[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v60 = (id)gLogObj;
        os_log_type_t v61 = type[0];
        if (os_log_type_enabled(v60, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s [nw_unique_connection_request init:] failed", (uint8_t *)buf, 0xCu);
        }
      }
      else if (v131)
      {
        uint64_t v69 = __nw_create_backtrace_string();
        if (v69)
        {
          os_log_type_t v70 = (char *)v69;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v71 = (id)gLogObj;
          os_log_type_t v72 = type[0];
          if (os_log_type_enabled(v71, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v70;
            _os_log_impl(&dword_1830D4000, v71, v72, "%{public}s [nw_unique_connection_request init:] failed, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
          }

          free(v70);
          if (!v59) {
            goto LABEL_92;
          }
          goto LABEL_91;
        }
        BOOL v60 = __nwlog_obj();
        os_log_type_t v82 = type[0];
        if (os_log_type_enabled(v60, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl(&dword_1830D4000, v60, v82, "%{public}s [nw_unique_connection_request init:] failed, no backtrace", (uint8_t *)buf, 0xCu);
        }
      }
      else
      {
        BOOL v60 = __nwlog_obj();
        os_log_type_t v77 = type[0];
        if (os_log_type_enabled(v60, (os_log_type_t)type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          _os_log_impl(&dword_1830D4000, v60, v77, "%{public}s [nw_unique_connection_request init:] failed, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
        }
      }
    }
    if (!v59)
    {
LABEL_92:
      nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), 0, *(void **)(a1 + 64), 0, 12);
      int v83 = 0;
LABEL_139:

      uint64_t v27 = v125;
LABEL_140:

LABEL_141:
      return;
    }
LABEL_91:
    free(v59);
    goto LABEL_92;
  }
  *((unsigned char *)v44 + 616) &= ~1u;
  __int16 v46 = _Block_copy(*(const void **)(a1 + 64));
  os_log_type_t v47 = (void *)*((void *)v45 + 74);
  *((void *)v45 + 74) = v46;

  uint64_t v48 = (void **)(v45 + 8);
  objc_storeStrong((id *)v45 + 1, *(id *)(a1 + 56));
  __int16 v49 = *(void **)(a1 + 48);
  if (v49)
  {
    id v50 = v49;
    BOOL v51 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v50, 0, 0);

    os_log_type_t v52 = (void *)*((void *)v45 + 2);
    *((void *)v45 + 2) = v51;
  }
  if (!string_ptr)
  {
    __int16 v85 = __nwlog_obj();
    os_log_type_enabled(v85, OS_LOG_TYPE_ERROR);
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "_strict_strlcat";
    uint64_t v86 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v86)) {
      goto LABEL_177;
    }
    free(v86);
  }
  uint64_t v53 = v45 + 24;
  unint64_t v54 = 436;
  os_log_type_t v55 = v45 + 24;
  while (*v55)
  {
    ++v55;
    if (!--v54)
    {
      if (!string_ptr)
      {
        BOOL v56 = __nwlog_obj();
        os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "_strict_strlcpy";
        uint64_t v57 = (void *)_os_log_send_and_compose_impl();

        if (__nwlog_abort((uint64_t)v57)) {
          goto LABEL_177;
        }
        free(v57);
      }
LABEL_56:
      BOOL v64 = v45 + 480;
      do
      {
        do
          uuid_generate_random((unsigned __int8 *)v45 + 480);
        while (!*v64);
      }
      while (!*((_DWORD *)v45 + 121) || !*((_DWORD *)v45 + 122) || !*((_DWORD *)v45 + 123));
      if (*(unsigned char *)(*(void *)(a1 + 40) + 152))
      {
        __int16 v87 = __nwlog_obj();
        if (os_log_type_enabled(v87, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v88 = *(void *)(a1 + 40);
          LODWORD(buf[0]) = 136446722;
          *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
          WORD6(buf[0]) = 2114;
          *(void *)((char *)buf + 14) = v88;
          WORD3(buf[1]) = 2114;
          *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v45;
          _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ using large TEST UUID for request: %{public}@", (uint8_t *)buf, 0x20u);
        }

        *BOOL v64 = -1;
        if (!v36) {
          goto LABEL_107;
        }
LABEL_63:
        v45[616] |= 0x10u;
        nwsc_schedule_prexisting_connection_retry(*(NWConcrete_nw_service_connector **)(a1 + 40), (NWConcrete_nw_unique_connection_request *)v45, v125, 0);
      }
      else
      {
        if (v36) {
          goto LABEL_63;
        }
LABEL_107:
        uint64_t v89 = *(_DWORD **)(a1 + 40);
        if (v89[4] == 1)
        {
          v45[616] |= 8u;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v90 = (id)gLogObj;
          if (os_log_type_enabled(v90, OS_LOG_TYPE_DEFAULT))
          {
            uint64_t v91 = *(void *)(a1 + 40);
            LODWORD(buf[0]) = 136446722;
            *(void *)((char *)buf + 4) = "nw_service_connector_start_request_block_invoke";
            WORD6(buf[0]) = 2114;
            *(void *)((char *)buf + 14) = v91;
            WORD3(buf[1]) = 2114;
            *((void *)&buf[1] + nw_tcp_options_set_enable_fast_open(options, 1) = v45;
            _os_log_impl(&dword_1830D4000, v90, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ holding request for listener ready: %{public}@", (uint8_t *)buf, 0x20u);
          }
        }
        else
        {
          os_log_type_t v92 = nwsc_request_create_and_start_connection_inner(v89, v45, 0);
          BOOL v93 = v92 == 0;

          if (v93)
          {
            nw_service_connector_cancel_request_inner(*(void **)(a1 + 40), *v48, (uint64_t)(v45 + 24), 0, 0);
            nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 40), v45, 0, 0, 12);
            goto LABEL_129;
          }
        }
      }
      id v94 = (uint64_t *)*(id *)(a1 + 40);
      int v83 = v45;
      if (v94)
      {
        if (v94[12])
        {
          int v137 = 0;
          memset(buf, 0, sizeof(buf));
          if (nwsc_get_identifier(*v48, (uint64_t)(v45 + 24), buf))
          {
            nw_dictionary_set_value(v94[12], (const char *)buf, v83);
LABEL_138:

            goto LABEL_139;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v95 = (id)gLogObj;
          os_log_type_t v96 = *v48;
          *(_DWORD *)os_log_type_t type = 136446722;
          *(void *)&os_log_type_t type[4] = "nw_service_connector_add_active_outgoing_request";
          *(_WORD *)&type[12] = 2114;
          *(void *)&type[14] = v96;
          *(_WORD *)&type[22] = 2082;
          long long v133 = v45 + 24;
          BOOL v97 = (void *)_os_log_send_and_compose_impl();

          os_log_type_t v131 = OS_LOG_TYPE_ERROR;
          char v130 = 0;
          if (__nwlog_fault((const char *)v97, &v131, &v130))
          {
            if (v131 == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v98 = (id)gLogObj;
              os_log_type_t v99 = v131;
              if (os_log_type_enabled(v98, v131))
              {
                int v100 = *v48;
                *(_DWORD *)os_log_type_t type = 136446722;
                *(void *)&os_log_type_t type[4] = "nw_service_connector_add_active_outgoing_request";
                *(_WORD *)&type[12] = 2114;
                *(void *)&type[14] = v100;
                *(_WORD *)&type[22] = 2082;
                long long v133 = v53;
                _os_log_impl(&dword_1830D4000, v98, v99, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s", type, 0x20u);
              }
              goto LABEL_120;
            }
            if (v130)
            {
              __int16 v101 = (char *)__nw_create_backtrace_string();
              int v102 = __nwlog_obj();
              os_log_type_t v103 = v131;
              BOOL v104 = os_log_type_enabled(v102, v131);
              if (v101)
              {
                if (v104)
                {
                  long long v105 = *v48;
                  *(_DWORD *)os_log_type_t type = 136446978;
                  *(void *)&os_log_type_t type[4] = "nw_service_connector_add_active_outgoing_request";
                  *(_WORD *)&type[12] = 2114;
                  *(void *)&type[14] = v105;
                  *(_WORD *)&type[22] = 2082;
                  long long v133 = v53;
                  __int16 v134 = 2082;
                  long long v135 = v101;
                  _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, dumping backtrace:%{public}s", type, 0x2Au);
                }

LABEL_126:
                free(v101);
                if (!v97) {
                  goto LABEL_138;
                }
LABEL_137:
                free(v97);
                goto LABEL_138;
              }
              if (v104)
              {
                long long v108 = *v48;
                *(_DWORD *)os_log_type_t type = 136446722;
                *(void *)&os_log_type_t type[4] = "nw_service_connector_add_active_outgoing_request";
                *(_WORD *)&type[12] = 2114;
                *(void *)&type[14] = v108;
                *(_WORD *)&type[22] = 2082;
                long long v133 = v53;
                _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, no backtrace", type, 0x20u);
              }
            }
            else
            {
              os_log_type_t v98 = __nwlog_obj();
              os_log_type_t v106 = v131;
              if (os_log_type_enabled(v98, v131))
              {
                long long v107 = *v48;
                *(_DWORD *)os_log_type_t type = 136446722;
                *(void *)&os_log_type_t type[4] = "nw_service_connector_add_active_outgoing_request";
                *(_WORD *)&type[12] = 2114;
                *(void *)&type[14] = v107;
                *(_WORD *)&type[22] = 2082;
                long long v133 = v53;
                _os_log_impl(&dword_1830D4000, v98, v106, "%{public}s Could not get identifier for endpoint %{public}@, service %{public}s, backtrace limit exceeded", type, 0x20u);
              }
LABEL_120:
            }
          }
LABEL_136:
          if (!v97) {
            goto LABEL_138;
          }
          goto LABEL_137;
        }
        long long v112 = __nwlog_obj();
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
        BOOL v97 = (void *)_os_log_send_and_compose_impl();

        type[0] = 16;
        os_log_type_t v131 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault((const char *)v97, type, &v131)) {
          goto LABEL_136;
        }
        if (type[0] == 17)
        {
          long long v110 = __nwlog_obj();
          os_log_type_t v113 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl(&dword_1830D4000, v110, v113, "%{public}s called with null serviceConnector->activeOutgoingRequests", (uint8_t *)buf, 0xCu);
          }
LABEL_170:

          goto LABEL_136;
        }
        if (v131 == OS_LOG_TYPE_DEFAULT)
        {
          long long v110 = __nwlog_obj();
          os_log_type_t v121 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl(&dword_1830D4000, v110, v121, "%{public}s called with null serviceConnector->activeOutgoingRequests, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_170;
        }
        __int16 v101 = (char *)__nw_create_backtrace_string();
        long long v115 = __nwlog_obj();
        os_log_type_t v118 = type[0];
        BOOL v119 = os_log_type_enabled(v115, (os_log_type_t)type[0]);
        if (v101)
        {
          if (v119)
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v101;
            _os_log_impl(&dword_1830D4000, v115, v118, "%{public}s called with null serviceConnector->activeOutgoingRequests, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
          }

          goto LABEL_126;
        }
        if (v119)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl(&dword_1830D4000, v115, v118, "%{public}s called with null serviceConnector->activeOutgoingRequests, no backtrace", (uint8_t *)buf, 0xCu);
        }
      }
      else
      {
        long long v109 = __nwlog_obj();
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
        BOOL v97 = (void *)_os_log_send_and_compose_impl();

        type[0] = 16;
        os_log_type_t v131 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault((const char *)v97, type, &v131)) {
          goto LABEL_136;
        }
        if (type[0] == 17)
        {
          long long v110 = __nwlog_obj();
          os_log_type_t v111 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl(&dword_1830D4000, v110, v111, "%{public}s called with null serviceConnector", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_170;
        }
        if (v131 == OS_LOG_TYPE_DEFAULT)
        {
          long long v110 = __nwlog_obj();
          os_log_type_t v120 = type[0];
          if (os_log_type_enabled(v110, (os_log_type_t)type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            _os_log_impl(&dword_1830D4000, v110, v120, "%{public}s called with null serviceConnector, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_170;
        }
        long long v114 = (char *)__nw_create_backtrace_string();
        long long v115 = __nwlog_obj();
        os_log_type_t v116 = type[0];
        BOOL v117 = os_log_type_enabled(v115, (os_log_type_t)type[0]);
        if (v114)
        {
          if (v117)
          {
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
            WORD6(buf[0]) = 2082;
            *(void *)((char *)buf + 14) = v114;
            _os_log_impl(&dword_1830D4000, v115, v116, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
          }

          free(v114);
          goto LABEL_136;
        }
        if (v117)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_service_connector_add_active_outgoing_request";
          _os_log_impl(&dword_1830D4000, v115, v116, "%{public}s called with null serviceConnector, no backtrace", (uint8_t *)buf, 0xCu);
        }
      }

      goto LABEL_136;
    }
  }
  if (string_ptr)
  {
    if (v54 >= 2) {
      goto LABEL_51;
    }
    goto LABEL_55;
  }
  long long v123 = __nwlog_obj();
  os_log_type_enabled(v123, OS_LOG_TYPE_ERROR);
  LODWORD(buf[0]) = 136446210;
  *(void *)((char *)buf + 4) = "_strict_strlcpy";
  long long v122 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v122))
  {
    free(v122);
    if (v54 >= 2)
    {
LABEL_51:
      uint64_t v62 = 0;
      while (1)
      {
        int v63 = string_ptr[v62];
        v55[v62] = v63;
        if (!v63) {
          goto LABEL_56;
        }
        --v54;
        ++v62;
        if (v54 <= 1)
        {
          v55 += v62;
          break;
        }
      }
    }
LABEL_55:
    *os_log_type_t v55 = 0;
    goto LABEL_56;
  }
LABEL_177:
  __break(1u);
}

void sub_183A877F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_start_request_block_invoke_112(uint64_t a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 32);
      uint64_t v6 = *(void *)(a1 + 40);
      int v10 = 136446978;
      BOOL v11 = "nw_service_connector_start_request_block_invoke";
      __int16 v12 = 2114;
      uint64_t v13 = v5;
      __int16 v14 = 2114;
      uint64_t v15 = v6;
      __int16 v16 = 1024;
      int v17 = a2;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ error when accepting request %{public}@ %{darwin.errno}d", (uint8_t *)&v10, 0x26u);
    }

    nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), *(void **)(*(void *)(a1 + 40) + 8), *(void *)(a1 + 40) + 24, *(void **)(*(void *)(a1 + 40) + 576), 0);
    nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), 0, *(void **)(a1 + 48), 0, a2);
  }
  else
  {
    BOOL v7 = *(void **)(a1 + 48);
    uint64_t v8 = *(void **)(a1 + 32);
    uint64_t v9 = *(void **)(*(void *)(a1 + 40) + 576);
    nw_service_connector_trigger_request_complete_block_inner(v8, 0, v7, v9, 0);
  }
}

void nwsc_schedule_prexisting_connection_retry(NWConcrete_nw_service_connector *a1, NWConcrete_nw_unique_connection_request *a2, NWConcrete_nw_unique_connection *a3, unsigned int a4)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  BOOL v7 = a1;
  uint64_t v8 = a2;
  uint64_t v9 = a3;
  if (a4 < 0x14)
  {
    uint64_t preexistingConnectionTimer = (uint64_t)v8->preexistingConnectionTimer;
    if (preexistingConnectionTimer)
    {
      nw_queue_cancel_source(preexistingConnectionTimer);
      v8->uint64_t preexistingConnectionTimer = 0;
    }
    objc_initWeak((id *)buf, v8);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke;
    v14[3] = &unk_1E52433B8;
    uint64_t v15 = v7;
    objc_copyWeak(&v17, (id *)buf);
    __int16 v16 = v9;
    unsigned int v18 = a4;
    BOOL source = nw_queue_context_create_source(0, 2, 3, 0, v14, 0);
    v8->uint64_t preexistingConnectionTimer = (void *)source;
    dispatch_time_t v13 = dispatch_time(0x8000000000000000, 100000000);
    nw_queue_set_timer_values(source, v13, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
    nw_queue_activate_source((uint64_t)v8->preexistingConnectionTimer);

    objc_destroyWeak(&v17);
    objc_destroyWeak((id *)buf);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v10 = (id)gLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446978;
      uint64_t v20 = "nwsc_schedule_prexisting_connection_retry";
      __int16 v21 = 2114;
      uint64_t v22 = v7;
      __int16 v23 = 2114;
      __int16 v24 = v8;
      __int16 v25 = 2114;
      __int16 v26 = v9;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ request %{public}@ still has existing activeConnection %{public}@", buf, 0x2Au);
    }

    nw_service_connector_cancel_request_inner(v7, v8->endpoint, (uint64_t)v8->service, 0, 0);
    nw_service_connector_trigger_request_complete_block_inner(v7, v8, 0, 0, 17);
  }
}

void sub_183A87CA8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, uint64_t a15, uint64_t a16, id location)
{
  objc_destroyWeak(v20);
  objc_destroyWeak(&location);

  _Unwind_Resume(a1);
}

void ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke(uint64_t a1)
{
  int v2 = *(NSObject **)(*(void *)(a1 + 32) + 32);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke_2;
  v3[3] = &unk_1E52433B8;
  objc_copyWeak(&v6, (id *)(a1 + 48));
  id v4 = *(id *)(a1 + 32);
  id v5 = *(id *)(a1 + 40);
  int v7 = *(_DWORD *)(a1 + 56);
  dispatch_async(v2, v3);

  objc_destroyWeak(&v6);
}

void ___ZL41nwsc_schedule_prexisting_connection_retryP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestP31NWConcrete_nw_unique_connectionj_block_invoke_2(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  WeakRetained = (NWConcrete_nw_unique_connection_request *)objc_loadWeakRetained((id *)(a1 + 48));
  uint64_t v3 = WeakRetained;
  if (WeakRetained)
  {
    if (*(_DWORD *)(*(void *)(a1 + 32) + 16) == 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        uint64_t v5 = *(void *)(a1 + 32);
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nwsc_schedule_prexisting_connection_retry_block_invoke_2";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring connection retry", buf, 0x16u);
      }
    }
    else if ((*((unsigned char *)WeakRetained + 616) & 0x10) != 0)
    {
      id v6 = *(void **)(*(void *)(a1 + 40) + 488);
      if (!v6) {
        goto LABEL_9;
      }
      int v7 = v6;
      uint64_t v19 = 0;
      uint64_t v20 = &v19;
      uint64_t v21 = 0x2020000000;
      char v22 = 0;
      uint64_t v8 = v7 + 34;
      *(void *)long long buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
      __int16 v24 = (NWConcrete_nw_unique_connection_request *)&unk_1E524B978;
      *((void *)&v25 + nw_tcp_options_set_enable_fast_open(options, 1) = &v19;
      uint64_t v9 = v7;
      *(void *)&long long v25 = v9;
      os_unfair_lock_lock(v8);
      (*(void (**)(unsigned char *))&buf[16])(buf);
      os_unfair_lock_unlock(v8);
      LODWORD(v_Block_object_dispose(&a9, 8) = *((unsigned __int8 *)v20 + 24);

      _Block_object_dispose(&v19, 8);
      if (!v8)
      {
        nwsc_schedule_prexisting_connection_retry(*(NWConcrete_nw_service_connector **)(a1 + 32), v3, *(NWConcrete_nw_unique_connection **)(a1 + 40), *(_DWORD *)(a1 + 56) + 1);
      }
      else
      {
LABEL_9:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v10 = (id)gLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
        {
          uint64_t v11 = *(void *)(a1 + 32);
          uint64_t v12 = *(void *)(a1 + 40);
          *(_DWORD *)long long buf = 136446978;
          *(void *)&uint8_t buf[4] = "nwsc_schedule_prexisting_connection_retry_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2114;
          *(void *)&buf[14] = v11;
          *(_WORD *)&buf[22] = 2114;
          __int16 v24 = v3;
          LOWORD(v25) = 2114;
          *(void *)((char *)&v25 + 2) = v12;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ restarting request %{public}@ with inactive activeConnection %{public}@", buf, 0x2Au);
        }

        dispatch_time_t v13 = *(NWConcrete_nw_unique_connection **)(a1 + 40);
        p_super = &v13->connection->super;
        if (p_super)
        {
          nw_connection_cancel(p_super);
          uint64_t v15 = *(void *)(a1 + 40);
          __int16 v16 = *(void **)(v15 + 488);
          *(void *)(v15 + 48_Block_object_dispose(&a9, 8) = 0;

          dispatch_time_t v13 = *(NWConcrete_nw_unique_connection **)(a1 + 40);
        }
        nw_service_connector_remove_active_connection(*(NWConcrete_nw_service_connector **)(a1 + 32), v13);
        *((unsigned char *)v3 + 616) &= ~0x10u;
        id v17 = nwsc_request_create_and_start_connection_inner(*(void **)(a1 + 32), v3, 0);
        BOOL v18 = v17 == 0;

        if (v18)
        {
          nw_service_connector_cancel_request_inner(*(void **)(a1 + 32), v3->endpoint, (uint64_t)v3->service, 0, 0);
          nw_service_connector_trigger_request_complete_block_inner(*(void **)(a1 + 32), v3, 0, 0, 12);
        }
      }
    }
  }
}

void sub_183A880E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_cancel_request(void *a1, void *a2, const char *a3)
{
  v58[2] = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  id v6 = a2;
  int v7 = v6;
  if (!v5)
  {
    uint64_t v29 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unint64_t v54 = "nw_service_connector_cancel_request";
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v10, &type, &v51)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v51)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v30, type);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v54 = "nw_service_connector_cancel_request";
          __int16 v55 = 2082;
          size_t v56 = (size_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }
      if (v38)
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v44, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_95:

    goto LABEL_35;
  }
  if (!v6)
  {
    BOOL v32 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unint64_t v54 = "nw_service_connector_cancel_request";
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v10, &type, &v51)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v33, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_95;
    }
    if (!v51)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v45, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_95;
    }
    char v39 = (char *)__nw_create_backtrace_string();
    os_log_type_t v30 = __nwlog_obj();
    os_log_type_t v40 = type;
    BOOL v41 = os_log_type_enabled(v30, type);
    if (!v39)
    {
      if (v41)
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v40, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_95;
    }
    if (v41)
    {
      *(_DWORD *)long long buf = 136446466;
      unint64_t v54 = "nw_service_connector_cancel_request";
      __int16 v55 = 2082;
      size_t v56 = (size_t)v39;
      _os_log_impl(&dword_1830D4000, v30, v40, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_76;
  }
  if (!a3)
  {
    os_log_type_t v34 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unint64_t v54 = "nw_service_connector_cancel_request";
    int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (!__nwlog_fault(v10, &type, &v51)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v35, "%{public}s called with null userService", buf, 0xCu);
      }
      goto LABEL_95;
    }
    if (!v51)
    {
      os_log_type_t v30 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v46, "%{public}s called with null userService, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_95;
    }
    char v39 = (char *)__nw_create_backtrace_string();
    os_log_type_t v30 = __nwlog_obj();
    os_log_type_t v42 = type;
    BOOL v43 = os_log_type_enabled(v30, type);
    if (!v39)
    {
      if (v43)
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v54 = "nw_service_connector_cancel_request";
        _os_log_impl(&dword_1830D4000, v30, v42, "%{public}s called with null userService, no backtrace", buf, 0xCu);
      }
      goto LABEL_95;
    }
    if (v43)
    {
      *(_DWORD *)long long buf = 136446466;
      unint64_t v54 = "nw_service_connector_cancel_request";
      __int16 v55 = 2082;
      size_t v56 = (size_t)v39;
      _os_log_impl(&dword_1830D4000, v30, v42, "%{public}s called with null userService, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_76:

    free(v39);
    if (!v10) {
      goto LABEL_46;
    }
    goto LABEL_36;
  }
  size_t v8 = strlen(a3);
  if (v8 < 0x101)
  {
    size_t v13 = v8;
    xpc_object_t v14 = xpc_string_create(a3);
    uint64_t v15 = v14;
    if (v14)
    {
      __int16 v16 = v5[4];
      block[0] = MEMORY[0x1E4F143A8];
      block[1] = 3221225472;
      block[2] = __nw_service_connector_cancel_request_block_invoke;
      block[3] = &unk_1E5249868;
      id v48 = v14;
      __int16 v49 = v5;
      id v50 = v7;
      dispatch_async(v16, block);

LABEL_45:
      goto LABEL_46;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v20 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446466;
    unint64_t v54 = "nw_service_connector_cancel_request";
    __int16 v55 = 2048;
    size_t v56 = v13;
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v51 = 0;
    if (__nwlog_fault(v21, &type, &v51))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v22 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v54 = "nw_service_connector_cancel_request";
          __int16 v55 = 2048;
          size_t v56 = v13;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
        }
      }
      else if (v51)
      {
        long long v25 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v22 = (id)gLogObj;
        os_log_type_t v26 = type;
        BOOL v27 = os_log_type_enabled(v22, type);
        if (v25)
        {
          if (v27)
          {
            *(_DWORD *)long long buf = 136446722;
            unint64_t v54 = "nw_service_connector_cancel_request";
            __int16 v55 = 2048;
            size_t v56 = v13;
            __int16 v57 = 2082;
            v58[0] = v25;
            _os_log_impl(&dword_1830D4000, v22, v26, "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v25);
          if (!v21) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }
        if (v27)
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v54 = "nw_service_connector_cancel_request";
          __int16 v55 = 2048;
          size_t v56 = v13;
          _os_log_impl(&dword_1830D4000, v22, v26, "%{public}s xpc_string_create(%zu) failed, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v22 = (id)gLogObj;
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v54 = "nw_service_connector_cancel_request";
          __int16 v55 = 2048;
          size_t v56 = v13;
          _os_log_impl(&dword_1830D4000, v22, v28, "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
    if (!v21) {
      goto LABEL_45;
    }
LABEL_44:
    free(v21);
    goto LABEL_45;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v9 = (id)gLogObj;
  *(_DWORD *)long long buf = 136446722;
  unint64_t v54 = "nw_service_connector_cancel_request";
  __int16 v55 = 2082;
  size_t v56 = (size_t)a3;
  __int16 v57 = 1024;
  LODWORD(v58[0]) = 256;
  int v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v51 = 0;
  if (__nwlog_fault(v10, &type, &v51))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446722;
        unint64_t v54 = "nw_service_connector_cancel_request";
        __int16 v55 = 2082;
        size_t v56 = (size_t)a3;
        __int16 v57 = 1024;
        LODWORD(v58[0]) = 256;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d", buf, 0x1Cu);
      }
    }
    else if (v51)
    {
      id v17 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)long long buf = 136446978;
          unint64_t v54 = "nw_service_connector_cancel_request";
          __int16 v55 = 2082;
          size_t v56 = (size_t)a3;
          __int16 v57 = 1024;
          LODWORD(v58[0]) = 256;
          WORD2(v58[0]) = 2082;
          *(void *)((char *)v58 + 6) = v17;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, dumping backtrace:%{public}s", buf, 0x26u);
        }

        free(v17);
        if (v10) {
          goto LABEL_36;
        }
        goto LABEL_46;
      }
      if (v19)
      {
        *(_DWORD *)long long buf = 136446722;
        unint64_t v54 = "nw_service_connector_cancel_request";
        __int16 v55 = 2082;
        size_t v56 = (size_t)a3;
        __int16 v57 = 1024;
        LODWORD(v58[0]) = 256;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, no backtrace", buf, 0x1Cu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = (id)gLogObj;
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)long long buf = 136446722;
        unint64_t v54 = "nw_service_connector_cancel_request";
        __int16 v55 = 2082;
        size_t v56 = (size_t)a3;
        __int16 v57 = 1024;
        LODWORD(v58[0]) = 256;
        _os_log_impl(&dword_1830D4000, v11, v24, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, backtrace limit exceeded", buf, 0x1Cu);
      }
    }
  }
LABEL_35:
  if (v10) {
LABEL_36:
  }
    free(v10);
LABEL_46:
}

void sub_183A88E24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_cancel_request_block_invoke(xpc_object_t *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  string_ptr = xpc_string_get_string_ptr(a1[4]);
  int v3 = *((_DWORD *)a1[5] + 4);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (id)gLogObj;
  uint64_t v5 = (NWConcrete_nw_unique_connection_request *)v4;
  if (v3 == 4)
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      xpc_object_t v6 = a1[5];
      xpc_object_t v7 = a1[6];
      int v15 = 136446978;
      __int16 v16 = "nw_service_connector_cancel_request_block_invoke";
      __int16 v17 = 2114;
      xpc_object_t v18 = v6;
      __int16 v19 = 2082;
      id v20 = (void *)string_ptr;
      __int16 v21 = 2114;
      xpc_object_t v22 = v7;
      _os_log_impl(&dword_1830D4000, &v5->super, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client cancelling service \"%{public}s\" to %{public}@", (uint8_t *)&v15, 0x2Au);
    }
  }
  else
  {
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEFAULT))
    {
      xpc_object_t v8 = a1[5];
      xpc_object_t v9 = a1[6];
      int v15 = 136446978;
      __int16 v16 = "nw_service_connector_cancel_request_block_invoke";
      __int16 v17 = 2114;
      xpc_object_t v18 = v8;
      __int16 v19 = 2082;
      id v20 = (void *)string_ptr;
      __int16 v21 = 2114;
      xpc_object_t v22 = v9;
      _os_log_impl(&dword_1830D4000, &v5->super, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancelling request for service \"%{public}s\" to %{public}@", (uint8_t *)&v15, 0x2Au);
    }

    uint64_t v5 = (NWConcrete_nw_unique_connection_request *)nw_service_connector_copy_pending_incoming_request(a1[5], a1[6], (uint64_t)string_ptr);
    if (v5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v11 = a1[5];
        int v15 = 136446722;
        __int16 v16 = "nw_service_connector_cancel_request_block_invoke";
        __int16 v17 = 2114;
        xpc_object_t v18 = v11;
        __int16 v19 = 2114;
        id v20 = v5;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancel: rejecting incoming %{public}@", (uint8_t *)&v15, 0x20u);
      }

      nw_service_connector_reject_incoming_request((NWConcrete_nw_service_connector *)a1[5], v5, 1);
    }
    os_log_type_t v12 = nw_service_connector_copy_active_outgoing_request(a1[5], a1[6], (uint64_t)string_ptr);
    nw_service_connector_cancel_request_inner(a1[5], a1[6], (uint64_t)string_ptr, 0, 0);
    if (v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v13 = (id)gLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        xpc_object_t v14 = a1[5];
        int v15 = 136446722;
        __int16 v16 = "nw_service_connector_cancel_request_block_invoke";
        __int16 v17 = 2114;
        xpc_object_t v18 = v14;
        __int16 v19 = 2114;
        id v20 = v5;
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancel: cancelling outgoing %{public}@", (uint8_t *)&v15, 0x20u);
      }

      nw_service_connector_trigger_request_complete_block_inner(a1[5], v12, 0, 0, 89);
    }
  }
}

void sub_183A89158(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_service_connector_cancel_active_connection(void *a1, void *a2, const char *a3, void *a4)
{
  v81[2] = *MEMORY[0x1E4F143B8];
  xpc_object_t v7 = a1;
  id v8 = a2;
  id v9 = a4;
  int v10 = v9;
  if (!v7)
  {
    __int16 v55 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
    size_t v56 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v74 = 0;
    if (!__nwlog_fault(v56, &type, &v74)) {
      goto LABEL_136;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s called with null serviceConnector", buf, 0xCu);
      }
    }
    else if (v74)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v57 = __nwlog_obj();
      os_log_type_t v62 = type;
      BOOL v63 = os_log_type_enabled(v57, type);
      if (backtrace_string)
      {
        if (v63)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          __int16 v78 = 2082;
          size_t v79 = (size_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v57, v62, "%{public}s called with null serviceConnector, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_136:
        if (!v56) {
          goto LABEL_79;
        }
LABEL_137:
        free(v56);
        goto LABEL_79;
      }
      if (v63)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_1830D4000, v57, v62, "%{public}s called with null serviceConnector, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v57 = __nwlog_obj();
      os_log_type_t v67 = type;
      if (os_log_type_enabled(v57, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        _os_log_impl(&dword_1830D4000, v57, v67, "%{public}s called with null serviceConnector, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_135:

    goto LABEL_136;
  }
  if (v9)
  {
    if (v8)
    {
      if (a3)
      {
        id v11 = v8;
        int v12 = [v11 type];

        if (v12 == 1)
        {
          size_t v13 = strlen(a3);
          if (v13 >= 0x101)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v14 = (id)gLogObj;
            *(_DWORD *)long long buf = 136446722;
            os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
            __int16 v78 = 2082;
            size_t v79 = (size_t)a3;
            __int16 v80 = 1024;
            LODWORD(v81[0]) = 256;
            int v15 = (const char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v74 = 0;
            if (__nwlog_fault(v15, &type, &v74))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                __int16 v16 = (id)gLogObj;
                os_log_type_t v17 = type;
                if (os_log_type_enabled(v16, type))
                {
                  *(_DWORD *)long long buf = 136446722;
                  os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                  __int16 v78 = 2082;
                  size_t v79 = (size_t)a3;
                  __int16 v80 = 1024;
                  LODWORD(v81[0]) = 256;
                  _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d", buf, 0x1Cu);
                }
              }
              else if (v74)
              {
                os_log_type_t v40 = (char *)__nw_create_backtrace_string();
                __int16 v16 = __nwlog_obj();
                os_log_type_t v41 = type;
                BOOL v42 = os_log_type_enabled(v16, type);
                if (v40)
                {
                  if (v42)
                  {
                    *(_DWORD *)long long buf = 136446978;
                    os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                    __int16 v78 = 2082;
                    size_t v79 = (size_t)a3;
                    __int16 v80 = 1024;
                    LODWORD(v81[0]) = 256;
                    WORD2(v81[0]) = 2082;
                    *(void *)((char *)v81 + 6) = v40;
                    _os_log_impl(&dword_1830D4000, v16, v41, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, dumping backtrace:%{public}s", buf, 0x26u);
                  }

                  free(v40);
                  if (!v15) {
                    goto LABEL_78;
                  }
LABEL_92:
                  __int16 v49 = (char *)v15;
                  goto LABEL_77;
                }
                if (v42)
                {
                  *(_DWORD *)long long buf = 136446722;
                  os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                  __int16 v78 = 2082;
                  size_t v79 = (size_t)a3;
                  __int16 v80 = 1024;
                  LODWORD(v81[0]) = 256;
                  _os_log_impl(&dword_1830D4000, v16, v41, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, no backtrace", buf, 0x1Cu);
                }
              }
              else
              {
                __int16 v16 = __nwlog_obj();
                os_log_type_t v50 = type;
                if (os_log_type_enabled(v16, type))
                {
                  *(_DWORD *)long long buf = 136446722;
                  os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                  __int16 v78 = 2082;
                  size_t v79 = (size_t)a3;
                  __int16 v80 = 1024;
                  LODWORD(v81[0]) = 256;
                  _os_log_impl(&dword_1830D4000, v16, v50, "%{public}s Service name \"%{public}s\" too long. Max allowed length is %d, backtrace limit exceeded", buf, 0x1Cu);
                }
              }
            }
            if (!v15) {
              goto LABEL_78;
            }
            goto LABEL_92;
          }
          size_t v32 = v13;
          xpc_object_t v33 = xpc_string_create(a3);
          os_log_type_t v34 = v33;
          if (v33)
          {
            os_log_type_t v35 = v7[4];
            block[0] = MEMORY[0x1E4F143A8];
            block[1] = 3221225472;
            block[2] = __nw_service_connector_cancel_active_connection_block_invoke;
            block[3] = &unk_1E5249BF8;
            id v70 = v33;
            uint64_t v71 = v7;
            id v72 = v11;
            id v73 = v10;
            dispatch_async(v35, block);

LABEL_102:
            goto LABEL_79;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v44 = (id)gLogObj;
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          __int16 v78 = 2048;
          size_t v79 = v32;
          os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v74 = 0;
          if (__nwlog_fault(v45, &type, &v74))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v46 = __nwlog_obj();
              os_log_type_t v47 = type;
              if (os_log_type_enabled(v46, type))
              {
                *(_DWORD *)long long buf = 136446466;
                os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                __int16 v78 = 2048;
                size_t v79 = v32;
                _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s xpc_string_create(%zu) failed", buf, 0x16u);
              }
            }
            else if (v74)
            {
              char v51 = (char *)__nw_create_backtrace_string();
              os_log_type_t v46 = __nwlog_obj();
              os_log_type_t v52 = type;
              BOOL v53 = os_log_type_enabled(v46, type);
              if (v51)
              {
                if (v53)
                {
                  *(_DWORD *)long long buf = 136446722;
                  os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                  __int16 v78 = 2048;
                  size_t v79 = v32;
                  __int16 v80 = 2082;
                  v81[0] = v51;
                  _os_log_impl(&dword_1830D4000, v46, v52, "%{public}s xpc_string_create(%zu) failed, dumping backtrace:%{public}s", buf, 0x20u);
                }

                free(v51);
                goto LABEL_99;
              }
              if (v53)
              {
                *(_DWORD *)long long buf = 136446466;
                os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                __int16 v78 = 2048;
                size_t v79 = v32;
                _os_log_impl(&dword_1830D4000, v46, v52, "%{public}s xpc_string_create(%zu) failed, no backtrace", buf, 0x16u);
              }
            }
            else
            {
              os_log_type_t v46 = __nwlog_obj();
              os_log_type_t v54 = type;
              if (os_log_type_enabled(v46, type))
              {
                *(_DWORD *)long long buf = 136446466;
                os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
                __int16 v78 = 2048;
                size_t v79 = v32;
                _os_log_impl(&dword_1830D4000, v46, v54, "%{public}s xpc_string_create(%zu) failed, backtrace limit exceeded", buf, 0x16u);
              }
            }
          }
LABEL_99:
          if (v45) {
            free(v45);
          }
          dispatch_async(v7[4], v10);
          goto LABEL_102;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v24 = (id)gLogObj;
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        __int16 v78 = 2114;
        size_t v79 = (size_t)v11;
        __int16 v19 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v74 = 0;
        if (!__nwlog_fault(v19, &type, &v74)) {
          goto LABEL_75;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          long long v25 = (id)gLogObj;
          os_log_type_t v26 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
            __int16 v78 = 2114;
            size_t v79 = (size_t)v11;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s Specified endpoint %{public}@ is not an address endpoint", buf, 0x16u);
          }
LABEL_74:

LABEL_75:
          if (!v19)
          {
LABEL_78:
            dispatch_async(v7[4], v10);
            goto LABEL_79;
          }
          goto LABEL_76;
        }
        if (!v74)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          long long v25 = (id)gLogObj;
          os_log_type_t v48 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
            __int16 v78 = 2114;
            size_t v79 = (size_t)v11;
            _os_log_impl(&dword_1830D4000, v25, v48, "%{public}s Specified endpoint %{public}@ is not an address endpoint, backtrace limit exceeded", buf, 0x16u);
          }
          goto LABEL_74;
        }
        int v36 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v25 = (id)gLogObj;
        os_log_type_t v37 = type;
        BOOL v38 = os_log_type_enabled(v25, type);
        if (!v36)
        {
          if (v38)
          {
            *(_DWORD *)long long buf = 136446466;
            os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
            __int16 v78 = 2114;
            size_t v79 = (size_t)v11;
            _os_log_impl(&dword_1830D4000, v25, v37, "%{public}s Specified endpoint %{public}@ is not an address endpoint, no backtrace", buf, 0x16u);
          }
          goto LABEL_74;
        }
        if (v38)
        {
          *(_DWORD *)long long buf = 136446722;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          __int16 v78 = 2114;
          size_t v79 = (size_t)v11;
          __int16 v80 = 2082;
          v81[0] = v36;
          _os_log_impl(&dword_1830D4000, v25, v37, "%{public}s Specified endpoint %{public}@ is not an address endpoint, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v36);
        if (!v19) {
          goto LABEL_78;
        }
LABEL_76:
        __int16 v49 = (char *)v19;
LABEL_77:
        free(v49);
        goto LABEL_78;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v22 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
      __int16 v19 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v74 = 0;
      if (!__nwlog_fault(v19, &type, &v74)) {
        goto LABEL_75;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null service", buf, 0xCu);
        }
LABEL_71:

        goto LABEL_75;
      }
      if (!v74)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (id)gLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_1830D4000, v20, v43, "%{public}s called with null service, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_71;
      }
      BOOL v27 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v20, type);
      if (!v27)
      {
        if (v31)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null service, no backtrace", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (v31)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        __int16 v78 = 2082;
        size_t v79 = (size_t)v27;
        _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null service, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v18 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
      __int16 v19 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v74 = 0;
      if (!__nwlog_fault(v19, &type, &v74)) {
        goto LABEL_75;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (!v74)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v20 = (id)gLogObj;
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_1830D4000, v20, v39, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_71;
      }
      BOOL v27 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v20, type);
      if (!v27)
      {
        if (v29)
        {
          *(_DWORD *)long long buf = 136446210;
          os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
          _os_log_impl(&dword_1830D4000, v20, v28, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_71;
      }
      if (v29)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
        __int16 v78 = 2082;
        size_t v79 = (size_t)v27;
        _os_log_impl(&dword_1830D4000, v20, v28, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v27);
    if (!v19) {
      goto LABEL_78;
    }
    goto LABEL_76;
  }
  os_log_type_t v59 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
  size_t v56 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v74 = 0;
  if (!__nwlog_fault(v56, &type, &v74)) {
    goto LABEL_136;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    __int16 v57 = __nwlog_obj();
    os_log_type_t v60 = type;
    if (os_log_type_enabled(v57, type))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
      _os_log_impl(&dword_1830D4000, v57, v60, "%{public}s called with null completionBlock", buf, 0xCu);
    }
    goto LABEL_135;
  }
  if (!v74)
  {
    __int16 v57 = __nwlog_obj();
    os_log_type_t v68 = type;
    if (os_log_type_enabled(v57, type))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
      _os_log_impl(&dword_1830D4000, v57, v68, "%{public}s called with null completionBlock, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_135;
  }
  BOOL v64 = (char *)__nw_create_backtrace_string();
  __int16 v57 = __nwlog_obj();
  os_log_type_t v65 = type;
  BOOL v66 = os_log_type_enabled(v57, type);
  if (!v64)
  {
    if (v66)
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
      _os_log_impl(&dword_1830D4000, v57, v65, "%{public}s called with null completionBlock, no backtrace", buf, 0xCu);
    }
    goto LABEL_135;
  }
  if (v66)
  {
    *(_DWORD *)long long buf = 136446466;
    os_log_type_t v77 = "nw_service_connector_cancel_active_connection";
    __int16 v78 = 2082;
    size_t v79 = (size_t)v64;
    _os_log_impl(&dword_1830D4000, v57, v65, "%{public}s called with null completionBlock, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v64);
  if (v56) {
    goto LABEL_137;
  }
LABEL_79:
}

void sub_183A8A43C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_service_connector_cancel_active_connection_block_invoke(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)(a1 + 32));
  int v3 = *(_DWORD **)(a1 + 40);
  if (v3[4] == 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (NWConcrete_nw_unique_connection *)(id)gLogObj;
    if (os_log_type_enabled(&v4->super, OS_LOG_TYPE_ERROR))
    {
      uint64_t v5 = *(void *)(a1 + 40);
      uint64_t v6 = *(void *)(a1 + 48);
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v5;
      *(_WORD *)&buf[22] = 2082;
      id v24 = string_ptr;
      *(_WORD *)long long v25 = 2114;
      *(void *)&v25[2] = v6;
      _os_log_impl(&dword_1830D4000, &v4->super, OS_LOG_TYPE_ERROR, "%{public}s %{public}@ already cancelled, ignoring client cancelling active connection for service \"%{public}s\" to %{public}@", buf, 0x2Au);
    }
  }
  else
  {
    id v4 = (NWConcrete_nw_unique_connection *)nw_service_connector_copy_active_connection_with_endpoint_and_service(v3, *(void **)(a1 + 48), (uint64_t)string_ptr);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    xpc_object_t v7 = (id)gLogObj;
    BOOL v8 = os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT);
    if (v4)
    {
      if (v8)
      {
        uint64_t v10 = *(void *)(a1 + 40);
        uint64_t v9 = *(void *)(a1 + 48);
        id v11 = "dead";
        connection = v4->connection;
        if (connection)
        {
          size_t v13 = connection;
          uint64_t v19 = 0;
          id v20 = &v19;
          uint64_t v21 = 0x2020000000;
          char v22 = 0;
          id v14 = v13 + 34;
          *(void *)long long buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&buf[16] = __nw_connection_is_cancelled_or_failed_block_invoke;
          id v24 = (const char *)&unk_1E524B978;
          *(void *)&v25[8] = &v19;
          int v15 = v13;
          *(void *)long long v25 = v15;
          os_unfair_lock_lock(v14);
          (*(void (**)(unsigned char *))&buf[16])(buf);
          os_unfair_lock_unlock(v14);
          LODWORD(v14) = *((unsigned __int8 *)v20 + 24);

          _Block_object_dispose(&v19, 8);
          if (!v14) {
            id v11 = "alive";
          }
        }
        *(_DWORD *)long long buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v10;
        *(_WORD *)&buf[22] = 2082;
        id v24 = string_ptr;
        *(_WORD *)long long v25 = 2114;
        *(void *)&v25[2] = v9;
        *(_WORD *)&v25[10] = 2082;
        *(void *)&v25[12] = v11;
        __int16 v26 = 2114;
        BOOL v27 = v4;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancelling active connection for service \"%{public}s\" to %{public}@: %{public}s activeConnection %{public}@", buf, 0x3Eu);
      }

      nwsc_unique_connection_shutdown_socket(*(NWConcrete_nw_service_connector **)(a1 + 40), v4);
      __int16 v16 = v4->connection;
    }
    else
    {
      if (v8)
      {
        uint64_t v17 = *(void *)(a1 + 40);
        uint64_t v18 = *(void *)(a1 + 48);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_service_connector_cancel_active_connection_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = v17;
        *(_WORD *)&buf[22] = 2082;
        id v24 = string_ptr;
        *(_WORD *)long long v25 = 2114;
        *(void *)&v25[2] = v18;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ client cancelling active connection for service \"%{public}s\" to %{public}@ but no active connection", buf, 0x2Au);
      }

      __int16 v16 = 0;
    }
    nw_service_connector_cancel_request_inner(*(void **)(a1 + 40), *(void **)(a1 + 48), (uint64_t)string_ptr, v16, 0);
    dispatch_async(*(dispatch_queue_t *)(*(void *)(a1 + 40) + 32), *(dispatch_block_t *)(a1 + 56));
  }
}

void sub_183A8A7E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void lsqpack_enc_cleanup(uint64_t a1)
{
  int v2 = *(void **)(a1 + 56);
  if (v2)
  {
    do
    {
      int v3 = (void *)v2[2];
      free(v2);
      int v2 = v3;
    }
    while (v3);
  }
  id v4 = *(void **)(a1 + 80);
  if (v4)
  {
    do
    {
      uint64_t v5 = (void *)*v4;
      free(v4);
      id v4 = v5;
    }
    while (v5);
  }
  free(*(void **)(a1 + 72));
  free(*(void **)(a1 + 216));
  uint64_t v6 = *(FILE **)(a1 + 200);
  if (v6)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
    fwrite("cleaned up", 0xAuLL, 1uLL, *(FILE **)(a1 + 200));
    xpc_object_t v7 = *(FILE **)(a1 + 200);
    fputc(10, v7);
  }
}

unint64_t lsqpack_enc_enc_str(char a1, unsigned char *a2, unint64_t a3, unsigned __int8 *__src, size_t __n)
{
  xpc_object_t v7 = (char *)&__src[__n];
  if (__n)
  {
    BOOL v8 = __src + 1;
    if (v7 <= (char *)__src + 1) {
      uint64_t v9 = (char *)(__src + 1);
    }
    else {
      uint64_t v9 = (char *)&__src[__n];
    }
    int64_t v10 = v9 - (char *)__src;
    if ((unint64_t)(v9 - (char *)__src) >= 2)
    {
      int v13 = 0;
      int v14 = 0;
      unint64_t v15 = v10 & 0xFFFFFFFFFFFFFFFELL;
      unint64_t v16 = v10 & 0xFFFFFFFFFFFFFFFELL;
      do
      {
        uint64_t v17 = *(v8 - 1);
        unsigned int v18 = *v8;
        v8 += 2;
        v13 += encode_table[2 * v17 + 1];
        v14 += encode_table[2 * v18 + 1];
        v16 -= 2;
      }
      while (v16);
      unsigned int v11 = v14 + v13;
      if (v10 == v15) {
        goto LABEL_13;
      }
      int v12 = &__src[v15];
    }
    else
    {
      unsigned int v11 = 0;
      int v12 = __src;
    }
    do
    {
      unsigned int v19 = *v12++;
      v11 += encode_table[2 * v19 + 1];
    }
    while (v12 < (unsigned __int8 *)v7);
  }
  else
  {
    unsigned int v11 = 0;
  }
LABEL_13:
  LODWORD(v20) = v11 >> 3;
  if ((v11 & 7) != 0) {
    unint64_t v20 = (v20 + 1);
  }
  else {
    unint64_t v20 = v20;
  }
  if (v20 < __n)
  {
    unint64_t v21 = ~(-1 << a1);
    int64x2_t v22 = vdupq_n_s64(-1 << a1);
    if (v21 > v20) {
      int v23 = 1;
    }
    else {
      int v23 = 2;
    }
    uint64x2_t v24 = (uint64x2_t)vdupq_n_s64(v20);
    int16x8_t v25 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v24, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CD70, v22)), (int32x4_t)vcgeq_u64(v24, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CD80, v22))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v24, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CD90, v22)), (int32x4_t)vcgeq_u64(v24, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CDA0, v22)))), (int8x16_t)xmmword_183D5CDB0);
    v25.i32[0] = vaddvq_s16(v25);
    uint8x8_t v26 = (uint8x8_t)vcnt_s8(*(int8x8_t *)v25.i8);
    v26.i16[0] = vaddlv_u8(v26);
    unint64_t result = (v23 + v26.i32[0] + v20);
    if (result <= a3)
    {
      int v28 = *a2 & (-2 << a1) | (1 << a1);
      if (v21 <= v20)
      {
        int v37 = -1 << a1;
        uint64_t v38 = ~v37;
        *a2 = v28 | ~(_BYTE)v37;
        os_log_type_t v39 = a2 + 1;
        unint64_t v40 = v20 - v38;
        if (v20 - v38 < 0x80)
        {
          LOBYTE(v20) = v20 - v38;
        }
        else
        {
          do
          {
            *v39++ = v40 | 0x80;
            unint64_t v20 = v40 >> 7;
            unint64_t v41 = v40 >> 14;
            v40 >>= 7;
          }
          while (v41);
        }
        *os_log_type_t v39 = v20;
      }
      else
      {
        *a2 = v28 | v20;
      }
      os_log_type_t v47 = &a2[v23 + v26.i32[0]];
      if (__n < 0xF)
      {
        uint64_t v49 = 0;
        unsigned int v48 = 0;
        if (__src != (unsigned __int8 *)v7)
        {
          do
          {
LABEL_47:
            uint64_t v62 = v49;
            while (1)
            {
              unsigned int v63 = *__src++;
              BOOL v64 = &encode_table[2 * v63];
              uint64_t v49 = *v64;
              unsigned int v65 = v64[1];
              unsigned int v66 = v65 + v48;
              if (v65 + v48 > 0x3F) {
                break;
              }
              uint64_t v62 = (v62 << v65) | v49;
              v48 += v65;
              if (__src == (unsigned __int8 *)v7)
              {
                os_log_type_t v68 = v47;
                uint64_t v49 = v62;
                unsigned int v48 = v66;
                goto LABEL_52;
              }
            }
            uint64_t v67 = v62 << -(uint64_t)v48;
            unsigned int v48 = v65 - (64 - v48);
            *os_log_type_t v47 = HIBYTE(v67);
            v47[1] = BYTE6(v67);
            v47[2] = BYTE5(v67);
            v47[3] = BYTE4(v67);
            LODWORD(v67) = v67 | (v49 >> v48);
            v47[4] = BYTE3(v67);
            v47[5] = BYTE2(v67);
            v47[6] = BYTE1(v67);
            os_log_type_t v68 = v47 + 8;
            v47[7] = v67;
            v47 += 8;
          }
          while (__src != (unsigned __int8 *)v7);
LABEL_52:
          if (!v48) {
            goto LABEL_65;
          }
          goto LABEL_56;
        }
      }
      else
      {
        unsigned int v48 = 0;
        uint64_t v49 = 0;
        os_log_type_t v50 = &a2[v23 + v26.i32[0]];
        while (1)
        {
          os_log_type_t v52 = __src + 2;
          uint64_t v51 = *(unsigned __int16 *)__src;
          unsigned int v53 = hencs[2 * v51];
          unsigned int v54 = v53 + v48;
          if (v53 + v48 > 0x3F)
          {
            os_log_type_t v58 = (unsigned __int16 *)__src;
          }
          else
          {
            do
            {
              unsigned int v48 = v54;
              uint64_t v55 = v49 << v53;
              uint64_t v56 = hencs[2 * v51 + 1];
              unsigned int v57 = *(unsigned __int16 *)v52;
              v52 += 2;
              uint64_t v51 = v57;
              uint64_t v49 = v55 | v56;
              unsigned int v53 = hencs[2 * v57];
              v54 += v53;
            }
            while (v54 < 0x40);
            os_log_type_t v58 = (unsigned __int16 *)(v52 - 2);
          }
          unint64_t __src = v52;
          if (v53 > 0x3F) {
            break;
          }
          char v59 = 64 - v48;
          uint64_t v60 = v49 << -(uint64_t)v48;
          uint64_t v49 = hencs[2 * v51 + 1];
          unsigned int v48 = v53 - (64 - v48);
          unsigned char *v50 = HIBYTE(v60);
          v50[1] = BYTE6(v60);
          _OWORD v50[2] = BYTE5(v60);
          v50[3] = BYTE4(v60);
          int v61 = v60 | (v49 >> (v53 - v59));
          uint8_t v50[4] = HIBYTE(v61);
          v50[5] = BYTE2(v61);
          v50[6] = BYTE1(v61);
          os_log_type_t v47 = v50 + 8;
          v50[7] = v61;
          v50 += 8;
          if (__src + 14 >= (unsigned __int8 *)v7)
          {
            if (__src == (unsigned __int8 *)v7) {
              goto LABEL_55;
            }
            goto LABEL_47;
          }
        }
        os_log_type_t v47 = v50;
        unint64_t __src = (unsigned __int8 *)v58;
        if (v58 != (unsigned __int16 *)v7) {
          goto LABEL_47;
        }
      }
LABEL_55:
      os_log_type_t v68 = v47;
      if (!v48)
      {
LABEL_65:
        if (result != v68 - a2) {
          __assert_rtn("lsqpack_enc_enc_str", "lsqpack.c", 823, "(unsigned) (p - dst) == len_size + enc_size_bytes");
        }
        return result;
      }
LABEL_56:
      unsigned int v69 = v48 + 7;
      char v70 = ((v48 + 7) & 0xF8) - v48;
      uint64_t v71 = v49 << v70;
      int v72 = (v49 << v70) | ~(-1 << v70);
      switch(v69 >> 3)
      {
        case 2u:
          goto LABEL_63;
        case 3u:
          goto LABEL_62;
        case 4u:
          goto LABEL_61;
        case 5u:
          goto LABEL_60;
        case 6u:
          goto LABEL_59;
        case 7u:
          goto LABEL_58;
        case 8u:
          *v68++ = HIBYTE(v71);
LABEL_58:
          *v68++ = BYTE6(v71);
LABEL_59:
          *v68++ = BYTE5(v71);
LABEL_60:
          *v68++ = BYTE4(v71);
LABEL_61:
          *v68++ = HIBYTE(v72);
LABEL_62:
          *v68++ = BYTE2(v72);
LABEL_63:
          *v68++ = BYTE1(v72);
          break;
        default:
          break;
      }
      unsigned char *v68 = v72;
      LODWORD(v6_Block_object_dispose(&a9, 8) = v68 + 1;
      goto LABEL_65;
    }
    return 0xFFFFFFFFLL;
  }
  unint64_t v29 = ~(-1 << a1);
  int64x2_t v30 = vdupq_n_s64(-1 << a1);
  if (v29 > __n) {
    int v31 = 1;
  }
  else {
    int v31 = 2;
  }
  uint64x2_t v32 = (uint64x2_t)vdupq_n_s64(__n);
  int16x8_t v33 = (int16x8_t)vandq_s8((int8x16_t)vuzp1q_s16((int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v32, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CD70, v30)), (int32x4_t)vcgeq_u64(v32, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CD80, v30))), (int16x8_t)vuzp1q_s32((int32x4_t)vcgeq_u64(v32, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CD90, v30)), (int32x4_t)vcgeq_u64(v32, (uint64x2_t)vsubq_s64((int64x2_t)xmmword_183D5CDA0, v30)))), (int8x16_t)xmmword_183D5CDB0);
  v33.i32[0] = vaddvq_s16(v33);
  *(int8x8_t *)v33.i8 = vcnt_s8(*(int8x8_t *)v33.i8);
  v33.i16[0] = vaddlv_u8(*(uint8x8_t *)v33.i8);
  __int32 v34 = v31 + v33.i32[0];
  unint64_t v35 = (v34 + __n);
  if (v35 > a3) {
    return 0xFFFFFFFFLL;
  }
  int v36 = *a2 & (-2 << a1);
  if (v29 <= __n)
  {
    int v42 = -1 << a1;
    unint64_t v43 = ~v42;
    *a2 = v36 | ~(_BYTE)v42;
    id v44 = a2 + 1;
    unint64_t v45 = __n - v43;
    if (v45 < 0x80)
    {
      LOBYTE(v43) = __n - v43;
    }
    else
    {
      do
      {
        *v44++ = v45 | 0x80;
        unint64_t v43 = v45 >> 7;
        unint64_t v46 = v45 >> 14;
        v45 >>= 7;
      }
      while (v46);
    }
    *id v44 = v43;
  }
  else
  {
    *a2 = v36 | __n;
  }
  memcpy(&a2[v34], __src, __n);
  return v35;
}

uint64_t lsqpack_enc_end_header(uint64_t a1, uint64_t a2)
{
  if ((*(unsigned char *)(a1 + 12) & 1) == 0) {
    return -1;
  }
  if (*(void *)(a1 + 216))
  {
    float v5 = *(float *)(a1 + 212);
    float v6 = (float)*(unsigned int *)(a1 + 144);
    if (v5 != 0.0) {
      float v6 = v5 + (float)(v6 - v5) * 0.4;
    }
    *(float *)(a1 + 212) = v6;
    xpc_object_t v7 = *(FILE **)(a1 + 200);
    if (v7)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v7);
      fprintf(*(FILE **)(a1 + 200), "header count actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(a1 + 144),
        *(float *)(a1 + 212));
      fputc(10, *(FILE **)(a1 + 200));
    }
    float v8 = *(float *)(a1 + 208);
    if (v8 != 0.0 && v8 > *(float *)(a1 + 212))
    {
      float v9 = vabds_f32((float)*(unsigned int *)(a1 + 228), v8);
      if (v9 >= 1.5 || (float)(v9 / v8) >= 0.1) {
        qenc_hist_update_size(a1, vcvtas_u32_f32(v8));
      }
    }
  }
  uint64_t v10 = *(void *)(a1 + 128);
  if (!v10 || !*(_DWORD *)(v10 + 60))
  {
    *(_WORD *)a2 = 0;
    unint64_t v15 = *(void *)(a1 + 128);
    unint64_t v16 = *(FILE **)(a1 + 200);
    if (v15)
    {
      if (v16)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v16);
        fprintf(*(FILE **)(a1 + 200), "ended header for stream %llu; dynamic table not referenced",
          *(void *)(*(void *)(a1 + 128) + 40));
        fputc(10, *(FILE **)(a1 + 200));
        unint64_t v15 = *(void *)(a1 + 128);
      }
      uint64_t v17 = (void *)(a1 + 80);
      do
      {
        uint64_t v17 = (void *)*v17;
        if (!v17) {
          __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
        }
      }
      while ((unint64_t)(v17 + 2) > v15 || (unint64_t)(v17 + 514) <= v15);
      unint64_t v19 = (v15 - (unint64_t)(v17 + 2)) >> 6;
      v17[1] &= ~(1 << v19);
      unint64_t v20 = &v17[8 * (unint64_t)v19];
      uint64_t v21 = v20[2];
      int64x2_t v22 = (void *)v20[3];
      int v23 = v20 + 2;
      if (v21)
      {
        *(void *)(v21 + _Block_object_dispose(&a9, 8) = v22;
        int64x2_t v22 = (void *)v23[1];
      }
      else
      {
        *(void *)(a1 + 104) = v22;
      }
      *int64x2_t v22 = v21;
      *(void *)(a1 + 12_Block_object_dispose(&a9, 8) = 0;
    }
    else if (v16)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v16);
      fwrite("ended header; hinfo absent", 0x1AuLL, 1uLL, *(FILE **)(a1 + 200));
      fputc(10, *(FILE **)(a1 + 200));
    }
    *(_DWORD *)(a1 + 12) &= ~1u;
    int v27 = 2;
    uint64_t result = 2;
    goto LABEL_67;
  }
  *(unsigned char *)a2 = 0;
  uint64_t v11 = *(_DWORD *)(v10 + 60) % (2 * *(_DWORD *)(a1 + 28));
  int v12 = v11 + 1;
  int v13 = *(FILE **)(a1 + 200);
  if (v13)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
    fprintf(*(FILE **)(a1 + 200), "LargestRef for stream %llu is encoded as %u", *(void *)(v10 + 40), v11 + 1);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (v11 > 0xFD)
  {
    *(unsigned char *)a2 = -1;
    unint64_t v24 = v11 - 254;
    if ((unint64_t)(v11 - 254) <= 0x7F)
    {
      *(unsigned char *)(a2 + nw_tcp_options_set_enable_fast_open(options, 1) = v11 + 2;
      unint64_t v14 = 2;
    }
    else
    {
      *(unsigned char *)(a2 + nw_tcp_options_set_enable_fast_open(options, 1) = (v11 + 2) | 0x80;
      if (v24 < 0x4000)
      {
        unint64_t v25 = v24 >> 7;
        unint64_t v14 = 3;
        uint64_t v26 = 2;
      }
      else
      {
        *(unsigned char *)(a2 + 2) = (v24 >> 7) | 0x80;
        if (v24 < 0x200000)
        {
          unint64_t v25 = v24 >> 14;
          unint64_t v14 = 4;
          uint64_t v26 = 3;
        }
        else
        {
          *(unsigned char *)(a2 + 3) = (v24 >> 14) | 0x80;
          unint64_t v25 = v24 >> 28;
          if (v24 >> 28)
          {
            *(unsigned char *)(a2 + 4) = (v24 >> 21) | 0x80;
            unint64_t v14 = 6;
            uint64_t v26 = 5;
          }
          else
          {
            unint64_t v25 = v24 >> 21;
            unint64_t v14 = 5;
            uint64_t v26 = 4;
          }
        }
      }
      *(unsigned char *)(a2 + v26) = v25;
    }
  }
  else
  {
    *(unsigned char *)a2 |= v12;
    unint64_t v14 = 1;
  }
  int v28 = (unsigned char *)(a2 + v14);
  unsigned int v29 = *(_DWORD *)(a1 + 156);
  unsigned int v30 = *(_DWORD *)(v10 + 60);
  BOOL v31 = v29 >= v30;
  unsigned int v32 = v29 - v30;
  char v33 = v29 < v30;
  LODWORD(v34) = v30 + ~v29;
  if (v31) {
    uint64_t v34 = v32;
  }
  else {
    uint64_t v34 = v34;
  }
  if (v31) {
    char v35 = 0;
  }
  else {
    char v35 = 0x80;
  }
  unsigned char *v28 = v33 << 7;
  if (v34 <= 0x7E)
  {
    unsigned char *v28 = v35 | v34;
    unint64_t v36 = (unint64_t)(v28 + 1);
LABEL_62:
    if (*(_DWORD *)(v10 + 60) > *(_DWORD *)(a1 + 4)) {
      qenc_add_to_risked_list(a1, (void *)v10);
    }
    int v42 = *(FILE **)(a1 + 200);
    if (v42)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v42);
      fprintf(*(FILE **)(a1 + 200), "ended header for stream %llu; max ref: %u encoded as %u; risked: %d",
        *(void *)(v10 + 40),
        *(_DWORD *)(v10 + 60),
        v12,
        *(_DWORD *)(v10 + 60) > *(_DWORD *)(a1 + 4));
      fputc(10, *(FILE **)(a1 + 200));
    }
    *(void *)(a1 + 12_Block_object_dispose(&a9, 8) = 0;
    *(_DWORD *)(a1 + 12) &= ~1u;
    uint64_t result = v36 - a2;
    int v27 = v36 - a2;
LABEL_67:
    *(_DWORD *)(a1 + 196) += v27;
    return result;
  }
  unsigned char *v28 = v35 | 0x7F;
  unint64_t v37 = v34 - 127;
  if (v37 < 0x80)
  {
    unint64_t v41 = v14 + 1;
LABEL_61:
    unint64_t v36 = a2 + v14 + 2;
    *(unsigned char *)(a2 + v4nw_tcp_options_set_enable_fast_open(options, 1) = v37;
    if (v36 > (unint64_t)v28) {
      goto LABEL_62;
    }
  }
  else
  {
    unint64_t v38 = v37;
    while (1)
    {
      unint64_t v39 = v14++;
      if (v14 > 0x15) {
        break;
      }
      *(unsigned char *)(a2 + 1 + v39) = v38 | 0x80;
      unint64_t v37 = v38 >> 7;
      unint64_t v40 = v38 >> 14;
      v38 >>= 7;
      if (!v40)
      {
        unint64_t v41 = v39 + 2;
        if ((uint64_t)(v39 + 2) <= 21) {
          goto LABEL_61;
        }
        return 0;
      }
    }
  }
  return 0;
}

void qenc_hist_update_size(uint64_t a1, unsigned int a2)
{
  if (*(_DWORD *)(a1 + 228) != a2)
  {
    if (!a2)
    {
      *(_DWORD *)(a1 + 232) = 0;
      *(void *)(a1 + 224) = 0;
      return;
    }
    id v4 = malloc_type_malloc(8 * (a2 + 1), 0x100004000313F17uLL);
    if (!v4) {
      return;
    }
    float v5 = v4;
    float v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(FILE **)(a1 + 200), "history size change from %u to %u", *(_DWORD *)(a1 + 228), a2);
      fputc(10, *(FILE **)(a1 + 200));
    }
    unsigned int v7 = *(_DWORD *)(a1 + 224);
    if (*(_DWORD *)(a1 + 232))
    {
      unsigned int v8 = v7 + 1;
      unsigned int v7 = *(_DWORD *)(a1 + 228);
      int v9 = v8 % v7;
    }
    else
    {
      int v9 = 0;
      if (!v7)
      {
        LODWORD(v10) = 0;
LABEL_15:
        unsigned int v13 = v10 % a2;
        *(_DWORD *)(a1 + 224) = v13;
        *(_DWORD *)(a1 + 22_Block_object_dispose(&a9, 8) = a2;
        *(_DWORD *)(a1 + 232) = v13 == 0;
        free(*(void **)(a1 + 216));
        *(void *)(a1 + 216) = v5;
        return;
      }
    }
    unint64_t v10 = 0;
    unsigned int v11 = v7 - 1;
    do
    {
      int v12 = v10;
      v5[v10] = *(void *)(*(void *)(a1 + 216) + 8 * ((v9 + v10) % *(_DWORD *)(a1 + 228)));
      ++v10;
    }
    while (v11 != v12 && v10 < a2);
    goto LABEL_15;
  }
}

uint64_t qenc_add_to_risked_list(uint64_t result, void *a2)
{
  a2[2] = 0;
  int v2 = *(void **)(result + 120);
  a2[3] = v2;
  void *v2 = a2;
  *(void *)(result + 120) = a2 + 2;
  uint64_t v3 = *(void *)(result + 136);
  if (v3)
  {
    a2[4] = *(void *)(v3 + 32);
    *(void *)(v3 + 32) = a2;
  }
  else
  {
    uint64_t v4 = result;
    unsigned int v5 = *(_DWORD *)(result + 40) + 1;
    *(_DWORD *)(result + 40) = v5;
    float v6 = *(FILE **)(result + 200);
    if (v6)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v6);
      fprintf(*(FILE **)(v4 + 200), "streams at risk: %u", *(_DWORD *)(v4 + 40));
      uint64_t result = fputc(10, *(FILE **)(v4 + 200));
      unsigned int v5 = *(_DWORD *)(v4 + 40);
    }
    if (v5 > *(_DWORD *)(v4 + 36)) {
      __assert_rtn("qenc_add_to_risked_list", "lsqpack.c", 1156, "enc->qpe_cur_streams_at_risk <= enc->qpe_max_risked_streams");
    }
  }
  return result;
}

uint64_t XXH_INLINE_XXH32(int *a1, unint64_t a2, int a3)
{
  if (!a1)
  {
    unsigned int v12 = a3 + 374761393;
    goto LABEL_12;
  }
  if (a2 < 0x10)
  {
    unsigned int v12 = a3 + 374761393 + a2;
    if (a2 < 4) {
      goto LABEL_10;
    }
    goto LABEL_9;
  }
  unint64_t v3 = (unint64_t)a1 + a2 - 15;
  int v4 = a3 + 606290984;
  int v5 = a3 - 2048144777;
  int v6 = a3 + 1640531535;
  do
  {
    HIDWORD(v7) = v4 - 2048144777 * *a1;
    LODWORD(v7) = HIDWORD(v7);
    int v4 = -1640531535 * (v7 >> 19);
    HIDWORD(v7) = v5 - 2048144777 * a1[1];
    LODWORD(v7) = HIDWORD(v7);
    int v5 = -1640531535 * (v7 >> 19);
    HIDWORD(v7) = a3 - 2048144777 * a1[2];
    LODWORD(v7) = HIDWORD(v7);
    a3 = -1640531535 * (v7 >> 19);
    HIDWORD(v7) = v6 - 2048144777 * a1[3];
    LODWORD(v7) = HIDWORD(v7);
    int v6 = -1640531535 * (v7 >> 19);
    a1 += 4;
  }
  while ((unint64_t)a1 < v3);
  HIDWORD(v9) = v4;
  LODWORD(v9) = v4;
  int v8 = v9 >> 31;
  HIDWORD(v9) = v5;
  LODWORD(v9) = v5;
  int v10 = v9 >> 25;
  HIDWORD(v9) = a3;
  LODWORD(v9) = a3;
  int v11 = v9 >> 20;
  HIDWORD(v9) = v6;
  LODWORD(v9) = v6;
  unsigned int v12 = v8 + a2 + v10 + v11 + (v9 >> 14);
  a2 &= 0xFu;
  if (a2 >= 4)
  {
    do
    {
LABEL_9:
      int v13 = *a1++;
      HIDWORD(v14) = v12 - 1028477379 * v13;
      LODWORD(v14) = HIDWORD(v14);
      unsigned int v12 = 668265263 * (v14 >> 15);
      a2 -= 4;
    }
    while (a2 > 3);
  }
LABEL_10:
  while (a2)
  {
    int v15 = *(unsigned __int8 *)a1;
    a1 = (int *)((char *)a1 + 1);
    HIDWORD(v16) = v12 + 374761393 * v15;
    LODWORD(v16) = HIDWORD(v16);
    unsigned int v12 = -1640531535 * (v16 >> 21);
    --a2;
  }
LABEL_12:
  unsigned int v17 = -1028477379 * ((-2048144777 * (v12 ^ (v12 >> 15))) ^ ((-2048144777 * (v12 ^ (v12 >> 15))) >> 13));
  return v17 ^ HIWORD(v17);
}

uint64_t qenc_has_or_can_evict_at_least(uint64_t a1, unint64_t a2)
{
  unint64_t v2 = (*(_DWORD *)(a1 + 20) - *(_DWORD *)(a1 + 16));
  if (v2 >= a2) {
    return 1;
  }
  int v3 = *(_DWORD *)(a1 + 152);
  if ((v3 & 4) == 0)
  {
    int v4 = *(uint64_t **)(a1 + 96);
    if (v4)
    {
      unsigned int v5 = 0;
      do
      {
        unsigned int v6 = *((_DWORD *)v4 + 14);
        if (!v5 || (v6 ? (BOOL v7 = v6 >= v5) : (BOOL v7 = 1), !v7)) {
          unsigned int v5 = *((_DWORD *)v4 + 14);
        }
        int v4 = (uint64_t *)*v4;
      }
      while (v4);
    }
    else
    {
      unsigned int v5 = 0;
    }
    *(_DWORD *)(a1 + 14_Block_object_dispose(&a9, 8) = v5;
    *(_DWORD *)(a1 + 152) = v3 | 4;
    uint64_t v8 = *(void *)(a1 + 128);
    if (!v8) {
      goto LABEL_24;
    }
    goto LABEL_18;
  }
  unsigned int v5 = *(_DWORD *)(a1 + 148);
  uint64_t v8 = *(void *)(a1 + 128);
  if (v8)
  {
LABEL_18:
    unsigned int v9 = *(_DWORD *)(v8 + 56);
    if (!v5 || (v9 ? (BOOL v10 = v9 >= v5) : (BOOL v10 = 1), !v10)) {
      unsigned int v5 = v9;
    }
  }
LABEL_24:
  uint64_t v11 = *(void *)(a1 + 56);
  if (v11)
  {
    if (v5)
    {
      do
      {
        unsigned int v12 = *(_DWORD *)(v11 + 24);
        if (v12 >= v5 || v12 > *(_DWORD *)(a1 + 4)) {
          break;
        }
        v2 += (*(_DWORD *)(v11 + 48) + *(_DWORD *)(v11 + 52) + 32);
        if (v2 >= a2) {
          return 1;
        }
        uint64_t v11 = *(void *)(v11 + 16);
      }
      while (v11);
    }
    else
    {
      do
      {
        if (*(_DWORD *)(v11 + 24) > *(_DWORD *)(a1 + 4)) {
          break;
        }
        v2 += (*(_DWORD *)(v11 + 48) + *(_DWORD *)(v11 + 52) + 32);
        if (v2 >= a2) {
          return 1;
        }
        uint64_t v11 = *(void *)(v11 + 16);
      }
      while (v11);
    }
  }
  return 0;
}

void *lsqpack_enc_push_entry(uint64_t a1, int a2, int a3, const void *a4, unsigned int a5, const void *a6, unsigned int a7)
{
  uint64_t v8 = a6;
  v44[2] = *MEMORY[0x1E4F143B8];
  int v13 = *(_DWORD *)(a1 + 52);
  uint64_t v14 = 1 << v13;
  if (*(_DWORD *)(a1 + 48) >= (1 << v13) >> 1)
  {
    unint64_t v16 = malloc_type_malloc(32 * (1 << (v13 + 1)), 0xA004088793A40uLL);
    if (!v16) {
      return v16;
    }
    uint64_t v17 = 0;
    int v18 = (1 << (v13 + 1)) - 1;
    unint64_t v19 = *(void **)(a1 + 72);
    uint64_t v8 = a6;
    do
    {
      unint64_t v20 = &v16[4 * v17];
      uint64_t v21 = &v16[4 * (v14 + v17)];
      v44[0] = v20;
      v44[1] = v21;
      *unint64_t v20 = 0;
      v20[1] = v20;
      void *v21 = 0;
      v21[1] = v21;
      v20[2] = 0;
      v20[3] = v20 + 2;
      v21[2] = 0;
      void v21[3] = v21 + 2;
      for (unint64_t i = &v19[4 * v17]; ; unint64_t i = &v19[4 * v17])
      {
        uint64_t v25 = *i;
        if (!*i) {
          break;
        }
        uint64_t v26 = *(void *)(v25 + 8);
        *unint64_t i = v26;
        if (!v26) {
          i[1] = (uint64_t)i;
        }
        unsigned int v23 = ((*(_DWORD *)(v25 + 44) & v18) >> v13) & 1;
        *(void *)(v25 + _Block_object_dispose(&a9, 8) = 0;
        uint64_t v24 = v44[v23];
        **(void **)(v24 + _Block_object_dispose(&a9, 8) = v25;
        *(void *)(v24 + _Block_object_dispose(&a9, 8) = v25 + 8;
        unint64_t v19 = *(void **)(a1 + 72);
      }
      while (1)
      {
        unsigned int v29 = (char *)&v19[4 * v17];
        unsigned int v32 = (uint64_t *)*((void *)v29 + 2);
        BOOL v31 = (uint64_t *)(v29 + 16);
        unsigned int v30 = v32;
        if (!v32) {
          break;
        }
        uint64_t v33 = *v30;
        *BOOL v31 = *v30;
        if (!v33) {
          v19[4 * v17 + 3] = v31;
        }
        unsigned int v27 = ((v30[5] & v18) >> v13) & 1;
        *unsigned int v30 = 0;
        uint64_t v28 = v44[v27];
        **(void **)(v28 + 24) = v30;
        *(void *)(v28 + 24) = v30;
        unint64_t v19 = *(void **)(a1 + 72);
      }
      ++v17;
    }
    while (v17 != v14);
    free(v19);
    *(_DWORD *)(a1 + 52) = v13 + 1;
    *(void *)(a1 + 72) = v16;
  }
  uint64_t v34 = malloc_type_malloc(a5 + (unint64_t)a7 + 56, 0x5A4B1079uLL);
  unint64_t v16 = v34;
  if (v34)
  {
    v34[10] = a3;
    v34[11] = a2;
    v34[12] = a5;
    v34[13] = a7;
    v34[7] = *(_DWORD *)(a1 + 16);
    v34[8] = *(_DWORD *)(a1 + 32);
    int v35 = *(_DWORD *)a1 + 1;
    *(_DWORD *)a1 = v35;
    v34[6] = v35;
    unint64_t v36 = v34 + 14;
    memcpy(v34 + 14, a4, a5);
    memcpy((char *)v36 + a5, v8, a7);
    v16[2] = 0;
    **(void **)(a1 + 64) = v16;
    *(void *)(a1 + 64) = v16 + 2;
    int v37 = -1 << *(_DWORD *)(a1 + 52);
    void *v16 = 0;
    uint64_t v38 = 32 * (a3 & ~v37);
    **(void **)(*(void *)(a1 + 72) + v38 + 24) = v16;
    uint64_t v39 = *(void *)(a1 + 72);
    *(void *)(v39 + v38 + 24) = v16;
    v16[1] = 0;
    uint64_t v40 = 32 * (a2 & ~v37);
    **(void **)(v39 + v40 + _Block_object_dispose(&a9, 8) = v16;
    *(void *)(*(void *)(a1 + 72) + v40 + _Block_object_dispose(&a9, 8) = v16 + 1;
    *(_DWORD *)(a1 + 16) += a5 + a7 + 32;
    ++*(_DWORD *)(a1 + 48);
    unint64_t v41 = *(FILE **)(a1 + 200);
    if (v41)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v41);
        *((_DWORD *)v16 + 6),
        *((_DWORD *)v16 + 12),
        (const char *)v16 + 56,
        *((_DWORD *)v16 + 13),
        (const char *)v16 + *((unsigned int *)v16 + 12) + 56,
        *(_DWORD *)(a1 + 48),
        *(_DWORD *)(a1 + 16));
      fputc(10, *(FILE **)(a1 + 200));
    }
  }
  return v16;
}

void qenc_remove_overflow_entries(uint64_t a1)
{
  unsigned int v2 = *(_DWORD *)(a1 + 16);
  unsigned int v3 = *(_DWORD *)(a1 + 20);
  unsigned int v4 = v3;
  if (v2 > v3)
  {
    unsigned int v5 = (void **)(a1 + 56);
    do
    {
      BOOL v7 = (char *)*v5;
      if (!*v5) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 852, "entry");
      }
      uint64_t v8 = *(FILE **)(a1 + 200);
      unsigned int v9 = *v5;
      if (v8)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
          *((_DWORD *)v7 + 6),
          *((_DWORD *)v7 + 12),
          v7 + 56,
          *((_DWORD *)v7 + 13),
          &v7[*((unsigned int *)v7 + 12) + 56],
          *(_DWORD *)(a1 + 48) - 1,
          *(_DWORD *)(a1 + 16) - (*((_DWORD *)v7 + 12) + *((_DWORD *)v7 + 13)) - 32);
        fputc(10, *(FILE **)(a1 + 200));
        unsigned int v9 = *(void **)(a1 + 56);
      }
      BOOL v10 = (void *)v9[2];
      void *v5 = v10;
      if (!v10) {
        *(void *)(a1 + 64) = v5;
      }
      int v11 = -1 << *(_DWORD *)(a1 + 52);
      uint64_t v12 = *((_DWORD *)v7 + 10) & ~v11;
      uint64_t v13 = *(void *)(a1 + 72);
      uint64_t v14 = v13 + 32 * v12;
      unint64_t v16 = *(char **)(v14 + 16);
      int v15 = (void *)(v14 + 16);
      if (v7 != v16) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 859, "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_nameval)");
      }
      uint64_t v17 = *(void *)v7;
      *int v15 = *(void *)v7;
      if (!v17) {
        *(void *)(v13 + 32 * v12 + 24) = v15;
      }
      int v18 = (void **)(v13 + 32 * (*((_DWORD *)v7 + 11) & ~v11));
      if (v7 != *v18) {
        __assert_rtn("qenc_drop_oldest_entry", "lsqpack.c", 862, "entry == STAILQ_FIRST(&enc->qpe_buckets[buckno].by_name)");
      }
      unint64_t v19 = (void *)*((void *)v7 + 1);
      void *v18 = v19;
      if (!v19) {
        v18[1] = v18;
      }
      int v6 = *((_DWORD *)v7 + 12) + *((_DWORD *)v7 + 13) + 32;
      *(_DWORD *)(a1 + 32) += v6;
      *(_DWORD *)(a1 + 16) -= v6;
      --*(_DWORD *)(a1 + 48);
      free(v7);
      unsigned int v4 = *(_DWORD *)(a1 + 20);
    }
    while (*(_DWORD *)(a1 + 16) > v4);
  }
  unint64_t v20 = *(FILE **)(a1 + 200);
  if (v4) {
    BOOL v21 = v20 == 0;
  }
  else {
    BOOL v21 = 1;
  }
  if (!v21)
  {
    int v22 = *(_DWORD *)(a1 + 12);
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v20);
    unsigned int v24 = *(_DWORD *)(a1 + 16);
    unsigned int v23 = *(_DWORD *)(a1 + 20);
    float v25 = (float)v23;
    float v26 = (float)v24 / (float)v23;
    double v27 = v26;
    if ((v22 & 2) != 0)
    {
      if (!v23) {
        __assert_rtn("qenc_effective_fill", "lsqpack.c", 878, "enc->qpe_cur_max_capacity");
      }
      uint64_t v28 = *(void *)(a1 + 56);
      unsigned int v40 = v2;
      uint64_t v39 = *(FILE **)(a1 + 200);
      if (v28 && (uint64_t v29 = *(void *)(v28 + 16)) != 0)
      {
        int v30 = 0;
        do
        {
          BOOL v31 = (_DWORD *)v28;
          uint64_t v28 = v29;
          int v32 = v31[12];
          uint64_t v33 = v29;
          while (1)
          {
            if (*(_DWORD *)(v33 + 48) == v32)
            {
              int v34 = *(_DWORD *)(v33 + 52);
              if (v34 == v31[13] && !memcmp((const void *)(v33 + 56), v31 + 14, (v34 + v32))) {
                break;
              }
            }
            uint64_t v33 = *(void *)(v33 + 16);
            if (!v33) {
              goto LABEL_25;
            }
          }
          v30 += v32 + v34 + 32;
LABEL_25:
          uint64_t v29 = *(void *)(v28 + 16);
        }
        while (v29);
      }
      else
      {
        int v30 = 0;
      }
      fprintf(v39, "fill: %.2f; effective fill: %.2f", v27, (float)((float)(v24 - v30) / v25));
      unsigned int v2 = v40;
    }
    else
    {
      fprintf(*(FILE **)(a1 + 200), "fill: %.2f", v26);
    }
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (v2 > v3 && *(void *)(a1 + 216))
  {
    float v35 = *(float *)(a1 + 208);
    float v36 = (float)*(unsigned int *)(a1 + 48);
    if (v35 != 0.0) {
      float v36 = v35 + (float)(v36 - v35) * 0.4;
    }
    *(float *)(a1 + 20_Block_object_dispose(&a9, 8) = v36;
    int v37 = *(FILE **)(a1 + 200);
    if (v37)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v37);
      fprintf(*(FILE **)(a1 + 200), "table size actual: %u; exponential moving average: %.3f",
        *(_DWORD *)(a1 + 48),
        *(float *)(a1 + 208));
      uint64_t v38 = *(FILE **)(a1 + 200);
      fputc(10, v38);
    }
  }
}

uint64_t enc_proc_ici(uint64_t a1, unint64_t a2)
{
  unsigned int v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got ICI instruction, count=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!a2)
  {
    int v6 = *(FILE **)(a1 + 200);
    if (v6)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v6);
      fwrite("ICI=0 is an error", 0x11uLL, 1uLL, *(FILE **)(a1 + 200));
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if (HIDWORD(a2))
  {
    unsigned int v5 = *(FILE **)(a1 + 200);
    if (v5)
    {
      fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
      fprintf(*(FILE **)(a1 + 200), "insertion count too high: %llu");
LABEL_12:
      uint64_t v9 = 0xFFFFFFFFLL;
LABEL_13:
      fputc(10, *(FILE **)(a1 + 200));
      return v9;
    }
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = *(_DWORD *)(a1 + 8) + a2;
  if (v7 > *(_DWORD *)a1)
  {
    uint64_t v8 = *(FILE **)(a1 + 200);
    if (v8)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
      fprintf(*(FILE **)(a1 + 200), "ICI: max_acked %u is larger than number of inserts %u");
      goto LABEL_12;
    }
    return 0xFFFFFFFFLL;
  }
  if (v7 <= *(_DWORD *)(a1 + 4))
  {
    uint64_t v13 = *(FILE **)(a1 + 200);
    if (v13)
    {
      fwrite("qenc: debug: ", 0xDuLL, 1uLL, v13);
      fprintf(*(FILE **)(a1 + 200), "duplicate ICI: %u", v7);
      uint64_t v9 = 0;
      goto LABEL_13;
    }
    return 0;
  }
  *(_DWORD *)(a1 + 4) = v7;
  *(_DWORD *)(a1 + _Block_object_dispose(&a9, 8) = v7;
  int v11 = *(FILE **)(a1 + 200);
  if (v11)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v11);
    fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
    fputc(10, *(FILE **)(a1 + 200));
  }
  uint64_t v12 = *(void *)(a1 + 112);
  if (!v12) {
    return 0;
  }
  do
  {
    uint64_t v9 = *(void *)(v12 + 16);
    if (*(_DWORD *)(v12 + 60) <= *(_DWORD *)(a1 + 4)) {
      qenc_remove_from_risked_list(a1, (void *)v12);
    }
    uint64_t v12 = v9;
  }
  while (v9);
  return v9;
}

uint64_t qenc_remove_from_risked_list(uint64_t result, void *a2)
{
  uint64_t v2 = result;
  if (*(void *)(result + 112))
  {
    uint64_t v3 = a2[2];
    unsigned int v4 = (void *)a2[3];
    if (v3)
    {
      *(void *)(v3 + 24) = v4;
      unsigned int v4 = (void *)a2[3];
    }
    else
    {
      *(void *)(result + 120) = v4;
    }
    *unsigned int v4 = v3;
    unsigned int v5 = (void *)a2[4];
    if (v5 == a2)
    {
      int v8 = *(_DWORD *)(result + 40);
      if (!v8) {
        __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1174, "enc->qpe_cur_streams_at_risk > 0");
      }
      *(_DWORD *)(result + 40) = v8 - 1;
      uint64_t v9 = *(FILE **)(result + 200);
      if (v9)
      {
        fwrite("qenc: debug: ", 0xDuLL, 1uLL, v9);
        fprintf(*(FILE **)(v2 + 200), "streams at risk: %u", *(_DWORD *)(v2 + 40));
        BOOL v10 = *(FILE **)(v2 + 200);
        return fputc(10, v10);
      }
    }
    else
    {
      int v6 = (void *)a2[4];
      do
      {
        unsigned int v7 = v6;
        int v6 = (void *)v6[4];
      }
      while (v6 != a2);
      v7[4] = v5;
      a2[4] = a2;
    }
  }
  else if (*(_DWORD *)(result + 40))
  {
    __assert_rtn("qenc_remove_from_risked_list", "lsqpack.c", 1168, "enc->qpe_cur_streams_at_risk == 0");
  }
  return result;
}

uint64_t enc_proc_header_ack(uint64_t a1, unint64_t a2)
{
  unsigned int v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Header Ack instruction, stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!(a2 >> 62))
  {
    unint64_t v6 = a1 + 96;
    while (1)
    {
      unint64_t v6 = *(void *)v6;
      if (!v6) {
        break;
      }
      if (*(void *)(v6 + 40) == a2)
      {
        if (*(_DWORD *)(v6 + 60) > *(_DWORD *)(a1 + 4))
        {
          qenc_remove_from_risked_list(a1, (void *)v6);
          *(_DWORD *)(a1 + 4) = *(_DWORD *)(v6 + 60);
          uint64_t v7 = *(void *)(a1 + 112);
          if (v7)
          {
            do
            {
              uint64_t v16 = *(void *)(v7 + 16);
              if (*(_DWORD *)(v7 + 60) <= *(_DWORD *)(a1 + 4)) {
                qenc_remove_from_risked_list(a1, (void *)v7);
              }
              uint64_t v7 = v16;
            }
            while (v16);
          }
          int v8 = *(FILE **)(a1 + 200);
          if (v8)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v8);
            fprintf(*(FILE **)(a1 + 200), "max acked ID is now %u", *(_DWORD *)(a1 + 4));
            fputc(10, *(FILE **)(a1 + 200));
          }
        }
        uint64_t v9 = (void *)(a1 + 80);
        do
        {
          uint64_t v9 = (void *)*v9;
          if (!v9) {
            __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
          }
          BOOL v10 = v9 + 2;
        }
        while ((unint64_t)(v9 + 2) > v6 || (unint64_t)(v9 + 514) <= v6);
        v9[1] &= ~(1 << ((v6 - (unint64_t)v10) >> 6));
        uint64_t v12 = &v9[8 * (unint64_t)((v6 - (unint64_t)v10) >> 6)];
        uint64_t v13 = v12[2];
        uint64_t v14 = (void *)v12[3];
        int v15 = v12 + 2;
        if (v13)
        {
          *(void *)(v13 + _Block_object_dispose(&a9, 8) = v14;
          uint64_t v14 = (void *)v15[1];
        }
        else
        {
          *(void *)(a1 + 104) = v14;
        }
        uint64_t result = 0;
        void *v14 = v13;
        return result;
      }
    }
  }
  return 0xFFFFFFFFLL;
}

uint64_t enc_proc_stream_cancel(uint64_t a1, unint64_t a2)
{
  unsigned int v4 = *(FILE **)(a1 + 200);
  if (v4)
  {
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v4);
    fprintf(*(FILE **)(a1 + 200), "got Cancel Stream instruction; stream=%llu", a2);
    fputc(10, *(FILE **)(a1 + 200));
  }
  if (!(a2 >> 62))
  {
    unint64_t v7 = *(void *)(a1 + 96);
    if (v7)
    {
      int v8 = 0;
      do
      {
        unint64_t v9 = *(void *)v7;
        if (*(void *)(v7 + 40) == a2)
        {
          BOOL v10 = *(FILE **)(a1 + 200);
          if (v10)
          {
            fwrite("qenc: debug: ", 0xDuLL, 1uLL, v10);
            fprintf(*(FILE **)(a1 + 200), "cancel header block for stream %llu, seqno %u", a2, *(_DWORD *)(v7 + 48));
            fputc(10, *(FILE **)(a1 + 200));
          }
          if (*(_DWORD *)(v7 + 60) > *(_DWORD *)(a1 + 4)) {
            qenc_remove_from_risked_list(a1, (void *)v7);
          }
          int v11 = (void *)(a1 + 80);
          do
          {
            int v11 = (void *)*v11;
            if (!v11) {
              __assert_rtn("enc_free_hinfo", "lsqpack.c", 347, "0");
            }
          }
          while ((unint64_t)(v11 + 2) > v7 || (unint64_t)(v11 + 514) <= v7);
          unint64_t v13 = (v7 - (unint64_t)(v11 + 2)) >> 6;
          v11[1] &= ~(1 << v13);
          uint64_t v14 = &v11[8 * (unint64_t)v13];
          uint64_t v15 = v14[2];
          uint64_t v16 = (void *)v14[3];
          uint64_t v17 = v14 + 2;
          if (v15)
          {
            *(void *)(v15 + _Block_object_dispose(&a9, 8) = v16;
            uint64_t v16 = (void *)v17[1];
          }
          else
          {
            *(void *)(a1 + 104) = v16;
          }
          void *v16 = v15;
          ++v8;
        }
        unint64_t v7 = v9;
      }
      while (v9);
    }
    else
    {
      int v8 = 0;
    }
    int v18 = *(FILE **)(a1 + 200);
    if (!v18) {
      return 0;
    }
    fwrite("qenc: debug: ", 0xDuLL, 1uLL, v18);
    fprintf(*(FILE **)(a1 + 200), "cancelled %u header block%.*s of stream %llu", v8, v8 != 1, "s", a2);
    uint64_t v6 = 0;
    goto LABEL_29;
  }
  unsigned int v5 = *(FILE **)(a1 + 200);
  if (v5)
  {
    fwrite("qenc: info: ", 0xCuLL, 1uLL, v5);
    fprintf(*(FILE **)(a1 + 200), "Invalid stream ID %llu in Cancel Stream", a2);
    uint64_t v6 = 0xFFFFFFFFLL;
LABEL_29:
    fputc(10, *(FILE **)(a1 + 200));
    return v6;
  }
  return 0xFFFFFFFFLL;
}

void lsqpack_dec_cleanup(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 80);
  if (v2)
  {
    do
    {
      uint64_t v3 = (void *)*v2;
      free(v2);
      uint64_t v2 = v3;
    }
    while (v3);
  }
  int v4 = *(_DWORD *)(a1 + 232);
  if ((v4 - 1) > 4)
  {
    if ((v4 - 8) > 6) {
      goto LABEL_9;
    }
    unsigned int v5 = *(_DWORD **)(a1 + 280);
    if (!v5) {
      goto LABEL_9;
    }
  }
  else
  {
    unsigned int v5 = *(_DWORD **)(a1 + 288);
    if (!v5) {
      goto LABEL_9;
    }
  }
LABEL_8:
  free(v5);
LABEL_9:
  int v6 = *(_DWORD *)(a1 + 60);
  unsigned int v7 = *(_DWORD *)(a1 + 64);
  while (v6 != v7)
  {
    unsigned int v5 = *(_DWORD **)(*(void *)(a1 + 72) + 8 * v7);
    unsigned int v7 = (v7 + 1) % *(_DWORD *)(a1 + 56);
    *(_DWORD *)(a1 + 64) = v7;
    int v8 = v5[2] - 1;
    v5[2] = v8;
    if (!v8) {
      goto LABEL_8;
    }
  }
  free(*(void **)(a1 + 72));
  *(void *)(a1 + 56) = 0;
  *(void *)(a1 + 64) = 0;
  *(void *)(a1 + 72) = 0;
  unint64_t v9 = *(FILE **)(a1 + 48);
  if (v9)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v9);
    fwrite("cleaned up", 0xAuLL, 1uLL, *(FILE **)(a1 + 48));
    BOOL v10 = *(FILE **)(a1 + 48);
    fputc(10, v10);
  }
}

uint64_t lsqpack_huff_decode_full(unsigned char *a1, int a2, unsigned char *a3, uint64_t a4, uint64_t a5, int a6)
{
  if (a4)
  {
    int v6 = a1;
    unsigned int v7 = a3;
    int v8 = &a3[(int)a4];
    switch(*(_DWORD *)a5)
    {
      case 0:
        *(_WORD *)(a5 + 4) = 256;
        int v6 = a1;
        unsigned int v7 = a3;
        goto LABEL_6;
      case 1:
        goto LABEL_6;
      case 2:
        goto LABEL_8;
      case 3:
        unsigned int v10 = *(unsigned __int8 *)(a5 + 4);
        int v6 = a1;
        unsigned int v7 = a3;
        break;
      default:
        goto LABEL_20;
    }
    while (1)
    {
      unint64_t v13 = (char *)&decode_tables + 48 * v10 + 3 * (*v6 & 0xF);
      char v14 = v13[1];
      if ((v14 & 4) != 0)
      {
LABEL_19:
        a4 = 0;
        uint64_t v9 = 3;
        return v9 | (a4 << 32);
      }
      char v15 = *v13;
      if ((v13[1] & 2) != 0)
      {
        *v7++ = v13[2];
        *(unsigned char *)(a5 + 4) = v15;
        *(unsigned char *)(a5 + 5) = v14 & 1;
        ++v6;
      }
      else
      {
        *(unsigned char *)(a5 + 4) = v15;
        *(unsigned char *)(a5 + 5) = v14 & 1;
        if (!v7) {
          goto LABEL_19;
        }
        ++v6;
      }
LABEL_6:
      if (v6 == &a1[a2]) {
        break;
      }
      if (v7 == v8)
      {
        uint64_t v9 = 2;
        *(_DWORD *)a5 = 2;
        return v9 | (a4 << 32);
      }
LABEL_8:
      int v11 = (unsigned __int8 *)&decode_tables
          + 48 * *(unsigned __int8 *)(a5 + 4)
          + 3 * ((unint64_t)*v6 >> 4);
      unsigned __int8 v12 = v11[1];
      if ((v12 & 4) != 0) {
        goto LABEL_19;
      }
      unsigned int v10 = *v11;
      if ((v11[1] & 2) != 0)
      {
        *v7++ = v11[2];
        *(unsigned char *)(a5 + 4) = v10;
        *(unsigned char *)(a5 + 5) = v12 & 1;
        if (v7 == v8) {
          goto LABEL_17;
        }
      }
      else
      {
        *(unsigned char *)(a5 + 4) = v10;
        *(unsigned char *)(a5 + 5) = v12 & 1;
        if (!v7) {
          goto LABEL_19;
        }
        if (v7 == v8)
        {
LABEL_17:
          *(_DWORD *)a5 = 3;
          uint64_t v9 = 2;
          return v9 | (a4 << 32);
        }
      }
    }
LABEL_20:
    if (a6)
    {
      if (*(unsigned char *)(a5 + 5)) {
        uint64_t v9 = 0;
      }
      else {
        uint64_t v9 = 3;
      }
    }
    else
    {
      uint64_t v9 = 1;
      *(_DWORD *)a5 = 1;
    }
    a4 = (v7 - a3);
  }
  else
  {
    uint64_t v9 = 2;
  }
  return v9 | (a4 << 32);
}

uint64_t qdec_header_process(uint64_t a1, void *a2, void *a3, uint64_t a4, unsigned char *a5, uint64_t *a6)
{
  uint64_t v9 = a2;
  a2[14] = *a3;
  a2[15] = a4;
  a2[16] = 0;
  unint64_t v11 = a2[7];
  while (2)
  {
    if (v11)
    {
      int v12 = *((_DWORD *)v9 + 26);
      if (v12) {
        unint64_t v13 = v11;
      }
      else {
        unint64_t v13 = 1;
      }
      uint64_t v14 = v9[16];
      uint64_t v15 = v9[14];
      if (v9[15] - v14 >= v13) {
        unint64_t v16 = v13;
      }
      else {
        unint64_t v16 = v9[15] - v14;
      }
      v9[16] = v16 + v14;
      if (v16)
      {
        v9[7] = v11 - v16;
        switch(((unsigned int (*)(uint64_t, void *, uint64_t, unint64_t))v9[12])(a1, v9, v15 + v14, v16))
        {
          case 0u:
            goto LABEL_31;
          case 1u:
            int v12 = *((_DWORD *)v9 + 26);
            goto LABEL_15;
          case 2u:
            unint64_t v11 = v9[7];
            if (!v11) {
              goto LABEL_12;
            }
            continue;
          case 3u:
LABEL_12:
            int v18 = (FILE **)(a1 + 48);
            uint64_t v17 = *(FILE **)(a1 + 48);
            if (!v17) {
              goto LABEL_62;
            }
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v17);
            fprintf(*v18, "header block for stream %llu has had an error");
            break;
          default:
            __assert_rtn("qdec_header_process", "lsqpack.c", 4223, "st == LQRHS_ERROR");
        }
        goto LABEL_27;
      }
LABEL_15:
      if ((v12 & 0x10) != 0) {
        goto LABEL_18;
      }
      unint64_t v19 = malloc_type_malloc(0xC0uLL, 0x10F0040D151BEFFuLL);
      if (v19)
      {
        long long v20 = *((_OWORD *)v9 + 3);
        long long v22 = *(_OWORD *)v9;
        long long v21 = *((_OWORD *)v9 + 1);
        v19[2] = *((_OWORD *)v9 + 2);
        v19[3] = v20;
        _OWORD *v19 = v22;
        v19[1] = v21;
        long long v23 = *((_OWORD *)v9 + 4);
        long long v24 = *((_OWORD *)v9 + 5);
        long long v25 = *((_OWORD *)v9 + 7);
        v19[6] = *((_OWORD *)v9 + 6);
        v19[7] = v25;
        v19[4] = v23;
        void v19[5] = v24;
        long long v26 = *((_OWORD *)v9 + 8);
        long long v27 = *((_OWORD *)v9 + 9);
        long long v28 = *((_OWORD *)v9 + 11);
        v19[10] = *((_OWORD *)v9 + 10);
        v19[11] = v28;
        v19[8] = v26;
        v19[9] = v27;
        uint64_t v29 = *(void **)(a1 + 88);
        *(void *)unint64_t v19 = 0;
        *((void *)v19 + nw_tcp_options_set_enable_fast_open(options, 1) = v29;
        *uint64_t v29 = v19;
        *(void *)(a1 + 8_Block_object_dispose(&a9, 8) = v19;
        int v12 = *((_DWORD *)v19 + 26) | 0x10;
        *((_DWORD *)v19 + 26) = v12;
        uint64_t v9 = v19;
LABEL_18:
        if (!v16)
        {
          *a3 += v9[16];
          float v35 = *(FILE **)(a1 + 48);
          if (v35)
          {
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v35);
            fprintf(*(FILE **)(a1 + 48), "header block for stream %llu needs more bytes", v9[5]);
            fputc(10, *(FILE **)(a1 + 48));
          }
          return 2;
        }
        unsigned int v30 = *(_DWORD *)(a1 + 224);
        if (v30 < *(_DWORD *)(a1 + 16))
        {
          uint64_t v31 = v9[8] & 7;
          v9[2] = 0;
          uint64_t v32 = a1 + 16 * v31;
          v9[3] = *(void *)(v32 + 104);
          **(void **)(v32 + 104) = v9;
          *(void *)(v32 + 104) = v9 + 2;
          *(_DWORD *)(a1 + 224) = v30 + 1;
          *((_DWORD *)v9 + 26) = v12 | 4;
          *a3 += v9[16];
          uint64_t v33 = *(FILE **)(a1 + 48);
          uint64_t v34 = 1;
          if (v33)
          {
            fwrite("qdec: debug: ", 0xDuLL, 1uLL, v33);
            fprintf(*(FILE **)(a1 + 48), "header block for stream %llu is blocked", v9[5]);
            fputc(10, *(FILE **)(a1 + 48));
          }
          return v34;
        }
        int v18 = (FILE **)(a1 + 48);
        float v36 = *(FILE **)(a1 + 48);
        if (v36)
        {
          fwrite("qdec: info: ", 0xCuLL, 1uLL, v36);
          fprintf(*(FILE **)(a1 + 48), "cannot block another header: reached maximum of %u");
LABEL_27:
          uint64_t v34 = 3;
LABEL_28:
          fputc(10, *v18);
          goto LABEL_63;
        }
      }
LABEL_62:
      uint64_t v34 = 3;
      goto LABEL_63;
    }
    break;
  }
LABEL_31:
  float v37 = *(float *)(a1 + 228);
  float v38 = (float)*((unsigned int *)v9 + 18);
  if (v37 != 0.0) {
    float v38 = v37 + (float)(v38 - v37) * 0.4;
  }
  *(float *)(a1 + 22_Block_object_dispose(&a9, 8) = v38;
  if (a6 && a5 && (v9[13] & 2) != 0)
  {
    if (!*a6) {
      goto LABEL_62;
    }
    unint64_t v39 = v9[5];
    *a5 = 0x80;
    if (*a6 <= 0) {
      __assert_rtn("lsqpack_enc_int", "lsqpack.c", 759, "dst < end");
    }
    if (v39 > 0x7E)
    {
      uint64_t v51 = &a5[*a6];
      *a5 = -1;
      os_log_type_t v52 = a5 + 1;
      unint64_t v53 = v39 - 127;
      if (v39 - 127 >= 0x80)
      {
        while (v52 < v51)
        {
          *v52++ = v53 | 0x80;
          unint64_t v39 = v53 >> 7;
          unint64_t v54 = v53 >> 14;
          v53 >>= 7;
          if (!v54)
          {
            uint64_t v55 = v52 - 1;
            goto LABEL_60;
          }
        }
        goto LABEL_62;
      }
      uint64_t v55 = a5;
      LOBYTE(v39) = v39 - 127;
LABEL_60:
      if (v52 >= v51) {
        goto LABEL_62;
      }
      unsigned int v40 = v55 + 2;
      unsigned char *v52 = v39;
      if (v55 + 2 <= a5) {
        goto LABEL_62;
      }
    }
    else
    {
      *a5 = v39 | 0x80;
      unsigned int v40 = a5 + 1;
    }
    int v41 = v40 - a5;
    *a6 = v40 - a5;
    unsigned int v42 = *(_DWORD *)(a1 + 20);
    *(_DWORD *)(a1 + 24) += v41;
    if (v42)
    {
      int v43 = *((_DWORD *)v9 + 16);
      unsigned int v44 = 2 * v42 + v43 - *(_DWORD *)(a1 + 36);
      if (~(v44 / (2 * v42) * 2 * v42) + v44 < v42) {
        *(_DWORD *)(a1 + 36) = v43;
      }
    }
  }
  else if (a6)
  {
    *a6 = 0;
  }
  *a3 += v9[16];
  unsigned int v45 = *(_DWORD *)(a1 + 28);
  unsigned int v46 = *(_DWORD *)(a1 + 24) + *((_DWORD *)v9 + 12);
  *(_DWORD *)(a1 + 24) = v46;
  if (v45 >= 0x80000001)
  {
    *(_DWORD *)(a1 + 24) = (float)((float)((float)v46 * 1000.0) / (float)v45);
    *(_DWORD *)(a1 + 2_Block_object_dispose(&a9, 8) = 1000;
    os_log_type_t v47 = *(FILE **)(a1 + 48);
    if (v47)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v47);
      unsigned int v48 = *(FILE **)(a1 + 48);
      unsigned int v49 = *(_DWORD *)(a1 + 28);
      if (v49)
      {
        float v50 = (float)*(unsigned int *)(a1 + 24) / (float)v49;
        if (v48)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, *(FILE **)(a1 + 48));
          fprintf(*(FILE **)(a1 + 48), "bytes in: %u; bytes out: %u, ratio: %.3f",
            *(_DWORD *)(a1 + 28),
            *(_DWORD *)(a1 + 24),
            v50);
          fputc(10, *(FILE **)(a1 + 48));
        }
      }
      else
      {
        float v50 = 0.0;
      }
      fprintf(v48, "reset bytes in/out counters, ratio: %.3f", v50);
      fputc(10, *(FILE **)(a1 + 48));
    }
  }
  int v18 = (FILE **)(a1 + 48);
  uint64_t v56 = *(FILE **)(a1 + 48);
  if (v56)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v56);
    fprintf(*v18, "header block for stream %llu is done", v9[5]);
    uint64_t v34 = 0;
    goto LABEL_28;
  }
  uint64_t v34 = 0;
LABEL_63:
  int v57 = *((_DWORD *)v9 + 26);
  if ((v57 & 0x10) != 0)
  {
    uint64_t v58 = *v9;
    char v59 = (void *)v9[1];
    if (*v9)
    {
      *(void *)(v58 + _Block_object_dispose(&a9, 8) = v59;
      *(void *)v9[1] = v58;
      if ((v57 & 4) == 0) {
        goto LABEL_72;
      }
    }
    else
    {
      *(void *)(a1 + 8_Block_object_dispose(&a9, 8) = v59;
      void *v59 = 0;
      if ((v57 & 4) == 0)
      {
LABEL_72:
        free(v9);
        return v34;
      }
    }
    uint64_t v60 = v9[2];
    if (v60) {
      *(void *)(v60 + 24) = v9[3];
    }
    else {
      *(void *)(a1 + 16 * (v9[8] & 7) + 104) = v9[3];
    }
    *(void *)v9[3] = v60;
    --*(_DWORD *)(a1 + 224);
    goto LABEL_72;
  }
  return v34;
}

uint64_t parse_header_prefix(uint64_t a1, uint64_t a2, unsigned __int8 *__src, uint64_t a4)
{
  if (a4 < 1)
  {
LABEL_26:
    if (*(void *)(a2 + 56)) {
      return 2;
    }
    else {
      return 3;
    }
  }
  int v4 = &__src[a4];
  switch(*(_DWORD *)(a2 + 136))
  {
    case 0:
      *(_DWORD *)(a2 + 144) = 0;
      *(_DWORD *)(a2 + 136) = 1;
      goto LABEL_6;
    case 1:
      if (!*(_DWORD *)(a2 + 144))
      {
LABEL_6:
        int v8 = __src + 1;
        unint64_t v6 = *__src;
        if (v6 == 255)
        {
          unsigned int v7 = 0;
          char v5 = 1;
          goto LABEL_13;
        }
        goto LABEL_17;
      }
      char v5 = 0;
      unint64_t v6 = *(void *)(a2 + 160);
      unsigned int v7 = *(_DWORD *)(a2 + 148);
      int v8 = __src;
      do
      {
        unsigned int v15 = *v8++;
        unsigned int v14 = v15;
        v6 += (unint64_t)(v15 & 0x7F) << v7;
        v7 += 7;
        if ((v15 & 0x80) == 0)
        {
          if (v7 >= 0x40)
          {
            if (v7 != 70) {
              return 3;
            }
            uint64_t v22 = 3;
            if (v14 > 1 || (v6 & 0x8000000000000000) == 0) {
              return v22;
            }
            *(void *)(a2 + 16_Block_object_dispose(&a9, 8) = v6;
            goto LABEL_18;
          }
LABEL_17:
          *(void *)(a2 + 16_Block_object_dispose(&a9, 8) = v6;
          if (!v6)
          {
            *(_DWORD *)(a2 + 104) |= 1u;
            *(_DWORD *)(a2 + 136) = 2;
LABEL_22:
            unint64_t __src = v8;
            if (v8 >= v4) {
              goto LABEL_26;
            }
LABEL_23:
            *(_DWORD *)(a2 + 176) = *__src >> 7;
            *(_DWORD *)(a2 + 144) = 0;
            *(_DWORD *)(a2 + 136) = 3;
            char v13 = 7;
            goto LABEL_24;
          }
LABEL_18:
          int v17 = *(_DWORD *)(a1 + 20);
          unint64_t v18 = (2 * v17);
          if (v6 > v18) {
            return 3;
          }
          if (v17) {
            unsigned int v19 = (v6 + v18 - 2) % v18;
          }
          else {
            unsigned int v19 = 0;
          }
          *(_DWORD *)(a2 + 64) = v19;
          *(_DWORD *)(a2 + 104) |= 3u;
          *(_DWORD *)(a2 + 136) = 2;
          unsigned int v26 = *(_DWORD *)(a1 + 20);
          unsigned int v27 = *(_DWORD *)(a1 + 32);
          int v28 = v27 - v26;
          if (v27 >= v26)
          {
            uint64_t v22 = 1;
            if (v27 < v19 || v28 + 1 > v19) {
              return v22;
            }
          }
          else if (v27 < v19 && v27 + v26 >= v19)
          {
            return 1;
          }
          goto LABEL_22;
        }
LABEL_13:
        ;
      }
      while (v8 < v4);
      if (v5) {
        int v16 = 0;
      }
      else {
        int v16 = *(_DWORD *)(a2 + 152);
      }
      unsigned int v23 = v16 + v8 - __src;
      if (v23 > 0xA) {
        return 3;
      }
      *(void *)(a2 + 160) = v6;
      *(_DWORD *)(a2 + 14_Block_object_dispose(&a9, 8) = v7;
      *(_DWORD *)(a2 + 152) = v23;
      unint64_t v24 = 1;
      *(_DWORD *)(a2 + 144) = 1;
      unsigned int v25 = 2 * *(_DWORD *)(a1 + 20);
      if (v25 >= 0xFF) {
        unint64_t v24 = 2;
      }
      if (v25 > 0x17E) {
        ++v24;
      }
      if (v25 > 0x40FE) {
        ++v24;
      }
      if (v25 > 0x2000FE) {
        ++v24;
      }
      if (v25 > 0x100000FE) {
        ++v24;
      }
      if (*(void *)(a2 + 48) - *(void *)(a2 + 56) <= v24) {
        return 2;
      }
      else {
        return 3;
      }
    case 2:
      goto LABEL_23;
    case 3:
      if (*(_DWORD *)(a2 + 144))
      {
        char v9 = 0;
        unint64_t v10 = *(void *)(a2 + 160);
        unsigned int v11 = *(_DWORD *)(a2 + 148);
        int v12 = __src;
        while (1)
        {
          unsigned int v30 = *v12++;
          unsigned int v29 = v30;
          v10 += (unint64_t)(v30 & 0x7F) << v11;
          v11 += 7;
          if ((v30 & 0x80) == 0) {
            break;
          }
LABEL_57:
          if (v12 >= v4)
          {
            if (v9) {
              int v31 = 0;
            }
            else {
              int v31 = *(_DWORD *)(a2 + 152);
            }
            unsigned int v35 = v31 + v12 - __src;
            if (v35 < 0xB)
            {
              *(void *)(a2 + 160) = v10;
              *(_DWORD *)(a2 + 14_Block_object_dispose(&a9, 8) = v11;
              *(_DWORD *)(a2 + 152) = v35;
              *(_DWORD *)(a2 + 144) = 1;
              return 2;
            }
            return 3;
          }
        }
        if (v11 >= 0x40)
        {
          if (v11 != 70) {
            return 3;
          }
          uint64_t v22 = 3;
          if (v29 > 1 || (v10 & 0x8000000000000000) == 0) {
            return v22;
          }
        }
      }
      else
      {
        char v13 = -1;
LABEL_24:
        int v20 = -1 << v13;
        int v12 = __src + 1;
        unint64_t v21 = v20 & 0x80 ^ 0xFFu;
        unint64_t v10 = *__src & v21;
        if (v10 >= v21)
        {
          unsigned int v11 = 0;
          char v9 = 1;
          goto LABEL_57;
        }
      }
      *(void *)(a2 + 16_Block_object_dispose(&a9, 8) = v10;
      if ((*(unsigned char *)(a2 + 104) & 2) == 0)
      {
        int v32 = 0;
LABEL_76:
        *(_DWORD *)(a2 + 6_Block_object_dispose(&a9, 8) = v32;
        *(void *)(a2 + 96) = parse_header_data;
        *(_DWORD *)(a2 + 136) = 0;
        if (v4 == v12) {
          return 2;
        }
        return parse_header_data(a1, a2, v12, v4 - v12);
      }
      int v32 = *(_DWORD *)(a1 + 20);
      if (*(_DWORD *)(a2 + 176))
      {
        if (!v32) {
          goto LABEL_76;
        }
        unsigned int v33 = 2 * v32;
        unint64_t v34 = *(_DWORD *)(a2 + 64) + v33 + ~v10;
      }
      else
      {
        if (!v32) {
          goto LABEL_76;
        }
        unint64_t v34 = v10 + *(unsigned int *)(a2 + 64);
        unsigned int v33 = 2 * v32;
      }
      int v32 = v34 % v33;
      goto LABEL_76;
    default:
      __assert_rtn("parse_header_prefix", "lsqpack.c", 3987, "0");
  }
}

uint64_t parse_header_data(uint64_t a1, uint64_t a2, unsigned __int8 *__src, uint64_t a4)
{
  int v4 = __src;
  unsigned int v7 = __src;
  if (a4 < 1)
  {
LABEL_218:
    if (*(void *)(a2 + 56)) {
      return 2;
    }
    if (*(_DWORD *)(a2 + 136))
    {
      int v162 = 3843;
      goto LABEL_341;
    }
    int v141 = *(_DWORD *)(a2 + 104);
    if ((v141 & 0x22) == 2)
    {
      int v162 = 3837;
      goto LABEL_341;
    }
    if ((v141 & 0x40) != 0)
    {
      int v162 = 3839;
      goto LABEL_341;
    }
    return 0;
  }
  int v8 = &__src[a4];
  char v9 = (_DWORD *)(a2 + 184);
  uint64_t v10 = 0xFFFFFFFFLL;
  unsigned int v11 = __src;
  while (1)
  {
    switch(*(_DWORD *)(a2 + 136))
    {
      case 0:
        int v14 = (char)*v11;
        if ((v14 & 0x80000000) == 0)
        {
          if ((v14 & 0x40) == 0)
          {
            if ((v14 & 0x20) == 0)
            {
              if ((v14 & 0x10) == 0)
              {
                *(_DWORD *)(a2 + 14_Block_object_dispose(&a9, 8) = v14 & 8;
                *(_DWORD *)(a2 + 160) = 0;
                *(_DWORD *)(a2 + 136) = 11;
                uint64_t v10 = 3;
LABEL_57:
                unsigned int v7 = v11 + 1;
                uint64_t v45 = *v11;
                unint64_t v46 = ~(-1 << v10);
                uint64_t v19 = v45 & v46;
                if ((v45 & v46) >= v46)
                {
                  unsigned int v20 = 0;
                  char v44 = 1;
                  do
                  {
                    if (v7 >= v8)
                    {
                      if (v44) {
                        int v146 = 0;
                      }
                      else {
                        int v146 = *(_DWORD *)(a2 + 168);
                      }
                      unsigned int v161 = v146 + v7 - v11;
                      if (v161 >= 0xB)
                      {
                        int v162 = 3802;
                        goto LABEL_342;
                      }
                      goto LABEL_334;
                    }
LABEL_113:
                    unsigned int v72 = *v7++;
                    unsigned int v71 = v72;
                    v19 += (unint64_t)(v72 & 0x7F) << v20;
                    v20 += 7;
                  }
                  while ((v72 & 0x80) != 0);
                  if (v20 >= 0x40)
                  {
                    int v156 = 3802;
                    if (v19 > -1 || v71 > 1) {
                      long long v158 = v11;
                    }
                    else {
                      long long v158 = v7;
                    }
                    int v162 = 3802;
                    goto LABEL_309;
                  }
                  if (!((unint64_t)v19 >> 24)) {
                    goto LABEL_116;
                  }
                  int v162 = 3802;
                  goto LABEL_341;
                }
LABEL_116:
                unsigned int v73 = *(_DWORD *)(a1 + 20);
                if (v73)
                {
                  unsigned int v74 = 2 * v73;
                  unsigned int v75 = ((int)v19 + *(_DWORD *)(a2 + 68) + 1) % v74;
                  unsigned int v73 = (v74 - v75 + *(_DWORD *)(a1 + 32)) % v74;
                  unsigned int v76 = *(_DWORD *)(a1 + 56);
                  if (!v76) {
                    goto LABEL_226;
                  }
                }
                else
                {
                  unsigned int v75 = 0;
                  unsigned int v76 = *(_DWORD *)(a1 + 56);
                  if (!v76)
                  {
LABEL_226:
                    int v162 = 3792;
                    goto LABEL_341;
                  }
                }
                unsigned int v77 = *(_DWORD *)(a1 + 60);
                unsigned int v78 = *(_DWORD *)(a1 + 64);
                BOOL v55 = v77 >= v78;
                unsigned int v79 = v77 - v78;
                if (v55) {
                  unsigned int v80 = 0;
                }
                else {
                  unsigned int v80 = v76;
                }
                if (v79 + v80 <= v73) {
                  goto LABEL_226;
                }
                BOOL v81 = *(unsigned int **)(*(void *)(a1 + 72) + 8 * ((v76 + ~v73 + v77) % v76));
                if (!v81) {
                  goto LABEL_226;
                }
                int v82 = *(_DWORD *)(a2 + 104);
                if ((v82 & 2) != 0) {
                  int v12 = v82 | (32 * (*(_DWORD *)(a2 + 64) == v75));
                }
                else {
                  int v12 = v82 | 0x40;
                }
                *(_DWORD *)(a2 + 104) = v12;
                if (header_out_begin_dynamic_nameref((unsigned int *)a1, (void *)a2, v81, *(_DWORD *)(a2 + 148)))
                {
                  int v162 = 3796;
                  goto LABEL_341;
                }
LABEL_5:
                int v13 = 4;
                goto LABEL_6;
              }
              *(_DWORD *)(a2 + 160) = 0;
              *(_DWORD *)(a2 + 136) = 2;
              uint64_t v10 = 4;
LABEL_110:
              unsigned int v7 = v11 + 1;
              uint64_t v69 = *v11;
              unint64_t v70 = ~(-1 << v10);
              uint64_t v19 = v69 & v70;
              if ((v69 & v70) >= v70)
              {
                unsigned int v20 = 0;
                char v18 = 1;
                do
                {
                  if (v7 >= v8)
                  {
                    if (v18) {
                      int v147 = 0;
                    }
                    else {
                      int v147 = *(_DWORD *)(a2 + 168);
                    }
                    unsigned int v161 = v147 + v7 - v11;
                    if (v161 >= 0xB)
                    {
                      int v162 = 3821;
                      goto LABEL_342;
                    }
                    goto LABEL_334;
                  }
LABEL_149:
                  unsigned int v100 = *v7++;
                  unsigned int v99 = v100;
                  v19 += (unint64_t)(v100 & 0x7F) << v20;
                  v20 += 7;
                }
                while ((v100 & 0x80) != 0);
                if (v20 >= 0x40)
                {
                  int v156 = 3821;
                  if (v19 > -1 || v99 > 1) {
                    long long v158 = v11;
                  }
                  else {
                    long long v158 = v7;
                  }
                  int v162 = 3821;
                  goto LABEL_309;
                }
                if (!((unint64_t)v19 >> 24)) {
                  goto LABEL_152;
                }
                int v162 = 3821;
                goto LABEL_341;
              }
LABEL_152:
              int v101 = *(_DWORD *)(a1 + 20);
              if (v101) {
                unsigned int v102 = ((int)v19 + *(_DWORD *)(a2 + 68) + 1) % (2 * v101);
              }
              else {
                unsigned int v102 = 0;
              }
              int v103 = header_out_dynamic_entry((unsigned int *)a1, a2, v102);
              int v104 = *(_DWORD *)(a2 + 104);
              if ((v104 & 2) != 0) {
                int v105 = v104 | (32 * (*(_DWORD *)(a2 + 64) == v102));
              }
              else {
                int v105 = v104 | 0x40;
              }
              *(_DWORD *)(a2 + 104) = v105;
              if (v103)
              {
                int v162 = 3816;
                goto LABEL_341;
              }
              goto LABEL_200;
            }
            *(_DWORD *)(a2 + 14_Block_object_dispose(&a9, 8) = v14 & 0x10;
            *(_DWORD *)(a2 + 152) = *v11 & 8;
            *(_DWORD *)(a2 + 160) = 0;
            *(_DWORD *)(a2 + 136) = 8;
            uint64_t v10 = 3;
LABEL_107:
            unsigned int v7 = v11 + 1;
            uint64_t v67 = *v11;
            unint64_t v68 = ~(-1 << v10);
            uint64_t v19 = v67 & v68;
            if ((v67 & v68) >= v68)
            {
              unsigned int v20 = 0;
              char v35 = 1;
              do
              {
                if (v7 >= v8)
                {
                  if (v35) {
                    int v145 = 0;
                  }
                  else {
                    int v145 = *(_DWORD *)(a2 + 168);
                  }
                  unsigned int v161 = v145 + v7 - v11;
                  if (v161 >= 0xB)
                  {
                    int v162 = 3731;
                    goto LABEL_342;
                  }
LABEL_334:
                  *(void *)(a2 + 176) = v19;
                  *(_DWORD *)(a2 + 164) = v20;
                  *(_DWORD *)(a2 + 16_Block_object_dispose(&a9, 8) = v161;
                  *(_DWORD *)(a2 + 160) = 1;
                  return 2;
                }
LABEL_203:
                unsigned int v135 = *v7++;
                unsigned int v134 = v135;
                v19 += (unint64_t)(v135 & 0x7F) << v20;
                v20 += 7;
              }
              while ((v135 & 0x80) != 0);
              if (v20 >= 0x40)
              {
                int v156 = 3731;
                if (v19 > -1 || v134 > 1) {
                  long long v158 = v11;
                }
                else {
                  long long v158 = v7;
                }
                int v162 = 3731;
LABEL_309:
                if (v20 == 70) {
                  unsigned int v11 = v158;
                }
                else {
                  int v162 = v156;
                }
                goto LABEL_342;
              }
              if (!((unint64_t)v19 >> 24)) {
                goto LABEL_206;
              }
              int v162 = 3731;
              goto LABEL_341;
            }
LABEL_206:
            *(_DWORD *)(a2 + 140) = v19;
            if (*(void *)(a2 + 80)) {
              __assert_rtn("header_out_begin_literal", "lsqpack.c", 3177, "!read_ctx->hbrc_out.xhdr");
            }
            int v136 = *(_DWORD *)(a2 + 148);
            if (*(_DWORD *)(a2 + 152)) {
              unsigned int v137 = v19 >> 1;
            }
            else {
              unsigned int v137 = 0;
            }
            uint64_t v138 = 4 * (*(_DWORD *)a1 & 1);
            uint64_t v139 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 40) + 8))(*(void *)(a2 + 32), 0, v138 + v137 + v19);
            *(void *)(a2 + 80) = v139;
            if (!v139)
            {
              int v162 = 3719;
              goto LABEL_341;
            }
            *(unsigned char *)(v139 + 35) = v138;
            if (v136) {
              *(unsigned char *)(v139 + 33) |= 0x40u;
            }
            *(void *)(a2 + 8_Block_object_dispose(&a9, 8) = 0;
            if (*(_DWORD *)(a2 + 152))
            {
              *(_DWORD *)(a2 + 184) = 0;
              int v13 = 9;
            }
            else
            {
              int v13 = 10;
            }
            goto LABEL_6;
          }
          *(_DWORD *)(a2 + 14_Block_object_dispose(&a9, 8) = v14 & 0x20;
          *(_DWORD *)(a2 + 144) = *v11 & 0x10;
          *(_DWORD *)(a2 + 160) = 0;
          *(_DWORD *)(a2 + 136) = 3;
          uint64_t v10 = 4;
LABEL_104:
          unsigned int v7 = v11 + 1;
          uint64_t v65 = *v11;
          unint64_t v66 = ~(-1 << v10);
          uint64_t v16 = v65 & v66;
          if ((v65 & v66) >= v66)
          {
            unsigned int v17 = 0;
            char v21 = 1;
            do
            {
              if (v7 >= v8)
              {
                if (v21) {
                  int v144 = 0;
                }
                else {
                  int v144 = *(_DWORD *)(a2 + 168);
                }
                unsigned int v152 = v144 + v7 - v11;
                if (v152 >= 0xB)
                {
                  int v162 = 3621;
                  goto LABEL_342;
                }
                goto LABEL_320;
              }
LABEL_162:
              unsigned int v107 = *v7++;
              unsigned int v106 = v107;
              v16 += (unint64_t)(v107 & 0x7F) << v17;
              v17 += 7;
            }
            while ((v107 & 0x80) != 0);
            if (v17 >= 0x40)
            {
              int v148 = 3621;
              if (v16 > -1 || v106 > 1) {
                long long v150 = v11;
              }
              else {
                long long v150 = v7;
              }
              int v151 = 3621;
              goto LABEL_279;
            }
            if (!((unint64_t)v16 >> 24)) {
              goto LABEL_165;
            }
            int v162 = 3621;
            goto LABEL_341;
          }
LABEL_165:
          if (*(_DWORD *)(a2 + 144))
          {
            if (*(void *)(a2 + 80)) {
              __assert_rtn("header_out_begin_static_nameref", "lsqpack.c", 3088, "!read_ctx->hbrc_out.xhdr");
            }
            if (v16 > 0x62)
            {
              int v162 = 3602;
              goto LABEL_341;
            }
            long long v108 = v9;
            uint64_t v109 = v10;
            long long v167 = v108;
            long long v171 = (char *)v4;
            long long v110 = v8;
            int v111 = *(_DWORD *)(a2 + 148);
            uint64_t v112 = a1;
            uint64_t v113 = 4 * (*(_DWORD *)a1 & 1);
            long long v114 = &(&static_table)[3 * v16];
            size_t v115 = *((unsigned int *)v114 + 4);
            uint64_t v169 = v112;
            uint64_t v116 = (*(uint64_t (**)(void, void, size_t))(*(void *)(v112 + 40) + 8))(*(void *)(a2 + 32), 0, v113 + v115);
            *(void *)(a2 + 80) = v116;
            if (!v116)
            {
              int v162 = 3602;
              unsigned int v11 = v7;
              a1 = v169;
              int v4 = (unsigned __int8 *)v171;
              goto LABEL_342;
            }
            BOOL v117 = (_DWORD *)v116;
            *(unsigned char *)(v116 + 35) = v113;
            *(unsigned char *)(v116 + 3nw_tcp_options_set_enable_fast_open(options, 1) = v16;
            char v118 = *(unsigned char *)(v116 + 33);
            *(unsigned char *)(v116 + 33) = v118 | 0xA;
            *(_DWORD *)(v116 + _Block_object_dispose(&a9, 8) = name_hashes[v16];
            if (v111) {
              *(unsigned char *)(v116 + 33) = v118 | 0x4A;
            }
            *(_WORD *)(v116 + 24) = v115;
            BOOL v119 = (char *)(*(void *)v116 + *(int *)(v116 + 16));
            memcpy(v119, *v114, v115);
            os_log_type_t v120 = &v119[v115];
            if (v113)
            {
              *(_WORD *)os_log_type_t v120 = 8250;
              LOWORD(v120) = (_WORD)v120 + 2;
            }
            int v8 = v110;
            a1 = v169;
            int v4 = (unsigned __int8 *)v171;
            uint64_t v10 = v109;
            v117[5] = (unsigned __int16)((_WORD)v120 - *v117);
            *(void *)(a2 + 8_Block_object_dispose(&a9, 8) = 1;
            char v9 = v167;
            goto LABEL_5;
          }
          unsigned int v121 = *(_DWORD *)(a1 + 20);
          if (v121)
          {
            unsigned int v122 = 2 * v121;
            unsigned int v121 = (2 * v121 - v16 + *(_DWORD *)(a2 + 68)) % (2 * v121);
            unsigned int v123 = (v122 - v121 + *(_DWORD *)(a1 + 32)) % v122;
            unsigned int v124 = *(_DWORD *)(a1 + 56);
            if (!v124) {
              goto LABEL_237;
            }
LABEL_180:
            unsigned int v125 = *(_DWORD *)(a1 + 60);
            unsigned int v126 = *(_DWORD *)(a1 + 64);
            BOOL v55 = v125 >= v126;
            unsigned int v127 = v125 - v126;
            if (v55) {
              unsigned int v128 = 0;
            }
            else {
              unsigned int v128 = v124;
            }
            if (v127 + v128 > v123)
            {
              id v129 = *(unsigned int **)(*(void *)(a1 + 72) + 8 * ((v124 + ~v123 + v125) % v124));
              if (v129)
              {
                int v130 = *(_DWORD *)(a2 + 104);
                if ((v130 & 2) != 0) {
                  int v131 = v130 | (32 * (*(_DWORD *)(a2 + 64) == v121));
                }
                else {
                  int v131 = v130 | 0x40;
                }
                *(_DWORD *)(a2 + 104) = v131;
                if (header_out_begin_dynamic_nameref((unsigned int *)a1, (void *)a2, v129, *(_DWORD *)(a2 + 148)))
                {
                  int v162 = 3613;
                  goto LABEL_341;
                }
                goto LABEL_5;
              }
            }
          }
          else
          {
            unsigned int v123 = 0;
            unsigned int v124 = *(_DWORD *)(a1 + 56);
            if (v124) {
              goto LABEL_180;
            }
          }
LABEL_237:
          int v162 = 3609;
          goto LABEL_341;
        }
        *(_DWORD *)(a2 + 144) = v14 & 0x40;
        *(_DWORD *)(a2 + 160) = 0;
        uint64_t v10 = 6;
        *(_DWORD *)(a2 + 136) = 1;
LABEL_60:
        unsigned int v7 = v11 + 1;
        uint64_t v47 = *v11;
        unint64_t v48 = ~(-1 << v10);
        uint64_t v16 = v47 & v48;
        if ((v47 & v48) >= v48)
        {
          unsigned int v17 = 0;
          char v15 = 1;
          do
          {
            if (v7 >= v8)
            {
              if (v15) {
                int v143 = 0;
              }
              else {
                int v143 = *(_DWORD *)(a2 + 168);
              }
              unsigned int v152 = v143 + v7 - v11;
              if (v152 >= 0xB)
              {
                int v162 = 3590;
                goto LABEL_342;
              }
LABEL_320:
              *(void *)(a2 + 176) = v16;
              goto LABEL_321;
            }
LABEL_127:
            unsigned int v84 = *v7++;
            unsigned int v83 = v84;
            v16 += (unint64_t)(v84 & 0x7F) << v17;
            v17 += 7;
          }
          while ((v84 & 0x80) != 0);
          if (v17 >= 0x40)
          {
            int v148 = 3590;
            if (v16 > -1 || v83 > 1) {
              long long v150 = v11;
            }
            else {
              long long v150 = v7;
            }
            int v151 = 3590;
            goto LABEL_279;
          }
          if (!((unint64_t)v16 >> 24)) {
            goto LABEL_130;
          }
          int v162 = 3590;
          goto LABEL_341;
        }
LABEL_130:
        if (!*(_DWORD *)(a2 + 144))
        {
          int v94 = *(_DWORD *)(a1 + 20);
          if (v94) {
            unsigned int v95 = (2 * v94 - (int)v16 + *(_DWORD *)(a2 + 68)) % (2 * v94);
          }
          else {
            unsigned int v95 = 0;
          }
          int v96 = header_out_dynamic_entry((unsigned int *)a1, a2, v95);
          int v97 = *(_DWORD *)(a2 + 104);
          if ((v97 & 2) != 0) {
            int v98 = v97 | (32 * (*(_DWORD *)(a2 + 64) == v95));
          }
          else {
            int v98 = v97 | 0x40;
          }
          *(_DWORD *)(a2 + 104) = v98;
          if (v96)
          {
LABEL_242:
            int v162 = 3585;
            goto LABEL_341;
          }
          goto LABEL_200;
        }
        if ((unint64_t)v16 > 0x62) {
          goto LABEL_242;
        }
        unsigned int v165 = v10;
        long long v166 = v8;
        long long v170 = (char *)v4;
        uint64_t v85 = 4 * (*(_DWORD *)a1 & 1);
        uint64_t v86 = &(&static_table)[3 * v16];
        size_t v88 = *((unsigned int *)v86 + 4);
        size_t v87 = *((unsigned int *)v86 + 5);
        uint64_t v89 = (v87 + v88);
        uint64_t v90 = (*(uint64_t (**)(void, void, uint64_t))(*(void *)(a1 + 40) + 8))(*(void *)(a2 + 32), 0, v89 + v85);
        if (!v90) {
          goto LABEL_232;
        }
        uint64_t v91 = (_DWORD *)v90;
        uint64_t v168 = a1;
        *(unsigned char *)(v90 + 35) = v85;
        *(unsigned char *)(v90 + 3nw_tcp_options_set_enable_fast_open(options, 1) = v16;
        *(unsigned char *)(v90 + 33) |= 0x3Au;
        *(_WORD *)(v90 + 24) = v88;
        *(_WORD *)(v90 + 26) = v87;
        *(_DWORD *)(v90 + _Block_object_dispose(&a9, 8) = name_hashes[v16];
        *(_DWORD *)(v90 + 12) = nameval_hashes[v16];
        os_log_type_t v92 = (char *)(*(void *)v90 + *(int *)(v90 + 16));
        memcpy(v92, (&static_table)[3 * v16], v88);
        BOOL v93 = &v92[v88];
        if (v85)
        {
          *(_WORD *)BOOL v93 = 8250;
          v93 += 2;
        }
        v91[5] = (unsigned __int16)((_WORD)v93 - *v91);
        memcpy(v93, (&static_table)[3 * v16 + 1], v87);
        a1 = v168;
        if (v85) {
          *(_WORD *)&v93[v87] = 2573;
        }
        if ((*(unsigned int (**)(void, _DWORD *))(*(void *)(v168 + 40) + 16))(*(void *)(a2 + 32), v91))
        {
LABEL_232:
          int v162 = 3585;
          unsigned int v11 = v7;
          int v4 = (unsigned __int8 *)v170;
          goto LABEL_342;
        }
        *(_DWORD *)(v168 + 28) += v89;
        int v4 = (unsigned __int8 *)v170;
        int v8 = v166;
        uint64_t v10 = v165;
        *(_DWORD *)(a2 + 136) = 0;
LABEL_7:
        unsigned int v11 = v7;
        if (v7 >= v8) {
          goto LABEL_218;
        }
        break;
      case 1:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_60;
        }
        char v15 = 0;
        uint64_t v16 = *(void *)(a2 + 176);
        unsigned int v17 = *(_DWORD *)(a2 + 164);
        unsigned int v7 = v11;
        goto LABEL_127;
      case 2:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_110;
        }
        char v18 = 0;
        uint64_t v19 = *(void *)(a2 + 176);
        unsigned int v20 = *(_DWORD *)(a2 + 164);
        unsigned int v7 = v11;
        goto LABEL_149;
      case 3:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_104;
        }
        char v21 = 0;
        uint64_t v16 = *(void *)(a2 + 176);
        unsigned int v17 = *(_DWORD *)(a2 + 164);
        unsigned int v7 = v11;
        goto LABEL_162;
      case 4:
        *(_DWORD *)(a2 + 152) = *v11 & 0x80;
        *(_DWORD *)(a2 + 160) = 0;
        *(_DWORD *)(a2 + 136) = 5;
        uint64_t v10 = 7;
        goto LABEL_23;
      case 5:
        if (*(_DWORD *)(a2 + 160))
        {
          char v22 = 0;
          int64_t v23 = *(void *)(a2 + 176);
          unsigned int v17 = *(_DWORD *)(a2 + 164);
          unsigned int v7 = v11;
          goto LABEL_190;
        }
LABEL_23:
        unsigned int v7 = v11 + 1;
        uint64_t v24 = *v11;
        unint64_t v25 = ~(-1 << v10);
        int64_t v23 = v24 & v25;
        if ((v24 & v25) < v25) {
          goto LABEL_193;
        }
        unsigned int v17 = 0;
        char v22 = 1;
        do
        {
          if (v7 >= v8)
          {
            if (v22) {
              int v142 = 0;
            }
            else {
              int v142 = *(_DWORD *)(a2 + 168);
            }
            unsigned int v152 = v142 + v7 - v11;
            if (v152 >= 0xB)
            {
              int v162 = 3658;
              goto LABEL_342;
            }
            *(void *)(a2 + 176) = v23;
LABEL_321:
            *(_DWORD *)(a2 + 164) = v17;
            *(_DWORD *)(a2 + 16_Block_object_dispose(&a9, 8) = v152;
            *(_DWORD *)(a2 + 160) = 1;
            return 2;
          }
LABEL_190:
          unsigned int v133 = *v7++;
          unsigned int v132 = v133;
          v23 += (unint64_t)(v133 & 0x7F) << v17;
          v17 += 7;
        }
        while ((v133 & 0x80) != 0);
        if (v17 >= 0x40)
        {
          int v148 = 3658;
          if (v23 > -1 || v132 > 1) {
            long long v150 = v11;
          }
          else {
            long long v150 = v7;
          }
          int v151 = 3658;
LABEL_279:
          BOOL v155 = v17 == 70;
          if (v17 == 70) {
            int v162 = v151;
          }
          else {
            int v162 = v148;
          }
          if (v155) {
            unsigned int v11 = v150;
          }
          goto LABEL_342;
        }
        if ((unint64_t)v23 >> 24)
        {
          int v162 = 3658;
          goto LABEL_341;
        }
LABEL_193:
        *(_DWORD *)(a2 + 140) = v23;
        if (!v23)
        {
          if (header_out_write_value((int *)a1, a2, 0, 1))
          {
            int v162 = 3653;
            goto LABEL_341;
          }
LABEL_200:
          *(_DWORD *)(a2 + 136) = 0;
          goto LABEL_7;
        }
        if (!*(_DWORD *)(a2 + 152))
        {
          if (guarantee_out_bytes(a1, a2, v23))
          {
            int v162 = 3646;
            goto LABEL_341;
          }
          int v13 = 7;
LABEL_6:
          *(_DWORD *)(a2 + 136) = v13;
          goto LABEL_7;
        }
        if (!guarantee_out_bytes(a1, a2, v23 + (v23 >> 1)))
        {
          *(_DWORD *)(a2 + 184) = 0;
          int v13 = 6;
          goto LABEL_6;
        }
        int v162 = 3639;
LABEL_341:
        unsigned int v11 = v7;
LABEL_342:
        *(_DWORD *)(a1 + 332) = v162;
        *(_DWORD *)(a1 + 32_Block_object_dispose(&a9, 8) = 0;
        uint64_t v163 = *(void *)(a2 + 40);
        *(void *)(a1 + 336) = &v11[*(void *)(a2 + 48)] - &v4[*(void *)(a2 + 56)];
        *(void *)(a1 + 344) = v163;
        long long v164 = *(FILE **)(a1 + 48);
        if (v164)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v164);
          fprintf(*(FILE **)(a1 + 48), "header block error on line %d, offset %llu, stream id %llu", *(_DWORD *)(a1 + 332), *(void *)(a1 + 336), *(void *)(a1 + 344));
          fputc(10, *(FILE **)(a1 + 48));
        }
        return 3;
      case 6:
        unsigned int v26 = *(_DWORD *)(a2 + 140);
        if (v26 >= (int)v8 - (int)v11) {
          int v27 = v8 - v11;
        }
        else {
          int v27 = *(_DWORD *)(a2 + 140);
        }
        if (!v27)
        {
          int v162 = 3663;
          goto LABEL_342;
        }
        uint64_t v28 = *(void *)(a2 + 80);
        if (!v28) {
          goto LABEL_345;
        }
        if (*(_DWORD *)(a2 + 88)) {
          unsigned int v29 = *(_DWORD *)(v28 + 20) - *(_DWORD *)(v28 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          unsigned int v29 = *(_DWORD *)(a2 + 92);
        }
        unsigned int v49 = *(unsigned __int16 *)(v28 + 26);
        if (v49 < v29) {
          goto LABEL_346;
        }
        unint64_t v50 = lsqpack_huff_decode(v11, v27, (char *)(*(void *)v28 + *(int *)(v28 + 16) + v29), v49 - v29, v9, v26 <= (int)v8 - (int)v11);
        unint64_t v52 = HIDWORD(v50);
        unsigned int v7 = &v11[v51];
        int v53 = *(_DWORD *)(a2 + 140);
        *(_DWORD *)(a2 + 140) = v53 - v51;
        if (v50 == 2)
        {
          if (HIDWORD(v50)) {
            *(_DWORD *)(a2 + 92) += HIDWORD(v50);
          }
          if (header_out_grow_buf(a1, a2))
          {
            int v162 = 3688;
            goto LABEL_341;
          }
          goto LABEL_7;
        }
        if (v50 == 1) {
          goto LABEL_85;
        }
        if (v50)
        {
          int v162 = 3691;
          goto LABEL_341;
        }
        if (header_out_write_value((int *)a1, a2, SHIDWORD(v50), v53 == v51))
        {
          int v162 = 3674;
          goto LABEL_341;
        }
        if (!*(_DWORD *)(a2 + 140)) {
          goto LABEL_200;
        }
        goto LABEL_7;
      case 7:
        uint64_t v30 = v10;
        unsigned int v31 = *(_DWORD *)(a2 + 140);
        if (v31 >= (int)v8 - (int)v11) {
          size_t v32 = (v8 - v11);
        }
        else {
          size_t v32 = v31;
        }
        if (!v32)
        {
          int v162 = 3697;
          goto LABEL_342;
        }
        uint64_t v33 = *(void *)(a2 + 80);
        if (!v33) {
          goto LABEL_345;
        }
        if (*(_DWORD *)(a2 + 88)) {
          unsigned int v34 = *(_DWORD *)(v33 + 20) - *(_DWORD *)(v33 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          unsigned int v34 = *(_DWORD *)(a2 + 92);
        }
        unsigned int v54 = *(unsigned __int16 *)(v33 + 26);
        BOOL v55 = v54 >= v34;
        unsigned int v56 = v54 - v34;
        if (!v55) {
          goto LABEL_346;
        }
        if (v56 < v32)
        {
          int v162 = 3700;
          goto LABEL_342;
        }
        memcpy((void *)(*(void *)v33 + *(int *)(v33 + 16) + v34), v11, v32);
        if (header_out_write_value((int *)a1, a2, v32, *(_DWORD *)(a2 + 140) == v32))
        {
          int v162 = 3704;
          goto LABEL_342;
        }
        unsigned int v7 = &v11[v32];
        int v57 = *(_DWORD *)(a2 + 140) - v32;
        *(_DWORD *)(a2 + 140) = v57;
        if (!v57) {
          *(_DWORD *)(a2 + 136) = 0;
        }
        goto LABEL_94;
      case 8:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_107;
        }
        char v35 = 0;
        uint64_t v19 = *(void *)(a2 + 176);
        unsigned int v20 = *(_DWORD *)(a2 + 164);
        unsigned int v7 = v11;
        goto LABEL_203;
      case 9:
        unsigned int v36 = *(_DWORD *)(a2 + 140);
        if (v36 >= (int)v8 - (int)v11) {
          int v37 = v8 - v11;
        }
        else {
          int v37 = *(_DWORD *)(a2 + 140);
        }
        if (!v37)
        {
          int v162 = 3736;
          goto LABEL_342;
        }
        uint64_t v38 = *(void *)(a2 + 80);
        if (!v38) {
          goto LABEL_345;
        }
        if (*(_DWORD *)(a2 + 88)) {
          unsigned int v39 = *(_DWORD *)(v38 + 20) - *(_DWORD *)(v38 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          unsigned int v39 = *(_DWORD *)(a2 + 92);
        }
        unsigned int v58 = *(unsigned __int16 *)(v38 + 26);
        if (v58 < v39) {
          goto LABEL_346;
        }
        unint64_t v59 = lsqpack_huff_decode(v11, v37, (char *)(*(void *)v38 + *(int *)(v38 + 16) + v39), v58 - v39, v9, v36 <= (int)v8 - (int)v11);
        unint64_t v52 = HIDWORD(v59);
        unsigned int v7 = &v11[v60];
        int v61 = *(_DWORD *)(a2 + 140);
        *(_DWORD *)(a2 + 140) = v61 - v60;
        if (v59 == 2)
        {
          if (HIDWORD(v59)) {
            *(_DWORD *)(a2 + 92) += HIDWORD(v59);
          }
          if (header_out_grow_buf(a1, a2))
          {
            int v162 = 3761;
            goto LABEL_341;
          }
        }
        else if (v59 == 1)
        {
LABEL_85:
          if (v52) {
            *(_DWORD *)(a2 + 92) += v52;
          }
        }
        else
        {
          if (v59)
          {
            int v162 = 3764;
            goto LABEL_341;
          }
          if (header_out_write_name((int *)a1, a2, SHIDWORD(v59), v61 == v60))
          {
            int v162 = 3747;
            goto LABEL_341;
          }
          if (!*(_DWORD *)(a2 + 140)) {
            goto LABEL_5;
          }
        }
        goto LABEL_7;
      case 0xA:
        uint64_t v30 = v10;
        unsigned int v40 = *(_DWORD *)(a2 + 140);
        if (v40 >= (int)v8 - (int)v11) {
          size_t v41 = (v8 - v11);
        }
        else {
          size_t v41 = v40;
        }
        if (!v41)
        {
          int v162 = 3770;
          goto LABEL_342;
        }
        uint64_t v42 = *(void *)(a2 + 80);
        if (!v42) {
LABEL_345:
        }
          __assert_rtn("get_dst", "lsqpack.c", 3359, "read_ctx->hbrc_out.xhdr");
        if (*(_DWORD *)(a2 + 88)) {
          unsigned int v43 = *(_DWORD *)(v42 + 20) - *(_DWORD *)(v42 + 16) + *(_DWORD *)(a2 + 92);
        }
        else {
          unsigned int v43 = *(_DWORD *)(a2 + 92);
        }
        unsigned int v62 = *(unsigned __int16 *)(v42 + 26);
        BOOL v55 = v62 >= v43;
        unsigned int v63 = v62 - v43;
        if (!v55) {
LABEL_346:
        }
          __assert_rtn("get_dst", "lsqpack.c", 3366, "read_ctx->hbrc_out.xhdr->val_len >= off");
        if (v63 < v41)
        {
          int v162 = 3773;
          goto LABEL_342;
        }
        memcpy((void *)(*(void *)v42 + *(int *)(v42 + 16) + v43), v11, v41);
        if (header_out_write_name((int *)a1, a2, v41, *(_DWORD *)(a2 + 140) == v41))
        {
          int v162 = 3777;
          goto LABEL_342;
        }
        unsigned int v7 = &v11[v41];
        int v64 = *(_DWORD *)(a2 + 140) - v41;
        *(_DWORD *)(a2 + 140) = v64;
        if (!v64) {
          *(_DWORD *)(a2 + 136) = 4;
        }
LABEL_94:
        uint64_t v10 = v30;
        goto LABEL_7;
      case 0xB:
        if (!*(_DWORD *)(a2 + 160)) {
          goto LABEL_57;
        }
        char v44 = 0;
        uint64_t v19 = *(void *)(a2 + 176);
        unsigned int v20 = *(_DWORD *)(a2 + 164);
        unsigned int v7 = v11;
        goto LABEL_113;
      default:
        __assert_rtn("parse_header_data", "lsqpack.c", 3826, "0");
    }
  }
}

uint64_t header_out_dynamic_entry(unsigned int *a1, uint64_t a2, int a3)
{
  unsigned int v5 = a1[5];
  if (v5) {
    unsigned int v5 = (2 * v5 - a3 + a1[8]) % (2 * v5);
  }
  unsigned int v6 = a1[14];
  if (!v6) {
    return 0xFFFFFFFFLL;
  }
  unsigned int v7 = a1[15];
  unsigned int v8 = a1[16];
  BOOL v9 = v7 >= v8;
  unsigned int v10 = v7 - v8;
  unsigned int v11 = v9 ? 0 : a1[14];
  if (v10 + v11 <= v5) {
    return 0xFFFFFFFFLL;
  }
  int v12 = *(unsigned int **)(*((void *)a1 + 9) + 8 * ((v6 + ~v5 + v7) % v6));
  if (!v12) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v13 = 4 * (*a1 & 1);
  uint64_t v14 = (*(uint64_t (**)(void, void, uint64_t))(*((void *)a1 + 5) + 8))(*(void *)(a2 + 32), 0, v12[1] + *v12 + v13);
  if (!v14) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v15 = v14;
  qdec_maybe_update_entry_hashes(*a1, v12);
  unsigned int v16 = v12[6];
  if ((v16 & 1) == 0)
  {
    if ((v16 & 2) == 0) {
      goto LABEL_12;
    }
LABEL_23:
    *(unsigned char *)(v15 + 33) |= 0x10u;
    *(_DWORD *)(v15 + 12) = v12[4];
    if ((v12[6] & 4) == 0) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  *(unsigned char *)(v15 + 33) |= 8u;
  *(_DWORD *)(v15 + _Block_object_dispose(&a9, 8) = v12[3];
  unsigned int v16 = v12[6];
  if ((v16 & 2) != 0) {
    goto LABEL_23;
  }
LABEL_12:
  if ((v16 & 4) != 0)
  {
LABEL_13:
    *(unsigned char *)(v15 + 33) |= 2u;
    *(unsigned char *)(v15 + 3nw_tcp_options_set_enable_fast_open(options, 1) = v12[5];
  }
LABEL_14:
  *(unsigned char *)(v15 + 35) = v13;
  size_t v17 = *v12;
  unsigned int v18 = v12[1];
  *(_WORD *)(v15 + 24) = v17;
  *(_WORD *)(v15 + 26) = v18;
  uint64_t v19 = (char *)(*(void *)v15 + *(int *)(v15 + 16));
  memcpy(v19, v12 + 7, v17);
  uint64_t v20 = *v12;
  char v21 = &v19[v20];
  if (v13)
  {
    *(_WORD *)char v21 = 8250;
    v21 += 2;
    uint64_t v20 = *v12;
  }
  *(_DWORD *)(v15 + 20) = (unsigned __int16)((_WORD)v21 - *(_DWORD *)v15);
  memcpy(v21, (char *)v12 + v20 + 28, v12[1]);
  if (v13) {
    *(_WORD *)&v21[v12[1]] = 2573;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(*((void *)a1 + 5) + 16))(*(void *)(a2 + 32), v15);
  if (!result) {
    a1[7] += v12[1] + *v12;
  }
  return result;
}

uint64_t header_out_begin_dynamic_nameref(unsigned int *a1, void *a2, unsigned int *a3, int a4)
{
  if (a2[10]) {
    __assert_rtn("header_out_begin_dynamic_nameref", "lsqpack.c", 3131, "!read_ctx->hbrc_out.xhdr");
  }
  uint64_t v8 = 4 * (*a1 & 1);
  uint64_t v9 = (*(uint64_t (**)(void, void, uint64_t))(*((void *)a1 + 5) + 8))(a2[4], 0, v8 + *a3);
  a2[10] = v9;
  if (!v9) {
    return 0xFFFFFFFFLL;
  }
  uint64_t v10 = v9;
  *(unsigned char *)(v9 + 35) = v8;
  if (a4) {
    *(unsigned char *)(v9 + 33) |= 0x40u;
  }
  qdec_maybe_update_entry_hashes(*a1, a3);
  unsigned int v11 = a3[6];
  if (v11)
  {
    *(unsigned char *)(v10 + 33) |= 8u;
    *(_DWORD *)(v10 + _Block_object_dispose(&a9, 8) = a3[3];
    unsigned int v11 = a3[6];
  }
  if ((v11 & 4) != 0)
  {
    *(unsigned char *)(v10 + 33) |= 2u;
    *(unsigned char *)(v10 + 3nw_tcp_options_set_enable_fast_open(options, 1) = a3[5];
  }
  size_t v12 = *a3;
  *(_WORD *)(v10 + 24) = v12;
  uint64_t v13 = (char *)(*(void *)v10 + *(int *)(v10 + 16));
  memcpy(v13, a3 + 7, v12);
  uint64_t v14 = &v13[*a3];
  if (v8)
  {
    *(_WORD *)uint64_t v14 = 8250;
    LOWORD(v14) = (_WORD)v14 + 2;
  }
  uint64_t result = 0;
  *(_DWORD *)(v10 + 20) = (unsigned __int16)((_WORD)v14 - *(_DWORD *)v10);
  a2[11] = 1;
  return result;
}

uint64_t guarantee_out_bytes(uint64_t a1, uint64_t a2, unint64_t a3)
{
  uint64_t v4 = *(void *)(a2 + 80);
  if (!v4) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3332, "read_ctx->hbrc_out.xhdr");
  }
  if (*(_DWORD *)(a2 + 88) != 1) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3333, "read_ctx->hbrc_out.state == XOUT_VALUE");
  }
  int v6 = *(_DWORD *)(v4 + 16);
  int v5 = *(_DWORD *)(v4 + 20);
  BOOL v7 = __OFSUB__(v5, v6);
  int v8 = v5 - v6;
  if (v8 < 0 != v7) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3335, "read_ctx->hbrc_out.xhdr->val_offset >= read_ctx->hbrc_out.xhdr->name_offset");
  }
  unsigned int v9 = *(_DWORD *)(a2 + 92) + v8;
  unsigned int v10 = *(unsigned __int16 *)(v4 + 26);
  BOOL v11 = v10 >= v9;
  unint64_t v12 = v10 - v9;
  if (!v11) {
    __assert_rtn("guarantee_out_bytes", "lsqpack.c", 3339, "read_ctx->hbrc_out.xhdr->val_len >= off");
  }
  if (v12 >= a3) {
    return 0;
  }
  uint64_t v13 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 8))(*(void *)(a2 + 32));
  *(void *)(a2 + 80) = v13;
  if (v13) {
    return 0;
  }
  else {
    return 0xFFFFFFFFLL;
  }
}

uint64_t header_out_write_value(int *a1, uint64_t a2, int a3, int a4)
{
  unsigned int v4 = *(_DWORD *)(a2 + 92) + a3;
  *(_DWORD *)(a2 + 92) = v4;
  if (!a4) {
    return 0;
  }
  BOOL v7 = (void *)(a2 + 80);
  uint64_t v8 = *(void *)(a2 + 80);
  int v9 = *a1;
  if (*a1)
  {
    int v10 = *(_DWORD *)(v8 + 20);
    if (v4 + v10 + 2 > *(unsigned __int16 *)(v8 + 26))
    {
      uint64_t v11 = (*(uint64_t (**)(void, void))(*((void *)a1 + 5) + 8))(*(void *)(a2 + 32), *(void *)(a2 + 80));
      *(void *)(a2 + 80) = v11;
      if (!v11) {
        return 0xFFFFFFFFLL;
      }
      uint64_t v8 = v11;
      int v10 = *(_DWORD *)(v11 + 20);
      unsigned int v4 = *(_DWORD *)(a2 + 92);
    }
    *(_WORD *)(*(void *)v8 + v10 + v4) = 2573;
    LOWORD(v4) = *(_WORD *)(a2 + 92);
    int v9 = *a1;
  }
  *(_WORD *)(v8 + 26) = v4;
  if ((v9 & 2) != 0)
  {
    char v12 = *(unsigned char *)(v8 + 33);
    if ((v12 & 8) == 0) {
      __assert_rtn("header_out_write_value", "lsqpack.c", 3266, "xhdr->flags & LSXPACK_NAME_HASH");
    }
    *(_DWORD *)(v8 + 12) = XXH_INLINE_XXH32((int *)(*(void *)v8 + *(int *)(v8 + 20)), (unsigned __int16)v4, *(_DWORD *)(v8 + 8));
    *(unsigned char *)(v8 + 33) = v12 | 0x10;
  }
  uint64_t result = (*(uint64_t (**)(void, uint64_t))(*((void *)a1 + 5) + 16))(*(void *)(a2 + 32), v8);
  if (result) {
    uint64_t result = 0xFFFFFFFFLL;
  }
  else {
    a1[7] += *(unsigned __int16 *)(v8 + 26) + *(unsigned __int16 *)(v8 + 24);
  }
  ++*(_DWORD *)(a2 + 72);
  *BOOL v7 = 0;
  v7[1] = 0;
  return result;
}

uint64_t lsqpack_huff_decode(unsigned __int8 *a1, int a2, char *a3, uint64_t a4, _DWORD *a5, int a6)
{
  int v6 = a4;
  if (!a6 || *a5) {
    return lsqpack_huff_decode_full(a1, a2, a3, a4, (uint64_t)a5, a6);
  }
  unint64_t v7 = 0;
  unsigned int v8 = 0;
  unint64_t v9 = (unint64_t)&a1[a2];
  int v10 = &a3[(int)a4];
  uint64_t v11 = a3;
  do
  {
    while (1)
    {
LABEL_4:
      char v12 = a1 + 8;
      if ((unint64_t)(a1 + 8) <= v9)
      {
        unsigned int v16 = (64 - v8) >> 3;
        if (v16 != 7)
        {
          if (v16 != 8)
          {
LABEL_20:
            unsigned int v14 = ((64 - (_BYTE)v8) & 0x78) + v8;
            uint64_t v13 = a1 + 5;
            unint64_t v15 = (v7 << 48) | ((unint64_t)*a1 << 40) | ((unint64_t)a1[1] << 32) | ((unint64_t)a1[2] << 24) | ((unint64_t)a1[3] << 16) | ((unint64_t)a1[4] << 8);
            char v12 = a1 + 6;
            goto LABEL_21;
          }
          unsigned int v17 = *a1++;
          unint64_t v7 = v17;
        }
        unsigned int v18 = *a1++;
        unint64_t v7 = v18 | (v7 << 8);
        goto LABEL_20;
      }
      if ((unint64_t)a1 >= v9)
      {
        if (v8 >= 5)
        {
          int v42 = (v7 << (16 - v8)) & 0xFFFE | (-1 << (16 - v8)) & 0xFFFE ^ 0xFFFF;
          if (v8 <= 7 && v42 == 0xFFFF) {
            goto LABEL_91;
          }
          unsigned int v43 = &hdecs[4 * v42];
          unsigned int v44 = *v43;
          unsigned int v45 = v8 - (v44 >> 2);
          if (v8 < v44 >> 2)
          {
LABEL_92:
            uint64_t v34 = 0;
            uint64_t v35 = 3;
            return v35 | (v34 << 32);
          }
          uint64_t v46 = v44 & 3;
          uint64_t v47 = &v11[v46];
          if (v46) {
            BOOL v48 = v47 > v10;
          }
          else {
            BOOL v48 = 1;
          }
          if (v48)
          {
            if (v47 > v10) {
              goto LABEL_51;
            }
            goto LABEL_92;
          }
          char v49 = v43[1];
          char v50 = v43[2];
          if (v46 == 2)
          {
            char *v11 = v49;
            v11[1] = v50;
            LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v11 + 2;
          }
          else if (v46 == 3)
          {
            char v51 = v43[3];
            char *v11 = v49;
            v11[1] = v50;
            v11[2] = v51;
            LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v11 + 3;
          }
          else
          {
            char *v11 = v49;
            LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v11 + 1;
          }
          unsigned int v8 = v45;
        }
        if (!v8 || (~v7 & ~(-1 << v8)) == 0)
        {
LABEL_91:
          uint64_t v35 = 0;
          uint64_t v34 = (v11 - a3);
          return v35 | (v34 << 32);
        }
        goto LABEL_92;
      }
      uint64_t v13 = a1 + 1;
      unint64_t v7 = *a1 | (v7 << 8);
      if ((unint64_t)(a1 + 1) >= v9)
      {
        unsigned int v14 = v8 + 8;
        goto LABEL_27;
      }
      uint64_t v13 = a1 + 2;
      unint64_t v7 = a1[1] | (v7 << 8);
      if ((unint64_t)(a1 + 2) >= v9)
      {
        unsigned int v14 = v8 + 16;
        goto LABEL_27;
      }
      uint64_t v13 = a1 + 3;
      unint64_t v7 = a1[2] | (v7 << 8);
      if ((unint64_t)(a1 + 3) >= v9)
      {
        unsigned int v14 = v8 + 24;
        goto LABEL_27;
      }
      uint64_t v13 = a1 + 4;
      unint64_t v7 = a1[3] | (v7 << 8);
      if ((unint64_t)(a1 + 4) >= v9)
      {
        unsigned int v14 = v8 + 32;
        goto LABEL_27;
      }
      uint64_t v13 = a1 + 5;
      unint64_t v7 = a1[4] | (v7 << 8);
      if ((unint64_t)(a1 + 5) >= v9)
      {
        unsigned int v14 = v8 + 40;
        goto LABEL_27;
      }
      uint64_t v13 = a1 + 6;
      unint64_t v7 = a1[5] | (v7 << 8);
      unsigned int v14 = v8 + 48;
      if ((unint64_t)(a1 + 6) < v9 && v8 <= 8)
      {
        uint64_t v13 = a1 + 7;
        unint64_t v7 = a1[6] | (v7 << 8);
        unsigned int v14 = v8 + 56;
        if ((unint64_t)(a1 + 7) < v9 && !v8)
        {
          unint64_t v15 = v7 << 8;
          unsigned int v14 = 64;
LABEL_21:
          unint64_t v7 = v15 | *v13;
          uint64_t v13 = v12;
        }
      }
LABEL_27:
      if (v10 - v11 < 12 || v14 < 0x10) {
        break;
      }
      unsigned int v8 = v14;
      do
      {
        uint64_t v19 = &hdecs[4 * (unsigned __int16)(v7 >> (v8 - 16))];
        unsigned int v20 = *v19;
        __int16 v21 = *(_WORD *)(v19 + 1);
        LOBYTE(v19) = v19[3];
        *(_WORD *)uint64_t v11 = v21;
        v11[2] = (char)v19;
        v11 += v20 & 3;
        v8 -= v20 >> 2;
        if (v20) {
          BOOL v22 = v8 > 0xF;
        }
        else {
          BOOL v22 = 0;
        }
      }
      while (v22);
      a1 = v13;
      if (v8 >= 0x10) {
        goto LABEL_60;
      }
    }
    unsigned int v8 = v14;
    a1 = v13;
  }
  while (v14 < 0x10);
  while (1)
  {
    int64_t v23 = &hdecs[4 * (unsigned __int16)(v7 >> (v14 - 16))];
    unsigned int v24 = *v23;
    int v25 = v24 & 3;
    unsigned int v26 = &v11[v24 & 3];
    if ((v24 & 3) == 0 || v26 > v10) {
      break;
    }
    char v28 = v23[1];
    char v29 = v23[2];
    if (v25 == 2)
    {
      char *v11 = v28;
      v11[1] = v29;
      v11 += 2;
    }
    else if (v25 == 3)
    {
      char v30 = v23[3];
      char *v11 = v28;
      v11[1] = v29;
      v11[2] = v30;
      v11 += 3;
    }
    else
    {
      *v11++ = v28;
    }
    v14 -= v24 >> 2;
    if (v14 <= 0xF)
    {
      unsigned int v8 = v14;
      a1 = v13;
      goto LABEL_4;
    }
  }
  unsigned int v8 = v14;
  if (v26 <= v10)
  {
LABEL_60:
    int v36 = v8 & 7;
    if ((v8 & 7) != 0 && v11 > a3)
    {
      int v37 = v11 - 1;
      do
      {
        BOOL v22 = v37 > a3;
        int v38 = *v37--;
        v8 += encode_table[2 * v38 + 1];
        int v36 = v8 & 7;
      }
      while (v22 && (v8 & 7) != 0);
      uint64_t v11 = v37 + 1;
    }
    if (v36) {
      __assert_rtn("huff_decode_fast", "lsqpack.c", 5398, "(avail_bits & 7) == 0");
    }
    int v39 = v10 - v11;
    uint64_t v40 = lsqpack_huff_decode_full(&v13[-(v8 >> 3)], v9 - (v13 - (v8 >> 3)), v11, (v10 - v11), (uint64_t)a5, 1);
    int v41 = v6 - v39;
    if ((v40 & 0xFFFFFFFD) != 0) {
      int v41 = 0;
    }
    uint64_t v34 = (v41 + HIDWORD(v40));
    uint64_t v35 = v40;
  }
  else
  {
LABEL_51:
    int v32 = v8 & 7;
    if ((v8 & 7) != 0 && v11 > a3)
    {
      --v11;
      do
      {
        BOOL v22 = v11 > a3;
        int v33 = *v11--;
        v8 += encode_table[2 * v33 + 1];
        int v32 = v8 & 7;
      }
      while (v22 && (v8 & 7) != 0);
      LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v11 + 1;
    }
    if (v32) {
      __assert_rtn("huff_decode_fast", "lsqpack.c", 5386, "(avail_bits & 7) == 0");
    }
    uint64_t v34 = (v11 - v10 + v6);
    uint64_t v35 = 2;
  }
  return v35 | (v34 << 32);
}

uint64_t header_out_grow_buf(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = (void *)(a2 + 80);
  uint64_t v3 = *(void *)(a2 + 80);
  if (!v3) {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3291, "read_ctx->hbrc_out.xhdr");
  }
  if (*(_DWORD *)(a2 + 88)) {
    unsigned int v6 = *(_DWORD *)(v3 + 20) - *(_DWORD *)(v3 + 16) + *(_DWORD *)(a2 + 92);
  }
  else {
    unsigned int v6 = *(_DWORD *)(a2 + 92);
  }
  unsigned int v7 = *(unsigned __int16 *)(v3 + 26);
  BOOL v8 = v7 >= v6;
  unsigned int v9 = v7 - v6;
  if (!v8) {
    __assert_rtn("header_out_grow_buf", "lsqpack.c", 3303, "read_ctx->hbrc_out.xhdr->val_len >= off");
  }
  if (v9 <= 2) {
    unsigned int v9 = 2;
  }
  if ((v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26) >= 0xFFFF) {
    unint64_t v10 = 0xFFFFLL;
  }
  else {
    unint64_t v10 = (v9 >> 1) + (unint64_t)*(unsigned __int16 *)(v3 + 26);
  }
  uint64_t v11 = (*(uint64_t (**)(void))(*(void *)(a1 + 40) + 8))(*(void *)(a2 + 32));
  *(void *)(a2 + 80) = v11;
  if (!v11) {
    return 0xFFFFFFFFLL;
  }
  if (v10 > *(unsigned __int16 *)(v11 + 26))
  {
    char v12 = *(FILE **)(a1 + 48);
    if (v12)
    {
      fwrite("qdec: info: ", 0xCuLL, 1uLL, v12);
      fprintf(*(FILE **)(a1 + 48), "allocated xhdr size (%zd) is smaller than requested (%zd)", *(unsigned __int16 *)(*v4 + 26), v10);
      fputc(10, *(FILE **)(a1 + 48));
    }
    *unsigned int v4 = 0;
    v4[1] = 0;
    return 0xFFFFFFFFLL;
  }
  return 0;
}

uint64_t header_out_write_name(int *a1, uint64_t a2, int a3, int a4)
{
  LODWORD(v4) = *(_DWORD *)(a2 + 92) + a3;
  *(_DWORD *)(a2 + 92) = v4;
  if (!a4) {
    return 0;
  }
  uint64_t v7 = *(void *)(a2 + 80);
  int v8 = *a1;
  if ((*a1 & 1) == 0)
  {
    int v9 = *(_DWORD *)(v7 + 16);
    *(_DWORD *)(v7 + 20) = (unsigned __int16)(v9 + v4);
    goto LABEL_8;
  }
  if ((int)v4 + 2 <= *(unsigned __int16 *)(v7 + 26))
  {
LABEL_7:
    *(_WORD *)(*(void *)v7 + *(int *)(v7 + 16) + v4) = 8250;
    int v9 = *(_DWORD *)(v7 + 16);
    LODWORD(v4) = *(_DWORD *)(a2 + 92);
    *(_DWORD *)(v7 + 20) = (unsigned __int16)(v9 + v4 + 2);
    int v8 = *a1;
LABEL_8:
    *(_WORD *)(v7 + 24) = v4;
    *(void *)(a2 + 8_Block_object_dispose(&a9, 8) = 1;
    if ((v8 & 6) != 0)
    {
      if (!*(void *)v7)
      {
        unsigned int v22 = 414139866;
LABEL_21:
        uint64_t result = 0;
        unsigned int v28 = (-2048144777 * (v22 ^ (v22 >> 15))) ^ ((-2048144777 * (v22 ^ (v22 >> 15))) >> 13);
        *(_DWORD *)(v7 + _Block_object_dispose(&a9, 8) = (-1028477379 * v28) ^ ((-1028477379 * v28) >> 16);
        *(unsigned char *)(v7 + 33) |= 8u;
        return result;
      }
      uint64_t v11 = (int *)(*(void *)v7 + v9);
      unint64_t v4 = (unsigned __int16)v4;
      if ((unsigned __int16)v4 < 0x10u)
      {
        unsigned int v22 = (unsigned __int16)v4 + 414139866;
        if ((unsigned __int16)v4 < 4uLL) {
          goto LABEL_19;
        }
      }
      else
      {
        unint64_t v12 = (unint64_t)v11 + (unsigned __int16)v4 - 15;
        int v13 = 1679910008;
        int v14 = 39378473;
        int v15 = -2008766304;
        int v16 = 645669457;
        do
        {
          HIDWORD(v17) = v16 - 2048144777 * *v11;
          LODWORD(v17) = HIDWORD(v17);
          int v16 = -1640531535 * (v17 >> 19);
          HIDWORD(v17) = v15 - 2048144777 * v11[1];
          LODWORD(v17) = HIDWORD(v17);
          int v15 = -1640531535 * (v17 >> 19);
          HIDWORD(v17) = v14 - 2048144777 * v11[2];
          LODWORD(v17) = HIDWORD(v17);
          int v14 = -1640531535 * (v17 >> 19);
          HIDWORD(v17) = v13 - 2048144777 * v11[3];
          LODWORD(v17) = HIDWORD(v17);
          int v13 = -1640531535 * (v17 >> 19);
          v11 += 4;
        }
        while ((unint64_t)v11 < v12);
        HIDWORD(v19) = v16;
        LODWORD(v19) = v16;
        int v18 = v19 >> 31;
        HIDWORD(v19) = v15;
        LODWORD(v19) = v15;
        int v20 = v19 >> 25;
        HIDWORD(v19) = v14;
        LODWORD(v19) = v14;
        int v21 = v19 >> 20;
        HIDWORD(v19) = v13;
        LODWORD(v19) = v13;
        unsigned int v22 = v18 + (unsigned __int16)v4 + v20 + v21 + (v19 >> 14);
        v4 &= 0xFu;
        if (v4 < 4)
        {
LABEL_19:
          while (v4)
          {
            int v26 = *(unsigned __int8 *)v11;
            uint64_t v11 = (int *)((char *)v11 + 1);
            HIDWORD(v27) = v22 + 374761393 * v26;
            LODWORD(v27) = HIDWORD(v27);
            unsigned int v22 = -1640531535 * (v27 >> 21);
            --v4;
          }
          goto LABEL_21;
        }
      }
      do
      {
        int v24 = *v11++;
        HIDWORD(v25) = v22 - 1028477379 * v24;
        LODWORD(v25) = HIDWORD(v25);
        unsigned int v22 = 668265263 * (v25 >> 15);
        v4 -= 4;
      }
      while (v4 > 3);
      goto LABEL_19;
    }
    return 0;
  }
  uint64_t v10 = (*(uint64_t (**)(void))(*((void *)a1 + 5) + 8))(*(void *)(a2 + 32));
  *(void *)(a2 + 80) = v10;
  if (v10)
  {
    uint64_t v7 = v10;
    LODWORD(v4) = *(_DWORD *)(a2 + 92);
    goto LABEL_7;
  }
  return 0xFFFFFFFFLL;
}

uint64_t qdec_maybe_update_entry_hashes(uint64_t result, unsigned int *a2)
{
  if ((result & 6) != 0)
  {
    unsigned int v3 = a2[6];
    if ((v3 & 1) == 0)
    {
      a2[6] = v3 | 1;
      unint64_t v4 = (int *)(a2 + 7);
      unint64_t v5 = *a2;
      if (v5 < 0x10)
      {
        unsigned int v16 = v5 + 414139866;
      }
      else
      {
        unint64_t v6 = (unint64_t)v4 + v5 - 15;
        int v7 = 1679910008;
        int v8 = 39378473;
        int v9 = -2008766304;
        int v10 = 645669457;
        do
        {
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v10 - 2048144777 * *v4;
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v10 = -1640531535 * (v11 >> 19);
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v9 - 2048144777 * v4[1];
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v9 = -1640531535 * (v11 >> 19);
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v8 - 2048144777 * v4[2];
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v8 = -1640531535 * (v11 >> 19);
          HIDWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = v7 - 2048144777 * v4[3];
          LODWORD(v1nw_tcp_options_set_enable_fast_open(options, 1) = HIDWORD(v11);
          int v7 = -1640531535 * (v11 >> 19);
          v4 += 4;
        }
        while ((unint64_t)v4 < v6);
        HIDWORD(v13) = v10;
        LODWORD(v13) = v10;
        int v12 = v13 >> 31;
        HIDWORD(v13) = v9;
        LODWORD(v13) = v9;
        int v14 = v13 >> 25;
        HIDWORD(v13) = v8;
        LODWORD(v13) = v8;
        int v15 = v13 >> 20;
        HIDWORD(v13) = v7;
        LODWORD(v13) = v7;
        unsigned int v16 = v12 + v5 + v14 + v15 + (v13 >> 14);
        v5 &= 0xFu;
      }
      if (v5 >= 4)
      {
        do
        {
          int v17 = *v4++;
          HIDWORD(v1_Block_object_dispose(&a9, 8) = v16 - 1028477379 * v17;
          LODWORD(v1_Block_object_dispose(&a9, 8) = HIDWORD(v18);
          unsigned int v16 = 668265263 * (v18 >> 15);
          v5 -= 4;
        }
        while (v5 > 3);
      }
      for (; v5; --v5)
      {
        int v19 = *(unsigned __int8 *)v4;
        unint64_t v4 = (int *)((char *)v4 + 1);
        HIDWORD(v20) = v16 + 374761393 * v19;
        LODWORD(v20) = HIDWORD(v20);
        unsigned int v16 = -1640531535 * (v20 >> 21);
      }
      unsigned int v21 = -1028477379 * ((-2048144777 * (v16 ^ (v16 >> 15))) ^ ((-2048144777 * (v16 ^ (v16 >> 15))) >> 13));
      a2[3] = v21 ^ HIWORD(v21);
    }
  }
  if ((result & 4) != 0)
  {
    unsigned int v22 = a2[6];
    if ((v22 & 2) == 0)
    {
      if ((v22 & 1) == 0) {
        __assert_rtn("qdec_maybe_update_entry_hashes", "lsqpack.c", 2964, "entry->dte_flags & DTEF_NAME_HASH");
      }
      a2[6] = v22 | 2;
      uint64_t result = XXH_INLINE_XXH32((int *)((char *)a2 + *a2 + 28), a2[1], a2[3]);
      a2[4] = result;
    }
  }
  return result;
}

uint64_t lsqpack_dec_push_entry(uint64_t a1, const char *a2)
{
  unsigned int v4 = *(_DWORD *)(a1 + 56);
  if (v4)
  {
    if ((*(_DWORD *)(a1 + 60) + 1) % v4 != *(_DWORD *)(a1 + 64))
    {
      unint64_t v6 = *(void **)(a1 + 72);
      goto LABEL_12;
    }
    unint64_t v5 = malloc_type_malloc(16 * v4, 0x80040B8603338uLL);
    if (v5)
    {
      unint64_t v6 = v5;
      uint64_t v7 = *(unsigned int *)(a1 + 60);
      uint64_t v8 = *(unsigned int *)(a1 + 64);
      if (v7 >= v8)
      {
        int v11 = v7 - v8;
        memcpy(v5, (const void *)(*(void *)(a1 + 72) + 8 * v8), 8 * (v7 - v8 + 1));
        int v9 = 0;
        *(_DWORD *)(a1 + 60) = v11;
      }
      else
      {
        memcpy(v5, *(const void **)(a1 + 72), 8 * v7 + 8);
        memcpy(&v6[*(unsigned int *)(a1 + 56) + *(unsigned int *)(a1 + 64)], (const void *)(*(void *)(a1 + 72) + 8 * *(unsigned int *)(a1 + 64)), 8 * (*(_DWORD *)(a1 + 56) - *(_DWORD *)(a1 + 64)));
        int v9 = *(_DWORD *)(a1 + 64) + *(_DWORD *)(a1 + 56);
      }
      *(_DWORD *)(a1 + 64) = v9;
      free(*(void **)(a1 + 72));
      *(void *)(a1 + 72) = v6;
      unsigned int v4 = 2 * *(_DWORD *)(a1 + 56);
      goto LABEL_11;
    }
    return 0xFFFFFFFFLL;
  }
  int v10 = malloc_type_malloc(0x20uLL, 0x80040B8603338uLL);
  *(void *)(a1 + 72) = v10;
  if (!v10) {
    return 0xFFFFFFFFLL;
  }
  unint64_t v6 = v10;
  unsigned int v4 = 4;
LABEL_11:
  *(_DWORD *)(a1 + 56) = v4;
LABEL_12:
  uint64_t v12 = *(unsigned int *)(a1 + 60);
  v6[v12] = a2;
  *(_DWORD *)(a1 + 60) = ((int)v12 + 1) % v4;
  *(_DWORD *)(a1 + 12) += *(_DWORD *)a2 + *((_DWORD *)a2 + 1) + 32;
  unint64_t v13 = *(FILE **)(a1 + 48);
  if (v13)
  {
    fwrite("qdec: debug: ", 0xDuLL, 1uLL, v13);
    fputc(10, *(FILE **)(a1 + 48));
  }
  unsigned int v14 = *(_DWORD *)(a1 + 20);
  if (v14) {
    unsigned int v14 = (*(_DWORD *)(a1 + 32) + 1) % (2 * v14);
  }
  *(_DWORD *)(a1 + 32) = v14;
  qdec_remove_overflow_entries(a1);
  uint64_t v15 = a1 + 16 * (*(_DWORD *)(a1 + 32) & 7);
  uint64_t v16 = *(void *)(v15 + 96);
  if (v16)
  {
    int v17 = (void *)(v15 + 104);
    do
    {
      uint64_t v18 = *(void *)(v16 + 16);
      if (*(_DWORD *)(v16 + 64) == *(_DWORD *)(a1 + 32))
      {
        *(_DWORD *)(v16 + 104) &= ~4u;
        int v19 = (void *)(v18 + 24);
        if (!v18) {
          int v19 = v17;
        }
        void *v19 = *(void *)(v16 + 24);
        **(void **)(v16 + 24) = v18;
        --*(_DWORD *)(a1 + 224);
        unint64_t v20 = *(FILE **)(a1 + 48);
        if (v20)
        {
          fwrite("qdec: debug: ", 0xDuLL, 1uLL, v20);
          fprintf(*(FILE **)(a1 + 48), "header block for stream %llu has become unblocked", *(void *)(v16 + 40));
          fputc(10, *(FILE **)(a1 + 48));
        }
        (**(void (***)(void))(a1 + 40))(*(void *)(v16 + 32));
      }
      uint64_t v16 = v18;
    }
    while (v18);
  }
  if (*(_DWORD *)(a1 + 12) > *(_DWORD *)(a1 + 8)) {
    return 0xFFFFFFFFLL;
  }
  return 0;
}

void qdec_remove_overflow_entries(uint64_t a1)
{
  unsigned int v1 = *(_DWORD *)(a1 + 12);
  while (v1 > *(_DWORD *)(a1 + 8))
  {
    unsigned int v3 = *(FILE **)(a1 + 48);
    if (v3)
    {
      fwrite("qdec: debug: ", 0xDuLL, 1uLL, v3);
      fprintf(*(FILE **)(a1 + 48), "capacity %u, drop entry", *(_DWORD *)(a1 + 12));
      fputc(10, *(FILE **)(a1 + 48));
      unsigned int v1 = *(_DWORD *)(a1 + 12);
    }
    uint64_t v4 = *(unsigned int *)(a1 + 64);
    unint64_t v5 = *(_DWORD **)(*(void *)(a1 + 72) + 8 * v4);
    *(_DWORD *)(a1 + 64) = (v4 + 1) % *(_DWORD *)(a1 + 56);
    unsigned int v1 = v1 - (*v5 + v5[1]) - 32;
    *(_DWORD *)(a1 + 12) = v1;
    int v6 = v5[2] - 1;
    v5[2] = v6;
    if (!v6)
    {
      free(v5);
      unsigned int v1 = *(_DWORD *)(a1 + 12);
    }
  }
}

void sub_183A8F974(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A8FA9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A8FB30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_create_with_cfurl(const __CFURL *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = [NWConcrete_nw_url_endpoint alloc];
    return -[NWConcrete_nw_url_endpoint initWithURL:](v2, a1);
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  unsigned int v14 = "nw_endpoint_create_with_cfurl";
  unint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v14 = "nw_endpoint_create_with_cfurl";
        uint64_t v8 = "%{public}s called with null url";
LABEL_18:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)long long buf = 136446466;
            unsigned int v14 = "nw_endpoint_create_with_cfurl";
            __int16 v15 = 2082;
            uint64_t v16 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null url, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (!v10) {
          goto LABEL_19;
        }
        *(_DWORD *)long long buf = 136446210;
        unsigned int v14 = "nw_endpoint_create_with_cfurl";
        uint64_t v8 = "%{public}s called with null url, no backtrace";
        goto LABEL_18;
      }
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned int v14 = "nw_endpoint_create_with_cfurl";
        uint64_t v8 = "%{public}s called with null url, backtrace limit exceeded";
        goto LABEL_18;
      }
    }
LABEL_19:
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  return 0;
}

uint64_t nw_endpoint_get_url_port(void *a1, char a2)
{
  *(void *)&v43[13] = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    char v29 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v41 = "nw_endpoint_get_url_port";
    char v30 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v30, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v41 = "nw_endpoint_get_url_port";
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v34 = type;
        BOOL v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)long long buf = 136446466;
            int v41 = "nw_endpoint_get_url_port";
            __int16 v42 = 2082;
            *(void *)unsigned int v43 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_46;
        }
        if (v35)
        {
          *(_DWORD *)long long buf = 136446210;
          int v41 = "nw_endpoint_get_url_port";
          _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unsigned int v31 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v41 = "nw_endpoint_get_url_port";
          _os_log_impl(&dword_1830D4000, v31, v36, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_46:
    if (!v30) {
      goto LABEL_28;
    }
    unint64_t v27 = (char *)v30;
    goto LABEL_27;
  }
  id v5 = v3;
  int v6 = [v5 type];

  if (v6 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    id v10 = v5;
    int v11 = [v10 type];

    *(_DWORD *)long long buf = 136446466;
    int v41 = "nw_endpoint_get_url_port";
    __int16 v42 = 1024;
    *(_DWORD *)unsigned int v43 = v11;
    LODWORD(v37) = 18;
    uint64_t v12 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v12, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v13 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          id v15 = v10;
          int v16 = objc_msgSend(v15, "type", buf, v37);

          *(_DWORD *)long long buf = 136446466;
          int v41 = "nw_endpoint_get_url_port";
          __int16 v42 = 1024;
          *(_DWORD *)unsigned int v43 = v16;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v38)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v13 = (id)gLogObj;
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v13, type);
        if (v17)
        {
          if (v19)
          {
            id v20 = v10;
            int v21 = objc_msgSend(v20, "type", buf, v37);

            *(_DWORD *)long long buf = 136446722;
            int v41 = "nw_endpoint_get_url_port";
            __int16 v42 = 1024;
            *(_DWORD *)unsigned int v43 = v21;
            v43[2] = 2082;
            *(void *)&v43[3] = v17;
            _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v17);
          if (!v12) {
            goto LABEL_28;
          }
LABEL_26:
          unint64_t v27 = (char *)v12;
LABEL_27:
          free(v27);
          goto LABEL_28;
        }
        if (v19)
        {
          id v25 = v10;
          int v26 = objc_msgSend(v25, "type", buf, v37);

          *(_DWORD *)long long buf = 136446466;
          int v41 = "nw_endpoint_get_url_port";
          __int16 v42 = 1024;
          *(_DWORD *)unsigned int v43 = v26;
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v13 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          id v23 = v10;
          int v24 = objc_msgSend(v23, "type", buf, v37);

          *(_DWORD *)long long buf = 136446466;
          int v41 = "nw_endpoint_get_url_port";
          __int16 v42 = 1024;
          *(_DWORD *)unsigned int v43 = v24;
          _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v12)
    {
LABEL_28:
      uint64_t v8 = 0;
      goto LABEL_29;
    }
    goto LABEL_26;
  }
  os_log_type_t v7 = v5;
  if (a2 & 1) == 0 && (v7[297]) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = bswap32(*((unsigned __int16 *)v7 + 120)) >> 16;
  }

LABEL_29:
  return v8;
}

void sub_183A90408(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_url_path(void *a1)
{
  *(void *)&v43[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    unint64_t v27 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v41 = "nw_endpoint_get_url_path";
    unsigned int v28 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v28, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v29 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v41 = "nw_endpoint_get_url_path";
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v29 = __nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v33 = os_log_type_enabled(v29, type);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)long long buf = 136446466;
            int v41 = "nw_endpoint_get_url_path";
            __int16 v42 = 2082;
            *(void *)unsigned int v43 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v33)
        {
          *(_DWORD *)long long buf = 136446210;
          int v41 = "nw_endpoint_get_url_path";
          _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v29 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v41 = "nw_endpoint_get_url_path";
          _os_log_impl(&dword_1830D4000, v29, v34, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v28) {
      goto LABEL_12;
    }
    id v15 = (char *)v28;
    goto LABEL_11;
  }
  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    id v8 = v3;
    int v9 = [v8 type];

    *(_DWORD *)long long buf = 136446466;
    int v41 = "nw_endpoint_get_url_path";
    __int16 v42 = 1024;
    *(_DWORD *)unsigned int v43 = v9;
    LODWORD(v35) = 18;
    id v10 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v10, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          id v13 = v8;
          int v14 = objc_msgSend(v13, "type", buf, v35);

          *(_DWORD *)long long buf = 136446466;
          int v41 = "nw_endpoint_get_url_path";
          __int16 v42 = 1024;
          *(_DWORD *)unsigned int v43 = v14;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v38)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (id)gLogObj;
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v11, type);
        if (v17)
        {
          if (v19)
          {
            id v20 = v8;
            int v21 = objc_msgSend(v20, "type", buf, v35);

            *(_DWORD *)long long buf = 136446722;
            int v41 = "nw_endpoint_get_url_path";
            __int16 v42 = 1024;
            *(_DWORD *)unsigned int v43 = v21;
            v43[2] = 2082;
            *(void *)&v43[3] = v17;
            _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v17);
          if (!v10) {
            goto LABEL_12;
          }
LABEL_10:
          id v15 = (char *)v10;
LABEL_11:
          free(v15);
          goto LABEL_12;
        }
        if (v19)
        {
          id v25 = v8;
          int v26 = objc_msgSend(v25, "type", buf, v35);

          *(_DWORD *)long long buf = 136446466;
          int v41 = "nw_endpoint_get_url_path";
          __int16 v42 = 1024;
          *(_DWORD *)unsigned int v43 = v26;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v11 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v11, type))
        {
          id v23 = v8;
          int v24 = objc_msgSend(v23, "type", buf, v35);

          *(_DWORD *)long long buf = 136446466;
          int v41 = "nw_endpoint_get_url_path";
          __int16 v42 = 1024;
          *(_DWORD *)unsigned int v43 = v24;
          _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v10)
    {
LABEL_12:
      uint64_t v6 = 0;
      goto LABEL_13;
    }
    goto LABEL_10;
  }
  id v5 = v3;
  v36[0] = MEMORY[0x1E4F143A8];
  v36[1] = 3221225472;
  v36[2] = __nw_endpoint_get_url_path_block_invoke;
  v36[3] = &unk_1E524BAA8;
  id v37 = v5;
  nw_endpoint_locked(v5, v36);
  uint64_t v6 = v5[34];

LABEL_13:
  return v6;
}

void sub_183A90AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_get_url_path_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if (!*(void *)(v1 + 272))
  {
    CFStringRef v3 = CFURLCopyPath(*(CFURLRef *)(v1 + 232));
    if (v3)
    {
      CFStringRef v4 = v3;
      if (CFStringGetLength(v3) >= 1) {
        *(void *)(*(void *)(a1 + 32) + 272) = nw_utilities_create_c_string_from_cfstring(v4);
      }
      CFRelease(v4);
    }
  }
}

CFTypeRef nw_endpoint_copy_cfurl(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    int v26 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v38 = "nw_endpoint_copy_cfurl";
    unint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v38 = "nw_endpoint_copy_cfurl";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)long long buf = 136446466;
            char v38 = "nw_endpoint_copy_cfurl";
            __int16 v39 = 2082;
            *(void *)uint64_t v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)long long buf = 136446210;
          char v38 = "nw_endpoint_copy_cfurl";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unsigned int v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v38 = "nw_endpoint_copy_cfurl";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v27) {
      goto LABEL_24;
    }
    int v24 = (char *)v27;
    goto LABEL_23;
  }
  CFStringRef v3 = (CFTypeRef *)v1;
  int v4 = [(CFTypeRef *)v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    id v7 = v3;
    int v8 = [(CFTypeRef *)v7 type];

    *(_DWORD *)long long buf = 136446466;
    char v38 = "nw_endpoint_copy_cfurl";
    __int16 v39 = 1024;
    *(_DWORD *)uint64_t v40 = v8;
    LODWORD(v34) = 18;
    int v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          os_log_type_t v12 = v7;
          int v13 = [(CFTypeRef *)v12 type];

          *(_DWORD *)long long buf = 136446466;
          char v38 = "nw_endpoint_copy_cfurl";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v13;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        int v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            uint64_t v17 = v7;
            int v18 = [(CFTypeRef *)v17 type];

            *(_DWORD *)long long buf = 136446722;
            char v38 = "nw_endpoint_copy_cfurl";
            __int16 v39 = 1024;
            *(_DWORD *)uint64_t v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          int v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          os_log_type_t v22 = v7;
          int v23 = [(CFTypeRef *)v22 type];

          *(_DWORD *)long long buf = 136446466;
          char v38 = "nw_endpoint_copy_cfurl";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v23;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          id v20 = v7;
          int v21 = [(CFTypeRef *)v20 type];

          *(_DWORD *)long long buf = 136446466;
          char v38 = "nw_endpoint_copy_cfurl";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v21;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v9)
    {
LABEL_24:
      CFTypeRef v5 = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  CFTypeRef v5 = CFRetain(v3[29]);
LABEL_25:

  return v5;
}

void sub_183A911A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t countOfBytesExpectedToReceive(void *a1)
{
  id v1 = a1;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    && ([v1 valueForHTTPHeaderField:@"Content-Encoding"],
        (uint64_t v2 = objc_claimAutoreleasedReturnValue()) != 0)
    && (CFStringRef v3 = v2, v4 = [v2 caseInsensitiveCompare:@"identity"], v3, v4))
  {
    uint64_t v5 = *MEMORY[0x1E4F18D08];
  }
  else
  {
    uint64_t v5 = [v1 expectedContentLength];
  }

  return v5;
}

BOOL nw_ws_allocate_options(void *a1)
{
  id v1 = a1;
  uint64_t v2 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  uint64_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    v2[8] = 0;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)uint64_t v2 = 0u;
    *((_OWORD *)v2 + nw_tcp_options_set_enable_fast_open(options, 1) = 0u;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183A9344C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_options_t nw_ws_create_options(nw_ws_version_t version)
{
  if (nw_protocol_copy_ws_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3583);
  }
  id v2 = (id)nw_protocol_copy_ws_definition::definition;
  options = nw_protocol_create_options(v2);

  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __nw_ws_create_options_block_invoke;
  v5[3] = &__block_descriptor_36_e9_B16__0_v8l;
  nw_ws_version_t v6 = version;
  nw_protocol_options_access_handle(options, v5);
  return &options->super;
}

void sub_183A9352C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183A9353C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_create_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 56) = *(_DWORD *)(a1 + 32);
  xpc_object_t v3 = xpc_array_create(0, 0);
  uint64_t v4 = *(void **)a2;
  *(void *)a2 = v3;

  xpc_object_t v5 = xpc_array_create(0, 0);
  nw_ws_version_t v6 = *(void **)(a2 + 8);
  *(void *)(a2 + _Block_object_dispose(&a9, 8) = v5;

  xpc_object_t v7 = xpc_array_create(0, 0);
  int v8 = *(void **)(a2 + 16);
  *(void *)(a2 + 16) = v7;

  *(unsigned char *)(a2 + 70) = *(unsigned char *)(a2 + 70) & 0xC7 | 0x30;
  *(_WORD *)(a2 + 6_Block_object_dispose(&a9, 8) = 3855;
  *(void *)(a2 + 60) = 0x100000001000;
  return 1;
}

BOOL nw_ws_copy_options(void *a1, uint64_t a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    int v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v26 = "nw_ws_copy_options";
    int v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v14, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v26 = "nw_ws_copy_options";
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)long long buf = 136446466;
            int v26 = "nw_ws_copy_options";
            __int16 v27 = 2082;
            uint64_t v28 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v21)
        {
          *(_DWORD *)long long buf = 136446210;
          int v26 = "nw_ws_copy_options";
          _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v26 = "nw_ws_copy_options";
          _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v14) {
      free(v14);
    }
    uint64_t v4 = 0;
    goto LABEL_4;
  }
  uint64_t v4 = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    *((void *)v4 + _Block_object_dispose(&a9, 8) = 0;
    *((_OWORD *)v4 + 2) = 0u;
    *((_OWORD *)v4 + 3) = 0u;
    *(_OWORD *)uint64_t v4 = 0u;
    *((_OWORD *)v4 + nw_tcp_options_set_enable_fast_open(options, 1) = 0u;
    objc_storeStrong((id *)v4, *(id *)a2);
    objc_storeStrong((id *)v4 + 1, *(id *)(a2 + 8));
    objc_storeStrong((id *)v4 + 2, *(id *)(a2 + 16));
    xpc_object_t v5 = _Block_copy(*(const void **)(a2 + 40));
    nw_ws_version_t v6 = (void *)*((void *)v4 + 5);
    *((void *)v4 + 5) = v5;

    objc_storeStrong((id *)v4 + 6, *(id *)(a2 + 48));
    char v7 = v4[70];
    *((_DWORD *)v4 + 14) = *(_DWORD *)(a2 + 56);
    v4[70] = v7 & 0xFE | *(unsigned char *)(a2 + 70) & 1;
    *((void *)v4 + 4) = *(void *)(a2 + 32);
    objc_storeStrong((id *)v4 + 3, *(id *)(a2 + 24));
    int v8 = v4[70] & 0xFD | (2 * ((*(unsigned __int8 *)(a2 + 70) >> 1) & 1));
    v4[70] = v8;
    unsigned int v9 = v8 & 0xFFFFFFFB | (4 * ((*(unsigned __int8 *)(a2 + 70) >> 2) & 1));
    v4[70] = v9;
    unsigned int v10 = v9 & 0xFFFFFFF7 | (8 * ((*(unsigned __int8 *)(a2 + 70) >> 3) & 1));
    v4[70] = v10;
    unsigned int v11 = v10 & 0xFFFFFFEF | (16 * ((*(unsigned __int8 *)(a2 + 70) >> 4) & 1));
    v4[70] = v11;
    v4[70] = v11 & 0xDF | *(unsigned char *)(a2 + 70) & 0x20;
    *((_WORD *)v4 + 34) = *(_WORD *)(a2 + 68);
    *(void *)(v4 + 60) = *(void *)(a2 + 60);
LABEL_4:

    return (BOOL)v4;
  }
  uint64_t v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446722;
  int v26 = "strict_calloc";
  __int16 v27 = 2048;
  uint64_t v28 = 1;
  __int16 v29 = 2048;
  uint64_t v30 = 72;
  int v18 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v18);
  if (!result)
  {
    free(v18);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_183A93A34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_deallocate_options(uint64_t a1, id *a2)
{
  id v3 = *a2;
  *a2 = 0;

  id v4 = a2[1];
  a2[1] = 0;

  id v5 = a2[2];
  a2[2] = 0;

  id v6 = a2[5];
  a2[5] = 0;

  id v7 = a2[6];
  a2[6] = 0;

  free(a2);
}

BOOL nw_ws_option_is_equal(void *a1, uint64_t a2, uint64_t a3)
{
  id v5 = a1;
  size_t count = xpc_array_get_count(*(xpc_object_t *)(a2 + 8));
  size_t v7 = xpc_array_get_count(*(xpc_object_t *)(a3 + 8));
  size_t v8 = xpc_array_get_count(*(xpc_object_t *)(a2 + 8));
  size_t v9 = v8;
  if (count != v7 || v8 == 0)
  {
    if (count != v7) {
      goto LABEL_35;
    }
LABEL_22:
    if (nw_unordered_xpc_array_is_equal(*(xpc_object_t *)a2, *(xpc_object_t *)a3)
      && *(void *)(a2 + 40) == *(void *)(a3 + 40)
      && *(void *)(a2 + 48) == *(void *)(a3 + 48)
      && *(_DWORD *)(a2 + 56) == *(_DWORD *)(a3 + 56)
      && ((*(unsigned char *)(a3 + 70) ^ *(unsigned char *)(a2 + 70)) & 1) == 0
      && *(void *)(a2 + 32) == *(void *)(a3 + 32))
    {
      BOOL v20 = 0;
      if (((*(unsigned char *)(a3 + 70) ^ *(unsigned char *)(a2 + 70)) & 0x3E) == 0 && *(void *)(a2 + 24) == *(void *)(a3 + 24))
      {
        if (*(unsigned __int8 *)(a2 + 68) != *(unsigned __int8 *)(a3 + 68)
          || *(unsigned __int8 *)(a2 + 69) != *(unsigned __int8 *)(a3 + 69)
          || *(_DWORD *)(a2 + 60) != *(_DWORD *)(a3 + 60))
        {
          goto LABEL_35;
        }
        BOOL v20 = *(_DWORD *)(a2 + 64) == *(_DWORD *)(a3 + 64);
      }
    }
    else
    {
LABEL_35:
      BOOL v20 = 0;
    }

    return v20;
  }
  else
  {
    id v24 = v5;
    unsigned int v11 = malloc_type_calloc(1uLL, v8, 0xEAFB8F1AuLL);
    os_log_type_t v12 = v11;
    if (v11) {
      goto LABEL_9;
    }
    os_log_type_t v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    char v23 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v23);
    if (!result)
    {
      free(v23);
LABEL_9:
      size_t v13 = 0;
      while (1)
      {
        int v14 = xpc_array_get_value(*(xpc_object_t *)(a2 + 8), v13);
        os_log_type_t v15 = xpc_array_get_value(*(xpc_object_t *)(a2 + 16), v13);
        size_t v16 = 0;
        while (v12[v16])
        {
LABEL_11:
          if (v9 == ++v16) {
            goto LABEL_17;
          }
        }
        uint64_t v17 = xpc_array_get_value(*(xpc_object_t *)(a3 + 8), v16);
        int v18 = xpc_array_get_value(*(xpc_object_t *)(a3 + 16), v16);
        if (!xpc_equal(v14, v17) || !xpc_equal(v15, v18)) {
          break;
        }
        v12[v16] = 1;

LABEL_17:
        if (++v13 == v9)
        {
          uint64_t v19 = 0;
          id v5 = v24;
          while (v12[v19])
          {
            if (v9 == ++v19)
            {
              free(v12);
              goto LABEL_22;
            }
          }
          free(v12);
          goto LABEL_35;
        }
      }

      goto LABEL_11;
    }
    __break(1u);
  }
  return result;
}

void sub_183A93E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_ws(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = (id *)v1;
    id v4 = v3[1];

    if (nw_protocol_copy_ws_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3583);
    }
    id v5 = (id)nw_protocol_copy_ws_definition::definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, (uint64_t)v5);

    goto LABEL_5;
  }
  size_t v8 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v19 = "nw_protocol_options_is_ws";
  size_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v19 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v19 = "nw_protocol_options_is_ws";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v14)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v19 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v19 = "nw_protocol_options_is_ws";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v9) {
    free(v9);
  }
  BOOL is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_183A94180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_options_add_additional_header(nw_protocol_options_t options, const char *name, const char *value)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v5 = options;
  if (!nw_protocol_options_is_ws(v5))
  {
    size_t v7 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v30 = "nw_ws_options_add_additional_header";
    size_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v8, &type, &v27)) {
      goto LABEL_63;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v30 = "nw_ws_options_add_additional_header";
          __int16 v31 = 2082;
          BOOL v32 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_63:
        if (!v8) {
          goto LABEL_13;
        }
LABEL_64:
        free(v8);
        goto LABEL_13;
      }
      if (v17)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v23, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_62:

    goto LABEL_63;
  }
  if (!name)
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v30 = "nw_ws_options_add_additional_header";
    size_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v8, &type, &v27)) {
      goto LABEL_63;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null name", buf, 0xCu);
      }
      goto LABEL_62;
    }
    if (!v27)
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null name, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_62;
    }
    int v18 = (char *)__nw_create_backtrace_string();
    size_t v9 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v20)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null name, no backtrace", buf, 0xCu);
      }
      goto LABEL_62;
    }
    if (v20)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v30 = "nw_ws_options_add_additional_header";
      __int16 v31 = 2082;
      BOOL v32 = v18;
      _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null name, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_43;
  }
  if (!value)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v30 = "nw_ws_options_add_additional_header";
    size_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v8, &type, &v27)) {
      goto LABEL_63;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null value", buf, 0xCu);
      }
      goto LABEL_62;
    }
    if (!v27)
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v25, "%{public}s called with null value, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_62;
    }
    int v18 = (char *)__nw_create_backtrace_string();
    size_t v9 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v18)
    {
      if (v22)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v30 = "nw_ws_options_add_additional_header";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null value, no backtrace", buf, 0xCu);
      }
      goto LABEL_62;
    }
    if (v22)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v30 = "nw_ws_options_add_additional_header";
      __int16 v31 = 2082;
      BOOL v32 = v18;
      _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null value, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_43:

    free(v18);
    if (!v8) {
      goto LABEL_13;
    }
    goto LABEL_64;
  }
  if (!strcasecmp(name, "Sec-WebSocket-Key")
    || !strcasecmp(name, "Sec-WebSocket-Protocol")
    || !strcasecmp(name, "Sec-WebSocket-Version")
    || !strcasecmp(name, "Upgrade")
    || !strcasecmp(name, "Connection"))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)long long buf = 136446722;
      uint64_t v30 = "nw_ws_options_add_additional_header";
      __int16 v31 = 2080;
      BOOL v32 = name;
      __int16 v33 = 2080;
      uint64_t v34 = value;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s Cannot override (%s, %s) header in the client's request", buf, 0x20u);
    }
  }
  else
  {
    v26[0] = MEMORY[0x1E4F143A8];
    v26[1] = 3221225472;
    v26[2] = __nw_ws_options_add_additional_header_block_invoke;
    v26[3] = &__block_descriptor_48_e9_B16__0_v8l;
    v26[4] = name;
    void v26[5] = value;
    nw_protocol_options_access_handle(v5, v26);
  }
LABEL_13:
}

void sub_183A94998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_add_additional_header_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = *(void **)(a2 + 8);
  xpc_object_t v5 = xpc_string_create(*(const char **)(a1 + 32));
  xpc_array_append_value(v4, v5);

  id v6 = *(void **)(a2 + 16);
  xpc_object_t v7 = xpc_string_create(*(const char **)(a1 + 40));
  xpc_array_append_value(v6, v7);

  return 1;
}

void sub_183A94A20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_maximum_message_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  return 1;
}

uint64_t __nw_ws_options_add_subprotocol_block_invoke(uint64_t a1, void **a2)
{
  id v2 = *a2;
  xpc_object_t v3 = xpc_string_create(*(const char **)(a1 + 32));
  xpc_array_append_value(v2, v3);

  return 1;
}

void sub_183A94A84(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ws_options_set_auto_reply_ping(nw_protocol_options_t options, BOOL auto_reply_ping)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  xpc_object_t v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_auto_reply_ping_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = auto_reply_ping;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v17 = "nw_ws_options_set_auto_reply_ping";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v17 = "nw_ws_options_set_auto_reply_ping";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v17 = "nw_ws_options_set_auto_reply_ping";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A94D7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_auto_reply_ping_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 70) = *(unsigned char *)(a2 + 70) & 0xFE | *(unsigned char *)(a1 + 32);
  return 1;
}

void nw_ws_options_set_skip_handshake(nw_protocol_options_t options, BOOL skip_handshake)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  xpc_object_t v3 = options;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_skip_handshake_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = skip_handshake;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v17 = "nw_ws_options_set_skip_handshake";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v17 = "nw_ws_options_set_skip_handshake";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v17 = "nw_ws_options_set_skip_handshake";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A95094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_skip_handshake_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 70) = *(unsigned char *)(a2 + 70) & 0xFD | (2 * *(unsigned char *)(a1 + 32));
  return 1;
}

void nw_ws_options_set_prepend_data(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_options_is_ws(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_ws_options_set_prepend_data_block_invoke;
    v13[3] = &unk_1E5248F68;
    id v14 = v4;
    nw_protocol_options_access_handle(v3, v13);

    goto LABEL_3;
  }
  xpc_object_t v5 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v18 = "nw_ws_options_set_prepend_data";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v18 = "nw_ws_options_set_prepend_data";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v18 = "nw_ws_options_set_prepend_data";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_183A953C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_prepend_data_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

void nw_ws_options_set_client_request_handler(nw_protocol_options_t options, dispatch_queue_t client_queue, nw_ws_client_request_handler_t handler)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  xpc_object_t v5 = options;
  id v6 = client_queue;
  nw_ws_client_request_handler_t v7 = handler;
  if (!nw_protocol_options_is_ws(v5))
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v33 = "nw_ws_options_set_client_request_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v33 = "nw_ws_options_set_client_request_handler";
          __int16 v34 = 2082;
          uint64_t v35 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v9) {
          goto LABEL_5;
        }
LABEL_56:
        free(v9);
        goto LABEL_5;
      }
      if (v18)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v24, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v6)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v33 = "nw_ws_options_set_client_request_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null client_queue", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v30)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v25, "%{public}s called with null client_queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    __int16 v19 = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v21)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v21)
    {
      *(_DWORD *)long long buf = 136446466;
      __int16 v33 = "nw_ws_options_set_client_request_handler";
      __int16 v34 = 2082;
      uint64_t v35 = v19;
      _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null client_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v7)
  {
    id v14 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v33 = "nw_ws_options_set_client_request_handler";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v9, &type, &v30)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v30)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v26, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    __int16 v19 = (char *)__nw_create_backtrace_string();
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v10, type);
    if (!v19)
    {
      if (v23)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v33 = "nw_ws_options_set_client_request_handler";
        _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)long long buf = 136446466;
      __int16 v33 = "nw_ws_options_set_client_request_handler";
      __int16 v34 = 2082;
      uint64_t v35 = v19;
      _os_log_impl(&dword_1830D4000, v10, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v19);
    if (!v9) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  v27[0] = MEMORY[0x1E4F143A8];
  v27[1] = 3221225472;
  v27[2] = __nw_ws_options_set_client_request_handler_block_invoke;
  v27[3] = &unk_1E52491D8;
  uint64_t v28 = v6;
  id v29 = v7;
  nw_protocol_options_access_handle(v5, v27);

LABEL_5:
}

void sub_183A95B60(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_client_request_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  objc_storeStrong((id *)(a2 + 48), *(id *)(a1 + 32));
  id v4 = _Block_copy(*(const void **)(a1 + 40));
  xpc_object_t v5 = *(void **)(a2 + 40);
  *(void *)(a2 + 40) = v4;

  return 1;
}

void nw_ws_options_set_permessage_deflate(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v17 = "nw_ws_options_set_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A95EC4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 70) = *(unsigned char *)(a2 + 70) & 0xF7 | (8 * *(unsigned char *)(a1 + 32));
  return 1;
}

BOOL nw_ws_options_get_permessage_deflate(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_ws(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_get_permessage_deflate_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_options_get_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183A96214(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_get_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 70) & 8) != 0;
  return 1;
}

void nw_ws_options_set_permessage_deflate_server_context_takeover(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_server_context_takeover_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_context_takeover";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A96540(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_server_context_takeover_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 70) = *(unsigned char *)(a2 + 70) & 0xEF | (16 * *(unsigned char *)(a1 + 32));
  return 1;
}

void nw_ws_options_set_permessage_deflate_server_max_window_bits(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_server_max_window_bits_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_server_max_window_bits";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A96858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_server_max_window_bits_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 6_Block_object_dispose(&a9, 8) = *(unsigned char *)(a1 + 32);
  return 1;
}

void nw_ws_options_set_permessage_deflate_client_context_takeover(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_client_context_takeover_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_context_takeover";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A96B64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_client_context_takeover_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 70) = *(unsigned char *)(a2 + 70) & 0xDF | (32 * *(unsigned char *)(a1 + 32));
  return 1;
}

void nw_ws_options_set_permessage_deflate_client_max_window_bits(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_client_max_window_bits_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_client_max_window_bits";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A96E7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_client_max_window_bits_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 69) = *(unsigned char *)(a1 + 32);
  return 1;
}

void nw_ws_options_set_permessage_deflate_incoming_buffer_size(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_incoming_buffer_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    int v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_incoming_buffer_size";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A97188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_incoming_buffer_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 60) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_ws_options_set_permessage_deflate_outgoing_buffer_size(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ws(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ws_options_set_permessage_deflate_outgoing_buffer_size_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    int v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
  xpc_object_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_options_set_permessage_deflate_outgoing_buffer_size";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A97494(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ws_options_set_permessage_deflate_outgoing_buffer_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 64) = *(_DWORD *)(a1 + 32);
  return 1;
}

BOOL nw_protocol_metadata_is_ws(nw_protocol_metadata_t metadata)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  BOOL v2 = v1;
  if (v1)
  {
    id v3 = v1;
    id v4 = v3[1];

    if (nw_protocol_copy_ws_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3583);
    }
    id v5 = (id)nw_protocol_copy_ws_definition::definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, (uint64_t)v5);

    goto LABEL_5;
  }
  os_log_type_t v8 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  __int16 v19 = "nw_protocol_metadata_is_ws";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v19 = "nw_protocol_metadata_is_ws";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v19 = "nw_protocol_metadata_is_ws";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v14)
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v19 = "nw_protocol_metadata_is_ws";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)long long buf = 136446210;
        __int16 v19 = "nw_protocol_metadata_is_ws";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v9) {
    free(v9);
  }
  BOOL is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_183A977B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_metadata_t nw_ws_create_metadata(nw_ws_opcode_t opcode)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (nw_protocol_copy_ws_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_ws_definition::onceToken, &__block_literal_global_3583);
  }
  id v2 = (id)nw_protocol_copy_ws_definition::definition;
  singleton = nw_protocol_metadata_create_singleton(v2);

  if (singleton)
  {
    nw_framer_message_set_value(singleton, "opcode", (void *)(int)opcode, 0);
    nw_framer_message_set_value(singleton, "close", (void *)0x3ED, 0);
    nw_framer_message_set_value(singleton, "permessage_deflate", (void *)1, 0);
    id v4 = singleton;
    goto LABEL_5;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ws_create_metadata";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ws_create_metadata";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ws_create_metadata";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v7) {
    free(v7);
  }
LABEL_5:

  return singleton;
}

void sub_183A97AEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_ws_opcode_t nw_ws_metadata_get_opcode(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    int v16 = -1;
    *(void *)&buf[16] = 0x2020000000;
    access_value[0] = MEMORY[0x1E4F143A8];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_opcode_block_invoke;
    access_value[3] = &unk_1E5243E98;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "opcode", access_value);
    nw_ws_opcode_t v2 = *(_DWORD *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_opcode";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  nw_ws_opcode_t v2 = nw_ws_opcode_invalid;
LABEL_3:

  return v2;
}

void sub_183A97E28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_opcode_block_invoke(uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

void nw_ws_metadata_set_close_code(nw_protocol_metadata_t metadata, nw_ws_close_code_t close_code)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = metadata;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "close", (void *)close_code, 0);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v15 = "nw_ws_metadata_set_close_code";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v15 = "nw_ws_metadata_set_close_code";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_close_code";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A98114(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_ws_close_code_t nw_ws_metadata_get_close_code(nw_protocol_metadata_t metadata)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    int v16 = 1005;
    *(void *)&buf[16] = 0x2020000000;
    access_value[0] = MEMORY[0x1E4F143A8];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_close_code_block_invoke;
    access_value[3] = &unk_1E5243E98;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "close", access_value);
    nw_ws_close_code_t v2 = *(_DWORD *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_close_code";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  nw_ws_close_code_t v2 = nw_ws_close_code_no_status_received;
LABEL_3:

  return v2;
}

void sub_183A98444(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_close_code_block_invoke(uint64_t a1, int a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2;
  return 1;
}

void nw_ws_metadata_set_pong_handler(nw_protocol_metadata_t metadata, dispatch_queue_t client_queue, nw_ws_pong_handler_t pong_handler)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v5 = metadata;
  id v6 = client_queue;
  nw_ws_pong_handler_t v7 = pong_handler;
  if (!nw_protocol_metadata_is_ws(v5))
  {
    char v12 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v36 = "nw_ws_metadata_set_pong_handler";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v36 = "nw_ws_metadata_set_pong_handler";
          __int16 v37 = 2082;
          char v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v13) {
          goto LABEL_5;
        }
LABEL_56:
        free(v13);
        goto LABEL_5;
      }
      if (v22)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v6)
  {
    int v16 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v36 = "nw_ws_metadata_set_pong_handler";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null client_queue", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null client_queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    BOOL v23 = (char *)__nw_create_backtrace_string();
    char v14 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null client_queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v25)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v36 = "nw_ws_metadata_set_pong_handler";
      __int16 v37 = 2082;
      char v38 = v23;
      _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null client_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v7)
  {
    uint64_t v18 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    uint64_t v36 = "nw_ws_metadata_set_pong_handler";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v13, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null pong_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v30, "%{public}s called with null pong_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    BOOL v23 = (char *)__nw_create_backtrace_string();
    char v14 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v36 = "nw_ws_metadata_set_pong_handler";
        _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null pong_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v27)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v36 = "nw_ws_metadata_set_pong_handler";
      __int16 v37 = 2082;
      char v38 = v23;
      _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null pong_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v23);
    if (!v13) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  os_log_type_t v8 = v6;
  nw_framer_message_set_value(v5, "client_queue", v8, &__block_literal_global_51441);
  os_log_type_t v9 = nw_dictionary_create();
  BOOL v10 = _Block_copy(v7);
  nw_dictionary_set_value((uint64_t)v9, "handler", v10);

  os_log_type_t v11 = v9;
  dispose_value[0] = MEMORY[0x1E4F143A8];
  dispose_value[1] = 3221225472;
  dispose_value[2] = __nw_ws_metadata_set_pong_handler_block_invoke_2;
  dispose_value[3] = &unk_1E5243EC0;
  BOOL v32 = v8;
  nw_framer_message_set_value(v5, "pong_handler", v11, dispose_value);

LABEL_5:
}

void sub_183A98C20(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_ws_metadata_set_pong_handler_block_invoke_2(uint64_t a1, void *a2)
{
  if (a2)
  {
    id v4 = nw_dictionary_copy_value((uint64_t)a2, (uint64_t)"handler");
    id v5 = v4;
    if (v4)
    {
      id v6 = *(NSObject **)(a1 + 32);
      if (v6)
      {
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = __nw_ws_metadata_set_pong_handler_block_invoke_3;
        block[3] = &unk_1E524AFA8;
        id v8 = v4;
        dispatch_async(v6, block);
      }
    }
  }
}

void __nw_ws_metadata_set_pong_handler_block_invoke_3(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  nw_ws_close_code_t v2 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 89);
  (*(void (**)(uint64_t))(v1 + 16))(v1);
}

void sub_183A98D80(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void *__Block_byref_object_copy__51453(uint64_t a1, uint64_t a2)
{
  BOOL result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__51454(uint64_t a1)
{
}

uint64_t __nw_ws_metadata_copy_pong_handler_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  if (v3)
  {
    id v5 = nw_dictionary_copy_value((uint64_t)v3, (uint64_t)"handler");
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    nw_ws_pong_handler_t v7 = *(void **)(v6 + 40);
    *(void *)(v6 + 40) = v5;

    nw_dictionary_set_value((uint64_t)v4, "handler", 0);
  }

  return 1;
}

uint64_t __Block_byref_object_copy__23_51462(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__24_51463(uint64_t a1)
{
}

uint64_t __nw_ws_metadata_copy_client_queue_block_invoke(uint64_t a1, void *a2)
{
  return 1;
}

nw_ws_response_t nw_ws_metadata_copy_server_response(nw_protocol_metadata_t metadata)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = metadata;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    int v16 = __Block_byref_object_copy__23_51462;
    os_log_type_t v17 = __Block_byref_object_dispose__24_51463;
    id v18 = 0;
    access_value[0] = MEMORY[0x1E4F143A8];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_copy_server_response_block_invoke;
    access_value[3] = &unk_1E5243E98;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "server_response", access_value);
    nw_ws_close_code_t v2 = *(id *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);

    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_copy_server_response";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  nw_ws_close_code_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183A991D4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_copy_server_response_block_invoke(uint64_t a1, void *a2)
{
  return 1;
}

BOOL nw_ws_metadata_get_negotiated_permessage_deflate(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    access_value[0] = MEMORY[0x1E4F143A8];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_negotiated_permessage_deflate_block_invoke;
    access_value[3] = &unk_1E5243E98;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "negotiated_permessage_deflate", access_value);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_negotiated_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183A99554(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_negotiated_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2 != 0;
  return 1;
}

void nw_ws_metadata_set_negotiated_permessage_deflate(void *a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "negotiated_permessage_deflate", (void *)a2, 0);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_negotiated_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A99848(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ws_metadata_get_permessage_deflate(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  if (nw_protocol_metadata_is_ws(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 1;
    access_value[0] = MEMORY[0x1E4F143A8];
    access_value[1] = 3221225472;
    access_value[2] = __nw_ws_metadata_get_permessage_deflate_block_invoke;
    access_value[3] = &unk_1E5243E98;
    access_value[4] = buf;
    nw_framer_message_access_value(v1, "permessage_deflate", access_value);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ws_metadata_get_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183A99B80(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ws_metadata_get_permessage_deflate_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2 != 0;
  return 1;
}

void nw_ws_metadata_set_permessage_deflate(void *a1, unsigned int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_ws(v3))
  {
    nw_framer_message_set_value(v3, "permessage_deflate", (void *)a2, 0);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_ws(metadata)", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_ws_metadata_set_permessage_deflate";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_ws(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183A99E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_array_insert_object_at_index(uint64_t a1, void *a2, char *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  BOOL v25 = a2;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v27 = "nw_array_insert_object_at_index";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v4, &type, &v23)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null array";
      goto LABEL_52;
    }
    if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v20 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v20) {
          goto LABEL_42;
        }
        *(_DWORD *)long long buf = 136446466;
        BOOL v27 = "nw_array_insert_object_at_index";
        __int16 v28 = 2082;
        os_log_type_t v29 = backtrace_string;
        os_log_type_t v21 = "%{public}s called with null array, dumping backtrace:%{public}s";
        goto LABEL_41;
      }
      if (!v20) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null array, no backtrace";
    }
    else
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null array, backtrace limit exceeded";
    }
LABEL_52:
    char v14 = v17;
    os_log_type_t v15 = v18;
    uint32_t v16 = 12;
    goto LABEL_22;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v27 = "nw_array_insert_object_at_index";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v4, &type, &v23)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null object";
      goto LABEL_52;
    }
    if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v22 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (!v22) {
          goto LABEL_42;
        }
        *(_DWORD *)long long buf = 136446466;
        BOOL v27 = "nw_array_insert_object_at_index";
        __int16 v28 = 2082;
        os_log_type_t v29 = backtrace_string;
        os_log_type_t v21 = "%{public}s called with null object, dumping backtrace:%{public}s";
LABEL_41:
        _os_log_impl(&dword_1830D4000, v17, v18, v21, buf, 0x16u);
LABEL_42:
        free(backtrace_string);
        if (v4) {
          goto LABEL_5;
        }
        return;
      }
      if (!v22) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null object, no backtrace";
    }
    else
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v27 = "nw_array_insert_object_at_index";
      os_log_type_t v11 = "%{public}s called with null object, backtrace limit exceeded";
    }
    goto LABEL_52;
  }
  int v3 = a1 + 40;
  LOBYTE(v3) = atomic_load_explicit((atomic_uchar *volatile)(a1 + 40), memory_order_acquire);
  if (!v3)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = (unint64_t *)(a1 + 16);
    unint64_t v8 = v7 + 8 * (void)a3;
    if (v6[1] >= v8)
    {
      std::vector<nw_object_wrapper_t>::emplace<nw_object *&>(v6, v8, &v25);
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446466;
    BOOL v27 = "nw_array_insert_object_at_index";
    __int16 v28 = 2048;
    os_log_type_t v29 = a3;
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v4, &type, &v23)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v27 = "nw_array_insert_object_at_index";
      __int16 v28 = 2048;
      os_log_type_t v29 = a3;
      os_log_type_t v11 = "%{public}s array index out of range: %lu";
LABEL_21:
      char v14 = v9;
      os_log_type_t v15 = v10;
      uint32_t v16 = 22;
LABEL_22:
      _os_log_impl(&dword_1830D4000, v14, v15, v11, buf, v16);
      goto LABEL_23;
    }
    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v27 = "nw_array_insert_object_at_index";
      __int16 v28 = 2048;
      os_log_type_t v29 = a3;
      os_log_type_t v11 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
      goto LABEL_21;
    }
    char v12 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v9 = gLogObj;
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v12)
    {
      if (!v13) {
        goto LABEL_23;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v27 = "nw_array_insert_object_at_index";
      __int16 v28 = 2048;
      os_log_type_t v29 = a3;
      os_log_type_t v11 = "%{public}s array index out of range: %lu, no backtrace";
      goto LABEL_21;
    }
    if (v13)
    {
      *(_DWORD *)long long buf = 136446722;
      BOOL v27 = "nw_array_insert_object_at_index";
      __int16 v28 = 2048;
      os_log_type_t v29 = a3;
      __int16 v30 = 2082;
      __int16 v31 = v12;
      _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s array index out of range: %lu, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v12);
LABEL_23:
    if (v4) {
      goto LABEL_5;
    }
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  BOOL v27 = "nw_array_insert_object_at_index";
  id v4 = (char *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v4))
  {
LABEL_5:
    free(v4);
    return;
  }
  __break(1u);
}

BOOL nw_array_is_empty(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 16) == *(void *)(a1 + 24);
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v11 = "nw_array_is_empty";
  BOOL v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v11 = "nw_array_is_empty";
        id v5 = "%{public}s called with null array";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v11 = "nw_array_is_empty";
          __int16 v12 = 2082;
          BOOL v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v11 = "nw_array_is_empty";
        id v5 = "%{public}s called with null array, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      int v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v11 = "nw_array_is_empty";
        id v5 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 1;
}

void nw_array_set_object_at_index(uint64_t a1, void *object, char *a3)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v25 = "nw_array_set_object_at_index";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22)) {
      goto LABEL_25;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null array";
      goto LABEL_54;
    }
    if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v19 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (!v19) {
          goto LABEL_44;
        }
        *(_DWORD *)long long buf = 136446466;
        BOOL v25 = "nw_array_set_object_at_index";
        __int16 v26 = 2082;
        BOOL v27 = backtrace_string;
        BOOL v20 = "%{public}s called with null array, dumping backtrace:%{public}s";
        goto LABEL_43;
      }
      if (!v19) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null array, no backtrace";
    }
    else
    {
      uint32_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null array, backtrace limit exceeded";
    }
LABEL_54:
    BOOL v13 = v16;
    os_log_type_t v14 = v17;
    uint32_t v15 = 12;
    goto LABEL_24;
  }
  if (!object)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v25 = "nw_array_set_object_at_index";
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22)) {
      goto LABEL_25;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null object";
      goto LABEL_54;
    }
    if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v21 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (!v21) {
          goto LABEL_44;
        }
        *(_DWORD *)long long buf = 136446466;
        BOOL v25 = "nw_array_set_object_at_index";
        __int16 v26 = 2082;
        BOOL v27 = backtrace_string;
        BOOL v20 = "%{public}s called with null object, dumping backtrace:%{public}s";
LABEL_43:
        _os_log_impl(&dword_1830D4000, v16, v17, v20, buf, 0x16u);
LABEL_44:
        free(backtrace_string);
        if (v4) {
          goto LABEL_5;
        }
        return;
      }
      if (!v21) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null object, no backtrace";
    }
    else
    {
      uint32_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v25 = "nw_array_set_object_at_index";
      os_log_type_t v10 = "%{public}s called with null object, backtrace limit exceeded";
    }
    goto LABEL_54;
  }
  int v3 = a1 + 40;
  LOBYTE(v3) = atomic_load_explicit((atomic_uchar *volatile)(a1 + 40), memory_order_acquire);
  if (!v3)
  {
    uint64_t v6 = (void **)(*(void *)(a1 + 16) + 8 * (void)a3);
    if ((unint64_t)v6 < *(void *)(a1 + 24))
    {
      BOOL v7 = os_retain(object);
      if (*v6) {
        os_release(*v6);
      }
      unint64_t *v6 = v7;
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446466;
    BOOL v25 = "nw_array_set_object_at_index";
    __int16 v26 = 2048;
    BOOL v27 = a3;
    os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v4, &type, &v22)) {
      goto LABEL_25;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v25 = "nw_array_set_object_at_index";
      __int16 v26 = 2048;
      BOOL v27 = a3;
      os_log_type_t v10 = "%{public}s array index out of range: %lu";
LABEL_23:
      BOOL v13 = v8;
      os_log_type_t v14 = v9;
      uint32_t v15 = 22;
LABEL_24:
      _os_log_impl(&dword_1830D4000, v13, v14, v10, buf, v15);
      goto LABEL_25;
    }
    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v25 = "nw_array_set_object_at_index";
      __int16 v26 = 2048;
      BOOL v27 = a3;
      os_log_type_t v10 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
      goto LABEL_23;
    }
    os_log_type_t v11 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v8 = gLogObj;
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v11)
    {
      if (!v12) {
        goto LABEL_25;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v25 = "nw_array_set_object_at_index";
      __int16 v26 = 2048;
      BOOL v27 = a3;
      os_log_type_t v10 = "%{public}s array index out of range: %lu, no backtrace";
      goto LABEL_23;
    }
    if (v12)
    {
      *(_DWORD *)long long buf = 136446722;
      BOOL v25 = "nw_array_set_object_at_index";
      __int16 v26 = 2048;
      BOOL v27 = a3;
      __int16 v28 = 2082;
      os_log_type_t v29 = v11;
      _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s array index out of range: %lu, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v11);
LABEL_25:
    if (v4) {
      goto LABEL_5;
    }
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446210;
  BOOL v25 = "nw_array_set_object_at_index";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v4))
  {
LABEL_5:
    free(v4);
    return;
  }
  __break(1u);
}

BOOL nw_array_contains_object(uint64_t a1, uint64_t a2)
{
  BOOL result = 0;
  if (a1 && a2)
  {
    id v5 = *(void **)(a1 + 16);
    os_log_type_t v4 = *(void **)(a1 + 24);
    if (v5 != v4)
    {
      while (*v5 != a2)
      {
        if (++v5 == v4)
        {
          id v5 = v4;
          return v5 != v4;
        }
      }
    }
    return v5 != v4;
  }
  return result;
}

void *nw_array_remove_object_at_index(uint64_t a1, char *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    __int16 v31 = "nw_array_remove_object_at_index";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v6, &type, &v28)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v31 = "nw_array_remove_object_at_index";
      os_log_type_t v9 = "%{public}s called with null array";
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v27 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)long long buf = 136446466;
          __int16 v31 = "nw_array_remove_object_at_index";
          __int16 v32 = 2082;
          char v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v6) {
          return 0;
        }
        goto LABEL_34;
      }
      if (!v27) {
        goto LABEL_33;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v31 = "nw_array_remove_object_at_index";
      os_log_type_t v9 = "%{public}s called with null array, no backtrace";
    }
    else
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)long long buf = 136446210;
      __int16 v31 = "nw_array_remove_object_at_index";
      os_log_type_t v9 = "%{public}s called with null array, backtrace limit exceeded";
    }
    BOOL v20 = v24;
    os_log_type_t v21 = v25;
    uint32_t v22 = 12;
    goto LABEL_32;
  }
  unint64_t v4 = *(void *)(a1 + 16) + 8 * (void)a2;
  if (v4 >= *(void *)(a1 + 24))
  {
LABEL_6:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446466;
    __int16 v31 = "nw_array_remove_object_at_index";
    __int16 v32 = 2048;
    char v33 = a2;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v6, &type, &v28)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)long long buf = 136446466;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      char v33 = a2;
      os_log_type_t v9 = "%{public}s array index out of range: %lu";
LABEL_31:
      BOOL v20 = v7;
      os_log_type_t v21 = v8;
      uint32_t v22 = 22;
LABEL_32:
      _os_log_impl(&dword_1830D4000, v20, v21, v9, buf, v22);
      goto LABEL_33;
    }
    if (!v28)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v7 = gLogObj;
      os_log_type_t v8 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)long long buf = 136446466;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      char v33 = a2;
      os_log_type_t v9 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
      goto LABEL_31;
    }
    os_log_type_t v10 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v7 = gLogObj;
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v10)
    {
      if (!v11) {
        goto LABEL_33;
      }
      *(_DWORD *)long long buf = 136446466;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      char v33 = a2;
      os_log_type_t v9 = "%{public}s array index out of range: %lu, no backtrace";
      goto LABEL_31;
    }
    if (v11)
    {
      *(_DWORD *)long long buf = 136446722;
      __int16 v31 = "nw_array_remove_object_at_index";
      __int16 v32 = 2048;
      char v33 = a2;
      __int16 v34 = 2082;
      uint64_t v35 = v10;
      _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s array index out of range: %lu, dumping backtrace:%{public}s", buf, 0x20u);
    }
    free(v10);
LABEL_33:
    if (!v6) {
      return 0;
    }
LABEL_34:
    free(v6);
    return 0;
  }
  int v5 = a1 + 40;
  LOBYTE(v5) = atomic_load_explicit((atomic_uchar *volatile)(a1 + 40), memory_order_acquire);
  if (v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    __int16 v31 = "nw_array_remove_object_at_index";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v6)) {
      goto LABEL_34;
    }
    __break(1u);
    goto LABEL_6;
  }
  BOOL v12 = *(void **)v4;
  *(void *)unint64_t v4 = 0;
  unint64_t v13 = v4 + 8;
  uint64_t v14 = *(void *)(a1 + 24);
  if (v4 + 8 != v14)
  {
    do
    {
      if (*(void *)v4) {
        os_release(*(void **)v4);
      }
      unint64_t v15 = v4 + 8;
      *(void *)unint64_t v4 = *(void *)(v4 + 8);
      *(void *)(v4 + _Block_object_dispose(&a9, 8) = 0;
      unint64_t v16 = v4 + 16;
      v4 += 8;
    }
    while (v16 != v14);
    unint64_t v13 = *(void *)(a1 + 24);
    unint64_t v4 = v15;
    if (v13 == v15) {
      goto LABEL_26;
    }
    goto LABEL_22;
  }
  if (v13 != v4)
  {
LABEL_22:
    unint64_t v17 = v13;
    do
    {
      BOOL v19 = *(void **)(v17 - 8);
      v17 -= 8;
      os_log_type_t v18 = v19;
      if (v19) {
        os_release(v18);
      }
      *(void *)(v13 - _Block_object_dispose(&a9, 8) = 0;
      unint64_t v13 = v17;
    }
    while (v17 != v4);
  }
LABEL_26:
  *(void *)(a1 + 24) = v4;
  return v12;
}

void nw_array_remove_all_objects(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    int v16 = 136446210;
    *(_DWORD *)long long buf = 136446210;
    BOOL v2 = "nw_array_remove_all_objects";
    BOOL v20 = "nw_array_remove_all_objects";
    uint64_t v3 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault((const char *)v3, &type, &v17)) {
      goto LABEL_29;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_29;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v20 = "nw_array_remove_all_objects";
      os_log_type_t v10 = "%{public}s called with null array";
      goto LABEL_28;
    }
LABEL_18:
    if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v15 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v20 = "nw_array_remove_all_objects";
          __int16 v21 = 2082;
          uint32_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (!v3) {
          return;
        }
LABEL_30:
        free((void *)v3);
        return;
      }
      if (!v15)
      {
LABEL_29:
        if (!v3) {
          return;
        }
        goto LABEL_30;
      }
      *(_DWORD *)long long buf = v16;
      BOOL v20 = "nw_array_remove_all_objects";
      os_log_type_t v10 = "%{public}s called with null array, no backtrace";
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_29;
      }
      *(_DWORD *)long long buf = v16;
      BOOL v20 = v2;
      os_log_type_t v10 = "%{public}s called with null array, backtrace limit exceeded";
    }
LABEL_28:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    goto LABEL_29;
  }
  uint64_t v3 = a1;
  __swp(v1, (unsigned int *)(a1 + 40));
  if (v1)
  {
    BOOL v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    BOOL v20 = "nw_array_remove_all_objects";
    BOOL v12 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v12))
    {
      free(v12);
      atomic_exchange_explicit((atomic_uchar *volatile)(v3 + 40), v1, memory_order_release);
      return;
    }
LABEL_17:
    __break(1u);
    goto LABEL_18;
  }
  unint64_t v4 = *(const char **)(a1 + 16);
  int v5 = *(const char **)(a1 + 24);
  if (v5 != v4)
  {
    BOOL v2 = *(const char **)(a1 + 24);
    do
    {
      BOOL v7 = (void *)*((void *)v2 - 1);
      v2 -= 8;
      uint64_t v6 = v7;
      if (v7) {
        os_release(v6);
      }
      *((void *)v5 - nw_tcp_options_set_enable_fast_open(options, 1) = 0;
      int v5 = v2;
    }
    while (v2 != v4);
  }
  *(void *)(v3 + 24) = v4;
  if (atomic_exchange_explicit((atomic_uchar *volatile)(v3 + 40), 0, memory_order_release) != 255)
  {
    unint64_t v13 = __nwlog_obj();
    os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    BOOL v20 = "nw_array_remove_all_objects";
    uint64_t v3 = _os_log_send_and_compose_impl();
    if (!__nwlog_abort(v3)) {
      goto LABEL_30;
    }
    goto LABEL_17;
  }
}

void nw_array_assign(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    int v15 = 136446210;
    *(_DWORD *)long long buf = 136446210;
    uint64_t v3 = "nw_array_assign";
    BOOL v19 = "nw_array_assign";
    uint64_t v4 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v16)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v19 = "nw_array_assign";
      BOOL v7 = "%{public}s called with null to";
      goto LABEL_39;
    }
LABEL_20:
    if (!v16)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)long long buf = v15;
      BOOL v19 = v3;
      BOOL v7 = "%{public}s called with null to, backtrace limit exceeded";
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v12 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (!v12) {
        goto LABEL_29;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v19 = "nw_array_assign";
      __int16 v20 = 2082;
      __int16 v21 = backtrace_string;
      unint64_t v13 = "%{public}s called with null to, dumping backtrace:%{public}s";
      goto LABEL_28;
    }
    if (v12)
    {
      *(_DWORD *)long long buf = v15;
      BOOL v19 = "nw_array_assign";
      BOOL v7 = "%{public}s called with null to, no backtrace";
LABEL_39:
      _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
      goto LABEL_40;
    }
    goto LABEL_40;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v19 = "nw_array_assign";
    uint64_t v4 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault((const char *)v4, &type, &v16)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v19 = "nw_array_assign";
      BOOL v7 = "%{public}s called with null from";
      goto LABEL_39;
    }
    if (!v16)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v19 = "nw_array_assign";
      BOOL v7 = "%{public}s called with null from, backtrace limit exceeded";
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v14 = os_log_type_enabled(v5, type);
    if (backtrace_string)
    {
      if (!v14) {
        goto LABEL_29;
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v19 = "nw_array_assign";
      __int16 v20 = 2082;
      __int16 v21 = backtrace_string;
      unint64_t v13 = "%{public}s called with null from, dumping backtrace:%{public}s";
LABEL_28:
      _os_log_impl(&dword_1830D4000, v5, v6, v13, buf, 0x16u);
LABEL_29:
      free(backtrace_string);
      if (!v4) {
        return;
      }
LABEL_41:
      free((void *)v4);
      return;
    }
    if (v14)
    {
      *(_DWORD *)long long buf = 136446210;
      BOOL v19 = "nw_array_assign";
      BOOL v7 = "%{public}s called with null from, no backtrace";
      goto LABEL_39;
    }
LABEL_40:
    if (!v4) {
      return;
    }
    goto LABEL_41;
  }
  uint64_t v4 = a1;
  __swp(v2, (unsigned int *)(a1 + 40));
  if (v2)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    BOOL v19 = "nw_array_assign";
    os_log_type_t v9 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v9))
    {
      free(v9);
      atomic_exchange_explicit((atomic_uchar *volatile)(v4 + 40), v2, memory_order_release);
      return;
    }
LABEL_19:
    __break(1u);
    goto LABEL_20;
  }
  if (a1 != a2) {
    std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(a1 + 16, *(void ***)(a2 + 16), *(void ***)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  }
  if (atomic_exchange_explicit((atomic_uchar *volatile)(v4 + 40), 0, memory_order_release) != 255)
  {
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446210;
    BOOL v19 = "nw_array_assign";
    uint64_t v4 = _os_log_send_and_compose_impl();
    if (!__nwlog_abort(v4)) {
      goto LABEL_41;
    }
    goto LABEL_19;
  }
}

uint64_t nw_array_is_equal(uint64_t a1, uint64_t a2)
{
  if (a1) {
    BOOL v3 = a2 == 0;
  }
  else {
    BOOL v3 = 1;
  }
  int v4 = v3;
  if (a1 == a2) {
    uint64_t result = 1;
  }
  else {
    uint64_t result = v4 ^ 1u;
  }
  if ((v4 & 1) == 0 && a1 != a2)
  {
    uint64_t v7 = *(void *)(a1 + 16);
    uint64_t v6 = *(void *)(a1 + 24);
    os_log_type_t v8 = *(uint64_t **)(a2 + 16);
    if (v6 - v7 == *(void *)(a2 + 24) - (void)v8)
    {
      if (v7 == v6)
      {
        return 1;
      }
      else
      {
        uint64_t v9 = v7 + 8;
        do
        {
          uint64_t v10 = *v8++;
          uint64_t result = *(void *)(v9 - 8) == v10;
          BOOL v11 = *(void *)(v9 - 8) != v10 || v9 == v6;
          v9 += 8;
        }
        while (!v11);
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

void *nw_array_create_combined_array(void *a1, void *object)
{
  BOOL v3 = a1;
  if (a1 && object)
  {
    uint64_t v4 = nw_array_create();
    std::vector<nw_object_wrapper_t>::reserve(v4 + 16, ((uint64_t)(*((void *)object + 3) - *((void *)object + 2)) >> 3)+ ((uint64_t)(*((void *)v3 + 3) - *((void *)v3 + 2)) >> 3));
    std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>((int64_t *)(v4 + 16), *(void *)(v4 + 16), *((void ***)v3 + 2), *((void ***)v3 + 3), (uint64_t)(*((void *)v3 + 3) - *((void *)v3 + 2)) >> 3);
    std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>((int64_t *)(v4 + 16), *(void *)(v4 + 24), *((void ***)object + 2), *((void ***)object + 3), (uint64_t)(*((void *)object + 3) - *((void *)object + 2)) >> 3);
    return (void *)v4;
  }
  if (a1) {
    goto LABEL_7;
  }
  if (object)
  {
    a1 = object;
LABEL_7:
    return os_retain(a1);
  }

  return (void *)nw_array_create();
}

void std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>(int64_t *a1, uint64_t a2, void **a3, void **a4, uint64_t a5)
{
  if (a5 < 1) {
    return;
  }
  uint64_t v6 = a3;
  int64_t v8 = *a1;
  unint64_t v9 = a1[1];
  uint64_t v10 = a2 - *a1;
  uint64_t v11 = v10 >> 3;
  BOOL v12 = (char *)(*a1 + (v10 & 0xFFFFFFFFFFFFFFF8));
  int64_t v13 = a1[2];
  if (a5 > (uint64_t)(v13 - v9) >> 3)
  {
    unint64_t v14 = a5 + ((uint64_t)(v9 - v8) >> 3);
    if (v14 >> 61) {
      abort();
    }
    uint64_t v15 = v13 - v8;
    if (v15 >> 2 > v14) {
      unint64_t v14 = v15 >> 2;
    }
    if ((unint64_t)v15 >= 0x7FFFFFFFFFFFFFF8) {
      unint64_t v14 = 0x1FFFFFFFFFFFFFFFLL;
    }
    uint64_t v81 = a2 - *a1;
    int64_t v83 = *a1;
    unint64_t v79 = v14;
    if (v14)
    {
      if (v14 >> 61) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      char v16 = (char *)operator new(8 * v14);
    }
    else
    {
      char v16 = 0;
    }
    uint64_t v23 = v11;
    os_log_type_t v24 = v16;
    os_log_type_t v25 = &v16[8 * v11];
    uint64_t v26 = 8 * a5;
    BOOL v27 = &v25[8 * a5];
    char v28 = v25;
    do
    {
      os_log_type_t v29 = *v6;
      if (*v6) {
        os_log_type_t v29 = os_retain(v29);
      }
      *(void *)char v28 = v29;
      v28 += 8;
      ++v6;
      v26 -= 8;
    }
    while (v26);
    uint64_t v30 = (char *)*a1;
    if ((char *)*a1 == v12)
    {
      uint64_t v32 = v81;
      int64_t v31 = v83;
      unint64_t v35 = v79;
      goto LABEL_37;
    }
    uint64_t v32 = v81;
    int64_t v31 = v83;
    unint64_t v33 = (v81 & 0xFFFFFFFFFFFFFFF8) + v83 - (void)v30 - 8;
    if (v33 >= 0x78)
    {
      unint64_t v36 = (v81 & 0xFFFFFFFFFFFFFFF8) - (v33 & 0xFFFFFFFFFFFFFFF8) - 8;
      unint64_t v37 = (unint64_t)&v24[v36];
      unint64_t v38 = v83 + v36;
      BOOL v39 = v37 >= (unint64_t)v12 || v38 >= (unint64_t)v25;
      __int16 v34 = v12;
      unint64_t v35 = v79;
      if (v39)
      {
        uint64_t v40 = (v33 >> 3) + 1;
        __int16 v34 = &v12[-8 * (v40 & 0x3FFFFFFFFFFFFFFCLL)];
        int v41 = (_OWORD *)(8 * v23 + v83 - 32);
        __int16 v42 = &v24[8 * v23 - 16];
        uint64_t v43 = v40 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v44 = v41[1];
          *((_OWORD *)v42 - nw_tcp_options_set_enable_fast_open(options, 1) = *v41;
          *(_OWORD *)__int16 v42 = v44;
          *int v41 = 0uLL;
          v41[1] = 0uLL;
          v41 -= 2;
          v42 -= 32;
          v43 -= 4;
        }
        while (v43);
        v25 -= 8 * (v40 & 0x3FFFFFFFFFFFFFFCLL);
        if (v40 == (v40 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_37:
          uint64_t v46 = (char *)a1[1];
          if (v46 == v12)
          {
LABEL_78:
            unsigned int v75 = (char *)*a1;
            *a1 = (int64_t)v25;
            a1[1] = (int64_t)v27;
            a1[2] = (int64_t)&v24[8 * v35];
            if (v12 != v75)
            {
              unsigned int v76 = v12;
              do
              {
                unsigned int v78 = (void *)*((void *)v76 - 1);
                v76 -= 8;
                unsigned int v77 = v78;
                if (v78) {
                  os_release(v77);
                }
                *((void *)v12 - nw_tcp_options_set_enable_fast_open(options, 1) = 0;
                BOOL v12 = v76;
              }
              while (v76 != v75);
            }
            if (v75)
            {
              operator delete(v75);
            }
            return;
          }
          unint64_t v47 = (unint64_t)&v46[-(v32 & 0xFFFFFFFFFFFFFFF8) - v31 - 8];
          if (v47 >= 0xA8)
          {
            unint64_t v49 = (v32 & 0xFFFFFFFFFFFFFFF8) + (v47 & 0xFFFFFFFFFFFFFFF8);
            if ((unint64_t)v27 >= v49 + v31 + 8 || v12 >= &v24[8 * a5 + 8 + v49])
            {
              uint64_t v51 = (v47 >> 3) + 1;
              uint64_t v52 = 8 * (v51 & 0x3FFFFFFFFFFFFFFCLL);
              BOOL v48 = &v12[v52];
              int v53 = &v24[8 * v23 + 16 + 8 * a5];
              uint64_t v54 = v51 & 0x3FFFFFFFFFFFFFFCLL;
              do
              {
                long long v55 = *((_OWORD *)v12 + 1);
                *((_OWORD *)v53 - nw_tcp_options_set_enable_fast_open(options, 1) = *(_OWORD *)v12;
                *(_OWORD *)int v53 = v55;
                *(_OWORD *)BOOL v12 = 0uLL;
                *((_OWORD *)v12 + nw_tcp_options_set_enable_fast_open(options, 1) = 0uLL;
                v12 += 32;
                v53 += 32;
                v54 -= 4;
              }
              while (v54);
              v27 += v52;
              if (v51 == (v51 & 0x3FFFFFFFFFFFFFFCLL)) {
                goto LABEL_77;
              }
            }
            else
            {
              BOOL v48 = v12;
            }
          }
          else
          {
            BOOL v48 = v12;
          }
          do
          {
            *(void *)BOOL v27 = *(void *)v48;
            v27 += 8;
            *(void *)BOOL v48 = 0;
            v48 += 8;
          }
          while (v48 != v46);
LABEL_77:
          BOOL v12 = (char *)a1[1];
          goto LABEL_78;
        }
      }
    }
    else
    {
      __int16 v34 = v12;
      unint64_t v35 = v79;
    }
    do
    {
      uint64_t v45 = *((void *)v34 - 1);
      v34 -= 8;
      *((void *)v25 - nw_tcp_options_set_enable_fast_open(options, 1) = v45;
      v25 -= 8;
      *(void *)__int16 v34 = 0;
    }
    while (v34 != v30);
    goto LABEL_37;
  }
  uint64_t v80 = v10 >> 3;
  uint64_t v17 = (uint64_t)(v9 - (void)v12) >> 3;
  if (v17 >= a5)
  {
    BOOL v19 = &a3[a5];
    __int16 v21 = (char *)a1[1];
    goto LABEL_51;
  }
  BOOL v19 = &a3[v17];
  if (v19 == a4)
  {
    __int16 v21 = (char *)a1[1];
  }
  else
  {
    uint64_t v82 = a2 - *a1;
    unsigned int v84 = (_OWORD *)*a1;
    __int16 v20 = &a3[v17];
    __int16 v21 = (char *)a1[1];
    do
    {
      uint64_t v22 = *v20;
      if (*v20) {
        uint64_t v22 = os_retain(v22);
      }
      *(void *)__int16 v21 = v22;
      v21 += 8;
      ++v20;
    }
    while (v20 != a4);
    uint64_t v10 = v82;
    int64_t v8 = (int64_t)v84;
  }
  a1[1] = (int64_t)v21;
  if ((uint64_t)(v9 - (void)v12) >= 1)
  {
LABEL_51:
    unsigned int v56 = &v12[8 * a5];
    uint64_t v57 = v21 - v56;
    unsigned int v58 = &v21[-8 * a5];
    unint64_t v59 = v21;
    if ((unint64_t)v58 < v9)
    {
      unint64_t v60 = (v10 & 0xFFFFFFFFFFFFFFF8) + v57;
      int v61 = (char *)(v60 + v8);
      unint64_t v62 = v60 + v8 + 8;
      if (v9 > v62) {
        unint64_t v62 = v9;
      }
      unint64_t v63 = v62 + ~v8 - v60;
      if (v63 > 0xE7
        && (v21 < &v61[(v63 & 0xFFFFFFFFFFFFFFF8) + 8]
          ? (BOOL v64 = v58 >= &v21[(v63 & 0xFFFFFFFFFFFFFFF8) + 8])
          : (BOOL v64 = 1),
            v64))
      {
        uint64_t v65 = (v63 >> 3) + 1;
        uint64_t v66 = 8 * (v65 & 0x3FFFFFFFFFFFFFFCLL);
        uint64_t v67 = &v58[v66];
        unint64_t v68 = v21 + 16;
        uint64_t v69 = v65 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v70 = *((_OWORD *)v58 + 1);
          *(v68 - nw_tcp_options_set_enable_fast_open(options, 1) = *(_OWORD *)v58;
          _OWORD *v68 = v70;
          *(_OWORD *)unsigned int v58 = 0uLL;
          *((_OWORD *)v58 + nw_tcp_options_set_enable_fast_open(options, 1) = 0uLL;
          v58 += 32;
          v68 += 2;
          v69 -= 4;
        }
        while (v69);
        unint64_t v59 = &v21[v66];
        if (v65 == (v65 & 0x3FFFFFFFFFFFFFFCLL)) {
          goto LABEL_66;
        }
      }
      else
      {
        uint64_t v67 = &v21[-8 * a5];
        unint64_t v59 = v21;
      }
      do
      {
        *(void *)unint64_t v59 = *(void *)v67;
        v59 += 8;
        *(void *)uint64_t v67 = 0;
        v67 += 8;
      }
      while ((unint64_t)v67 < v9);
    }
LABEL_66:
    a1[1] = (int64_t)v59;
    if (v21 != v56)
    {
      unsigned int v71 = (void **)(v21 - 8);
      uint64_t v72 = 8 * (v57 >> 3);
      uint64_t v73 = v8 + 8 * v80 - 8;
      do
      {
        if (*v71) {
          os_release(*v71);
        }
        *v71-- = *(void **)(v73 + v72);
        *(void *)(v73 + v72) = 0;
        v72 -= 8;
      }
      while (v72);
    }
    for (; v6 != v19; ++v6)
    {
      unsigned int v74 = *v6;
      if (*v6) {
        unsigned int v74 = os_retain(v74);
      }
      *(void *)BOOL v12 = v74;
      v12 += 8;
    }
  }
}

BOOL nw_array_compare(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (a1)
  {
    unint64_t v6 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
    if (a2) {
      goto LABEL_3;
    }
  }
  else
  {
    unint64_t v6 = 0;
    if (a2)
    {
LABEL_3:
      if (v6 == (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3) {
        goto LABEL_4;
      }
      return 0;
    }
  }
  if (v6) {
    return 0;
  }
LABEL_4:
  if (v6)
  {
    BOOL v7 = 0;
    for (i = 0; i != v6; BOOL v7 = i >= v6)
    {
      uint64_t object_at_index = nw_array_get_object_at_index(a1, i);
      uint64_t v10 = nw_array_get_object_at_index(a2, i);
      if (((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a3 + 16))(a3, object_at_index, v10) & 1) == 0) {
        break;
      }
      ++i;
    }
  }
  else
  {
    return 1;
  }
  return v7;
}

void nw_array_review_change(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v5 = a1;
  if (a1) {
    uint64_t v71 = (uint64_t)(*(void *)(a1 + 24) - *(void *)(a1 + 16)) >> 3;
  }
  else {
    uint64_t v71 = 0;
  }
  unsigned int v78 = 0;
  unint64_t v79 = 0;
  uint64_t v80 = 0;
  if (a2) {
    std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>((uint64_t)&v78, *(void ***)(a2 + 16), *(void ***)(a2 + 24), (uint64_t)(*(void *)(a2 + 24) - *(void *)(a2 + 16)) >> 3);
  }
  if (v71)
  {
    unint64_t v6 = 0;
    BOOL v7 = 0;
    int64_t v8 = 0;
    unint64_t v9 = 0;
    uint64_t v10 = v79;
    unsigned int v76 = v78;
    uint64_t v11 = v79;
    while (1)
    {
      uint64_t object_at_index = (void *)nw_array_get_object_at_index(v5, v6);
      uint64_t v14 = (char *)v11 - (char *)v76;
      BOOL v13 = v11 == v76;
      uint64_t v11 = v76;
      if (v13) {
        goto LABEL_19;
      }
      object = object_at_index;
      uint64_t v72 = v9;
      uint64_t v15 = v5;
      uint64_t v16 = 0;
      unint64_t v17 = v14 >> 3;
      if (v17 <= 1) {
        uint64_t v18 = 1;
      }
      else {
        uint64_t v18 = v17;
      }
      BOOL v19 = v78;
      uint64_t v10 = v79;
      uint64_t v20 = v79 - v78;
      do
      {
        uint64_t v21 = nw_array_get_object_at_index(v15, v6);
        if (v20 == v16) {
          goto LABEL_107;
        }
        if ((*(unsigned int (**)(uint64_t, uint64_t, void *))(a3 + 16))(a3, v21, v19[v16]))
        {
          uint64_t v11 = &v76[v16];
          uint64_t v5 = v15;
          if (v11 + 1 == v10)
          {
            unint64_t v9 = v72;
            if (v10 != v11) {
              goto LABEL_44;
            }
          }
          else
          {
            unint64_t v9 = v72;
            do
            {
              if (*v11) {
                os_release(*v11);
              }
              uint64_t v23 = v11 + 1;
              NSObject *v11 = v11[1];
              v11[1] = 0;
              os_log_type_t v24 = v11 + 2;
              ++v11;
            }
            while (v24 != v10);
            uint64_t v11 = v23;
            if (v10 == v23) {
              goto LABEL_48;
            }
LABEL_44:
            __int16 v34 = v10;
            do
            {
              unint64_t v36 = *--v34;
              unint64_t v35 = v36;
              if (v36) {
                os_release(v35);
              }
              *(v10 - nw_tcp_options_set_enable_fast_open(options, 1) = 0;
              uint64_t v10 = v34;
            }
            while (v34 != v11);
          }
LABEL_48:
          unint64_t v79 = v11;
          uint64_t v10 = v11;
          goto LABEL_9;
        }
        ++v16;
      }
      while (v18 != v16);
      uint64_t v11 = v10;
      uint64_t v5 = v15;
      unint64_t v9 = v72;
      uint64_t object_at_index = object;
LABEL_19:
      if (object_at_index) {
        uint64_t v22 = os_retain(object_at_index);
      }
      else {
        uint64_t v22 = 0;
      }
      long long v25 = 0uLL;
      if (v8 < v9)
      {
        *(void *)int64_t v8 = v22;
        v8 += 8;
        goto LABEL_9;
      }
      int64_t v26 = v8 - v7;
      uint64_t v27 = (v8 - v7) >> 3;
      unint64_t v28 = v27 + 1;
      if ((unint64_t)(v27 + 1) >> 61) {
        goto LABEL_107;
      }
      if ((v9 - v7) >> 2 > v28) {
        unint64_t v28 = (v9 - v7) >> 2;
      }
      if ((unint64_t)(v9 - v7) >= 0x7FFFFFFFFFFFFFF8) {
        unint64_t v29 = 0x1FFFFFFFFFFFFFFFLL;
      }
      else {
        unint64_t v29 = v28;
      }
      if (v29)
      {
        uint64_t v73 = v22;
        if (v29 >> 61) {
          std::__throw_bad_array_new_length[abi:nn180100]();
        }
        uint64_t v30 = (char *)operator new(8 * v29);
        long long v25 = 0uLL;
        int64_t v26 = v8 - v7;
        uint64_t v22 = v73;
      }
      else
      {
        uint64_t v30 = 0;
      }
      int64_t v31 = &v30[8 * v27];
      *(void *)int64_t v31 = v22;
      unsigned int v74 = v31 + 8;
      if (v8 != v7)
      {
        unint64_t v32 = v8 - v7 - 8;
        objecta = (void *)v29;
        if (v32 < 0x138)
        {
          unint64_t v33 = v8;
          goto LABEL_59;
        }
        unint64_t v37 = v32 & 0xFFFFFFFFFFFFFFF8;
        if (&v30[v26 - 8 - (v32 & 0xFFFFFFFFFFFFFFF8)] > &v30[v26 - 8])
        {
          unint64_t v33 = v8;
          goto LABEL_59;
        }
        if (&v8[-v37 - 8] > v8 - 8)
        {
          unint64_t v33 = v8;
          goto LABEL_59;
        }
        unint64_t v38 = v32 >> 3;
        if (&v30[v26 - v37 - 8] < v8)
        {
          unint64_t v33 = v8;
          if (&v8[-8 * v38 - 8] < v31) {
            goto LABEL_111;
          }
        }
        unint64_t v39 = v38 + 1;
        unint64_t v33 = &v8[-8 * (v39 & 0x3FFFFFFFFFFFFFFCLL)];
        uint64_t v40 = &v30[8 * ((v8 - v7) >> 3) - 16];
        int v41 = v8 - 32;
        uint64_t v42 = v39 & 0x3FFFFFFFFFFFFFFCLL;
        do
        {
          long long v43 = *((_OWORD *)v41 + 1);
          *((_OWORD *)v40 - nw_tcp_options_set_enable_fast_open(options, 1) = *(_OWORD *)v41;
          *(_OWORD *)uint64_t v40 = v43;
          *(_OWORD *)int v41 = v25;
          *((_OWORD *)v41 + nw_tcp_options_set_enable_fast_open(options, 1) = v25;
          v41 -= 32;
          v40 -= 32;
          v42 -= 4;
        }
        while (v42);
        v31 -= 8 * (v39 & 0x3FFFFFFFFFFFFFFCLL);
        if (v39 != (v39 & 0x3FFFFFFFFFFFFFFCLL))
        {
LABEL_111:
          do
          {
LABEL_59:
            uint64_t v44 = *((void *)v33 - 1);
            v33 -= 8;
            *((void *)v31 - nw_tcp_options_set_enable_fast_open(options, 1) = v44;
            v31 -= 8;
            *(void *)unint64_t v33 = 0;
          }
          while (v33 != v7);
        }
        uint64_t v45 = v30;
        uint64_t v46 = v8;
        do
        {
          BOOL v48 = (void *)*((void *)v46 - 1);
          v46 -= 8;
          unint64_t v47 = v48;
          if (v48) {
            os_release(v47);
          }
          *((void *)v8 - nw_tcp_options_set_enable_fast_open(options, 1) = 0;
          int64_t v8 = v46;
        }
        while (v46 != v7);
        unint64_t v29 = (unint64_t)objecta;
        uint64_t v30 = v45;
      }
      unint64_t v9 = &v30[8 * v29];
      if (v7) {
        operator delete(v7);
      }
      int64_t v8 = v74;
      BOOL v7 = v31;
LABEL_9:
      if (++v6 == v71) {
        goto LABEL_69;
      }
    }
  }
  int64_t v8 = 0;
  BOOL v7 = 0;
  uint64_t v10 = v79;
LABEL_69:
  unint64_t v49 = v78;
  unint64_t v50 = v10 - v78;
  unint64_t v51 = (v8 - v7) >> 3;
  if (v8 == v7)
  {
    uint64_t v77 = 0;
    if (v10 != v78)
    {
LABEL_77:
      if (v50 <= 1) {
        uint64_t v55 = 1;
      }
      else {
        uint64_t v55 = v50;
      }
      uint64_t v56 = v55 - 1;
      uint64_t v57 = v77 - v51 + 1;
      unsigned int v58 = v49;
      while (v50)
      {
        uint64_t v59 = (uint64_t)*v58++;
        int v60 = (*(uint64_t (**)(uint64_t, uint64_t, uint64_t, BOOL))(a4 + 16))(a4, v59, 1, v57 == v50);
        BOOL v62 = v56-- != 0;
        if (v60)
        {
          --v50;
          if (v62) {
            continue;
          }
        }
        goto LABEL_90;
      }
LABEL_107:
      abort();
    }
  }
  else
  {
    if (v51 <= 1) {
      uint64_t v52 = 1;
    }
    else {
      uint64_t v52 = (v8 - v7) >> 3;
    }
    uint64_t v53 = v50 + v51 - 1;
    uint64_t v54 = v7;
    uint64_t v77 = v52;
    do
    {
      if (((*(uint64_t (**)(uint64_t, void, uint64_t, BOOL))(a4 + 16))(a4, *(void *)v54, 2, v53 == 0) & 1) == 0) {
        goto LABEL_89;
      }
      --v53;
      v54 += 8;
      --v52;
    }
    while (v52);
    if (v10 != v49) {
      goto LABEL_77;
    }
  }
LABEL_89:
  if (v49)
  {
LABEL_90:
    if (v10 != v49)
    {
      unint64_t v63 = v10;
      do
      {
        uint64_t v65 = *--v63;
        BOOL v64 = v65;
        if (v65) {
          os_release(v64);
        }
        *(v10 - nw_tcp_options_set_enable_fast_open(options, 1) = 0;
        uint64_t v10 = v63;
      }
      while (v63 != v49);
      uint64_t v10 = v78;
    }
    operator delete(v10);
  }
  if (v7)
  {
    if (v8 != v7)
    {
      uint64_t v66 = v8;
      do
      {
        unint64_t v68 = (void *)*((void *)v66 - 1);
        v66 -= 8;
        uint64_t v67 = v68;
        if (v68) {
          os_release(v67);
        }
        *((void *)v8 - nw_tcp_options_set_enable_fast_open(options, 1) = 0;
        int64_t v8 = v66;
      }
      while (v66 != v7);
    }
    operator delete(v7);
  }
}

uint64_t in_adjust_cksum(uint64_t a1, int a2, unsigned int a3, unsigned int a4, unsigned int a5, unsigned int a6)
{
  unsigned int v6 = a4 - a3;
  if ((int)(a4 - a3) >= 1)
  {
    BOOL v7 = (unsigned __int8 *)(a1 + a3);
    if (v7)
    {
      unint64_t v9 = (uint32x2_t *)(v7 + 1);
      unint64_t v8 = (unint64_t)*v7 << 8;
      --v6;
      if (((v7 + 1) & 2) == 0)
      {
LABEL_4:
        if (v6 >= 0x40) {
          goto LABEL_5;
        }
        goto LABEL_34;
      }
    }
    else
    {
      unint64_t v8 = 0;
      unint64_t v9 = (uint32x2_t *)(a1 + a3);
      if ((v7 & 2) == 0) {
        goto LABEL_4;
      }
    }
    unsigned int v27 = v6 - 2;
    if (v6 < 2)
    {
      uint64_t v10 = 0;
      if ((v6 & 1) == 0) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
    unsigned int v28 = v9->u16[0];
    unint64_t v9 = (uint32x2_t *)((char *)v9 + 2);
    v8 += v28;
    v6 -= 2;
    if (v27 >= 0x40)
    {
LABEL_5:
      uint64_t v10 = 0;
      _X13 = v9;
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }
        unint64_t v9 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }
        v8 += vaddvq_s64(vaddq_s64(vaddq_s64((int64x2_t)vaddl_u32(*_X13, _X13[4]), (int64x2_t)vaddl_u32(_X13[2], _X13[6])), vaddq_s64((int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13->i8, *(uint32x4_t *)_X13[4].i8), (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13[2].i8, *(uint32x4_t *)_X13[6].i8))));
        v6 -= 64;
        unint64_t v17 = __ROR8__(v8, 56);
        if ((v7 & 1) == 0) {
          unint64_t v17 = v8;
        }
        unint64_t v18 = v10 + HIDWORD(v17) + v17;
        if (v8 >> 62)
        {
          unint64_t v8 = 0;
          uint64_t v10 = v18;
        }
        _X13 += 8;
      }
      while (v6 > 0x3F);
      if (v6 < 0x20)
      {
LABEL_12:
        if ((v6 & 0x10) == 0) {
          goto LABEL_13;
        }
        goto LABEL_36;
      }
LABEL_35:
      uint32x4_t v29 = *(uint32x4_t *)v9->i8;
      uint32x4_t v30 = *(uint32x4_t *)v9[2].i8;
      v9 += 4;
      v8 += vaddvq_s64(vaddq_s64((int64x2_t)vaddl_u32(*(uint32x2_t *)v29.i8, *(uint32x2_t *)v30.i8), (int64x2_t)vaddl_high_u32(v29, v30)));
      if ((v6 & 0x10) == 0)
      {
LABEL_13:
        if ((v6 & 8) == 0) {
          goto LABEL_14;
        }
        goto LABEL_37;
      }
LABEL_36:
      uint32x4_t v31 = *(uint32x4_t *)v9->i8;
      v9 += 2;
      v8 += vaddlvq_u32(v31);
      if ((v6 & 8) == 0)
      {
LABEL_14:
        if ((v6 & 4) == 0) {
          goto LABEL_15;
        }
        goto LABEL_38;
      }
LABEL_37:
      uint64_t v32 = v9->u32[0];
      uint64_t v33 = v9->u32[1];
      ++v9;
      v8 += v32 + v33;
      if ((v6 & 4) == 0)
      {
LABEL_15:
        if ((v6 & 2) == 0) {
          goto LABEL_16;
        }
        goto LABEL_39;
      }
LABEL_38:
      unsigned __int32 v34 = v9->i32[0];
      unint64_t v9 = (uint32x2_t *)((char *)v9 + 4);
      v8 += v34;
      if ((v6 & 2) == 0)
      {
LABEL_16:
        if ((v6 & 1) == 0)
        {
LABEL_18:
          unint64_t v19 = __ROR8__(v8, 56);
          if (v7) {
            unint64_t v20 = v19;
          }
          else {
            unint64_t v20 = v8;
          }
          unint64_t v21 = ((unint64_t)(v10 + v20 + HIDWORD(v20)) >> 32)
              + (v10 + v20 + HIDWORD(v20));
          unsigned int v22 = (unsigned __int16)(((HIDWORD(v21) + (unsigned __int16)v21 + WORD1(v21)) >> 16)
                                 + WORD2(v21)
                                 + v21
                                 + WORD1(v21)
                                 + ((((HIDWORD(v21) + (unsigned __int16)v21 + WORD1(v21)) >> 16)
                                   + (unsigned __int16)(WORD2(v21) + v21 + WORD1(v21))) >> 16));
          goto LABEL_22;
        }
LABEL_17:
        v8 += v9->u8[0];
        goto LABEL_18;
      }
LABEL_39:
      unsigned int v35 = v9->u16[0];
      unint64_t v9 = (uint32x2_t *)((char *)v9 + 2);
      v8 += v35;
      if ((v6 & 1) == 0) {
        goto LABEL_18;
      }
      goto LABEL_17;
    }
LABEL_34:
    uint64_t v10 = 0;
    if (v6 < 0x20) {
      goto LABEL_12;
    }
    goto LABEL_35;
  }
  if ((v6 & 0x80000000) == 0)
  {
    unsigned int v22 = 0;
    goto LABEL_22;
  }
  uint64_t v40 = (unsigned __int8 *)(a1 + a4);
  if (v40)
  {
    long long v43 = (uint32x2_t *)(v40 + 1);
    unint64_t v41 = (unint64_t)*v40 << 8;
    unsigned int v42 = ~v6;
  }
  else
  {
    unint64_t v41 = 0;
    unsigned int v42 = a3 - a4;
    long long v43 = (uint32x2_t *)(a1 + a4);
  }
  if ((v43 & 2) != 0)
  {
    if (v42 < 2)
    {
      uint64_t v63 = 0;
      if ((v42 & 1) == 0) {
        goto LABEL_105;
      }
      goto LABEL_104;
    }
    unsigned int v64 = v43->u16[0];
    long long v43 = (uint32x2_t *)((char *)v43 + 2);
    v41 += v64;
    v42 -= 2;
  }
  if (v42 < 0x40)
  {
    uint64_t v63 = 0;
  }
  else
  {
    uint64_t v63 = 0;
    _X13 = v43;
    if (v40)
    {
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }
        long long v43 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }
        v41 += vaddvq_s64(vaddq_s64(vaddq_s64((int64x2_t)vaddl_u32(*_X13, _X13[4]), (int64x2_t)vaddl_u32(_X13[2], _X13[6])), vaddq_s64((int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13->i8, *(uint32x4_t *)_X13[4].i8), (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13[2].i8, *(uint32x4_t *)_X13[6].i8))));
        v42 -= 64;
        unint64_t v71 = __ROR8__(v41, 56);
        unint64_t v72 = v63 + HIDWORD(v71) + v71;
        if (v41 >> 62)
        {
          unint64_t v41 = 0;
          uint64_t v63 = v72;
        }
        _X13 += 8;
      }
      while (v42 > 0x3F);
    }
    else
    {
      do
      {
        __asm { PRFM            #0, [X13,#0x20] }
        long long v43 = _X13 + 8;
        __asm { PRFM            #0, [X13,#0x40] }
        v41 += vaddvq_s64(vaddq_s64(vaddq_s64((int64x2_t)vaddl_u32(*_X13, _X13[4]), (int64x2_t)vaddl_u32(_X13[2], _X13[6])), vaddq_s64((int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13->i8, *(uint32x4_t *)_X13[4].i8), (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X13[2].i8, *(uint32x4_t *)_X13[6].i8))));
        v42 -= 64;
        unint64_t v68 = v63 + HIDWORD(v41) + v41;
        if (v41 >> 62)
        {
          unint64_t v41 = 0;
          uint64_t v63 = v68;
        }
        _X13 += 8;
      }
      while (v42 > 0x3F);
    }
  }
  if (v42 >= 0x20)
  {
    uint32x4_t v75 = *(uint32x4_t *)v43->i8;
    uint32x4_t v76 = *(uint32x4_t *)v43[2].i8;
    v43 += 4;
    v41 += vaddvq_s64(vaddq_s64((int64x2_t)vaddl_u32(*(uint32x2_t *)v75.i8, *(uint32x2_t *)v76.i8), (int64x2_t)vaddl_high_u32(v75, v76)));
    if ((v42 & 0x10) == 0)
    {
LABEL_100:
      if ((v42 & 8) == 0) {
        goto LABEL_101;
      }
      goto LABEL_110;
    }
  }
  else if ((v42 & 0x10) == 0)
  {
    goto LABEL_100;
  }
  uint32x4_t v77 = *(uint32x4_t *)v43->i8;
  v43 += 2;
  v41 += vaddlvq_u32(v77);
  if ((v42 & 8) == 0)
  {
LABEL_101:
    if ((v42 & 4) == 0) {
      goto LABEL_102;
    }
    goto LABEL_111;
  }
LABEL_110:
  uint64_t v78 = v43->u32[0];
  uint64_t v79 = v43->u32[1];
  ++v43;
  v41 += v78 + v79;
  if ((v42 & 4) == 0)
  {
LABEL_102:
    if ((v42 & 2) == 0) {
      goto LABEL_103;
    }
LABEL_112:
    unsigned int v81 = v43->u16[0];
    long long v43 = (uint32x2_t *)((char *)v43 + 2);
    v41 += v81;
    if ((v42 & 1) == 0) {
      goto LABEL_105;
    }
    goto LABEL_104;
  }
LABEL_111:
  unsigned __int32 v80 = v43->i32[0];
  long long v43 = (uint32x2_t *)((char *)v43 + 4);
  v41 += v80;
  if ((v42 & 2) != 0) {
    goto LABEL_112;
  }
LABEL_103:
  if (v42) {
LABEL_104:
  }
    v41 += v43->u8[0];
LABEL_105:
  unsigned int v22 = 0;
  _ZF = (v40 & 1) == 0;
  unint64_t v73 = __ROR8__(v41, 56);
  if (_ZF) {
    unint64_t v73 = v41;
  }
  unint64_t v74 = ((unint64_t)(v63 + v73 + HIDWORD(v73)) >> 32) + (v63 + v73 + HIDWORD(v73));
  a6 += (unsigned __int16)(((HIDWORD(v74) + (unsigned __int16)v74 + WORD1(v74)) >> 16)
                         + WORD2(v74)
                         + v74
                         + WORD1(v74)
                         + ((((HIDWORD(v74) + (unsigned __int16)v74 + WORD1(v74)) >> 16)
                           + (unsigned __int16)(WORD2(v74) + v74 + WORD1(v74))) >> 16));
LABEL_22:
  unsigned int v23 = a2 - (a4 + a5);
  if ((int)v23 < 1) {
    goto LABEL_23;
  }
  unint64_t v36 = (unsigned __int8 *)(a1 + a4 + a5);
  if (v36)
  {
    unint64_t v38 = (uint32x2_t *)(v36 + 1);
    unint64_t v37 = (unint64_t)*v36 << 8;
    --v23;
  }
  else
  {
    unint64_t v37 = 0;
    unint64_t v38 = (uint32x2_t *)(a1 + a4 + a5);
  }
  if ((v38 & 2) != 0)
  {
    if (v23 < 2)
    {
      uint64_t v39 = 0;
      if ((v23 & 1) == 0) {
        goto LABEL_69;
      }
      goto LABEL_68;
    }
    unsigned int v44 = v38->u16[0];
    unint64_t v38 = (uint32x2_t *)((char *)v38 + 2);
    v37 += v44;
    v23 -= 2;
  }
  if (v23 < 0x40)
  {
    uint64_t v39 = 0;
  }
  else
  {
    uint64_t v39 = 0;
    _X14 = v38;
    do
    {
      __asm { PRFM            #0, [X14,#0x20] }
      unint64_t v38 = _X14 + 8;
      __asm { PRFM            #0, [X14,#0x40] }
      v37 += vaddvq_s64(vaddq_s64(vaddq_s64((int64x2_t)vaddl_u32(*_X14, _X14[4]), (int64x2_t)vaddl_u32(_X14[2], _X14[6])), vaddq_s64((int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X14->i8, *(uint32x4_t *)_X14[4].i8), (int64x2_t)vaddl_high_u32(*(uint32x4_t *)_X14[2].i8, *(uint32x4_t *)_X14[6].i8))));
      v23 -= 64;
      unint64_t v48 = __ROR8__(v37, 56);
      if ((v36 & 1) == 0) {
        unint64_t v48 = v37;
      }
      unint64_t v49 = v39 + HIDWORD(v48) + v48;
      if (v37 >> 62)
      {
        unint64_t v37 = 0;
        uint64_t v39 = v49;
      }
      _X14 += 8;
    }
    while (v23 > 0x3F);
  }
  if (v23 >= 0x20)
  {
    uint32x4_t v56 = *(uint32x4_t *)v38->i8;
    uint32x4_t v57 = *(uint32x4_t *)v38[2].i8;
    v38 += 4;
    v37 += vaddvq_s64(vaddq_s64((int64x2_t)vaddl_u32(*(uint32x2_t *)v56.i8, *(uint32x2_t *)v57.i8), (int64x2_t)vaddl_high_u32(v56, v57)));
    if ((v23 & 0x10) == 0)
    {
LABEL_64:
      if ((v23 & 8) == 0) {
        goto LABEL_65;
      }
      goto LABEL_77;
    }
  }
  else if ((v23 & 0x10) == 0)
  {
    goto LABEL_64;
  }
  uint32x4_t v58 = *(uint32x4_t *)v38->i8;
  v38 += 2;
  v37 += vaddlvq_u32(v58);
  if ((v23 & 8) == 0)
  {
LABEL_65:
    if ((v23 & 4) == 0) {
      goto LABEL_66;
    }
    goto LABEL_78;
  }
LABEL_77:
  uint64_t v59 = v38->u32[0];
  uint64_t v60 = v38->u32[1];
  ++v38;
  v37 += v59 + v60;
  if ((v23 & 4) == 0)
  {
LABEL_66:
    if ((v23 & 2) == 0) {
      goto LABEL_67;
    }
LABEL_79:
    unsigned int v62 = v38->u16[0];
    unint64_t v38 = (uint32x2_t *)((char *)v38 + 2);
    v37 += v62;
    if ((v23 & 1) == 0) {
      goto LABEL_69;
    }
    goto LABEL_68;
  }
LABEL_78:
  unsigned __int32 v61 = v38->i32[0];
  unint64_t v38 = (uint32x2_t *)((char *)v38 + 4);
  v37 += v61;
  if ((v23 & 2) != 0) {
    goto LABEL_79;
  }
LABEL_67:
  if (v23) {
LABEL_68:
  }
    v37 += v38->u8[0];
LABEL_69:
  unint64_t v50 = __ROR8__(v37, 56);
  _ZF = (v36 & 1) == 0;
  if (v36) {
    unint64_t v52 = v50;
  }
  else {
    unint64_t v52 = v37;
  }
  unint64_t v53 = ((unint64_t)(v39 + v52 + HIDWORD(v52)) >> 32) + (v39 + v52 + HIDWORD(v52));
  LODWORD(v53) = ((HIDWORD(v53) + (unsigned __int16)v53 + WORD1(v53)) >> 16)
               + (unsigned __int16)(WORD2(v53) + v53 + WORD1(v53));
  unsigned int v54 = v53 + WORD1(v53);
  unsigned int v55 = bswap32(v54) >> 16;
  if (!_ZF) {
    LOWORD(v54) = v55;
  }
  unsigned int v22 = ((v22 + (unsigned __int16)v54) >> 16) + (unsigned __int16)(v22 + v54);
LABEL_23:
  unsigned int v24 = a6 - v22;
  if (a6 <= v22) {
    unsigned int v24 = (unsigned __int16)(a6 + ~(_WORD)v22);
  }
  if (v22) {
    unsigned int v25 = v24;
  }
  else {
    unsigned int v25 = a6;
  }
  return (unsigned __int16)(((HIWORD(v25) + (unsigned __int16)v25) >> 16)
                          + HIWORD(v25)
                          + v25
                          + ((((HIWORD(v25) + (unsigned __int16)v25) >> 16)
                            + (unsigned __int16)(HIWORD(v25) + v25)) >> 16));
}

uint64_t in6_pseudo(unsigned __int16 *a1, unsigned __int16 *a2, int a3)
{
  unsigned int v3 = *a1;
  int v4 = *a1;
  if (v4 == 255)
  {
    if ((((v3 >> 8) & 0xF) != 2 || (BYTE1(v3) & 0xF0) == 48) && (BYTE1(v3) & 0xF) != 1) {
      goto LABEL_4;
    }
  }
  else if (v4 != 254 || (BYTE1(v3) & 0xC0) != 0x80)
  {
LABEL_4:
    v3 += a1[1];
  }
  unsigned int v5 = *a2;
  unsigned int v6 = v3 + a1[2] + a1[3] + a1[4] + a1[5] + a1[6] + a1[7] + v5;
  int v7 = *a2;
  if (v7 != 255)
  {
    if (v7 == 254 && (BYTE1(v5) & 0xC0) == 0x80) {
      goto LABEL_25;
    }
LABEL_24:
    v6 += a2[1];
    goto LABEL_25;
  }
  BOOL v10 = ((v5 >> 8) & 0xF) != 2 || (BYTE1(v5) & 0xF0) == 48;
  if (v10 && (BYTE1(v5) & 0xF) != 1) {
    goto LABEL_24;
  }
LABEL_25:
  unsigned int v11 = vaddvq_s32((int32x4_t)vmovl_u16(*(uint16x4_t *)(a2 + 2))) + a2[6] + v6 + a2[7] + a3;
  return (unsigned __int16)(((HIWORD(v11) + (unsigned __int16)v11) >> 16)
                          + HIWORD(v11)
                          + v11
                          + ((((HIWORD(v11) + (unsigned __int16)v11) >> 16)
                            + (unsigned __int16)(HIWORD(v11) + v11)) >> 16));
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_52707()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

NWConcrete_nw_read_request *nw_read_request_create_multiple(unint64_t a1, unint64_t a2, void *a3, void *a4)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  id v8 = a3;
  id v9 = a4;
  if (v9)
  {
    if (a1 <= 1) {
      unint64_t v10 = 1;
    }
    else {
      unint64_t v10 = a1;
    }
    if (a2 >= 0x100) {
      unint64_t v11 = 256;
    }
    else {
      unint64_t v11 = a2;
    }
    if (v10 > v11)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v12 = (id)gLogObj;
      *(_DWORD *)long long buf = 136446722;
      uint64_t v46 = "nw_read_request_create_multiple";
      __int16 v47 = 2048;
      unint64_t v48 = v10;
      __int16 v49 = 2048;
      unint64_t v50 = v11;
      BOOL v13 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v43 = 0;
      if (!__nwlog_fault(v13, &type, &v43)) {
        goto LABEL_44;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (id)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)long long buf = 136446722;
          uint64_t v46 = "nw_read_request_create_multiple";
          __int16 v47 = 2048;
          unint64_t v48 = v10;
          __int16 v49 = 2048;
          unint64_t v50 = v11;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s min_data_count (%zu) > max_data_count (%zu)", buf, 0x20u);
        }
      }
      else if (v43)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (id)gLogObj;
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)long long buf = 136446978;
            uint64_t v46 = "nw_read_request_create_multiple";
            __int16 v47 = 2048;
            unint64_t v48 = v10;
            __int16 v49 = 2048;
            unint64_t v50 = v11;
            __int16 v51 = 2082;
            unint64_t v52 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s min_data_count (%zu) > max_data_count (%zu), dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(backtrace_string);
          if (!v13) {
            goto LABEL_46;
          }
          goto LABEL_45;
        }
        if (v26)
        {
          *(_DWORD *)long long buf = 136446722;
          uint64_t v46 = "nw_read_request_create_multiple";
          __int16 v47 = 2048;
          unint64_t v48 = v10;
          __int16 v49 = 2048;
          unint64_t v50 = v11;
          _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s min_data_count (%zu) > max_data_count (%zu), no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = (id)gLogObj;
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)long long buf = 136446722;
          uint64_t v46 = "nw_read_request_create_multiple";
          __int16 v47 = 2048;
          unint64_t v48 = v10;
          __int16 v49 = 2048;
          unint64_t v50 = v11;
          _os_log_impl(&dword_1830D4000, v14, v31, "%{public}s min_data_count (%zu) > max_data_count (%zu), backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_43;
    }
    uint64_t v16 = objc_alloc_init(NWConcrete_nw_read_request);
    if (v16)
    {
      unint64_t v17 = _Block_copy(v9);
      id data_multiple_completion = v16->data_multiple_completion;
      v16->id data_multiple_completion = v17;

      objc_storeStrong((id *)&v16->connection, a3);
      v16->qos_class = qos_class_self();
      v16->min = v10;
      v16->max = v11;
      BOOL v19 = nw_array_create();
      read_array = v16->read_array;
      v16->read_array = (OS_nw_array *)v19;

      BOOL v21 = nw_array_create();
      context_array = v16->context_array;
      v16->context_array = (OS_nw_array *)v21;

      v16->variant = 3;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
      unsigned int v23 = v16;
      goto LABEL_55;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (id)gLogObj;
    *(_DWORD *)long long buf = 136446210;
    uint64_t v46 = "nw_read_request_create_multiple";
    unsigned int v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v28, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32x4_t v29 = (id)gLogObj;
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v46 = "nw_read_request_create_multiple";
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v43)
      {
        uint64_t v32 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32x4_t v29 = (id)gLogObj;
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v29, type);
        if (v32)
        {
          if (v34)
          {
            *(_DWORD *)long long buf = 136446466;
            uint64_t v46 = "nw_read_request_create_multiple";
            __int16 v47 = 2082;
            unint64_t v48 = (unint64_t)v32;
            _os_log_impl(&dword_1830D4000, v29, v33, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v32);
          if (!v28) {
            goto LABEL_55;
          }
          goto LABEL_54;
        }
        if (v34)
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v46 = "nw_read_request_create_multiple";
          _os_log_impl(&dword_1830D4000, v29, v33, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint32x4_t v29 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v29, type))
        {
          *(_DWORD *)long long buf = 136446210;
          uint64_t v46 = "nw_read_request_create_multiple";
          _os_log_impl(&dword_1830D4000, v29, v35, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v28)
    {
LABEL_55:

      goto LABEL_56;
    }
LABEL_54:
    free(v28);
    goto LABEL_55;
  }
  unint64_t v37 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v46 = "nw_read_request_create_multiple";
  BOOL v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (__nwlog_fault(v13, &type, &v43))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_1830D4000, v14, v38, "%{public}s called with null completion", buf, 0xCu);
      }
LABEL_43:

      goto LABEL_44;
    }
    if (!v43)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_1830D4000, v14, v42, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_43;
    }
    uint64_t v39 = (char *)__nw_create_backtrace_string();
    uint64_t v14 = __nwlog_obj();
    os_log_type_t v40 = type;
    BOOL v41 = os_log_type_enabled(v14, type);
    if (!v39)
    {
      if (v41)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v46 = "nw_read_request_create_multiple";
        _os_log_impl(&dword_1830D4000, v14, v40, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_43;
    }
    if (v41)
    {
      *(_DWORD *)long long buf = 136446466;
      uint64_t v46 = "nw_read_request_create_multiple";
      __int16 v47 = 2082;
      unint64_t v48 = (unint64_t)v39;
      _os_log_impl(&dword_1830D4000, v14, v40, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v39);
  }
LABEL_44:
  if (v13) {
LABEL_45:
  }
    free(v13);
LABEL_46:
  uint64_t v16 = 0;
LABEL_56:

  return v16;
}

void sub_183A9DA04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_read_request_get_maximum_datagram_count(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  unsigned int v2 = v1;
  if (v1)
  {
    if (*((_DWORD *)v1 + 17) == 3)
    {
      uint64_t v3 = v1[10];
    }
    else
    {
      maximum_datagram_size_t count = v1[1];
      if (maximum_datagram_count) {
        maximum_datagram_size_t count = nw_read_request_get_maximum_datagram_count();
      }
      uint64_t v3 = maximum_datagram_count + 1;
    }
    goto LABEL_7;
  }
  unsigned int v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null request", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = "nw_read_request_get_maximum_datagram_count";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0;
LABEL_7:

  return v3;
}

void sub_183A9DCDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_read_request_fail(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  if (v3)
  {
    posix_CFErrorRef error = nw_error_create_posix_error(a2);
    unsigned int v5 = (void *)v3[19];
    v3[19] = posix_error;

    nw_read_request_report(v3, 0);
    goto LABEL_3;
  }
  unsigned int v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  unint64_t v17 = "nw_read_request_fail";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = "nw_read_request_fail";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null request", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          unint64_t v17 = "nw_read_request_fail";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = "nw_read_request_fail";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null request, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        unint64_t v17 = "nw_read_request_fail";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_183A9DFA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2(void *a1, unint64_t a2, void *a3)
{
  id v6 = a3;
  objc_storeStrong((id *)(*(void *)(*(void *)(a1[5] + 8) + 24) + 8 * a2), a3);
  if (a1[7] == a1[8])
  {
    uint64_t v7 = nw_array_get_object_at_index(*(void *)(a1[4] + 168), a2);
    uint64_t v8 = *(void *)(*(void *)(a1[6] + 8) + 24);
    os_log_type_t v9 = *(void **)(v8 + 8 * a2);
    *(void *)(v8 + 8 * a2) = v7;
  }
  return 1;
}

void ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_105(void *a1)
{
  (*(void (**)(void))(a1[5] + 16))();
  unsigned int v2 = *(void **)(*(void *)(a1[6] + 8) + 24);
  if (v2 || *(void *)(*(void *)(a1[7] + 8) + 24))
  {
    if (a1[8])
    {
      unint64_t v3 = 0;
      do
      {
        uint64_t v4 = *(void *)(*(void *)(a1[6] + 8) + 24);
        if (v4)
        {
          unsigned int v5 = *(void **)(v4 + 8 * v3);
          if (v5)
          {
            *(void *)(v4 + 8 * v3) = 0;
          }
        }
        uint64_t v6 = *(void *)(*(void *)(a1[7] + 8) + 24);
        if (v6)
        {
          uint64_t v7 = *(void **)(v6 + 8 * v3);
          if (v7)
          {
            *(void *)(v6 + 8 * v3) = 0;
          }
        }
        ++v3;
      }
      while (v3 < a1[8]);
      unsigned int v2 = *(void **)(*(void *)(a1[6] + 8) + 24);
    }
    if (v2)
    {
      free(v2);
      *(void *)(*(void *)(a1[6] + 8) + 24) = 0;
    }
    uint64_t v8 = *(void **)(*(void *)(a1[7] + 8) + 24);
    if (v8)
    {
      free(v8);
      *(void *)(*(void *)(a1[7] + 8) + 24) = 0;
    }
  }
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_106(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40), *(unsigned int *)(a1 + 48));
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_107(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(void *)(*(void *)(a1 + 32) + 88), *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 64), *(void *)(a1 + 48));
}

uint64_t __Block_byref_object_copy__52816(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__52817(uint64_t a1)
{
}

uint64_t __nw_read_request_receive_block_invoke(uint64_t a1, void *a2, uint64_t a3, uint64_t a4, unsigned int a5)
{
  id v9 = a2;
  if (*(_DWORD *)(a1 + 72) < a5) {
    a5 = *(_DWORD *)(a1 + 72);
  }
  uint64_t v24 = 0;
  os_log_type_t v25 = &v24;
  uint64_t v26 = 0x2020000000;
  uint64_t v27 = 0;
  unint64_t v10 = *(void **)(*(void *)(a1 + 32) + 96);
  v22[0] = MEMORY[0x1E4F143A8];
  v22[1] = 3221225472;
  v22[2] = __nw_read_request_receive_block_invoke_2;
  v22[3] = &unk_1E5243EE8;
  v22[4] = &v24;
  v22[5] = a4;
  unsigned int v23 = a5;
  nw_fd_wrapper_get_fd(v10, v22);
  unint64_t v11 = v25[3];
  if (v11)
  {
    if (v11 == -1)
    {
      posix_CFErrorRef error = nw_error_create_posix_error(**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8));
      uint64_t v13 = *(void *)(a1 + 32);
      char v14 = *(void **)(v13 + 152);
      *(void *)(v13 + 152) = posix_error;

      nw_read_request_report(*(void **)(a1 + 32), 0);
      uint64_t v15 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v16 = *(void **)(v15 + 40);
      *(void *)(v15 + 40) = 0;

      uint64_t v17 = 0;
    }
    else if (v11 >= a5)
    {
      *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += v11;
      uint64_t v17 = 1;
    }
    else
    {
      dispatch_data_t subrange = dispatch_data_create_subrange(*(dispatch_data_t *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), v11 + a3, *(void *)(a1 + 64) - (v11 + a3));
      uint64_t v19 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v20 = *(void **)(v19 + 40);
      *(void *)(v19 + 40) = subrange;

      uint64_t v17 = 0;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += *((_DWORD *)v25 + 6);
      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) = 1;
    }
  }
  else
  {
    uint64_t v17 = 0;
    *(unsigned char *)(*(void *)(a1 + 32) + 176) |= 8u;
  }
  _Block_object_dispose(&v24, 8);

  return v17;
}

void sub_183A9E390(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke(uint64_t a1)
{
  WeakRetained = (const void **)objc_loadWeakRetained((id *)(a1 + 32));
  unsigned int v2 = WeakRetained;
  if (WeakRetained)
  {
    unint64_t v3 = _Block_copy(WeakRetained[4]);
    uint64_t v4 = v3;
    if (v3)
    {
      unsigned int v5 = (void *)v2[7];
      dispatch_qos_class_t v6 = *((_DWORD *)v2 + 16);
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      v7[2] = ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke_2;
      v7[3] = &unk_1E524B950;
      id v9 = v3;
      uint64_t v8 = v2;
      nw_connection_async_client_if_needed_with_override(v5, 0, v6, v7);
    }
  }
}

void sub_183A9E490(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke_2(uint64_t a1)
{
  if (((*(uint64_t (**)(void))(*(void *)(a1 + 40) + 16))() & 1) == 0)
  {
    unsigned int v2 = *(void **)(a1 + 32);
    unint64_t v3 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 89);
    nw_read_request_report_error_with_override(v2, 0, v3);
  }
}

void sub_183A9E558(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_read_request_receive_block_invoke_2(uint64_t a1, int __fd)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = write(__fd, *(const void **)(a1 + 40), *(unsigned int *)(a1 + 48));
  return 1;
}

void __nw_http_alt_svc_storage_copy_shared_block_invoke()
{
  uint64_t v0 = objc_alloc_init(NWConcrete_nw_http_alt_svc_storage);
  unsigned int v1 = (void *)nw_http_alt_svc_storage_copy_shared_storage;
  nw_http_alt_svc_storage_copy_shared_storage = (uint64_t)v0;

  uint64_t v2 = [MEMORY[0x1E4F18E40] sharedPersistentStore];
  unint64_t v3 = *(void **)(nw_http_alt_svc_storage_copy_shared_storage + 8);
  *(void *)(nw_http_alt_svc_storage_copy_shared_storage + _Block_object_dispose(&a9, 8) = v2;
}

NWConcrete_nw_http_alt_svc_storage *nw_http_alt_svc_storage_create_ns(void *a1)
{
  unsigned int v1 = a1;
  uint64_t v2 = objc_alloc_init(NWConcrete_nw_http_alt_svc_storage);
  storage = v2->storage;
  v2->storage = v1;

  return v2;
}

void nw_http_alt_svc_parse_and_set(void *a1, const char *a2, unsigned int a3, const char *a4, const char *a5, void *a6)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v73 = a6;
  unint64_t v74 = v9;
  if (!v9)
  {
    uint64_t v53 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    unsigned int v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (!__nwlog_fault(v54, &v78, &v77)) {
      goto LABEL_108;
    }
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      unsigned int v55 = __nwlog_obj();
      os_log_type_t v56 = v78;
      if (!os_log_type_enabled(v55, v78)) {
        goto LABEL_107;
      }
      *(_DWORD *)long long buf = 136446210;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      uint32x4_t v57 = "%{public}s called with null storage";
LABEL_106:
      _os_log_impl(&dword_1830D4000, v55, v56, v57, buf, 0xCu);
      goto LABEL_107;
    }
    if (!v77)
    {
      unsigned int v55 = __nwlog_obj();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null storage, backtrace limit exceeded";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned __int32 v61 = __nwlog_obj();
    os_log_type_t v62 = v78;
    BOOL v63 = os_log_type_enabled(v61, v78);
    if (backtrace_string)
    {
      if (!v63) {
        goto LABEL_98;
      }
      *(_DWORD *)long long buf = 136446466;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      __int16 v81 = 2082;
      uint64_t v82 = backtrace_string;
      unsigned int v64 = "%{public}s called with null storage, dumping backtrace:%{public}s";
      goto LABEL_97;
    }
    if (!v63) {
      goto LABEL_117;
    }
    *(_DWORD *)long long buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v67 = "%{public}s called with null storage, no backtrace";
LABEL_116:
    _os_log_impl(&dword_1830D4000, v61, v62, v67, buf, 0xCu);
    goto LABEL_117;
  }
  if (!a2)
  {
    uint32x4_t v58 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    unsigned int v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (!__nwlog_fault(v54, &v78, &v77)) {
      goto LABEL_108;
    }
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      unsigned int v55 = __nwlog_obj();
      os_log_type_t v56 = v78;
      if (!os_log_type_enabled(v55, v78)) {
        goto LABEL_107;
      }
      *(_DWORD *)long long buf = 136446210;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      uint32x4_t v57 = "%{public}s called with null hostname";
      goto LABEL_106;
    }
    if (!v77)
    {
      unsigned int v55 = __nwlog_obj();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned __int32 v61 = __nwlog_obj();
    os_log_type_t v62 = v78;
    BOOL v65 = os_log_type_enabled(v61, v78);
    if (backtrace_string)
    {
      if (!v65) {
        goto LABEL_98;
      }
      *(_DWORD *)long long buf = 136446466;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      __int16 v81 = 2082;
      uint64_t v82 = backtrace_string;
      unsigned int v64 = "%{public}s called with null hostname, dumping backtrace:%{public}s";
      goto LABEL_97;
    }
    if (!v65) {
      goto LABEL_117;
    }
    *(_DWORD *)long long buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    uint64_t v67 = "%{public}s called with null hostname, no backtrace";
    goto LABEL_116;
  }
  if (!a3)
  {
    uint64_t v59 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
    unsigned int v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (!__nwlog_fault(v54, &v78, &v77)) {
      goto LABEL_108;
    }
    if (v78 == OS_LOG_TYPE_FAULT)
    {
      unsigned int v55 = __nwlog_obj();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null port";
        goto LABEL_106;
      }
LABEL_107:

LABEL_108:
      if (!v54) {
        goto LABEL_72;
      }
LABEL_109:
      free(v54);
      goto LABEL_72;
    }
    if (!v77)
    {
      unsigned int v55 = __nwlog_obj();
      os_log_type_t v56 = v78;
      if (os_log_type_enabled(v55, v78))
      {
        *(_DWORD *)long long buf = 136446210;
        unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
        uint32x4_t v57 = "%{public}s called with null port, backtrace limit exceeded";
        goto LABEL_106;
      }
      goto LABEL_107;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned __int32 v61 = __nwlog_obj();
    os_log_type_t v62 = v78;
    BOOL v66 = os_log_type_enabled(v61, v78);
    if (backtrace_string)
    {
      if (!v66) {
        goto LABEL_98;
      }
      *(_DWORD *)long long buf = 136446466;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      __int16 v81 = 2082;
      uint64_t v82 = backtrace_string;
      unsigned int v64 = "%{public}s called with null port, dumping backtrace:%{public}s";
LABEL_97:
      _os_log_impl(&dword_1830D4000, v61, v62, v64, buf, 0x16u);
LABEL_98:

      free(backtrace_string);
      if (!v54) {
        goto LABEL_72;
      }
      goto LABEL_109;
    }
    if (v66)
    {
      *(_DWORD *)long long buf = 136446210;
      unsigned __int32 v80 = "nw_http_alt_svc_parse_and_set";
      uint64_t v67 = "%{public}s called with null port, no backtrace";
      goto LABEL_116;
    }
LABEL_117:

    if (!v54) {
      goto LABEL_72;
    }
    goto LABEL_109;
  }
  size_t v10 = strlen(a4);
  CFAllocatorRef alloc = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  unint64_t v11 = (__CFString *)CFStringCreateWithCString((CFAllocatorRef)*MEMORY[0x1E4F1CF80], a2, 0x8000100u);
  if (!strcmp(a4, "clear"))
  {
    [v74[1] removeHTTPAlternativeServiceEntriesWithHost:v11 port:a3];
  }
  else
  {
    unint64_t v68 = v11;
    id v12 = objc_alloc_init(MEMORY[0x1E4F18E30]);
    if (v10 != -1)
    {
      cStr = (char *)a2;
      uint64_t v13 = 0;
      uint64_t v69 = a3;
      int v14 = 2;
      uint64_t v15 = MEMORY[0x1E4F14390];
      uint64_t v16 = a4;
      size_t v75 = v10;
      while (1)
      {
        __int16 v18 = &a4[v13];
        unsigned int v19 = a4[v13];
        if (v19 == 61)
        {
          const char *v18 = 0;
          uint64_t v20 = (char *)(v16 - 1);
          do
          {
            while (1)
            {
              unsigned int v22 = v20;
              int v23 = v20[1];
              int v24 = v20[1];
              if ((v23 & 0x80000000) == 0) {
                break;
              }
              if (!__maskrune(*++v20, 0x4000uLL)) {
                goto LABEL_15;
              }
            }
            ++v20;
          }
          while ((*(_DWORD *)(v15 + 4 * v23 + 60) & 0x4000) != 0);
LABEL_15:
          if (v24)
          {
            os_log_type_t v25 = &v22[strlen(v20)];
            while (1)
            {
              uint64_t v27 = v25;
              if (v25 <= v20) {
                break;
              }
              uint64_t v28 = *v25;
              if (*v25 < 0)
              {
                int v26 = __maskrune(v28, 0x4000uLL);
                os_log_type_t v25 = v27 - 1;
                if (!v26) {
                  break;
                }
              }
              else
              {
                --v25;
                if ((*(_DWORD *)(v15 + 4 * v28 + 60) & 0x4000) == 0) {
                  break;
                }
              }
            }
            v27[1] = 0;
          }
          __int16 v18 = &a4[v13];
          uint64_t v16 = &a4[v13 + 1];
          if (!strcmp(v20, "h3"))
          {
            [v12 setServiceType:1];
            uint32x4_t v29 = (__CFString *)CFStringCreateWithCString(alloc, cStr, 0x8000100u);
            [v12 setHost:v29];

            [v12 setPort:v69];
            if (a5)
            {
              os_log_type_t v30 = (__CFString *)CFStringCreateWithCString(alloc, a5, 0x8000100u);
              os_log_type_t v31 = [MEMORY[0x1E4F1CB10] URLWithString:v30];
              uint64_t v32 = [v31 host];
              [v12 setPartition:v32];
            }
            int v14 = 0;
            __int16 v18 = &a4[v13];
          }
          else if (!strcmp(v20, "ma"))
          {
            int v14 = 1;
          }
          else
          {
            int v14 = 2;
          }
        }
        BOOL v33 = v19 > 0x3B || ((1 << v19) & 0x800100000000001) == 0;
        if (v33) {
          goto LABEL_9;
        }
        const char *v18 = 0;
        BOOL v34 = v16 - 1;
        do
        {
          unint64_t v36 = v16;
          unint64_t v37 = v34;
          int v38 = *(unsigned __int8 *)v16;
          if (*v16 < 0) {
            int v35 = __maskrune(*(unsigned __int8 *)v16, 0x4000uLL);
          }
          else {
            int v35 = *(_DWORD *)(v15 + 4 * *(unsigned __int8 *)v16 + 60) & 0x4000;
          }
          ++v16;
          ++v34;
        }
        while (v35);
        if (v38)
        {
          uint64_t v39 = (char *)&v37[strlen(v36)];
          while (1)
          {
            BOOL v41 = v39;
            if (v39 <= v36) {
              break;
            }
            uint64_t v42 = *v39;
            if (*v39 < 0)
            {
              int v40 = __maskrune(v42, 0x4000uLL);
              uint64_t v39 = v41 - 1;
              if (!v40) {
                break;
              }
            }
            else
            {
              --v39;
              if ((*(_DWORD *)(v15 + 4 * v42 + 60) & 0x4000) == 0) {
                break;
              }
            }
          }
          v41[1] = 0;
        }
        if (v14 == 1) {
          break;
        }
        char v43 = &a4[v13];
        if (!v14)
        {
          id v44 = v12;
          size_t v45 = strlen(v36);
          if (v45 >= 2 && *v36 == 34 && v36[v45 - 1] == 34)
          {
            if (v45 == -1)
            {
LABEL_54:
              uint64_t v46 = 0;
            }
            else
            {
              uint64_t v46 = 0;
              while (v34[v46] != 58)
              {
                if (v45 + 1 == ++v46) {
                  goto LABEL_54;
                }
              }
            }
            v36[v46] = 0;
            __int16 v47 = &v36[v46 + 1];
            v36[v45 - 1] = 0;
            if (*v16)
            {
              uint64_t v48 = (uint64_t)CFStringCreateWithCString(alloc, v36 + 1, 0x8000100u);
            }
            else
            {
              uint64_t v48 = [v44 host];
            }
            __int16 v51 = (void *)v48;
            [v44 setAlternateHost:v48];

            if (*v47) {
              uint64_t v52 = atoi(v47);
            }
            else {
              uint64_t v52 = [v44 port];
            }
            char v43 = &a4[v13];
            [v44 setAlternatePort:v52];
          }
          goto LABEL_61;
        }
LABEL_62:
        uint64_t v16 = v43 + 1;
        if (v19 == 44)
        {
          check_certs_and_store_entry(v74, v12, v73);
          id v17 = objc_alloc_init(MEMORY[0x1E4F18E30]);

          int v14 = 2;
          id v12 = v17;
        }
        else
        {
          int v14 = 2;
        }
        size_t v10 = v75;
LABEL_9:
        BOOL v33 = v13++ == v10;
        if (v33) {
          goto LABEL_69;
        }
      }
      int v49 = atoi(v36);
      if (v49 >= 604800) {
        int v50 = 604800;
      }
      else {
        int v50 = v49;
      }
      id v44 = [MEMORY[0x1E4F1C9C8] dateWithTimeIntervalSinceNow:(double)v50];
      [v12 setExpirationDate:v44];
      char v43 = &a4[v13];
LABEL_61:

      goto LABEL_62;
    }
LABEL_69:
    check_certs_and_store_entry(v74, v12, v73);

    unint64_t v11 = v68;
  }

LABEL_72:
}

void check_certs_and_store_entry(void *a1, void *a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = a1;
  id v6 = a2;
  id v7 = a3;
  CFMutableArrayRef Mutable = CFArrayCreateMutable((CFAllocatorRef)*MEMORY[0x1E4F1CF80], 0, MEMORY[0x1E4F1D510]);
  id v9 = v7;
  handler[0] = MEMORY[0x1E4F143A8];
  handler[1] = 3221225472;
  handler[2] = __check_certs_and_store_entry_block_invoke;
  handler[3] = &__block_descriptor_40_e38_v16__0__NSObject_OS_sec_certificate__8l;
  handler[4] = Mutable;
  sec_protocol_metadata_access_peer_certificate_chain(v9, handler);
  size_t v10 = [v6 alternateHost];
  long long v38 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  long long v41 = 0u;
  unint64_t v11 = Mutable;
  uint64_t v31 = [(__CFArray *)v11 countByEnumeratingWithState:&v38 objects:buf count:16];
  if (v31)
  {
    uint64_t v12 = *(void *)v39;
    id v29 = v6;
    os_log_type_t v30 = v5;
    uint64_t v27 = *(void *)v39;
    uint64_t v28 = v9;
    uint64_t v32 = v11;
    do
    {
      for (uint64_t i = 0; i != v31; ++i)
      {
        if (*(void *)v39 != v12) {
          objc_enumerationMutation(v11);
        }
        int v14 = (void *)SecCertificateCopyDNSNames();
        long long v34 = 0u;
        long long v35 = 0u;
        long long v36 = 0u;
        long long v37 = 0u;
        id v15 = v14;
        uint64_t v16 = [v15 countByEnumeratingWithState:&v34 objects:v42 count:16];
        if (v16)
        {
          uint64_t v17 = v16;
          uint64_t v18 = *(void *)v35;
          while (2)
          {
            for (uint64_t j = 0; j != v17; ++j)
            {
              if (*(void *)v35 != v18) {
                objc_enumerationMutation(v15);
              }
              uint64_t v20 = *(void **)(*((void *)&v34 + 1) + 8 * j);
              if ([v20 isEqualToString:v10]) {
                goto LABEL_26;
              }
              if ([v20 hasPrefix:@"*"]
                && (unint64_t)[v20 length] >= 2)
              {
                BOOL v21 = [v20 substringFromIndex:1];
                uint64_t v22 = [v10 rangeOfString:@"."];
                if (v23)
                {
                  int v24 = [v10 substringFromIndex:v22];
                  char v25 = [v24 isEqualToString:v21];

                  if (v25)
                  {

LABEL_26:
                    unint64_t v11 = v32;

                    id v6 = v29;
                    unsigned int v5 = v30;
                    [v30[1] storeHTTPServiceEntry:v29];
                    id v9 = v28;
                    goto LABEL_27;
                  }
                }
              }
            }
            uint64_t v17 = [v15 countByEnumeratingWithState:&v34 objects:v42 count:16];
            if (v17) {
              continue;
            }
            break;
          }
        }

        unint64_t v11 = v32;
        uint64_t v12 = v27;
      }
      id v6 = v29;
      unsigned int v5 = v30;
      id v9 = v28;
      uint64_t v31 = [(__CFArray *)v32 countByEnumeratingWithState:&v38 objects:buf count:16];
    }
    while (v31);
  }

  if (gLogDatapath)
  {
    int v26 = __nwlog_obj();
    if (os_log_type_enabled(v26, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446210;
      id v44 = "check_certs_and_store_entry";
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s Ignoring the alternative service header since it is not covered under the setting origin's certificate", buf, 0xCu);
    }
  }
LABEL_27:
  if (v11) {
    CFRelease(v11);
  }
}

void __check_certs_and_store_entry_block_invoke(uint64_t a1, sec_certificate_t certificate)
{
  SecCertificateRef v3 = sec_certificate_copy_ref(certificate);
  CFArrayAppendValue(*(CFMutableArrayRef *)(a1 + 32), v3);
  if (v3)
  {
    CFRelease(v3);
  }
}

uint64_t __Block_byref_object_copy__53012(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__53013(uint64_t a1)
{
}

uint64_t ___ZL35nw_ip_channel_inbox_input_availableP11nw_protocolS0__block_invoke(uint64_t a1, void *a2)
{
  SecCertificateRef v3 = a2;
  uint64_t v4 = v3;
  uint64_t v5 = v3[4];
  id v6 = (void *)v3[5];
  if (v5)
  {
    *(void *)(v5 + 40) = v6;
    id v6 = (void *)v3[5];
  }
  else
  {
    *(void *)(*(void *)(a1 + 48) + _Block_object_dispose(&a9, 8) = v6;
  }
  void *v6 = v5;
  void v3[4] = 0;
  void v3[5] = 0;
  nw_ip_channel_inbox_handle_input_frame(*(void **)(a1 + 32), *(void *)(a1 + 56), v3, *(void **)(a1 + 40), *(unsigned __int8 **)(a1 + 64));

  return 1;
}

void sub_183A9F600(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ip_channel_inbox_handle_input_frame(void *a1, uint64_t a2, void *a3, void *a4, unsigned __int8 *a5)
{
  uint64_t v249 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v10 = a3;
  object = a4;
  memset(__src, 0, 28);
  memset(__dst, 0, 28);
  int v11 = *((_DWORD *)v9 + 14);
  if (v11 != 2)
  {
    int v225 = *((unsigned __int8 *)v9 + 166);
    uint64_t v20 = (unsigned __int8 *)v9[19];
    if (v20)
    {
      memcpy(__dst, v9[19], *v20);
      BOOL v21 = 0;
      BOOL v22 = 0;
      int v23 = 0;
      if (v20[1] == 2) {
        __int16 v24 = 528;
      }
      else {
        __int16 v24 = 7708;
      }
      *(_WORD *)&__src[0].os_log_type_t sa_len = v24;
    }
    else
    {
      BOOL v21 = 0;
      BOOL v22 = 0;
      int v23 = 0;
    }
    goto LABEL_14;
  }
  int v12 = *((_DWORD *)v9 + 40);
  LODWORD(v236) = 0;
  uint64_t v13 = (unsigned __int8 *)nw_frame_unclaimed_bytes((uint64_t)v10, &v236);
  if (!v236) {
    goto LABEL_324;
  }
  int v14 = *v13 >> 4;
  if (v14 != 6)
  {
    if (v14 != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_324;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_ip_parse";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v14;
      unsigned int v19 = "%{public}s Unknown IP version: %u";
      goto LABEL_38;
    }
    *(_DWORD *)uint64_t address = 0;
    uint64_t v15 = nw_frame_unclaimed_bytes((uint64_t)v10, address);
    uint64_t v248 = 0;
    memset(&buf[20], 0, 32);
    int v17 = *(_DWORD *)address;
    if (*(_DWORD *)address <= 0x13u)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int v243 = 136446466;
        *(void *)&v243[4] = "ipv4_parse";
        *(_WORD *)&v243[12] = 1024;
        *(_DWORD *)&v243[14] = *(_DWORD *)address;
        unsigned int v19 = "%{public}s Received IPv4 packet with incorrect length %u";
LABEL_110:
        BOOL v33 = v243;
        goto LABEL_111;
      }
      goto LABEL_324;
    }
    *(_OWORD *)long long buf = *(_OWORD *)v15;
    *(_DWORD *)&buf[16] = *(_DWORD *)(v15 + 16);
    unsigned int v34 = 4 * (buf[0] & 0xF);
    if (v34 < 0x14 || *(_DWORD *)address < v34)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int v243 = 136446466;
        *(void *)&v243[4] = "ipv4_parse";
        *(_WORD *)&v243[12] = 1024;
        *(_DWORD *)&v243[14] = v34;
        unsigned int v19 = "%{public}s Invalid IPv4 header length: %u";
        goto LABEL_110;
      }
LABEL_324:
      nw_frame_finalize((uint64_t)v10);
      goto LABEL_325;
    }
    int v35 = *(unsigned __int16 *)&buf[10];
    *(_WORD *)&buf[10] = 0;
    long long v36 = buf;
    if (v34 - 2 >= 0xE)
    {
      uint64_t v57 = ((v34 - 2) >> 1) + 1;
      uint32x4_t v58 = (uint16x4_t *)&buf[8];
      int32x4_t v59 = 0uLL;
      uint64_t v60 = v57 & 0xFFFFFFF8;
      int32x4_t v61 = 0uLL;
      do
      {
        int32x4_t v59 = (int32x4_t)vaddw_u16((uint32x4_t)v59, v58[-1]);
        int32x4_t v61 = (int32x4_t)vaddw_u16((uint32x4_t)v61, *v58);
        v58 += 2;
        v60 -= 8;
      }
      while (v60);
      unsigned int v37 = vaddvq_s32(vaddq_s32(v61, v59));
      if ((v57 & 0xFFFFFFF8) == v57) {
        goto LABEL_85;
      }
      long long v36 = &buf[2 * (v57 & 0xFFFFFFF8)];
      int v38 = v34 - 2 * (v57 & 0xFFFFFFF8);
    }
    else
    {
      unsigned int v37 = 0;
      int v38 = 4 * (buf[0] & 0xF);
    }
    unsigned int v62 = v38 + 2;
    do
    {
      int v63 = *(unsigned __int16 *)v36;
      v36 += 2;
      v37 += v63;
      v62 -= 2;
    }
    while (v62 > 3);
LABEL_85:
    if (v35 != (unsigned __int16)~(HIWORD(v37) + v37 + ((HIWORD(v37) + (unsigned __int16)v37) >> 16)))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v18 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)int v243 = 136446466;
        *(void *)&v243[4] = "ipv4_parse";
        *(_WORD *)&v243[12] = 1024;
        *(_DWORD *)&v243[14] = v35;
        unsigned int v19 = "%{public}s Invalid ipv4 header checksum 0x%x";
        goto LABEL_110;
      }
      goto LABEL_324;
    }
    unsigned int v64 = bswap32(*(unsigned __int16 *)&buf[2]) >> 16;
    if (*(_DWORD *)address < v64)
    {
      uint64_t v42 = __nwlog_obj();
      if (!os_log_type_enabled(v42, OS_LOG_TYPE_INFO)) {
        goto LABEL_324;
      }
      *(_DWORD *)int v243 = 136446722;
      *(void *)&v243[4] = "ipv4_parse";
      *(_WORD *)&v243[12] = 1024;
      *(_DWORD *)&v243[14] = v64;
      *(_WORD *)&v243[18] = 1024;
      *(_DWORD *)&v243[20] = *(_DWORD *)address;
      char v43 = "%{public}s Received IPv4 packet with incorrect length, expected %u received %u";
      id v44 = v243;
      goto LABEL_46;
    }
    if (*(_DWORD *)address > v64)
    {
      if (gLogDatapath)
      {
        uint64_t v185 = __nwlog_obj();
        BOOL v186 = os_log_type_enabled(v185, OS_LOG_TYPE_DEBUG);
        int v17 = *(_DWORD *)address;
        if (v186)
        {
          *(_DWORD *)int v243 = 136446722;
          *(void *)&v243[4] = "ipv4_parse";
          *(_WORD *)&v243[12] = 1024;
          *(_DWORD *)&v243[14] = v64;
          *(_WORD *)&v243[18] = 1024;
          *(_DWORD *)&v243[20] = *(_DWORD *)address;
          _os_log_impl(&dword_1830D4000, v185, OS_LOG_TYPE_DEBUG, "%{public}s Received length mismatch with IP total length %u != %u", v243, 0x18u);
          int v17 = *(_DWORD *)address;
        }
      }
      nw_frame_claim((uint64_t)v10, v16, 0, v17 - v64);
    }
    if ((buf[12] & 0xF0) == 0xE0)
    {
      unsigned __int32 v80 = __nwlog_obj();
      if (!os_log_type_enabled(v80, OS_LOG_TYPE_INFO)) {
        goto LABEL_324;
      }
      *(_DWORD *)int v243 = 136446210;
      *(void *)&v243[4] = "ipv4_parse";
      size_t v75 = "%{public}s Invalid source address";
      uint32x4_t v76 = v243;
      goto LABEL_120;
    }
    BOOL v21 = (*(_WORD *)&buf[6] & 0xFF3F) != 0;
    unsigned __int16 v125 = *(_WORD *)&buf[4];
    if ((*(_WORD *)&buf[6] & 0xFF3F) == 0) {
      unsigned __int16 v125 = 0;
    }
    int v23 = v125;
    BOOL v22 = *(unsigned __int16 *)&buf[6] == 32;
    int v225 = buf[9];
    *(_WORD *)__src[0].sa_data = 0;
    *(void *)&__src[0].sa_data[6] = 0;
    *(_WORD *)&__src[0].os_log_type_t sa_len = 528;
    *(_DWORD *)&__src[0].sa_data[2] = *(_DWORD *)&buf[12];
    *(_DWORD *)&__dst[0].os_log_type_t sa_len = 528;
    *(void *)&__dst[0].sa_data[6] = 0;
    *(_DWORD *)&__dst[0].sa_data[2] = *(_DWORD *)&buf[16];
    uint64_t v82 = (uint64_t)v10;
    int v83 = v34;
    goto LABEL_214;
  }
  *(_DWORD *)int v243 = 0;
  uint64_t v30 = nw_frame_unclaimed_bytes((uint64_t)v10, v243);
  int v32 = *(_DWORD *)v243;
  if (*(_DWORD *)v243 <= 0x27u)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v18 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_324;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = *(_DWORD *)v243;
    unsigned int v19 = "%{public}s Received IPv6 packet with incorrect length %u";
    goto LABEL_38;
  }
  uint64_t v39 = v30;
  uint64_t v40 = bswap32(*(unsigned __int16 *)(v30 + 4)) >> 16;
  int v41 = v40 + 40;
  if ((v40 + 40) > *(_DWORD *)v243)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v42 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_324;
    }
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v41;
    *(_WORD *)&buf[18] = 1024;
    *(_DWORD *)&buf[20] = *(_DWORD *)v243;
    char v43 = "%{public}s Received IPv6 packet with incorrect length, expected %u received %u";
    id v44 = buf;
LABEL_46:
    _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_INFO, v43, v44, 0x18u);
    goto LABEL_324;
  }
  if (v40 + 80 < (unint64_t)*(unsigned int *)v243)
  {
    if (gLogDatapath)
    {
      uint64_t v179 = __nwlog_obj();
      BOOL v180 = os_log_type_enabled(v179, OS_LOG_TYPE_DEBUG);
      int v32 = *(_DWORD *)v243;
      if (v180)
      {
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "ipv6_parse";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v41;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = *(_DWORD *)v243;
        _os_log_impl(&dword_1830D4000, v179, OS_LOG_TYPE_DEBUG, "%{public}s Received length mismatch with IPv6 %u != %u", buf, 0x18u);
        int v32 = *(_DWORD *)v243;
      }
    }
    nw_frame_claim((uint64_t)v10, v31, 0, v32 - v41);
  }
  int v225 = *(unsigned __int8 *)(v39 + 6);
  if (v225 == 44)
  {
    BOOL v22 = *(unsigned __int16 *)(v39 + 42) == 256;
    int v23 = *(_DWORD *)(v39 + 44);
    int v225 = *(unsigned __int8 *)(v39 + 40);
    BOOL v21 = 1;
  }
  else
  {
    BOOL v21 = 0;
    BOOL v22 = 0;
    int v23 = 0;
  }
  int v65 = *(_DWORD *)(v39 + 8);
  int v66 = *(_DWORD *)(v39 + 12);
  int v67 = *(_DWORD *)(v39 + 16);
  if (*(void *)(v39 + 8)) {
    BOOL v68 = 0;
  }
  else {
    BOOL v68 = v67 == -65536;
  }
  int v69 = v68;
  if (*(unsigned char *)(v39 + 8) == 0xFF || v69)
  {
    unint64_t v74 = __nwlog_obj();
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      goto LABEL_324;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    size_t v75 = "%{public}s Invalid source address";
LABEL_107:
    uint32x4_t v76 = buf;
    char v77 = v74;
    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
LABEL_121:
    _os_log_impl(&dword_1830D4000, v77, v78, v75, v76, 0xCu);
    goto LABEL_324;
  }
  unsigned int v70 = *(_DWORD *)(v39 + 20);
  *(void *)&__src[0].os_log_type_t sa_len = 7708;
  *(void *)&__src[1].sa_data[2] = v70;
  *(_DWORD *)&__src[0].sa_data[6] = v65;
  *(_DWORD *)&__src[0].sa_data[10] = v66;
  *(_DWORD *)&__src[1].os_log_type_t sa_len = v67;
  if ((v65 & 0xC0FF) == 0x80FE)
  {
    *(_DWORD *)&__src[1].sa_data[6] = v12;
    loga = __nwlog_obj();
    if (os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = "ipv6_parse";
      *(_WORD *)&unsigned char buf[12] = 1040;
      *(_DWORD *)&buf[14] = __src[0].sa_len;
      *(_WORD *)&buf[18] = 2096;
      *(void *)&buf[20] = __src;
      *(_WORD *)&unsigned char buf[28] = 1024;
      *(_DWORD *)&buf[30] = v12;
      _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_DEBUG, "%{public}s Set scopeid for src %{network:sockaddr}.*P to %u", buf, 0x22u);
    }
  }
  unsigned int v71 = *(_DWORD *)(v39 + 24);
  unsigned int v72 = *(_DWORD *)(v39 + 28);
  int v73 = *(_DWORD *)(v39 + 32);
  if (!__PAIR64__(v72, v71) && v73 == -65536)
  {
    unint64_t v74 = __nwlog_obj();
    if (!os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
      goto LABEL_324;
    }
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "ipv6_parse";
    size_t v75 = "%{public}s Invalid destination address";
    goto LABEL_107;
  }
  unsigned int v81 = *(_DWORD *)(v39 + 36);
  *(void *)&__dst[0].os_log_type_t sa_len = 7708;
  *(void *)&__dst[1].sa_data[2] = v81;
  *(_DWORD *)&__dst[0].sa_data[6] = v71;
  *(_DWORD *)&__dst[0].sa_data[10] = v72;
  *(_DWORD *)&__dst[1].os_log_type_t sa_len = v73;
  if ((v71 & 0xC0FF) == 0x80FE)
  {
    *(_DWORD *)&__dst[1].sa_data[6] = v12;
    logb = __nwlog_obj();
    if (os_log_type_enabled(logb, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446978;
      *(void *)&uint8_t buf[4] = "ipv6_parse";
      *(_WORD *)&unsigned char buf[12] = 1040;
      *(_DWORD *)&buf[14] = __dst[0].sa_len;
      *(_WORD *)&buf[18] = 2096;
      *(void *)&buf[20] = __dst;
      *(_WORD *)&unsigned char buf[28] = 1024;
      *(_DWORD *)&buf[30] = v12;
      _os_log_impl(&dword_1830D4000, logb, OS_LOG_TYPE_DEBUG, "%{public}s Set scopeid for dst %{network:sockaddr}.*P to %u", buf, 0x22u);
    }
  }
  nw_frame_claim((uint64_t)v10, v31, 40, 0);
  if (*(unsigned char *)(v39 + 6) != 44) {
    goto LABEL_215;
  }
  uint64_t v82 = (uint64_t)v10;
  int v83 = 8;
LABEL_214:
  nw_frame_claim(v82, v16, v83, 0);
LABEL_215:
  if (v225 != *((unsigned __int8 *)v9 + 166))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v56 = (id)gLogObj;
    if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
    {
      int v126 = *((unsigned __int8 *)v9 + 166);
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v225;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v126;
      _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_INFO, "%{public}s Received IP packet with protocol %u != %u", buf, 0x18u);
    }
    goto LABEL_78;
  }
  int v11 = *((_DWORD *)v9 + 14);
LABEL_14:
  if ((v11 & 0xFFFFFFFE) != 2) {
    goto LABEL_148;
  }
  if (!v21 || v22)
  {
    char v27 = v225;
    if (v225 == 17)
    {
      *(_DWORD *)int v243 = 0;
      uint64_t v46 = (__int16 *)nw_frame_unclaimed_bytes((uint64_t)v10, v243);
      if (*(_DWORD *)v243 < 8u
        || (__int16 v47 = *v46, v48 = v46[1], *(_DWORD *)v243 < bswap32((unsigned __int16)v46[2]) >> 16) && !v21)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v29 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_udp_parse";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = *(_DWORD *)v243;
        unsigned int v19 = "%{public}s Received UDP packet with incorrect length %u";
        goto LABEL_55;
      }
      int sa_family = __src[0].sa_family;
      if (__src[0].sa_family == 30 && !v46[3])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned __int32 v80 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_udp_parse";
        size_t v75 = "%{public}s Received IPv6 UDP packet with 0 checksum";
        goto LABEL_119;
      }
      if (!v21)
      {
        if (__src[0].sa_family == 2) {
          unsigned int v84 = &__src[0].sa_data[2];
        }
        else {
          unsigned int v84 = &__src[0].sa_data[6];
        }
        if (__dst[0].sa_family == 2) {
          uint64_t v85 = &__dst[0].sa_data[2];
        }
        else {
          uint64_t v85 = &__dst[0].sa_data[6];
        }
        if ((udp_validate_cksum_internal((uint64_t)v10, *(unsigned int *)v243, (unsigned __int16 *)v84, (unsigned __int16 *)v85, __src[0].sa_family == 30, 0) & 1) == 0)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned __int32 v80 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
            goto LABEL_324;
          }
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_udp_parse";
          size_t v75 = "%{public}s Received UDP packet with invalid checksum";
LABEL_119:
          uint32x4_t v76 = buf;
LABEL_120:
          char v77 = v80;
          os_log_type_t v78 = OS_LOG_TYPE_INFO;
          goto LABEL_121;
        }
        int sa_family = __src[0].sa_family;
      }
      if (sa_family != 30 && sa_family != 2)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v29 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_udp_parse";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = __src[0].sa_family;
        unsigned int v19 = "%{public}s Unsuppposed address family: %u";
        goto LABEL_55;
      }
      *(_WORD *)__src[0].sa_data = v47;
      *(_WORD *)__dst[0].sa_data = v48;
      char v27 = 17;
LABEL_145:
      if (a5 && v22)
      {
        *((_DWORD *)a5 + 14) = v23;
        a5[60] = v27;
        memcpy(a5, __src, __src[0].sa_len);
        memcpy(a5 + 28, __dst, __dst[0].sa_len);
      }
      goto LABEL_148;
    }
    if (v225 != 6) {
      goto LABEL_145;
    }
    if (__dst[0].sa_family == 2)
    {
      if ((__dst[0].sa_data[2] & 0xF0) != 0xE0) {
        goto LABEL_30;
      }
    }
    else if (__dst[0].sa_family != 30 || __dst[0].sa_data[6] != 255)
    {
LABEL_30:
      *(_DWORD *)int v243 = 0;
      uint64_t v28 = (unsigned __int16 *)nw_frame_unclaimed_bytes((uint64_t)v10, v243);
      if (*(_DWORD *)v243 <= 0x13u)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v29 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = *(_DWORD *)v243;
        unsigned int v19 = "%{public}s Received TCP packet with incorrect length %u";
LABEL_55:
        BOOL v33 = buf;
        int v49 = v29;
        os_log_type_t v50 = OS_LOG_TYPE_ERROR;
LABEL_112:
        _os_log_impl(&dword_1830D4000, v49, v50, v19, v33, 0x12u);
        goto LABEL_324;
      }
      unsigned int v51 = *v28;
      unsigned int v52 = v28[1];
      unsigned int v53 = *((unsigned __int8 *)v28 + 12);
      int log = *((unsigned __int8 *)v28 + 13);
      if (__src[0].sa_family == 2) {
        unsigned int v54 = &__src[0].sa_data[2];
      }
      else {
        unsigned int v54 = &__src[0].sa_data[6];
      }
      if (__dst[0].sa_family == 2) {
        unsigned int v55 = &__dst[0].sa_data[2];
      }
      else {
        unsigned int v55 = &__dst[0].sa_data[6];
      }
      if ((validate_tcp_cksum((uint64_t)v10, *(unsigned int *)v243, (unsigned int *)v54, (unsigned int *)v55, v51, v52, __dst[0].sa_family == 30) & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned __int32 v80 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        size_t v75 = "%{public}s invalid tcp checksum";
        goto LABEL_119;
      }
      if (v53 < 0x50 || *(_DWORD *)v243 < ((v53 >> 2) & 0x3C))
      {
        int v121 = (v53 >> 2) & 0x3C;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v121;
        unsigned int v19 = "%{public}s invalid tcp offset: %u";
      }
      else
      {
        if (__src[0].sa_family == 30)
        {
          *(_WORD *)__src[0].sa_data = v51;
          char v27 = v225;
          goto LABEL_226;
        }
        char v27 = v225;
        if (__src[0].sa_family == 2)
        {
          *(_WORD *)__src[0].sa_data = v51;
LABEL_226:
          *(_WORD *)__dst[0].sa_data = v52;
          if ((~log & 3) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            unsigned __int32 v80 = gLogObj;
            if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
              goto LABEL_324;
            }
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
            size_t v75 = "%{public}s Dropping SYN|FIN";
            goto LABEL_119;
          }
          if ((log & 0x16) != 2)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            int v130 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)long long buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
              _os_log_impl(&dword_1830D4000, v130, OS_LOG_TYPE_INFO, "%{public}s Non SYN packet delivered to listener", buf, 0xCu);
            }
            if ((log & 4) == 0) {
              nw_tcp_respond_reset((uint64_t)v10, a2, (uint64_t)(v9 + 11), (uint64_t)__dst, (uint64_t)__src);
            }
            goto LABEL_324;
          }
          goto LABEL_145;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v18 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_324;
        }
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_tcp_parse_syn";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = __src[0].sa_family;
        unsigned int v19 = "%{public}s Unsuppposed address family: %u";
      }
LABEL_38:
      BOOL v33 = buf;
LABEL_111:
      int v49 = v18;
      os_log_type_t v50 = OS_LOG_TYPE_INFO;
      goto LABEL_112;
    }
    os_log_type_t v56 = __nwlog_obj();
    if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_INFO, "%{public}s Received TCP packet with multicast destination address", buf, 0xCu);
    }
LABEL_78:

    goto LABEL_324;
  }
  if (a5)
  {
    if (v23 != *((_DWORD *)a5 + 14)
      || (int v25 = a5[1], v25 != __src[0].sa_family)
      || (size_t v26 = *a5, v26 != __src[0].sa_len))
    {
LABEL_321:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v175 = (id)gLogObj;
      if (os_log_type_enabled(v175, OS_LOG_TYPE_INFO))
      {
        int v176 = *((_DWORD *)a5 + 14);
        *(_DWORD *)long long buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v23;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v176;
        _os_log_impl(&dword_1830D4000, v175, OS_LOG_TYPE_INFO, "%{public}s Invalid fragment ID being dropped %u (expecting %u)", buf, 0x18u);
      }

      goto LABEL_324;
    }
    if (v25 == 30)
    {
      if (*((void *)a5 + 1) != *(void *)&__src[0].sa_data[6] || *((void *)a5 + 2) != *(void *)&__src[1].sa_len) {
        goto LABEL_321;
      }
    }
    else if (v25 != 2 || *((_DWORD *)a5 + 1) != *(_DWORD *)&__src[0].sa_data[2])
    {
      goto LABEL_321;
    }
    int v123 = a5[29];
    if (v123 != __dst[0].sa_family) {
      goto LABEL_321;
    }
    size_t v124 = a5[28];
    if (v124 != __dst[0].sa_len) {
      goto LABEL_321;
    }
    if (v123 == 30)
    {
      if (*(void *)(a5 + 36) != *(void *)&__dst[0].sa_data[6]
        || *(void *)(a5 + 44) != *(void *)&__dst[1].sa_len)
      {
        goto LABEL_321;
      }
    }
    else if (v123 != 2 || *((_DWORD *)a5 + 8) != *(_DWORD *)&__dst[0].sa_data[2])
    {
      goto LABEL_321;
    }
    int v225 = a5[60];
    memcpy(__src, a5, v26);
    memcpy(__dst, a5 + 28, v124);
    if (!object) {
      goto LABEL_151;
    }
    goto LABEL_149;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v45 = (id)gLogObj;
  if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v23;
    _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_INFO, "%{public}s Invalid fragment ID being dropped %u", buf, 0x12u);
  }

LABEL_148:
  if (object)
  {
LABEL_149:
    if (*((void *)object + 3) != *((void *)object + 2))
    {
      v237[0] = MEMORY[0x1E4F143A8];
      v237[1] = 3221225472;
      v237[2] = ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke;
      v237[3] = &unk_1E5244020;
      *(sockaddr *)int v239 = __src[0];
      *(sockaddr *)&v239[12] = *(sockaddr *)&__src[0].sa_data[10];
      *(sockaddr *)__int16 v240 = __dst[0];
      *(sockaddr *)&v240[12] = *(sockaddr *)&__dst[0].sa_data[10];
      id v238 = v10;
      BOOL v86 = nw_array_apply(object, (uint64_t)v237);

      if (!v86) {
        goto LABEL_325;
      }
    }
  }
LABEL_151:
  os_log_t logc = nw_endpoint_create_address(__src);
  nw_endpoint_t v87 = nw_endpoint_create_address(__dst);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  size_t v88 = (id)gLogObj;
  if (os_log_type_enabled(v88, OS_LOG_TYPE_DEBUG))
  {
    description = nw_endpoint_get_description(v87);
    logging_description = nw_endpoint_get_logging_description(logc);
    *(_DWORD *)long long buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = description;
    *(_WORD *)&buf[22] = 2082;
    *(void *)&unsigned char buf[24] = logging_description;
    _os_log_impl(&dword_1830D4000, v88, OS_LOG_TYPE_DEBUG, "%{public}s Looking up %{public}s<->%{public}s", buf, 0x20u);
  }

  uint64_t v91 = v9;
  os_log_type_t v92 = (void **)v91;
  if (*((unsigned __int16 *)v91 + 82) != *(unsigned __int16 *)__dst[0].sa_data) {
    goto LABEL_169;
  }
  if ((v91[167] & 1) == 0) {
    goto LABEL_155;
  }
  uint64_t v95 = *((void *)v91 + 19);
  if (!v95)
  {
LABEL_169:

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unsigned int v100 = (id)gLogObj;
    if (os_log_type_enabled(v100, OS_LOG_TYPE_INFO))
    {
      int v101 = nw_endpoint_get_description(v87);
      unsigned int v102 = nw_endpoint_get_logging_description(logc);
      *(_DWORD *)long long buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v101;
      *(_WORD *)&buf[22] = 2082;
      *(void *)&unsigned char buf[24] = v102;
      _os_log_impl(&dword_1830D4000, v100, OS_LOG_TYPE_INFO, "%{public}s packet %{public}s<-%{public}s does not match listener", buf, 0x20u);
    }

    goto LABEL_324;
  }
  int v96 = *(unsigned __int8 *)(v95 + 1);
  if (__dst[0].sa_family == 2 && v96 == 2)
  {
    if (*(_DWORD *)(v95 + 4) != *(_DWORD *)&__dst[0].sa_data[2]) {
      goto LABEL_169;
    }
  }
  else
  {
    if (__dst[0].sa_family != 30 || v96 != 30) {
      goto LABEL_169;
    }
    uint64_t v98 = *(void *)(v95 + 8);
    uint64_t v97 = *(void *)(v95 + 16);
    if (v98 != *(void *)&__dst[0].sa_data[6] || v97 != *(void *)&__dst[1].sa_len) {
      goto LABEL_169;
    }
  }
LABEL_155:

  if (nw_parameters_get_upper_transport_protocol(v92[6]) != 253) {
    goto LABEL_254;
  }
  int v236 = 0;
  nw_parameters_get_upper_transport_protocol_options(v92[6]);
  nw_parameters_t parameters = (nw_parameters_t)objc_claimAutoreleasedReturnValue();
  if (nw_protocol_options_is_quic_stream(parameters))
  {
    id v93 = nw_quic_stream_copy_shared_connection_options(parameters);
    size_t source_connection_id_length = nw_quic_connection_get_source_connection_id_length(v93);
  }
  else if (nw_protocol_options_is_quic_connection(parameters))
  {
    size_t source_connection_id_length = nw_quic_connection_get_source_connection_id_length(parameters);
  }
  else
  {
    size_t source_connection_id_length = 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v103 = (id)gLogObj;
  if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = source_connection_id_length;
    _os_log_impl(&dword_1830D4000, v103, OS_LOG_TYPE_DEBUG, "%{public}s Using CID length %u", buf, 0x12u);
  }

  *(_DWORD *)long long buf = 0;
  uint64_t v104 = nw_frame_unclaimed_bytes((uint64_t)v10, buf);
  unint64_t v105 = (*(_DWORD *)buf - 8);
  if (*(_DWORD *)buf <= 8u
    || (*(_DWORD *)buf -= 8,
        !nw_quic_parse_internal((const unsigned __int8 *)(v104 + 8), v105, source_connection_id_length, (dispatch_data_t *)&v236)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v108 = (id)gLogObj;
    if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
      _os_log_impl(&dword_1830D4000, v108, OS_LOG_TYPE_DEBUG, "%{public}s Unable to parse connection ID", buf, 0xCu);
    }
    goto LABEL_253;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unsigned int v106 = (id)gLogObj;
  if (os_log_type_enabled(v106, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v107 = v92[5];
    *(_DWORD *)long long buf = 136447234;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v107;
    *(_WORD *)&buf[22] = 2112;
    *(void *)&unsigned char buf[24] = v236;
    *(_WORD *)&uint8_t buf[32] = 2112;
    *(void *)&buf[34] = logc;
    *(_WORD *)&buf[42] = 2112;
    *(void *)&buf[44] = v87;
    _os_log_impl(&dword_1830D4000, v106, OS_LOG_TYPE_DEFAULT, "%{public}s Received QUIC short header packet on interface %@ with CID %@ [%@->%@]", buf, 0x34u);
  }

  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
  }
  long long v108 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  identifier = (long long *)nw_protocol_definition_get_identifier(v108);
  *(void *)&address[12] = 0;
  *(void *)&address[4] = 0;
  uint64_t v246 = 0;
  *(_WORD *)&address[2] = *((_WORD *)v92 + 82);
  *(_WORD *)uint64_t address = 7708;
  id v220 = nw_parameters_copy_context(v92[6]);
  nw_endpoint_t v218 = nw_endpoint_create_address((const sockaddr *)address);
  id type = nw_context_copy_registered_endpoint(v220, v218);
  id v110 = nw_endpoint_copy_registrar_for_identifier(type, identifier, 0);
  int v111 = v110;
  if (!v110) {
    goto LABEL_252;
  }
  uint64_t quic_instance_by_id = nw_protocol_instance_registrar_find_quic_instance_by_id(v110, v236);
  if (!quic_instance_by_id) {
    goto LABEL_252;
  }
  BOOL v208 = (void *)quic_instance_by_id;
  os_log_type_t v209 = v111;
  uint64_t v113 = __nwlog_obj();
  if (os_log_type_enabled(v113, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    _os_log_impl(&dword_1830D4000, v113, OS_LOG_TYPE_INFO, "%{public}s Found an existing QUIC connection, adding a new path", buf, 0xCu);
  }

  int v111 = v209;
  uint64_t v114 = v208[3];
  if (!v114 || (size_t v115 = *(void (**)(void))(v114 + 120)) == 0)
  {
LABEL_252:

LABEL_253:
LABEL_254:
    id v139 = v92[6];
    parametersa = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v139, 0, 0);

    if (__dst[0].sa_family == 2)
    {
      if ((__dst[0].sa_data[2] & 0xF0) == 0xE0) {
        goto LABEL_270;
      }
      nw_protocol_stack_t v140 = v92[5];
      int v141 = &__dst[0].sa_data[2];
    }
    else
    {
      if (__dst[0].sa_family != 30)
      {
        nw_protocol_stack_t v140 = v92[5];
        goto LABEL_281;
      }
      if (__dst[0].sa_data[6] == 255) {
        goto LABEL_270;
      }
      nw_protocol_stack_t v140 = v92[5];
      if (*(_DWORD *)&__dst[0].sa_data[6] || *(_DWORD *)&__dst[0].sa_data[10] || *(_DWORD *)&__dst[1].sa_len != -65536)
      {
LABEL_281:

        nw_parameters_set_local_endpoint(parametersa, v87);
        nw_parameters_set_reuse_local_address(parametersa, 1);
        unsigned int v149 = v92[4];
        if (v149)
        {
          *(void *)long long buf = 0;
          *(void *)&uint8_t buf[8] = 0;
          long long v150 = v149;
          *(_OWORD *)long long buf = *(_OWORD *)(v150 + 28);

          if (!uuid_is_null(buf)) {
            nw_parameters_require_netagent_uuid(parametersa, buf);
          }
        }
        if (!objc_msgSend(v92[1], "canHandleNewConnection:", v92, v197, v198))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v168 = (id)gLogObj;
          if (os_log_type_enabled(v168, OS_LOG_TYPE_INFO))
          {
            uint64_t v169 = nw_endpoint_get_description(v87);
            long long v170 = nw_endpoint_get_logging_description(logc);
            *(_DWORD *)long long buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v169;
            *(_WORD *)&buf[22] = 2082;
            *(void *)&unsigned char buf[24] = v170;
            _os_log_impl(&dword_1830D4000, v168, OS_LOG_TYPE_INFO, "%{public}s Dropping %{public}s<-%{public}s, listener can't handle new connections", buf, 0x20u);
          }

          goto LABEL_324;
        }
        *(void *)uint64_t address = 0;
        *(void *)&address[8] = 0;
        int v151 = v92;
        nw_endpoint_t v87 = v87;
        int v221 = logc;
        unsigned int v152 = parametersa;
        int v219 = object;
        int v212 = v151;
        uuid_clear(address);
        *(void *)int v243 = 0;
        *(void *)&v243[8] = 0;
        nw_path_get_client_id(v151[8], v243);
        nw_parameters_set_parent_id_inner(v152, v243, 0);
        nw_parameters_set_server_mode(v152, 1);
        typea = nw_parameters_copy_default_protocol_stack(&v152->super);
        long long v153 = nw_protocol_stack_copy_transport_protocol(typea);
        if (nw_protocol_options_is_tcp(v153) && !nw_tcp_options_get_connection_timeout(v153))
        {
          uint32_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_tcp_accept_timeout_seconds, 5);
          if (int64_with_default) {
            nw_tcp_options_set_connection_timeout(v153, int64_with_default);
          }
        }
        [v92[1] updateParametersForNewConnection:v152];
        BOOL v155 = nw_parameters_copy_description_internal(v152, 1);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v156 = (id)gLogObj;
        if (os_log_type_enabled(v156, OS_LOG_TYPE_INFO))
        {
          long long v157 = v92[1];
          long long v158 = nw_endpoint_get_description(v87);
          long long v159 = nw_endpoint_get_logging_description(v221);
          *(_DWORD *)long long buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_new_flow";
          *(_WORD *)&unsigned char buf[12] = 2112;
          *(void *)&buf[14] = v157;
          *(_WORD *)&buf[22] = 2082;
          *(void *)&unsigned char buf[24] = v158;
          *(_WORD *)&uint8_t buf[32] = 2082;
          *(void *)&buf[34] = v159;
          *(_WORD *)&buf[42] = 2082;
          *(void *)&buf[44] = v155;
          _os_log_impl(&dword_1830D4000, v156, OS_LOG_TYPE_INFO, "%{public}s Listener %@ received new flow %{public}s<-%{public}s %{public}s", buf, 0x34u);
        }

        if (v155) {
          free(v155);
        }
        long long v160 = (char *)[v92[1] getPeerDeviceID];
        if (v160)
        {
          nw_endpoint_set_device_id(v221, v160);
          free(v160);
        }
        unsigned int v161 = nw_connection_create_from_protocol_on_nw_queue(v221, v152, 0);
        int v162 = v161;
        if (v161)
        {
          uint64_t v163 = v161;
          nw_context_assert_queue(v163[3]);
          char flow_id = nw_endpoint_handler_get_flow_id(v163[18], address);

          if (flow_id)
          {
            if (object) {
              nw_array_append((uint64_t)v219, v163);
            }
            [v92[1] handleInbound:v163 addProtocolInbox:nw_parameters_get_attach_protocol_listener(v152)];

            if (uuid_is_null(address))
            {
              unsigned int v165 = __nwlog_obj();
              if (os_log_type_enabled(v165, OS_LOG_TYPE_INFO))
              {
                long long v166 = nw_endpoint_get_description(v87);
                long long v167 = nw_endpoint_get_logging_description(v221);
                *(_DWORD *)long long buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v166;
                *(_WORD *)&buf[22] = 2082;
                *(void *)&unsigned char buf[24] = v167;
                *(_WORD *)&uint8_t buf[32] = 1024;
                *(_DWORD *)&buf[34] = v225;
                _os_log_impl(&dword_1830D4000, v165, OS_LOG_TYPE_INFO, "%{public}s No flow id for new inbound connection %{public}s<-%{public}s %u", buf, 0x26u);
              }
              goto LABEL_311;
            }
            nw_frame_reclassify((uint64_t)v10, (uint64_t)address);

LABEL_316:
LABEL_325:

            return;
          }
          long long v171 = __nwlog_obj();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_new_flow";
            long long v172 = "%{public}s nw_connection_get_flow_id_on_nw_queue failed";
            goto LABEL_309;
          }
        }
        else
        {
          long long v171 = __nwlog_obj();
          if (os_log_type_enabled(v171, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_new_flow";
            long long v172 = "%{public}s nw_connection_create_from_protocol_on_nw_queue failed";
LABEL_309:
            _os_log_impl(&dword_1830D4000, v171, OS_LOG_TYPE_ERROR, v172, buf, 0xCu);
          }
        }

        unsigned int v165 = v212;
LABEL_311:

        goto LABEL_324;
      }
      int v141 = &__dst[1].sa_data[2];
    }
    int v142 = *(_DWORD *)v141;
    if (*(_DWORD *)v141 == -1
      || v140
      && (buf[0] = 0,
          v243[0] = 0,
          int ipv4_netmask = nw_interface_get_ipv4_netmask(v140, buf),
          int ipv4_broadcast = nw_interface_get_ipv4_broadcast(v140, v243),
          v243[0])
      && (v142 == ipv4_broadcast || buf[0] && (ipv4_broadcast & ipv4_netmask) == v142))
    {

LABEL_270:
      int address_family = nw_endpoint_get_address_family(logc);
      if (address_family == 30)
      {
        memset(&buf[4], 0, 24);
        *(_WORD *)long long buf = 7708;
        *(_WORD *)&buf[2] = *(_WORD *)__dst[0].sa_data;
        nw_endpoint_t v146 = nw_endpoint_create_address((const sockaddr *)buf);
      }
      else
      {
        if (address_family != 2) {
          goto LABEL_276;
        }
        *(_WORD *)long long buf = 528;
        *(_WORD *)&buf[2] = *(_WORD *)__dst[0].sa_data;
        *(_DWORD *)&uint8_t buf[4] = 0;
        *(void *)&uint8_t buf[8] = 0;
        nw_endpoint_t v146 = nw_endpoint_create_address((const sockaddr *)buf);
      }
      nw_endpoint_t v87 = v146;
LABEL_276:
      nw_protocol_stack_t v140 = nw_parameters_copy_default_protocol_stack(parametersa);
      nw_protocol_options_t v147 = nw_protocol_stack_copy_transport_protocol(v140);
      if (!nw_protocol_options_is_udp(v147))
      {
LABEL_280:

        goto LABEL_281;
      }
      int v148 = v147;
      if (nw_protocol_options_is_udp(v148))
      {
        *(void *)long long buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_udp_options_set_ignore_inbound_checksum_block_invoke;
        *(void *)&unsigned char buf[24] = &__block_descriptor_33_e9_B16__0_v8l;
        uint8_t buf[32] = 1;
        nw_protocol_options_access_handle(v148, buf);
LABEL_279:

        goto LABEL_280;
      }
      uint64_t v177 = __nwlog_obj();
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
      LODWORD(v19_Block_object_dispose(&a9, 8) = 12;
      os_log_type_t v197 = buf;
      id v222 = (char *)_os_log_send_and_compose_impl();

      v243[0] = 16;
      address[0] = 0;
      if (__nwlog_fault(v222, v243, address))
      {
        if (v243[0] == 17)
        {
          os_log_type_t v178 = __nwlog_obj();
          os_log_type_t typeb = v243[0];
          if (os_log_type_enabled(v178, (os_log_type_t)v243[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
            _os_log_impl(&dword_1830D4000, v178, typeb, "%{public}s called with null nw_protocol_options_is_udp(options)", buf, 0xCu);
          }
        }
        else
        {
          if (address[0])
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            typec = __nwlog_obj();
            os_log_type_t v210 = v243[0];
            BOOL v182 = os_log_type_enabled(typec, (os_log_type_t)v243[0]);
            if (backtrace_string)
            {
              if (v182)
              {
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = backtrace_string;
                _os_log_impl(&dword_1830D4000, typec, v210, "%{public}s called with null nw_protocol_options_is_udp(options), dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(backtrace_string);
            }
            else
            {
              if (v182)
              {
                *(_DWORD *)long long buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
                _os_log_impl(&dword_1830D4000, typec, v210, "%{public}s called with null nw_protocol_options_is_udp(options), no backtrace", buf, 0xCu);
              }
            }
            goto LABEL_358;
          }
          os_log_type_t v178 = __nwlog_obj();
          os_log_type_t typed = v243[0];
          if (os_log_type_enabled(v178, (os_log_type_t)v243[0]))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_udp_options_set_ignore_inbound_checksum";
            _os_log_impl(&dword_1830D4000, v178, typed, "%{public}s called with null nw_protocol_options_is_udp(options), backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_358:
      if (v222) {
        free(v222);
      }
      goto LABEL_279;
    }
    goto LABEL_281;
  }
  os_log_type_t v211 = v115();
  uint64_t v116 = __nwlog_obj();
  if (os_log_type_enabled(v116, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2112;
    *(void *)&buf[14] = v211;
    _os_log_impl(&dword_1830D4000, v116, OS_LOG_TYPE_INFO, "%{public}s QUIC protocol peer path %@", buf, 0x16u);
  }

  *(void *)int v243 = 0;
  *(void *)&v243[8] = v243;
  *(void *)&v243[16] = 0x2020000000;
  __int16 v244 = 0;
  BOOL v117 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  char v118 = v220;
  if (v117)
  {
LABEL_192:
    __int16 v244 = v117;
    v233[0] = MEMORY[0x1E4F143A8];
    v233[1] = 3221225472;
    v233[2] = ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke_38;
    v233[3] = &unk_1E5247F90;
    BOOL v119 = v92;
    long long v234 = v119;
    long long v235 = v243;
    nw_path_enumerate_interface_options(v211, v233);
    int is_null = uuid_is_null(*(const unsigned __int8 **)(*(void *)&v243[8] + 24));
    if (is_null)
    {
      os_log_type_t v120 = __nwlog_obj();
      if (os_log_type_enabled(v120, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
        _os_log_impl(&dword_1830D4000, v120, OS_LOG_TYPE_INFO, "%{public}s Did not find a matching interface", buf, 0xCu);
      }
      goto LABEL_248;
    }
    os_log_type_t v120 = nw_path_copy_flow_registration(v118, (uint64_t)v208);
    if (v10 && (*(_DWORD *)long long buf = 0, (v127 = (const void *)nw_frame_unclaimed_bytes((uint64_t)v10, buf)) != 0))
    {
      dispatch_data_t v205 = dispatch_data_create(v127, *(unsigned int *)buf, 0, 0);
      nw_frame_claim((uint64_t)v10, v128, *(int *)buf, 0);
      dispatch_data_t v129 = v205;
    }
    else
    {
      dispatch_data_t v129 = 0;
    }
    dispatch_data_t v206 = v129;
    int v131 = nw_interface_option_details_create(v119[5], *(_OWORD **)(*(void *)&v243[8] + 24), logc, 0, v129, -1);
    os_log_type_t v204 = v131;
    if (v131)
    {
      nw_path_flow_registration_add_extra_interface_option(v120, v131);
    }
    else
    {
      os_log_type_t v202 = v120;
      unsigned int v132 = __nwlog_obj();
      if (os_log_type_enabled(v132, OS_LOG_TYPE_ERROR))
      {
        unsigned int v133 = v119[5];
        uint64_t v134 = *(void *)(*(void *)&v243[8] + 24);
        *(_DWORD *)long long buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
        *(_WORD *)&unsigned char buf[12] = 2112;
        *(void *)&buf[14] = v133;
        *(_WORD *)&buf[22] = 1042;
        *(_DWORD *)&unsigned char buf[24] = 16;
        *(_WORD *)&unsigned char buf[28] = 2098;
        *(void *)&buf[30] = v134;
        _os_log_impl(&dword_1830D4000, v132, OS_LOG_TYPE_ERROR, "%{public}s Unable to create interface option details with %@ [%{public,uuid_t}.16P]", buf, 0x26u);
      }

      os_log_type_t v120 = v202;
    }
    BOOL v135 = nw_path_flow_registration_copy_path(v120);
    uint64_t v136 = v208[3];
    if (v136)
    {
      unsigned int v137 = *(void (**)(void *, void, BOOL))(v136 + 168);
      if (v137)
      {
        v137(v208, v208[6], v135);
LABEL_247:

LABEL_248:
        uint64_t v138 = *(void **)(*(void *)&v243[8] + 24);
        if (v138)
        {
          free(v138);
          *(void *)(*(void *)&v243[8] + 24) = 0;
        }
        if (!is_null)
        {
          int v173 = __nwlog_obj();
          if (os_log_type_enabled(v173, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)long long buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
            _os_log_impl(&dword_1830D4000, v173, OS_LOG_TYPE_INFO, "%{public}s QUIC migration handled packet", buf, 0xCu);
          }

          nw_frame_finalize((uint64_t)v10);
          _Block_object_dispose(v243, 8);

          goto LABEL_316;
        }

        _Block_object_dispose(v243, 8);
        int v111 = v209;
        goto LABEL_252;
      }
    }
    uint64_t v187 = __nwlog_obj();
    int v188 = (const char *)v208[2];
    if (!v188) {
      int v188 = "invalid";
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v188;
    LODWORD(v19_Block_object_dispose(&a9, 8) = 22;
    os_log_type_t v197 = buf;
    os_log_type_t v189 = (void *)v187;
    BOOL v203 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v232 = OS_LOG_TYPE_ERROR;
    char v231 = 0;
    if (__nwlog_fault(v203, &v232, &v231))
    {
      if (v232 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v190 = __nwlog_obj();
        os_log_type_t v199 = v232;
        if (os_log_type_enabled(v190, v232))
        {
          uint64_t v191 = (const char *)v208[2];
          if (!v191) {
            uint64_t v191 = "invalid";
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v191;
          _os_log_impl(&dword_1830D4000, v190, v199, "%{public}s protocol %{public}s has invalid updated_path callback", buf, 0x16u);
        }
      }
      else
      {
        if (v231)
        {
          unsigned int v192 = (char *)__nw_create_backtrace_string();
          int v200 = __nwlog_obj();
          HIDWORD(v19_Block_object_dispose(&a9, 8) = v232;
          BOOL v193 = os_log_type_enabled(v200, v232);
          if (v192)
          {
            if (v193)
            {
              int v194 = (const char *)v208[2];
              if (!v194) {
                int v194 = "invalid";
              }
              *(_DWORD *)long long buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v194;
              *(_WORD *)&buf[22] = 2082;
              *(void *)&unsigned char buf[24] = v192;
              _os_log_impl(&dword_1830D4000, v200, BYTE4(v198), "%{public}s protocol %{public}s has invalid updated_path callback, dumping backtrace:%{public}s", buf, 0x20u);
            }

            free(v192);
          }
          else
          {
            if (v193)
            {
              int v196 = (const char *)v208[2];
              if (!v196) {
                int v196 = "invalid";
              }
              *(_DWORD *)long long buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v196;
              _os_log_impl(&dword_1830D4000, v200, BYTE4(v198), "%{public}s protocol %{public}s has invalid updated_path callback, no backtrace", buf, 0x16u);
            }
          }
          goto LABEL_377;
        }
        uint64_t v190 = __nwlog_obj();
        os_log_type_t v201 = v232;
        if (os_log_type_enabled(v190, v232))
        {
          os_log_type_t v195 = (const char *)v208[2];
          if (!v195) {
            os_log_type_t v195 = "invalid";
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_channel_inbox_handle_input_frame";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v195;
          _os_log_impl(&dword_1830D4000, v190, v201, "%{public}s protocol %{public}s has invalid updated_path callback, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
LABEL_377:
    if (v203) {
      free(v203);
    }
    goto LABEL_247;
  }
  int v183 = __nwlog_obj();
  os_log_type_enabled(v183, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446722;
  *(void *)&uint8_t buf[4] = "strict_calloc";
  *(_WORD *)&unsigned char buf[12] = 2048;
  *(void *)&buf[14] = 1;
  *(_WORD *)&buf[22] = 2048;
  *(void *)&unsigned char buf[24] = 16;
  LODWORD(v19_Block_object_dispose(&a9, 8) = 32;
  os_log_type_t v197 = buf;
  uint64_t v184 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v184))
  {
    free(v184);
    char v118 = v220;
    goto LABEL_192;
  }
  __break(1u);
}

void sub_183AA2274(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, uint64_t a18, uint64_t a19, void *a20,void *a21,void *a22,void *a23,uint64_t a24,uint64_t a25,void *a26,void *a27,uint64_t a28,void *a29,void *a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,void *a36,uint64_t a37,void *a38)
{
  _Block_object_dispose((const void *)(v43 - 240), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a3;
  nw_endpoint_t v5 = nw_connection_copy_endpoint(v4);
  id v6 = nw_connection_copy_parameters(v4);
  nw_endpoint_t v7 = nw_parameters_copy_local_endpoint(v6);
  if (!v5) {
    goto LABEL_12;
  }
  uint64_t v8 = v5;
  int v9 = [v8 type];

  if (v9 != 1) {
    goto LABEL_12;
  }
  int v10 = nw_endpoint_address_endpoint_matches_address(v8, (unsigned __int8 *)(a1 + 40), 0, 0);
  int v11 = v7 ? v10 : 0;
  if (v11 == 1
    && (int v12 = v7, v13 = [v12 type], v12, v13 == 1)
    && nw_endpoint_address_endpoint_matches_address(v12, (unsigned __int8 *)(a1 + 68), 0, 0))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v14 = (id)gLogObj;
    if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)int v17 = 136446466;
      *(void *)&v17[4] = "nw_ip_channel_inbox_handle_input_frame_block_invoke";
      *(_WORD *)&v17[12] = 2112;
      *(void *)&v17[14] = v4;
      _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_INFO, "%{public}s Reclassifying packet for %@", v17, 0x16u);
    }

    *(void *)int v17 = 0;
    *(void *)&v17[8] = 0;
    nw_connection_get_flow_id_on_nw_queue(v4, v17);
    nw_frame_reclassify(*(void *)(a1 + 32), (uint64_t)v17);
    uint64_t v15 = 0;
  }
  else
  {
LABEL_12:
    uint64_t v15 = 1;
  }

  return v15;
}

void sub_183AA2664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL38nw_ip_channel_inbox_handle_input_frameP19nw_ip_channel_inboxP11nw_protocolPU22objcproto11OS_nw_frame8NSObjectPU22objcproto11OS_nw_arrayS3_P27nw_ip_channel_fragment_info_block_invoke_38(uint64_t a1, void *a2, _OWORD *a3)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  nw_endpoint_t v5 = a2;
  if (nw_interface_shallow_compare(v5, *(void **)(*(void *)(a1 + 32) + 40)))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      nw_endpoint_t v7 = v5 + 104;
      int v8 = 136446978;
      int v9 = "nw_ip_channel_inbox_handle_input_frame_block_invoke";
      if (!v5) {
        nw_endpoint_t v7 = 0;
      }
      __int16 v10 = 2080;
      int v11 = v7;
      __int16 v12 = 1040;
      int v13 = 16;
      __int16 v14 = 2096;
      uint64_t v15 = a3;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s Found interface %s, using agent id %{uuid_t}.16P", (uint8_t *)&v8, 0x26u);
    }

    *(_OWORD *)*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = *a3;
  }
}

nw_protocol_definition_t nw_protocol_copy_ip_definition(void)
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  uint64_t v0 = (void *)g_ip_definition;

  return (nw_protocol_definition_t)v0;
}

BOOL nw_ip_deserialize_options(void *a1, _OWORD *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (a2)
  {
    if (a3 == 16)
    {
      BOOL v7 = nw_ip_copy_options(v5, a2);
      goto LABEL_4;
    }
    int v13 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v25 = "nw_ip_deserialize_options";
    __int16 v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_ip_options))", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v22)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_ip_options)), backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)long long buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_ip_options)), no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v19)
      {
        *(_DWORD *)long long buf = 136446466;
        int v25 = "nw_ip_deserialize_options";
        __int16 v26 = 2082;
        char v27 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null (serialized_length == sizeof(struct nw_protocol_ip_options)), dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    int v9 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v25 = "nw_ip_deserialize_options";
    __int16 v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v10, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null serialized_bytes", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v22)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null serialized_bytes, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)long long buf = 136446210;
          int v25 = "nw_ip_deserialize_options";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null serialized_bytes, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)long long buf = 136446466;
        int v25 = "nw_ip_deserialize_options";
        __int16 v26 = 2082;
        char v27 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null serialized_bytes, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v10) {
    free(v10);
  }
  BOOL v7 = 0;
LABEL_4:

  return v7;
}

void sub_183AA2CFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ip_serialize_options(void *a1, _OWORD *a2, void *a3)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (!a2)
  {
    int v8 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)long long buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v14)
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_ip_serialize_options";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v9) {
      free(v9);
    }
    goto LABEL_22;
  }
  *(void *)long long buf = 0;
  *(void *)&uint8_t buf[8] = 0;
  if (*a2 == 0)
  {
LABEL_22:
    BOOL v7 = 0;
    goto LABEL_23;
  }
  BOOL v7 = nw_ip_copy_options(v5, a2);
  *a3 = 16;
LABEL_23:

  return v7;
}

void sub_183AA2FCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_ip_deallocate_metadata(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_ip_allocate_metadata(void *a1)
{
  id v1 = a1;
  uint64_t v2 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    void *v2 = 0;
    v2[1] = 0;
    v2[2] = 0;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183AA312C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_ip_create_options()
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  uint64_t v0 = (void *)g_ip_definition;

  return nw_protocol_create_options(v0);
}

void nw_ip_options_set_use_minimum_mtu(nw_protocol_options_t options, BOOL use_minimum_mtu)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  SecCertificateRef v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_use_minimum_mtu_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = use_minimum_mtu;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_ip_options_set_use_minimum_mtu";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_use_minimum_mtu";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_ip_options_set_use_minimum_mtu";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_use_minimum_mtu";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_use_minimum_mtu";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA3478(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_use_minimum_mtu_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 13) = *(unsigned char *)(a2 + 13) & 0xFE | *(unsigned char *)(a1 + 32);
  return 1;
}

void nw_ip_options_set_calculate_receive_time(nw_protocol_options_t options, BOOL calculate_receive_time)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  SecCertificateRef v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_calculate_receive_time_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = calculate_receive_time;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_ip_options_set_calculate_receive_time";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_calculate_receive_time";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_ip_options_set_calculate_receive_time";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_calculate_receive_time";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_calculate_receive_time";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA3790(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_calculate_receive_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 13) = *(unsigned char *)(a2 + 13) & 0xFD | (2 * *(unsigned char *)(a1 + 32));
  return 1;
}

void nw_ip_options_set_hop_limit(nw_protocol_options_t options, uint8_t hop_limit)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  SecCertificateRef v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_hop_limit_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    uint8_t v13 = hop_limit;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_ip_options_set_hop_limit";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_hop_limit";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_ip_options_set_hop_limit";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_hop_limit";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_hop_limit";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA3AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 12) = *(unsigned char *)(a1 + 32);
  return 1;
}

void nw_ip_options_set_version(nw_protocol_options_t options, nw_ip_version_t version)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  SecCertificateRef v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_version_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_ip_version_t v13 = version;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_ip_options_set_version";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_version";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_ip_options_set_version";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_version";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_version";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA3DB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_version_block_invoke(uint64_t a1, _DWORD *a2)
{
  *a2 = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_ip_options_set_local_address_preference(nw_protocol_options_t options, nw_ip_local_address_preference_t preference)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  SecCertificateRef v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_local_address_preference_block_invoke;
    v12[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_ip_local_address_preference_t v13 = preference;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_ip_options_set_local_address_preference";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_local_address_preference";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_ip_options_set_local_address_preference";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_local_address_preference";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_local_address_preference";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA40C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_local_address_preference_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 4) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_ip_options_set_disable_multicast_loopback(nw_protocol_options_t options, BOOL disable_multicast_loopback)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  SecCertificateRef v3 = options;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_disable_multicast_loopback_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    BOOL v13 = disable_multicast_loopback;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v17 = "nw_ip_options_set_disable_multicast_loopback";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_disable_multicast_loopback";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          char v17 = "nw_ip_options_set_disable_multicast_loopback";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_disable_multicast_loopback";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v17 = "nw_ip_options_set_disable_multicast_loopback";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA43CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_disable_multicast_loopback_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 13) = *(unsigned char *)(a2 + 13) & 0xFB | (4 * *(unsigned char *)(a1 + 32));
  return 1;
}

BOOL nw_ip_options_get_disable_multicast_loopback(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_disable_multicast_loopback_block_invoke;
    v12[3] = &unk_1E5248E90;
    void v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_disable_multicast_loopback";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183AA471C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_disable_multicast_loopback_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 13) & 4) != 0;
  return 1;
}

void nw_ip_options_set_corrupt_checksums(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_corrupt_checksums_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_corrupt_checksums";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA4A48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_corrupt_checksums_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 13) = *(unsigned char *)(a2 + 13) & 0xF7 | (8 * *(unsigned char *)(a1 + 32));
  return 1;
}

void nw_ip_options_set_receive_hop_limit(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_options_is_ip(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_set_receive_hop_limit_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_options_access_handle(v3, v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
          __int16 v18 = 2082;
          BOOL v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v17 = "nw_ip_options_set_receive_hop_limit";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183AA4D60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_set_receive_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 13) = *(unsigned char *)(a2 + 13) & 0xEF | (16 * *(unsigned char *)(a1 + 32));
  return 1;
}

nw_protocol_metadata_t nw_ip_create_metadata(void)
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  uint64_t v0 = (void *)g_ip_definition;

  return (nw_protocol_metadata_t)nw_protocol_metadata_create_singleton(v0);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke(uint64_t a1)
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::non_ect_metadata;
  nw_ip_copy_metadata_for_ecn_flag::non_ect_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_2;
  v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::non_ect_metadata, (uint64_t)v6);
}

void sub_183AA4EC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_3(uint64_t a1)
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::ect_1_metadata;
  nw_ip_copy_metadata_for_ecn_flag::ect_1_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_4;
  v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::ect_1_metadata, (uint64_t)v6);
}

void sub_183AA4FA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_5(uint64_t a1)
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::ect_0_metadata;
  nw_ip_copy_metadata_for_ecn_flag::ect_0_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_6;
  v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::ect_0_metadata, (uint64_t)v6);
}

void sub_183AA5090(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_7(uint64_t a1)
{
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  id v2 = (id)g_ip_definition;
  singleton = nw_protocol_metadata_create_singleton(v2);
  uint64_t v4 = (void *)nw_ip_copy_metadata_for_ecn_flag::ce_metadata;
  nw_ip_copy_metadata_for_ecn_flag::ce_uint64_t metadata = (uint64_t)singleton;

  v6[0] = MEMORY[0x1E4F143A8];
  v6[1] = 3221225472;
  void v6[2] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_8;
  v6[3] = &__block_descriptor_36_e9_B16__0_v8l;
  int v7 = *(_DWORD *)(a1 + 32);
  return nw_protocol_metadata_access_handle(nw_ip_copy_metadata_for_ecn_flag::ce_metadata, (uint64_t)v6);
}

void sub_183AA5178(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_8(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(&a9, 8) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_6(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(&a9, 8) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_4(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(&a9, 8) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_ip_copy_metadata_for_ecn_flag_block_invoke_2(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 22) |= 1u;
  *(_DWORD *)(a2 + _Block_object_dispose(&a9, 8) = *(_DWORD *)(a1 + 32);
  return 1;
}

void nw_ip_metadata_set_ecn_flag(nw_protocol_metadata_t metadata, nw_ip_ecn_flag_t ecn_flag)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v3 = metadata;
  nw_protocol_metadata_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_ip_metadata_set_ecn_flag_block_invoke;
    v14[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_ip_ecn_flag_t v15 = ecn_flag;
    uint64_t isa = (uint64_t)v3[4].isa;
    if (isa) {
      __nw_ip_metadata_set_ecn_flag_block_invoke((uint64_t)v14, isa);
    }
    goto LABEL_4;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v19 = "nw_ip_metadata_set_ecn_flag";
  int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v19 = "nw_ip_metadata_set_ecn_flag";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v19 = "nw_ip_metadata_set_ecn_flag";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v19 = "nw_ip_metadata_set_ecn_flag";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        BOOL v19 = "nw_ip_metadata_set_ecn_flag";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
LABEL_4:
}

BOOL __nw_ip_metadata_set_ecn_flag_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  char v2 = *(unsigned char *)(a2 + 22);
  if (v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_metadata_t v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446210;
      id v6 = "nw_ip_metadata_set_ecn_flag_block_invoke";
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s Cannot modify static IP metadata", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    *(_DWORD *)(a2 + _Block_object_dispose(&a9, 8) = *(_DWORD *)(a1 + 32);
  }
  return (v2 & 1) == 0;
}

nw_ip_ecn_flag_t nw_ip_metadata_get_ecn_flag(nw_protocol_metadata_t metadata)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v1 = metadata;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    nw_protocol_metadata_t v3 = buf;
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = __nw_ip_metadata_get_ecn_flag_block_invoke;
    v15[3] = &unk_1E5248E90;
    v15[4] = buf;
    uint64_t isa = (uint64_t)v1[4].isa;
    if (isa)
    {
      __nw_ip_metadata_get_ecn_flag_block_invoke((uint64_t)v15, isa);
      nw_protocol_metadata_t v3 = *(unsigned char **)&buf[8];
    }
    nw_ip_ecn_flag_t v5 = *((_DWORD *)v3 + 6);
    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }
  uint64_t v7 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_ecn_flag";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  nw_ip_ecn_flag_t v5 = nw_ip_ecn_flag_non_ect;
LABEL_5:

  return v5;
}

uint64_t __nw_ip_metadata_get_ecn_flag_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 8);
  return 1;
}

void nw_ip_metadata_set_dscp_value(void *a1, unsigned int a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v3 = a1;
  nw_protocol_metadata_t v4 = v3;
  if (!v3)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v25 = "nw_ip_metadata_set_dscp_value";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v7, &type, &v22)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        int v25 = "nw_ip_metadata_set_dscp_value";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)long long buf = 136446466;
          int v25 = "nw_ip_metadata_set_dscp_value";
          __int16 v26 = 2082;
          char v27 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)long long buf = 136446210;
        int v25 = "nw_ip_metadata_set_dscp_value";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        int v25 = "nw_ip_metadata_set_dscp_value";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (a2 < 0x40)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __nw_ip_metadata_set_dscp_value_block_invoke;
    v20[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v21 = a2;
    uint64_t v5 = v3[4];
    if (v5) {
      __nw_ip_metadata_set_dscp_value_block_invoke((uint64_t)v20, v5);
    }
    goto LABEL_5;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  int v25 = "nw_ip_metadata_set_dscp_value";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (!__nwlog_fault(v7, &type, &v22)) {
    goto LABEL_39;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)long long buf = 136446210;
      int v25 = "nw_ip_metadata_set_dscp_value";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null (dscp_value <= _MAX_DSCP)", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v22)
  {
    int v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)long long buf = 136446210;
      int v25 = "nw_ip_metadata_set_dscp_value";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  nw_ip_ecn_flag_t v15 = (char *)__nw_create_backtrace_string();
  int v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)long long buf = 136446210;
      int v25 = "nw_ip_metadata_set_dscp_value";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)long long buf = 136446466;
    int v25 = "nw_ip_metadata_set_dscp_value";
    __int16 v26 = 2082;
    char v27 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

BOOL __nw_ip_metadata_set_dscp_value_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  char v2 = *(unsigned char *)(a2 + 22);
  if (v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_metadata_t v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446210;
      id v6 = "nw_ip_metadata_set_dscp_value_block_invoke";
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s Cannot modify static IP metadata", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    *(unsigned char *)(a2 + 20) = *(unsigned char *)(a1 + 32);
  }
  return (v2 & 1) == 0;
}

uint64_t nw_ip_metadata_get_dscp_value(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v1 = a1;
  char v2 = v1;
  if (v1)
  {
    *(void *)long long buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v18 = 0;
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_ip_metadata_get_dscp_value_block_invoke;
    v14[3] = &unk_1E5248E90;
    void v14[4] = buf;
    uint64_t v3 = v1[4];
    if (v3)
    {
      __nw_ip_metadata_get_dscp_value_block_invoke((uint64_t)v14, v3);
      uint64_t v4 = *(unsigned __int8 *)(*(void *)&buf[8] + 24);
    }
    else
    {
      uint64_t v4 = 0;
    }
    _Block_object_dispose(buf, 8);
    goto LABEL_6;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_metadata_get_dscp_value";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0;
LABEL_6:

  return v4;
}

uint64_t __nw_ip_metadata_get_dscp_value_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 20);
  return 1;
}

void nw_ip_metadata_set_service_class(nw_protocol_metadata_t metadata, nw_service_class_t service_class)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v3 = metadata;
  nw_protocol_metadata_t v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_ip_metadata_set_service_class_block_invoke;
    v14[3] = &__block_descriptor_36_e9_B16__0_v8l;
    nw_service_class_t v15 = service_class;
    uint64_t isa = (uint64_t)v3[4].isa;
    if (isa) {
      __nw_ip_metadata_set_service_class_block_invoke((uint64_t)v14, isa);
    }
    goto LABEL_4;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  uint64_t v19 = "nw_ip_metadata_set_service_class";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_service_class";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)long long buf = 136446466;
          uint64_t v19 = "nw_ip_metadata_set_service_class";
          __int16 v20 = 2082;
          char v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_service_class";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)long long buf = 136446210;
        uint64_t v19 = "nw_ip_metadata_set_service_class";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
LABEL_4:
}

BOOL __nw_ip_metadata_set_service_class_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  char v2 = *(unsigned char *)(a2 + 22);
  if (v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_metadata_t v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446210;
      id v6 = "nw_ip_metadata_set_service_class_block_invoke";
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s Cannot modify static IP metadata", (uint8_t *)&v5, 0xCu);
    }
  }
  else
  {
    *(_DWORD *)(a2 + 12) = *(_DWORD *)(a1 + 32);
  }
  return (v2 & 1) == 0;
}