void sub_183C62E50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  void *v18;
  void *v19;
  void *v20;
  void *v21;
  uint64_t v22;

  _Block_object_dispose((const void *)(v22 - 192), 8);

  _Unwind_Resume(a1);
}

void __nw_connection_report_symptom_internal_on_nw_queue_block_invoke(uint64_t a1, void *a2)
{
  v3 = a2;
  v4 = v3;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    endpoint = v3;
    nw_endpoint_type_t type = nw_endpoint_get_type(v3);
    v4 = endpoint;
    if (type == nw_endpoint_type_url
      || (nw_endpoint_type_t v6 = nw_endpoint_get_type(endpoint), v4 = endpoint, v6 == nw_endpoint_type_host))
    {
      hostname = nw_endpoint_get_hostname(v4);
      v4 = endpoint;
      if (hostname)
      {
        size_t v8 = strlen(hostname);
        v4 = endpoint;
        if (v8)
        {
          symptom_set_additional_qualifier();
          *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
          v4 = endpoint;
        }
      }
    }
  }
}

void sub_183C62F94(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void nw_connection_report_symptom_on_nw_queue(void *a1, int a2, void *a3, int a4)
{
  *(void *)&v28[13] = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a3;
  if (v7)
  {
    nw_context_assert_queue(*((void **)v7 + 3));
    if (v8)
    {
      id v9 = v8;
      os_unfair_lock_lock((os_unfair_lock_t)v9 + 28);
      id v10 = *((id *)v9 + 8);
      os_unfair_lock_unlock((os_unfair_lock_t)v9 + 28);

      if (!v10) {
        goto LABEL_15;
      }
LABEL_8:
      nw_connection_report_symptom_internal_on_nw_queue(a2, *((void **)v7 + 1), *((void **)v7 + 2), v10, 0, 0, 0, 0, a4, *((_DWORD *)v7 + 126));
      uint64_t v11 = *((void *)v7 + 2);
      if (v11 && !nw_path_parameters_get_logging_disabled(*(void *)(v11 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v12 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
        {
          int v13 = *((_DWORD *)v7 + 112);
          v14 = off_1E5249E98[a2 - 421889];
          *(_DWORD *)buf = 136446722;
          v26 = "nw_connection_report_symptom_on_nw_queue";
          __int16 v27 = 1024;
          *(_DWORD *)v28 = v13;
          v28[2] = 2082;
          *(void *)&v28[3] = v14;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_INFO, "%{public}s [C%u] reported %{public}s symptom", buf, 0x1Cu);
        }
      }
      goto LABEL_15;
    }
    if ((*((unsigned char *)v7 + 109) & 0x40) != 0)
    {
      id v10 = (id)nw_endpoint_handler_copy_connected_path(*((void **)v7 + 18));
      if (v10) {
        goto LABEL_8;
      }
    }
    else
    {
      id v10 = 0;
    }
LABEL_15:

    goto LABEL_16;
  }
  v15 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v26 = "nw_connection_report_symptom_on_nw_queue";
  v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_report_symptom_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v17 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v26 = "nw_connection_report_symptom_on_nw_queue";
          __int16 v27 = 2082;
          *(void *)v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_33;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_report_symptom_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v17 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        v26 = "nw_connection_report_symptom_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_33:
  if (v16) {
    free(v16);
  }
LABEL_16:
}

void sub_183C6339C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_endpoint_handler_for_handler_id(NWConcrete_nw_connection *a1, __int16 a2)
{
  uint64_t v6 = 0;
  id v7 = &v6;
  uint64_t v8 = 0x3032000000;
  id v9 = __Block_byref_object_copy__79980;
  id v10 = __Block_byref_object_dispose__79981;
  id v11 = 0;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL50nw_connection_copy_endpoint_handler_for_handler_idP24NWConcrete_nw_connectiont_block_invoke;
  v4[3] = &unk_1E5249D48;
  __int16 v5 = a2;
  v4[4] = &v6;
  nw_endpoint_handler_apply_to_leaf_children(a1, v4);
  id v2 = (id)v7[5];
  _Block_object_dispose(&v6, 8);

  return v2;
}

void sub_183C6349C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, char a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, id a20)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__79980(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__79981(uint64_t a1)
{
}

uint64_t ___ZL50nw_connection_copy_endpoint_handler_for_handler_idP24NWConcrete_nw_connectiont_block_invoke(uint64_t a1, void *a2)
{
  id v3 = a2;
  v4 = v3;
  int v5 = (unsigned __int16)(WORD2(v3) ^ WORD1(v3) ^ HIWORD(v3) ^ (unsigned __int16)v3);
  if (!v3) {
    int v5 = 0;
  }
  if (v5 == *(unsigned __int16 *)(a1 + 40))
  {
    uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 8);
    id v7 = v3;
    id v8 = *(id *)(v6 + 40);
    *(void *)(v6 + 40) = v7;
LABEL_11:

    uint64_t v12 = 0;
    goto LABEL_12;
  }
  id v9 = nw_endpoint_handler_copy_parent(v3);
  if (v9)
  {
    id v10 = v9;
    while (*(unsigned __int16 *)(a1 + 40) != (unsigned __int16)(WORD2(v10) ^ WORD1(v10) ^ HIWORD(v10) ^ (unsigned __int16)v10))
    {
      id v11 = (id *)v10;
      id v10 = v11[9];

      if (!v10) {
        goto LABEL_9;
      }
    }
    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 8);
    v14 = *(void **)(v13 + 40);
    *(void *)(v13 + 40) = v10;
    id v8 = v10;

    goto LABEL_11;
  }
LABEL_9:
  uint64_t v12 = 1;
LABEL_12:

  return v12;
}

BOOL nw_connection_fillout_tcp_connection_info(void *a1, uint64_t a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      char v27 = 0;
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      v20[2] = __nw_connection_fillout_tcp_connection_info_block_invoke;
      v20[3] = &unk_1E524BAF8;
      BOOL v21 = v3;
      os_log_type_t v22 = buf;
      uint64_t v23 = a2;
      os_unfair_lock_lock(v4 + 34);
      __nw_connection_fillout_tcp_connection_info_block_invoke(v20);
      os_unfair_lock_unlock(v4 + 34);
      BOOL v5 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

      _Block_object_dispose(buf, 8);
      goto LABEL_4;
    }
    id v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null info_ptr", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v24)
      {
        id v9 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
          _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null info_ptr, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null info_ptr, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null info_ptr, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    id v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v8, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v24)
      {
        id v9 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_fillout_tcp_connection_info";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v8) {
    free(v8);
  }
  BOOL v5 = 0;
LABEL_4:

  return v5;
}

void __nw_connection_fillout_tcp_connection_info_block_invoke(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  v1 = (unsigned char *)a1[4];
  if ((v1[109] & 0x40) == 0) {
    return;
  }
  id v3 = v1;
  id v4 = v3[2];

  LODWORD(v3) = nw_parameters_get_multipath(v4);
  BOOL v5 = (void *)a1[4];
  if (!v3)
  {
    id v9 = (_OWORD *)a1[6];
    os_log_type_t v10 = v5;
    id v11 = v10;
    if (v10)
    {
      if (v9)
      {
        BOOL v12 = nw_endpoint_handler_fillout_tcp_connection_info((void *)v10[18], v9);
LABEL_13:

        *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = v12;
        return;
      }
      BOOL v17 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
      os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (__nwlog_fault(v14, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v15 = __nwlog_obj();
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null tcp_connection_info", buf, 0xCu);
          }
LABEL_46:

          goto LABEL_47;
        }
        if (!v26)
        {
          BOOL v15 = __nwlog_obj();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v15, v25, "%{public}s called with null tcp_connection_info, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_46;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v15 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446210;
            v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null tcp_connection_info, no backtrace", buf, 0xCu);
          }
          goto LABEL_46;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
          __int16 v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null tcp_connection_info, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v13 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
      os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (__nwlog_fault(v14, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v15 = __nwlog_obj();
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null connection", buf, 0xCu);
          }
          goto LABEL_46;
        }
        if (!v26)
        {
          BOOL v15 = __nwlog_obj();
          os_log_type_t v24 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446210;
            v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_46;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v15 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446210;
            v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
            _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null connection, no backtrace", buf, 0xCu);
          }
          goto LABEL_46;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          v29 = "nw_connection_get_tcp_connection_info_for_connected_endpoint_locked";
          __int16 v30 = 2082;
          v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_34:

        free(backtrace_string);
      }
    }
LABEL_47:
    if (v14) {
      free(v14);
    }
    BOOL v12 = 0;
    goto LABEL_13;
  }
  uint64_t v6 = v5[2];
  if (v6 && !nw_path_parameters_get_logging_disabled(*(void *)(v6 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v7 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
    {
      int v8 = *(_DWORD *)(a1[4] + 448);
      *(_DWORD *)buf = 136446466;
      v29 = "nw_connection_fillout_tcp_connection_info_block_invoke";
      __int16 v30 = 1024;
      LODWORD(v31) = v8;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%u] MPTCP is currently not supported", buf, 0x12u);
    }
  }
}

void sub_183C640DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_used_tfo_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (object_getClass(v4) == (Class)MEMORY[0x1E4F14580] && (bytes_ptr = xpc_data_get_bytes_ptr(v4)) != 0)
  {
    uint64_t v5 = 1;
    if (xpc_data_get_length(v4) == 408 && (bytes_ptr[244] & 0x10) != 0)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      uint64_t v5 = 0;
    }
  }
  else
  {
    uint64_t v5 = 1;
  }

  return v5;
}

void sub_183C64180(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_better_path_available(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v19 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_better_path_available_block_invoke;
    v13[3] = &unk_1E524B978;
    BOOL v15 = buf;
    os_log_type_t v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_better_path_available_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_better_path_available";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_better_path_available";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_better_path_available";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_better_path_available";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_better_path_available";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_connection_better_path_available_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(_DWORD *)(*(void *)(result + 32) + 132) == 1;
  return result;
}

BOOL nw_connection_has_proxy_attempt_locked_on_nw_queue(void *a1)
{
  *(void *)&v33[5] = *MEMORY[0x1E4F143B8];
  v1 = a1;
  id v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[3]);
    if (*((_DWORD *)v2 + 20) == 5)
    {
      BOOL v3 = v2[2];
      if (v3 && !nw_path_parameters_get_logging_disabled(v3[13]))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v4 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
        {
          int v5 = *((_DWORD *)v2 + 112);
          *(_DWORD *)buf = 136446466;
          v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
          __int16 v32 = 1024;
          *(_DWORD *)v33 = v5;
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Cancelled, cannot check for proxy attempts", buf, 0x12u);
        }
      }
      goto LABEL_10;
    }
    os_log_type_t v8 = v2[18];
    if (v8)
    {
      BOOL has_proxy_child_locked = nw_endpoint_handler_has_proxy_child_locked(v8);
      id v7 = v2[2];
      if (!v7) {
        goto LABEL_20;
      }
      goto LABEL_14;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
    uint64_t v13 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault((const char *)v13, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s Cannot check proxy endpoint without parent endpoint handler", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
            __int16 v32 = 2082;
            *(void *)v33 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s Cannot check proxy endpoint without parent endpoint handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v13)
          {
LABEL_10:
            BOOL has_proxy_child_locked = 0;
            id v7 = v2[2];
            if (!v7) {
              goto LABEL_20;
            }
LABEL_14:
            if (!nw_path_parameters_get_logging_disabled(v7[13]))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              id v9 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
              {
                int v10 = *((_DWORD *)v2 + 112);
                *(_DWORD *)buf = 136446722;
                v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
                __int16 v32 = 1024;
                *(_DWORD *)v33 = v10;
                v33[2] = 1024;
                *(_DWORD *)&v33[3] = has_proxy_child_locked;
                _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Has proxy attempt: %u", buf, 0x18u);
              }
            }
            goto LABEL_20;
          }
LABEL_39:
          free(v13);
          goto LABEL_10;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s Cannot check proxy endpoint without parent endpoint handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s Cannot check proxy endpoint without parent endpoint handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v13) {
      goto LABEL_10;
    }
    goto LABEL_39;
  }
  uint64_t v20 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
  BOOL v21 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v21, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v28)
    {
      os_log_type_t v24 = (char *)__nw_create_backtrace_string();
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v22, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
          __int16 v32 = 2082;
          *(void *)v33 = v24;
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        goto LABEL_56;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        v31 = "nw_connection_has_proxy_attempt_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_56:
  if (v21) {
    free(v21);
  }
  BOOL has_proxy_child_locked = 0;
LABEL_20:

  return has_proxy_child_locked;
}

void sub_183C64B8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_has_proxy_child_locked(void *a1)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    nw_endpoint_t v3 = nw_endpoint_handler_copy_endpoint(v1);
    nw_endpoint_t v4 = v3;
    if (v3)
    {
      BOOL v5 = nw_endpoint_copy_proxy_original_endpoint(v3);
      if (v5)
      {
        uint64_t v6 = v2;
        char v7 = v6[268];

        if ((v7 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v8 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
          {
            id v9 = v6;

            int v10 = v9;
            char v11 = v6[268];

            if (v11) {
              id v12 = "dry-run ";
            }
            else {
              id v12 = "";
            }
            nw_endpoint_t v13 = nw_endpoint_handler_copy_endpoint(v10);
            logging_description = nw_endpoint_get_logging_description(v13);
            v46 = v9 + 168;
            v47 = v12;
            os_log_type_t v15 = v10;
            char v16 = v15;
            uint64_t v17 = v15[30];
            if (v17 > 5) {
              BOOL v18 = "unknown-state";
            }
            else {
              BOOL v18 = off_1E523FB38[v17];
            }
            v45 = v18;

            os_log_type_t v22 = v16;
            os_log_type_t v23 = v22;
            os_log_type_t v24 = logging_description;
            os_log_type_t v25 = "path";
            switch(*((_DWORD *)v22 + 29))
            {
              case 0:
                break;
              case 1:
                os_log_type_t v25 = "resolver";
                break;
              case 2:
                os_log_type_t v25 = nw_endpoint_flow_mode_string(v22[31]);
                break;
              case 3:
                os_log_type_t v25 = "proxy";
                break;
              case 4:
                os_log_type_t v25 = "fallback";
                break;
              case 5:
                os_log_type_t v25 = "transform";
                break;
              default:
                os_log_type_t v25 = "unknown-mode";
                break;
            }

            BOOL v26 = v23;
            os_unfair_lock_lock((os_unfair_lock_t)v26 + 28);
            id v27 = v26[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v26 + 28);

            *(_DWORD *)buf = 136448258;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v46;
            *(_WORD *)&buf[22] = 2082;
            v52 = v47;
            __int16 v53 = 2082;
            v54 = v24;
            __int16 v55 = 2082;
            v56 = v45;
            __int16 v57 = 2082;
            v58 = v25;
            __int16 v59 = 2114;
            id v60 = v27;
            __int16 v61 = 2112;
            nw_endpoint_t v62 = v4;
            __int16 v63 = 2112;
            BOOL v64 = v5;
            _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint %@ has proxy original endpoint %@", buf, 0x5Cu);
          }
        }
        BOOL v21 = 1;
      }
      else
      {
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000;
        LOBYTE(v52) = 0;
        v48[0] = MEMORY[0x1E4F143A8];
        v48[1] = 3221225472;
        v48[2] = ___ZL42nw_endpoint_handler_has_proxy_child_lockedPU33objcproto22OS_nw_endpoint_handler8NSObject_block_invoke;
        v48[3] = &unk_1E5249D70;
        v48[4] = buf;
        os_log_type_t v19 = v2;
        uint64_t v20 = v48;
        if (objc_opt_respondsToSelector()) {
          [v19[31] applyWithHandler:v19 toChildren:v20];
        }

        BOOL v21 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
        _Block_object_dispose(buf, 8);
      }

LABEL_28:
      goto LABEL_29;
    }
    v33 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
    v34 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (__nwlog_fault(v34, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v35 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
          _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v49)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v35 = __nwlog_obj();
        os_log_type_t v41 = type;
        BOOL v42 = os_log_type_enabled(v35, type);
        if (backtrace_string)
        {
          if (v42)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v35, v41, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_65;
        }
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
          _os_log_impl(&dword_1830D4000, v35, v41, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v35 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
          _os_log_impl(&dword_1830D4000, v35, v44, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_65:
    if (v34) {
      free(v34);
    }
    BOOL v21 = 0;
    goto LABEL_28;
  }
  v29 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
  __int16 v30 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v49 = 0;
  if (__nwlog_fault(v30, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
        _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v49)
    {
      v37 = (char *)__nw_create_backtrace_string();
      v31 = __nwlog_obj();
      os_log_type_t v38 = type;
      BOOL v39 = os_log_type_enabled(v31, type);
      if (v37)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v37;
          _os_log_impl(&dword_1830D4000, v31, v38, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v37);
        goto LABEL_59;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
        _os_log_impl(&dword_1830D4000, v31, v38, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v31 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_proxy_child_locked";
        _os_log_impl(&dword_1830D4000, v31, v43, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_59:
  if (v30) {
    free(v30);
  }
  BOOL v21 = 0;
LABEL_29:

  return v21;
}

void sub_183C6535C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL42nw_endpoint_handler_has_proxy_child_lockedPU33objcproto22OS_nw_endpoint_handler8NSObject_block_invoke(uint64_t a1, uint64_t a2)
{
  int has_proxy_child_locked = nw_endpoint_handler_has_proxy_child_locked(a2);
  if (has_proxy_child_locked) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  return has_proxy_child_locked ^ 1u;
}

BOOL nw_connection_has_proxy_attempt_on_nw_queue(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    nw_context_assert_queue(*((void **)v1 + 3));
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v19 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_has_proxy_attempt_on_nw_queue_block_invoke;
    v13[3] = &unk_1E524B978;
    os_log_type_t v15 = buf;
    os_log_type_t v14 = v2;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_has_proxy_attempt_on_nw_queue_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_has_proxy_attempt_on_nw_queue";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_has_proxy_attempt_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_has_proxy_attempt_on_nw_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_has_proxy_attempt_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_has_proxy_attempt_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

void sub_183C65758(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_connection_has_proxy_attempt_on_nw_queue_block_invoke(uint64_t a1)
{
  BOOL result = nw_connection_has_proxy_attempt_locked_on_nw_queue(*(void **)(a1 + 32));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void nw_connection_shares_protocol_stack(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  char v7 = a1;
  os_log_type_t v8 = a2;
  id v9 = a3;
  id v10 = a4;
  BOOL v11 = v10;
  if (!v7)
  {
    os_log_type_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v49 = "nw_connection_shares_protocol_stack";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v47 = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v16, &v47, &v46)) {
      goto LABEL_81;
    }
    if (v47 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v26 = v47;
      BOOL v27 = os_log_type_enabled(v17, v47);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          char v49 = "nw_connection_shares_protocol_stack";
          __int16 v50 = 2082;
          v51 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v26, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_81:
        if (!v16) {
          goto LABEL_15;
        }
LABEL_82:
        free(v16);
        goto LABEL_15;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v26, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v35 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v35, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_80:

    goto LABEL_81;
  }
  if (!v8)
  {
    char v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v49 = "nw_connection_shares_protocol_stack";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v47 = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v16, &v47, &v46)) {
      goto LABEL_81;
    }
    if (v47 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v20 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null other_connection", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v46)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v36 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v36, "%{public}s called with null other_connection, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    char v28 = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v29 = v47;
    BOOL v30 = os_log_type_enabled(v17, v47);
    if (!v28)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null other_connection, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      char v49 = "nw_connection_shares_protocol_stack";
      __int16 v50 = 2082;
      v51 = v28;
      _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null other_connection, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_55;
  }
  if (!v9)
  {
    BOOL v21 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v49 = "nw_connection_shares_protocol_stack";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v47 = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v16, &v47, &v46)) {
      goto LABEL_81;
    }
    if (v47 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v22 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null completion_queue", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v46)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v37 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v37, "%{public}s called with null completion_queue, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    char v28 = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v31 = v47;
    BOOL v32 = os_log_type_enabled(v17, v47);
    if (!v28)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null completion_queue, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      char v49 = "nw_connection_shares_protocol_stack";
      __int16 v50 = 2082;
      v51 = v28;
      _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null completion_queue, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_55;
  }
  if (!v10)
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v49 = "nw_connection_shares_protocol_stack";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v47 = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v16, &v47, &v46)) {
      goto LABEL_81;
    }
    if (v47 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v24 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v24, "%{public}s called with null completion", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v46)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v38 = v47;
      if (os_log_type_enabled(v17, v47))
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v38, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    char v28 = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v33 = v47;
    BOOL v34 = os_log_type_enabled(v17, v47);
    if (!v28)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        char v49 = "nw_connection_shares_protocol_stack";
        _os_log_impl(&dword_1830D4000, v17, v33, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      char v49 = "nw_connection_shares_protocol_stack";
      __int16 v50 = 2082;
      v51 = v28;
      _os_log_impl(&dword_1830D4000, v17, v33, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_55:

    free(v28);
    if (!v16) {
      goto LABEL_15;
    }
    goto LABEL_82;
  }
  if (v7 == v8)
  {
    uint64_t v12 = v7[2];
    if (v12 && !nw_path_parameters_get_logging_disabled(*(void *)(v12 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      nw_endpoint_t v13 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_INFO))
      {
        int v14 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446466;
        char v49 = "nw_connection_shares_protocol_stack";
        __int16 v50 = 1024;
        LODWORD(v51) = v14;
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_INFO, "%{public}s [C%u] shares a protocol stack with itself", buf, 0x12u);
      }
    }
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_connection_shares_protocol_stack_block_invoke;
    block[3] = &unk_1E524AFA8;
    id v45 = v11;
    dispatch_async(v9, block);
  }
  else
  {
    v39[0] = MEMORY[0x1E4F143A8];
    v39[1] = 3221225472;
    v39[2] = __nw_connection_shares_protocol_stack_block_invoke_2;
    v39[3] = &unk_1E5249BF8;
    v40 = v7;
    os_log_type_t v41 = v8;
    BOOL v42 = v9;
    id v43 = v11;
    nw_connection_async_if_needed(v40, v39);
  }
LABEL_15:
}

void sub_183C66240(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_shares_protocol_stack_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void __nw_connection_shares_protocol_stack_block_invoke_2(id *a1)
{
  id v2 = (os_unfair_lock_s *)((char *)a1[4] + 136);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = __nw_connection_shares_protocol_stack_block_invoke_3;
  v3[3] = &unk_1E5249BF8;
  id v4 = a1[5];
  id v5 = a1[4];
  id v6 = a1[6];
  id v7 = a1[7];
  os_unfair_lock_lock(v2);
  __nw_connection_shares_protocol_stack_block_invoke_3((id *)v3);
  os_unfair_lock_unlock(v2);
}

void __nw_connection_shares_protocol_stack_block_invoke_3(id *a1)
{
  id v2 = (os_unfair_lock_s *)((char *)a1[4] + 136);
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = __nw_connection_shares_protocol_stack_block_invoke_4;
  v3[3] = &unk_1E5249BF8;
  id v4 = a1[5];
  id v5 = a1[4];
  id v6 = a1[6];
  id v7 = a1[7];
  os_unfair_lock_lock(v2);
  __nw_connection_shares_protocol_stack_block_invoke_4((uint64_t)v3);
  os_unfair_lock_unlock(v2);
}

void __nw_connection_shares_protocol_stack_block_invoke_4(uint64_t a1)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  id v2 = *(void **)(a1 + 40);
  BOOL v3 = (void **)*(id *)(a1 + 32);
  id v4 = v2;
  if (!v3)
  {
    BOOL v39 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
    v40 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v69 = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (__nwlog_fault(v40, &v69, &v68))
    {
      if (v69 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v41 = __nwlog_obj();
        os_log_type_t v42 = v69;
        if (os_log_type_enabled(v41, v69))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v68)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v41 = __nwlog_obj();
        os_log_type_t v44 = v69;
        BOOL v45 = os_log_type_enabled(v41, v69);
        if (backtrace_string)
        {
          if (v45)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            __int16 v72 = 2082;
            *(void *)v73 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v41, v44, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_123;
        }
        if (v45)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v41, v44, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v41 = __nwlog_obj();
        os_log_type_t v52 = v69;
        if (os_log_type_enabled(v41, v69))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v41, v52, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_123:
    if (v40) {
      free(v40);
    }
    LOBYTE(v13) = 0;
    goto LABEL_35;
  }
  nw_context_assert_queue(v3[3]);
  nw_context_assert_queue(v4[3]);
  if (*((_DWORD *)v3 + 20) == 5)
  {
    id v5 = v3[2];
    if (v5 && !nw_path_parameters_get_logging_disabled(v5[13]))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v6 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_25;
      }
      goto LABEL_15;
    }
    goto LABEL_95;
  }
  if (*((_DWORD *)v4 + 20) != 5)
  {
    id v6 = v3[18];
    if (!v6 || (*((unsigned char *)v3 + 109) & 0x40) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v9 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
      id v10 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v69 = OS_LOG_TYPE_ERROR;
      char v68 = 0;
      if (__nwlog_fault(v10, &v69, &v68))
      {
        if (v69 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v11 = (id)gLogObj;
          os_log_type_t v12 = v69;
          if (os_log_type_enabled(v11, v69))
          {
            *(_DWORD *)buf = 136446210;
            v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Cannot check shares protocol stack without connected endpoint handler", buf, 0xCu);
          }
        }
        else if (v68)
        {
          BOOL v21 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v11 = (id)gLogObj;
          os_log_type_t v22 = v69;
          BOOL v23 = os_log_type_enabled(v11, v69);
          if (v21)
          {
            if (v23)
            {
              *(_DWORD *)buf = 136446466;
              v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
              __int16 v72 = 2082;
              *(void *)v73 = v21;
              _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s Cannot check shares protocol stack without connected endpoint handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v21);
            if (!v10) {
              goto LABEL_25;
            }
            goto LABEL_24;
          }
          if (v23)
          {
            *(_DWORD *)buf = 136446210;
            v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s Cannot check shares protocol stack without connected endpoint handler, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v11 = (id)gLogObj;
          os_log_type_t v29 = v69;
          if (os_log_type_enabled(v11, v69))
          {
            *(_DWORD *)buf = 136446210;
            v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            _os_log_impl(&dword_1830D4000, v11, v29, "%{public}s Cannot check shares protocol stack without connected endpoint handler, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v10) {
        goto LABEL_25;
      }
LABEL_24:
      free(v10);
      goto LABEL_25;
    }
    id v24 = v4[18];
    BOOL v64 = v24;
    if (v24 && (*((unsigned char *)v4 + 109) & 0x40) != 0)
    {
      os_log_type_t v33 = v24;
      __int16 v59 = v6;
      id v60 = v33;
      os_log_type_t type = nw_endpoint_handler_copy_flow(v59);
      __int16 v61 = nw_endpoint_handler_copy_flow(v60);
      LODWORD(v13) = 0;
      if (!type) {
        goto LABEL_86;
      }
      BOOL v34 = v61;
      if (v61)
      {
        __int16 v57 = type;
        v58 = v61;
        nw_endpoint_t v13 = (char *)v57 + 376;
        while (*(_DWORD *)(*((void *)v13 + 2) + 32) == 2)
        {
LABEL_64:
          nw_endpoint_t v13 = (char *)*((void *)v13 + 4);
          if (!v13) {
            goto LABEL_85;
          }
        }
        os_log_type_t v35 = (char *)v58 + 376;
        while (1)
        {
          if (*(_DWORD *)(*((void *)v35 + 2) + 32) != 2)
          {
            if (v13 == v35)
            {
              if (gLogDatapath)
              {
                v54 = __nwlog_obj();
                if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
                {
                  __int16 v55 = "invalid";
                  if (v13 && *((void *)v13 + 2)) {
                    __int16 v55 = (const char *)*((void *)v13 + 2);
                  }
                  *(_DWORD *)buf = 136447234;
                  v71 = "nw_endpoint_flow_shares_protocol_stack";
                  __int16 v72 = 2080;
                  *(void *)v73 = v55;
                  *(_WORD *)&v73[8] = 2048;
                  *(void *)&v73[10] = v13;
                  *(_WORD *)&v73[18] = 2080;
                  v74 = v55;
                  __int16 v75 = 2048;
                  v76 = v13;
                  _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEBUG, "%{public}s protocol %s (%p) matches protocol %s (%p)", buf, 0x34u);
                }
              }
              LODWORD(v13) = 1;
LABEL_85:

LABEL_86:
              BOOL v34 = v61;
              break;
            }
            if (gLogDatapath)
            {
              log = __nwlog_obj();
              if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
              {
                if (v13)
                {
                  os_log_type_t v36 = (const char *)*((void *)v13 + 2);
                  if (!v36) {
                    os_log_type_t v36 = "invalid";
                  }
                }
                else
                {
                  os_log_type_t v36 = "invalid";
                }
                os_log_type_t v37 = (const char *)*((void *)v35 + 2);
                if (!v37) {
                  os_log_type_t v37 = "invalid";
                }
                *(_DWORD *)buf = 136447234;
                v71 = "nw_endpoint_flow_shares_protocol_stack";
                __int16 v72 = 2080;
                *(void *)v73 = v36;
                *(_WORD *)&v73[8] = 2048;
                *(void *)&v73[10] = v13;
                *(_WORD *)&v73[18] = 2080;
                v74 = v37;
                __int16 v75 = 2048;
                v76 = v35;
                _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s protocol %s (%p) does not match protocol %s (%p)", buf, 0x34u);
              }
            }
          }
          os_log_type_t v35 = (char *)*((void *)v35 + 4);
          if (!v35) {
            goto LABEL_64;
          }
        }
      }

      goto LABEL_88;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v69 = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (__nwlog_fault(v26, &v69, &v68))
    {
      if (v69 == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v27 = (id)gLogObj;
        os_log_type_t v28 = v69;
        if (os_log_type_enabled(v27, v69))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s Cannot check shares protocol stack without connected endpoint handler", buf, 0xCu);
        }
      }
      else if (v68)
      {
        BOOL v30 = (char *)__nw_create_backtrace_string();
        BOOL v27 = __nwlog_obj();
        os_log_type_t v31 = v69;
        BOOL v32 = os_log_type_enabled(v27, v69);
        if (v30)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
            __int16 v72 = 2082;
            *(void *)v73 = v30;
            _os_log_impl(&dword_1830D4000, v27, v31, "%{public}s Cannot check shares protocol stack without connected endpoint handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v30);
          if (!v26) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v27, v31, "%{public}s Cannot check shares protocol stack without connected endpoint handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v27 = __nwlog_obj();
        os_log_type_t v38 = v69;
        if (os_log_type_enabled(v27, v69))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v27, v38, "%{public}s Cannot check shares protocol stack without connected endpoint handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v26)
    {
LABEL_51:
      LODWORD(v13) = 0;
LABEL_88:

LABEL_26:
      int v14 = v3[2];
      if (!v14) {
        goto LABEL_35;
      }
      goto LABEL_27;
    }
LABEL_50:
    free(v26);
    goto LABEL_51;
  }
  id v7 = v3[2];
  if (v7 && !nw_path_parameters_get_logging_disabled(v7[13]))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v6 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_25;
    }
LABEL_15:
    int v8 = *((_DWORD *)v3 + 112);
    *(_DWORD *)buf = 136446466;
    v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
    __int16 v72 = 1024;
    *(_DWORD *)v73 = v8;
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Cancelled, cannot check for shares protocol stack", buf, 0x12u);
LABEL_25:
    LODWORD(v13) = 0;
    goto LABEL_26;
  }
LABEL_95:
  LODWORD(v13) = 0;
  int v14 = v3[2];
  if (!v14) {
    goto LABEL_35;
  }
LABEL_27:
  if (!nw_path_parameters_get_logging_disabled(v14[13]))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v15 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_34;
    }
    int v16 = *((_DWORD *)v3 + 112);
    uint64_t v17 = v4;
    os_log_type_t v18 = v17;
    if (v17)
    {
      uint64_t v19 = *((unsigned int *)v17 + 112);
LABEL_33:

      *(_DWORD *)buf = 136446978;
      v71 = "nw_connection_shares_protocol_stack_locked_on_nw_queue";
      __int16 v72 = 1024;
      *(_DWORD *)v73 = v16;
      *(_WORD *)&v73[4] = 2048;
      *(void *)&v73[6] = v19;
      *(_WORD *)&v73[14] = 1024;
      *(_DWORD *)&v73[16] = v13;
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] shares a protocol stack with [C%llu]: %{BOOL}d", buf, 0x22u);
LABEL_34:

      goto LABEL_35;
    }
    char v46 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v71 = "nw_connection_get_id";
    os_log_type_t v47 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v69 = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (__nwlog_fault(v47, &v69, &v68))
    {
      if (v69 == OS_LOG_TYPE_FAULT)
      {
        v48 = __nwlog_obj();
        os_log_type_t v49 = v69;
        if (os_log_type_enabled(v48, v69))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_get_id";
          _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v68)
      {
        __int16 v50 = (char *)__nw_create_backtrace_string();
        v48 = __nwlog_obj();
        os_log_type_t typea = v69;
        BOOL v51 = os_log_type_enabled(v48, v69);
        if (v50)
        {
          if (v51)
          {
            *(_DWORD *)buf = 136446466;
            v71 = "nw_connection_get_id";
            __int16 v72 = 2082;
            *(void *)v73 = v50;
            _os_log_impl(&dword_1830D4000, v48, typea, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v50);
          goto LABEL_132;
        }
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_get_id";
          _os_log_impl(&dword_1830D4000, v48, typea, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v48 = __nwlog_obj();
        os_log_type_t v53 = v69;
        if (os_log_type_enabled(v48, v69))
        {
          *(_DWORD *)buf = 136446210;
          v71 = "nw_connection_get_id";
          _os_log_impl(&dword_1830D4000, v48, v53, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_132:
    if (v47) {
      free(v47);
    }
    uint64_t v19 = 0;
    goto LABEL_33;
  }
LABEL_35:

  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __nw_connection_shares_protocol_stack_block_invoke_5;
  block[3] = &unk_1E5249BD0;
  os_log_type_t v20 = *(NSObject **)(a1 + 48);
  id v66 = *(id *)(a1 + 56);
  char v67 = (char)v13;
  dispatch_async(v20, block);
}

void sub_183C67378(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, uint64_t a20,void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_shares_protocol_stack_block_invoke_5(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

void __nw_connection_start_throughput_monitor_on_nw_queue_block_invoke(uint64_t a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v1 = (void **)*(id *)(a1 + 32);
  id v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1[3]);
    if ((*((unsigned char *)v2 + 109) & 0x40) == 0)
    {
      BOOL v3 = v2[2];
      if (v3 && !nw_path_parameters_get_logging_disabled(v3[13]))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v4 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
        {
          int v5 = *((_DWORD *)v2 + 112);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_throughput_measure_on_nw_queue";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v5;
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection does not have a connected handler", buf, 0x12u);
        }
      }
      goto LABEL_32;
    }
    uint64_t v38 = 0;
    memset(v37, 0, sizeof(v37));
    long long v35 = 0u;
    long long v36 = 0u;
    memset(buf, 0, sizeof(buf));
    id v6 = v2;
    id v7 = v6[2];

    if (!nw_parameters_get_multipath(v7))
    {
      int v8 = v6;
      nw_context_assert_queue(v2[3]);
      id v9 = v8;
      if (nw_parameters_get_ip_protocol(v6[2]) == 6)
      {
        BOOL v10 = nw_endpoint_handler_fillout_tcp_info(v9[18], buf);

        if (v10)
        {
          BOOL v11 = (unsigned char *)(*(void *)((char *)&v37[2] + 12) + *(void *)((char *)v37 + 12));
          uint64_t v12 = mach_continuous_time();
          if (v12 <= 1) {
            uint64_t v13 = 1;
          }
          else {
            uint64_t v13 = v12;
          }
          uint64_t v14 = (uint64_t)v9[45];
          if (v14)
          {
            unint64_t v15 = nw_delta_nanos(v14, v13);
            int v16 = v6[2];
            unint64_t v17 = 1000 * (v11 - (unsigned char *)v9[44]) / (v15 / 0xF4240);
            if (v16 && !nw_path_parameters_get_logging_disabled(v16[13]))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              os_log_type_t v18 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
              {
                unsigned int v19 = *((_DWORD *)v9 + 112);
                LODWORD(v39[0]) = 136446722;
                *(void *)((char *)v39 + 4) = "nw_connection_throughput_measure_on_nw_queue";
                WORD2(v39[1]) = 1024;
                *(_DWORD *)((char *)&v39[1] + 6) = v19;
                WORD1(v39[2]) = 2048;
                *(void *)((char *)&v39[2] + 4) = v17;
                _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] bps: %llu", (uint8_t *)v39, 0x1Cu);
              }
            }
            if (v17 < *((unsigned int *)v9 + 94))
            {
              os_log_type_t v20 = v9;
              nw_context_assert_queue(v2[3]);
              BOOL v21 = (const void *)*((void *)v20 + 48);
              if (v21 && v20[20] != 5)
              {
                os_log_type_t v22 = _Block_copy(v21);
                dispatch_qos_class_t v23 = v20[48];
                v39[0] = MEMORY[0x1E4F143A8];
                v39[1] = 3221225472;
                v39[2] = ___ZL45nw_connection_send_low_throughput_on_nw_queueP24NWConcrete_nw_connectiony_block_invoke;
                v39[3] = &unk_1E5249D98;
                id v40 = v22;
                unint64_t v41 = v17;
                id v24 = v22;
                nw_connection_async_client(v20, v23, v39);
              }
            }
          }
          *((_OWORD *)v9 + 22) = *((_OWORD *)v9 + 21);
          v9[42] = v11;
          v9[43] = (id)v13;
        }
        goto LABEL_32;
      }
    }
    goto LABEL_32;
  }
  id v25 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_throughput_measure_on_nw_queue";
  os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v39[0]) = 16;
  char v33 = 0;
  if (__nwlog_fault(v26, v39, &v33))
  {
    if (LOBYTE(v39[0]) == 17)
    {
      BOOL v27 = __nwlog_obj();
      os_log_type_t v28 = v39[0];
      if (os_log_type_enabled(v27, v39[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_throughput_measure_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v27 = __nwlog_obj();
      os_log_type_t v30 = v39[0];
      BOOL v31 = os_log_type_enabled(v27, v39[0]);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_throughput_measure_on_nw_queue";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_49;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_throughput_measure_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v27 = __nwlog_obj();
      os_log_type_t v32 = v39[0];
      if (os_log_type_enabled(v27, v39[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_throughput_measure_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v27, v32, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_49:
  if (v26) {
    free(v26);
  }
LABEL_32:
}

void sub_183C67998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL45nw_connection_send_low_throughput_on_nw_queueP24NWConcrete_nw_connectiony_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(void *)(a1 + 40));
}

void nw_connection_report_estimated_byte_threshold_change_on_queue(NWConcrete_nw_connection *a1, uint64_t a2, int a3, int a4, int a5)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  BOOL v10 = v9;
  if (!v9)
  {
    os_log_type_t v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
    dispatch_qos_class_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v23, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v24 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
            __int16 v34 = 2082;
            long long v35 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v24 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_56:
    if (v23) {
      free(v23);
    }
    goto LABEL_39;
  }
  nw_context_assert_queue(v9->context);
  if ((*((unsigned char *)v10 + 109) & 0x40) != 0)
  {
    uint64_t v12 = nw_endpoint_handler_copy_connected_path(v10->parent_endpoint_handler);
    if (v12)
    {
      if (a5) {
        int v14 = 8;
      }
      else {
        int v14 = 6;
      }
      if (a5) {
        int v15 = 7;
      }
      else {
        int v15 = 5;
      }
      if (a4) {
        int v14 = v15;
      }
      if (a5) {
        int v16 = 4;
      }
      else {
        int v16 = 2;
      }
      if (a5) {
        int v17 = 3;
      }
      else {
        int v17 = 1;
      }
      if (a4) {
        int v16 = v17;
      }
      if (a3) {
        int v18 = v16;
      }
      else {
        int v18 = v14;
      }
      nw_connection_report_symptom_internal_on_nw_queue(421899, v10->endpoint, v10->parameters, v12, 0, 0, a2, v18, 0, v10->privacy_stance);
    }
    else
    {
      parameters = v10->parameters;
      if (parameters && !nw_path_parameters_get_logging_disabled(*((void *)parameters + 13)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v20 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
        {
          unsigned int top_id = v10->top_id;
          *(_DWORD *)buf = 136446466;
          char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
          __int16 v34 = 1024;
          LODWORD(v35) = top_id;
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Not reporting estimated byte threshold change because connection has no connected path", buf, 0x12u);
        }
      }
    }
    goto LABEL_38;
  }
  BOOL v11 = v10->parameters;
  if (v11 && !nw_path_parameters_get_logging_disabled(*((void *)v11 + 13)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v12 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
    {
      unsigned int v13 = v10->top_id;
      *(_DWORD *)buf = 136446466;
      char v33 = "nw_connection_report_estimated_byte_threshold_change_on_queue";
      __int16 v34 = 1024;
      LODWORD(v35) = v13;
      _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Not reporting estimated byte threshold change because connection has no connected endpoint handler", buf, 0x12u);
    }
LABEL_38:
  }
LABEL_39:
}

void sub_183C67E74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_report_excessive_data_usage_event(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v71 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  if (v5)
  {
    xpc_object_t v6 = xpc_dictionary_create(0, 0, 0);
    if (v6)
    {
      id v7 = v5;
      int v8 = v7[1].isa;

      if (!v8)
      {
        Class isa = v7[2].isa;
        if (!isa || nw_path_parameters_get_logging_disabled(*((void *)isa + 13)))
        {
          uint64_t effective_process_name = 0;
          goto LABEL_77;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v10 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
        {
          int v24 = (int)v7[56].isa;
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
          __int16 v63 = 1024;
          LODWORD(v64) = v24;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection has no remote endpoint", buf, 0x12u);
        }
        uint64_t effective_process_name = 0;
LABEL_76:

LABEL_77:
        goto LABEL_78;
      }
      nw_path_t v9 = nw_connection_copy_current_path(v7);
      BOOL v10 = v9;
      if (v9)
      {
        BOOL v11 = nw_path_copy_interface(v9);
        if (!v11)
        {
          Class v30 = v7[2].isa;
          if (v30 && !nw_path_parameters_get_logging_disabled(*((void *)v30 + 13)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v31 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              int v32 = (int)v7[56].isa;
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
              __int16 v63 = 1024;
              LODWORD(v64) = v32;
              _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection has no interface", buf, 0x12u);
            }
          }
          BOOL v11 = 0;
          uint64_t effective_process_name = 0;
          goto LABEL_75;
        }
        if (nw_utilities_get_self_name::onceToken != -1) {
          dispatch_once(&nw_utilities_get_self_name::onceToken, &__block_literal_global_11_44681);
        }
        uint64_t v12 = (const char *)nw_utilities_get_self_name::name;
        if (nw_utilities_get_self_name::name)
        {
          unsigned int v13 = v7;
          id v14 = v13[2];
          v58 = (NWConcrete_nw_connection *)v13;

          uint64_t effective_process_name = nw_parameters_get_effective_process_name(v14);
          if (effective_process_name)
          {
            __int16 v55 = (const char *)effective_process_name;
            int v16 = v11;
            uint64_t v17 = v16[24];

            if (v17 > 4) {
              int v18 = "unknown";
            }
            else {
              int v18 = off_1E524BC28[v17];
            }
            string = (char *)v18;
            __int16 v34 = v16;
            int v35 = v34[25];
            v54 = v34;

            if (v35 <= 1001)
            {
              if (!v35)
              {
                uint64_t v36 = "other";
                goto LABEL_67;
              }
              if (v35 == 1001)
              {
                uint64_t v36 = "wifi_infrastructure";
                goto LABEL_67;
              }
            }
            else
            {
              switch(v35)
              {
                case 1002:
                  uint64_t v36 = "wifi_awdl";
                  goto LABEL_67;
                case 4001:
                  uint64_t v36 = "coprocessor";
                  goto LABEL_67;
                case 5001:
                  uint64_t v36 = "companion";
LABEL_67:
                  v56 = (char *)v36;
                  xpc_dictionary_set_uint64(v6, "bytes_in", a2);
                  xpc_dictionary_set_uint64(v6, "bytes_out", a3);
                  xpc_dictionary_set_string(v6, "bundle_id", v12);
                  xpc_dictionary_set_string(v6, "effective_bundle_id", v55);
                  xpc_dictionary_set_string(v6, "interface_type", string);
                  xpc_dictionary_set_string(v6, "interface_subtype", v56);
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v37 = (id)gLogObj;
                  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446722;
                    nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
                    __int16 v63 = 2048;
                    uint64_t v64 = a2;
                    __int16 v65 = 2048;
                    uint64_t v66 = a3;
                    _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, "%{public}s Excessive data usage detected, bytes in/out: %llu/%llu", buf, 0x20u);
                  }

                  if (os_variant_has_internal_diagnostics()
                    && nw_connection_stats_get_apple_host(v58))
                  {
                    description = nw_endpoint_get_description(v8);
                    xpc_dictionary_set_string(v6, "endpoint", description);
                    id v40 = __nwlog_obj();
                    if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
                    {
                      id v41 = nw_connection_copy_connected_local_endpoint(v58);
                      uint64_t v42 = nw_endpoint_get_description(v41);
                      id v43 = nw_connection_copy_connected_remote_endpoint(v58);
                      logging_description = nw_endpoint_get_logging_description(v43);
                      *(_DWORD *)buf = 136447234;
                      nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
                      __int16 v63 = 2082;
                      uint64_t v64 = (uint64_t)v42;
                      __int16 v65 = 2082;
                      uint64_t v66 = (uint64_t)logging_description;
                      __int16 v67 = 2080;
                      char v68 = string;
                      __int16 v69 = 2080;
                      v70 = v56;
                      _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEBUG, "%{public}s Excessive data usage event: %{public}s<->%{public}s, interface: %s, subtype: %s", buf, 0x34u);
                    }
                  }
                  analytics_send_event_delayInitStub(v38);
                  uint64_t effective_process_name = 1;
                  BOOL v11 = v54;
                  goto LABEL_75;
              }
            }
            uint64_t v36 = "unknown";
            goto LABEL_67;
          }
LABEL_75:

          goto LABEL_76;
        }
      }
      else
      {
        Class v28 = v7[2].isa;
        if (!v28 || nw_path_parameters_get_logging_disabled(*((void *)v28 + 13)))
        {
          BOOL v10 = 0;
          uint64_t effective_process_name = 0;
          goto LABEL_76;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v11 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
        {
          int v29 = (int)v7[56].isa;
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
          __int16 v63 = 1024;
          LODWORD(v64) = v29;
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection has no path", buf, 0x12u);
        }
      }
      uint64_t effective_process_name = 0;
      goto LABEL_75;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v19 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (__nwlog_fault(v20, &type, &v59))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v21 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
        }
      }
      else if (v59)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v21 = (id)gLogObj;
        os_log_type_t v26 = type;
        BOOL v27 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v27)
          {
            *(_DWORD *)buf = 136446466;
            nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
            __int16 v63 = 2082;
            uint64_t v64 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s xpc_dictionary_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v20) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s xpc_dictionary_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v21 = (id)gLogObj;
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
          _os_log_impl(&dword_1830D4000, v21, v33, "%{public}s xpc_dictionary_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v20)
    {
LABEL_53:
      uint64_t effective_process_name = 0;
LABEL_78:

      goto LABEL_79;
    }
LABEL_52:
    free(v20);
    goto LABEL_53;
  }
  char v46 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
  os_log_type_t v47 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v59 = 0;
  if (__nwlog_fault(v47, &type, &v59))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
        _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v59)
    {
      __int16 v50 = (char *)__nw_create_backtrace_string();
      v48 = __nwlog_obj();
      os_log_type_t v51 = type;
      BOOL v52 = os_log_type_enabled(v48, type);
      if (v50)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
          __int16 v63 = 2082;
          uint64_t v64 = (uint64_t)v50;
          _os_log_impl(&dword_1830D4000, v48, v51, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v50);
        goto LABEL_98;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
        _os_log_impl(&dword_1830D4000, v48, v51, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v48 = __nwlog_obj();
      os_log_type_t v53 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v62 = "nw_report_excessive_data_usage_event";
        _os_log_impl(&dword_1830D4000, v48, v53, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_98:
  if (v47) {
    free(v47);
  }
  uint64_t effective_process_name = 0;
LABEL_79:

  return effective_process_name;
}

void sub_183C6897C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_attempted_endpoint_array(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    id v19 = __Block_byref_object_copy__79980;
    os_log_type_t v20 = __Block_byref_object_dispose__79981;
    id v21 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_attempted_endpoint_array_block_invoke;
    v13[3] = &unk_1E524B978;
    id v14 = v1;
    int v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_attempted_endpoint_array_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_attempted_endpoint_array";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_attempted_endpoint_array";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_attempted_endpoint_array";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_attempted_endpoint_array";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_attempted_endpoint_array";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_attempted_endpoint_array_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(*(void *)(a1 + 32) + 328);
  if (v1)
  {
    uint64_t v3 = nw_array_create();
    if (v3 != v1)
    {
      uint64_t v4 = v3;
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v3 + 16, *(void ***)(v1 + 16), *(void ***)(v1 + 24), (uint64_t)(*(void *)(v1 + 24) - *(void *)(v1 + 16)) >> 3);
      uint64_t v1 = v4;
    }
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
    xpc_object_t v6 = *(void **)(v5 + 40);
    *(void *)(v5 + 40) = v1;
  }
}

void sub_183C6AD6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, objc_super a10)
{
  a10.super_class = (Class)NWConcrete_nw_agent_client;
  [(_Unwind_Exception *)&a10 dealloc];
  _Unwind_Resume(a1);
}

void sub_183C6B700(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_agent_get_next_id(void)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int add = atomic_fetch_add(nw_agent_get_next_id(void)::s_last_id, 1u);
  uint64_t result = add + 1;
  if (add == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      uint64_t v4 = "nw_agent_get_next_id";
      __int16 v5 = 1024;
      int v6 = 0;
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached %u agent ids, wrapping", (uint8_t *)&v3, 0x12u);
    }

    return nw_agent_get_next_id();
  }
  return result;
}

id nw_agent_client_copy_advertise_descriptor(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[7];
    goto LABEL_3;
  }
  __int16 v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_agent_client_copy_advertise_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_advertise_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null client", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_agent_client_copy_advertise_descriptor";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null client, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_advertise_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null client, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_advertise_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null client, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

id nw_agent_client_copy_browse_descriptor(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[8];
    goto LABEL_3;
  }
  __int16 v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_agent_client_copy_browse_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_browse_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null client", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_agent_client_copy_browse_descriptor";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null client, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_browse_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null client, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_browse_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null client, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

id nw_agent_client_copy_group_descriptor(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[9];
    goto LABEL_3;
  }
  __int16 v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_agent_client_copy_group_descriptor";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_group_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null client", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_agent_client_copy_group_descriptor";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null client, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_group_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null client, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_agent_client_copy_group_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null client, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_agent_send_error_response(void *a1, void *a2, void *a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  __int16 v5 = a1;
  int v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    char v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v47 = "nw_agent_send_error_response";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v17, &type, &v44)) {
      goto LABEL_71;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v47 = "nw_agent_send_error_response";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null agent", buf, 0xCu);
      }
      goto LABEL_70;
    }
    if (!v44)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v47 = "nw_agent_send_error_response";
        _os_log_impl(&dword_1830D4000, v18, v40, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_70;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v18 = __nwlog_obj();
    os_log_type_t v31 = type;
    BOOL v32 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v47 = "nw_agent_send_error_response";
        _os_log_impl(&dword_1830D4000, v18, v31, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
      goto LABEL_70;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v47 = "nw_agent_send_error_response";
      __int16 v48 = 2082;
      uint64_t v49 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v18, v31, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_44:

    free(backtrace_string);
    goto LABEL_71;
  }
  if (!v6)
  {
    os_log_type_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v47 = "nw_agent_send_error_response";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v17, &type, &v44)) {
      goto LABEL_71;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v47 = "nw_agent_send_error_response";
        _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null client", buf, 0xCu);
      }
      goto LABEL_70;
    }
    if (!v44)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v47 = "nw_agent_send_error_response";
        _os_log_impl(&dword_1830D4000, v18, v41, "%{public}s called with null client, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_70;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v18 = __nwlog_obj();
    os_log_type_t v33 = type;
    BOOL v34 = os_log_type_enabled(v18, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v47 = "nw_agent_send_error_response";
        _os_log_impl(&dword_1830D4000, v18, v33, "%{public}s called with null client, no backtrace", buf, 0xCu);
      }
      goto LABEL_70;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v47 = "nw_agent_send_error_response";
      __int16 v48 = 2082;
      uint64_t v49 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v18, v33, "%{public}s called with null client, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_44;
  }
  if (!v7)
  {
    uint64_t v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v47 = "nw_agent_send_error_response";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (__nwlog_fault(v17, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v47 = "nw_agent_send_error_response";
          _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null error", buf, 0xCu);
        }
LABEL_70:

        goto LABEL_71;
      }
      if (!v44)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v47 = "nw_agent_send_error_response";
          _os_log_impl(&dword_1830D4000, v18, v42, "%{public}s called with null error, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_70;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v18 = __nwlog_obj();
      os_log_type_t v35 = type;
      BOOL v36 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v47 = "nw_agent_send_error_response";
          _os_log_impl(&dword_1830D4000, v18, v35, "%{public}s called with null error, no backtrace", buf, 0xCu);
        }
        goto LABEL_70;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v47 = "nw_agent_send_error_response";
        __int16 v48 = 2082;
        uint64_t v49 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v18, v35, "%{public}s called with null error, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_44;
    }
LABEL_71:
    if (v17) {
      free(v17);
    }
    BOOL v14 = 0;
    goto LABEL_8;
  }
  nw_path_t v9 = v7;
  int error_code = nw_error_get_error_code(v9);
  char error_domain = nw_error_get_error_domain(v9);
  os_log_type_t v12 = (char *)malloc_type_calloc(1uLL, 0xDuLL, 0xEAFB8F1AuLL);
  char v13 = (unsigned __int8 *)v12;
  if (v12)
  {
    char *v12 = -40;
    *(_DWORD *)(v12 + 1) = 8;
    *(_DWORD *)(v12 + 5) = error_code;
    v12[9] = error_domain;
    v12[12] = 0;
    *((_WORD *)v12 + 5) = 0;
LABEL_6:

    BOOL v14 = nw_agent_assign(v5, v13, 0xDuLL, v6 + 8, 0);
    if (v13) {
      free(v13);
    }
LABEL_8:

    return v14;
  }
  int v24 = __nwlog_obj();
  os_log_type_enabled(v24, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v47 = "strict_calloc";
  __int16 v48 = 2048;
  uint64_t v49 = 1;
  __int16 v50 = 2048;
  uint64_t v51 = 13;
  os_log_type_t v25 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v25);
  if (!result)
  {
    free(v25);
    os_log_type_t v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v47 = "nw_necp_append_tlv";
    BOOL v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (__nwlog_fault(v27, &type, &v44))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        Class v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null tlv_start", buf, 0xCu);
        }
      }
      else if (v44)
      {
        os_log_type_t v37 = (char *)__nw_create_backtrace_string();
        Class v28 = __nwlog_obj();
        os_log_type_t v38 = type;
        BOOL v39 = os_log_type_enabled(v28, type);
        if (v37)
        {
          if (v39)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v47 = "nw_necp_append_tlv";
            __int16 v48 = 2082;
            uint64_t v49 = (uint64_t)v37;
            _os_log_impl(&dword_1830D4000, v28, v38, "%{public}s called with null tlv_start, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v37);
          goto LABEL_77;
        }
        if (v39)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v28, v38, "%{public}s called with null tlv_start, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        Class v28 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v47 = "nw_necp_append_tlv";
          _os_log_impl(&dword_1830D4000, v28, v43, "%{public}s called with null tlv_start, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_77:
    if (v27) {
      free(v27);
    }
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

void sub_183C6C9D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_agent_assign(NWConcrete_nw_agent *a1, unsigned __int8 *a2, size_t a3, unsigned __int8 *a4, char a5)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  nw_path_t v9 = a1;
  if (!v9)
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_agent_assign";
    int v24 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v24, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_agent_assign";
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null agent", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v25 = __nwlog_obj();
        os_log_type_t v30 = type;
        BOOL v31 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v38 = "nw_agent_assign";
            __int16 v39 = 2082;
            uint64_t v40 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v30, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_agent_assign";
          _os_log_impl(&dword_1830D4000, v25, v30, "%{public}s called with null agent, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v25 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_agent_assign";
          _os_log_impl(&dword_1830D4000, v25, v32, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_47:
    if (!v24) {
      goto LABEL_27;
    }
    os_log_type_t v21 = (char *)v24;
    goto LABEL_26;
  }
  if (a3 >= 0xFFFFFFF0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    os_log_type_t v38 = "nw_agent_assign";
    __int16 v39 = 2048;
    uint64_t v40 = a3;
    BOOL v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v11, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_agent_assign";
          __int16 v39 = 2048;
          uint64_t v40 = a3;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s Invalid data length (%zu)", buf, 0x16u);
        }
      }
      else if (v35)
      {
        __int16 v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (id)gLogObj;
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v12, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446722;
            os_log_type_t v38 = "nw_agent_assign";
            __int16 v39 = 2048;
            uint64_t v40 = a3;
            __int16 v41 = 2082;
            os_log_type_t v42 = v17;
            _os_log_impl(&dword_1830D4000, v12, v18, "%{public}s Invalid data length (%zu), dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v17);
          if (!v11) {
            goto LABEL_27;
          }
LABEL_25:
          os_log_type_t v21 = (char *)v11;
LABEL_26:
          free(v21);
          goto LABEL_27;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_agent_assign";
          __int16 v39 = 2048;
          uint64_t v40 = a3;
          _os_log_impl(&dword_1830D4000, v12, v18, "%{public}s Invalid data length (%zu), no backtrace", buf, 0x16u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = (id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_agent_assign";
          __int16 v39 = 2048;
          uint64_t v40 = a3;
          _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s Invalid data length (%zu), backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
    if (!v11)
    {
LABEL_27:
      uint64_t fd = 0;
LABEL_28:

      return fd;
    }
    goto LABEL_25;
  }
  BOOL v14 = malloc_type_calloc(1uLL, a3 + 16, 0xEAFB8F1AuLL);
  if (v14)
  {
LABEL_9:
    _OWORD *v14 = *(_OWORD *)a4;
    if (a3) {
      memcpy(v14 + 1, a2, a3);
    }
    int v15 = (void *)*((void *)v9 + 105);
    v33[0] = MEMORY[0x1E4F143A8];
    v33[1] = 3221225472;
    v33[2] = ___ZL15nw_agent_assignP19NWConcrete_nw_agentPhmS1_b_block_invoke;
    v33[3] = &__block_descriptor_49_e8_B12__0i8l;
    char v34 = a5;
    v33[4] = v14;
    v33[5] = a3 + 16;
    uint64_t fd = nw_fd_wrapper_get_fd(v15, v33);
    free(v14);
    goto LABEL_28;
  }
  BOOL v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v38 = "strict_calloc";
  __int16 v39 = 2048;
  uint64_t v40 = 1;
  __int16 v41 = 2048;
  os_log_type_t v42 = (char *)(a3 + 16);
  Class v28 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_9;
  }
  __break(1u);
  return result;
}

void sub_183C6D0C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL15nw_agent_assignP19NWConcrete_nw_agentPhmS1_b_block_invoke(uint64_t a1, int a2)
{
  if (*(unsigned char *)(a1 + 48)) {
    int v3 = 20;
  }
  else {
    int v3 = 11;
  }
  return nw_network_agent_ctl_setsockopt_inner(a2, v3, *(const unsigned __int8 **)(a1 + 32), *(_DWORD *)(a1 + 40), 0, 0) == 0;
}

BOOL nw_agent_send_group_member_update(void *a1, void *a2, void *a3)
{
  __int16 v5 = a1;
  int v6 = a2;
  unint64_t v10 = 0;
  BOOL v7 = nw_path_create_endpoint_array_result(&v10, a3, 213);
  BOOL v8 = nw_agent_assign(v5, (unsigned __int8 *)v7, v10, v6 + 8, 1);
  if (v7) {
    free((void *)v7);
  }

  return v8;
}

void sub_183C6D1B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_agent *nw_agent_create(const char *a1, const char *a2, const char *a3, void *a4)
{
  uint64_t v143 = *MEMORY[0x1E4F143B8];
  BOOL v8 = a4;
  nw_path_t v9 = v8;
  if (!a1)
  {
    v86 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (!__nwlog_fault(v87, &type, &v138)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      os_log_type_t v89 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v89, "%{public}s called with null domain", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (!v138)
    {
      v88 = __nwlog_obj();
      os_log_type_t v125 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v125, "%{public}s called with null domain, backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_213;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    os_log_type_t v107 = type;
    BOOL v108 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (v108)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v107, "%{public}s called with null domain, no backtrace", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (v108)
    {
      *(_DWORD *)location = 136446466;
      *(void *)&location[4] = "nw_agent_create";
      __int16 v141 = 2082;
      v142 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v88, v107, "%{public}s called with null domain, dumping backtrace:%{public}s", location, 0x16u);
    }
    goto LABEL_146;
  }
  if (!a2)
  {
    v90 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (!__nwlog_fault(v87, &type, &v138)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      os_log_type_t v91 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v91, "%{public}s called with null type", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (!v138)
    {
      v88 = __nwlog_obj();
      os_log_type_t v126 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v126, "%{public}s called with null type, backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_213;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    os_log_type_t v109 = type;
    BOOL v110 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (v110)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v109, "%{public}s called with null type, no backtrace", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (v110)
    {
      *(_DWORD *)location = 136446466;
      *(void *)&location[4] = "nw_agent_create";
      __int16 v141 = 2082;
      v142 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v88, v109, "%{public}s called with null type, dumping backtrace:%{public}s", location, 0x16u);
    }
    goto LABEL_146;
  }
  if (!v8)
  {
    v92 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (!__nwlog_fault(v87, &type, &v138)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      os_log_type_t v93 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v93, "%{public}s called with null queue", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (!v138)
    {
      v88 = __nwlog_obj();
      os_log_type_t v127 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v127, "%{public}s called with null queue, backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_213;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    os_log_type_t v111 = type;
    BOOL v112 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (v112)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v111, "%{public}s called with null queue, no backtrace", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (v112)
    {
      *(_DWORD *)location = 136446466;
      *(void *)&location[4] = "nw_agent_create";
      __int16 v141 = 2082;
      v142 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v88, v111, "%{public}s called with null queue, dumping backtrace:%{public}s", location, 0x16u);
    }
    goto LABEL_146;
  }
  if (strlen(a1) >= 0x20)
  {
    v94 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (!__nwlog_fault(v87, &type, &v138)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      os_log_type_t v95 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v95, "%{public}s called with null (strlen(domain) < 32)", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (!v138)
    {
      v88 = __nwlog_obj();
      os_log_type_t v128 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v128, "%{public}s called with null (strlen(domain) < 32), backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_213;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    os_log_type_t v113 = type;
    BOOL v114 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (v114)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v113, "%{public}s called with null (strlen(domain) < 32), no backtrace", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (v114)
    {
      *(_DWORD *)location = 136446466;
      *(void *)&location[4] = "nw_agent_create";
      __int16 v141 = 2082;
      v142 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v88, v113, "%{public}s called with null (strlen(domain) < 32), dumping backtrace:%{public}s", location, 0x16u);
    }
    goto LABEL_146;
  }
  if (strlen(a2) >= 0x20)
  {
    v96 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (!__nwlog_fault(v87, &type, &v138)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      os_log_type_t v97 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v97, "%{public}s called with null (strlen(type) < 32)", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (!v138)
    {
      v88 = __nwlog_obj();
      os_log_type_t v129 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v129, "%{public}s called with null (strlen(type) < 32), backtrace limit exceeded", location, 0xCu);
      }
      goto LABEL_213;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    v88 = __nwlog_obj();
    os_log_type_t v115 = type;
    BOOL v116 = os_log_type_enabled(v88, type);
    if (!backtrace_string)
    {
      if (v116)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v115, "%{public}s called with null (strlen(type) < 32), no backtrace", location, 0xCu);
      }
      goto LABEL_213;
    }
    if (v116)
    {
      *(_DWORD *)location = 136446466;
      *(void *)&location[4] = "nw_agent_create";
      __int16 v141 = 2082;
      v142 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v88, v115, "%{public}s called with null (strlen(type) < 32), dumping backtrace:%{public}s", location, 0x16u);
    }
LABEL_146:

    free(backtrace_string);
    if (!v87) {
      goto LABEL_216;
    }
    goto LABEL_215;
  }
  if (a3 && strlen(a3) >= 0x80)
  {
    v104 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (!__nwlog_fault(v87, &type, &v138)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v88 = __nwlog_obj();
      os_log_type_t v105 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v105, "%{public}s called with null (strlen(description) < 128)", location, 0xCu);
      }
    }
    else if (v138)
    {
      v122 = (char *)__nw_create_backtrace_string();
      v88 = __nwlog_obj();
      os_log_type_t v123 = type;
      BOOL v124 = os_log_type_enabled(v88, type);
      if (v122)
      {
        if (v124)
        {
          *(_DWORD *)location = 136446466;
          *(void *)&location[4] = "nw_agent_create";
          __int16 v141 = 2082;
          v142 = v122;
          _os_log_impl(&dword_1830D4000, v88, v123, "%{public}s called with null (strlen(description) < 128), dumping backtrace:%{public}s", location, 0x16u);
        }

        free(v122);
LABEL_214:
        if (!v87)
        {
LABEL_216:
          v84 = 0;
          goto LABEL_81;
        }
LABEL_215:
        free(v87);
        goto LABEL_216;
      }
      if (v124)
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v123, "%{public}s called with null (strlen(description) < 128), no backtrace", location, 0xCu);
      }
    }
    else
    {
      v88 = __nwlog_obj();
      os_log_type_t v132 = type;
      if (os_log_type_enabled(v88, type))
      {
        *(_DWORD *)location = 136446210;
        *(void *)&location[4] = "nw_agent_create";
        _os_log_impl(&dword_1830D4000, v88, v132, "%{public}s called with null (strlen(description) < 128), backtrace limit exceeded", location, 0xCu);
      }
    }
LABEL_213:

    goto LABEL_214;
  }
  unint64_t v10 = objc_alloc_init(NWConcrete_nw_agent);
  if (v10)
  {
    unsigned int v11 = nw_network_agent_open_control_socket();
    if ((v11 & 0x80000000) == 0)
    {
      unsigned int v12 = v11;
      int v13 = *(unsigned __int8 *)a1;
      *((unsigned char *)v10 + 20) = v13;
      if (v13)
      {
        int v14 = *((unsigned __int8 *)a1 + 1);
        *((unsigned char *)v10 + 21) = v14;
        if (v14)
        {
          int v15 = *((unsigned __int8 *)a1 + 2);
          *((unsigned char *)v10 + 22) = v15;
          if (v15)
          {
            int v16 = *((unsigned __int8 *)a1 + 3);
            *((unsigned char *)v10 + 23) = v16;
            if (v16)
            {
              int v17 = *((unsigned __int8 *)a1 + 4);
              *((unsigned char *)v10 + 24) = v17;
              if (v17)
              {
                int v18 = *((unsigned __int8 *)a1 + 5);
                *((unsigned char *)v10 + 25) = v18;
                if (v18)
                {
                  int v19 = *((unsigned __int8 *)a1 + 6);
                  *((unsigned char *)v10 + 26) = v19;
                  if (v19)
                  {
                    int v20 = *((unsigned __int8 *)a1 + 7);
                    *((unsigned char *)v10 + 27) = v20;
                    if (v20)
                    {
                      int v21 = *((unsigned __int8 *)a1 + 8);
                      *((unsigned char *)v10 + 28) = v21;
                      if (v21)
                      {
                        int v22 = *((unsigned __int8 *)a1 + 9);
                        *((unsigned char *)v10 + 29) = v22;
                        if (v22)
                        {
                          int v23 = *((unsigned __int8 *)a1 + 10);
                          *((unsigned char *)v10 + 30) = v23;
                          if (v23)
                          {
                            int v24 = *((unsigned __int8 *)a1 + 11);
                            *((unsigned char *)v10 + 31) = v24;
                            if (v24)
                            {
                              int v25 = *((unsigned __int8 *)a1 + 12);
                              *((unsigned char *)v10 + 32) = v25;
                              if (v25)
                              {
                                int v26 = *((unsigned __int8 *)a1 + 13);
                                *((unsigned char *)v10 + 33) = v26;
                                if (v26)
                                {
                                  int v27 = *((unsigned __int8 *)a1 + 14);
                                  *((unsigned char *)v10 + 34) = v27;
                                  if (v27)
                                  {
                                    int v28 = *((unsigned __int8 *)a1 + 15);
                                    *((unsigned char *)v10 + 35) = v28;
                                    if (v28)
                                    {
                                      int v29 = *((unsigned __int8 *)a1 + 16);
                                      *((unsigned char *)v10 + 36) = v29;
                                      if (v29)
                                      {
                                        int v30 = *((unsigned __int8 *)a1 + 17);
                                        *((unsigned char *)v10 + 37) = v30;
                                        if (v30)
                                        {
                                          int v31 = *((unsigned __int8 *)a1 + 18);
                                          *((unsigned char *)v10 + 38) = v31;
                                          if (v31)
                                          {
                                            int v32 = *((unsigned __int8 *)a1 + 19);
                                            *((unsigned char *)v10 + 39) = v32;
                                            if (v32)
                                            {
                                              int v33 = *((unsigned __int8 *)a1 + 20);
                                              *((unsigned char *)v10 + 40) = v33;
                                              if (v33)
                                              {
                                                int v34 = *((unsigned __int8 *)a1 + 21);
                                                *((unsigned char *)v10 + 41) = v34;
                                                if (v34)
                                                {
                                                  int v35 = *((unsigned __int8 *)a1 + 22);
                                                  *((unsigned char *)v10 + 42) = v35;
                                                  if (v35)
                                                  {
                                                    int v36 = *((unsigned __int8 *)a1 + 23);
                                                    *((unsigned char *)v10 + 43) = v36;
                                                    if (v36)
                                                    {
                                                      int v37 = *((unsigned __int8 *)a1 + 24);
                                                      *((unsigned char *)v10 + 44) = v37;
                                                      if (v37)
                                                      {
                                                        int v38 = *((unsigned __int8 *)a1 + 25);
                                                        *((unsigned char *)v10 + 45) = v38;
                                                        if (v38)
                                                        {
                                                          int v39 = *((unsigned __int8 *)a1 + 26);
                                                          *((unsigned char *)v10 + 46) = v39;
                                                          if (v39)
                                                          {
                                                            int v40 = *((unsigned __int8 *)a1 + 27);
                                                            *((unsigned char *)v10 + 47) = v40;
                                                            if (v40)
                                                            {
                                                              int v41 = *((unsigned __int8 *)a1 + 28);
                                                              *((unsigned char *)v10 + 48) = v41;
                                                              if (v41)
                                                              {
                                                                int v42 = *((unsigned __int8 *)a1 + 29);
                                                                *((unsigned char *)v10 + 49) = v42;
                                                                if (v42)
                                                                {
                                                                  int v43 = *((unsigned __int8 *)a1 + 30);
                                                                  *((unsigned char *)v10 + 50) = v43;
                                                                  if (v43) {
                                                                    *((unsigned char *)v10 + 51) = 0;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      int v44 = *(unsigned __int8 *)a2;
      *((unsigned char *)v10 + 52) = v44;
      if (v44)
      {
        int v45 = *((unsigned __int8 *)a2 + 1);
        *((unsigned char *)v10 + 53) = v45;
        if (v45)
        {
          int v46 = *((unsigned __int8 *)a2 + 2);
          *((unsigned char *)v10 + 54) = v46;
          if (v46)
          {
            int v47 = *((unsigned __int8 *)a2 + 3);
            *((unsigned char *)v10 + 55) = v47;
            if (v47)
            {
              int v48 = *((unsigned __int8 *)a2 + 4);
              *((unsigned char *)v10 + 56) = v48;
              if (v48)
              {
                int v49 = *((unsigned __int8 *)a2 + 5);
                *((unsigned char *)v10 + 57) = v49;
                if (v49)
                {
                  int v50 = *((unsigned __int8 *)a2 + 6);
                  *((unsigned char *)v10 + 58) = v50;
                  if (v50)
                  {
                    int v51 = *((unsigned __int8 *)a2 + 7);
                    *((unsigned char *)v10 + 59) = v51;
                    if (v51)
                    {
                      int v52 = *((unsigned __int8 *)a2 + 8);
                      *((unsigned char *)v10 + 60) = v52;
                      if (v52)
                      {
                        int v53 = *((unsigned __int8 *)a2 + 9);
                        *((unsigned char *)v10 + 61) = v53;
                        if (v53)
                        {
                          int v54 = *((unsigned __int8 *)a2 + 10);
                          *((unsigned char *)v10 + 62) = v54;
                          if (v54)
                          {
                            int v55 = *((unsigned __int8 *)a2 + 11);
                            *((unsigned char *)v10 + 63) = v55;
                            if (v55)
                            {
                              int v56 = *((unsigned __int8 *)a2 + 12);
                              *((unsigned char *)v10 + 64) = v56;
                              if (v56)
                              {
                                int v57 = *((unsigned __int8 *)a2 + 13);
                                *((unsigned char *)v10 + 65) = v57;
                                if (v57)
                                {
                                  int v58 = *((unsigned __int8 *)a2 + 14);
                                  *((unsigned char *)v10 + 66) = v58;
                                  if (v58)
                                  {
                                    int v59 = *((unsigned __int8 *)a2 + 15);
                                    *((unsigned char *)v10 + 67) = v59;
                                    if (v59)
                                    {
                                      int v60 = *((unsigned __int8 *)a2 + 16);
                                      *((unsigned char *)v10 + 68) = v60;
                                      if (v60)
                                      {
                                        int v61 = *((unsigned __int8 *)a2 + 17);
                                        *((unsigned char *)v10 + 69) = v61;
                                        if (v61)
                                        {
                                          int v62 = *((unsigned __int8 *)a2 + 18);
                                          *((unsigned char *)v10 + 70) = v62;
                                          if (v62)
                                          {
                                            int v63 = *((unsigned __int8 *)a2 + 19);
                                            *((unsigned char *)v10 + 71) = v63;
                                            if (v63)
                                            {
                                              int v64 = *((unsigned __int8 *)a2 + 20);
                                              *((unsigned char *)v10 + 72) = v64;
                                              if (v64)
                                              {
                                                int v65 = *((unsigned __int8 *)a2 + 21);
                                                *((unsigned char *)v10 + 73) = v65;
                                                if (v65)
                                                {
                                                  int v66 = *((unsigned __int8 *)a2 + 22);
                                                  *((unsigned char *)v10 + 74) = v66;
                                                  if (v66)
                                                  {
                                                    int v67 = *((unsigned __int8 *)a2 + 23);
                                                    *((unsigned char *)v10 + 75) = v67;
                                                    if (v67)
                                                    {
                                                      int v68 = *((unsigned __int8 *)a2 + 24);
                                                      *((unsigned char *)v10 + 76) = v68;
                                                      if (v68)
                                                      {
                                                        int v69 = *((unsigned __int8 *)a2 + 25);
                                                        *((unsigned char *)v10 + 77) = v69;
                                                        if (v69)
                                                        {
                                                          int v70 = *((unsigned __int8 *)a2 + 26);
                                                          *((unsigned char *)v10 + 78) = v70;
                                                          if (v70)
                                                          {
                                                            int v71 = *((unsigned __int8 *)a2 + 27);
                                                            *((unsigned char *)v10 + 79) = v71;
                                                            if (v71)
                                                            {
                                                              int v72 = *((unsigned __int8 *)a2 + 28);
                                                              *((unsigned char *)v10 + 80) = v72;
                                                              if (v72)
                                                              {
                                                                int v73 = *((unsigned __int8 *)a2 + 29);
                                                                *((unsigned char *)v10 + 81) = v73;
                                                                if (v73)
                                                                {
                                                                  int v74 = *((unsigned __int8 *)a2 + 30);
                                                                  *((unsigned char *)v10 + 82) = v74;
                                                                  if (v74) {
                                                                    *((unsigned char *)v10 + 83) = 0;
                                                                  }
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
      if (a3)
      {
        __int16 v75 = (char *)v10 + 84;
        uint64_t v76 = 128;
        while (1)
        {
          int v77 = *(unsigned __int8 *)a3;
          *__int16 v75 = v77;
          if (!v77) {
            break;
          }
          ++v75;
          ++a3;
          if ((unint64_t)--v76 <= 1)
          {
            *__int16 v75 = 0;
            break;
          }
        }
      }
      objc_storeStrong((id *)v10 + 27, a4);
      v78 = nw_fd_wrapper_create(v12);
      nw_fd_wrapper_guard(v78);
      objc_storeStrong((id *)v10 + 105, v78);
      v79 = dispatch_source_create(MEMORY[0x1E4F14478], v12, 0, v9);
      objc_initWeak((id *)location, v10);
      handler[0] = MEMORY[0x1E4F143A8];
      handler[1] = 3221225472;
      handler[2] = __nw_agent_create_block_invoke;
      handler[3] = &unk_1E524BAA8;
      id v137 = v78;
      v80 = v78;
      dispatch_source_set_cancel_handler(v79, handler);
      v133[0] = MEMORY[0x1E4F143A8];
      v133[1] = 3221225472;
      v133[2] = __nw_agent_create_block_invoke_2;
      v133[3] = &unk_1E5249F88;
      objc_copyWeak(&v135, (id *)location);
      v81 = v79;
      v134 = v81;
      dispatch_source_set_event_handler(v81, v133);
      v82 = (void *)*((void *)v10 + 106);
      *((void *)v10 + 106) = v81;
      v83 = v81;

      dispatch_resume(v83);
      v84 = v10;

      objc_destroyWeak(&v135);
      objc_destroyWeak((id *)location);
      goto LABEL_80;
    }
    v102 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v99 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (__nwlog_fault(v99, &type, &v138))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v100 = __nwlog_obj();
        os_log_type_t v103 = type;
        if (os_log_type_enabled(v100, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_1830D4000, v100, v103, "%{public}s called with null (fd >= 0)", location, 0xCu);
        }
LABEL_207:

        goto LABEL_208;
      }
      if (!v138)
      {
        v100 = __nwlog_obj();
        os_log_type_t v131 = type;
        if (os_log_type_enabled(v100, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_1830D4000, v100, v131, "%{public}s called with null (fd >= 0), backtrace limit exceeded", location, 0xCu);
        }
        goto LABEL_207;
      }
      v117 = (char *)__nw_create_backtrace_string();
      v100 = __nwlog_obj();
      os_log_type_t v120 = type;
      BOOL v121 = os_log_type_enabled(v100, type);
      if (!v117)
      {
        if (v121)
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_1830D4000, v100, v120, "%{public}s called with null (fd >= 0), no backtrace", location, 0xCu);
        }
        goto LABEL_207;
      }
      if (v121)
      {
        *(_DWORD *)location = 136446466;
        *(void *)&location[4] = "nw_agent_create";
        __int16 v141 = 2082;
        v142 = v117;
        _os_log_impl(&dword_1830D4000, v100, v120, "%{public}s called with null (fd >= 0), dumping backtrace:%{public}s", location, 0x16u);
      }
      goto LABEL_157;
    }
  }
  else
  {
    v98 = __nwlog_obj();
    *(_DWORD *)location = 136446210;
    *(void *)&location[4] = "nw_agent_create";
    v99 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v138 = 0;
    if (__nwlog_fault(v99, &type, &v138))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v100 = __nwlog_obj();
        os_log_type_t v101 = type;
        if (os_log_type_enabled(v100, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_1830D4000, v100, v101, "%{public}s called with null agent", location, 0xCu);
        }
        goto LABEL_207;
      }
      if (!v138)
      {
        v100 = __nwlog_obj();
        os_log_type_t v130 = type;
        if (os_log_type_enabled(v100, type))
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_1830D4000, v100, v130, "%{public}s called with null agent, backtrace limit exceeded", location, 0xCu);
        }
        goto LABEL_207;
      }
      v117 = (char *)__nw_create_backtrace_string();
      v100 = __nwlog_obj();
      os_log_type_t v118 = type;
      BOOL v119 = os_log_type_enabled(v100, type);
      if (!v117)
      {
        if (v119)
        {
          *(_DWORD *)location = 136446210;
          *(void *)&location[4] = "nw_agent_create";
          _os_log_impl(&dword_1830D4000, v100, v118, "%{public}s called with null agent, no backtrace", location, 0xCu);
        }
        goto LABEL_207;
      }
      if (v119)
      {
        *(_DWORD *)location = 136446466;
        *(void *)&location[4] = "nw_agent_create";
        __int16 v141 = 2082;
        v142 = v117;
        _os_log_impl(&dword_1830D4000, v100, v118, "%{public}s called with null agent, dumping backtrace:%{public}s", location, 0x16u);
      }
LABEL_157:

      free(v117);
    }
  }
LABEL_208:
  if (v99) {
    free(v99);
  }
  v84 = 0;
LABEL_80:

LABEL_81:
  return v84;
}

void sub_183C6E724(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_agent_create_block_invoke(uint64_t a1)
{
}

void *__Block_byref_object_copy__80774(uint64_t a1, uint64_t a2)
{
  BOOL result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

void __Block_byref_object_dispose__80775(uint64_t a1)
{
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_160(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 824));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

uint64_t __Block_byref_object_copy__161(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__162(uint64_t a1)
{
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_164(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 752));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2(uint64_t a1, int a2, int a3, void *a4)
{
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_166(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 752));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_167(uint64_t a1, int a2, int a3, void *a4)
{
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_168(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 832));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_169(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 792));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_170(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (!v3)
  {
    int v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke_2";
    BOOL v7 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null discovered_endpoints", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
            __int16 v17 = 2082;
            int v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null discovered_endpoints, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null discovered_endpoints, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null discovered_endpoints, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (!v7) {
      goto LABEL_5;
    }
    __int16 v5 = (char *)v7;
    goto LABEL_4;
  }
  *(void *)buf = 0;
  endpoint_array_BOOL result = nw_path_create_endpoint_array_result(buf, v3, 202);
  nw_agent_assign(*(NWConcrete_nw_agent **)(a1 + 32), (unsigned __int8 *)endpoint_array_result, *(size_t *)buf, (unsigned __int8 *)(*(void *)(a1 + 40) + 8), 0);
  if (endpoint_array_result)
  {
    __int16 v5 = (char *)endpoint_array_result;
LABEL_4:
    free(v5);
  }
LABEL_5:
}

void sub_183C6EC04(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_173(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 800));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_174(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 24 * *(unsigned __int8 *)(a1 + 48) + 360));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_175(uint64_t a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (!v3)
  {
    int v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke_2";
    BOOL v7 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v7, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null resolved_endpoints", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
            __int16 v17 = 2082;
            int v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null resolved_endpoints, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null resolved_endpoints, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_read_message_on_queue_block_invoke";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null resolved_endpoints, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (!v7) {
      goto LABEL_5;
    }
    __int16 v5 = (char *)v7;
    goto LABEL_4;
  }
  *(void *)buf = 0;
  endpoint_array_BOOL result = nw_path_create_endpoint_array_result(buf, v3, 203);
  nw_agent_assign(*(NWConcrete_nw_agent **)(a1 + 32), (unsigned __int8 *)endpoint_array_result, *(size_t *)buf, (unsigned __int8 *)(*(void *)(a1 + 40) + 8), 0);
  if (endpoint_array_result)
  {
    __int16 v5 = (char *)endpoint_array_result;
LABEL_4:
    free(v5);
  }
LABEL_5:
}

void sub_183C6EF94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_176(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 24 * *(unsigned __int8 *)(a1 + 48) + 368));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_177(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 760));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_178(uint64_t a1, int a2, int a3, void *a4)
{
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_179(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 768));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_181(uint64_t a1, void *a2, void *a3, void *a4)
{
  id v7 = a2;
  id v8 = a3;
  id v9 = a4;
  unint64_t v10 = *(void **)(a1 + 32);
  v16[0] = MEMORY[0x1E4F143A8];
  v16[1] = 3221225472;
  __int16 v17 = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_3;
  int v18 = &unk_1E524A158;
  id v19 = v7;
  id v20 = v10;
  id v21 = v8;
  id v22 = *(id *)(a1 + 40);
  id v23 = v9;
  os_log_type_t v11 = (os_unfair_lock_s *)v20;
  BOOL v12 = v16;
  id v13 = v9;
  id v14 = v8;
  id v15 = v7;
  os_unfair_lock_lock(v11 + 2);
  v17((uint64_t)v12);
  os_unfair_lock_unlock(v11 + 2);
}

void sub_183C6F1EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, void *a17, void *a18)
{
  _Unwind_Resume(a1);
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_184(uint64_t a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 80);
  if (v1)
  {
    id v3 = v1;
    uint64_t v4 = *(void *)(a1 + 32);
    __int16 v5 = *(void **)(v4 + 80);
    *(void *)(v4 + 80) = 0;

    uint64_t v6 = *(void *)(a1 + 40);
    if (*(char *)(v6 + 856) < 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)__str = 136446210;
        *(void *)&__str[4] = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Closing channel on nexus", (uint8_t *)__str, 0xCu);
      }

      nw_channel_close((uint64_t)v3);
    }
    else
    {
      uint64_t v15 = 0;
      int v16 = &v15;
      uint64_t v17 = 0x2020000000;
      char v18 = 1;
      uint64_t v7 = *(void *)(v6 + 736);
      v12[0] = MEMORY[0x1E4F143A8];
      v12[1] = 3221225472;
      v12[2] = ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_185;
      v12[3] = &unk_1E524A1A8;
      id v8 = v3;
      id v13 = v8;
      id v14 = &v15;
      nw_dictionary_apply(v7, (uint64_t)v12);
      if (*((unsigned char *)v16 + 24))
      {
        long long uu = 0uLL;
        nw_parameters_get_proc_uuid(*(void **)(*(void *)(a1 + 32) + 40), &uu);
        memset(out, 0, 37);
        uuid_unparse((const unsigned __int8 *)&uu, out);
        int pid = nw_parameters_get_pid(*(void **)(*(void *)(a1 + 32) + 40));
        long long v24 = 0u;
        memset(v25, 0, sizeof(v25));
        *(_OWORD *)__str = 0u;
        snprintf(__str, 0x35uLL, "%d-%s", pid, out);
        nw_dictionary_set_value(*(void *)(*(void *)(a1 + 40) + 744), __str, 0);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unint64_t v10 = (id)gLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          id v20 = "nw_agent_read_message_on_queue_block_invoke";
          __int16 v21 = 2080;
          id v22 = __str;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s Removing channel on nexus for %s", buf, 0x16u);
        }

        nw_channel_close((uint64_t)v8);
      }

      _Block_object_dispose(&v15, 8);
    }
  }
}

void sub_183C6F500(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, void *a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_187(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 784));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_188(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 808));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_189(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    nw_agent_send_group_member_update(*(void **)(a1 + 32), *(void **)(a1 + 40), v3);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke_2";
  __int16 v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null assign_members", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null assign_members, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null assign_members, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null assign_members, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183C6F86C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_190(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(*(void *)(a1 + 32) + 816));
  uint64_t v3 = *(void *)(*(void *)(a1 + 40) + 8);
  uint64_t v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_191(uint64_t a1, void *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if (v3)
  {
    nw_agent_send_group_member_update(*(void **)(a1 + 32), *(void **)(a1 + 40), v3);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke_2";
  __int16 v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null assign_members", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null assign_members, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null assign_members, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null assign_members, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183C6FB74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_2_185(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (*(void *)(a3 + 80) == *(void *)(a1 + 32)) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
  return *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
}

void ___ZL30nw_agent_read_message_on_queueP19NWConcrete_nw_agent_block_invoke_3(uint64_t a1)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 32) || (*(unsigned char *)(*(void *)(a1 + 40) + 856) & 2) == 0 && !*(void *)(a1 + 48))
  {
    uint64_t v4 = *(void *)(*(void *)(a1 + 56) + 80);
    out[0] = 0;
    memset(__str, 0, sizeof(__str));
    if (v4) {
      unsigned int v5 = 54;
    }
    else {
      unsigned int v5 = 61;
    }
    BOOL assign_message_internal = nw_path_create_assign_message_internal(out, __str, v5, 0, 0, 0, 0, 0);
    if (assign_message_internal)
    {
      nw_agent_assign(*(NWConcrete_nw_agent **)(a1 + 40), (unsigned __int8 *)assign_message_internal, out[0], (unsigned __int8 *)(*(void *)(a1 + 56) + 8), 0);
      os_log_type_t v7 = (char *)assign_message_internal;
LABEL_13:
      free(v7);
      return;
    }
    int v42 = __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke_3";
    int v43 = (const char *)_os_log_send_and_compose_impl();

    LOBYTE(uu) = 16;
    LOBYTE(v93) = 0;
    if (!__nwlog_fault(v43, &uu, &v93)) {
      goto LABEL_109;
    }
    if (uu == 17)
    {
      int v44 = __nwlog_obj();
      os_log_type_t v45 = uu;
      if (os_log_type_enabled(v44, (os_log_type_t)uu))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null assign_message", (uint8_t *)buf, 0xCu);
      }
    }
    else if ((_BYTE)v93)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v44 = __nwlog_obj();
      os_log_type_t v47 = uu;
      BOOL v48 = os_log_type_enabled(v44, (os_log_type_t)uu);
      if (backtrace_string)
      {
        if (v48)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null assign_message, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }

        free(backtrace_string);
LABEL_109:
        if (!v43) {
          return;
        }
        goto LABEL_110;
      }
      if (v48)
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null assign_message, no backtrace", (uint8_t *)buf, 0xCu);
      }
    }
    else
    {
      int v44 = __nwlog_obj();
      os_log_type_t v72 = uu;
      if (os_log_type_enabled(v44, (os_log_type_t)uu))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
        _os_log_impl(&dword_1830D4000, v44, v72, "%{public}s called with null assign_message, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
      }
    }

    goto LABEL_109;
  }
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(void *)(v2 + 80))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s Client already assigned channel", (uint8_t *)buf, 0xCu);
    }

    return;
  }
  long long uu = 0uLL;
  nw_parameters_get_proc_uuid(*(void **)(v2 + 40), &uu);
  memset(out, 0, 37);
  uuid_unparse((const unsigned __int8 *)&uu, (char *)out);
  int pid = nw_parameters_get_pid(*(void **)(*(void *)(a1 + 56) + 40));
  long long v95 = 0u;
  memset(v96, 0, sizeof(v96));
  *(_OWORD *)__str = 0u;
  snprintf(__str, 0x35uLL, "%d-%s", pid, (const char *)out);
  uint64_t v9 = *(void *)(a1 + 40);
  if (!*(void *)(v9 + 744))
  {
    BOOL v10 = nw_dictionary_create();
    uint64_t v11 = *(void *)(a1 + 40);
    char v12 = *(void **)(v11 + 744);
    *(void *)(v11 + 744) = v10;

    uint64_t v9 = *(void *)(a1 + 40);
    if (*(char *)(v9 + 856) < 0) {
      goto LABEL_19;
    }
    goto LABEL_18;
  }
  if ((*(char *)(v9 + 856) & 0x80000000) == 0)
  {
LABEL_18:
    id v13 = nw_dictionary_copy_value(*(void *)(v9 + 744), (uint64_t)__str);
    uint64_t v14 = *(void *)(a1 + 56);
    uint64_t v15 = *(void **)(v14 + 80);
    *(void *)(v14 + 80) = v13;
  }
LABEL_19:
  uint64_t v16 = *(void *)(a1 + 56);
  uint64_t v17 = *(void *)(v16 + 80);
  if (v17) {
    goto LABEL_32;
  }
  uint64_t v18 = *(void *)(a1 + 40);
  uint64_t v20 = *(void *)(v18 + 240);
  uint64_t v19 = *(void *)(v18 + 248);
  if (v20)
  {
    __int16 v21 = *(_DWORD **)(v18 + 240);
  }
  else
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    __int16 v21 = (id)nw_context_copy_implicit_context::implicit_context;
  }
  BOOL channel_to_new_instance_and_context = nw_nexus_create_channel_to_new_instance_and_context(v19, v21);
  uint64_t v23 = *(void *)(a1 + 56);
  long long v24 = *(void **)(v23 + 80);
  *(void *)(v23 + 80) = channel_to_new_instance_and_context;

  if (!v20) {
  uint64_t v25 = *(void *)(*(void *)(a1 + 56) + 80);
  }
  if (v25)
  {
    int v26 = *(void **)(*(void *)(a1 + 40) + 248);
    if (v26) {
      int v26 = os_retain(v26);
    }
    *(void *)(v25 + 160) = v26;
    nw_channel_set_close_automatically(*(void *)(*(void *)(a1 + 56) + 80), 1);
    nw_channel_set_no_close_delay(*(void *)(*(void *)(a1 + 56) + 80));
    uint64_t v27 = *(void *)(a1 + 40);
    uint64_t v16 = *(void *)(a1 + 56);
    if ((*(char *)(v27 + 856) & 0x80000000) == 0)
    {
      nw_dictionary_set_value(*(void *)(v27 + 744), __str, *(void **)(v16 + 80));
      uint64_t v16 = *(void *)(a1 + 56);
    }
LABEL_32:
    long long v93 = 0uLL;
    int v91 = 0;
    nw_channel_get_nexus_instance(*(void *)(v16 + 80), &v93, &v91);
    unsigned int v90 = 0;
    uint64_t key = nw_channel_get_key(*(void *)(*(void *)(a1 + 56) + 80), &v90);
    v84 = (const void *)key;
    if (v17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v29 = (id)gLogObj;
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_38;
      }
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      WORD2(buf[1]) = 1040;
      *(_DWORD *)((char *)&buf[1] + 6) = 16;
      WORD1(buf[2]) = 2096;
      *(void *)((char *)&buf[2] + 4) = &v93;
      WORD2(buf[3]) = 2080;
      *(void *)((char *)&buf[3] + 6) = __str;
      int v30 = "%{public}s Reusing channel on nexus %{uuid_t}.16P for %s";
    }
    else
    {
      nw_nexus_bind_client_port(*(void *)(*(void *)(a1 + 40) + 248), (uint64_t)&v93, 0, 0, key, v90);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v29 = (id)gLogObj;
      if (!os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_38;
      }
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      WORD2(buf[1]) = 1040;
      *(_DWORD *)((char *)&buf[1] + 6) = 16;
      WORD1(buf[2]) = 2096;
      *(void *)((char *)&buf[2] + 4) = &v93;
      WORD2(buf[3]) = 2080;
      *(void *)((char *)&buf[3] + 6) = __str;
      int v30 = "%{public}s Creating channel on nexus %{uuid_t}.16P for %s";
    }
    _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, v30, (uint8_t *)buf, 0x26u);
LABEL_38:

    id v87 = nw_framer_options_copy_peer_protocol_definition(*(void **)(a1 + 64));
    int v31 = *(void **)(a1 + 32);
    int v33 = *(void **)(a1 + 48);
    int v32 = *(void **)(a1 + 56);
    int v34 = *(void **)(a1 + 64);
    id v35 = *(id *)(a1 + 40);
    int v36 = v32;
    id v85 = v31;
    id v86 = v33;
    id v37 = v34;
    int v38 = v37;
    if (v35)
    {
      if (!v36)
      {
        int v57 = __nwlog_obj();
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
        int v50 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v92 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v50, type, &v92)) {
          goto LABEL_143;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v51 = __nwlog_obj();
          os_log_type_t v58 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_1830D4000, v51, v58, "%{public}s called with null client", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_142;
        }
        if (v92 == OS_LOG_TYPE_DEFAULT)
        {
          int v51 = __nwlog_obj();
          os_log_type_t v81 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_1830D4000, v51, v81, "%{public}s called with null client, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_142;
        }
        int v67 = (char *)__nw_create_backtrace_string();
        int v51 = __nwlog_obj();
        os_log_type_t v68 = type[0];
        BOOL v69 = os_log_type_enabled(v51, type[0]);
        if (!v67)
        {
          if (v69)
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_1830D4000, v51, v68, "%{public}s called with null client, no backtrace", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_142;
        }
        if (v69)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v67;
          _os_log_impl(&dword_1830D4000, v51, v68, "%{public}s called with null client, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        goto LABEL_96;
      }
      if (v37)
      {
        id v39 = nw_parameters_copy_context(v36[5]);
        buf[0] = MEMORY[0x1E4F143A8];
        buf[1] = 3221225472;
        buf[2] = ___ZL31nw_agent_client_attach_protocolP19NWConcrete_nw_agentP26NWConcrete_nw_agent_clientPU25objcproto14OS_nw_endpoint8NSObjectS5_PU33objcproto22OS_nw_protocol_optionsS3__block_invoke;
        buf[3] = &unk_1E524A158;
        uint8_t buf[4] = v35;
        v100 = v36;
        id v101 = v38;
        id v102 = v85;
        id v103 = v86;
        nw_queue_context_async(v39, buf);

        goto LABEL_42;
      }
      int v59 = __nwlog_obj();
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
      int v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v92 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v50, type, &v92))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v51 = __nwlog_obj();
          os_log_type_t v60 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_1830D4000, v51, v60, "%{public}s called with null options", (uint8_t *)buf, 0xCu);
          }
LABEL_142:

          goto LABEL_143;
        }
        if (v92 == OS_LOG_TYPE_DEFAULT)
        {
          int v51 = __nwlog_obj();
          os_log_type_t v82 = type[0];
          if (os_log_type_enabled(v51, type[0]))
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_1830D4000, v51, v82, "%{public}s called with null options, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_142;
        }
        int v67 = (char *)__nw_create_backtrace_string();
        int v51 = __nwlog_obj();
        os_log_type_t v70 = type[0];
        BOOL v71 = os_log_type_enabled(v51, type[0]);
        if (!v67)
        {
          if (v71)
          {
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
            _os_log_impl(&dword_1830D4000, v51, v70, "%{public}s called with null options, no backtrace", (uint8_t *)buf, 0xCu);
          }
          goto LABEL_142;
        }
        if (v71)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v67;
          _os_log_impl(&dword_1830D4000, v51, v70, "%{public}s called with null options, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
LABEL_96:

        free(v67);
        if (!v50)
        {
LABEL_42:

          *(void *)os_log_type_t type = 0;
          BOOL v40 = nw_path_create_assign_message_internal((size_t *)type, &v93, 0, v84, v90, *(void **)(a1 + 32), *(void **)(a1 + 48), v87);
          if (v40)
          {
            nw_agent_assign(*(NWConcrete_nw_agent **)(a1 + 40), (unsigned __int8 *)v40, *(size_t *)type, (unsigned __int8 *)(*(void *)(a1 + 56) + 8), 0);
            int v41 = (char *)v40;
            goto LABEL_44;
          }
          int v53 = __nwlog_obj();
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
          int v54 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t v92 = OS_LOG_TYPE_ERROR;
          char v88 = 0;
          if (__nwlog_fault(v54, &v92, &v88))
          {
            if (v92 == OS_LOG_TYPE_FAULT)
            {
              int v55 = __nwlog_obj();
              os_log_type_t v56 = v92;
              if (os_log_type_enabled(v55, v92))
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null assign_message", (uint8_t *)buf, 0xCu);
              }
            }
            else if (v88)
            {
              int v64 = (char *)__nw_create_backtrace_string();
              int v55 = __nwlog_obj();
              os_log_type_t v65 = v92;
              BOOL v66 = os_log_type_enabled(v55, v92);
              if (v64)
              {
                if (v66)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v64;
                  _os_log_impl(&dword_1830D4000, v55, v65, "%{public}s called with null assign_message, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
                }

                free(v64);
                goto LABEL_135;
              }
              if (v66)
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                _os_log_impl(&dword_1830D4000, v55, v65, "%{public}s called with null assign_message, no backtrace", (uint8_t *)buf, 0xCu);
              }
            }
            else
            {
              int v55 = __nwlog_obj();
              os_log_type_t v80 = v92;
              if (os_log_type_enabled(v55, v92))
              {
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
                _os_log_impl(&dword_1830D4000, v55, v80, "%{public}s called with null assign_message, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
              }
            }
          }
LABEL_135:
          if (!v54) {
            goto LABEL_45;
          }
          int v41 = (char *)v54;
LABEL_44:
          free(v41);
LABEL_45:

          return;
        }
LABEL_144:
        free(v50);
        goto LABEL_42;
      }
    }
    else
    {
      int v49 = __nwlog_obj();
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
      int v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v92 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v50, type, &v92)) {
        goto LABEL_143;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v51 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
          _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null agent", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_142;
      }
      if (v92 == OS_LOG_TYPE_DEFAULT)
      {
        int v51 = __nwlog_obj();
        os_log_type_t v79 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
          _os_log_impl(&dword_1830D4000, v51, v79, "%{public}s called with null agent, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_142;
      }
      int v61 = (char *)__nw_create_backtrace_string();
      int v51 = __nwlog_obj();
      os_log_type_t v62 = type[0];
      BOOL v63 = os_log_type_enabled(v51, type[0]);
      if (!v61)
      {
        if (v63)
        {
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
          _os_log_impl(&dword_1830D4000, v51, v62, "%{public}s called with null agent, no backtrace", (uint8_t *)buf, 0xCu);
        }
        goto LABEL_142;
      }
      if (v63)
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_agent_client_attach_protocol";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v61;
        _os_log_impl(&dword_1830D4000, v51, v62, "%{public}s called with null agent, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
      }

      free(v61);
    }
LABEL_143:
    if (!v50) {
      goto LABEL_42;
    }
    goto LABEL_144;
  }
  int v73 = __nwlog_obj();
  LODWORD(buf[0]) = 136446210;
  *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
  int v43 = (const char *)_os_log_send_and_compose_impl();

  LOBYTE(v93) = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v43, &v93, type)) {
    goto LABEL_109;
  }
  if (v93 == 17)
  {
    int v74 = __nwlog_obj();
    os_log_type_t v75 = v93;
    if (os_log_type_enabled(v74, (os_log_type_t)v93))
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s called with null client->channel", (uint8_t *)buf, 0xCu);
    }
LABEL_150:

    goto LABEL_109;
  }
  if (type[0] == OS_LOG_TYPE_DEFAULT)
  {
    int v74 = __nwlog_obj();
    os_log_type_t v83 = v93;
    if (os_log_type_enabled(v74, (os_log_type_t)v93))
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      _os_log_impl(&dword_1830D4000, v74, v83, "%{public}s called with null client->channel, backtrace limit exceeded", (uint8_t *)buf, 0xCu);
    }
    goto LABEL_150;
  }
  uint64_t v76 = (char *)__nw_create_backtrace_string();
  int v74 = __nwlog_obj();
  os_log_type_t v77 = v93;
  BOOL v78 = os_log_type_enabled(v74, (os_log_type_t)v93);
  if (!v76)
  {
    if (v78)
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
      _os_log_impl(&dword_1830D4000, v74, v77, "%{public}s called with null client->channel, no backtrace", (uint8_t *)buf, 0xCu);
    }
    goto LABEL_150;
  }
  if (v78)
  {
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "nw_agent_read_message_on_queue_block_invoke";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v76;
    _os_log_impl(&dword_1830D4000, v74, v77, "%{public}s called with null client->channel, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
  }

  free(v76);
  if (v43)
  {
LABEL_110:
    os_log_type_t v7 = (char *)v43;
    goto LABEL_13;
  }
}

void sub_183C70E3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void ___ZL31nw_agent_client_attach_protocolP19NWConcrete_nw_agentP26NWConcrete_nw_agent_clientPU25objcproto14OS_nw_endpoint8NSObjectS5_PU33objcproto22OS_nw_protocol_optionsS3__block_invoke(uint64_t a1)
{
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  uint64_t v6 = ___ZL31nw_agent_client_attach_protocolP19NWConcrete_nw_agentP26NWConcrete_nw_agent_clientPU25objcproto14OS_nw_endpoint8NSObjectS5_PU33objcproto22OS_nw_protocol_optionsS3__block_invoke_2;
  os_log_type_t v7 = &unk_1E524A1D0;
  uint64_t v2 = *(void **)(a1 + 32);
  id v8 = *(id *)(a1 + 40);
  id v9 = *(id *)(a1 + 48);
  id v10 = *(id *)(a1 + 56);
  id v11 = *(id *)(a1 + 64);
  id v3 = v2;
  uint64_t v4 = v5;
  os_unfair_lock_lock(v3 + 2);
  v6((uint64_t)v4);
  os_unfair_lock_unlock(v3 + 2);
}

void sub_183C70F9C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16)
{
  _Unwind_Resume(a1);
}

void ___ZL31nw_agent_client_attach_protocolP19NWConcrete_nw_agentP26NWConcrete_nw_agent_clientPU25objcproto14OS_nw_endpoint8NSObjectS5_PU33objcproto22OS_nw_protocol_optionsS3__block_invoke_2(uint64_t a1)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(void *)(v2 + 80))
  {
    if (!*(void *)(v2 + 88))
    {
      id v3 = nw_protocol_options_copy(*(void **)(a1 + 40));
      nw_protocol_options_set_log_id(v3, "A", (const char *)(*(void *)(a1 + 32) + 24), 1);
      uint64_t protocol_handler = nw_channel_get_protocol_handler(*(void *)(*(void *)(a1 + 32) + 80));
      nw_protocol_definition_t v5 = nw_protocol_options_copy_definition(&v3->super);
      nw_protocol_definition_t v6 = v5;
      if (v5)
      {
        os_log_type_t v7 = v5;
        char isa = (char)v7[23].isa;

        if (isa)
        {
          uint64_t v9 = nw_protocol_definition_get_framer_create(v7);
          if (v9)
          {
            id v10 = (uint64_t (*)(NSObject *, NSObject *, void, void))v9;
            id v11 = *(NSObject **)(a1 + 48);
            if (v11) {
              nw_parameters_set_local_endpoint(*(nw_parameters_t *)(*(void *)(a1 + 32) + 40), v11);
            }
            char v12 = nw_parameters_copy_default_protocol_stack(*(nw_parameters_t *)(*(void *)(a1 + 32) + 40));
            nw_protocol_stack_prepend_application_protocol(v12, &v3->super);
            id v13 = v7;

            uint64_t v14 = v10(v13 + 1, v13, *(void *)(a1 + 56), *(void *)(*(void *)(a1 + 32) + 40));
            nw_parameters_set_protocol_instance(v3, v15, v14);
            id v16 = nw_agent_client_copy_path(*(void **)(a1 + 32));
            nw_path_get_client_id(v16, (_OWORD *)v14);

            *(void *)(*(void *)(a1 + 32) + 88) = v14;
            if (v14)
            {
              uint64_t v17 = *(void (***)(uint64_t, void))(v14 + 24);
              if (v17)
              {
                uint64_t v18 = *v17;
                if (v18)
                {
                  v18(v14, 0);
                  goto LABEL_12;
                }
              }
              uint64_t v25 = __nwlog_obj();
              int v26 = *(const char **)(v14 + 16);
              if (!v26) {
                int v26 = "invalid";
              }
            }
            else
            {
              uint64_t v25 = __nwlog_obj();
              int v26 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            __int16 v95 = 2082;
            *(void *)v96 = v26;
            int v43 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v91 = 0;
            if (__nwlog_fault(v43, &type, &v91))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                int v44 = __nwlog_obj();
                os_log_type_t v45 = type;
                if (os_log_type_enabled(v44, type))
                {
                  int v46 = "invalid";
                  if (v14 && *(void *)(v14 + 16)) {
                    int v46 = *(const char **)(v14 + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v46;
                  _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s protocol %{public}s has invalid add_input_handler callback", buf, 0x16u);
                }
              }
              else if (v91)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                int v44 = __nwlog_obj();
                os_log_type_t v48 = type;
                BOOL v49 = os_log_type_enabled(v44, type);
                if (backtrace_string)
                {
                  if (v49)
                  {
                    int v50 = "invalid";
                    if (v14 && *(void *)(v14 + 16)) {
                      int v50 = *(const char **)(v14 + 16);
                    }
                    *(_DWORD *)buf = 136446722;
                    v94 = "nw_agent_client_attach_protocol_block_invoke";
                    __int16 v95 = 2082;
                    *(void *)v96 = v50;
                    *(_WORD *)&v96[8] = 2082;
                    *(void *)&v96[10] = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v44, v48, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(backtrace_string);
                  goto LABEL_151;
                }
                if (v49)
                {
                  v84 = "invalid";
                  if (v14 && *(void *)(v14 + 16)) {
                    v84 = *(const char **)(v14 + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v84;
                  _os_log_impl(&dword_1830D4000, v44, v48, "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace", buf, 0x16u);
                }
              }
              else
              {
                int v44 = __nwlog_obj();
                os_log_type_t v67 = type;
                if (os_log_type_enabled(v44, type))
                {
                  os_log_type_t v68 = "invalid";
                  if (v14 && *(void *)(v14 + 16)) {
                    os_log_type_t v68 = *(const char **)(v14 + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v68;
                  _os_log_impl(&dword_1830D4000, v44, v67, "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded", buf, 0x16u);
                }
              }
            }
LABEL_151:
            if (v43) {
              free(v43);
            }
LABEL_12:
            if (protocol_handler)
            {
              uint64_t v19 = *(void (***)(uint64_t, uint64_t))(protocol_handler + 24);
              if (v19)
              {
                uint64_t v20 = *v19;
                if (v20)
                {
                  v20(protocol_handler, v14);
                  goto LABEL_16;
                }
              }
              uint64_t v27 = __nwlog_obj();
              uint64_t v28 = *(const char **)(protocol_handler + 16);
              if (!v28) {
                uint64_t v28 = "invalid";
              }
            }
            else
            {
              uint64_t v27 = __nwlog_obj();
              uint64_t v28 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            __int16 v95 = 2082;
            *(void *)v96 = v28;
            int v51 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v91 = 0;
            if (__nwlog_fault(v51, &type, &v91))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v52 = __nwlog_obj();
                os_log_type_t v53 = type;
                if (os_log_type_enabled(v52, type))
                {
                  int v54 = "invalid";
                  if (protocol_handler && *(void *)(protocol_handler + 16)) {
                    int v54 = *(const char **)(protocol_handler + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v54;
                  _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s protocol %{public}s has invalid add_input_handler callback", buf, 0x16u);
                }
              }
              else if (v91)
              {
                int v55 = (char *)__nw_create_backtrace_string();
                os_log_type_t v52 = __nwlog_obj();
                os_log_type_t v56 = type;
                BOOL v57 = os_log_type_enabled(v52, type);
                if (v55)
                {
                  if (v57)
                  {
                    os_log_type_t v58 = "invalid";
                    if (protocol_handler && *(void *)(protocol_handler + 16)) {
                      os_log_type_t v58 = *(const char **)(protocol_handler + 16);
                    }
                    *(_DWORD *)buf = 136446722;
                    v94 = "nw_agent_client_attach_protocol_block_invoke";
                    __int16 v95 = 2082;
                    *(void *)v96 = v58;
                    *(_WORD *)&v96[8] = 2082;
                    *(void *)&v96[10] = v55;
                    _os_log_impl(&dword_1830D4000, v52, v56, "%{public}s protocol %{public}s has invalid add_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(v55);
                  goto LABEL_159;
                }
                if (v57)
                {
                  id v85 = "invalid";
                  if (protocol_handler && *(void *)(protocol_handler + 16)) {
                    id v85 = *(const char **)(protocol_handler + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v85;
                  _os_log_impl(&dword_1830D4000, v52, v56, "%{public}s protocol %{public}s has invalid add_input_handler callback, no backtrace", buf, 0x16u);
                }
              }
              else
              {
                os_log_type_t v52 = __nwlog_obj();
                os_log_type_t v69 = type;
                if (os_log_type_enabled(v52, type))
                {
                  os_log_type_t v70 = "invalid";
                  if (protocol_handler && *(void *)(protocol_handler + 16)) {
                    os_log_type_t v70 = *(const char **)(protocol_handler + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v70;
                  _os_log_impl(&dword_1830D4000, v52, v69, "%{public}s protocol %{public}s has invalid add_input_handler callback, backtrace limit exceeded", buf, 0x16u);
                }
              }
            }
LABEL_159:
            if (v51) {
              free(v51);
            }
LABEL_16:
            if (v14)
            {
              uint64_t v21 = *(void *)(v14 + 24);
              if (v21)
              {
                id v22 = *(void (**)(uint64_t, void))(v21 + 24);
                if (v22)
                {
                  v22(v14, 0);
LABEL_20:

LABEL_21:
                  return;
                }
              }
              int v29 = __nwlog_obj();
              int v30 = *(const char **)(v14 + 16);
              if (!v30) {
                int v30 = "invalid";
              }
            }
            else
            {
              int v29 = __nwlog_obj();
              int v30 = "invalid";
            }
            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            __int16 v95 = 2082;
            *(void *)v96 = v30;
            int v59 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v91 = 0;
            if (__nwlog_fault(v59, &type, &v91))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v60 = __nwlog_obj();
                os_log_type_t v61 = type;
                if (os_log_type_enabled(v60, type))
                {
                  os_log_type_t v62 = "invalid";
                  if (v14 && *(void *)(v14 + 16)) {
                    os_log_type_t v62 = *(const char **)(v14 + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v62;
                  _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s protocol %{public}s has invalid connect callback", buf, 0x16u);
                }
              }
              else if (v91)
              {
                BOOL v63 = (char *)__nw_create_backtrace_string();
                os_log_type_t v60 = __nwlog_obj();
                os_log_type_t v64 = type;
                BOOL v65 = os_log_type_enabled(v60, type);
                if (v63)
                {
                  if (v65)
                  {
                    BOOL v66 = "invalid";
                    if (v14 && *(void *)(v14 + 16)) {
                      BOOL v66 = *(const char **)(v14 + 16);
                    }
                    *(_DWORD *)buf = 136446722;
                    v94 = "nw_agent_client_attach_protocol_block_invoke";
                    __int16 v95 = 2082;
                    *(void *)v96 = v66;
                    *(_WORD *)&v96[8] = 2082;
                    *(void *)&v96[10] = v63;
                    _os_log_impl(&dword_1830D4000, v60, v64, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
                  }

                  free(v63);
                  goto LABEL_167;
                }
                if (v65)
                {
                  id v86 = "invalid";
                  if (v14 && *(void *)(v14 + 16)) {
                    id v86 = *(const char **)(v14 + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v86;
                  _os_log_impl(&dword_1830D4000, v60, v64, "%{public}s protocol %{public}s has invalid connect callback, no backtrace", buf, 0x16u);
                }
              }
              else
              {
                os_log_type_t v60 = __nwlog_obj();
                os_log_type_t v71 = type;
                if (os_log_type_enabled(v60, type))
                {
                  os_log_type_t v72 = "invalid";
                  if (v14 && *(void *)(v14 + 16)) {
                    os_log_type_t v72 = *(const char **)(v14 + 16);
                  }
                  *(_DWORD *)buf = 136446466;
                  v94 = "nw_agent_client_attach_protocol_block_invoke";
                  __int16 v95 = 2082;
                  *(void *)v96 = v72;
                  _os_log_impl(&dword_1830D4000, v60, v71, "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded", buf, 0x16u);
                }
              }
            }
LABEL_167:
            if (v59) {
              free(v59);
            }
            goto LABEL_20;
          }
          int v41 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v94 = "nw_agent_client_attach_protocol_block_invoke";
          int v36 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v91 = 0;
          if (!__nwlog_fault(v36, &type, &v91)) {
            goto LABEL_195;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            id v37 = __nwlog_obj();
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_1830D4000, v37, v42, "%{public}s called with null create_function", buf, 0xCu);
            }
            goto LABEL_194;
          }
          if (!v91)
          {
            id v37 = __nwlog_obj();
            os_log_type_t v90 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_1830D4000, v37, v90, "%{public}s called with null create_function, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_194;
          }
          os_log_type_t v79 = (char *)__nw_create_backtrace_string();
          id v37 = __nwlog_obj();
          os_log_type_t v82 = type;
          BOOL v83 = os_log_type_enabled(v37, type);
          if (!v79)
          {
            if (v83)
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_1830D4000, v37, v82, "%{public}s called with null create_function, no backtrace", buf, 0xCu);
            }
            goto LABEL_194;
          }
          if (v83)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            __int16 v95 = 2082;
            *(void *)v96 = v79;
            _os_log_impl(&dword_1830D4000, v37, v82, "%{public}s called with null create_function, dumping backtrace:%{public}s", buf, 0x16u);
          }
        }
        else
        {
          id v39 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v94 = "nw_agent_client_attach_protocol_block_invoke";
          int v36 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v91 = 0;
          if (!__nwlog_fault(v36, &type, &v91)) {
            goto LABEL_195;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            id v37 = __nwlog_obj();
            os_log_type_t v40 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_1830D4000, v37, v40, "%{public}s called with null nw_protocol_definition_is_framer(framer_definition)", buf, 0xCu);
            }
            goto LABEL_194;
          }
          if (!v91)
          {
            id v37 = __nwlog_obj();
            os_log_type_t v89 = type;
            if (os_log_type_enabled(v37, type))
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_1830D4000, v37, v89, "%{public}s called with null nw_protocol_definition_is_framer(framer_definition), backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_194;
          }
          os_log_type_t v79 = (char *)__nw_create_backtrace_string();
          id v37 = __nwlog_obj();
          os_log_type_t v80 = type;
          BOOL v81 = os_log_type_enabled(v37, type);
          if (!v79)
          {
            if (v81)
            {
              *(_DWORD *)buf = 136446210;
              v94 = "nw_agent_client_attach_protocol_block_invoke";
              _os_log_impl(&dword_1830D4000, v37, v80, "%{public}s called with null nw_protocol_definition_is_framer(framer_definition), no backtrace", buf, 0xCu);
            }
            goto LABEL_194;
          }
          if (v81)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            __int16 v95 = 2082;
            *(void *)v96 = v79;
            _os_log_impl(&dword_1830D4000, v37, v80, "%{public}s called with null nw_protocol_definition_is_framer(framer_definition), dumping backtrace:%{public}s", buf, 0x16u);
          }
        }

        free(v79);
        if (!v36) {
          goto LABEL_21;
        }
        goto LABEL_196;
      }
      id v35 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v94 = "nw_agent_client_attach_protocol_block_invoke";
      int v36 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v91 = 0;
      if (!__nwlog_fault(v36, &type, &v91)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v37 = __nwlog_obj();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_agent_client_attach_protocol_block_invoke";
          _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s called with null framer_definition", buf, 0xCu);
        }
      }
      else if (v91)
      {
        uint64_t v76 = (char *)__nw_create_backtrace_string();
        id v37 = __nwlog_obj();
        os_log_type_t v77 = type;
        BOOL v78 = os_log_type_enabled(v37, type);
        if (v76)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            v94 = "nw_agent_client_attach_protocol_block_invoke";
            __int16 v95 = 2082;
            *(void *)v96 = v76;
            _os_log_impl(&dword_1830D4000, v37, v77, "%{public}s called with null framer_definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v76);
LABEL_195:
          if (!v36) {
            goto LABEL_21;
          }
LABEL_196:
          free(v36);
          goto LABEL_21;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_agent_client_attach_protocol_block_invoke";
          _os_log_impl(&dword_1830D4000, v37, v77, "%{public}s called with null framer_definition, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v37 = __nwlog_obj();
        os_log_type_t v88 = type;
        if (os_log_type_enabled(v37, type))
        {
          *(_DWORD *)buf = 136446210;
          v94 = "nw_agent_client_attach_protocol_block_invoke";
          _os_log_impl(&dword_1830D4000, v37, v88, "%{public}s called with null framer_definition, backtrace limit exceeded", buf, 0xCu);
        }
      }
LABEL_194:

      goto LABEL_195;
    }
    int v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v94 = "nw_agent_client_attach_protocol_block_invoke";
    int v32 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (!__nwlog_fault(v32, &type, &v91)) {
      goto LABEL_184;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v94 = "nw_agent_client_attach_protocol_block_invoke";
        _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null (client->framer_protocol == NULL)", buf, 0xCu);
      }
    }
    else if (v91)
    {
      int v73 = (char *)__nw_create_backtrace_string();
      int v33 = __nwlog_obj();
      os_log_type_t v74 = type;
      BOOL v75 = os_log_type_enabled(v33, type);
      if (v73)
      {
        if (v75)
        {
          *(_DWORD *)buf = 136446466;
          v94 = "nw_agent_client_attach_protocol_block_invoke";
          __int16 v95 = 2082;
          *(void *)v96 = v73;
          _os_log_impl(&dword_1830D4000, v33, v74, "%{public}s called with null (client->framer_protocol == NULL), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v73);
        goto LABEL_184;
      }
      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        v94 = "nw_agent_client_attach_protocol_block_invoke";
        _os_log_impl(&dword_1830D4000, v33, v74, "%{public}s called with null (client->framer_protocol == NULL), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v33 = __nwlog_obj();
      os_log_type_t v87 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        v94 = "nw_agent_client_attach_protocol_block_invoke";
        _os_log_impl(&dword_1830D4000, v33, v87, "%{public}s called with null (client->framer_protocol == NULL), backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_184:
    if (v32) {
      free(v32);
    }
    return;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v23 = (id)gLogObj;
  if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
  {
    uint64_t v24 = *(void *)(a1 + 32) + 8;
    *(_DWORD *)buf = 136446722;
    v94 = "nw_agent_client_attach_protocol_block_invoke_2";
    __int16 v95 = 1042;
    *(_DWORD *)v96 = 16;
    *(_WORD *)&v96[4] = 2098;
    *(void *)&v96[6] = v24;
    _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s Not attaching protocol to closed client %{public,uuid_t}.16P", buf, 0x1Cu);
  }
}

void sub_183C722DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_agent_change_state(void *a1, int a2, int a3, void *a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  os_log_type_t v7 = a1;
  id v8 = a4;
  if (v7)
  {
    uint64_t v9 = v7[27];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_agent_change_state_block_invoke;
    block[3] = &unk_1E5249FB0;
    uint64_t v19 = v7;
    int v21 = a2;
    int v22 = a3;
    id v20 = v8;
    dispatch_async(v9, block);

    goto LABEL_3;
  }
  id v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v26 = "nw_agent_change_state";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v11, &v24, &v23))
  {
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = v24;
      if (os_log_type_enabled(v12, v24))
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_agent_change_state";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v15 = v24;
      BOOL v16 = os_log_type_enabled(v12, v24);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          int v26 = "nw_agent_change_state";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_agent_change_state";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v17 = v24;
      if (os_log_type_enabled(v12, v24))
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_agent_change_state";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v11) {
    free(v11);
  }
LABEL_3:
}

void __nw_agent_change_state_block_invoke(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = (id *)(a1 + 32);
  *(_DWORD *)(*(void *)(a1 + 32) + 232) = *(_DWORD *)(a1 + 48);
  *(_DWORD *)(*(void *)(a1 + 32) + 236) = *(_DWORD *)(a1 + 52);
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 224), *(id *)(a1 + 40));
  id v3 = *v2;
  uint64_t v4 = v3;
  if (v3)
  {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v3 + 27));
    nw_protocol_definition_t v5 = (void *)v4[105];
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZL19nw_agent_sync_stateP19NWConcrete_nw_agent_block_invoke;
    os_log_type_t v24 = &unk_1E524A220;
    uint64_t v25 = v4;
    nw_fd_wrapper_get_fd(v5, buf);

    goto LABEL_3;
  }
  os_log_type_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_agent_sync_state";
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v14, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_agent_sync_state";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_agent_sync_state";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_agent_sync_state";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_agent_sync_state";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v14) {
    free(v14);
  }
LABEL_3:

  if (!*(_DWORD *)(*(void *)(a1 + 32) + 232))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_protocol_definition_t v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
    {
      size_t count = nw_dictionary_get_count(*(void *)(*(void *)(a1 + 32) + 736));
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_agent_change_state_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = count;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}s changed state to inactive, removing %zu clients", buf, 0x16u);
    }

    id v8 = nw_dictionary_create();
    uint64_t v10 = *(void *)(a1 + 32);
    uint64_t v9 = a1 + 32;
    id v11 = *(void **)(v10 + 736);
    *(void *)(v10 + 736) = v8;

    char v12 = *(void **)(*(void *)v9 + 744);
    *(void *)(*(void *)v9 + 744) = 0;
  }
}

void sub_183C72A10(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL19nw_agent_sync_stateP19NWConcrete_nw_agent_block_invoke(uint64_t a1, int a2)
{
  uint64_t v14 = 0;
  os_log_type_t v15 = &v14;
  int v17 = 0;
  uint64_t v16 = 0x2020000000;
  id v3 = *(void **)(a1 + 32);
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  uint64_t v9 = ___ZL19nw_agent_sync_stateP19NWConcrete_nw_agent_block_invoke_2;
  uint64_t v10 = &unk_1E524A1F8;
  id v11 = v3;
  char v12 = &v14;
  int v13 = a2;
  uint64_t v4 = (os_unfair_lock_s *)v11;
  nw_protocol_definition_t v5 = v8;
  os_unfair_lock_lock(v4 + 2);
  v9((uint64_t)v5);
  os_unfair_lock_unlock(v4 + 2);

  BOOL v6 = *((_DWORD *)v15 + 6) == 0;
  _Block_object_dispose(&v14, 8);
  return v6;
}

void sub_183C72B34(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, void *a7, uint64_t a8, uint64_t a9, ...)
{
  va_start(va, a9);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL19nw_agent_sync_stateP19NWConcrete_nw_agent_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  *(void *)&v49[4068] = *MEMORY[0x1E4F143B8];
  bzero(v48, 0x1000uLL);
  uint64_t v2 = *(void *)(v1 + 32);
  char v3 = *(unsigned char *)(v2 + 856);
  if ((v3 & 0x28) == 0)
  {
    uint64_t v7 = 0;
    goto LABEL_22;
  }
  if ((*(unsigned char *)(v2 + 856) & 8) != 0)
  {
    int v4 = *(_DWORD *)(v2 + 260);
    v48[0] = *(_DWORD *)(v2 + 256);
    v48[1] = v4;
    v48[2] = v4;
    unint64_t v5 = *(unsigned __int8 *)(v2 + 348);
    if (*(unsigned char *)(v2 + 348))
    {
      if (v5 < 8)
      {
        unint64_t v6 = 0;
        do
        {
LABEL_10:
          unint64_t v12 = v6;
          int v13 = *(_DWORD *)(v2 + 288 + 4 * v6++);
          v48[v12 + 3] = v13;
        }
        while (v6 < v5);
        goto LABEL_11;
      }
      unint64_t v6 = v5 & 0xF8;
      id v8 = v49;
      uint64_t v9 = (long long *)(v2 + 304);
      unint64_t v10 = v6;
      do
      {
        long long v11 = *v9;
        *(v8 - 1) = *(v9 - 1);
        *id v8 = v11;
        v8 += 2;
        v9 += 2;
        v10 -= 8;
      }
      while (v10);
      if (v6 != v5) {
        goto LABEL_10;
      }
    }
  }
LABEL_11:
  if ((v3 & 0x20) != 0 && (unint64_t v14 = *(unsigned __int8 *)(v2 + 712), *(unsigned char *)(v2 + 712)))
  {
    if (v14 >= 3)
    {
      uint64_t v16 = 0;
      uint64_t v17 = v14 & 1;
      if ((v14 & 1) == 0) {
        uint64_t v17 = 2;
      }
      unint64_t v15 = v14 - v17;
      os_log_type_t v18 = (__int32 *)(v2 + 380);
      unint64_t v19 = v15;
      do
      {
        v50.val[0].i32[0] = *(v18 - 7);
        v50.val[0].i32[1] = *(v18 - 1);
        v50.val[1].i32[0] = *(v18 - 6);
        v50.val[1].i32[1] = *v18;
        os_log_type_t v20 = (float *)&v49[4 * (v16 & 0xFFFFFFFC) + 44];
        vst2_f32(v20, v50);
        v18 += 12;
        v16 += 4;
        v19 -= 2;
      }
      while (v19);
    }
    else
    {
      unint64_t v15 = 0;
    }
    uint64_t v21 = 2 * v15;
    int v22 = (uint64_t *)(v2 + 24 * v15 + 352);
    uint64_t v7 = 204;
    do
    {
      uint64_t v23 = *v22;
      v22 += 3;
      *(void *)&v49[4 * (v21 & 0xFFFFFFFE) + 44] = v23;
      ++v15;
      v21 += 2;
    }
    while (v15 < v14);
  }
  else
  {
    uint64_t v7 = 204;
  }
LABEL_22:
  os_log_type_t v24 = *(NSObject **)(v2 + 224);
  if (v24)
  {
    uint64_t v44 = 0;
    os_log_type_t v45 = &v44;
    uint64_t v46 = 0x2000000000;
    uint64_t v47 = 0;
    v43[0] = 0;
    v43[1] = v43;
    v43[2] = 0x2000000000;
    v43[3] = (char *)v48 + v7;
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 0x40000000;
    applier[2] = __nw_dispatch_data_copyout_block_invoke;
    applier[3] = &unk_1E5242B60;
    applier[5] = v43;
    applier[6] = 4096 - v7;
    applier[4] = &v44;
    dispatch_data_apply(v24, applier);
    uint64_t v25 = v45[3];
    _Block_object_dispose(v43, 8);
    _Block_object_dispose(&v44, 8);
    v7 += v25;
    uint64_t v2 = *(void *)(v1 + 32);
    char v3 = *(unsigned char *)(v2 + 856);
  }
  uint64_t v26 = (unsigned __int8 *)(v2 + 720);
  __int16 v27 = (unsigned char *)(v2 + 20);
  uint64_t v28 = (unsigned char *)(v2 + 52);
  uint64_t v29 = v2 + 84;
  int v31 = *(_DWORD *)(v2 + 232);
  unsigned int v30 = *(_DWORD *)(v2 + 236);
  int v32 = (v30 >> 1) & 1;
  BOOL v33 = v31 == 1;
  BOOL v34 = v31 == 3;
  int v35 = (v30 >> 2) & 1;
  char v36 = (v31 & 0xFFFFFFFE) == 2;
  id v37 = (const unsigned __int8 *)v48;
  if (!v7) {
    id v37 = 0;
  }
  BOOL v41 = (v30 & 8) != 0;
  char v38 = v30 & 1;
  if (v3) {
    int v39 = 3;
  }
  else {
    int v39 = 1;
  }
  uint64_t result = nw_network_agent_ctl_setsockopt(*(_DWORD *)(v1 + 48), v39, v26, v27, v28, v29, v33, v34, v36, v38, v32, v35, (v3 & 8) != 0, (v3 & 2) != 0, (v3 & 0x10) != 0, (v3 & 0x20) != 0, (v3 & 0x40) != 0, (v3 & 4) != 0, v41,
             v37,
             v7);
  *(_DWORD *)(*(void *)(*(void *)(v1 + 40) + 8) + 24) = result;
  if (!*(_DWORD *)(*(void *)(*(void *)(v1 + 40) + 8) + 24)) {
    *(unsigned char *)(*(void *)(v1 + 32) + 856) |= 1u;
  }
  if (*(_DWORD *)(*(void *)(v1 + 32) + 716))
  {
    LODWORD(applier[0]) = *(_DWORD *)(*(void *)(v1 + 32) + 716);
    uint64_t result = nw_network_agent_ctl_setsockopt_inner(*(_DWORD *)(v1 + 48), 24, (const unsigned __int8 *)applier, 4u, 0, 0);
    *(_DWORD *)(*(void *)(*(void *)(v1 + 40) + 8) + 24) = result;
  }
  return result;
}

NWConcrete_nw_agent *nw_agent_create_with_path_override_info(void *a1, const char *a2, void *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = v6;
  if (v5)
  {
    if (v6)
    {
      id v8 = nw_agent_create("Network", "PathOverride", a2, v6);
      goto LABEL_4;
    }
    unint64_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_agent_create_with_path_override_info";
    long long v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_agent_create_with_path_override_info";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null queue", buf, 0xCu);
        }
LABEL_38:

        goto LABEL_39;
      }
      if (!v23)
      {
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_agent_create_with_path_override_info";
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_agent_create_with_path_override_info";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null queue, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_agent_create_with_path_override_info";
        __int16 v27 = 2082;
        uint64_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    unint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_agent_create_with_path_override_info";
    long long v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_agent_create_with_path_override_info";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null override_info", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (!v23)
      {
        unint64_t v12 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_agent_create_with_path_override_info";
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null override_info, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_agent_create_with_path_override_info";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null override_info, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_agent_create_with_path_override_info";
        __int16 v27 = 2082;
        uint64_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null override_info, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
    }
  }
LABEL_39:
  if (v11) {
    free(v11);
  }
  id v8 = 0;
LABEL_4:

  return v8;
}

void sub_183C733EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_agent_set_uuid(void *a1, _OWORD *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  char v3 = a1;
  if (!v3)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_agent_set_uuid";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v22) = 16;
    char v19 = 0;
    if (__nwlog_fault(v7, &v22, &v19))
    {
      if (v22 == 17)
      {
        id v8 = __nwlog_obj();
        os_log_type_t v9 = v22;
        if (os_log_type_enabled(v8, (os_log_type_t)v22))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_set_uuid";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null agent", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v8 = __nwlog_obj();
        os_log_type_t v13 = v22;
        BOOL v14 = os_log_type_enabled(v8, (os_log_type_t)v22);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_agent_set_uuid";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_set_uuid";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null agent, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v8 = __nwlog_obj();
        os_log_type_t v15 = v22;
        if (os_log_type_enabled(v8, (os_log_type_t)v22))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_agent_set_uuid";
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v7) {
      free(v7);
    }
    goto LABEL_4;
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  os_log_type_t v21 = 0;
  int v4 = malloc_type_malloc(0x10uLL, 0xF2B69DE5uLL);
  if (v4)
  {
LABEL_3:
    os_log_type_t v21 = v4;
    *(_OWORD *)*(void *)(*(void *)&buf[8] + 24) = *a2;
    id v5 = v3[27];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_agent_set_uuid_block_invoke;
    block[3] = &unk_1E524B978;
    os_log_type_t v17 = v3;
    BOOL v18 = buf;
    dispatch_async(v5, block);

    _Block_object_dispose(buf, 8);
LABEL_4:

    return;
  }
  unint64_t v10 = __nwlog_obj();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  int v22 = 136446466;
  char v23 = "strict_malloc";
  __int16 v24 = 2048;
  uint64_t v25 = 16;
  long long v11 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v11))
  {
    free(v11);
    goto LABEL_3;
  }
  __break(1u);
}

void sub_183C737EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_uuid_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 856) & 1) == 0)
  {
    *(_OWORD *)(v2 + 720) = *(_OWORD *)*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    goto LABEL_14;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_agent_set_uuid_block_invoke";
  int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (!__nwlog_fault(v4, &type, &v14))
  {
LABEL_12:
    if (!v4) {
      goto LABEL_14;
    }
    goto LABEL_13;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_agent_set_uuid_block_invoke";
    uint64_t v7 = "%{public}s Cannot modify agent UUID after registration";
LABEL_19:
    unint64_t v12 = v5;
    os_log_type_t v13 = v6;
LABEL_20:
    _os_log_impl(&dword_1830D4000, v12, v13, v7, buf, 0xCu);
    goto LABEL_21;
  }
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_21;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_agent_set_uuid_block_invoke";
    uint64_t v7 = "%{public}s Cannot modify agent UUID after registration, backtrace limit exceeded";
    goto LABEL_19;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  os_log_type_t v9 = type;
  BOOL v10 = os_log_type_enabled(v5, type);
  if (backtrace_string)
  {
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v17 = "nw_agent_set_uuid_block_invoke";
      __int16 v18 = 2082;
      char v19 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v5, v9, "%{public}s Cannot modify agent UUID after registration, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(backtrace_string);
    goto LABEL_12;
  }
  if (v10)
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_agent_set_uuid_block_invoke";
    uint64_t v7 = "%{public}s Cannot modify agent UUID after registration, no backtrace";
    unint64_t v12 = v5;
    os_log_type_t v13 = v9;
    goto LABEL_20;
  }
LABEL_21:

  if (v4) {
LABEL_13:
  }
    free(v4);
LABEL_14:
  long long v11 = *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v11)
  {
    free(v11);
    *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
  }
}

void nw_agent_get_uuid(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    *a2 = *((_OWORD *)v3 + 45);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_agent_get_uuid";
  os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_agent_get_uuid";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_agent_get_uuid";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_agent_get_uuid";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_agent_get_uuid";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_agent_set_activate_handler(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_agent_set_activate_handler";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_activate_handler";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "nw_agent_set_activate_handler";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_activate_handler";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_activate_handler";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __nw_agent_set_activate_handler_block_invoke;
    v21[3] = &unk_1E524B950;
    os_log_type_t v6 = (os_unfair_lock_s *)v3;
    int v22 = v6;
    id v23 = v5;
    os_unfair_lock_lock(v6 + 2);
    __nw_agent_set_activate_handler_block_invoke((uint64_t)v21);
    os_unfair_lock_unlock(v6 + 2);

    goto LABEL_4;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "nw_agent_set_activate_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_activate_handler";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null activate_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_activate_handler";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null activate_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_activate_handler";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null activate_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_agent_set_activate_handler";
    __int16 v28 = 2082;
    uint64_t v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null activate_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183C742E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_activate_handler_block_invoke(uint64_t a1)
{
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 752);
  *(void *)(v3 + 752) = v2;
}

void __nw_agent_set_assert_handlers_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 856) |= 4u;
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 760);
  *(void *)(v3 + 760) = v2;

  id v5 = _Block_copy(*(const void **)(a1 + 48));
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void **)(v6 + 768);
  *(void *)(v6 + 768) = v5;
}

void nw_agent_set_error_handler(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_agent_set_error_handler";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_error_handler";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "nw_agent_set_error_handler";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_error_handler";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_error_handler";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __nw_agent_set_error_handler_block_invoke;
    v21[3] = &unk_1E524B950;
    uint64_t v6 = (os_unfair_lock_s *)v3;
    int v22 = v6;
    id v23 = v5;
    os_unfair_lock_lock(v6 + 2);
    __nw_agent_set_error_handler_block_invoke((uint64_t)v21);
    os_unfair_lock_unlock(v6 + 2);

    goto LABEL_4;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "nw_agent_set_error_handler";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_error_handler";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null error_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_error_handler";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null error_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  uint64_t v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_error_handler";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null error_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_agent_set_error_handler";
    __int16 v28 = 2082;
    uint64_t v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null error_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183C748F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_error_handler_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 856) |= 4u;
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 832);
  *(void *)(v3 + 832) = v2;
}

void nw_agent_set_token_low_water_mark(void *a1, int a2, void *a3)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a3;
  uint64_t v7 = v6;
  if (!v5)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v30 = "nw_agent_set_token_low_water_mark";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v10, &v28, &v27)) {
      goto LABEL_38;
    }
    if (v28 == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = v28;
      if (os_log_type_enabled(v11, v28))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_agent_set_token_low_water_mark";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = v28;
      BOOL v17 = os_log_type_enabled(v11, v28);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v30 = "nw_agent_set_token_low_water_mark";
          __int16 v31 = 2082;
          int v32 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v10) {
          goto LABEL_4;
        }
LABEL_39:
        free(v10);
        goto LABEL_4;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_agent_set_token_low_water_mark";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v21 = v28;
      if (os_log_type_enabled(v11, v28))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v30 = "nw_agent_set_token_low_water_mark";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v6)
  {
    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = __nw_agent_set_token_low_water_mark_block_invoke;
    v23[3] = &unk_1E524BB48;
    os_log_type_t v8 = (os_unfair_lock_s *)v5;
    char v24 = v8;
    int v26 = a2;
    id v25 = v7;
    os_unfair_lock_lock(v8 + 2);
    __nw_agent_set_token_low_water_mark_block_invoke((uint64_t)v23);
    os_unfair_lock_unlock(v8 + 2);

    goto LABEL_4;
  }
  char v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v30 = "nw_agent_set_token_low_water_mark";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v28 = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (!__nwlog_fault(v10, &v28, &v27)) {
    goto LABEL_38;
  }
  if (v28 == OS_LOG_TYPE_FAULT)
  {
    BOOL v11 = __nwlog_obj();
    os_log_type_t v14 = v28;
    if (os_log_type_enabled(v11, v28))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_agent_set_token_low_water_mark";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null tokens_needed_handler", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v27)
  {
    BOOL v11 = __nwlog_obj();
    os_log_type_t v22 = v28;
    if (os_log_type_enabled(v11, v28))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_agent_set_token_low_water_mark";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null tokens_needed_handler, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  BOOL v18 = (char *)__nw_create_backtrace_string();
  BOOL v11 = __nwlog_obj();
  os_log_type_t v19 = v28;
  BOOL v20 = os_log_type_enabled(v11, v28);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v30 = "nw_agent_set_token_low_water_mark";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null tokens_needed_handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v30 = "nw_agent_set_token_low_water_mark";
    __int16 v31 = 2082;
    int v32 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null tokens_needed_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183C74EB8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_token_low_water_mark_block_invoke(uint64_t a1)
{
  *(_DWORD *)(*(void *)(a1 + 32) + 716) = *(_DWORD *)(a1 + 48);
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 824);
  *(void *)(v3 + 824) = v2;
}

void nw_agent_add_token(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v27 = "nw_agent_add_token";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_agent_add_token";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          char v27 = "nw_agent_add_token";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_agent_add_token";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        char v27 = "nw_agent_add_token";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    id v6 = v3[27];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_agent_add_token_block_invoke;
    block[3] = &unk_1E524B9A0;
    os_log_type_t v22 = v3;
    id v23 = v5;
    dispatch_async(v6, block);

    goto LABEL_4;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v27 = "nw_agent_add_token";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      char v27 = "nw_agent_add_token";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null token", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      char v27 = "nw_agent_add_token";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null token, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      char v27 = "nw_agent_add_token";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null token, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    char v27 = "nw_agent_add_token";
    __int16 v28 = 2082;
    uint64_t v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null token, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

void __nw_agent_add_token_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void **)(*(void *)(a1 + 32) + 840);
  v2[0] = MEMORY[0x1E4F143A8];
  v2[1] = 3221225472;
  v2[2] = __nw_agent_add_token_block_invoke_2;
  v2[3] = &unk_1E524A220;
  id v3 = *(id *)(a1 + 40);
  nw_fd_wrapper_get_fd(v1, v2);
}

void sub_183C754EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_agent_add_token_block_invoke_2(uint64_t a1)
{
  uint64_t v1 = MEMORY[0x1F4188790](a1);
  int v3 = v2;
  uint64_t v4 = v1;
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  bzero(v14, 0x1000uLL);
  id v5 = *(NSObject **)(v4 + 32);
  uint64_t v10 = 0;
  BOOL v11 = &v10;
  uint64_t v12 = 0x2000000000;
  uint64_t v13 = 0;
  v9[0] = 0;
  v9[1] = v9;
  v9[2] = 0x2000000000;
  v9[3] = v14;
  if (v5)
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    void v8[2] = __nw_dispatch_data_copyout_block_invoke;
    v8[3] = &unk_1E5242B60;
    v8[5] = v9;
    v8[6] = 4096;
    v8[4] = &v10;
    dispatch_data_apply(v5, v8);
    unsigned int v6 = *((_DWORD *)v11 + 6);
  }
  else
  {
    unsigned int v6 = 0;
  }
  _Block_object_dispose(v9, 8);
  _Block_object_dispose(&v10, 8);
  nw_network_agent_ctl_setsockopt_inner(v3, 21, v14, v6, 0, 0);
  return 1;
}

void nw_agent_flush_tokens(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    int v3 = v1[27];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_agent_flush_tokens_block_invoke;
    block[3] = &unk_1E524BAA8;
    uint64_t v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_agent_flush_tokens";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_flush_tokens";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_agent_flush_tokens";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_flush_tokens";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_flush_tokens";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

uint64_t __nw_agent_flush_tokens_block_invoke(uint64_t a1)
{
  return nw_fd_wrapper_get_fd(*(void **)(*(void *)(a1 + 32) + 840), &__block_literal_global_81122);
}

uint64_t __nw_agent_flush_tokens_block_invoke_2(uint64_t a1, int a2)
{
  return 1;
}

void nw_agent_reset_error(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  int v2 = v1;
  if (v1)
  {
    int v3 = v1[27];
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_agent_reset_error_block_invoke;
    block[3] = &unk_1E524BAA8;
    uint64_t v13 = v1;
    dispatch_async(v3, block);

    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_agent_reset_error";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_reset_error";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_agent_reset_error";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_reset_error";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_reset_error";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

uint64_t __nw_agent_reset_error_block_invoke(uint64_t a1)
{
  return nw_fd_wrapper_get_fd(*(void **)(*(void *)(a1 + 32) + 840), &__block_literal_global_80);
}

uint64_t __nw_agent_reset_error_block_invoke_2(uint64_t a1, int a2)
{
  return 1;
}

BOOL nw_agent_add_to_interface(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      BOOL v6 = nw_network_agent_add_to_interface((uint64_t)v4 + 104, v3 + 720) == 0;
      goto LABEL_4;
    }
    uint64_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v24 = "nw_agent_add_to_interface";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_add_to_interface";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null interface", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v21)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_add_to_interface";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_add_to_interface";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        char v24 = "nw_agent_add_to_interface";
        __int16 v25 = 2082;
        int v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v24 = "nw_agent_add_to_interface";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_add_to_interface";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null agent", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v21)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_add_to_interface";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_add_to_interface";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null agent, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        char v24 = "nw_agent_add_to_interface";
        __int16 v25 = 2082;
        int v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9) {
    free(v9);
  }
  BOOL v6 = 0;
LABEL_4:

  return v6;
}

BOOL nw_agent_remove_from_interface(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  int v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      BOOL v6 = nw_network_agent_remove_from_interface((uint64_t)v4 + 104, v3 + 720) == 0;
      goto LABEL_4;
    }
    uint64_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v24 = "nw_agent_remove_from_interface";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_remove_from_interface";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null interface", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v21)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_remove_from_interface";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_remove_from_interface";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        char v24 = "nw_agent_remove_from_interface";
        __int16 v25 = 2082;
        int v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v24 = "nw_agent_remove_from_interface";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_remove_from_interface";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null agent", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v21)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_remove_from_interface";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          char v24 = "nw_agent_remove_from_interface";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null agent, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        char v24 = "nw_agent_remove_from_interface";
        __int16 v25 = 2082;
        int v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9) {
    free(v9);
  }
  BOOL v6 = 0;
LABEL_4:

  return v6;
}

void nw_agent_add_resolve_handlers(void *a1, int a2, int a3, void *a4, void *a5)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  os_log_type_t v9 = a1;
  id v10 = a4;
  id v11 = a5;
  uint64_t v12 = v11;
  if (!v9)
  {
    char v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_agent_add_resolve_handlers";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v15, &v40, &v39)) {
      goto LABEL_55;
    }
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v39)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v16 = __nwlog_obj();
      os_log_type_t v23 = v40;
      BOOL v24 = os_log_type_enabled(v16, v40);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v42 = "nw_agent_add_resolve_handlers";
          __int16 v43 = 2082;
          uint64_t v44 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v15) {
          goto LABEL_5;
        }
LABEL_56:
        free(v15);
        goto LABEL_5;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v30 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v30, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v10)
  {
    BOOL v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_agent_add_resolve_handlers";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v15, &v40, &v39)) {
      goto LABEL_55;
    }
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v19 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null start_resolve_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v39)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v31 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v31, "%{public}s called with null start_resolve_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    __int16 v25 = (char *)__nw_create_backtrace_string();
    BOOL v16 = __nwlog_obj();
    os_log_type_t v26 = v40;
    BOOL v27 = os_log_type_enabled(v16, v40);
    if (!v25)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s called with null start_resolve_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v42 = "nw_agent_add_resolve_handlers";
      __int16 v43 = 2082;
      uint64_t v44 = v25;
      _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s called with null start_resolve_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v11)
  {
    os_log_type_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "nw_agent_add_resolve_handlers";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v40 = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v15, &v40, &v39)) {
      goto LABEL_55;
    }
    if (v40 == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v21 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null stop_resolve_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v39)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v32 = v40;
      if (os_log_type_enabled(v16, v40))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v32, "%{public}s called with null stop_resolve_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    __int16 v25 = (char *)__nw_create_backtrace_string();
    BOOL v16 = __nwlog_obj();
    os_log_type_t v28 = v40;
    BOOL v29 = os_log_type_enabled(v16, v40);
    if (!v25)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "nw_agent_add_resolve_handlers";
        _os_log_impl(&dword_1830D4000, v16, v28, "%{public}s called with null stop_resolve_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v42 = "nw_agent_add_resolve_handlers";
      __int16 v43 = 2082;
      uint64_t v44 = v25;
      _os_log_impl(&dword_1830D4000, v16, v28, "%{public}s called with null stop_resolve_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v25);
    if (!v15) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  os_log_type_t v13 = v9[27];
  block[0] = MEMORY[0x1E4F143A8];
  block[1] = 3221225472;
  block[2] = __nw_agent_add_resolve_handlers_block_invoke;
  block[3] = &unk_1E524A020;
  BOOL v34 = v9;
  int v37 = a2;
  int v38 = a3;
  id v35 = v10;
  id v36 = v12;
  dispatch_async(v13, block);

LABEL_5:
}

void __nw_agent_add_resolve_handlers_block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(a1 + 32) + 856) |= 0x20u;
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = *(unsigned __int8 *)(v1 + 712);
  if (v2 < 0xF)
  {
    uint64_t v5 = 24 * v2;
    *(_DWORD *)(v1 + 24 * v2 + 352) = *(_DWORD *)(a1 + 56);
    *(_DWORD *)(*(void *)(a1 + 32) + 24 * v2 + 356) = *(_DWORD *)(a1 + 60);
    BOOL v6 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v7 = *(void *)(a1 + 32) + v5;
    os_log_type_t v8 = *(void **)(v7 + 360);
    *(void *)(v7 + 360) = v6;

    os_log_type_t v9 = _Block_copy(*(const void **)(a1 + 48));
    uint64_t v10 = *(void *)(a1 + 32) + v5;
    id v11 = *(void **)(v10 + 368);
    *(void *)(v10 + 368) = v9;

    ++*(unsigned char *)(*(void *)(a1 + 32) + 712);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v12 = 136446210;
      os_log_type_t v13 = "nw_agent_add_resolve_handlers_block_invoke";
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s Maximum number of resolution pairs reached", (uint8_t *)&v12, 0xCu);
    }
  }
}

void nw_agent_set_browse_handlers(void *a1, void *a2, void *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v36 = "nw_agent_set_browse_handlers";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_agent_set_browse_handlers";
          __int16 v37 = 2082;
          int v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11) {
          goto LABEL_5;
        }
LABEL_56:
        free(v11);
        goto LABEL_5;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v12 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v26, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v6)
  {
    uint64_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v36 = "nw_agent_set_browse_handlers";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null start_browse_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      int v12 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s called with null start_browse_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    int v12 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null start_browse_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_agent_set_browse_handlers";
      __int16 v37 = 2082;
      int v38 = v21;
      _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null start_browse_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v7)
  {
    BOOL v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v36 = "nw_agent_set_browse_handlers";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null stop_browse_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      int v12 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v28, "%{public}s called with null stop_browse_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v21 = (char *)__nw_create_backtrace_string();
    int v12 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_browse_handlers";
        _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null stop_browse_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_agent_set_browse_handlers";
      __int16 v37 = 2082;
      int v38 = v21;
      _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null stop_browse_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v21);
    if (!v11) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = __nw_agent_set_browse_handlers_block_invoke;
  v29[3] = &unk_1E5249FD8;
  os_log_type_t v9 = (os_unfair_lock_s *)v5;
  os_log_type_t v30 = v9;
  id v31 = v6;
  id v32 = v8;
  os_unfair_lock_lock(v9 + 2);
  __nw_agent_set_browse_handlers_block_invoke((uint64_t)v29);
  os_unfair_lock_unlock(v9 + 2);

LABEL_5:
}

void sub_183C77680(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_browse_handlers_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 856) |= 0x10u;
  unint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 792);
  *(void *)(v3 + 792) = v2;

  id v5 = _Block_copy(*(const void **)(a1 + 48));
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = *(void **)(v6 + 800);
  *(void *)(v6 + 800) = v5;
}

void nw_agent_set_flow_handlers(void *a1, int a2, int a3, char a4, void *a5, void *a6)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  id v11 = a1;
  id v12 = a5;
  id v13 = a6;
  uint64_t v14 = v13;
  if (!v11)
  {
    BOOL v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v45 = "nw_agent_set_flow_handlers";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v43 = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v17, &v43, &v42)) {
      goto LABEL_55;
    }
    if (v43 == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = v43;
      if (os_log_type_enabled(v18, v43))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = __nwlog_obj();
      os_log_type_t v25 = v43;
      BOOL v26 = os_log_type_enabled(v18, v43);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v45 = "nw_agent_set_flow_handlers";
          __int16 v46 = 2082;
          uint64_t v47 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v17) {
          goto LABEL_5;
        }
LABEL_56:
        free(v17);
        goto LABEL_5;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v32 = v43;
      if (os_log_type_enabled(v18, v43))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v32, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v12)
  {
    BOOL v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v45 = "nw_agent_set_flow_handlers";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v43 = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v17, &v43, &v42)) {
      goto LABEL_55;
    }
    if (v43 == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v21 = v43;
      if (os_log_type_enabled(v18, v43))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null start_flow_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v42)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v33 = v43;
      if (os_log_type_enabled(v18, v43))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v33, "%{public}s called with null start_flow_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v27 = (char *)__nw_create_backtrace_string();
    BOOL v18 = __nwlog_obj();
    os_log_type_t v28 = v43;
    BOOL v29 = os_log_type_enabled(v18, v43);
    if (!v27)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v28, "%{public}s called with null start_flow_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v45 = "nw_agent_set_flow_handlers";
      __int16 v46 = 2082;
      uint64_t v47 = v27;
      _os_log_impl(&dword_1830D4000, v18, v28, "%{public}s called with null start_flow_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v13)
  {
    os_log_type_t v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v45 = "nw_agent_set_flow_handlers";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v43 = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v17, &v43, &v42)) {
      goto LABEL_55;
    }
    if (v43 == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v23 = v43;
      if (os_log_type_enabled(v18, v43))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null stop_flow_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v42)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v34 = v43;
      if (os_log_type_enabled(v18, v43))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v34, "%{public}s called with null stop_flow_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    os_log_type_t v27 = (char *)__nw_create_backtrace_string();
    BOOL v18 = __nwlog_obj();
    os_log_type_t v30 = v43;
    BOOL v31 = os_log_type_enabled(v18, v43);
    if (!v27)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v45 = "nw_agent_set_flow_handlers";
        _os_log_impl(&dword_1830D4000, v18, v30, "%{public}s called with null stop_flow_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v45 = "nw_agent_set_flow_handlers";
      __int16 v46 = 2082;
      uint64_t v47 = v27;
      _os_log_impl(&dword_1830D4000, v18, v30, "%{public}s called with null stop_flow_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v27);
    if (!v17) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  v35[0] = MEMORY[0x1E4F143A8];
  v35[1] = 3221225472;
  v35[2] = __nw_agent_set_flow_handlers_block_invoke;
  v35[3] = &unk_1E524A048;
  os_log_type_t v15 = (os_unfair_lock_s *)v11;
  id v36 = v15;
  int v39 = a2;
  int v40 = a3;
  char v41 = a4;
  id v37 = v12;
  id v38 = v14;
  os_unfair_lock_lock(v15 + 2);
  __nw_agent_set_flow_handlers_block_invoke((uint64_t)v35);
  os_unfair_lock_unlock(v15 + 2);

LABEL_5:
}

void sub_183C77EA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void nw_agent_add_flow_request_endpoint_type(void *a1, int a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    uint64_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    v20[2] = __nw_agent_add_flow_request_endpoint_type_block_invoke;
    v20[3] = &unk_1E524A070;
    os_log_type_t v21 = (os_unfair_lock_s *)v3;
    int v22 = a2;
    id v5 = v21 + 2;
    os_unfair_lock_lock(v21 + 2);
    __nw_agent_add_flow_request_endpoint_type_block_invoke((uint64_t)v20);
    os_unfair_lock_unlock(v5);

    goto LABEL_4;
  }
  uint64_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v7, &type, &v23)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null endpoint_type", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null endpoint_type, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  os_log_type_t v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null endpoint_type, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v26 = "nw_agent_add_flow_request_endpoint_type";
    __int16 v27 = 2082;
    os_log_type_t v28 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null endpoint_type, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183C783F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_agent_add_flow_request_endpoint_type_block_invoke(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  unint64_t v2 = *(unsigned __int8 *)(v1 + 348);
  if (v2 < 0xF)
  {
    *(_DWORD *)(v1 + 4 * v2 + 288) = *(_DWORD *)(a1 + 40);
    ++*(unsigned char *)(*(void *)(a1 + 32) + 348);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136446210;
      id v5 = "nw_agent_add_flow_request_endpoint_type_block_invoke";
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s Maximum number of flow types", (uint8_t *)&v4, 0xCu);
    }
  }
}

void nw_agent_set_flow_sizes(void *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  os_log_type_t v8 = v7;
  if (v7)
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __nw_agent_set_flow_sizes_block_invoke;
    v18[3] = &unk_1E524A098;
    os_log_type_t v19 = (os_unfair_lock_s *)v7;
    uint64_t v20 = a2;
    uint64_t v21 = a3;
    uint64_t v22 = a4;
    os_log_type_t v9 = v19 + 2;
    os_unfair_lock_lock(v19 + 2);
    __nw_agent_set_flow_sizes_block_invoke(v18);
    os_unfair_lock_unlock(v9);

    goto LABEL_3;
  }
  uint64_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v26 = "nw_agent_set_flow_sizes";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v11, &v24, &v23))
  {
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      id v12 = __nwlog_obj();
      os_log_type_t v13 = v24;
      if (os_log_type_enabled(v12, v24))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_agent_set_flow_sizes";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v12 = __nwlog_obj();
      os_log_type_t v15 = v24;
      BOOL v16 = os_log_type_enabled(v12, v24);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_agent_set_flow_sizes";
          __int16 v27 = 2082;
          os_log_type_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_agent_set_flow_sizes";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v12 = __nwlog_obj();
      os_log_type_t v17 = v24;
      if (os_log_type_enabled(v12, v24))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_agent_set_flow_sizes";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v11) {
    free(v11);
  }
LABEL_3:
}

void sub_183C78824(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_flow_sizes_block_invoke(void *a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1[4];
  if (*(void *)(v1 + 248))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446210;
      int v4 = "nw_agent_set_flow_sizes_block_invoke";
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s Cannot set flow sizes after setting flow handlers", (uint8_t *)&v3, 0xCu);
    }
  }
  else
  {
    *(void *)(v1 + 264) = a1[5];
    *(void *)(a1[4] + 272) = a1[6];
    *(void *)(a1[4] + 280) = a1[7];
  }
}

void nw_agent_set_flow_do_not_coalesce(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  unint64_t v2 = v1;
  if (v1)
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_agent_set_flow_do_not_coalesce_block_invoke;
    v12[3] = &unk_1E524BAA8;
    os_log_type_t v13 = (os_unfair_lock_s *)v1;
    int v3 = v13 + 2;
    os_unfair_lock_lock(v13 + 2);
    __nw_agent_set_flow_do_not_coalesce_block_invoke((uint64_t)v12);
    os_unfair_lock_unlock(v3);

    goto LABEL_3;
  }
  int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_agent_set_flow_do_not_coalesce";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_set_flow_do_not_coalesce";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_agent_set_flow_do_not_coalesce";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_set_flow_do_not_coalesce";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_agent_set_flow_do_not_coalesce";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_183C78C40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_flow_do_not_coalesce_block_invoke(uint64_t a1)
{
  uint64_t v5 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (*(void *)(v1 + 248))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446210;
      int v4 = "nw_agent_set_flow_do_not_coalesce_block_invoke";
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s Cannot set do not coalesce after setting flow handlers", (uint8_t *)&v3, 0xCu);
    }
  }
  else
  {
    *(unsigned char *)(v1 + 856) |= 0x80u;
  }
}

void nw_agent_set_flow_context(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_agent_set_flow_context";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_flow_context";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "nw_agent_set_flow_context";
          __int16 v28 = 2082;
          uint64_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_flow_context";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_agent_set_flow_context";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v21[0] = MEMORY[0x1E4F143A8];
    v21[1] = 3221225472;
    v21[2] = __nw_agent_set_flow_context_block_invoke;
    v21[3] = &unk_1E524B9A0;
    uint64_t v6 = (os_unfair_lock_s *)v3;
    uint64_t v22 = v6;
    id v23 = v5;
    os_unfair_lock_lock(v6 + 2);
    __nw_agent_set_flow_context_block_invoke((uint64_t)v21);
    os_unfair_lock_unlock(v6 + 2);

    goto LABEL_4;
  }
  os_log_type_t v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "nw_agent_set_flow_context";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_flow_context";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_flow_context";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  BOOL v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_agent_set_flow_context";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_agent_set_flow_context";
    __int16 v28 = 2082;
    uint64_t v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_183C79280(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_flow_context_block_invoke(uint64_t a1)
{
}

void nw_agent_set_group_handlers(void *a1, void *a2, void *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v36 = "nw_agent_set_group_handlers";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null agent", buf, 0xCu);
      }
    }
    else if (v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_agent_set_group_handlers";
          __int16 v37 = 2082;
          id v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_55:
        if (!v11) {
          goto LABEL_5;
        }
LABEL_56:
        free(v11);
        goto LABEL_5;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v26, "%{public}s called with null agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_54:

    goto LABEL_55;
  }
  if (!v6)
  {
    os_log_type_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v36 = "nw_agent_set_group_handlers";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null add_members_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s called with null add_members_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v21 = (char *)__nw_create_backtrace_string();
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null add_members_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_agent_set_group_handlers";
      __int16 v37 = 2082;
      id v38 = v21;
      _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null add_members_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!v7)
  {
    BOOL v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v36 = "nw_agent_set_group_handlers";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v11, &type, &v33)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null remove_members_handler", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (!v33)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v28, "%{public}s called with null remove_members_handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_54;
    }
    uint64_t v21 = (char *)__nw_create_backtrace_string();
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v12, type);
    if (!v21)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        id v36 = "nw_agent_set_group_handlers";
        _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null remove_members_handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_54;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      id v36 = "nw_agent_set_group_handlers";
      __int16 v37 = 2082;
      id v38 = v21;
      _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null remove_members_handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(v21);
    if (!v11) {
      goto LABEL_5;
    }
    goto LABEL_56;
  }
  v29[0] = MEMORY[0x1E4F143A8];
  v29[1] = 3221225472;
  v29[2] = __nw_agent_set_group_handlers_block_invoke;
  v29[3] = &unk_1E5249FD8;
  os_log_type_t v9 = (os_unfair_lock_s *)v5;
  uint64_t v30 = v9;
  id v31 = v6;
  id v32 = v8;
  os_unfair_lock_lock(v9 + 2);
  __nw_agent_set_group_handlers_block_invoke((uint64_t)v29);
  os_unfair_lock_unlock(v9 + 2);

LABEL_5:
}

void sub_183C79A24(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_agent_set_group_handlers_block_invoke(uint64_t a1)
{
  *(unsigned char *)(*(void *)(a1 + 32) + 856) |= 0x40u;
  unint64_t v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  id v4 = *(void **)(v3 + 808);
  *(void *)(v3 + 808) = v2;

  id v5 = _Block_copy(*(const void **)(a1 + 48));
  uint64_t v6 = *(void *)(a1 + 32);
  id v7 = *(void **)(v6 + 816);
  *(void *)(v6 + 816) = v5;
}

uint64_t nw_log_delta_to_ms(unsigned int a1)
{
  return (unsigned __int16)(a1 & 0x7FF) << (a1 >> 11);
}

uint64_t nw_log_ms_to_delta(unsigned int a1)
{
  unsigned int v1 = 21 - __clz(a1);
  int v2 = (a1 >> v1) | (v1 << 11);
  if (a1 < 0x800) {
    LOWORD(v2) = a1;
  }
  return (unsigned __int16)v2;
}

void nw_log_ring_append(uint64_t a1, unint64_t a2, char *__src)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *(void *)a1;
  if (a2 + 1 > *(void *)a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = *(void *)a1;
    int __srca = 136446722;
    id v36 = "nw_log_ring_append";
    __int16 v37 = 2048;
    unint64_t v38 = a2;
    __int16 v39 = 2048;
    uint64_t v40 = v6;
    id v7 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v7, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v10 = *(void *)a1;
          int __srca = 136446722;
          id v36 = "nw_log_ring_append";
          __int16 v37 = 2048;
          unint64_t v38 = a2;
          __int16 v39 = 2048;
          uint64_t v40 = v10;
          os_log_type_t v11 = "%{public}s Trying to insert %zu bytes in ring of %zu bytes";
LABEL_34:
          _os_log_impl(&dword_1830D4000, v8, v9, v11, (uint8_t *)&__srca, 0x20u);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = gLogObj;
        os_log_type_t v9 = type;
        BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v26)
          {
            uint64_t v27 = *(void *)a1;
            int __srca = 136446978;
            id v36 = "nw_log_ring_append";
            __int16 v37 = 2048;
            unint64_t v38 = a2;
            __int16 v39 = 2048;
            uint64_t v40 = v27;
            __int16 v41 = 2082;
            char v42 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Trying to insert %zu bytes in ring of %zu bytes, dumping backtrace:%{public}s", (uint8_t *)&__srca, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_35;
        }
        if (v26)
        {
          uint64_t v31 = *(void *)a1;
          int __srca = 136446722;
          id v36 = "nw_log_ring_append";
          __int16 v37 = 2048;
          unint64_t v38 = a2;
          __int16 v39 = 2048;
          uint64_t v40 = v31;
          os_log_type_t v11 = "%{public}s Trying to insert %zu bytes in ring of %zu bytes, no backtrace";
          goto LABEL_34;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v30 = *(void *)a1;
          int __srca = 136446722;
          id v36 = "nw_log_ring_append";
          __int16 v37 = 2048;
          unint64_t v38 = a2;
          __int16 v39 = 2048;
          uint64_t v40 = v30;
          os_log_type_t v11 = "%{public}s Trying to insert %zu bytes in ring of %zu bytes, backtrace limit exceeded";
          goto LABEL_34;
        }
      }
    }
LABEL_35:
    if (!v7) {
      return;
    }
    id v32 = (char *)v7;
LABEL_44:
    free(v32);
    return;
  }
  if (a2 >= 0x100)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int __srca = 136446722;
    id v36 = "nw_log_ring_append";
    __int16 v37 = 2048;
    unint64_t v38 = a2;
    __int16 v39 = 2048;
    uint64_t v40 = 255;
    os_log_type_t v12 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v12, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v13 = gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          int __srca = 136446722;
          id v36 = "nw_log_ring_append";
          __int16 v37 = 2048;
          unint64_t v38 = a2;
          __int16 v39 = 2048;
          uint64_t v40 = 255;
          os_log_type_t v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu";
LABEL_41:
          _os_log_impl(&dword_1830D4000, v13, v14, v15, (uint8_t *)&__srca, 0x20u);
        }
      }
      else if (v33)
      {
        os_log_type_t v28 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v13 = gLogObj;
        os_log_type_t v14 = type;
        BOOL v29 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v28)
        {
          if (v29)
          {
            int __srca = 136446978;
            id v36 = "nw_log_ring_append";
            __int16 v37 = 2048;
            unint64_t v38 = a2;
            __int16 v39 = 2048;
            uint64_t v40 = 255;
            __int16 v41 = 2082;
            char v42 = v28;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, dumping backtrace:%{public}s", (uint8_t *)&__srca, 0x2Au);
          }
          free(v28);
          goto LABEL_42;
        }
        if (v29)
        {
          int __srca = 136446722;
          id v36 = "nw_log_ring_append";
          __int16 v37 = 2048;
          unint64_t v38 = a2;
          __int16 v39 = 2048;
          uint64_t v40 = 255;
          os_log_type_t v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, no backtrace";
          goto LABEL_41;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v13 = gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          int __srca = 136446722;
          id v36 = "nw_log_ring_append";
          __int16 v37 = 2048;
          unint64_t v38 = a2;
          __int16 v39 = 2048;
          uint64_t v40 = 255;
          os_log_type_t v15 = "%{public}s Trying to insert %zu bytes in ring. Max entry length=%zu, backtrace limit exceeded";
          goto LABEL_41;
        }
      }
    }
LABEL_42:
    if (!v12) {
      return;
    }
    id v32 = (char *)v12;
    goto LABEL_44;
  }
  LOBYTE(__srca) = a2;
  uint64_t v17 = a1 + 17;
  uint64_t v18 = *(void *)(a1 + 8);
  os_log_type_t v19 = (void *)(a1 + 17 + v18);
  unint64_t v20 = v5 - v18;
  if (v5 - v18 >= a2) {
    size_t v21 = a2;
  }
  else {
    size_t v21 = v5 - v18;
  }
  memcpy(v19, __src, v21);
  size_t v22 = *(void *)(a1 + 8) + v21;
  *(void *)(a1 + 8) = v22;
  if (v20 < a2)
  {
    size_t v22 = a2 - v21;
    memcpy((void *)(a1 + 17), &__src[v21], a2 - v21);
    *(void *)(a1 + 8) = a2 - v21;
    *(unsigned char *)(a1 + 16) = 1;
  }
  uint64_t v23 = *(void *)a1;
  memcpy((void *)(v17 + v22), &__srca, *(void *)a1 != v22);
  uint64_t v24 = *(void *)(a1 + 8);
  if (v23 != v22) {
    ++v24;
  }
  *(void *)(a1 + 8) = v24;
  if (v23 == v22)
  {
    *(unsigned char *)(a1 + 17) = a2;
    *(void *)(a1 + 8) = 1;
    *(unsigned char *)(a1 + 16) = 1;
  }
}

size_t nw_log_ring_copyout(uint64_t *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (a3)
    {
      id v4 = (char *)a1 + 17;
      *a2 = 1;
      uint64_t v5 = a2 + 1;
      unint64_t v6 = a3 - 1;
      if (a1[*((unsigned char *)a1 + 16) == 0] <= (unint64_t)(a3 - 1))
      {
        if (*((unsigned char *)a1 + 16))
        {
          uint64_t v11 = a1[1];
          size_t v12 = *a1 - v11;
          memcpy(v5, &v4[v11], v12);
        }
        else
        {
          size_t v12 = 0;
        }
        memcpy(&v5[v12], v4, a1[1]);
        size_t v8 = a1[1] + v12;
      }
      else
      {
        unint64_t v7 = a1[1];
        if (v6 >= v7) {
          size_t v8 = a1[1];
        }
        else {
          size_t v8 = a3 - 1;
        }
        memcpy(&v5[v6 - v8], &v4[v7 - v8], v8);
        if (v6 > v7 && *((unsigned char *)a1 + 16))
        {
          uint64_t v9 = *a1;
          if (v6 - v8 >= *a1 - a1[1]) {
            size_t v10 = *a1 - a1[1];
          }
          else {
            size_t v10 = v6 - v8;
          }
          memcpy(v5, &v4[v9 - v10], v10);
          v8 += v10;
        }
      }
      return v8 + 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_log_ring_copyout";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v14, &type, &v22)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_log_ring_copyout";
        uint64_t v17 = "%{public}s called with null maxLength";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (!v22)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_log_ring_copyout";
        uint64_t v17 = "%{public}s called with null maxLength, backtrace limit exceeded";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_log_ring_copyout";
        uint64_t v17 = "%{public}s called with null maxLength, no backtrace";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_log_ring_copyout";
      __int16 v26 = 2082;
      uint64_t v27 = backtrace_string;
      unint64_t v20 = "%{public}s called with null maxLength, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v25 = "nw_log_ring_copyout";
  os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (!__nwlog_fault(v14, &type, &v22)) {
    goto LABEL_46;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v22)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_log_ring_copyout";
        uint64_t v17 = "%{public}s called with null bufferOut, backtrace limit exceeded";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v19 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v25 = "nw_log_ring_copyout";
        uint64_t v17 = "%{public}s called with null bufferOut, no backtrace";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v25 = "nw_log_ring_copyout";
      __int16 v26 = 2082;
      uint64_t v27 = backtrace_string;
      unint64_t v20 = "%{public}s called with null bufferOut, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_1830D4000, v15, v16, v20, buf, 0x16u);
    }
LABEL_36:
    free(backtrace_string);
    goto LABEL_46;
  }
  os_log_type_t v15 = __nwlog_obj();
  os_log_type_t v16 = type;
  if (os_log_type_enabled(v15, type))
  {
    *(_DWORD *)buf = 136446210;
    BOOL v25 = "nw_log_ring_copyout";
    uint64_t v17 = "%{public}s called with null bufferOut";
LABEL_45:
    _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
  }
LABEL_46:
  if (v14) {
    free(v14);
  }
  return 0;
}

void nw_log_ring_parse(unsigned char *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_log_ring_parse";
    size_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_log_ring_parse";
      os_log_type_t v13 = "%{public}s called with null buffer";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v21 = "nw_log_ring_parse";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null buffer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_41:
        if (!v10) {
          return;
        }
LABEL_42:
        free(v10);
        return;
      }
      if (!v15) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_log_ring_parse";
      os_log_type_t v13 = "%{public}s called with null buffer, no backtrace";
    }
    else
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_41;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v21 = "nw_log_ring_parse";
      os_log_type_t v13 = "%{public}s called with null buffer, backtrace limit exceeded";
    }
LABEL_40:
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
    goto LABEL_41;
  }
  if (a2)
  {
    if (*a1 == 1)
    {
      unint64_t v5 = a2 - 1;
      do
      {
        if (v5 < 2) {
          break;
        }
        unint64_t v6 = a1[v5];
        BOOL v7 = v5 - 1 >= v6;
        unint64_t v5 = v5 - 1 - v6;
        if (!v7) {
          break;
        }
      }
      while (((*(uint64_t (**)(uint64_t))(a3 + 16))(a3) & 1) != 0);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v8 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v9 = *a1;
        *(_DWORD *)buf = 136446466;
        BOOL v21 = "nw_log_ring_parse";
        __int16 v22 = 1024;
        LODWORD(v23) = v9;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s Unsupported log ring version: %u", buf, 0x12u);
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v21 = "nw_log_ring_parse";
  size_t v10 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v10, &type, &v18)) {
    goto LABEL_41;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_log_ring_parse";
    os_log_type_t v13 = "%{public}s called with null length";
    goto LABEL_40;
  }
  if (!v18)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_log_ring_parse";
    os_log_type_t v13 = "%{public}s called with null length, backtrace limit exceeded";
    goto LABEL_40;
  }
  os_log_type_t v16 = (char *)__nw_create_backtrace_string();
  uint64_t v11 = __nwlog_obj();
  os_log_type_t v12 = type;
  BOOL v17 = os_log_type_enabled(v11, type);
  if (!v16)
  {
    if (!v17) {
      goto LABEL_41;
    }
    *(_DWORD *)buf = 136446210;
    BOOL v21 = "nw_log_ring_parse";
    os_log_type_t v13 = "%{public}s called with null length, no backtrace";
    goto LABEL_40;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    BOOL v21 = "nw_log_ring_parse";
    __int16 v22 = 2082;
    uint64_t v23 = v16;
    _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null length, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v16);
  if (v10) {
    goto LABEL_42;
  }
}

void sub_183C7B9A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __Block_byref_object_copy__81752(uint64_t result, uint64_t a2)
{
  *(void *)(result + 40) = *(void *)(a2 + 40);
  *(void *)(a2 + 40) = 0;
  return result;
}

void __Block_byref_object_dispose__81753(uint64_t a1)
{
}

uint64_t ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_226(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v120 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  id v7 = a4;
  identifier = nw_protocol_definition_get_identifier(v6);
  uint64_t registered_endpoint = *(void *)(a1 + 96);
  if (registered_endpoint) {
    goto LABEL_75;
  }
  id v98 = v7;
  int v10 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  uint64_t v11 = *(void **)(a1 + 40);
  os_log_type_t v12 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  os_log_type_t v13 = *(void **)(a1 + 48);
  id v14 = *(id *)(a1 + 32);
  id v97 = v11;
  id v15 = v12;
  id v16 = v13;
  __int16 v95 = v14;
  v96 = v15;
  if (!v14)
  {
    os_log_type_t v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v103 = "nw_endpoint_flow_find_protocol_to_join";
    int v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v61 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v100)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v65 = type;
      BOOL v66 = os_log_type_enabled(v60, type);
      if (backtrace_string)
      {
        if (v66)
        {
          *(_DWORD *)buf = 136446466;
          id v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_160:
        if (!v59) {
          goto LABEL_73;
        }
        goto LABEL_161;
      }
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v65, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v78 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v78, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_159:

    goto LABEL_160;
  }
  BOOL v17 = (unsigned int *)v14;
  uint64_t v18 = v17[29];

  if (v18 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (id)gLogObj;
    if (v18 > 5) {
      uint64_t v28 = "unknown-mode";
    }
    else {
      uint64_t v28 = off_1E523FB08[v18];
    }
    *(_DWORD *)buf = 136446722;
    id v103 = "nw_endpoint_flow_find_protocol_to_join";
    __int16 v104 = 2082;
    os_log_type_t v105 = (void *)v28;
    __int16 v106 = 2082;
    os_log_type_t v107 = "flow";
    id v35 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (__nwlog_fault(v35, &type, &v100))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v36 = (id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          if (v18 > 5) {
            unint64_t v38 = "unknown-mode";
          }
          else {
            unint64_t v38 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          id v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = (void *)v38;
          __int16 v106 = 2082;
          os_log_type_t v107 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v100)
      {
        __int16 v39 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v36 = (id)gLogObj;
        os_log_type_t v40 = type;
        BOOL v41 = os_log_type_enabled(v36, type);
        if (v39)
        {
          if (v41)
          {
            if (v18 > 5) {
              char v42 = "unknown-mode";
            }
            else {
              char v42 = off_1E523FB08[v18];
            }
            *(_DWORD *)buf = 136446978;
            id v103 = "nw_endpoint_flow_find_protocol_to_join";
            __int16 v104 = 2082;
            os_log_type_t v105 = (void *)v42;
            __int16 v106 = 2082;
            os_log_type_t v107 = "flow";
            __int16 v108 = 2082;
            os_log_type_t v109 = v39;
            _os_log_impl(&dword_1830D4000, v36, v40, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v39);
          if (!v35) {
            goto LABEL_73;
          }
LABEL_71:
          __int16 v46 = (char *)v35;
LABEL_72:
          free(v46);
          goto LABEL_73;
        }
        if (v41)
        {
          if (v18 > 5) {
            uint64_t v45 = "unknown-mode";
          }
          else {
            uint64_t v45 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          id v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = (void *)v45;
          __int16 v106 = 2082;
          os_log_type_t v107 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v40, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v36 = (id)gLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v36, type))
        {
          if (v18 > 5) {
            uint64_t v44 = "unknown-mode";
          }
          else {
            uint64_t v44 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          id v103 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v104 = 2082;
          os_log_type_t v105 = (void *)v44;
          __int16 v106 = 2082;
          os_log_type_t v107 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v43, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v35)
    {
LABEL_73:
      uint64_t registered_endpoint = 0;
      goto LABEL_74;
    }
    goto LABEL_71;
  }
  if (!identifier)
  {
    os_log_type_t v62 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v103 = "nw_endpoint_flow_find_protocol_to_join";
    int v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v63, "%{public}s called with null identifier", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (!v100)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v79 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v79, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_159;
    }
    os_log_type_t v71 = (char *)__nw_create_backtrace_string();
    os_log_type_t v60 = __nwlog_obj();
    os_log_type_t v72 = type;
    BOOL v73 = os_log_type_enabled(v60, type);
    if (!v71)
    {
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v72, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (v73)
    {
      *(_DWORD *)buf = 136446466;
      id v103 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v104 = 2082;
      os_log_type_t v105 = v71;
      _os_log_impl(&dword_1830D4000, v60, v72, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_126;
  }
  if (!v15)
  {
    os_log_type_t v67 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v103 = "nw_endpoint_flow_find_protocol_to_join";
    int v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v68, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (!v100)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v80, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_159;
    }
    os_log_type_t v71 = (char *)__nw_create_backtrace_string();
    os_log_type_t v60 = __nwlog_obj();
    os_log_type_t v74 = type;
    BOOL v75 = os_log_type_enabled(v60, type);
    if (!v71)
    {
      if (v75)
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v74, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (v75)
    {
      *(_DWORD *)buf = 136446466;
      id v103 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v104 = 2082;
      os_log_type_t v105 = v71;
      _os_log_impl(&dword_1830D4000, v60, v74, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_126;
  }
  if (!v16)
  {
    os_log_type_t v69 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v103 = "nw_endpoint_flow_find_protocol_to_join";
    int v59 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v59, &type, &v100)) {
      goto LABEL_160;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v70, "%{public}s called with null parameters", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (!v100)
    {
      os_log_type_t v60 = __nwlog_obj();
      os_log_type_t v81 = type;
      if (os_log_type_enabled(v60, type))
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v81, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_159;
    }
    os_log_type_t v71 = (char *)__nw_create_backtrace_string();
    os_log_type_t v60 = __nwlog_obj();
    os_log_type_t v76 = type;
    BOOL v77 = os_log_type_enabled(v60, type);
    if (!v71)
    {
      if (v77)
      {
        *(_DWORD *)buf = 136446210;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v60, v76, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_159;
    }
    if (v77)
    {
      *(_DWORD *)buf = 136446466;
      id v103 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v104 = 2082;
      os_log_type_t v105 = v71;
      _os_log_impl(&dword_1830D4000, v60, v76, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_126:

    free(v71);
    if (!v59) {
      goto LABEL_73;
    }
LABEL_161:
    __int16 v46 = (char *)v59;
    goto LABEL_72;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  BOOL v19 = &g_registration_list;
  do
  {
    BOOL v19 = (uint64_t *)*v19;
    if (!v19)
    {
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }
  while (*(void *)identifier != v19[4]
       || *((void *)identifier + 1) != v19[5]
       || *((void *)identifier + 2) != v19[6]
       || *((void *)identifier + 3) != v19[7]
       || *((void *)identifier + 4) != v19[8]);
  uint64_t v24 = v19[13];
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  if (!v24)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v29 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v17);
        long long v93 = nw_endpoint_handler_dry_run_string(v17);
        nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v17);
        logging_description = nw_endpoint_get_logging_description(v31);
        id v32 = nw_endpoint_handler_state_string(v17);
        char v33 = nw_endpoint_handler_mode_string(v17);
        id v34 = nw_endpoint_handler_copy_current_path(v17);
        *(_DWORD *)buf = 136448258;
        id v103 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v104 = 2082;
        os_log_type_t v105 = (void *)id_string;
        __int16 v106 = 2082;
        os_log_type_t v107 = v93;
        __int16 v108 = 2082;
        os_log_type_t v109 = (void *)logging_description;
        __int16 v110 = 2082;
        os_log_type_t v111 = v32;
        __int16 v112 = 2082;
        os_log_type_t v113 = v33;
        __int16 v114 = 2114;
        id v115 = v34;
        __int16 v116 = 2080;
        v117 = identifier;
        __int16 v118 = 2048;
        uint64_t v119 = (uint64_t)identifier;
        _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x5Cu);
      }
    }
    goto LABEL_73;
  }
  id v25 = v15;
  __int16 v26 = v25;
  while (1)
  {
    uint64_t registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join((uint64_t)identifier, -1, v97, v26, v25, v16, v10 != 0);
    if (registered_endpoint) {
      break;
    }
    uint64_t registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v26, v10 != 0);

    __int16 v26 = (void *)registered_endpoint;
    if (!registered_endpoint) {
      goto LABEL_53;
    }
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v82 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
    {
      v94 = nw_endpoint_handler_get_id_string(v17);
      os_log_type_t v92 = nw_endpoint_handler_dry_run_string(v17);
      nw_endpoint_t v83 = nw_endpoint_handler_copy_endpoint(v17);
      os_log_type_t v90 = nw_endpoint_get_logging_description(v83);
      os_log_type_t v89 = nw_endpoint_handler_state_string(v17);
      v84 = nw_endpoint_handler_mode_string(v17);
      id v85 = nw_endpoint_handler_copy_current_path(v17);
      id v86 = v85;
      id v103 = "nw_endpoint_flow_find_protocol_to_join";
      os_log_type_t v87 = "invalid";
      os_log_type_t v88 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v88) {
        os_log_type_t v87 = v88;
      }
      __int16 v104 = 2082;
      os_log_type_t v105 = (void *)v94;
      __int16 v106 = 2082;
      os_log_type_t v107 = v92;
      __int16 v108 = 2082;
      os_log_type_t v109 = (void *)v90;
      __int16 v110 = 2082;
      os_log_type_t v111 = v89;
      __int16 v112 = 2082;
      os_log_type_t v113 = v84;
      __int16 v114 = 2114;
      id v115 = v85;
      __int16 v116 = 2080;
      v117 = (void *)v87;
      __int16 v118 = 2048;
      uint64_t v119 = registered_endpoint;
      _os_log_impl(&dword_1830D4000, v82, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)", buf, 0x5Cu);
    }
  }
LABEL_53:

LABEL_74:
  id v7 = v98;
  if (registered_endpoint)
  {
LABEL_75:
    if (nw_endpoint_flow_join_protocol(*(void **)(a1 + 32), *(void **)(a1 + 48), v7, v6, identifier, -1, registered_endpoint, *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24), *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), (unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)))
    {
      uint64_t v47 = 0;
      *(unsigned char *)(*(void *)(a1 + 56) + 33) |= 1u;
      goto LABEL_85;
    }
  }
  uint64_t v48 = nw_endpoint_flow_add_one_protocol(*(void **)(a1 + 32), (long long *)identifier, v7, v6, *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40), *(void **)(a1 + 48), *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24));
  if (v48)
  {
    *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = v48;
    if (nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)))
    {
      uint64_t v47 = 1;
    }
    else
    {
      id v99 = v7;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v49 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
      {
        float32x2x2_t v50 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        int v51 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        nw_endpoint_t v52 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        os_log_type_t v53 = nw_endpoint_get_logging_description(v52);
        int v54 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        int v55 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v56 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        *(_DWORD *)buf = 136448002;
        id v103 = "nw_endpoint_flow_attach_protocols_block_invoke";
        __int16 v104 = 2082;
        os_log_type_t v105 = (void *)v50;
        __int16 v106 = 2082;
        os_log_type_t v107 = v51;
        __int16 v108 = 2082;
        os_log_type_t v109 = (void *)v53;
        __int16 v110 = 2082;
        os_log_type_t v111 = v54;
        __int16 v112 = 2082;
        os_log_type_t v113 = v55;
        __int16 v114 = 2114;
        id v115 = v56;
        __int16 v116 = 2082;
        v117 = identifier;
        _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached link-layer protocol: %{public}s", buf, 0x52u);
      }
      uint64_t v47 = 1;
      id v7 = v99;
    }
  }
  else
  {
    uint64_t v47 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24) = 1;
  }
LABEL_85:

  return v47;
}

void sub_183C7CF00(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_81876()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

void nw_endpoint_handler_register_adaptive_read_handler(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    os_log_type_t v65 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    BOOL v66 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v89) = 0;
    if (__nwlog_fault(v66, type, &v89))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v68 = type[0];
        if (os_log_type_enabled(v67, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v89)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v70 = type[0];
        BOOL v71 = os_log_type_enabled(v67, type[0]);
        if (backtrace_string)
        {
          if (v71)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            __int16 v93 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_1830D4000, v67, v70, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_98;
        }
        if (v71)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v67, v70, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v72 = type[0];
        if (os_log_type_enabled(v67, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v67, v72, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_98:
    if (v66) {
      free(v66);
    }
    unsigned int mode = 0;
    goto LABEL_101;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    id v4 = nw_endpoint_handler_copy_flow(v2);
    unint64_t v5 = v4;
    if (*((void *)v4 + 127))
    {
      int v6 = *((_DWORD *)v4 + 252);
      if (!v6) {
        int v6 = 5;
      }
      int v89 = v6;
      id v7 = (void *)*((void *)v4 + 51);
      if (!v7) {
        goto LABEL_30;
      }
      uint64_t v8 = v7[3];
      if (!v8) {
        goto LABEL_30;
      }
      int v9 = *(uint64_t (**)(void))(v8 + 144);
      if (!v9) {
        goto LABEL_30;
      }
      int v10 = (void *)v7[5];
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = v7[11];
        if (v17) {
          v7[11] = v17 + 1;
        }
        char v11 = -1;
      }
      else
      {
        char v11 = 0;
      }
      *(void *)buf = v7;
      buf[8] = v11;
      uint64_t v18 = (void *)*((void *)v5 + 52);
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v20 = *((void *)v5 + 58);
        if (v20) {
          *((void *)v5 + 58) = v20 + 1;
        }
        char v19 = -1;
      }
      else
      {
        char v19 = 0;
      }
      *(void *)os_log_type_t type = (char *)v5 + 376;
      char v91 = v19;
      char v21 = v9();
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_26:
          if (v21) {
            goto LABEL_81;
          }
LABEL_30:
          __int16 v22 = v2;
          BOOL v23 = (*((unsigned char *)v22 + 268) & 0x20) == 0;

          if (v23)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v24 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              id v25 = v22;

              __int16 v26 = v25;
              BOOL v27 = (*((unsigned char *)v22 + 268) & 1) == 0;

              if (v27) {
                uint64_t v28 = "";
              }
              else {
                uint64_t v28 = "dry-run ";
              }
              nw_endpoint_t v29 = nw_endpoint_handler_copy_endpoint(v26);
              logging_description = nw_endpoint_get_logging_description(v29);
              nw_endpoint_t v31 = v26;
              id v32 = v31;
              uint64_t v33 = v31[30];
              if (v33 > 5) {
                id v34 = "unknown-state";
              }
              else {
                id v34 = off_1E523FB38[v33];
              }
              os_log_type_t v87 = v34;

              id v35 = v32;
              id v36 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  id v36 = "resolver";
                  break;
                case 2:
                  id v36 = nw_endpoint_flow_mode_string(v35[31]);
                  break;
                case 3:
                  id v36 = "proxy";
                  break;
                case 4:
                  id v36 = "fallback";
                  break;
                case 5:
                  id v36 = "transform";
                  break;
                default:
                  id v36 = "unknown-mode";
                  break;
              }
              id v86 = v36;

              BOOL v57 = v35;
              os_log_type_t v58 = v25;
              os_unfair_lock_lock((os_unfair_lock_t)v57 + 28);
              id v59 = v57[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v57 + 28);

              id v60 = v59;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
              __int16 v93 = 2082;
              id_str = v58->id_str;
              __int16 v95 = 2082;
              v96 = v28;
              __int16 v97 = 2082;
              id v98 = (void *)logging_description;
              __int16 v99 = 2082;
              char v100 = v87;
              __int16 v101 = 2082;
              id v102 = v86;
              __int16 v103 = 2114;
              id v104 = v60;
              __int16 v105 = 2082;
              __int16 v106 = "read_timeout";
              _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification for %{public}s failed", buf, 0x52u);
            }
LABEL_80:

            goto LABEL_81;
          }
          goto LABEL_81;
        }
      }
      else if (v10 != &nw_protocol_ref_counted_handle)
      {
        goto LABEL_26;
      }
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      if (v21) {
        goto LABEL_81;
      }
      goto LABEL_30;
    }
    os_log_type_t v12 = (void *)*((void *)v4 + 51);
    if (!v12 || (uint64_t v13 = v12[3]) == 0 || (v14 = *(uint64_t (**)(void))(v13 + 152)) == 0)
    {
LABEL_56:
      char v42 = v2;
      BOOL v43 = (*((unsigned char *)v42 + 268) & 0x20) == 0;

      if (v43)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v24 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v44 = v42;

          uint64_t v45 = v44;
          BOOL v46 = (*((unsigned char *)v42 + 268) & 1) == 0;

          if (v46) {
            uint64_t v47 = "";
          }
          else {
            uint64_t v47 = "dry-run ";
          }
          nw_endpoint_t v48 = nw_endpoint_handler_copy_endpoint(v45);
          BOOL v49 = nw_endpoint_get_logging_description(v48);
          float32x2x2_t v50 = v45;
          int v51 = v50;
          uint64_t v52 = v50[30];
          if (v52 > 5) {
            os_log_type_t v53 = "unknown-state";
          }
          else {
            os_log_type_t v53 = off_1E523FB38[v52];
          }
          os_log_type_t v88 = v53;

          int v54 = v51;
          int v55 = v54;
          id v56 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              id v56 = "resolver";
              break;
            case 2:
              id v56 = nw_endpoint_flow_mode_string(v54[31]);
              break;
            case 3:
              id v56 = "proxy";
              break;
            case 4:
              id v56 = "fallback";
              break;
            case 5:
              id v56 = "transform";
              break;
            default:
              id v56 = "unknown-mode";
              break;
          }

          os_log_type_t v61 = v55;
          os_unfair_lock_lock((os_unfair_lock_t)v61 + 28);
          id v62 = v61[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v61 + 28);

          os_log_type_t v63 = v44->id_str;
          id v64 = v62;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
          __int16 v93 = 2082;
          id_str = v63;
          __int16 v95 = 2082;
          v96 = v47;
          __int16 v97 = 2082;
          id v98 = (void *)v49;
          __int16 v99 = 2082;
          char v100 = v88;
          __int16 v101 = 2082;
          id v102 = v56;
          __int16 v103 = 2114;
          id v104 = v64;
          __int16 v105 = 2082;
          __int16 v106 = "read_timeout";
          _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unregister notification for %{public}s failed", buf, 0x52u);
        }
        goto LABEL_80;
      }
LABEL_81:

      goto LABEL_122;
    }
    id v15 = (void *)v12[5];
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v37 = v12[11];
      if (v37) {
        v12[11] = v37 + 1;
      }
      char v16 = -1;
    }
    else
    {
      char v16 = 0;
    }
    *(void *)buf = v12;
    buf[8] = v16;
    unint64_t v38 = (void *)*((void *)v5 + 52);
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v40 = *((void *)v5 + 58);
      if (v40) {
        *((void *)v5 + 58) = v40 + 1;
      }
      char v39 = -1;
    }
    else
    {
      char v39 = 0;
    }
    *(void *)os_log_type_t type = (char *)v5 + 376;
    char v91 = v39;
    char v41 = v14();
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v15 != &nw_protocol_ref_counted_handle)
      {
LABEL_52:
        if (v41) {
          goto LABEL_81;
        }
        goto LABEL_56;
      }
    }
    else if (v15 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_52;
    }
    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if (v41) {
      goto LABEL_81;
    }
    goto LABEL_56;
  }
LABEL_101:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v73 = (id)gLogObj;
  if (mode > 5) {
    os_log_type_t v74 = "unknown-mode";
  }
  else {
    os_log_type_t v74 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
  __int16 v93 = 2082;
  id_str = (void *)v74;
  __int16 v95 = 2082;
  v96 = "flow";
  BOOL v75 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v89) = 0;
  if (!__nwlog_fault((const char *)v75, type, &v89))
  {
LABEL_120:
    if (!v75) {
      goto LABEL_122;
    }
LABEL_121:
    free(v75);
    goto LABEL_122;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v76 = (id)gLogObj;
    os_log_type_t v77 = type[0];
    if (os_log_type_enabled(v76, type[0]))
    {
      if (mode > 5) {
        os_log_type_t v78 = "unknown-mode";
      }
      else {
        os_log_type_t v78 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
      __int16 v93 = 2082;
      id_str = (void *)v78;
      __int16 v95 = 2082;
      v96 = "flow";
      _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_119:

    goto LABEL_120;
  }
  if (!(_BYTE)v89)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v76 = (id)gLogObj;
    os_log_type_t v83 = type[0];
    if (os_log_type_enabled(v76, type[0]))
    {
      if (mode > 5) {
        v84 = "unknown-mode";
      }
      else {
        v84 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
      __int16 v93 = 2082;
      id_str = (void *)v84;
      __int16 v95 = 2082;
      v96 = "flow";
      _os_log_impl(&dword_1830D4000, v76, v83, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_119;
  }
  os_log_type_t v79 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v76 = (id)gLogObj;
  os_log_type_t v80 = type[0];
  BOOL v81 = os_log_type_enabled(v76, type[0]);
  if (!v79)
  {
    if (v81)
    {
      if (mode > 5) {
        id v85 = "unknown-mode";
      }
      else {
        id v85 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
      __int16 v93 = 2082;
      id_str = (void *)v85;
      __int16 v95 = 2082;
      v96 = "flow";
      _os_log_impl(&dword_1830D4000, v76, v80, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_119;
  }
  if (v81)
  {
    if (mode > 5) {
      os_log_type_t v82 = "unknown-mode";
    }
    else {
      os_log_type_t v82 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_read_handler";
    __int16 v93 = 2082;
    id_str = (void *)v82;
    __int16 v95 = 2082;
    v96 = "flow";
    __int16 v97 = 2082;
    id v98 = v79;
    _os_log_impl(&dword_1830D4000, v76, v80, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v79);
  if (v75) {
    goto LABEL_121;
  }
LABEL_122:
}

void sub_183C7DC50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_register_adaptive_write_handler(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v107 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    os_log_type_t v65 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    BOOL v66 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v89) = 0;
    if (__nwlog_fault(v66, type, &v89))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v68 = type[0];
        if (os_log_type_enabled(v67, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if ((_BYTE)v89)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v70 = type[0];
        BOOL v71 = os_log_type_enabled(v67, type[0]);
        if (backtrace_string)
        {
          if (v71)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            __int16 v93 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_1830D4000, v67, v70, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_98;
        }
        if (v71)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v67, v70, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v67 = __nwlog_obj();
        os_log_type_t v72 = type[0];
        if (os_log_type_enabled(v67, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v67, v72, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_98:
    if (v66) {
      free(v66);
    }
    unsigned int mode = 0;
    goto LABEL_101;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    id v4 = nw_endpoint_handler_copy_flow(v2);
    unint64_t v5 = v4;
    if (*((void *)v4 + 128))
    {
      int v6 = *((_DWORD *)v4 + 253);
      if (!v6) {
        int v6 = 5;
      }
      int v89 = v6;
      id v7 = (void *)*((void *)v4 + 51);
      if (!v7) {
        goto LABEL_30;
      }
      uint64_t v8 = v7[3];
      if (!v8) {
        goto LABEL_30;
      }
      int v9 = *(uint64_t (**)(void))(v8 + 144);
      if (!v9) {
        goto LABEL_30;
      }
      int v10 = (void *)v7[5];
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = v7[11];
        if (v17) {
          v7[11] = v17 + 1;
        }
        char v11 = -1;
      }
      else
      {
        char v11 = 0;
      }
      *(void *)buf = v7;
      buf[8] = v11;
      uint64_t v18 = (void *)*((void *)v5 + 52);
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v20 = *((void *)v5 + 58);
        if (v20) {
          *((void *)v5 + 58) = v20 + 1;
        }
        char v19 = -1;
      }
      else
      {
        char v19 = 0;
      }
      *(void *)os_log_type_t type = (char *)v5 + 376;
      char v91 = v19;
      char v21 = v9();
      if (v18 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v10 != &nw_protocol_ref_counted_handle)
        {
LABEL_26:
          if (v21) {
            goto LABEL_81;
          }
LABEL_30:
          __int16 v22 = v2;
          BOOL v23 = (*((unsigned char *)v22 + 268) & 0x20) == 0;

          if (v23)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v24 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
            {
              id v25 = v22;

              __int16 v26 = v25;
              BOOL v27 = (*((unsigned char *)v22 + 268) & 1) == 0;

              if (v27) {
                uint64_t v28 = "";
              }
              else {
                uint64_t v28 = "dry-run ";
              }
              nw_endpoint_t v29 = nw_endpoint_handler_copy_endpoint(v26);
              logging_description = nw_endpoint_get_logging_description(v29);
              nw_endpoint_t v31 = v26;
              id v32 = v31;
              uint64_t v33 = v31[30];
              if (v33 > 5) {
                id v34 = "unknown-state";
              }
              else {
                id v34 = off_1E523FB38[v33];
              }
              os_log_type_t v87 = v34;

              id v35 = v32;
              id v36 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  id v36 = "resolver";
                  break;
                case 2:
                  id v36 = nw_endpoint_flow_mode_string(v35[31]);
                  break;
                case 3:
                  id v36 = "proxy";
                  break;
                case 4:
                  id v36 = "fallback";
                  break;
                case 5:
                  id v36 = "transform";
                  break;
                default:
                  id v36 = "unknown-mode";
                  break;
              }
              id v86 = v36;

              BOOL v57 = v35;
              os_log_type_t v58 = v25;
              os_unfair_lock_lock((os_unfair_lock_t)v57 + 28);
              id v59 = v57[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v57 + 28);

              id v60 = v59;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
              __int16 v93 = 2082;
              id_str = v58->id_str;
              __int16 v95 = 2082;
              v96 = v28;
              __int16 v97 = 2082;
              id v98 = (void *)logging_description;
              __int16 v99 = 2082;
              char v100 = v87;
              __int16 v101 = 2082;
              id v102 = v86;
              __int16 v103 = 2114;
              id v104 = v60;
              __int16 v105 = 2082;
              __int16 v106 = "write_timeout";
              _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification for %{public}s failed", buf, 0x52u);
            }
LABEL_80:

            goto LABEL_81;
          }
          goto LABEL_81;
        }
      }
      else if (v10 != &nw_protocol_ref_counted_handle)
      {
        goto LABEL_26;
      }
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      if (v21) {
        goto LABEL_81;
      }
      goto LABEL_30;
    }
    os_log_type_t v12 = (void *)*((void *)v4 + 51);
    if (!v12 || (uint64_t v13 = v12[3]) == 0 || (v14 = *(uint64_t (**)(void))(v13 + 152)) == 0)
    {
LABEL_56:
      char v42 = v2;
      BOOL v43 = (*((unsigned char *)v42 + 268) & 0x20) == 0;

      if (v43)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v24 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v44 = v42;

          uint64_t v45 = v44;
          BOOL v46 = (*((unsigned char *)v42 + 268) & 1) == 0;

          if (v46) {
            uint64_t v47 = "";
          }
          else {
            uint64_t v47 = "dry-run ";
          }
          nw_endpoint_t v48 = nw_endpoint_handler_copy_endpoint(v45);
          BOOL v49 = nw_endpoint_get_logging_description(v48);
          float32x2x2_t v50 = v45;
          int v51 = v50;
          uint64_t v52 = v50[30];
          if (v52 > 5) {
            os_log_type_t v53 = "unknown-state";
          }
          else {
            os_log_type_t v53 = off_1E523FB38[v52];
          }
          os_log_type_t v88 = v53;

          int v54 = v51;
          int v55 = v54;
          id v56 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              id v56 = "resolver";
              break;
            case 2:
              id v56 = nw_endpoint_flow_mode_string(v54[31]);
              break;
            case 3:
              id v56 = "proxy";
              break;
            case 4:
              id v56 = "fallback";
              break;
            case 5:
              id v56 = "transform";
              break;
            default:
              id v56 = "unknown-mode";
              break;
          }

          os_log_type_t v61 = v55;
          os_unfair_lock_lock((os_unfair_lock_t)v61 + 28);
          id v62 = v61[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v61 + 28);

          os_log_type_t v63 = v44->id_str;
          id v64 = v62;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
          __int16 v93 = 2082;
          id_str = v63;
          __int16 v95 = 2082;
          v96 = v47;
          __int16 v97 = 2082;
          id v98 = (void *)v49;
          __int16 v99 = 2082;
          char v100 = v88;
          __int16 v101 = 2082;
          id v102 = v56;
          __int16 v103 = 2114;
          id v104 = v64;
          __int16 v105 = 2082;
          __int16 v106 = "write_timeout";
          _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unregister notification for %{public}s failed", buf, 0x52u);
        }
        goto LABEL_80;
      }
LABEL_81:

      goto LABEL_122;
    }
    id v15 = (void *)v12[5];
    if (v15 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v37 = v12[11];
      if (v37) {
        v12[11] = v37 + 1;
      }
      char v16 = -1;
    }
    else
    {
      char v16 = 0;
    }
    *(void *)buf = v12;
    buf[8] = v16;
    unint64_t v38 = (void *)*((void *)v5 + 52);
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v40 = *((void *)v5 + 58);
      if (v40) {
        *((void *)v5 + 58) = v40 + 1;
      }
      char v39 = -1;
    }
    else
    {
      char v39 = 0;
    }
    *(void *)os_log_type_t type = (char *)v5 + 376;
    char v91 = v39;
    char v41 = v14();
    if (v38 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v15 != &nw_protocol_ref_counted_handle)
      {
LABEL_52:
        if (v41) {
          goto LABEL_81;
        }
        goto LABEL_56;
      }
    }
    else if (v15 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_52;
    }
    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if (v41) {
      goto LABEL_81;
    }
    goto LABEL_56;
  }
LABEL_101:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v73 = (id)gLogObj;
  if (mode > 5) {
    os_log_type_t v74 = "unknown-mode";
  }
  else {
    os_log_type_t v74 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
  __int16 v93 = 2082;
  id_str = (void *)v74;
  __int16 v95 = 2082;
  v96 = "flow";
  BOOL v75 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v89) = 0;
  if (!__nwlog_fault((const char *)v75, type, &v89))
  {
LABEL_120:
    if (!v75) {
      goto LABEL_122;
    }
LABEL_121:
    free(v75);
    goto LABEL_122;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v76 = (id)gLogObj;
    os_log_type_t v77 = type[0];
    if (os_log_type_enabled(v76, type[0]))
    {
      if (mode > 5) {
        os_log_type_t v78 = "unknown-mode";
      }
      else {
        os_log_type_t v78 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
      __int16 v93 = 2082;
      id_str = (void *)v78;
      __int16 v95 = 2082;
      v96 = "flow";
      _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_119:

    goto LABEL_120;
  }
  if (!(_BYTE)v89)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v76 = (id)gLogObj;
    os_log_type_t v83 = type[0];
    if (os_log_type_enabled(v76, type[0]))
    {
      if (mode > 5) {
        v84 = "unknown-mode";
      }
      else {
        v84 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
      __int16 v93 = 2082;
      id_str = (void *)v84;
      __int16 v95 = 2082;
      v96 = "flow";
      _os_log_impl(&dword_1830D4000, v76, v83, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_119;
  }
  os_log_type_t v79 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v76 = (id)gLogObj;
  os_log_type_t v80 = type[0];
  BOOL v81 = os_log_type_enabled(v76, type[0]);
  if (!v79)
  {
    if (v81)
    {
      if (mode > 5) {
        id v85 = "unknown-mode";
      }
      else {
        id v85 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
      __int16 v93 = 2082;
      id_str = (void *)v85;
      __int16 v95 = 2082;
      v96 = "flow";
      _os_log_impl(&dword_1830D4000, v76, v80, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_119;
  }
  if (v81)
  {
    if (mode > 5) {
      os_log_type_t v82 = "unknown-mode";
    }
    else {
      os_log_type_t v82 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_adaptive_write_handler";
    __int16 v93 = 2082;
    id_str = (void *)v82;
    __int16 v95 = 2082;
    v96 = "flow";
    __int16 v97 = 2082;
    id v98 = v79;
    _os_log_impl(&dword_1830D4000, v76, v80, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v79);
  if (v75) {
    goto LABEL_121;
  }
LABEL_122:
}

void sub_183C7E998(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_register_keepalive_handler(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    id v62 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    os_log_type_t v63 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (__nwlog_fault(v63, type, &v88))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v64 = __nwlog_obj();
        os_log_type_t v65 = type[0];
        if (os_log_type_enabled(v64, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v88)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v64 = __nwlog_obj();
        os_log_type_t v67 = type[0];
        BOOL v68 = os_log_type_enabled(v64, type[0]);
        if (backtrace_string)
        {
          if (v68)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            __int16 v90 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_1830D4000, v64, v67, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_96;
        }
        if (v68)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v64, v67, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v64 = __nwlog_obj();
        os_log_type_t v69 = type[0];
        if (os_log_type_enabled(v64, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v64, v69, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_96:
    if (v63) {
      free(v63);
    }
    unsigned int mode = 0;
    goto LABEL_99;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    id v4 = nw_endpoint_handler_copy_flow(v2);
    unint64_t v5 = (void *)*((void *)v4 + 51);
    if (*((void *)v4 + 129))
    {
      if (!v5) {
        goto LABEL_28;
      }
      uint64_t v6 = v5[3];
      if (!v6) {
        goto LABEL_28;
      }
      id v7 = *(uint64_t (**)(void))(v6 + 144);
      if (!v7) {
        goto LABEL_28;
      }
      uint64_t v8 = (void *)v5[5];
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = v5[11];
        if (v14) {
          v5[11] = v14 + 1;
        }
        char v9 = -1;
      }
      else
      {
        char v9 = 0;
      }
      *(void *)buf = v5;
      buf[8] = v9;
      id v15 = (void *)*((void *)v4 + 52);
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = *((void *)v4 + 58);
        if (v17) {
          *((void *)v4 + 58) = v17 + 1;
        }
        char v16 = -1;
      }
      else
      {
        char v16 = 0;
      }
      *(void *)os_log_type_t type = (char *)v4 + 376;
      char v87 = v16;
      char v18 = v7();
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v8 != &nw_protocol_ref_counted_handle)
        {
LABEL_24:
          if (v18) {
            goto LABEL_79;
          }
LABEL_28:
          char v19 = v2;
          BOOL v20 = (*((unsigned char *)v19 + 268) & 0x20) == 0;

          if (v20)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            char v21 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              __int16 v22 = v19;

              BOOL v23 = v22;
              BOOL v24 = (*((unsigned char *)v19 + 268) & 1) == 0;

              if (v24) {
                id v25 = "";
              }
              else {
                id v25 = "dry-run ";
              }
              nw_endpoint_t v26 = nw_endpoint_handler_copy_endpoint(v23);
              logging_description = nw_endpoint_get_logging_description(v26);
              uint64_t v28 = v23;
              nw_endpoint_t v29 = v28;
              uint64_t v30 = v28[30];
              if (v30 > 5) {
                nw_endpoint_t v31 = "unknown-state";
              }
              else {
                nw_endpoint_t v31 = off_1E523FB38[v30];
              }
              v84 = v31;

              id v32 = v29;
              uint64_t v33 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  uint64_t v33 = "resolver";
                  break;
                case 2:
                  uint64_t v33 = nw_endpoint_flow_mode_string(v32[31]);
                  break;
                case 3:
                  uint64_t v33 = "proxy";
                  break;
                case 4:
                  uint64_t v33 = "fallback";
                  break;
                case 5:
                  uint64_t v33 = "transform";
                  break;
                default:
                  uint64_t v33 = "unknown-mode";
                  break;
              }
              os_log_type_t v83 = v33;

              int v54 = v32;
              int v55 = v22;
              os_unfair_lock_lock((os_unfair_lock_t)v54 + 28);
              id v56 = v54[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v54 + 28);

              id v57 = v56;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
              __int16 v90 = 2082;
              id_str = v55->id_str;
              __int16 v92 = 2082;
              __int16 v93 = v25;
              __int16 v94 = 2082;
              __int16 v95 = (void *)logging_description;
              __int16 v96 = 2082;
              __int16 v97 = v84;
              __int16 v98 = 2082;
              __int16 v99 = v83;
              __int16 v100 = 2114;
              id v101 = v57;
              __int16 v102 = 2082;
              __int16 v103 = "keepalive";
              _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification for %{public}s failed", buf, 0x52u);
            }
LABEL_78:

            goto LABEL_79;
          }
          goto LABEL_79;
        }
      }
      else if (v8 != &nw_protocol_ref_counted_handle)
      {
        goto LABEL_24;
      }
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      if (v18) {
        goto LABEL_79;
      }
      goto LABEL_28;
    }
    if (!v5 || (uint64_t v10 = v5[3]) == 0 || (v11 = *(uint64_t (**)(void))(v10 + 152)) == 0)
    {
LABEL_54:
      char v39 = v2;
      BOOL v40 = (*((unsigned char *)v39 + 268) & 0x20) == 0;

      if (v40)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v21 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          char v41 = v39;

          char v42 = v41;
          BOOL v43 = (*((unsigned char *)v39 + 268) & 1) == 0;

          if (v43) {
            uint64_t v44 = "";
          }
          else {
            uint64_t v44 = "dry-run ";
          }
          nw_endpoint_t v45 = nw_endpoint_handler_copy_endpoint(v42);
          BOOL v46 = nw_endpoint_get_logging_description(v45);
          uint64_t v47 = v42;
          nw_endpoint_t v48 = v47;
          uint64_t v49 = v47[30];
          if (v49 > 5) {
            float32x2x2_t v50 = "unknown-state";
          }
          else {
            float32x2x2_t v50 = off_1E523FB38[v49];
          }
          id v85 = v50;

          int v51 = v48;
          uint64_t v52 = v51;
          os_log_type_t v53 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v53 = "resolver";
              break;
            case 2:
              os_log_type_t v53 = nw_endpoint_flow_mode_string(v51[31]);
              break;
            case 3:
              os_log_type_t v53 = "proxy";
              break;
            case 4:
              os_log_type_t v53 = "fallback";
              break;
            case 5:
              os_log_type_t v53 = "transform";
              break;
            default:
              os_log_type_t v53 = "unknown-mode";
              break;
          }

          os_log_type_t v58 = v52;
          os_unfair_lock_lock((os_unfair_lock_t)v58 + 28);
          id v59 = v58[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v58 + 28);

          id v60 = v41->id_str;
          id v61 = v59;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
          __int16 v90 = 2082;
          id_str = v60;
          __int16 v92 = 2082;
          __int16 v93 = v44;
          __int16 v94 = 2082;
          __int16 v95 = (void *)v46;
          __int16 v96 = 2082;
          __int16 v97 = v85;
          __int16 v98 = 2082;
          __int16 v99 = v53;
          __int16 v100 = 2114;
          id v101 = v61;
          __int16 v102 = 2082;
          __int16 v103 = "keepalive";
          _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unregister notification for %{public}s failed", buf, 0x52u);
        }
        goto LABEL_78;
      }
LABEL_79:

      goto LABEL_120;
    }
    os_log_type_t v12 = (void *)v5[5];
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v34 = v5[11];
      if (v34) {
        v5[11] = v34 + 1;
      }
      char v13 = -1;
    }
    else
    {
      char v13 = 0;
    }
    *(void *)buf = v5;
    buf[8] = v13;
    id v35 = (void *)*((void *)v4 + 52);
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v37 = *((void *)v4 + 58);
      if (v37) {
        *((void *)v4 + 58) = v37 + 1;
      }
      char v36 = -1;
    }
    else
    {
      char v36 = 0;
    }
    *(void *)os_log_type_t type = (char *)v4 + 376;
    char v87 = v36;
    char v38 = v11();
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v12 != &nw_protocol_ref_counted_handle)
      {
LABEL_50:
        if (v38) {
          goto LABEL_79;
        }
        goto LABEL_54;
      }
    }
    else if (v12 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_50;
    }
    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if (v38) {
      goto LABEL_79;
    }
    goto LABEL_54;
  }
LABEL_99:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v70 = (id)gLogObj;
  if (mode > 5) {
    BOOL v71 = "unknown-mode";
  }
  else {
    BOOL v71 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
  __int16 v90 = 2082;
  id_str = (void *)v71;
  __int16 v92 = 2082;
  __int16 v93 = "flow";
  os_log_type_t v72 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v88 = 0;
  if (!__nwlog_fault((const char *)v72, type, &v88))
  {
LABEL_118:
    if (!v72) {
      goto LABEL_120;
    }
LABEL_119:
    free(v72);
    goto LABEL_120;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v73 = (id)gLogObj;
    os_log_type_t v74 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        BOOL v75 = "unknown-mode";
      }
      else {
        BOOL v75 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
      __int16 v90 = 2082;
      id_str = (void *)v75;
      __int16 v92 = 2082;
      __int16 v93 = "flow";
      _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_117:

    goto LABEL_118;
  }
  if (!v88)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v73 = (id)gLogObj;
    os_log_type_t v80 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        BOOL v81 = "unknown-mode";
      }
      else {
        BOOL v81 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
      __int16 v90 = 2082;
      id_str = (void *)v81;
      __int16 v92 = 2082;
      __int16 v93 = "flow";
      _os_log_impl(&dword_1830D4000, v73, v80, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_117;
  }
  os_log_type_t v76 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v73 = (id)gLogObj;
  os_log_type_t v77 = type[0];
  BOOL v78 = os_log_type_enabled(v73, type[0]);
  if (!v76)
  {
    if (v78)
    {
      if (mode > 5) {
        os_log_type_t v82 = "unknown-mode";
      }
      else {
        os_log_type_t v82 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
      __int16 v90 = 2082;
      id_str = (void *)v82;
      __int16 v92 = 2082;
      __int16 v93 = "flow";
      _os_log_impl(&dword_1830D4000, v73, v77, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_117;
  }
  if (v78)
  {
    if (mode > 5) {
      os_log_type_t v79 = "unknown-mode";
    }
    else {
      os_log_type_t v79 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_keepalive_handler";
    __int16 v90 = 2082;
    id_str = (void *)v79;
    __int16 v92 = 2082;
    __int16 v93 = "flow";
    __int16 v94 = 2082;
    __int16 v95 = v76;
    _os_log_impl(&dword_1830D4000, v73, v77, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v76);
  if (v72) {
    goto LABEL_119;
  }
LABEL_120:
}

void sub_183C7F6C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_flow_reset_expected_progress_target_block_invoke(uint64_t a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!setsockopt(a2, 6, 537, (const void *)(a1 + 32), 8u)) {
    return 1;
  }
  int v2 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v3 = (id)gLogObj;
  id v4 = v3;
  if (v2 != 22)
  {
    *(_DWORD *)buf = 136446466;
    char v18 = "nw_endpoint_flow_reset_expected_progress_target_block_invoke";
    __int16 v19 = 1024;
    int v20 = v2;
    unint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446466;
        char v18 = "nw_endpoint_flow_reset_expected_progress_target_block_invoke";
        __int16 v19 = 1024;
        int v20 = v2;
        uint64_t v8 = "%{public}s setsockopt MPTCP_EXPECTED_PROGRESS_TARGET failed %{darwin.errno}d";
LABEL_20:
        char v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_21;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_22;
        }
        *(_DWORD *)buf = 136446466;
        char v18 = "nw_endpoint_flow_reset_expected_progress_target_block_invoke";
        __int16 v19 = 1024;
        int v20 = v2;
        uint64_t v8 = "%{public}s setsockopt MPTCP_EXPECTED_PROGRESS_TARGET failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_20;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = (id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_22:

          if (!v5) {
            return 1;
          }
          goto LABEL_16;
        }
        *(_DWORD *)buf = 136446466;
        char v18 = "nw_endpoint_flow_reset_expected_progress_target_block_invoke";
        __int16 v19 = 1024;
        int v20 = v2;
        uint64_t v8 = "%{public}s setsockopt MPTCP_EXPECTED_PROGRESS_TARGET failed %{darwin.errno}d, no backtrace";
        char v13 = v6;
        os_log_type_t v14 = v10;
LABEL_21:
        _os_log_impl(&dword_1830D4000, v13, v14, v8, buf, 0x12u);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446722;
        char v18 = "nw_endpoint_flow_reset_expected_progress_target_block_invoke";
        __int16 v19 = 1024;
        int v20 = v2;
        __int16 v21 = 2082;
        __int16 v22 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s setsockopt MPTCP_EXPECTED_PROGRESS_TARGET failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
    }
    if (!v5) {
      return 1;
    }
LABEL_16:
    free(v5);
    return 1;
  }
  if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    char v18 = "nw_endpoint_flow_reset_expected_progress_target_block_invoke";
    __int16 v19 = 1024;
    int v20 = 22;
    _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s setsockopt MPTCP_EXPECTED_PROGRESS_TARGET failed %{darwin.errno}d", buf, 0x12u);
  }

  return 1;
}

uint64_t ___ZL36nw_endpoint_flow_validate_delegationP30NWConcrete_nw_endpoint_handler_block_invoke_218(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  if (object_getClass(v4) != (Class)MEMORY[0x1E4F145F0]
    || (string_ptr = xpc_string_get_string_ptr(v4),
        size_t length = xpc_string_get_length(v4),
        size_t v7 = *(void *)(a1 + 48),
        BOOL v8 = v7 >= length,
        size_t v9 = v7 - length,
        !v8))
  {
LABEL_11:
    uint64_t v21 = 1;
    goto LABEL_12;
  }
  int v10 = strcmp(string_ptr, (const char *)(*(void *)(a1 + 56) + v9));
  char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32));
  if (v10)
  {
    if ((logging_disabled & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v12 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
        os_log_type_t v14 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
        char v15 = id_string;
        nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
        logging_description = nw_endpoint_get_logging_description(v32);
        uint64_t v17 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
        char v18 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
        id v19 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
        uint64_t v20 = *(void *)(a1 + 56);
        *(_DWORD *)buf = 136448258;
        id v35 = "nw_endpoint_flow_validate_delegation_block_invoke";
        __int16 v36 = 2082;
        uint64_t v37 = v15;
        __int16 v38 = 2082;
        char v39 = v14;
        __int16 v40 = 2082;
        char v41 = logging_description;
        __int16 v42 = 2082;
        BOOL v43 = v17;
        __int16 v44 = 2082;
        nw_endpoint_t v45 = v18;
        __int16 v46 = 2114;
        id v47 = v19;
        __int16 v48 = 2082;
        uint64_t v49 = v20;
        __int16 v50 = 2082;
        int v51 = string_ptr;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Domain \"%{public}s\" does not match %{public}s", buf, 0x5Cu);
      }
    }
    goto LABEL_11;
  }
  if ((logging_disabled & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v23 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
    {
      BOOL v24 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
      id v25 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
      nw_endpoint_t v26 = v24;
      nw_endpoint_t v33 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
      BOOL v27 = nw_endpoint_get_logging_description(v33);
      uint64_t v28 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
      nw_endpoint_t v29 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
      id v30 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
      uint64_t v31 = *(void *)(a1 + 56);
      *(_DWORD *)buf = 136448258;
      id v35 = "nw_endpoint_flow_validate_delegation_block_invoke";
      __int16 v36 = 2082;
      uint64_t v37 = v26;
      __int16 v38 = 2082;
      char v39 = v25;
      __int16 v40 = 2082;
      char v41 = v27;
      __int16 v42 = 2082;
      BOOL v43 = v28;
      __int16 v44 = 2082;
      nw_endpoint_t v45 = v29;
      __int16 v46 = 2114;
      id v47 = v30;
      __int16 v48 = 2082;
      uint64_t v49 = v31;
      __int16 v50 = 2082;
      int v51 = string_ptr;
      _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Domain \"%{public}s\" matches %{public}s", buf, 0x5Cu);
    }
  }
  uint64_t v21 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
LABEL_12:

  return v21;
}

void sub_183C7FF6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_access_parent_flow_handler(void *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v4)
  {
    unint64_t v5 = (id *)v3;
    if (v5)
    {
      uint64_t v6 = v5;
      size_t v7 = v5[9];

      if (v7)
      {
        while (1)
        {
          size_t v7 = v7;
          int v8 = v7[29];

          if (v8 == 2) {
            break;
          }
          size_t v9 = v7;
          size_t v7 = v9[9];

          if (!v7) {
            goto LABEL_8;
          }
        }
        v4[2](v4, v7);
      }
      goto LABEL_8;
    }
    os_log_type_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v29 = "nw_endpoint_handler_copy_parent";
    char v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v15, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v29 = "nw_endpoint_handler_copy_parent";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v16 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            nw_endpoint_t v29 = "nw_endpoint_handler_copy_parent";
            __int16 v30 = 2082;
            uint64_t v31 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v29 = "nw_endpoint_handler_copy_parent";
          _os_log_impl(&dword_1830D4000, v16, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v16 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          nw_endpoint_t v29 = "nw_endpoint_handler_copy_parent";
          _os_log_impl(&dword_1830D4000, v16, v25, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_44:
    if (v15) {
      free(v15);
    }
    size_t v7 = 0;
LABEL_8:

    goto LABEL_9;
  }
  int v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  nw_endpoint_t v29 = "nw_endpoint_handler_access_parent_flow_handler";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v11, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v29 = "nw_endpoint_handler_access_parent_flow_handler";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null accessor", buf, 0xCu);
      }
    }
    else if (v26)
    {
      char v18 = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v29 = "nw_endpoint_handler_access_parent_flow_handler";
          __int16 v30 = 2082;
          uint64_t v31 = v18;
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null accessor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        goto LABEL_39;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v29 = "nw_endpoint_handler_access_parent_flow_handler";
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null accessor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v29 = "nw_endpoint_handler_access_parent_flow_handler";
        _os_log_impl(&dword_1830D4000, v12, v24, "%{public}s called with null accessor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_39:
  if (v11) {
    free(v11);
  }
LABEL_9:
}

void sub_183C804D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_has_connected_flow(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    size_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "nw_endpoint_handler_has_connected_flow";
    int v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        size_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_endpoint_handler_has_connected_flow";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        size_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v19 = "nw_endpoint_handler_has_connected_flow";
            __int16 v20 = 2082;
            uint64_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_endpoint_handler_has_connected_flow";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        size_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_endpoint_handler_has_connected_flow";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v8) {
      free(v8);
    }
    goto LABEL_25;
  }
  id v3 = (NWConcrete_nw_endpoint_handler *)v1;
  int mode = v3->mode;

  if (mode != 2)
  {
LABEL_25:
    BOOL v6 = 0;
    goto LABEL_26;
  }
  unint64_t v5 = nw_endpoint_handler_copy_flow(v3);
  BOOL v6 = (*((_DWORD *)v5 + 225) & 0x80000000) == 0 || *((void *)v5 + 113) != 0;

LABEL_26:
  return v6;
}

void sub_183C807C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_connected_socket_wrapper(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0 || (v2[8]._os_unfair_lock_opaque & 0x100) != 0)
    {
      id v4 = *(id *)&v2[222]._os_unfair_lock_opaque;
    }
    else
    {
      id v3 = *(void **)&v2[234]._os_unfair_lock_opaque;
      if (!v3)
      {
        id v5 = 0;
        goto LABEL_8;
      }
      id v4 = (id)nw_endpoint_handler_copy_connected_socket_wrapper(v3);
    }
    id v5 = v4;
LABEL_8:
    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_9;
  }
  size_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v18 = "nw_endpoint_flow_copy_connected_socket_wrapper";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_endpoint_flow_copy_connected_socket_wrapper";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          char v18 = "nw_endpoint_flow_copy_connected_socket_wrapper";
          __int16 v19 = 2082;
          __int16 v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_endpoint_flow_copy_connected_socket_wrapper";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      size_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_endpoint_flow_copy_connected_socket_wrapper";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v8) {
    free(v8);
  }
  id v5 = 0;
LABEL_9:

  return v5;
}

void sub_183C80AAC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_endpoint_flow_fillout_tcp_connection_info_block_invoke(uint64_t a1, int a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  socklen_t v17 = 112;
  int v2 = getsockopt(a2, 6, 262, *(void **)(a1 + 32), &v17);
  if (v2)
  {
    int v3 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    __int16 v19 = "nw_endpoint_flow_fillout_tcp_connection_info_block_invoke";
    __int16 v20 = 1024;
    int v21 = v3;
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v5, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "nw_endpoint_flow_fillout_tcp_connection_info_block_invoke";
        __int16 v20 = 1024;
        int v21 = v3;
        int v8 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d";
LABEL_16:
        BOOL v13 = v6;
        os_log_type_t v14 = v7;
        goto LABEL_17;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (!os_log_type_enabled(v6, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "nw_endpoint_flow_fillout_tcp_connection_info_block_invoke";
        __int16 v20 = 1024;
        int v21 = v3;
        int v8 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_16;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v6 = (id)gLogObj;
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (!backtrace_string)
      {
        if (!v11)
        {
LABEL_18:

          if (!v5) {
            return v2 == 0;
          }
          goto LABEL_12;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v19 = "nw_endpoint_flow_fillout_tcp_connection_info_block_invoke";
        __int16 v20 = 1024;
        int v21 = v3;
        int v8 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, no backtrace";
        BOOL v13 = v6;
        os_log_type_t v14 = v10;
LABEL_17:
        _os_log_impl(&dword_1830D4000, v13, v14, v8, buf, 0x12u);
        goto LABEL_18;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446722;
        __int16 v19 = "nw_endpoint_flow_fillout_tcp_connection_info_block_invoke";
        __int16 v20 = 1024;
        int v21 = v3;
        __int16 v22 = 2082;
        BOOL v23 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }

      free(backtrace_string);
    }
    if (v5) {
LABEL_12:
    }
      free(v5);
  }
  return v2 == 0;
}

void *nw_endpoint_handler_copy_connected_parameters_with_protocol(void *a1, void *a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    nw_endpoint_t v33 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
    socklen_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v17, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          _os_log_impl(&dword_1830D4000, v18, v34, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v18 = __nwlog_obj();
        os_log_type_t v36 = type;
        BOOL v37 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
            __int16 v43 = 2082;
            __int16 v44 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v18, v36, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v17) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        if (v37)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          _os_log_impl(&dword_1830D4000, v18, v36, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v18 = __nwlog_obj();
        os_log_type_t v38 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          _os_log_impl(&dword_1830D4000, v18, v38, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_48;
    }
LABEL_49:
    if (!v17)
    {
LABEL_51:
      os_log_type_t v14 = 0;
      goto LABEL_52;
    }
LABEL_50:
    free(v17);
    goto LABEL_51;
  }
  id v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    if (mode > 5) {
      char v16 = "unknown-mode";
    }
    else {
      char v16 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
    __int16 v43 = 2082;
    __int16 v44 = (void *)v16;
    __int16 v45 = 2082;
    __int16 v46 = "flow";
    socklen_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v17, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          if (mode > 5) {
            __int16 v20 = "unknown-mode";
          }
          else {
            __int16 v20 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          __int16 v43 = 2082;
          __int16 v44 = (void *)v20;
          __int16 v45 = 2082;
          __int16 v46 = "flow";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v39)
      {
        int v21 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (id)gLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v18, type);
        if (v21)
        {
          if (v23)
          {
            if (mode > 5) {
              uint64_t v24 = "unknown-mode";
            }
            else {
              uint64_t v24 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
            __int16 v43 = 2082;
            __int16 v44 = (void *)v24;
            __int16 v45 = 2082;
            __int16 v46 = "flow";
            __int16 v47 = 2082;
            __int16 v48 = v21;
            _os_log_impl(&dword_1830D4000, v18, v22, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v21);
          if (!v17) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        if (v23)
        {
          if (mode > 5) {
            uint64_t v31 = "unknown-mode";
          }
          else {
            uint64_t v31 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          __int16 v43 = 2082;
          __int16 v44 = (void *)v31;
          __int16 v45 = 2082;
          __int16 v46 = "flow";
          _os_log_impl(&dword_1830D4000, v18, v22, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v18, type))
        {
          if (mode > 5) {
            __int16 v30 = "unknown-mode";
          }
          else {
            __int16 v30 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          __int16 v42 = "nw_endpoint_handler_copy_connected_parameters_with_protocol";
          __int16 v43 = 2082;
          __int16 v44 = (void *)v30;
          __int16 v45 = 2082;
          __int16 v46 = "flow";
          _os_log_impl(&dword_1830D4000, v18, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
LABEL_48:

      goto LABEL_49;
    }
    goto LABEL_49;
  }
  os_log_type_t v7 = nw_endpoint_handler_copy_flow(v5);
  os_unfair_lock_lock((os_unfair_lock_t)v7 + 220);
  identifier = nw_protocol_definition_get_identifier(v4);
  size_t v9 = (void *)*((void *)v7 + 1);
  if (v9)
  {
    os_log_type_t v10 = v9;
    id v11 = v10[2];

    if (nw_parameters_has_protocol_in_stack(v11, identifier))
    {
      id v12 = v11;
      BOOL v13 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v12, 0, 0);

      os_log_type_t v14 = (void *)v13;
    }
    else
    {
      os_log_type_t v14 = 0;
    }

    os_log_type_t v25 = (void *)*((void *)v7 + 69);
    if (v25)
    {
LABEL_23:
      if (nw_parameters_has_protocol_in_stack(v25, identifier))
      {
        id v26 = *((id *)v7 + 69);
        BOOL v27 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v26, 0, 0);

        os_log_type_t v14 = (void *)v27;
      }
    }
  }
  else
  {
    os_log_type_t v14 = 0;
    os_log_type_t v25 = (void *)*((void *)v7 + 69);
    if (v25) {
      goto LABEL_23;
    }
  }
  if (!v14)
  {
    uint64_t v28 = *((void *)v7 + 117);
    if (v28) {
      os_log_type_t v14 = (void *)nw_endpoint_handler_copy_connected_parameters_with_protocol(v28, v4);
    }
    else {
      os_log_type_t v14 = 0;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v7 + 220);

LABEL_52:
  return v14;
}

void sub_183C8156C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_handler *nw_endpoint_handler_copy_top_protocol_flow_handler(void *a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    os_log_type_t v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
          __int16 v32 = 2082;
          nw_endpoint_t v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_42;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_41:

    goto LABEL_42;
  }
  id v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    if (mode > 5) {
      size_t v9 = "unknown-mode";
    }
    else {
      size_t v9 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
    __int16 v32 = 2082;
    nw_endpoint_t v33 = (void *)v9;
    __int16 v34 = 2082;
    id v35 = "flow";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v10, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5) {
            BOOL v13 = "unknown-mode";
          }
          else {
            BOOL v13 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
          __int16 v32 = 2082;
          nw_endpoint_t v33 = (void *)v13;
          __int16 v34 = 2082;
          id v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v28)
      {
        os_log_type_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            if (mode > 5) {
              socklen_t v17 = "unknown-mode";
            }
            else {
              socklen_t v17 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
            __int16 v32 = 2082;
            nw_endpoint_t v33 = (void *)v17;
            __int16 v34 = 2082;
            id v35 = "flow";
            __int16 v36 = 2082;
            BOOL v37 = v14;
            _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v14);
          if (!v10) {
            goto LABEL_44;
          }
          goto LABEL_43;
        }
        if (v16)
        {
          if (mode > 5) {
            __int16 v20 = "unknown-mode";
          }
          else {
            __int16 v20 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
          __int16 v32 = 2082;
          nw_endpoint_t v33 = (void *)v20;
          __int16 v34 = 2082;
          id v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5) {
            os_log_type_t v19 = "unknown-mode";
          }
          else {
            os_log_type_t v19 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v31 = "nw_endpoint_handler_copy_top_protocol_flow_handler";
          __int16 v32 = 2082;
          nw_endpoint_t v33 = (void *)v19;
          __int16 v34 = 2082;
          id v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_41;
    }
LABEL_42:
    if (!v10)
    {
LABEL_44:
      os_log_type_t v7 = 0;
      goto LABEL_45;
    }
LABEL_43:
    free(v10);
    goto LABEL_44;
  }
  id v5 = nw_endpoint_handler_copy_flow(v3);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
  if (*((void *)v5 + 117)
    && (*((unsigned char *)v5 + 32) & 2) == 0
    && (*((unsigned char *)v5 + 33) & 1) == 0
    && *((NWConcrete_nw_endpoint_mode_handler **)v5 + 94) == (NWConcrete_nw_endpoint_mode_handler *)((char *)v5 + 376))
  {
    BOOL v6 = (NWConcrete_nw_endpoint_handler *)nw_endpoint_handler_copy_top_protocol_flow_handler();
  }
  else
  {
    BOOL v6 = v3;
  }
  os_log_type_t v7 = v6;
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

LABEL_45:
  return v7;
}

void sub_183C81C40(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_modify_protocol_stack(void *a1, void *a2)
{
  uint64_t v395 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v367 = a2;
  v364 = v3;
  if (!v3)
  {
    v314 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v378 = "nw_endpoint_handler_modify_protocol_stack";
    v174 = (char *)_os_log_send_and_compose_impl();

    v375[0] = OS_LOG_TYPE_ERROR;
    v373[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v174, v375, v373))
    {
      if (v375[0] == OS_LOG_TYPE_FAULT)
      {
        v175 = __nwlog_obj();
        os_log_type_t v315 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_1830D4000, v175, v315, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_477;
      }
      if (v373[0] == OS_LOG_TYPE_DEFAULT)
      {
        v175 = __nwlog_obj();
        os_log_type_t v327 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_1830D4000, v175, v327, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_477;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v175 = __nwlog_obj();
      os_log_type_t v319 = v375[0];
      BOOL v320 = os_log_type_enabled(v175, v375[0]);
      if (!backtrace_string)
      {
        if (v320)
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_1830D4000, v175, v319, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_477;
      }
      if (v320)
      {
        *(_DWORD *)buf = 136446466;
        v378 = "nw_endpoint_handler_modify_protocol_stack";
        __int16 v379 = 2082;
        v380 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v175, v319, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_628;
    }
LABEL_478:
    if (!v174) {
      goto LABEL_480;
    }
LABEL_479:
    free(v174);
    goto LABEL_480;
  }
  id v4 = (unsigned int *)v3;
  uint64_t v5 = v4[29];

  if (v5 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v172 = (id)gLogObj;
    if (v5 > 5) {
      v173 = "unknown-mode";
    }
    else {
      v173 = off_1E523FB08[v5];
    }
    *(_DWORD *)buf = 136446722;
    v378 = "nw_endpoint_handler_modify_protocol_stack";
    __int16 v379 = 2082;
    v380 = (char *)v173;
    __int16 v381 = 2082;
    v382 = "flow";
    v174 = (char *)_os_log_send_and_compose_impl();

    v375[0] = OS_LOG_TYPE_ERROR;
    v373[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v174, v375, v373))
    {
      if (v375[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v175 = (id)gLogObj;
        os_log_type_t v176 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          if (v5 > 5) {
            v177 = "unknown-mode";
          }
          else {
            v177 = off_1E523FB08[v5];
          }
          *(_DWORD *)buf = 136446722;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          __int16 v379 = 2082;
          v380 = (char *)v177;
          __int16 v381 = 2082;
          v382 = "flow";
          _os_log_impl(&dword_1830D4000, v175, v176, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v373[0])
      {
        v178 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v175 = (id)gLogObj;
        os_log_type_t v179 = v375[0];
        BOOL v180 = os_log_type_enabled(v175, v375[0]);
        if (v178)
        {
          if (v180)
          {
            if (v5 > 5) {
              v181 = "unknown-mode";
            }
            else {
              v181 = off_1E523FB08[v5];
            }
            *(_DWORD *)buf = 136446978;
            v378 = "nw_endpoint_handler_modify_protocol_stack";
            __int16 v379 = 2082;
            v380 = (char *)v181;
            __int16 v381 = 2082;
            v382 = "flow";
            __int16 v383 = 2082;
            v384 = v178;
            _os_log_impl(&dword_1830D4000, v175, v179, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v178);
          if (!v174) {
            goto LABEL_480;
          }
          goto LABEL_479;
        }
        if (v180)
        {
          if (v5 > 5) {
            v184 = "unknown-mode";
          }
          else {
            v184 = off_1E523FB08[v5];
          }
          *(_DWORD *)buf = 136446722;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          __int16 v379 = 2082;
          v380 = (char *)v184;
          __int16 v381 = 2082;
          v382 = "flow";
          _os_log_impl(&dword_1830D4000, v175, v179, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        v175 = (id)gLogObj;
        os_log_type_t v182 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          if (v5 > 5) {
            v183 = "unknown-mode";
          }
          else {
            v183 = off_1E523FB08[v5];
          }
          *(_DWORD *)buf = 136446722;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          __int16 v379 = 2082;
          v380 = (char *)v183;
          __int16 v381 = 2082;
          v382 = "flow";
          _os_log_impl(&dword_1830D4000, v175, v182, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_477;
    }
    goto LABEL_478;
  }
  if (!v367)
  {
    v316 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v378 = "nw_endpoint_handler_modify_protocol_stack";
    v174 = (char *)_os_log_send_and_compose_impl();

    v375[0] = OS_LOG_TYPE_ERROR;
    v373[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v174, v375, v373))
    {
      if (v375[0] == OS_LOG_TYPE_FAULT)
      {
        v175 = __nwlog_obj();
        os_log_type_t v317 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_1830D4000, v175, v317, "%{public}s called with null modifier", buf, 0xCu);
        }
LABEL_477:

        goto LABEL_478;
      }
      if (v373[0] == OS_LOG_TYPE_DEFAULT)
      {
        v175 = __nwlog_obj();
        os_log_type_t v335 = v375[0];
        if (os_log_type_enabled(v175, v375[0]))
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_1830D4000, v175, v335, "%{public}s called with null modifier, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_477;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v175 = __nwlog_obj();
      os_log_type_t v325 = v375[0];
      BOOL v326 = os_log_type_enabled(v175, v375[0]);
      if (!backtrace_string)
      {
        if (v326)
        {
          *(_DWORD *)buf = 136446210;
          v378 = "nw_endpoint_handler_modify_protocol_stack";
          _os_log_impl(&dword_1830D4000, v175, v325, "%{public}s called with null modifier, no backtrace", buf, 0xCu);
        }
        goto LABEL_477;
      }
      if (v326)
      {
        *(_DWORD *)buf = 136446466;
        v378 = "nw_endpoint_handler_modify_protocol_stack";
        __int16 v379 = 2082;
        v380 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v175, v325, "%{public}s called with null modifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_628:

      free(backtrace_string);
      if (!v174) {
        goto LABEL_480;
      }
      goto LABEL_479;
    }
    goto LABEL_478;
  }
  BOOL v6 = v4;
  int state = v6->state;

  if ((state & 0xFFFFFFFE) == 4)
  {
LABEL_480:
    uint64_t v196 = 0;
    goto LABEL_603;
  }
  v356 = v6;
  id v8 = nw_endpoint_handler_copy_flow(v6);
  size_t v9 = v6;
  id v361 = v9[4];
  v362 = v9;

  uint64_t v10 = *((void *)v8 + 51);
  v357 = v8;
  if (!v10) {
    goto LABEL_456;
  }
  char v11 = 0;
  unsigned int log = 0;
  uint64_t v359 = (uint64_t)v8 + 376;
  while (2)
  {
    int v368 = 0;
    os_log_type_t v12 = *(_DWORD **)(v10 + 16);
    BOOL v13 = (*((void (**)(id, void, _DWORD *, int *))v367 + 2))(v367, log, v12, &v368);
    os_log_type_t v14 = v13;
    if (v13)
    {
      os_log_type_t v15 = v13;
      BOOL v16 = v15 + 1;
      id v17 = v15[1];

      identifier = nw_protocol_definition_get_identifier(v17);
      os_log_type_t v19 = v15;
      id v20 = *v16;
    }
    else
    {
      id v20 = 0;
      identifier = 0;
    }
    uint64_t v21 = *(void *)(v10 + 32);
    switch(v368)
    {
      case 0:
        ++log;
        uint64_t v359 = v10;
        goto LABEL_218;
      case 1:
        if ((v12[9] & 0xFFFFFFFE) == 2)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v214 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
            {
              loga = v214;
              id_string = nw_endpoint_handler_get_id_string(v362);
              v230 = nw_endpoint_handler_dry_run_string(v362);
              nw_endpoint_t v231 = nw_endpoint_handler_copy_endpoint(v362);
              logging_description = nw_endpoint_get_logging_description(v231);
              v233 = nw_endpoint_handler_state_string(v362);
              v234 = nw_endpoint_handler_mode_string(v362);
              id v235 = nw_endpoint_handler_copy_current_path(v362);
              *(_DWORD *)buf = 136448002;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              __int16 v379 = 2082;
              v380 = (char *)id_string;
              __int16 v381 = 2082;
              v382 = v230;
              __int16 v383 = 2082;
              v384 = (void *)logging_description;
              __int16 v385 = 2082;
              v386 = v233;
              __int16 v387 = 2082;
              v388 = v234;
              __int16 v389 = 2114;
              id v390 = v235;
              __int16 v391 = 2082;
              v392 = v12;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Can only replace one-to-one protocols, (%{public}s is not one-to-one)", buf, 0x52u);

              goto LABEL_599;
            }
            goto LABEL_600;
          }
          goto LABEL_601;
        }
        if (identifier)
        {
          nw_endpoint_t v29 = nw_endpoint_handler_copy_endpoint(v362);
          uint64_t protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition((uint64_t)identifier, v20, v29, v361);

          if (!protocol_for_definition)
          {
            if (nw_endpoint_handler_get_logging_disabled(v362)) {
              goto LABEL_601;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v214 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
              goto LABEL_600;
            }
LABEL_541:
            loga = v214;
            v256 = nw_endpoint_handler_get_id_string(v362);
            v257 = nw_endpoint_handler_dry_run_string(v362);
            nw_endpoint_t v258 = nw_endpoint_handler_copy_endpoint(v362);
            v259 = nw_endpoint_get_logging_description(v258);
            v260 = nw_endpoint_handler_state_string(v362);
            v261 = nw_endpoint_handler_mode_string(v362);
            id v262 = nw_endpoint_handler_copy_current_path(v362);
            *(_DWORD *)buf = 136448002;
            v378 = "nw_endpoint_handler_modify_protocol_stack";
            __int16 v379 = 2082;
            v380 = (char *)v256;
            __int16 v381 = 2082;
            v382 = v257;
            __int16 v383 = 2082;
            v384 = (void *)v259;
            __int16 v385 = 2082;
            v386 = v260;
            __int16 v387 = 2082;
            v388 = v261;
            __int16 v389 = 2114;
            id v390 = v262;
            __int16 v391 = 2082;
            v392 = identifier;
            _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create protocol %{public}s", buf, 0x52u);

            goto LABEL_599;
          }
          nw_parameters_add_protocol_stack_member(v361, 4, 0xFFFFFFFF, v14);
          nw_endpoint_handler_set_protocol_instance(v362, v14, v20, protocol_for_definition);
          if (!v21)
          {
            v328 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v378 = "__nw_protocol_replace_input_handler";
            v329 = (char *)_os_log_send_and_compose_impl();

            v375[0] = OS_LOG_TYPE_ERROR;
            v373[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v329, v375, v373))
            {
              if (v375[0] == OS_LOG_TYPE_FAULT)
              {
                v330 = __nwlog_obj();
                os_log_type_t v331 = v375[0];
                if (os_log_type_enabled(v330, v375[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v378 = "__nw_protocol_replace_input_handler";
                  _os_log_impl(&dword_1830D4000, v330, v331, "%{public}s called with null protocol", buf, 0xCu);
                }
                goto LABEL_671;
              }
              if (v373[0])
              {
                v336 = (char *)__nw_create_backtrace_string();
                v330 = __nwlog_obj();
                os_log_type_t v337 = v375[0];
                BOOL v338 = os_log_type_enabled(v330, v375[0]);
                if (v336)
                {
                  if (v338)
                  {
                    *(_DWORD *)buf = 136446466;
                    v378 = "__nw_protocol_replace_input_handler";
                    __int16 v379 = 2082;
                    v380 = v336;
                    _os_log_impl(&dword_1830D4000, v330, v337, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v336);
                  goto LABEL_672;
                }
                if (v338)
                {
                  *(_DWORD *)buf = 136446210;
                  v378 = "__nw_protocol_replace_input_handler";
                  _os_log_impl(&dword_1830D4000, v330, v337, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                v330 = __nwlog_obj();
                os_log_type_t v340 = v375[0];
                if (os_log_type_enabled(v330, v375[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v378 = "__nw_protocol_replace_input_handler";
                  _os_log_impl(&dword_1830D4000, v330, v340, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
                }
              }
LABEL_671:
            }
LABEL_672:
            if (v329) {
              free(v329);
            }
LABEL_674:
            if (nw_endpoint_handler_get_logging_disabled(v362)) {
              goto LABEL_601;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v214 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
              goto LABEL_600;
            }
LABEL_546:
            loga = v214;
            v263 = nw_endpoint_handler_get_id_string(v362);
            v264 = nw_endpoint_handler_dry_run_string(v362);
            nw_endpoint_t v360 = nw_endpoint_handler_copy_endpoint(v362);
            v265 = nw_endpoint_get_logging_description(v360);
            v266 = nw_endpoint_handler_state_string(v362);
            v267 = nw_endpoint_handler_mode_string(v362);
            id v268 = nw_endpoint_handler_copy_current_path(v362);
            *(_DWORD *)buf = 136448258;
            v378 = "nw_endpoint_handler_modify_protocol_stack";
            __int16 v379 = 2082;
            v380 = (char *)v263;
            __int16 v381 = 2082;
            v382 = v264;
            __int16 v383 = 2082;
            v384 = (void *)v265;
            __int16 v385 = 2082;
            v386 = v266;
            __int16 v387 = 2082;
            v388 = v267;
            __int16 v389 = 2114;
            id v390 = v268;
            __int16 v391 = 2082;
            v392 = v12;
            __int16 v393 = 2082;
            v394 = identifier;
            _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to replace protocol %{public}s with %{public}s", buf, 0x5Cu);

            goto LABEL_599;
          }
          if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v43 = *(void *)(v21 + 88);
            if (v43) {
              *(void *)(v21 + 88) = v43 + 1;
            }
            *(void *)v375 = v21;
            char v31 = v376 | 1;
          }
          else
          {
            *(void *)v375 = v21;
            char v31 = v376 & 0xFE;
          }
          char v376 = v31;
          if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v45 = *(void *)(v10 + 88);
            if (v45) {
              *(void *)(v10 + 88) = v45 + 1;
            }
            *(void *)v373 = v10;
            char v44 = v374 | 1;
          }
          else
          {
            *(void *)v373 = v10;
            char v44 = v374 & 0xFE;
          }
          char v374 = v44;
          if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v47 = *(void *)(protocol_for_definition + 88);
            if (v47) {
              *(void *)(protocol_for_definition + 88) = v47 + 1;
            }
            *(void *)v370 = protocol_for_definition;
            char v46 = v371 | 1;
          }
          else
          {
            *(void *)v370 = protocol_for_definition;
            char v46 = v371 & 0xFE;
          }
          char v371 = v46;
          uint64_t v48 = *(void *)(v21 + 24);
          if (v48)
          {
            uint64_t v49 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v48 + 16);
            if (v49)
            {
              char v50 = v49(v21, v10, protocol_for_definition);
              if ((v371 & 1) == 0) {
                goto LABEL_87;
              }
              goto LABEL_86;
            }
          }
          __int16 v105 = __nwlog_obj();
          __int16 v106 = *(const char **)(v21 + 16);
          if (!v106) {
            __int16 v106 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v378 = "__nw_protocol_replace_input_handler";
          __int16 v379 = 2082;
          v380 = (char *)v106;
          __int16 v381 = 2048;
          v382 = (const char *)v21;
          v351 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v369 = 0;
          uint64_t v107 = (char *)v351;
          if (!__nwlog_fault(v351, &type, &v369))
          {
LABEL_338:
            if (v107) {
              free(v107);
            }
            char v50 = 0;
            if ((v46 & 1) == 0)
            {
LABEL_87:
              if (v374)
              {
                nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
                if ((v376 & 1) == 0)
                {
LABEL_89:
                  if ((v50 & 1) == 0) {
                    goto LABEL_674;
                  }
LABEL_93:
                  uint64_t v51 = *(void *)(v359 + 32);
                  BOOL v52 = v51 == v10 || v51 == 0;
                  char v11 = 1;
                  if (!v52 || v51 == protocol_for_definition) {
                    goto LABEL_102;
                  }
                  if (v51)
                  {
                    if (*(_UNKNOWN **)(v51 + 40) == &nw_protocol_ref_counted_handle)
                    {
                      uint64_t v82 = *(void *)(v51 + 88);
                      if (v82)
                      {
                        uint64_t v83 = v82 - 1;
                        *(void *)(v51 + 88) = v83;
                        if (!v83)
                        {
                          v84 = *(void (***)(void))(v51 + 64);
                          if (v84)
                          {
                            *(void *)(v51 + 64) = 0;
                            v84[2](v84);
                            _Block_release(v84);
                          }
                          if (*(unsigned char *)(v51 + 72))
                          {
                            id v85 = *(const void **)(v51 + 64);
                            if (v85) {
                              _Block_release(v85);
                            }
                          }
                          free((void *)v51);
                        }
                      }
                    }
                  }
                  *(void *)(v359 + 32) = protocol_for_definition;
                  if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle
                    && (uint64_t v65 = *(void *)(protocol_for_definition + 88)) != 0)
                  {
                    *(void *)(protocol_for_definition + 88) = v65 + 1;
                    uint64_t v10 = protocol_for_definition;
                  }
                  else
                  {
LABEL_102:
                    uint64_t v10 = protocol_for_definition;
                  }
                  goto LABEL_219;
                }
              }
              else if ((v376 & 1) == 0)
              {
                goto LABEL_89;
              }
              nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
              if ((v50 & 1) == 0) {
                goto LABEL_674;
              }
              goto LABEL_93;
            }
LABEL_86:
            nw::release_if_needed<nw_protocol *>((uint64_t *)v370);
            goto LABEL_87;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            __int16 v108 = __nwlog_obj();
            os_log_type_t v343 = type;
            if (os_log_type_enabled(v108, type))
            {
              os_log_type_t v109 = *(const char **)(v21 + 16);
              if (!v109) {
                os_log_type_t v109 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v378 = "__nw_protocol_replace_input_handler";
              __int16 v379 = 2082;
              v380 = (char *)v109;
              __int16 v381 = 2048;
              v382 = (const char *)v21;
              _os_log_impl(&dword_1830D4000, v108, v343, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback", buf, 0x20u);
            }
          }
          else
          {
            if (v369)
            {
              uint64_t v119 = (char *)__nw_create_backtrace_string();
              v345 = __nwlog_obj();
              os_log_type_t v341 = type;
              BOOL v120 = os_log_type_enabled(v345, type);
              if (v119)
              {
                if (v120)
                {
                  BOOL v121 = *(const char **)(v21 + 16);
                  if (!v121) {
                    BOOL v121 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  v378 = "__nw_protocol_replace_input_handler";
                  __int16 v379 = 2082;
                  v380 = (char *)v121;
                  __int16 v381 = 2048;
                  v382 = (const char *)v21;
                  __int16 v383 = 2082;
                  v384 = v119;
                  _os_log_impl(&dword_1830D4000, v345, v341, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                free(v119);
              }
              else
              {
                if (v120)
                {
                  v150 = *(const char **)(v21 + 16);
                  if (!v150) {
                    v150 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v378 = "__nw_protocol_replace_input_handler";
                  __int16 v379 = 2082;
                  v380 = (char *)v150;
                  __int16 v381 = 2048;
                  v382 = (const char *)v21;
                  _os_log_impl(&dword_1830D4000, v345, v341, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace", buf, 0x20u);
                }
              }
              goto LABEL_337;
            }
            __int16 v108 = __nwlog_obj();
            os_log_type_t v347 = type;
            if (os_log_type_enabled(v108, type))
            {
              v147 = *(const char **)(v21 + 16);
              if (!v147) {
                v147 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              v378 = "__nw_protocol_replace_input_handler";
              __int16 v379 = 2082;
              v380 = (char *)v147;
              __int16 v381 = 2048;
              v382 = (const char *)v21;
              _os_log_impl(&dword_1830D4000, v108, v347, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded", buf, 0x20u);
            }
          }

LABEL_337:
          uint64_t v107 = (char *)v351;
          goto LABEL_338;
        }
        if (!v21)
        {
          if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v86 = *(void *)(v10 + 88);
            if (v86) {
              *(void *)(v10 + 88) = v86 + 1;
            }
            *(void *)v375 = v10;
            char v64 = v376 | 1;
          }
          else
          {
            *(void *)v375 = v10;
            char v64 = v376 & 0xFE;
          }
          char v376 = v64;
          if (v359)
          {
            if (*(_UNKNOWN **)(v359 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v88 = *(void *)(v359 + 88);
              if (v88) {
                *(void *)(v359 + 88) = v88 + 1;
              }
              *(void *)v373 = v359;
              char v87 = v374 | 1;
            }
            else
            {
              *(void *)v373 = v359;
              char v87 = v374 & 0xFE;
            }
            char v374 = v87;
            uint64_t v89 = *(void *)(v10 + 24);
            if (v89)
            {
              __int16 v90 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v89 + 8);
              if (v90)
              {
                char v91 = v90(v10, v359, 1);
                if (v374) {
                  goto LABEL_202;
                }
                goto LABEL_203;
              }
            }
            v133 = __nwlog_obj();
            v134 = *(const char **)(v10 + 16);
            if (!v134) {
              v134 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_remove_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v134;
            __int16 v381 = 2048;
            v382 = (const char *)v10;
            id v135 = (char *)_os_log_send_and_compose_impl();

            v370[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v135, v370, &type))
            {
              if (v370[0] == OS_LOG_TYPE_FAULT)
              {
                v136 = __nwlog_obj();
                os_log_type_t v137 = v370[0];
                if (os_log_type_enabled(v136, v370[0]))
                {
                  char v138 = *(const char **)(v10 + 16);
                  if (!v138) {
                    char v138 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v378 = "__nw_protocol_remove_input_handler";
                  __int16 v379 = 2082;
                  v380 = (char *)v138;
                  __int16 v381 = 2048;
                  v382 = (const char *)v10;
                  _os_log_impl(&dword_1830D4000, v136, v137, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback", buf, 0x20u);
                }
                goto LABEL_300;
              }
              if (type)
              {
                v155 = (char *)__nw_create_backtrace_string();
                v156 = __nwlog_obj();
                os_log_type_t v355 = v370[0];
                BOOL v157 = os_log_type_enabled(v156, v370[0]);
                if (v155)
                {
                  if (v157)
                  {
                    v158 = *(const char **)(v10 + 16);
                    if (!v158) {
                      v158 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    v378 = "__nw_protocol_remove_input_handler";
                    __int16 v379 = 2082;
                    v380 = (char *)v158;
                    __int16 v381 = 2048;
                    v382 = (const char *)v10;
                    __int16 v383 = 2082;
                    v384 = v155;
                    _os_log_impl(&dword_1830D4000, v156, v355, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }

                  free(v155);
                }
                else
                {
                  if (v157)
                  {
                    v170 = *(const char **)(v10 + 16);
                    if (!v170) {
                      v170 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    v378 = "__nw_protocol_remove_input_handler";
                    __int16 v379 = 2082;
                    v380 = (char *)v170;
                    __int16 v381 = 2048;
                    v382 = (const char *)v10;
                    _os_log_impl(&dword_1830D4000, v156, v355, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace", buf, 0x20u);
                  }
                }
              }
              else
              {
                v136 = __nwlog_obj();
                os_log_type_t v167 = v370[0];
                if (os_log_type_enabled(v136, v370[0]))
                {
                  v168 = *(const char **)(v10 + 16);
                  if (!v168) {
                    v168 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v378 = "__nw_protocol_remove_input_handler";
                  __int16 v379 = 2082;
                  v380 = (char *)v168;
                  __int16 v381 = 2048;
                  v382 = (const char *)v10;
                  _os_log_impl(&dword_1830D4000, v136, v167, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded", buf, 0x20u);
                }
LABEL_300:
              }
            }
            if (v135) {
              free(v135);
            }
            char v91 = 0;
            if (v87) {
LABEL_202:
            }
              nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
LABEL_203:
            if (v376) {
LABEL_204:
            }
              nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
LABEL_205:
            if ((v91 & 1) == 0)
            {
              if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                v214 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
                {
                  loga = v214;
                  v286 = nw_endpoint_handler_get_id_string(v362);
                  v287 = nw_endpoint_handler_dry_run_string(v362);
                  nw_endpoint_t v288 = nw_endpoint_handler_copy_endpoint(v362);
                  v289 = nw_endpoint_get_logging_description(v288);
                  v290 = nw_endpoint_handler_state_string(v362);
                  v291 = nw_endpoint_handler_mode_string(v362);
                  id v292 = nw_endpoint_handler_copy_current_path(v362);
                  *(_DWORD *)buf = 136448002;
                  v378 = "nw_endpoint_handler_modify_protocol_stack";
                  __int16 v379 = 2082;
                  v380 = (char *)v286;
                  __int16 v381 = 2082;
                  v382 = v287;
                  __int16 v383 = 2082;
                  v384 = (void *)v289;
                  __int16 v385 = 2082;
                  v386 = v290;
                  __int16 v387 = 2082;
                  v388 = v291;
                  __int16 v389 = 2114;
                  id v390 = v292;
                  __int16 v391 = 2082;
                  v392 = v12;
                  _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove protocol %{public}s", buf, 0x52u);

                  goto LABEL_599;
                }
                goto LABEL_600;
              }
              goto LABEL_601;
            }
            goto LABEL_206;
          }
          v151 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v378 = "__nw_protocol_remove_input_handler";
          v152 = (char *)_os_log_send_and_compose_impl();

          v373[0] = OS_LOG_TYPE_ERROR;
          v370[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v152, v373, v370))
          {
            if (v373[0] == OS_LOG_TYPE_FAULT)
            {
              v153 = __nwlog_obj();
              os_log_type_t v154 = v373[0];
              if (os_log_type_enabled(v153, v373[0]))
              {
                *(_DWORD *)buf = 136446210;
                v378 = "__nw_protocol_remove_input_handler";
                _os_log_impl(&dword_1830D4000, v153, v154, "%{public}s called with null input_protocol", buf, 0xCu);
              }
              goto LABEL_417;
            }
            if (v370[0])
            {
              v164 = (char *)__nw_create_backtrace_string();
              v153 = __nwlog_obj();
              os_log_type_t v350 = v373[0];
              BOOL v165 = os_log_type_enabled(v153, v373[0]);
              if (v164)
              {
                if (v165)
                {
                  *(_DWORD *)buf = 136446466;
                  v378 = "__nw_protocol_remove_input_handler";
                  __int16 v379 = 2082;
                  v380 = v164;
                  _os_log_impl(&dword_1830D4000, v153, v350, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v164);
                goto LABEL_418;
              }
              if (v165)
              {
                *(_DWORD *)buf = 136446210;
                v378 = "__nw_protocol_remove_input_handler";
                _os_log_impl(&dword_1830D4000, v153, v350, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              v153 = __nwlog_obj();
              os_log_type_t v171 = v373[0];
              if (os_log_type_enabled(v153, v373[0]))
              {
                *(_DWORD *)buf = 136446210;
                v378 = "__nw_protocol_remove_input_handler";
                _os_log_impl(&dword_1830D4000, v153, v171, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
              }
            }
LABEL_417:
          }
LABEL_418:
          if (v152) {
            free(v152);
          }
          char v91 = 0;
          if (v64) {
            goto LABEL_204;
          }
          goto LABEL_205;
        }
        if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v74 = *(void *)(v21 + 88);
          if (v74) {
            *(void *)(v21 + 88) = v74 + 1;
          }
          *(void *)v375 = v21;
          char v32 = v376 | 1;
        }
        else
        {
          *(void *)v375 = *(void *)(v10 + 32);
          char v32 = v376 & 0xFE;
        }
        char v376 = v32;
        if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v76 = *(void *)(v10 + 88);
          if (v76) {
            *(void *)(v10 + 88) = v76 + 1;
          }
          *(void *)v373 = v10;
          char v75 = v374 | 1;
        }
        else
        {
          *(void *)v373 = v10;
          char v75 = v374 & 0xFE;
        }
        char v374 = v75;
        if (v359)
        {
          if (*(_UNKNOWN **)(v359 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v78 = *(void *)(v359 + 88);
            if (v78) {
              *(void *)(v359 + 88) = v78 + 1;
            }
            *(void *)v370 = v359;
            char v77 = v371 | 1;
          }
          else
          {
            *(void *)v370 = v359;
            char v77 = v371 & 0xFE;
          }
          char v371 = v77;
          uint64_t v79 = *(void *)(v21 + 24);
          if (v79)
          {
            os_log_type_t v80 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v79 + 16);
            if (v80)
            {
              char v81 = v80(v21, v10, v359);
              if (v371) {
                goto LABEL_174;
              }
              goto LABEL_175;
            }
          }
          os_log_type_t v125 = __nwlog_obj();
          os_log_type_t v126 = *(const char **)(v21 + 16);
          if (!v126) {
            os_log_type_t v126 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          v378 = "__nw_protocol_replace_input_handler";
          __int16 v379 = 2082;
          v380 = (char *)v126;
          __int16 v381 = 2048;
          v382 = (const char *)v21;
          os_log_type_t v127 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v369 = 0;
          if (__nwlog_fault(v127, &type, &v369))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v128 = __nwlog_obj();
              os_log_type_t v129 = type;
              if (os_log_type_enabled(v128, type))
              {
                os_log_type_t v130 = *(const char **)(v21 + 16);
                if (!v130) {
                  os_log_type_t v130 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v378 = "__nw_protocol_replace_input_handler";
                __int16 v379 = 2082;
                v380 = (char *)v130;
                __int16 v381 = 2048;
                v382 = (const char *)v21;
                _os_log_impl(&dword_1830D4000, v128, v129, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback", buf, 0x20u);
              }
              goto LABEL_286;
            }
            if (v369)
            {
              uint64_t v143 = (char *)__nw_create_backtrace_string();
              v144 = __nwlog_obj();
              os_log_type_t v354 = type;
              BOOL v145 = os_log_type_enabled(v144, type);
              if (v143)
              {
                if (v145)
                {
                  v146 = *(const char **)(v21 + 16);
                  if (!v146) {
                    v146 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  v378 = "__nw_protocol_replace_input_handler";
                  __int16 v379 = 2082;
                  v380 = (char *)v146;
                  __int16 v381 = 2048;
                  v382 = (const char *)v21;
                  __int16 v383 = 2082;
                  v384 = v143;
                  _os_log_impl(&dword_1830D4000, v144, v354, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                free(v143);
              }
              else
              {
                if (v145)
                {
                  v166 = *(const char **)(v21 + 16);
                  if (!v166) {
                    v166 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v378 = "__nw_protocol_replace_input_handler";
                  __int16 v379 = 2082;
                  v380 = (char *)v166;
                  __int16 v381 = 2048;
                  v382 = (const char *)v21;
                  _os_log_impl(&dword_1830D4000, v144, v354, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace", buf, 0x20u);
                }
              }
            }
            else
            {
              os_log_type_t v128 = __nwlog_obj();
              os_log_type_t v162 = type;
              if (os_log_type_enabled(v128, type))
              {
                v163 = *(const char **)(v21 + 16);
                if (!v163) {
                  v163 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                v378 = "__nw_protocol_replace_input_handler";
                __int16 v379 = 2082;
                v380 = (char *)v163;
                __int16 v381 = 2048;
                v382 = (const char *)v21;
                _os_log_impl(&dword_1830D4000, v128, v162, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded", buf, 0x20u);
              }
LABEL_286:
            }
          }
          if (v127) {
            free(v127);
          }
          char v81 = 0;
          if (v77) {
LABEL_174:
          }
            nw::release_if_needed<nw_protocol *>((uint64_t *)v370);
LABEL_175:
          if ((v374 & 1) == 0) {
            goto LABEL_177;
          }
LABEL_176:
          nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
          goto LABEL_177;
        }
        v139 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v378 = "__nw_protocol_replace_input_handler";
        v140 = (char *)_os_log_send_and_compose_impl();

        v370[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v140, v370, &type)) {
          goto LABEL_408;
        }
        if (v370[0] == OS_LOG_TYPE_FAULT)
        {
          __int16 v141 = __nwlog_obj();
          os_log_type_t v142 = v370[0];
          if (os_log_type_enabled(v141, v370[0]))
          {
            *(_DWORD *)buf = 136446210;
            v378 = "__nw_protocol_replace_input_handler";
            _os_log_impl(&dword_1830D4000, v141, v142, "%{public}s called with null new_input_protocol", buf, 0xCu);
          }
LABEL_407:

          goto LABEL_408;
        }
        if (type == OS_LOG_TYPE_DEFAULT)
        {
          __int16 v141 = __nwlog_obj();
          os_log_type_t v169 = v370[0];
          if (os_log_type_enabled(v141, v370[0]))
          {
            *(_DWORD *)buf = 136446210;
            v378 = "__nw_protocol_replace_input_handler";
            _os_log_impl(&dword_1830D4000, v141, v169, "%{public}s called with null new_input_protocol, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_407;
        }
        v160 = (char *)__nw_create_backtrace_string();
        __int16 v141 = __nwlog_obj();
        os_log_type_t v349 = v370[0];
        BOOL v161 = os_log_type_enabled(v141, v370[0]);
        if (!v160)
        {
          if (v161)
          {
            *(_DWORD *)buf = 136446210;
            v378 = "__nw_protocol_replace_input_handler";
            _os_log_impl(&dword_1830D4000, v141, v349, "%{public}s called with null new_input_protocol, no backtrace", buf, 0xCu);
          }
          goto LABEL_407;
        }
        if (v161)
        {
          *(_DWORD *)buf = 136446466;
          v378 = "__nw_protocol_replace_input_handler";
          __int16 v379 = 2082;
          v380 = v160;
          _os_log_impl(&dword_1830D4000, v141, v349, "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v160);
LABEL_408:
        if (v140) {
          free(v140);
        }
        char v81 = 0;
        if (v75) {
          goto LABEL_176;
        }
LABEL_177:
        if (v376)
        {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
          if ((v81 & 1) == 0)
          {
LABEL_557:
            if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              v214 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
              {
                loga = v214;
                v275 = nw_endpoint_handler_get_id_string(v362);
                v276 = nw_endpoint_handler_dry_run_string(v362);
                nw_endpoint_t v277 = nw_endpoint_handler_copy_endpoint(v362);
                v278 = nw_endpoint_get_logging_description(v277);
                v279 = nw_endpoint_handler_state_string(v362);
                v280 = nw_endpoint_handler_mode_string(v362);
                id v281 = nw_endpoint_handler_copy_current_path(v362);
                v282 = v281;
                v283 = "invalid";
                if (v359 && *(void *)(v359 + 16)) {
                  v283 = *(const char **)(v359 + 16);
                }
                *(_DWORD *)buf = 136448258;
                v378 = "nw_endpoint_handler_modify_protocol_stack";
                __int16 v379 = 2082;
                v380 = (char *)v275;
                __int16 v381 = 2082;
                v382 = v276;
                __int16 v383 = 2082;
                v384 = (void *)v278;
                __int16 v385 = 2082;
                v386 = v279;
                __int16 v387 = 2082;
                v388 = v280;
                __int16 v389 = 2114;
                id v390 = v281;
                __int16 v391 = 2082;
                v392 = v12;
                __int16 v393 = 2082;
                v394 = (void *)v283;
                _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to replace protocol %{public}s with %{public}s", buf, 0x5Cu);

                goto LABEL_599;
              }
              goto LABEL_600;
            }
            goto LABEL_601;
          }
        }
        else if ((v81 & 1) == 0)
        {
          goto LABEL_557;
        }
LABEL_206:
        uint64_t v92 = *(void *)(v359 + 32);
        BOOL v93 = v92 == v10 || v92 == 0;
        char v11 = 1;
        if (!v93 || v92 == v21) {
          goto LABEL_218;
        }
        if (v92)
        {
          if (*(_UNKNOWN **)(v92 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v95 = *(void *)(v92 + 88);
            if (v95)
            {
              uint64_t v96 = v95 - 1;
              *(void *)(v92 + 88) = v96;
              if (!v96)
              {
                __int16 v97 = *(void (***)(void))(v92 + 64);
                if (v97)
                {
                  *(void *)(v92 + 64) = 0;
                  v97[2](v97);
                  _Block_release(v97);
                }
                if (*(unsigned char *)(v92 + 72))
                {
                  __int16 v98 = *(const void **)(v92 + 64);
                  if (v98) {
                    _Block_release(v98);
                  }
                }
                free((void *)v92);
              }
            }
          }
        }
        *(void *)(v359 + 32) = v21;
        if (!v21)
        {
          uint64_t v10 = 0;
          goto LABEL_219;
        }
        goto LABEL_215;
      case 2:
        if (!identifier)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v214 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
            {
              loga = v214;
              v215 = nw_endpoint_handler_get_id_string(v362);
              v216 = nw_endpoint_handler_dry_run_string(v362);
              nw_endpoint_t v217 = nw_endpoint_handler_copy_endpoint(v362);
              v218 = nw_endpoint_get_logging_description(v217);
              v219 = nw_endpoint_handler_state_string(v362);
              v220 = nw_endpoint_handler_mode_string(v362);
              id v221 = nw_endpoint_handler_copy_current_path(v362);
              *(_DWORD *)buf = 136448002;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              __int16 v379 = 2082;
              v380 = (char *)v215;
              __int16 v381 = 2082;
              v382 = v216;
              __int16 v383 = 2082;
              v384 = (void *)v218;
              __int16 v385 = 2082;
              v386 = v219;
              __int16 v387 = 2082;
              v388 = v220;
              __int16 v389 = 2114;
              id v390 = v221;
              __int16 v391 = 2082;
              v392 = v12;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot insert NULL protocol before %{public}s", buf, 0x52u);

              goto LABEL_599;
            }
            goto LABEL_600;
          }
          goto LABEL_601;
        }
        nw_endpoint_t v22 = nw_endpoint_handler_copy_endpoint(v362);
        uint64_t v21 = nw_endpoint_handler_create_protocol_for_definition((uint64_t)identifier, v20, v22, v361);

        if (!v21)
        {
          if (nw_endpoint_handler_get_logging_disabled(v362)) {
            goto LABEL_601;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v214 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
            goto LABEL_600;
          }
          goto LABEL_541;
        }
        nw_parameters_add_protocol_stack_member(v361, 4, 0xFFFFFFFF, v14);
        nw_endpoint_handler_set_protocol_instance(v362, v14, v20, v21);
        if (!v359)
        {
          v321 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v378 = "nw_protocol_utilities_add_input_handler";
          v322 = (char *)_os_log_send_and_compose_impl();

          v375[0] = OS_LOG_TYPE_ERROR;
          v373[0] = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v322, v375, v373)) {
            goto LABEL_663;
          }
          if (v375[0] == OS_LOG_TYPE_FAULT)
          {
            v323 = __nwlog_obj();
            os_log_type_t v324 = v375[0];
            if (os_log_type_enabled(v323, v375[0]))
            {
              *(_DWORD *)buf = 136446210;
              v378 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_1830D4000, v323, v324, "%{public}s called with null input_protocol", buf, 0xCu);
            }
            goto LABEL_662;
          }
          if (v373[0])
          {
            v332 = (char *)__nw_create_backtrace_string();
            v323 = __nwlog_obj();
            os_log_type_t v333 = v375[0];
            BOOL v334 = os_log_type_enabled(v323, v375[0]);
            if (v332)
            {
              if (v334)
              {
                *(_DWORD *)buf = 136446466;
                v378 = "nw_protocol_utilities_add_input_handler";
                __int16 v379 = 2082;
                v380 = v332;
                _os_log_impl(&dword_1830D4000, v323, v333, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v332);
LABEL_663:
              if (v322) {
                free(v322);
              }
              uint64_t v359 = 0;
LABEL_591:
              v302 = v362;
              BOOL v303 = (*((unsigned char *)v302 + 268) & 0x20) == 0;

              if (!v303) {
                goto LABEL_601;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              v214 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
                goto LABEL_600;
              }
              loga = v214;
              v304 = nw_endpoint_handler_get_id_string(v302);
              v305 = nw_endpoint_handler_dry_run_string(v302);
              nw_endpoint_t v306 = nw_endpoint_handler_copy_endpoint(v302);
              v307 = nw_endpoint_get_logging_description(v306);
              v308 = nw_endpoint_handler_state_string(v302);
              v309 = nw_endpoint_handler_mode_string(v302);
              id v310 = nw_endpoint_handler_copy_current_path(v302);
              v311 = v310;
              v312 = "invalid";
              if (v359 && *(void *)(v359 + 16)) {
                v312 = *(const char **)(v359 + 16);
              }
              *(_DWORD *)buf = 136448258;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              __int16 v379 = 2082;
              v380 = (char *)v304;
              __int16 v381 = 2082;
              v382 = v305;
              __int16 v383 = 2082;
              v384 = (void *)v307;
              __int16 v385 = 2082;
              v386 = v308;
              __int16 v387 = 2082;
              v388 = v309;
              __int16 v389 = 2114;
              id v390 = v310;
              __int16 v391 = 2082;
              v392 = identifier;
              __int16 v393 = 2082;
              v394 = (void *)v312;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s below %{public}s", buf, 0x5Cu);

LABEL_599:
              v214 = loga;
              goto LABEL_600;
            }
            if (v334)
            {
              *(_DWORD *)buf = 136446210;
              v378 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_1830D4000, v323, v333, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            v323 = __nwlog_obj();
            os_log_type_t v339 = v375[0];
            if (os_log_type_enabled(v323, v375[0]))
            {
              *(_DWORD *)buf = 136446210;
              v378 = "nw_protocol_utilities_add_input_handler";
              _os_log_impl(&dword_1830D4000, v323, v339, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
            }
          }
LABEL_662:

          goto LABEL_663;
        }
        if (v21 == v359)
        {
          v240 = __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          v378 = "nw_protocol_utilities_add_input_handler";
          __int16 v379 = 2048;
          v380 = (char *)v359;
          v241 = (char *)_os_log_send_and_compose_impl();

          v375[0] = OS_LOG_TYPE_ERROR;
          v373[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v241, v375, v373))
          {
            if (v375[0] == OS_LOG_TYPE_FAULT)
            {
              v242 = __nwlog_obj();
              os_log_type_t v243 = v375[0];
              if (os_log_type_enabled(v242, v375[0]))
              {
                *(_DWORD *)buf = 136446466;
                v378 = "nw_protocol_utilities_add_input_handler";
                __int16 v379 = 2048;
                v380 = (char *)v359;
                _os_log_impl(&dword_1830D4000, v242, v243, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
              }
              goto LABEL_588;
            }
            if (v373[0])
            {
              v272 = (char *)__nw_create_backtrace_string();
              v242 = __nwlog_obj();
              os_log_type_t v273 = v375[0];
              BOOL v274 = os_log_type_enabled(v242, v375[0]);
              if (v272)
              {
                if (v274)
                {
                  *(_DWORD *)buf = 136446722;
                  v378 = "nw_protocol_utilities_add_input_handler";
                  __int16 v379 = 2048;
                  v380 = (char *)v359;
                  __int16 v381 = 2082;
                  v382 = v272;
                  _os_log_impl(&dword_1830D4000, v242, v273, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                }

                free(v272);
                goto LABEL_589;
              }
              if (v274)
              {
                *(_DWORD *)buf = 136446466;
                v378 = "nw_protocol_utilities_add_input_handler";
                __int16 v379 = 2048;
                v380 = (char *)v359;
                _os_log_impl(&dword_1830D4000, v242, v273, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
              }
            }
            else
            {
              v242 = __nwlog_obj();
              os_log_type_t v285 = v375[0];
              if (os_log_type_enabled(v242, v375[0]))
              {
                *(_DWORD *)buf = 136446466;
                v378 = "nw_protocol_utilities_add_input_handler";
                __int16 v379 = 2048;
                v380 = (char *)v359;
                _os_log_impl(&dword_1830D4000, v242, v285, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
              }
            }
LABEL_588:
          }
LABEL_589:
          if (v241) {
            free(v241);
          }
          goto LABEL_591;
        }
        os_log_type_t v23 = *(void **)(v21 + 24);
        if (!v23 || !*v23)
        {
          v247 = __nwlog_obj();
          if (os_log_type_enabled(v247, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v378 = "nw_protocol_utilities_add_input_handler";
            __int16 v379 = 2048;
            v380 = (char *)v21;
            _os_log_impl(&dword_1830D4000, v247, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
          }

          goto LABEL_591;
        }
        if ((nw_protocol_add_input_handler(v21, v359) & 1) == 0) {
          goto LABEL_591;
        }
        if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v33 = *(void *)(v10 + 88);
          if (v33) {
            *(void *)(v10 + 88) = v33 + 1;
          }
          *(void *)v375 = v10;
          char v24 = v376 | 1;
        }
        else
        {
          *(void *)v375 = v10;
          char v24 = v376 & 0xFE;
        }
        char v376 = v24;
        if (*(_UNKNOWN **)(v359 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v35 = *(void *)(v359 + 88);
          if (v35) {
            *(void *)(v359 + 88) = v35 + 1;
          }
          *(void *)v373 = v359;
          char v34 = v374 | 1;
        }
        else
        {
          *(void *)v373 = v359;
          char v34 = v374 & 0xFE;
        }
        char v374 = v34;
        if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v37 = *(void *)(v21 + 88);
          if (v37) {
            *(void *)(v21 + 88) = v37 + 1;
          }
          *(void *)v370 = v21;
          char v36 = v371 | 1;
        }
        else
        {
          *(void *)v370 = v21;
          char v36 = v371 & 0xFE;
        }
        char v371 = v36;
        uint64_t v38 = *(void *)(v10 + 24);
        if (v38)
        {
          char v39 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v38 + 16);
          if (v39)
          {
            char v40 = v39(v10, v359, v21);
            if ((v371 & 1) == 0) {
              goto LABEL_56;
            }
LABEL_55:
            nw::release_if_needed<nw_protocol *>((uint64_t *)v370);
            goto LABEL_56;
          }
        }
        __int16 v99 = __nwlog_obj();
        __int16 v100 = *(const char **)(v10 + 16);
        if (!v100) {
          __int16 v100 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v378 = "__nw_protocol_replace_input_handler";
        __int16 v379 = 2082;
        v380 = (char *)v100;
        __int16 v381 = 2048;
        v382 = (const char *)v10;
        id v101 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v369 = 0;
        if (!__nwlog_fault(v101, &type, &v369)) {
          goto LABEL_328;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v102 = __nwlog_obj();
          os_log_type_t v103 = type;
          if (os_log_type_enabled(v102, type))
          {
            uint64_t v104 = *(const char **)(v10 + 16);
            if (!v104) {
              uint64_t v104 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v104;
            __int16 v381 = 2048;
            v382 = (const char *)v10;
            _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback", buf, 0x20u);
          }
LABEL_238:

          goto LABEL_328;
        }
        if (!v369)
        {
          __int16 v102 = __nwlog_obj();
          os_log_type_t v131 = type;
          if (os_log_type_enabled(v102, type))
          {
            os_log_type_t v132 = *(const char **)(v10 + 16);
            if (!v132) {
              os_log_type_t v132 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v132;
            __int16 v381 = 2048;
            v382 = (const char *)v10;
            _os_log_impl(&dword_1830D4000, v102, v131, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded", buf, 0x20u);
          }
          goto LABEL_238;
        }
        id v115 = (char *)__nw_create_backtrace_string();
        __int16 v116 = __nwlog_obj();
        os_log_type_t v353 = type;
        BOOL v117 = os_log_type_enabled(v116, type);
        if (v115)
        {
          if (v117)
          {
            __int16 v118 = *(const char **)(v10 + 16);
            if (!v118) {
              __int16 v118 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v118;
            __int16 v381 = 2048;
            v382 = (const char *)v10;
            __int16 v383 = 2082;
            v384 = v115;
            _os_log_impl(&dword_1830D4000, v116, v353, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v115);
        }
        else
        {
          if (v117)
          {
            v149 = *(const char **)(v10 + 16);
            if (!v149) {
              v149 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v149;
            __int16 v381 = 2048;
            v382 = (const char *)v10;
            _os_log_impl(&dword_1830D4000, v116, v353, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace", buf, 0x20u);
          }
        }
LABEL_328:
        if (v101) {
          free(v101);
        }
        char v40 = 0;
        if (v36) {
          goto LABEL_55;
        }
LABEL_56:
        if (v374) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
        }
        if (v376) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
        }
        if ((v40 & 1) == 0)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v214 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
            {
              loga = v214;
              v248 = nw_endpoint_handler_get_id_string(v362);
              v249 = nw_endpoint_handler_dry_run_string(v362);
              nw_endpoint_t v358 = nw_endpoint_handler_copy_endpoint(v362);
              v250 = nw_endpoint_get_logging_description(v358);
              v251 = nw_endpoint_handler_state_string(v362);
              v252 = nw_endpoint_handler_mode_string(v362);
              id v253 = nw_endpoint_handler_copy_current_path(v362);
              v254 = v253;
              v255 = *(const char **)(v359 + 16);
              if (!v255) {
                v255 = "invalid";
              }
              *(_DWORD *)buf = 136448258;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              __int16 v379 = 2082;
              v380 = (char *)v248;
              __int16 v381 = 2082;
              v382 = v249;
              __int16 v383 = 2082;
              v384 = (void *)v250;
              __int16 v385 = 2082;
              v386 = v251;
              __int16 v387 = 2082;
              v388 = v252;
              __int16 v389 = 2114;
              id v390 = v253;
              __int16 v391 = 2082;
              v392 = (void *)v255;
              __int16 v393 = 2082;
              v394 = identifier;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to replace protocol %{public}s with %{public}s", buf, 0x5Cu);

              goto LABEL_599;
            }
LABEL_600:
          }
LABEL_601:

          uint64_t v196 = 0;
          goto LABEL_602;
        }
        uint64_t v41 = *(void *)(v359 + 32);
        BOOL v42 = v41 == v10 || v41 == 0;
        char v11 = 1;
        if (v42 && v41 != v21)
        {
          if (v41)
          {
            if (*(_UNKNOWN **)(v41 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v70 = *(void *)(v41 + 88);
              if (v70)
              {
                uint64_t v71 = v70 - 1;
                *(void *)(v41 + 88) = v71;
                if (!v71)
                {
                  os_log_type_t v72 = *(void (***)(void))(v41 + 64);
                  if (v72)
                  {
                    *(void *)(v41 + 64) = 0;
                    v72[2](v72);
                    _Block_release(v72);
                  }
                  if (*(unsigned char *)(v41 + 72))
                  {
                    id v73 = *(const void **)(v41 + 64);
                    if (v73) {
                      _Block_release(v73);
                    }
                  }
                  free((void *)v41);
                }
              }
            }
          }
          *(void *)(v359 + 32) = v21;
LABEL_215:
          if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v94 = *(void *)(v21 + 88);
            if (v94) {
              *(void *)(v21 + 88) = v94 + 1;
            }
          }
        }
LABEL_218:
        uint64_t v10 = v21;
LABEL_219:

        if (v10) {
          continue;
        }
        if (v11)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v185 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v185, OS_LOG_TYPE_DEBUG))
            {
              v186 = nw_endpoint_handler_get_id_string(v362);
              v187 = nw_endpoint_handler_dry_run_string(v362);
              nw_endpoint_t v188 = nw_endpoint_handler_copy_endpoint(v362);
              v189 = nw_endpoint_get_logging_description(v188);
              v190 = nw_endpoint_handler_state_string(v362);
              v191 = nw_endpoint_handler_mode_string(v362);
              id v192 = nw_endpoint_handler_copy_current_path(v362);
              *(_DWORD *)buf = 136447746;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              __int16 v379 = 2082;
              v380 = (char *)v186;
              __int16 v381 = 2082;
              v382 = v187;
              __int16 v383 = 2082;
              v384 = (void *)v189;
              __int16 v385 = 2082;
              v386 = v190;
              __int16 v387 = 2082;
              v388 = v191;
              __int16 v389 = 2114;
              id v390 = v192;
              _os_log_impl(&dword_1830D4000, v185, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Modified protocol stack", buf, 0x48u);
            }
          }
          v193 = v362;
          v356->int state = 2;

          *((_DWORD *)v193 + 20) = 262147;
          nw_endpoint_handler_report(v193, 0, (_WORD *)v193 + 40, 0);
          if ((*((unsigned char *)v357 + 33) & 4) != 0)
          {
            id v194 = nw_endpoint_handler_copy_association(v193, 0);
            v195 = v194;
            if (v194) {
              nw_association_mark_flow_disconnected(v194, v193);
            }
            *((unsigned char *)v357 + 33) &= ~4u;
          }
          uint64_t v196 = nw_endpoint_flow_connect(v193);
          goto LABEL_602;
        }
LABEL_456:
        v197 = v362;
        BOOL v198 = (*((unsigned char *)v197 + 268) & 0x20) == 0;

        if (v198)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v199 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v199, OS_LOG_TYPE_DEBUG))
          {
            v200 = v197;

            v201 = v200;
            BOOL v202 = (*((unsigned char *)v197 + 268) & 1) == 0;

            if (v202) {
              v203 = "";
            }
            else {
              v203 = "dry-run ";
            }
            nw_endpoint_t v204 = nw_endpoint_handler_copy_endpoint(v201);
            v205 = nw_endpoint_get_logging_description(v204);
            v206 = v201;
            v207 = v206;
            uint64_t v208 = v356->state;
            if (v208 > 5) {
              v209 = "unknown-state";
            }
            else {
              v209 = off_1E523FB38[v208];
            }

            v210 = v207;
            v211 = v210;
            unsigned int v212 = v4[29];
            v213 = "path";
            switch(v212)
            {
              case 0u:
                break;
              case 1u:
                v213 = "resolver";
                break;
              case 2u:
                v213 = nw_endpoint_flow_mode_string(v210[31]);
                break;
              case 3u:
                v213 = "proxy";
                break;
              case 4u:
                v213 = "fallback";
                break;
              case 5u:
                v213 = "transform";
                break;
              default:
                v213 = "unknown-mode";
                break;
            }

            v244 = v211;
            os_unfair_lock_lock((os_unfair_lock_t)v244 + 28);
            id v245 = v244[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v244 + 28);

            *(_DWORD *)buf = 136447746;
            v378 = "nw_endpoint_handler_modify_protocol_stack";
            __int16 v379 = 2082;
            v380 = v200 + 168;
            __int16 v381 = 2082;
            v382 = v203;
            __int16 v383 = 2082;
            v384 = (void *)v205;
            __int16 v385 = 2082;
            v386 = v209;
            __int16 v387 = 2082;
            v388 = v213;
            __int16 v389 = 2114;
            id v390 = v245;
            _os_log_impl(&dword_1830D4000, v199, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No modifications made to protocol stack", buf, 0x48u);
          }
        }
        uint64_t v196 = 1;
LABEL_602:

LABEL_603:
        return v196;
      case 3:
        if (!identifier)
        {
          if ((nw_endpoint_handler_get_logging_disabled(v362) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v214 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v214, OS_LOG_TYPE_ERROR))
            {
              loga = v214;
              v222 = nw_endpoint_handler_get_id_string(v362);
              v223 = nw_endpoint_handler_dry_run_string(v362);
              nw_endpoint_t v224 = nw_endpoint_handler_copy_endpoint(v362);
              v225 = nw_endpoint_get_logging_description(v224);
              v226 = nw_endpoint_handler_state_string(v362);
              v227 = nw_endpoint_handler_mode_string(v362);
              id v228 = nw_endpoint_handler_copy_current_path(v362);
              *(_DWORD *)buf = 136448002;
              v378 = "nw_endpoint_handler_modify_protocol_stack";
              __int16 v379 = 2082;
              v380 = (char *)v222;
              __int16 v381 = 2082;
              v382 = v223;
              __int16 v383 = 2082;
              v384 = (void *)v225;
              __int16 v385 = 2082;
              v386 = v226;
              __int16 v387 = 2082;
              v388 = v227;
              __int16 v389 = 2114;
              id v390 = v228;
              __int16 v391 = 2082;
              v392 = v12;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot insert NULL protocol after %{public}s", buf, 0x52u);

              goto LABEL_599;
            }
            goto LABEL_600;
          }
          goto LABEL_601;
        }
        nw_endpoint_t v25 = nw_endpoint_handler_copy_endpoint(v362);
        uint64_t v26 = nw_endpoint_handler_create_protocol_for_definition((uint64_t)identifier, v20, v25, v361);

        if (!v26)
        {
          if (nw_endpoint_handler_get_logging_disabled(v362)) {
            goto LABEL_601;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v214 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
            goto LABEL_600;
          }
          goto LABEL_541;
        }
        nw_parameters_add_protocol_stack_member(v361, 4, 0xFFFFFFFF, v14);
        nw_endpoint_handler_set_protocol_instance(v362, v14, v20, v26);
        if (v26 == v10)
        {
          v236 = __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          v378 = "nw_protocol_utilities_add_input_handler";
          __int16 v379 = 2048;
          v380 = (char *)v10;
          v237 = (char *)_os_log_send_and_compose_impl();

          v375[0] = OS_LOG_TYPE_ERROR;
          v373[0] = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v237, v375, v373)) {
            goto LABEL_579;
          }
          if (v375[0] == OS_LOG_TYPE_FAULT)
          {
            v238 = __nwlog_obj();
            os_log_type_t v239 = v375[0];
            if (os_log_type_enabled(v238, v375[0]))
            {
              *(_DWORD *)buf = 136446466;
              v378 = "nw_protocol_utilities_add_input_handler";
              __int16 v379 = 2048;
              v380 = (char *)v10;
              _os_log_impl(&dword_1830D4000, v238, v239, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
            goto LABEL_578;
          }
          if (v373[0])
          {
            v269 = (char *)__nw_create_backtrace_string();
            v238 = __nwlog_obj();
            os_log_type_t v270 = v375[0];
            BOOL v271 = os_log_type_enabled(v238, v375[0]);
            if (v269)
            {
              if (v271)
              {
                *(_DWORD *)buf = 136446722;
                v378 = "nw_protocol_utilities_add_input_handler";
                __int16 v379 = 2048;
                v380 = (char *)v10;
                __int16 v381 = 2082;
                v382 = v269;
                _os_log_impl(&dword_1830D4000, v238, v270, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v269);
LABEL_579:
              if (v237) {
                free(v237);
              }
LABEL_581:
              v293 = v362;
              BOOL v294 = (*((unsigned char *)v293 + 268) & 0x20) == 0;

              if (!v294) {
                goto LABEL_601;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              loga = (id)gconnectionLogObj;
              if (os_log_type_enabled(loga, OS_LOG_TYPE_ERROR))
              {
                v295 = nw_endpoint_handler_get_id_string(v293);
                v296 = nw_endpoint_handler_dry_run_string(v293);
                v297 = v295;
                nw_endpoint_t v363 = nw_endpoint_handler_copy_endpoint(v293);
                v298 = nw_endpoint_get_logging_description(v363);
                v299 = nw_endpoint_handler_state_string(v293);
                v300 = nw_endpoint_handler_mode_string(v293);
                id v301 = nw_endpoint_handler_copy_current_path(v293);
                *(_DWORD *)buf = 136448258;
                v378 = "nw_endpoint_handler_modify_protocol_stack";
                __int16 v379 = 2082;
                v380 = (char *)v297;
                __int16 v381 = 2082;
                v382 = v296;
                __int16 v383 = 2082;
                v384 = (void *)v298;
                __int16 v385 = 2082;
                v386 = v299;
                __int16 v387 = 2082;
                v388 = v300;
                __int16 v389 = 2114;
                id v390 = v301;
                __int16 v391 = 2082;
                v392 = identifier;
                __int16 v393 = 2082;
                v394 = v12;
                _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to add protocol %{public}s above %{public}s", buf, 0x5Cu);
              }
              goto LABEL_599;
            }
            if (v271)
            {
              *(_DWORD *)buf = 136446466;
              v378 = "nw_protocol_utilities_add_input_handler";
              __int16 v379 = 2048;
              v380 = (char *)v10;
              _os_log_impl(&dword_1830D4000, v238, v270, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
            }
          }
          else
          {
            v238 = __nwlog_obj();
            os_log_type_t v284 = v375[0];
            if (os_log_type_enabled(v238, v375[0]))
            {
              *(_DWORD *)buf = 136446466;
              v378 = "nw_protocol_utilities_add_input_handler";
              __int16 v379 = 2048;
              v380 = (char *)v10;
              _os_log_impl(&dword_1830D4000, v238, v284, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
            }
          }
LABEL_578:

          goto LABEL_579;
        }
        os_log_type_t v27 = *(void **)(v26 + 24);
        if (!v27 || !*v27)
        {
          v246 = __nwlog_obj();
          if (os_log_type_enabled(v246, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446466;
            v378 = "nw_protocol_utilities_add_input_handler";
            __int16 v379 = 2048;
            v380 = (char *)v26;
            _os_log_impl(&dword_1830D4000, v246, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
          }

          goto LABEL_581;
        }
        if ((nw_protocol_add_input_handler(v26, v10) & 1) == 0) {
          goto LABEL_581;
        }
        if (!v21) {
          goto LABEL_126;
        }
        if (*(_UNKNOWN **)(v21 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v53 = *(void *)(v21 + 88);
          if (v53) {
            *(void *)(v21 + 88) = v53 + 1;
          }
          *(void *)v375 = v21;
          char v28 = v376 | 1;
        }
        else
        {
          *(void *)v375 = v21;
          char v28 = v376 & 0xFE;
        }
        char v376 = v28;
        if (*(_UNKNOWN **)(v10 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v55 = *(void *)(v10 + 88);
          if (v55) {
            *(void *)(v10 + 88) = v55 + 1;
          }
          *(void *)v373 = v10;
          char v54 = v374 | 1;
        }
        else
        {
          *(void *)v373 = v10;
          char v54 = v374 & 0xFE;
        }
        char v374 = v54;
        if (*(_UNKNOWN **)(v26 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v57 = *(void *)(v26 + 88);
          if (v57) {
            *(void *)(v26 + 88) = v57 + 1;
          }
          *(void *)v370 = v26;
          char v56 = v371 | 1;
        }
        else
        {
          *(void *)v370 = v26;
          char v56 = v371 & 0xFE;
        }
        char v371 = v56;
        uint64_t v58 = *(void *)(v21 + 24);
        if (v58)
        {
          id v59 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t))(v58 + 16);
          if (v59)
          {
            char v60 = v59(v21, v10, v26);
            if ((v371 & 1) == 0) {
              goto LABEL_120;
            }
LABEL_119:
            nw::release_if_needed<nw_protocol *>((uint64_t *)v370);
            goto LABEL_120;
          }
        }
        __int16 v110 = __nwlog_obj();
        os_log_type_t v111 = *(const char **)(v21 + 16);
        if (!v111) {
          os_log_type_t v111 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        v378 = "__nw_protocol_replace_input_handler";
        __int16 v379 = 2082;
        v380 = (char *)v111;
        __int16 v381 = 2048;
        v382 = (const char *)v21;
        v352 = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v369 = 0;
        __int16 v112 = (char *)v352;
        if (!__nwlog_fault(v352, &type, &v369)) {
          goto LABEL_360;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v113 = __nwlog_obj();
          os_log_type_t v344 = type;
          if (os_log_type_enabled(v113, type))
          {
            __int16 v114 = *(const char **)(v21 + 16);
            if (!v114) {
              __int16 v114 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v114;
            __int16 v381 = 2048;
            v382 = (const char *)v21;
            _os_log_impl(&dword_1830D4000, v113, v344, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback", buf, 0x20u);
          }
LABEL_256:

          goto LABEL_359;
        }
        if (!v369)
        {
          os_log_type_t v113 = __nwlog_obj();
          os_log_type_t v348 = type;
          if (os_log_type_enabled(v113, type))
          {
            v148 = *(const char **)(v21 + 16);
            if (!v148) {
              v148 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v148;
            __int16 v381 = 2048;
            v382 = (const char *)v21;
            _os_log_impl(&dword_1830D4000, v113, v348, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded", buf, 0x20u);
          }
          goto LABEL_256;
        }
        v122 = (char *)__nw_create_backtrace_string();
        v346 = __nwlog_obj();
        os_log_type_t v342 = type;
        BOOL v123 = os_log_type_enabled(v346, type);
        if (v122)
        {
          if (v123)
          {
            BOOL v124 = *(const char **)(v21 + 16);
            if (!v124) {
              BOOL v124 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v124;
            __int16 v381 = 2048;
            v382 = (const char *)v21;
            __int16 v383 = 2082;
            v384 = v122;
            _os_log_impl(&dword_1830D4000, v346, v342, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v122);
        }
        else
        {
          if (v123)
          {
            v159 = *(const char **)(v21 + 16);
            if (!v159) {
              v159 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            v378 = "__nw_protocol_replace_input_handler";
            __int16 v379 = 2082;
            v380 = (char *)v159;
            __int16 v381 = 2048;
            v382 = (const char *)v21;
            _os_log_impl(&dword_1830D4000, v346, v342, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace", buf, 0x20u);
          }
        }
LABEL_359:
        __int16 v112 = (char *)v352;
LABEL_360:
        if (v112) {
          free(v112);
        }
        char v60 = 0;
        if (v56) {
          goto LABEL_119;
        }
LABEL_120:
        if (v374)
        {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v373);
          if ((v376 & 1) == 0)
          {
LABEL_122:
            if ((v60 & 1) == 0) {
              goto LABEL_542;
            }
            goto LABEL_126;
          }
        }
        else if ((v376 & 1) == 0)
        {
          goto LABEL_122;
        }
        nw::release_if_needed<nw_protocol *>((uint64_t *)v375);
        if ((v60 & 1) == 0)
        {
LABEL_542:
          if (nw_endpoint_handler_get_logging_disabled(v362)) {
            goto LABEL_601;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v214 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v214, OS_LOG_TYPE_ERROR)) {
            goto LABEL_600;
          }
          goto LABEL_546;
        }
LABEL_126:
        uint64_t v61 = *(void *)(v10 + 32);
        BOOL v62 = v61 == v21 || v61 == 0;
        char v11 = 1;
        if (v62 && v61 != v26)
        {
          if (v61)
          {
            if (*(_UNKNOWN **)(v61 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v66 = *(void *)(v61 + 88);
              if (v66)
              {
                uint64_t v67 = v66 - 1;
                *(void *)(v61 + 88) = v67;
                if (!v67)
                {
                  BOOL v68 = *(void (***)(void))(v61 + 64);
                  if (v68)
                  {
                    *(void *)(v61 + 64) = 0;
                    v68[2](v68);
                    _Block_release(v68);
                  }
                  if (*(unsigned char *)(v61 + 72))
                  {
                    os_log_type_t v69 = *(const void **)(v61 + 64);
                    if (v69) {
                      _Block_release(v69);
                    }
                  }
                  free((void *)v61);
                }
              }
            }
          }
          *(void *)(v10 + 32) = v26;
          if (*(_UNKNOWN **)(v26 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v63 = *(void *)(v26 + 88);
            if (v63) {
              *(void *)(v26 + 88) = v63 + 1;
            }
          }
        }
        goto LABEL_219;
      default:
        goto LABEL_219;
    }
  }
}

void sub_183C86484(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25,uint64_t a26,uint64_t a27,void *a28,uint64_t a29,uint64_t a30,void *a31,uint64_t a32,uint64_t a33,void *a34)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_append_and_start_application_protocol(void *a1, void *a2)
{
  uint64_t v375 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  os_log_type_t v348 = v3;
  if (!v3)
  {
    uint64_t v208 = v4;
    v209 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
    nw_endpoint_t v25 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v353) = 0;
    if (!__nwlog_fault(v25, type, &v353)) {
      goto LABEL_335;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v210 = __nwlog_obj();
      os_log_type_t v211 = type[0];
      if (os_log_type_enabled(v210, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        _os_log_impl(&dword_1830D4000, v210, v211, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v353)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v210 = __nwlog_obj();
      os_log_type_t v241 = type[0];
      BOOL v242 = os_log_type_enabled(v210, type[0]);
      if (backtrace_string)
      {
        if (v242)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
          __int16 v359 = 2082;
          nw_endpoint_t v360 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v210, v241, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_335:
        os_log_type_t v23 = v208;
        if (!v25) {
          goto LABEL_87;
        }
        goto LABEL_86;
      }
      if (v242)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        _os_log_impl(&dword_1830D4000, v210, v241, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v210 = __nwlog_obj();
      os_log_type_t v287 = type[0];
      if (os_log_type_enabled(v210, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        _os_log_impl(&dword_1830D4000, v210, v287, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_335;
  }
  BOOL v6 = (unsigned int *)v3;
  uint64_t v7 = v6[29];

  if (v7 == 2)
  {
    nw_protocol_definition_t v347 = nw_protocol_options_copy_definition(v5);
    v346 = v5;
    if (nw_endpoint_handler_get_minimize_logging(v6))
    {
      if (nw_endpoint_handler_get_logging_disabled(v6))
      {
LABEL_45:
        BOOL v42 = v6;
        int state = v42->state;

        if ((state & 0xFFFFFFFE) == 4)
        {
          uint64_t started = 0;
LABEL_209:

          os_log_type_t v23 = v346;
          goto LABEL_210;
        }
        uint64_t v45 = nw_endpoint_handler_copy_flow(v42);
        char v46 = v45;
        v345 = v45;
        if ((*((unsigned char *)v45 + 32) & 4) != 0)
        {
          uint64_t v63 = (os_unfair_lock_s *)((char *)v45 + 880);
          os_unfair_lock_lock((os_unfair_lock_t)v45 + 220);
          char v64 = *((id *)v46 + 117);
          os_unfair_lock_unlock(v63);
          if (v64) {
            uint64_t started = nw_endpoint_handler_append_and_start_application_protocol(v64, v346);
          }
          else {
            uint64_t started = 0;
          }
          goto LABEL_208;
        }
        uint64_t v47 = v42;
        parameters = v47->parameters;
        uint64_t v48 = v47;

        nw_protocol_stack_t v342 = nw_parameters_copy_default_protocol_stack(parameters);
        nw_protocol_stack_append_application_protocol(v342, v346);
        output_handler = (nw_protocol *)*((void *)v345 + 51);
        if (!output_handler)
        {
          uint64_t v65 = v47;
          BOOL v66 = (*((unsigned char *)v65 + 268) & 0x20) == 0;

          if (v66)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v67 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
            {
              BOOL v68 = v65;

              os_log_type_t v69 = v68;
              BOOL v70 = (*((unsigned char *)v65 + 268) & 1) == 0;

              if (v70) {
                uint64_t v71 = "";
              }
              else {
                uint64_t v71 = "dry-run ";
              }
              nw_endpoint_t v72 = nw_endpoint_handler_copy_endpoint(v69);
              logging_description = nw_endpoint_get_logging_description(v72);
              uint64_t v74 = v69;
              char v75 = v74;
              uint64_t v76 = v42->state;
              if (v76 > 5) {
                char v77 = "unknown-state";
              }
              else {
                char v77 = off_1E523FB38[v76];
              }

              uint64_t v78 = v75;
              uint64_t v79 = v78;
              unsigned int v80 = v6[29];
              char v81 = "path";
              switch(v80)
              {
                case 0u:
                  break;
                case 1u:
                  char v81 = "resolver";
                  break;
                case 2u:
                  char v81 = nw_endpoint_flow_mode_string(v78[31]);
                  break;
                case 3u:
                  char v81 = "proxy";
                  break;
                case 4u:
                  char v81 = "fallback";
                  break;
                case 5u:
                  char v81 = "transform";
                  break;
                default:
                  char v81 = "unknown-mode";
                  break;
              }

              id v135 = v79;
              os_unfair_lock_lock((os_unfair_lock_t)v135 + 28);
              id v136 = v135[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v135 + 28);

              *(_DWORD *)buf = 136447746;
              nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
              __int16 v359 = 2082;
              nw_endpoint_t v360 = v68 + 168;
              __int16 v361 = 2082;
              v362 = v71;
              __int16 v363 = 2082;
              v364 = (void *)logging_description;
              __int16 v365 = 2082;
              v366 = v77;
              __int16 v367 = 2082;
              int v368 = v81;
              __int16 v369 = 2114;
              id v370 = v136;
              _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No previous output handler on flow", buf, 0x48u);
            }
          }
          goto LABEL_206;
        }
        uint64_t v51 = (uint64_t)v345 + 376;
        if (output_handler != *((nw_protocol **)v345 + 90))
        {
          gotLoadHelper_x19__ne_filter_protocol_identifier(v49);
          uint64_t v53 = *(void *)&v47[7].id_str[40];
          while (1)
          {
            char v54 = output_handler;
            identifier = output_handler->identifier;
            char v56 = v53 ? (void *)ne_filter_protocol_identifier_delayInitStub(v52) : 0;
            if (nw_protocols_are_equal(identifier, v56)) {
              break;
            }
            uint64_t v57 = nw_parameters_copy_protocol_options_legacy(parameters, output_handler);
            uint64_t v58 = v57;
            if (v57)
            {
              id v59 = v57;
              id v60 = v59[1];

              uint64_t v61 = (char *)v60;
              if (v61)
              {
                uint64_t v61 = v61;
                BOOL v62 = v61[184] < 0;

                if (v62)
                {
                  uint64_t v58 = v59;
LABEL_91:

                  break;
                }
              }
            }
            else
            {
              uint64_t v61 = 0;
            }
            output_handler = v54->output_handler;
            if (!output_handler) {
              goto LABEL_91;
            }

            uint64_t v51 = (uint64_t)v54;
            if (output_handler == *((nw_protocol **)v345 + 90)) {
              goto LABEL_93;
            }
          }
          output_handler = v54;
        }
LABEL_93:
        uint64_t v82 = nw_protocol_definition_get_identifier(v347);
        nw_endpoint_t v83 = nw_endpoint_handler_copy_endpoint(v48);
        uint64_t protocol_for_definition = nw_endpoint_handler_create_protocol_for_definition((uint64_t)v82, v347, v83, parameters);

        if (!protocol_for_definition)
        {
          uint64_t v88 = v48;
          BOOL v89 = (*((unsigned char *)v88 + 268) & 0x20) == 0;

          if (v89)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v90 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v90, OS_LOG_TYPE_ERROR))
            {
              id_string = nw_endpoint_handler_get_id_string(v88);
              uint64_t v92 = nw_endpoint_handler_dry_run_string(v88);
              nw_endpoint_t v93 = nw_endpoint_handler_copy_endpoint(v88);
              uint64_t v94 = nw_endpoint_get_logging_description(v93);
              uint64_t v95 = nw_endpoint_handler_state_string(v88);
              uint64_t v96 = nw_endpoint_handler_mode_string(v88);
              id v97 = nw_endpoint_handler_copy_current_path(v88);
              *(_DWORD *)buf = 136448002;
              nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
              __int16 v359 = 2082;
              nw_endpoint_t v360 = (char *)id_string;
              __int16 v361 = 2082;
              v362 = v92;
              __int16 v363 = 2082;
              v364 = (void *)v94;
              __int16 v365 = 2082;
              v366 = v95;
              __int16 v367 = 2082;
              int v368 = v96;
              __int16 v369 = 2114;
              id v370 = v97;
              __int16 v371 = 2114;
              nw_protocol_definition_t v372 = v347;
              _os_log_impl(&dword_1830D4000, v90, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to create protocol handler for %{public}@", buf, 0x52u);
            }
          }
          goto LABEL_206;
        }
        nw_endpoint_handler_set_protocol_instance(v48, v346, v347, protocol_for_definition);
        uint64_t v85 = *(void *)(v51 + 32);
        if (v85)
        {
          if (*(_UNKNOWN **)(v85 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v103 = *(void *)(v85 + 88);
            if (v103)
            {
              uint64_t v104 = v103 - 1;
              *(void *)(v85 + 88) = v104;
              if (!v104)
              {
                __int16 v105 = *(void (***)(void))(v85 + 64);
                if (v105)
                {
                  *(void *)(v85 + 64) = 0;
                  v105[2](v105);
                  _Block_release(v105);
                }
                if (*(unsigned char *)(v85 + 72))
                {
                  __int16 v106 = *(const void **)(v85 + 64);
                  if (v106) {
                    _Block_release(v106);
                  }
                }
                free((void *)v85);
              }
            }
          }
          *(void *)(v51 + 32) = 0;
        }
        if (protocol_for_definition != v51)
        {
          uint64_t v86 = *(void **)(protocol_for_definition + 24);
          if (v86 && *v86)
          {
            if (nw_protocol_add_input_handler(protocol_for_definition, v51))
            {
              if (output_handler->handle == &nw_protocol_ref_counted_handle)
              {
                callbacks = output_handler[1].callbacks;
                if (callbacks) {
                  output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                }
                *(void *)os_log_type_t type = output_handler;
                char v87 = v356 | 1;
              }
              else
              {
                *(void *)os_log_type_t type = output_handler;
                char v87 = v356 & 0xFE;
              }
              char v356 = v87;
              if (*(_UNKNOWN **)(v51 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v112 = *(void *)(v51 + 88);
                if (v112) {
                  *(void *)(v51 + 88) = v112 + 1;
                }
                uint64_t v353 = v51;
                char v111 = v354 | 1;
              }
              else
              {
                uint64_t v353 = v51;
                char v111 = v354 & 0xFE;
              }
              char v354 = v111;
              if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v114 = *(void *)(protocol_for_definition + 88);
                if (v114) {
                  *(void *)(protocol_for_definition + 88) = v114 + 1;
                }
                *(void *)os_log_type_t v350 = protocol_for_definition;
                char v113 = v351 | 1;
              }
              else
              {
                *(void *)os_log_type_t v350 = protocol_for_definition;
                char v113 = v351 & 0xFE;
              }
              char v351 = v113;
              id v115 = output_handler->callbacks;
              if (v115)
              {
                replace_input_handler = (uint64_t (*)(nw_protocol *, uint64_t, uint64_t))v115->replace_input_handler;
                if (replace_input_handler)
                {
                  char v117 = replace_input_handler(output_handler, v51, protocol_for_definition);
                  if ((v351 & 1) == 0) {
                    goto LABEL_147;
                  }
                  goto LABEL_146;
                }
              }
              nw_endpoint_t v288 = __nwlog_obj();
              name = output_handler->identifier->name;
              *(_DWORD *)buf = 136446722;
              nw_endpoint_t v358 = "__nw_protocol_replace_input_handler";
              if (!name) {
                name = "invalid";
              }
              __int16 v359 = 2082;
              nw_endpoint_t v360 = (char *)name;
              __int16 v361 = 2048;
              v362 = (const char *)output_handler;
              unsigned int log = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v352 = OS_LOG_TYPE_ERROR;
              char v349 = 0;
              if (__nwlog_fault(log, &v352, &v349))
              {
                if (v352 == OS_LOG_TYPE_FAULT)
                {
                  v290 = __nwlog_obj();
                  os_log_type_t v291 = v352;
                  if (os_log_type_enabled(v290, v352))
                  {
                    id v292 = output_handler->identifier->name;
                    if (!v292) {
                      id v292 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    nw_endpoint_t v358 = "__nw_protocol_replace_input_handler";
                    __int16 v359 = 2082;
                    nw_endpoint_t v360 = (char *)v292;
                    __int16 v361 = 2048;
                    v362 = (const char *)output_handler;
                    _os_log_impl(&dword_1830D4000, v290, v291, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback", buf, 0x20u);
                  }
LABEL_345:

                  goto LABEL_379;
                }
                if (!v349)
                {
                  v290 = __nwlog_obj();
                  os_log_type_t v309 = v352;
                  if (os_log_type_enabled(v290, v352))
                  {
                    id v310 = output_handler->identifier->name;
                    if (!v310) {
                      id v310 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    nw_endpoint_t v358 = "__nw_protocol_replace_input_handler";
                    __int16 v359 = 2082;
                    nw_endpoint_t v360 = (char *)v310;
                    __int16 v361 = 2048;
                    v362 = (const char *)output_handler;
                    _os_log_impl(&dword_1830D4000, v290, v309, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded", buf, 0x20u);
                  }
                  goto LABEL_345;
                }
                v299 = (char *)__nw_create_backtrace_string();
                v300 = __nwlog_obj();
                os_log_type_t v301 = v352;
                BOOL v302 = os_log_type_enabled(v300, v352);
                if (v299)
                {
                  if (v302)
                  {
                    BOOL v303 = output_handler->identifier->name;
                    if (!v303) {
                      BOOL v303 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    nw_endpoint_t v358 = "__nw_protocol_replace_input_handler";
                    __int16 v359 = 2082;
                    nw_endpoint_t v360 = (char *)v303;
                    __int16 v361 = 2048;
                    v362 = (const char *)output_handler;
                    __int16 v363 = 2082;
                    v364 = v299;
                    _os_log_impl(&dword_1830D4000, v300, v301, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }

                  free(v299);
                }
                else
                {
                  if (v302)
                  {
                    v311 = output_handler->identifier->name;
                    if (!v311) {
                      v311 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    nw_endpoint_t v358 = "__nw_protocol_replace_input_handler";
                    __int16 v359 = 2082;
                    nw_endpoint_t v360 = (char *)v311;
                    __int16 v361 = 2048;
                    v362 = (const char *)output_handler;
                    _os_log_impl(&dword_1830D4000, v300, v301, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace", buf, 0x20u);
                  }
                }
              }
LABEL_379:
              if (log) {
                free(log);
              }
              char v117 = 0;
              if ((v113 & 1) == 0)
              {
LABEL_147:
                if (v354)
                {
                  nw::release_if_needed<nw_protocol *>(&v353);
                  if ((v356 & 1) == 0)
                  {
LABEL_150:
                    char logging_disabled = nw_endpoint_handler_get_logging_disabled(v48);
                    if (v117)
                    {
                      if ((logging_disabled & 1) == 0)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        uint64_t v119 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v119, OS_LOG_TYPE_DEBUG))
                        {
                          BOOL v120 = nw_endpoint_handler_get_id_string(v48);
                          os_log_type_t v325 = nw_endpoint_handler_dry_run_string(v48);
                          nw_endpoint_t loga = nw_endpoint_handler_copy_endpoint(v48);
                          BOOL v121 = nw_endpoint_get_logging_description(loga);
                          v122 = nw_endpoint_handler_state_string(v48);
                          BOOL v123 = nw_endpoint_handler_mode_string(v48);
                          id v124 = nw_endpoint_handler_copy_current_path(v48);
                          *(_DWORD *)buf = 136448002;
                          nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                          __int16 v359 = 2082;
                          nw_endpoint_t v360 = (char *)v120;
                          __int16 v361 = 2082;
                          v362 = v325;
                          __int16 v363 = 2082;
                          v364 = (void *)v121;
                          __int16 v365 = 2082;
                          v366 = v122;
                          __int16 v367 = 2082;
                          int v368 = v123;
                          __int16 v369 = 2114;
                          id v370 = v124;
                          __int16 v371 = 2114;
                          nw_protocol_definition_t v372 = v347;
                          _os_log_impl(&dword_1830D4000, v119, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached protocol %{public}@ to connected flow", buf, 0x52u);
                        }
                      }
                      os_log_type_t v125 = v48;
                      v42->int state = 2;

                      v125->event = (nw_endpoint_handler_event_s)262147;
                      nw_endpoint_handler_report(v125, 0, &v125->event.domain, 0);
                      if ((*((unsigned char *)v345 + 33) & 4) != 0)
                      {
                        id v126 = nw_endpoint_handler_copy_association(v125, 0);
                        os_log_type_t v127 = v126;
                        if (v126) {
                          nw_association_mark_flow_disconnected(v126, v125);
                        }
                        *((unsigned char *)v345 + 33) &= ~4u;
                      }
                      uint64_t started = nw_endpoint_flow_connect(v125);
                      goto LABEL_207;
                    }
                    if ((logging_disabled & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      os_log_type_t v128 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v128, OS_LOG_TYPE_ERROR))
                      {
                        os_log_type_t v129 = nw_endpoint_handler_get_id_string(v48);
                        os_log_type_t v324 = nw_endpoint_handler_dry_run_string(v48);
                        BOOL v326 = v129;
                        nw_endpoint_t logb = nw_endpoint_handler_copy_endpoint(v48);
                        v323 = nw_endpoint_get_logging_description(logb);
                        os_log_type_t v130 = nw_endpoint_handler_state_string(v48);
                        os_log_type_t v131 = nw_endpoint_handler_mode_string(v48);
                        id v132 = nw_endpoint_handler_copy_current_path(v48);
                        *(_DWORD *)buf = 136448002;
                        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                        __int16 v359 = 2082;
                        nw_endpoint_t v360 = (char *)v326;
                        __int16 v361 = 2082;
                        v362 = v324;
                        __int16 v363 = 2082;
                        v364 = (void *)v323;
                        __int16 v365 = 2082;
                        v366 = v130;
                        __int16 v367 = 2082;
                        int v368 = v131;
                        __int16 v369 = 2114;
                        id v370 = v132;
                        __int16 v371 = 2114;
                        nw_protocol_definition_t v372 = v347;
                        _os_log_impl(&dword_1830D4000, v128, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to replace flow protocol with protocol %{public}@", buf, 0x52u);
                      }
                    }
                    if (*(_UNKNOWN **)(protocol_for_definition + 40) == &nw_protocol_ref_counted_handle)
                    {
                      uint64_t v157 = *(void *)(protocol_for_definition + 88);
                      if (v157) {
                        *(void *)(protocol_for_definition + 88) = v157 + 1;
                      }
                      *(void *)os_log_type_t type = protocol_for_definition;
                      char v133 = v356 | 1;
                    }
                    else
                    {
                      *(void *)os_log_type_t type = protocol_for_definition;
                      char v133 = v356 & 0xFE;
                    }
                    char v356 = v133;
                    if (*(_UNKNOWN **)(v51 + 40) == &nw_protocol_ref_counted_handle)
                    {
                      uint64_t v159 = *(void *)(v51 + 88);
                      if (v159) {
                        *(void *)(v51 + 88) = v159 + 1;
                      }
                      uint64_t v353 = v51;
                      char v158 = v354 | 1;
                    }
                    else
                    {
                      uint64_t v353 = v51;
                      char v158 = v354 & 0xFE;
                    }
                    char v354 = v158;
                    uint64_t v160 = *(void *)(protocol_for_definition + 24);
                    if (v160)
                    {
                      BOOL v161 = *(uint64_t (**)(uint64_t, uint64_t, void))(v160 + 8);
                      if (v161)
                      {
                        int v162 = v161(protocol_for_definition, v51, 0);
                        if ((v354 & 1) == 0) {
                          goto LABEL_223;
                        }
                        goto LABEL_222;
                      }
                    }
                    v293 = __nwlog_obj();
                    BOOL v294 = *(const char **)(protocol_for_definition + 16);
                    *(_DWORD *)buf = 136446722;
                    nw_endpoint_t v358 = "__nw_protocol_remove_input_handler";
                    if (!v294) {
                      BOOL v294 = "invalid";
                    }
                    __int16 v359 = 2082;
                    nw_endpoint_t v360 = (char *)v294;
                    __int16 v361 = 2048;
                    v362 = (const char *)protocol_for_definition;
                    v295 = (char *)_os_log_send_and_compose_impl();

                    v350[0] = OS_LOG_TYPE_ERROR;
                    os_log_type_t v352 = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v295, v350, &v352))
                    {
                      if (v350[0] == OS_LOG_TYPE_FAULT)
                      {
                        v296 = __nwlog_obj();
                        os_log_type_t v297 = v350[0];
                        if (os_log_type_enabled(v296, v350[0]))
                        {
                          v298 = *(const char **)(protocol_for_definition + 16);
                          if (!v298) {
                            v298 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          nw_endpoint_t v358 = "__nw_protocol_remove_input_handler";
                          __int16 v359 = 2082;
                          nw_endpoint_t v360 = (char *)v298;
                          __int16 v361 = 2048;
                          v362 = (const char *)protocol_for_definition;
                          _os_log_impl(&dword_1830D4000, v296, v297, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback", buf, 0x20u);
                        }
LABEL_354:

                        goto LABEL_393;
                      }
                      if (v352 == OS_LOG_TYPE_DEFAULT)
                      {
                        v296 = __nwlog_obj();
                        os_log_type_t v312 = v350[0];
                        if (os_log_type_enabled(v296, v350[0]))
                        {
                          v313 = *(const char **)(protocol_for_definition + 16);
                          if (!v313) {
                            v313 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          nw_endpoint_t v358 = "__nw_protocol_remove_input_handler";
                          __int16 v359 = 2082;
                          nw_endpoint_t v360 = (char *)v313;
                          __int16 v361 = 2048;
                          v362 = (const char *)protocol_for_definition;
                          _os_log_impl(&dword_1830D4000, v296, v312, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded", buf, 0x20u);
                        }
                        goto LABEL_354;
                      }
                      v304 = (char *)__nw_create_backtrace_string();
                      v305 = __nwlog_obj();
                      os_log_type_t v306 = v350[0];
                      BOOL v307 = os_log_type_enabled(v305, v350[0]);
                      if (v304)
                      {
                        if (v307)
                        {
                          v308 = *(const char **)(protocol_for_definition + 16);
                          if (!v308) {
                            v308 = "invalid";
                          }
                          *(_DWORD *)buf = 136446978;
                          nw_endpoint_t v358 = "__nw_protocol_remove_input_handler";
                          __int16 v359 = 2082;
                          nw_endpoint_t v360 = (char *)v308;
                          __int16 v361 = 2048;
                          v362 = (const char *)protocol_for_definition;
                          __int16 v363 = 2082;
                          v364 = v304;
                          _os_log_impl(&dword_1830D4000, v305, v306, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                        }

                        free(v304);
                      }
                      else
                      {
                        if (v307)
                        {
                          v314 = *(const char **)(protocol_for_definition + 16);
                          if (!v314) {
                            v314 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          nw_endpoint_t v358 = "__nw_protocol_remove_input_handler";
                          __int16 v359 = 2082;
                          nw_endpoint_t v360 = (char *)v314;
                          __int16 v361 = 2048;
                          v362 = (const char *)protocol_for_definition;
                          _os_log_impl(&dword_1830D4000, v305, v306, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace", buf, 0x20u);
                        }
                      }
                    }
LABEL_393:
                    if (v295) {
                      free(v295);
                    }
                    int v162 = 0;
                    if ((v158 & 1) == 0)
                    {
LABEL_223:
                      if (v356)
                      {
                        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                        if (v162)
                        {
LABEL_225:
                          if (output_handler != (nw_protocol *)v51)
                          {
                            v163 = output_handler->callbacks;
                            if (v163 && v163->add_input_handler)
                            {
                              if (nw_protocol_add_input_handler((uint64_t)output_handler, v51))
                              {
                                int minimize_logging = nw_endpoint_handler_get_minimize_logging(v48);
                                char v165 = nw_endpoint_handler_get_logging_disabled(v48);
                                if (minimize_logging)
                                {
                                  if (v165) {
                                    goto LABEL_206;
                                  }
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                  }
                                  v166 = (id)gconnectionLogObj;
                                  if (os_log_type_enabled(v166, OS_LOG_TYPE_DEBUG))
                                  {
                                    os_log_type_t v315 = nw_endpoint_handler_get_id_string(v48);
                                    v316 = nw_endpoint_handler_dry_run_string(v48);
                                    nw_endpoint_t v317 = nw_endpoint_handler_copy_endpoint(v48);
                                    v318 = nw_endpoint_get_logging_description(v317);
                                    os_log_type_t v319 = v48;
                                    BOOL v320 = nw_endpoint_handler_state_string(v48);
                                    v321 = nw_endpoint_handler_mode_string(v319);
                                    id v322 = nw_endpoint_handler_copy_current_path(v319);
                                    *(_DWORD *)buf = 136448002;
                                    nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                    __int16 v359 = 2082;
                                    nw_endpoint_t v360 = (char *)v315;
                                    __int16 v361 = 2082;
                                    v362 = v316;
                                    __int16 v363 = 2082;
                                    v364 = (void *)v318;
                                    __int16 v365 = 2082;
                                    v366 = v320;
                                    __int16 v367 = 2082;
                                    int v368 = v321;
                                    __int16 v369 = 2114;
                                    id v370 = v322;
                                    __int16 v371 = 2114;
                                    nw_protocol_definition_t v372 = v347;
                                    _os_log_impl(&dword_1830D4000, v166, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Successfully repaired protocol stack after failed %{public}@ insertion", buf, 0x52u);
                                  }
                                }
                                else
                                {
                                  if (v165)
                                  {
LABEL_206:
                                    uint64_t started = 0;
LABEL_207:

                                    char v64 = parameters;
LABEL_208:

                                    goto LABEL_209;
                                  }
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                  }
                                  v166 = (id)gconnectionLogObj;
                                  if (os_log_type_enabled(v166, OS_LOG_TYPE_DEFAULT))
                                  {
                                    os_log_type_t v167 = nw_endpoint_handler_get_id_string(v48);
                                    v168 = nw_endpoint_handler_dry_run_string(v48);
                                    nw_endpoint_t v169 = nw_endpoint_handler_copy_endpoint(v48);
                                    v170 = nw_endpoint_get_logging_description(v169);
                                    os_log_type_t v171 = v48;
                                    id v172 = nw_endpoint_handler_state_string(v48);
                                    v173 = nw_endpoint_handler_mode_string(v171);
                                    id v174 = nw_endpoint_handler_copy_current_path(v171);
                                    *(_DWORD *)buf = 136448002;
                                    nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                    __int16 v359 = 2082;
                                    nw_endpoint_t v360 = (char *)v167;
                                    __int16 v361 = 2082;
                                    v362 = v168;
                                    __int16 v363 = 2082;
                                    v364 = (void *)v170;
                                    __int16 v365 = 2082;
                                    v366 = v172;
                                    __int16 v367 = 2082;
                                    int v368 = v173;
                                    __int16 v369 = 2114;
                                    id v370 = v174;
                                    __int16 v371 = 2114;
                                    nw_protocol_definition_t v372 = v347;
                                    _os_log_impl(&dword_1830D4000, v166, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Successfully repaired protocol stack after failed %{public}@ insertion", buf, 0x52u);
                                  }
                                }

                                goto LABEL_206;
                              }
                            }
                            else
                            {
                              v207 = __nwlog_obj();
                              if (os_log_type_enabled(v207, OS_LOG_TYPE_ERROR))
                              {
                                *(_DWORD *)buf = 136446466;
                                nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                                __int16 v359 = 2048;
                                nw_endpoint_t v360 = (char *)output_handler;
                                _os_log_impl(&dword_1830D4000, v207, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
                              }
                            }
LABEL_300:
                            if (nw_endpoint_handler_get_logging_disabled(v48)) {
                              goto LABEL_206;
                            }
                            if (__nwlog_connection_log::onceToken != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                            }
                            id logh = (id)gconnectionLogObj;
                            v244 = nw_endpoint_handler_get_id_string(v48);
                            id v245 = nw_endpoint_handler_dry_run_string(v48);
                            nw_endpoint_t v246 = nw_endpoint_handler_copy_endpoint(v48);
                            v247 = nw_endpoint_get_logging_description(v246);
                            v248 = nw_endpoint_handler_state_string(v48);
                            v249 = nw_endpoint_handler_mode_string(v48);
                            id v250 = nw_endpoint_handler_copy_current_path(v48);
                            *(_DWORD *)buf = 136447746;
                            nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            __int16 v359 = 2082;
                            nw_endpoint_t v360 = (char *)v244;
                            __int16 v361 = 2082;
                            v362 = v245;
                            __int16 v363 = 2082;
                            v364 = (void *)v247;
                            __int16 v365 = 2082;
                            v366 = v248;
                            __int16 v367 = 2082;
                            int v368 = v249;
                            __int16 v369 = 2114;
                            id v370 = v250;
                            os_log_type_t v182 = (char *)_os_log_send_and_compose_impl();

                            type[0] = OS_LOG_TYPE_ERROR;
                            LOBYTE(v353) = 0;
                            if (__nwlog_fault(v182, type, &v353))
                            {
                              if (type[0] == OS_LOG_TYPE_FAULT)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                }
                                v183 = (id)gconnectionLogObj;
                                os_log_type_t v251 = type[0];
                                if (os_log_type_enabled(v183, type[0]))
                                {
                                  v252 = nw_endpoint_handler_get_id_string(v48);
                                  id v253 = nw_endpoint_handler_dry_run_string(v48);
                                  logi = v183;
                                  nw_endpoint_t v254 = nw_endpoint_handler_copy_endpoint(v48);
                                  v255 = nw_endpoint_get_logging_description(v254);
                                  v256 = v48;
                                  v257 = nw_endpoint_handler_state_string(v48);
                                  nw_endpoint_t v258 = nw_endpoint_handler_mode_string(v256);
                                  id v259 = nw_endpoint_handler_copy_current_path(v256);
                                  *(_DWORD *)buf = 136447746;
                                  nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                  __int16 v359 = 2082;
                                  nw_endpoint_t v360 = (char *)v252;
                                  __int16 v361 = 2082;
                                  v362 = v253;
                                  __int16 v363 = 2082;
                                  v364 = (void *)v255;
                                  __int16 v365 = 2082;
                                  v366 = v257;
                                  __int16 v367 = 2082;
                                  int v368 = v258;
                                  __int16 v369 = 2114;
                                  id v370 = v259;
                                  _os_log_impl(&dword_1830D4000, logi, v251, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol", buf, 0x48u);

                                  v183 = logi;
                                }
LABEL_321:

                                goto LABEL_327;
                              }
                              if (!(_BYTE)v353)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                }
                                v183 = (id)gconnectionLogObj;
                                os_log_type_t v268 = type[0];
                                if (os_log_type_enabled(v183, type[0]))
                                {
                                  v269 = nw_endpoint_handler_get_id_string(v48);
                                  os_log_type_t v270 = nw_endpoint_handler_dry_run_string(v48);
                                  logk = v183;
                                  nw_endpoint_t v271 = nw_endpoint_handler_copy_endpoint(v48);
                                  v272 = nw_endpoint_get_logging_description(v271);
                                  os_log_type_t v273 = v48;
                                  BOOL v274 = nw_endpoint_handler_state_string(v48);
                                  v275 = nw_endpoint_handler_mode_string(v273);
                                  id v276 = nw_endpoint_handler_copy_current_path(v273);
                                  *(_DWORD *)buf = 136447746;
                                  nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                  __int16 v359 = 2082;
                                  nw_endpoint_t v360 = (char *)v269;
                                  __int16 v361 = 2082;
                                  v362 = v270;
                                  __int16 v363 = 2082;
                                  v364 = (void *)v272;
                                  __int16 v365 = 2082;
                                  v366 = v274;
                                  __int16 v367 = 2082;
                                  int v368 = v275;
                                  __int16 v369 = 2114;
                                  id v370 = v276;
                                  _os_log_impl(&dword_1830D4000, logk, v268, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol, backtrace limit exceeded", buf, 0x48u);

                                  v183 = logk;
                                }
                                goto LABEL_321;
                              }
                              v260 = __nw_create_backtrace_string();
                              if (!v260)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                }
                                nw_endpoint_t v277 = (id)gconnectionLogObj;
                                os_log_type_t v278 = type[0];
                                if (os_log_type_enabled(v277, type[0]))
                                {
                                  logl = v277;
                                  v279 = nw_endpoint_handler_get_id_string(v48);
                                  v280 = nw_endpoint_handler_dry_run_string(v48);
                                  nw_endpoint_t v281 = nw_endpoint_handler_copy_endpoint(v48);
                                  v282 = nw_endpoint_get_logging_description(v281);
                                  v283 = v48;
                                  os_log_type_t v284 = nw_endpoint_handler_state_string(v48);
                                  os_log_type_t v285 = nw_endpoint_handler_mode_string(v283);
                                  id v286 = nw_endpoint_handler_copy_current_path(v283);
                                  *(_DWORD *)buf = 136447746;
                                  nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                  __int16 v359 = 2082;
                                  nw_endpoint_t v360 = (char *)v279;
                                  __int16 v361 = 2082;
                                  v362 = v280;
                                  __int16 v363 = 2082;
                                  v364 = (void *)v282;
                                  __int16 v365 = 2082;
                                  v366 = v284;
                                  __int16 v367 = 2082;
                                  int v368 = v285;
                                  __int16 v369 = 2114;
                                  id v370 = v286;
                                  _os_log_impl(&dword_1830D4000, logl, v278, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol, no backtrace", buf, 0x48u);

                                  nw_endpoint_t v277 = logl;
                                }

                                goto LABEL_327;
                              }
                              id v194 = (char *)v260;
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              v195 = (id)gconnectionLogObj;
                              os_log_type_t v261 = type[0];
                              if (os_log_type_enabled(v195, type[0]))
                              {
                                id v262 = nw_endpoint_handler_get_id_string(v48);
                                logj = nw_endpoint_handler_dry_run_string(v48);
                                nw_endpoint_t v328 = nw_endpoint_handler_copy_endpoint(v48);
                                v263 = nw_endpoint_get_logging_description(v328);
                                v264 = v48;
                                v265 = nw_endpoint_handler_state_string(v48);
                                v266 = nw_endpoint_handler_mode_string(v264);
                                id v267 = nw_endpoint_handler_copy_current_path(v264);
                                *(_DWORD *)buf = 136448002;
                                nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                                __int16 v359 = 2082;
                                nw_endpoint_t v360 = (char *)v262;
                                __int16 v361 = 2082;
                                v362 = logj;
                                __int16 v363 = 2082;
                                v364 = (void *)v263;
                                __int16 v365 = 2082;
                                v366 = v265;
                                __int16 v367 = 2082;
                                int v368 = v266;
                                __int16 v369 = 2114;
                                id v370 = v267;
                                __int16 v371 = 2082;
                                nw_protocol_definition_t v372 = (nw_protocol_definition_t)v194;
                                _os_log_impl(&dword_1830D4000, v195, v261, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol, dumping backtrace:%{public}s", buf, 0x52u);
                              }
LABEL_316:

                              free(v194);
                              goto LABEL_327;
                            }
                            goto LABEL_327;
                          }
                          v203 = __nwlog_obj();
                          *(_DWORD *)buf = 136446466;
                          nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                          __int16 v359 = 2048;
                          nw_endpoint_t v360 = (char *)v51;
                          nw_endpoint_t v204 = (char *)_os_log_send_and_compose_impl();

                          type[0] = OS_LOG_TYPE_ERROR;
                          LOBYTE(v353) = 0;
                          if (__nwlog_fault(v204, type, &v353))
                          {
                            if (type[0] == OS_LOG_TYPE_FAULT)
                            {
                              v205 = __nwlog_obj();
                              os_log_type_t v206 = type[0];
                              if (os_log_type_enabled(v205, type[0]))
                              {
                                *(_DWORD *)buf = 136446466;
                                nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                                __int16 v359 = 2048;
                                nw_endpoint_t v360 = (char *)v51;
                                _os_log_impl(&dword_1830D4000, v205, v206, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
                              }
                            }
                            else if ((_BYTE)v353)
                            {
                              unsigned int v212 = (char *)__nw_create_backtrace_string();
                              v205 = __nwlog_obj();
                              os_log_type_t v213 = type[0];
                              BOOL v214 = os_log_type_enabled(v205, type[0]);
                              if (v212)
                              {
                                if (v214)
                                {
                                  *(_DWORD *)buf = 136446722;
                                  nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                                  __int16 v359 = 2048;
                                  nw_endpoint_t v360 = (char *)v51;
                                  __int16 v361 = 2082;
                                  v362 = v212;
                                  _os_log_impl(&dword_1830D4000, v205, v213, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                                }

                                free(v212);
                                goto LABEL_298;
                              }
                              if (v214)
                              {
                                *(_DWORD *)buf = 136446466;
                                nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                                __int16 v359 = 2048;
                                nw_endpoint_t v360 = (char *)v51;
                                _os_log_impl(&dword_1830D4000, v205, v213, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
                              }
                            }
                            else
                            {
                              v205 = __nwlog_obj();
                              os_log_type_t v243 = type[0];
                              if (os_log_type_enabled(v205, type[0]))
                              {
                                *(_DWORD *)buf = 136446466;
                                nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                                __int16 v359 = 2048;
                                nw_endpoint_t v360 = (char *)v51;
                                _os_log_impl(&dword_1830D4000, v205, v243, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
                              }
                            }
                          }
LABEL_298:
                          if (v204) {
                            free(v204);
                          }
                          goto LABEL_300;
                        }
                      }
                      else if (v162)
                      {
                        goto LABEL_225;
                      }
                      if (nw_endpoint_handler_get_logging_disabled(v48)) {
                        goto LABEL_206;
                      }
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      id logc = (id)gconnectionLogObj;
                      v175 = nw_endpoint_handler_get_id_string(v48);
                      os_log_type_t v176 = nw_endpoint_handler_dry_run_string(v48);
                      nw_endpoint_t v177 = nw_endpoint_handler_copy_endpoint(v48);
                      v178 = nw_endpoint_get_logging_description(v177);
                      os_log_type_t v179 = nw_endpoint_handler_state_string(v48);
                      BOOL v180 = nw_endpoint_handler_mode_string(v48);
                      id v181 = nw_endpoint_handler_copy_current_path(v48);
                      *(_DWORD *)buf = 136448002;
                      nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                      __int16 v359 = 2082;
                      nw_endpoint_t v360 = (char *)v175;
                      __int16 v361 = 2082;
                      v362 = v176;
                      __int16 v363 = 2082;
                      v364 = (void *)v178;
                      __int16 v365 = 2082;
                      v366 = v179;
                      __int16 v367 = 2082;
                      int v368 = v180;
                      __int16 v369 = 2114;
                      id v370 = v181;
                      __int16 v371 = 2114;
                      nw_protocol_definition_t v372 = v347;
                      os_log_type_t v182 = (char *)_os_log_send_and_compose_impl();

                      type[0] = OS_LOG_TYPE_ERROR;
                      LOBYTE(v353) = 0;
                      if (__nwlog_fault(v182, type, &v353))
                      {
                        if (type[0] == OS_LOG_TYPE_FAULT)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          v183 = (id)gconnectionLogObj;
                          os_log_type_t v184 = type[0];
                          if (os_log_type_enabled(v183, type[0]))
                          {
                            v185 = nw_endpoint_handler_get_id_string(v48);
                            v186 = nw_endpoint_handler_dry_run_string(v48);
                            logd = v183;
                            nw_endpoint_t v187 = nw_endpoint_handler_copy_endpoint(v48);
                            nw_endpoint_t v188 = nw_endpoint_get_logging_description(v187);
                            v189 = v48;
                            v190 = nw_endpoint_handler_state_string(v48);
                            v191 = nw_endpoint_handler_mode_string(v189);
                            id v192 = nw_endpoint_handler_copy_current_path(v189);
                            *(_DWORD *)buf = 136448002;
                            nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            __int16 v359 = 2082;
                            nw_endpoint_t v360 = (char *)v185;
                            __int16 v361 = 2082;
                            v362 = v186;
                            __int16 v363 = 2082;
                            v364 = (void *)v188;
                            __int16 v365 = 2082;
                            v366 = v190;
                            __int16 v367 = 2082;
                            int v368 = v191;
                            __int16 v369 = 2114;
                            id v370 = v192;
                            __int16 v371 = 2114;
                            nw_protocol_definition_t v372 = v347;
                            _os_log_impl(&dword_1830D4000, logd, v184, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion", buf, 0x52u);

                            v183 = logd;
                          }
                          goto LABEL_321;
                        }
                        if (!(_BYTE)v353)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          v183 = (id)gconnectionLogObj;
                          os_log_type_t v215 = type[0];
                          if (os_log_type_enabled(v183, type[0]))
                          {
                            v216 = nw_endpoint_handler_get_id_string(v48);
                            nw_endpoint_t v217 = nw_endpoint_handler_dry_run_string(v48);
                            logf = v183;
                            nw_endpoint_t v218 = nw_endpoint_handler_copy_endpoint(v48);
                            v219 = nw_endpoint_get_logging_description(v218);
                            v220 = v48;
                            id v221 = nw_endpoint_handler_state_string(v48);
                            v222 = nw_endpoint_handler_mode_string(v220);
                            id v223 = nw_endpoint_handler_copy_current_path(v220);
                            *(_DWORD *)buf = 136448002;
                            nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            __int16 v359 = 2082;
                            nw_endpoint_t v360 = (char *)v216;
                            __int16 v361 = 2082;
                            v362 = v217;
                            __int16 v363 = 2082;
                            v364 = (void *)v219;
                            __int16 v365 = 2082;
                            v366 = v221;
                            __int16 v367 = 2082;
                            int v368 = v222;
                            __int16 v369 = 2114;
                            id v370 = v223;
                            __int16 v371 = 2114;
                            nw_protocol_definition_t v372 = v347;
                            _os_log_impl(&dword_1830D4000, logf, v215, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion, backtrace limit exceeded", buf, 0x52u);

                            v183 = logf;
                          }
                          goto LABEL_321;
                        }
                        v193 = __nw_create_backtrace_string();
                        if (!v193)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          v183 = (id)gconnectionLogObj;
                          os_log_type_t v224 = type[0];
                          if (os_log_type_enabled(v183, type[0]))
                          {
                            v225 = nw_endpoint_handler_get_id_string(v48);
                            v226 = nw_endpoint_handler_dry_run_string(v48);
                            logg = v183;
                            nw_endpoint_t v227 = nw_endpoint_handler_copy_endpoint(v48);
                            id v228 = nw_endpoint_get_logging_description(v227);
                            v229 = v48;
                            v230 = nw_endpoint_handler_state_string(v48);
                            nw_endpoint_t v231 = nw_endpoint_handler_mode_string(v229);
                            id v232 = nw_endpoint_handler_copy_current_path(v229);
                            *(_DWORD *)buf = 136448002;
                            nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                            __int16 v359 = 2082;
                            nw_endpoint_t v360 = (char *)v225;
                            __int16 v361 = 2082;
                            v362 = v226;
                            __int16 v363 = 2082;
                            v364 = (void *)v228;
                            __int16 v365 = 2082;
                            v366 = v230;
                            __int16 v367 = 2082;
                            int v368 = v231;
                            __int16 v369 = 2114;
                            id v370 = v232;
                            __int16 v371 = 2114;
                            nw_protocol_definition_t v372 = v347;
                            _os_log_impl(&dword_1830D4000, logg, v224, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion, no backtrace", buf, 0x52u);

                            v183 = logg;
                          }
                          goto LABEL_321;
                        }
                        id v194 = (char *)v193;
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        v195 = (id)gconnectionLogObj;
                        os_log_type_t v196 = type[0];
                        if (os_log_type_enabled(v195, type[0]))
                        {
                          v197 = nw_endpoint_handler_get_id_string(v48);
                          loge = nw_endpoint_handler_dry_run_string(v48);
                          nw_endpoint_t v327 = nw_endpoint_handler_copy_endpoint(v48);
                          BOOL v198 = nw_endpoint_get_logging_description(v327);
                          v199 = v48;
                          v200 = nw_endpoint_handler_state_string(v48);
                          v201 = nw_endpoint_handler_mode_string(v199);
                          id v202 = nw_endpoint_handler_copy_current_path(v199);
                          *(_DWORD *)buf = 136448258;
                          nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
                          __int16 v359 = 2082;
                          nw_endpoint_t v360 = (char *)v197;
                          __int16 v361 = 2082;
                          v362 = loge;
                          __int16 v363 = 2082;
                          v364 = (void *)v198;
                          __int16 v365 = 2082;
                          v366 = v200;
                          __int16 v367 = 2082;
                          int v368 = v201;
                          __int16 v369 = 2114;
                          id v370 = v202;
                          __int16 v371 = 2114;
                          nw_protocol_definition_t v372 = v347;
                          __int16 v373 = 2082;
                          char v374 = v194;
                          _os_log_impl(&dword_1830D4000, v195, v196, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new %{public}@ insertion, dumping backtrace:%{public}s", buf, 0x5Cu);
                        }
                        goto LABEL_316;
                      }
LABEL_327:
                      if (v182) {
                        free(v182);
                      }
                      goto LABEL_206;
                    }
LABEL_222:
                    nw::release_if_needed<nw_protocol *>(&v353);
                    goto LABEL_223;
                  }
                }
                else if ((v356 & 1) == 0)
                {
                  goto LABEL_150;
                }
                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                goto LABEL_150;
              }
LABEL_146:
              nw::release_if_needed<nw_protocol *>((uint64_t *)v350);
              goto LABEL_147;
            }
          }
          else
          {
            __int16 v102 = __nwlog_obj();
            if (os_log_type_enabled(v102, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
              __int16 v359 = 2048;
              nw_endpoint_t v360 = (char *)protocol_for_definition;
              _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
            }
          }
LABEL_187:
          os_log_type_t v137 = v48;
          BOOL v138 = (*((unsigned char *)v137 + 268) & 0x20) == 0;

          if (v138)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v139 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v139, OS_LOG_TYPE_ERROR))
            {
              v140 = v137;

              __int16 v141 = v140;
              BOOL v142 = (*((unsigned char *)v137 + 268) & 1) == 0;

              if (v142) {
                uint64_t v143 = "";
              }
              else {
                uint64_t v143 = "dry-run ";
              }
              nw_endpoint_t v144 = nw_endpoint_handler_copy_endpoint(v141);
              BOOL v145 = nw_endpoint_get_logging_description(v144);
              v146 = v141;
              v147 = v146;
              uint64_t v148 = v42->state;
              if (v148 > 5) {
                v149 = "unknown-state";
              }
              else {
                v149 = off_1E523FB38[v148];
              }

              v150 = v147;
              v151 = v150;
              unsigned int v152 = v6[29];
              v153 = "path";
              switch(v152)
              {
                case 0u:
                  break;
                case 1u:
                  v153 = "resolver";
                  break;
                case 2u:
                  v153 = nw_endpoint_flow_mode_string(v150[31]);
                  break;
                case 3u:
                  v153 = "proxy";
                  break;
                case 4u:
                  v153 = "fallback";
                  break;
                case 5u:
                  v153 = "transform";
                  break;
                default:
                  v153 = "unknown-mode";
                  break;
              }

              os_log_type_t v154 = v151;
              os_unfair_lock_lock((os_unfair_lock_t)v154 + 28);
              id v155 = v154[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v154 + 28);

              *(_DWORD *)buf = 136448002;
              nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
              __int16 v359 = 2082;
              nw_endpoint_t v360 = v140 + 168;
              __int16 v361 = 2082;
              v362 = v143;
              __int16 v363 = 2082;
              v364 = (void *)v145;
              __int16 v365 = 2082;
              v366 = v149;
              __int16 v367 = 2082;
              int v368 = v153;
              __int16 v369 = 2114;
              id v370 = v155;
              __int16 v371 = 2114;
              nw_protocol_definition_t v372 = v347;
              _os_log_impl(&dword_1830D4000, v139, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach protocol %{public}@", buf, 0x52u);
            }
          }
          goto LABEL_206;
        }
        __int16 v98 = __nwlog_obj();
        *(_DWORD *)buf = 136446466;
        nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
        __int16 v359 = 2048;
        nw_endpoint_t v360 = (char *)v51;
        __int16 v99 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v353) = 0;
        if (__nwlog_fault(v99, type, &v353))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            __int16 v100 = __nwlog_obj();
            os_log_type_t v101 = type[0];
            if (os_log_type_enabled(v100, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
              __int16 v359 = 2048;
              nw_endpoint_t v360 = (char *)v51;
              _os_log_impl(&dword_1830D4000, v100, v101, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
            }
          }
          else if ((_BYTE)v353)
          {
            uint64_t v107 = (char *)__nw_create_backtrace_string();
            __int16 v100 = __nwlog_obj();
            os_log_type_t v108 = type[0];
            BOOL v109 = os_log_type_enabled(v100, type[0]);
            if (v107)
            {
              if (v109)
              {
                *(_DWORD *)buf = 136446722;
                nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
                __int16 v359 = 2048;
                nw_endpoint_t v360 = (char *)v51;
                __int16 v361 = 2082;
                v362 = v107;
                _os_log_impl(&dword_1830D4000, v100, v108, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
              }

              free(v107);
              goto LABEL_185;
            }
            if (v109)
            {
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
              __int16 v359 = 2048;
              nw_endpoint_t v360 = (char *)v51;
              _os_log_impl(&dword_1830D4000, v100, v108, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
            }
          }
          else
          {
            __int16 v100 = __nwlog_obj();
            os_log_type_t v134 = type[0];
            if (os_log_type_enabled(v100, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              nw_endpoint_t v358 = "nw_protocol_utilities_add_input_handler";
              __int16 v359 = 2048;
              nw_endpoint_t v360 = (char *)v51;
              _os_log_impl(&dword_1830D4000, v100, v134, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
            }
          }
        }
LABEL_185:
        if (v99) {
          free(v99);
        }
        goto LABEL_187;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v233 = nw_endpoint_handler_get_id_string(v6);
        v234 = nw_endpoint_handler_dry_run_string(v6);
        nw_endpoint_t v235 = nw_endpoint_handler_copy_endpoint(v6);
        v236 = nw_endpoint_get_logging_description(v235);
        v237 = nw_endpoint_handler_state_string(v6);
        v238 = nw_endpoint_handler_mode_string(v6);
        id v239 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        __int16 v359 = 2082;
        nw_endpoint_t v360 = (char *)v233;
        __int16 v361 = 2082;
        v362 = v234;
        __int16 v363 = 2082;
        v364 = (void *)v236;
        __int16 v365 = 2082;
        v366 = v237;
        __int16 v367 = 2082;
        int v368 = v238;
        __int16 v369 = 2114;
        id v370 = v239;
        __int16 v371 = 2114;
        nw_protocol_definition_t v372 = v347;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Starting protocol %{public}@", buf, 0x52u);
      }
    }
    else
    {
      id v8 = v6;
      char v9 = *((unsigned char *)v8 + 268);

      if ((v9 & 0x20) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        char v11 = v8;

        os_log_type_t v12 = v11;
        char v13 = *((unsigned char *)v8 + 268);

        if (v13) {
          os_log_type_t v14 = "dry-run ";
        }
        else {
          os_log_type_t v14 = "";
        }
        nw_endpoint_t v15 = nw_endpoint_handler_copy_endpoint(v12);
        BOOL v16 = nw_endpoint_get_logging_description(v15);
        id v17 = (char *)(v11 + 42);
        os_log_type_t v18 = v12;
        os_log_type_t v19 = v18;
        uint64_t v20 = v18[30];
        if (v20 > 5) {
          uint64_t v21 = "unknown-state";
        }
        else {
          uint64_t v21 = off_1E523FB38[v20];
        }

        uint64_t v33 = v19;
        char v34 = v33;
        nw_endpoint_t v344 = v15;
        uint64_t v35 = "path";
        switch(v6[29])
        {
          case 0u:
            break;
          case 1u:
            uint64_t v35 = "resolver";
            break;
          case 2u:
            uint64_t v35 = nw_endpoint_flow_mode_string(v33[31]);
            break;
          case 3u:
            uint64_t v35 = "proxy";
            break;
          case 4u:
            uint64_t v35 = "fallback";
            break;
          case 5u:
            uint64_t v35 = "transform";
            break;
          default:
            uint64_t v35 = "unknown-mode";
            break;
        }

        char v39 = v34;
        os_unfair_lock_lock((os_unfair_lock_t)v39 + 28);
        id v40 = v39[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v39 + 28);

        id v41 = v40;
        *(_DWORD *)buf = 136448002;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        __int16 v359 = 2082;
        nw_endpoint_t v360 = v17;
        __int16 v361 = 2082;
        v362 = v14;
        __int16 v363 = 2082;
        v364 = (void *)v16;
        __int16 v365 = 2082;
        v366 = v21;
        __int16 v367 = 2082;
        int v368 = v35;
        __int16 v369 = 2114;
        id v370 = v41;
        __int16 v371 = 2114;
        nw_protocol_definition_t v372 = v347;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Starting protocol %{public}@", buf, 0x52u);
      }
    }

    goto LABEL_45;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v22 = (id)gLogObj;
  os_log_type_t v23 = v5;
  if (v7 > 5) {
    char v24 = "unknown-mode";
  }
  else {
    char v24 = off_1E523FB08[v7];
  }
  *(_DWORD *)buf = 136446722;
  nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
  __int16 v359 = 2082;
  nw_endpoint_t v360 = (char *)v24;
  __int16 v361 = 2082;
  v362 = "flow";
  nw_endpoint_t v25 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v353) = 0;
  if (__nwlog_fault(v25, type, &v353))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (id)gLogObj;
      os_log_type_t v27 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        if (v7 > 5) {
          char v28 = "unknown-mode";
        }
        else {
          char v28 = off_1E523FB08[v7];
        }
        *(_DWORD *)buf = 136446722;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        __int16 v359 = 2082;
        nw_endpoint_t v360 = (char *)v28;
        __int16 v361 = 2082;
        v362 = "flow";
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if ((_BYTE)v353)
    {
      nw_endpoint_t v29 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (id)gLogObj;
      os_log_type_t v30 = type[0];
      BOOL v31 = os_log_type_enabled(v26, type[0]);
      if (v29)
      {
        if (v31)
        {
          if (v7 > 5) {
            char v32 = "unknown-mode";
          }
          else {
            char v32 = off_1E523FB08[v7];
          }
          *(_DWORD *)buf = 136446978;
          nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
          __int16 v359 = 2082;
          nw_endpoint_t v360 = (char *)v32;
          __int16 v361 = 2082;
          v362 = "flow";
          __int16 v363 = 2082;
          v364 = v29;
          _os_log_impl(&dword_1830D4000, v26, v30, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v29);
        if (!v25) {
          goto LABEL_87;
        }
        goto LABEL_86;
      }
      if (v31)
      {
        if (v7 > 5) {
          uint64_t v38 = "unknown-mode";
        }
        else {
          uint64_t v38 = off_1E523FB08[v7];
        }
        *(_DWORD *)buf = 136446722;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        __int16 v359 = 2082;
        nw_endpoint_t v360 = (char *)v38;
        __int16 v361 = 2082;
        v362 = "flow";
        _os_log_impl(&dword_1830D4000, v26, v30, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = (id)gLogObj;
      os_log_type_t v36 = type[0];
      if (os_log_type_enabled(v26, type[0]))
      {
        if (v7 > 5) {
          uint64_t v37 = "unknown-mode";
        }
        else {
          uint64_t v37 = off_1E523FB08[v7];
        }
        *(_DWORD *)buf = 136446722;
        nw_endpoint_t v358 = "nw_endpoint_handler_append_and_start_application_protocol";
        __int16 v359 = 2082;
        nw_endpoint_t v360 = (char *)v37;
        __int16 v361 = 2082;
        v362 = "flow";
        _os_log_impl(&dword_1830D4000, v26, v36, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
  if (v25) {
LABEL_86:
  }
    free(v25);
LABEL_87:
  uint64_t started = 0;
LABEL_210:

  return started;
}

void sub_183C89924(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_start_tls_while_connected(void *a1)
{
  uint64_t v370 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    v189 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
    id v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v350) = 0;
    if (!__nwlog_fault(v22, type, &v350)) {
      goto LABEL_292;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v190 = __nwlog_obj();
      os_log_type_t v191 = type[0];
      if (os_log_type_enabled(v190, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        _os_log_impl(&dword_1830D4000, v190, v191, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v350)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v190 = __nwlog_obj();
      os_log_type_t v215 = type[0];
      BOOL v216 = os_log_type_enabled(v190, type[0]);
      if (backtrace_string)
      {
        if (v216)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
          __int16 v356 = 2082;
          v357 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v190, v215, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_292:
        uint64_t v20 = 0;
        if (!v22) {
          goto LABEL_95;
        }
        goto LABEL_94;
      }
      if (v216)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        _os_log_impl(&dword_1830D4000, v190, v215, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v190 = __nwlog_obj();
      os_log_type_t v241 = type[0];
      if (os_log_type_enabled(v190, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        _os_log_impl(&dword_1830D4000, v190, v241, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_292;
  }
  id v3 = (unsigned int *)v1;
  uint64_t v4 = v3[29];

  if (v4 == 2)
  {
    v345 = v2;
    if (nw_endpoint_handler_get_minimize_logging(v3))
    {
      if (nw_endpoint_handler_get_logging_disabled(v3))
      {
LABEL_45:
        char v39 = v3;
        int state = v39->state;

        if ((state & 0xFFFFFFFE) == 4)
        {
          uint64_t started = 0;
LABEL_200:
          uint64_t v20 = v345;
          goto LABEL_201;
        }
        BOOL v42 = nw_endpoint_handler_copy_flow(v39);
        uint64_t v43 = v42;
        nw_protocol_stack_t v342 = v42;
        if ((*((unsigned char *)v42 + 32) & 4) != 0)
        {
          os_unfair_lock_lock((os_unfair_lock_t)v42 + 220);
          if (*((void *)v43 + 117)) {
            uint64_t started = nw_endpoint_start_tls_while_connected();
          }
          else {
            uint64_t started = 0;
          }
          os_unfair_lock_unlock((os_unfair_lock_t)v43 + 220);
          goto LABEL_199;
        }
        char v44 = v39;
        id v344 = v44[4];
        uint64_t v45 = v44;

        nw_parameters_set_tls(v344, 1);
        char v46 = (void *)nw_protocol_boringssl_copy_definition();
        os_log_type_t v340 = v46;
        os_log_type_t v341 = nw_parameters_copy_protocol_options_for_definition(v344, v46);
        if (v341)
        {
          output_handler = (nw_protocol *)*((void *)v342 + 51);
          if (output_handler)
          {
            uint64_t v49 = (uint64_t)v342 + 376;
            if (output_handler != *((nw_protocol **)v342 + 90))
            {
              gotLoadHelper_x20__ne_filter_protocol_identifier(v47);
              uint64_t v51 = v46[264];
              while (1)
              {
                double v52 = output_handler;
                identifier = output_handler->identifier;
                char v54 = v51 ? (void *)ne_filter_protocol_identifier_delayInitStub(v50) : 0;
                if (nw_protocols_are_equal(identifier, v54)) {
                  break;
                }
                uint64_t v55 = nw_parameters_copy_protocol_options_legacy(v344, output_handler);
                char v56 = v55;
                if (v55)
                {
                  uint64_t v57 = v55;
                  id v58 = v57[1];

                  id v59 = (char *)v58;
                  if (v59)
                  {
                    id v59 = v59;
                    BOOL v60 = v59[184] < 0;

                    if (v60)
                    {
                      char v56 = v57;
LABEL_99:

                      break;
                    }
                  }
                }
                else
                {
                  id v59 = 0;
                }
                output_handler = v52->output_handler;
                if (!output_handler) {
                  goto LABEL_99;
                }

                uint64_t v49 = (uint64_t)v52;
                if (output_handler == *((nw_protocol **)v342 + 90)) {
                  goto LABEL_101;
                }
              }
              output_handler = v52;
            }
LABEL_101:
            uint64_t v86 = nw_protocol_boringssl_identifier();
            if (v86)
            {
              nw_endpoint_t v87 = nw_endpoint_handler_copy_endpoint(v45);
              uint64_t internal = nw_protocol_create_internal(v86, v87, (const char *)v344, 1);

              if (internal)
              {
                nw_endpoint_handler_set_protocol_instance(v45, v341, v340, internal);
                if (internal != v49)
                {
                  BOOL v89 = *(void **)(internal + 24);
                  if (v89 && *v89)
                  {
                    if (nw_protocol_add_input_handler(internal, v49))
                    {
                      if (output_handler->handle == &nw_protocol_ref_counted_handle)
                      {
                        callbacks = output_handler[1].callbacks;
                        if (callbacks) {
                          output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler
                        }
                                                                                + 1);
                        *(void *)os_log_type_t type = output_handler;
                        char v90 = v353 | 1;
                      }
                      else
                      {
                        *(void *)os_log_type_t type = output_handler;
                        char v90 = v353 & 0xFE;
                      }
                      char v353 = v90;
                      if (*(_UNKNOWN **)(v49 + 40) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v120 = *(void *)(v49 + 88);
                        if (v120) {
                          *(void *)(v49 + 88) = v120 + 1;
                        }
                        uint64_t v350 = v49;
                        char v119 = v351 | 1;
                      }
                      else
                      {
                        uint64_t v350 = v49;
                        char v119 = v351 & 0xFE;
                      }
                      char v351 = v119;
                      if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v122 = *(void *)(internal + 88);
                        if (v122) {
                          *(void *)(internal + 88) = v122 + 1;
                        }
                        *(void *)nw_protocol_definition_t v347 = internal;
                        char v121 = v348 | 1;
                      }
                      else
                      {
                        *(void *)nw_protocol_definition_t v347 = internal;
                        char v121 = v348 & 0xFE;
                      }
                      char v348 = v121;
                      BOOL v123 = output_handler->callbacks;
                      if (v123)
                      {
                        replace_input_handler = (uint64_t (*)(nw_protocol *, uint64_t, uint64_t))v123->replace_input_handler;
                        if (replace_input_handler)
                        {
                          char v125 = replace_input_handler(output_handler, v49, internal);
                          if ((v348 & 1) == 0) {
                            goto LABEL_158;
                          }
                          goto LABEL_157;
                        }
                      }
                      id v286 = __nwlog_obj();
                      name = output_handler->identifier->name;
                      *(_DWORD *)buf = 136446722;
                      os_log_type_t v355 = "__nw_protocol_replace_input_handler";
                      if (!name) {
                        name = "invalid";
                      }
                      __int16 v356 = 2082;
                      v357 = (char *)name;
                      __int16 v358 = 2048;
                      __int16 v359 = (const char *)output_handler;
                      unsigned int log = (char *)_os_log_send_and_compose_impl();

                      os_log_type_t v349 = OS_LOG_TYPE_ERROR;
                      char v346 = 0;
                      if (__nwlog_fault(log, &v349, &v346))
                      {
                        if (v349 == OS_LOG_TYPE_FAULT)
                        {
                          nw_endpoint_t v288 = __nwlog_obj();
                          os_log_type_t v289 = v349;
                          if (os_log_type_enabled(v288, v349))
                          {
                            v290 = output_handler->identifier->name;
                            if (!v290) {
                              v290 = "invalid";
                            }
                            *(_DWORD *)buf = 136446722;
                            os_log_type_t v355 = "__nw_protocol_replace_input_handler";
                            __int16 v356 = 2082;
                            v357 = (char *)v290;
                            __int16 v358 = 2048;
                            __int16 v359 = (const char *)output_handler;
                            _os_log_impl(&dword_1830D4000, v288, v289, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback", buf, 0x20u);
                          }
LABEL_336:

                          goto LABEL_370;
                        }
                        if (!v346)
                        {
                          nw_endpoint_t v288 = __nwlog_obj();
                          os_log_type_t v307 = v349;
                          if (os_log_type_enabled(v288, v349))
                          {
                            v308 = output_handler->identifier->name;
                            if (!v308) {
                              v308 = "invalid";
                            }
                            *(_DWORD *)buf = 136446722;
                            os_log_type_t v355 = "__nw_protocol_replace_input_handler";
                            __int16 v356 = 2082;
                            v357 = (char *)v308;
                            __int16 v358 = 2048;
                            __int16 v359 = (const char *)output_handler;
                            _os_log_impl(&dword_1830D4000, v288, v307, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, backtrace limit exceeded", buf, 0x20u);
                          }
                          goto LABEL_336;
                        }
                        os_log_type_t v297 = (char *)__nw_create_backtrace_string();
                        v298 = __nwlog_obj();
                        os_log_type_t v299 = v349;
                        BOOL v300 = os_log_type_enabled(v298, v349);
                        if (v297)
                        {
                          if (v300)
                          {
                            os_log_type_t v301 = output_handler->identifier->name;
                            if (!v301) {
                              os_log_type_t v301 = "invalid";
                            }
                            *(_DWORD *)buf = 136446978;
                            os_log_type_t v355 = "__nw_protocol_replace_input_handler";
                            __int16 v356 = 2082;
                            v357 = (char *)v301;
                            __int16 v358 = 2048;
                            __int16 v359 = (const char *)output_handler;
                            __int16 v360 = 2082;
                            __int16 v361 = v297;
                            _os_log_impl(&dword_1830D4000, v298, v299, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                          }

                          free(v297);
                        }
                        else
                        {
                          if (v300)
                          {
                            os_log_type_t v309 = output_handler->identifier->name;
                            if (!v309) {
                              os_log_type_t v309 = "invalid";
                            }
                            *(_DWORD *)buf = 136446722;
                            os_log_type_t v355 = "__nw_protocol_replace_input_handler";
                            __int16 v356 = 2082;
                            v357 = (char *)v309;
                            __int16 v358 = 2048;
                            __int16 v359 = (const char *)output_handler;
                            _os_log_impl(&dword_1830D4000, v298, v299, "%{public}s protocol %{public}s (%p) has invalid replace_input_handler callback, no backtrace", buf, 0x20u);
                          }
                        }
                      }
LABEL_370:
                      if (log) {
                        free(log);
                      }
                      char v125 = 0;
                      if ((v121 & 1) == 0)
                      {
LABEL_158:
                        if (v351)
                        {
                          nw::release_if_needed<nw_protocol *>(&v350);
                          if ((v353 & 1) == 0)
                          {
LABEL_161:
                            char logging_disabled = nw_endpoint_handler_get_logging_disabled(v45);
                            if (v125)
                            {
                              if ((logging_disabled & 1) == 0)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                }
                                os_log_type_t v127 = (id)gconnectionLogObj;
                                if (os_log_type_enabled(v127, OS_LOG_TYPE_DEBUG))
                                {
                                  id_string = nw_endpoint_handler_get_id_string(v45);
                                  v323 = nw_endpoint_handler_dry_run_string(v45);
                                  nw_endpoint_t loga = nw_endpoint_handler_copy_endpoint(v45);
                                  logging_description = nw_endpoint_get_logging_description(loga);
                                  os_log_type_t v130 = nw_endpoint_handler_state_string(v45);
                                  os_log_type_t v131 = nw_endpoint_handler_mode_string(v45);
                                  id v132 = nw_endpoint_handler_copy_current_path(v45);
                                  *(_DWORD *)buf = 136447746;
                                  os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                  __int16 v356 = 2082;
                                  v357 = (char *)id_string;
                                  __int16 v358 = 2082;
                                  __int16 v359 = v323;
                                  __int16 v360 = 2082;
                                  __int16 v361 = (void *)logging_description;
                                  __int16 v362 = 2082;
                                  __int16 v363 = v130;
                                  __int16 v364 = 2082;
                                  __int16 v365 = v131;
                                  __int16 v366 = 2114;
                                  id v367 = v132;
                                  _os_log_impl(&dword_1830D4000, v127, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Attached TLS protocol to connected flow", buf, 0x48u);
                                }
                              }
                              char v133 = v45;
                              v39->int state = 2;

                              *((_DWORD *)v133 + 20) = 262147;
                              nw_endpoint_handler_report(v133, 0, (_WORD *)v133 + 40, 0);
                              if ((*((unsigned char *)v342 + 33) & 4) != 0)
                              {
                                id v134 = nw_endpoint_handler_copy_association(v133, 0);
                                id v135 = v134;
                                if (v134) {
                                  nw_association_mark_flow_disconnected(v134, v133);
                                }
                                *((unsigned char *)v342 + 33) &= ~4u;
                              }
                              uint64_t started = nw_endpoint_flow_connect(v133);
                              goto LABEL_198;
                            }
                            if ((logging_disabled & 1) == 0)
                            {
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              id v136 = (id)gconnectionLogObj;
                              if (os_log_type_enabled(v136, OS_LOG_TYPE_ERROR))
                              {
                                os_log_type_t v137 = nw_endpoint_handler_get_id_string(v45);
                                id v322 = nw_endpoint_handler_dry_run_string(v45);
                                os_log_type_t v324 = v137;
                                nw_endpoint_t logb = nw_endpoint_handler_copy_endpoint(v45);
                                v321 = nw_endpoint_get_logging_description(logb);
                                BOOL v138 = nw_endpoint_handler_state_string(v45);
                                v139 = nw_endpoint_handler_mode_string(v45);
                                id v140 = nw_endpoint_handler_copy_current_path(v45);
                                *(_DWORD *)buf = 136447746;
                                os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                __int16 v356 = 2082;
                                v357 = (char *)v324;
                                __int16 v358 = 2082;
                                __int16 v359 = v322;
                                __int16 v360 = 2082;
                                __int16 v361 = (void *)v321;
                                __int16 v362 = 2082;
                                __int16 v363 = v138;
                                __int16 v364 = 2082;
                                __int16 v365 = v139;
                                __int16 v366 = 2114;
                                id v367 = v140;
                                _os_log_impl(&dword_1830D4000, v136, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to replace flow protocol with TLS protocol", buf, 0x48u);
                              }
                            }
                            if (*(_UNKNOWN **)(internal + 40) == &nw_protocol_ref_counted_handle)
                            {
                              uint64_t v153 = *(void *)(internal + 88);
                              if (v153) {
                                *(void *)(internal + 88) = v153 + 1;
                              }
                              *(void *)os_log_type_t type = internal;
                              char v141 = v353 | 1;
                            }
                            else
                            {
                              *(void *)os_log_type_t type = internal;
                              char v141 = v353 & 0xFE;
                            }
                            char v353 = v141;
                            if (*(_UNKNOWN **)(v49 + 40) == &nw_protocol_ref_counted_handle)
                            {
                              uint64_t v155 = *(void *)(v49 + 88);
                              if (v155) {
                                *(void *)(v49 + 88) = v155 + 1;
                              }
                              uint64_t v350 = v49;
                              char v154 = v351 | 1;
                            }
                            else
                            {
                              uint64_t v350 = v49;
                              char v154 = v351 & 0xFE;
                            }
                            char v351 = v154;
                            uint64_t v156 = *(void *)(internal + 24);
                            if (v156)
                            {
                              uint64_t v157 = *(uint64_t (**)(uint64_t, uint64_t, void))(v156 + 8);
                              if (v157)
                              {
                                int v158 = v157(internal, v49, 0);
                                if ((v351 & 1) == 0) {
                                  goto LABEL_214;
                                }
                                goto LABEL_213;
                              }
                            }
                            os_log_type_t v291 = __nwlog_obj();
                            id v292 = *(const char **)(internal + 16);
                            *(_DWORD *)buf = 136446722;
                            os_log_type_t v355 = "__nw_protocol_remove_input_handler";
                            if (!v292) {
                              id v292 = "invalid";
                            }
                            __int16 v356 = 2082;
                            v357 = (char *)v292;
                            __int16 v358 = 2048;
                            __int16 v359 = (const char *)internal;
                            v293 = (char *)_os_log_send_and_compose_impl();

                            v347[0] = OS_LOG_TYPE_ERROR;
                            os_log_type_t v349 = OS_LOG_TYPE_DEFAULT;
                            if (__nwlog_fault(v293, v347, &v349))
                            {
                              if (v347[0] == OS_LOG_TYPE_FAULT)
                              {
                                BOOL v294 = __nwlog_obj();
                                os_log_type_t v295 = v347[0];
                                if (os_log_type_enabled(v294, v347[0]))
                                {
                                  v296 = *(const char **)(internal + 16);
                                  if (!v296) {
                                    v296 = "invalid";
                                  }
                                  *(_DWORD *)buf = 136446722;
                                  os_log_type_t v355 = "__nw_protocol_remove_input_handler";
                                  __int16 v356 = 2082;
                                  v357 = (char *)v296;
                                  __int16 v358 = 2048;
                                  __int16 v359 = (const char *)internal;
                                  _os_log_impl(&dword_1830D4000, v294, v295, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback", buf, 0x20u);
                                }
LABEL_345:

                                goto LABEL_384;
                              }
                              if (v349 == OS_LOG_TYPE_DEFAULT)
                              {
                                BOOL v294 = __nwlog_obj();
                                os_log_type_t v310 = v347[0];
                                if (os_log_type_enabled(v294, v347[0]))
                                {
                                  v311 = *(const char **)(internal + 16);
                                  if (!v311) {
                                    v311 = "invalid";
                                  }
                                  *(_DWORD *)buf = 136446722;
                                  os_log_type_t v355 = "__nw_protocol_remove_input_handler";
                                  __int16 v356 = 2082;
                                  v357 = (char *)v311;
                                  __int16 v358 = 2048;
                                  __int16 v359 = (const char *)internal;
                                  _os_log_impl(&dword_1830D4000, v294, v310, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded", buf, 0x20u);
                                }
                                goto LABEL_345;
                              }
                              BOOL v302 = (char *)__nw_create_backtrace_string();
                              BOOL v303 = __nwlog_obj();
                              os_log_type_t v304 = v347[0];
                              BOOL v305 = os_log_type_enabled(v303, v347[0]);
                              if (v302)
                              {
                                if (v305)
                                {
                                  os_log_type_t v306 = *(const char **)(internal + 16);
                                  if (!v306) {
                                    os_log_type_t v306 = "invalid";
                                  }
                                  *(_DWORD *)buf = 136446978;
                                  os_log_type_t v355 = "__nw_protocol_remove_input_handler";
                                  __int16 v356 = 2082;
                                  v357 = (char *)v306;
                                  __int16 v358 = 2048;
                                  __int16 v359 = (const char *)internal;
                                  __int16 v360 = 2082;
                                  __int16 v361 = v302;
                                  _os_log_impl(&dword_1830D4000, v303, v304, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                                }

                                free(v302);
                              }
                              else
                              {
                                if (v305)
                                {
                                  os_log_type_t v312 = *(const char **)(internal + 16);
                                  if (!v312) {
                                    os_log_type_t v312 = "invalid";
                                  }
                                  *(_DWORD *)buf = 136446722;
                                  os_log_type_t v355 = "__nw_protocol_remove_input_handler";
                                  __int16 v356 = 2082;
                                  v357 = (char *)v312;
                                  __int16 v358 = 2048;
                                  __int16 v359 = (const char *)internal;
                                  _os_log_impl(&dword_1830D4000, v303, v304, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace", buf, 0x20u);
                                }
                              }
                            }
LABEL_384:
                            if (v293) {
                              free(v293);
                            }
                            int v158 = 0;
                            if ((v154 & 1) == 0)
                            {
LABEL_214:
                              if (v353)
                              {
                                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                                if (v158)
                                {
LABEL_216:
                                  if (output_handler != (nw_protocol *)v49)
                                  {
                                    uint64_t v159 = output_handler->callbacks;
                                    if (v159 && v159->add_input_handler)
                                    {
                                      if (nw_protocol_add_input_handler((uint64_t)output_handler, v49))
                                      {
                                        int minimize_logging = nw_endpoint_handler_get_minimize_logging(v45);
                                        char v161 = nw_endpoint_handler_get_logging_disabled(v45);
                                        if (minimize_logging)
                                        {
                                          if (v161) {
                                            goto LABEL_197;
                                          }
                                          if (__nwlog_connection_log::onceToken != -1) {
                                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                          }
                                          int v162 = (id)gconnectionLogObj;
                                          if (os_log_type_enabled(v162, OS_LOG_TYPE_DEBUG))
                                          {
                                            v313 = nw_endpoint_handler_get_id_string(v45);
                                            v314 = nw_endpoint_handler_dry_run_string(v45);
                                            nw_endpoint_t v315 = nw_endpoint_handler_copy_endpoint(v45);
                                            v316 = nw_endpoint_get_logging_description(v315);
                                            nw_endpoint_t v317 = v45;
                                            v318 = nw_endpoint_handler_state_string(v45);
                                            os_log_type_t v319 = nw_endpoint_handler_mode_string(v317);
                                            id v320 = nw_endpoint_handler_copy_current_path(v317);
                                            *(_DWORD *)buf = 136447746;
                                            os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                            __int16 v356 = 2082;
                                            v357 = (char *)v313;
                                            __int16 v358 = 2082;
                                            __int16 v359 = v314;
                                            __int16 v360 = 2082;
                                            __int16 v361 = (void *)v316;
                                            __int16 v362 = 2082;
                                            __int16 v363 = v318;
                                            __int16 v364 = 2082;
                                            __int16 v365 = v319;
                                            __int16 v366 = 2114;
                                            id v367 = v320;
                                            _os_log_impl(&dword_1830D4000, v162, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Successfully repaired protocol stack after failed TLS insertion", buf, 0x48u);
                                          }
                                          goto LABEL_226;
                                        }
                                        if ((v161 & 1) == 0)
                                        {
                                          if (__nwlog_connection_log::onceToken != -1) {
                                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                          }
                                          int v162 = (id)gconnectionLogObj;
                                          if (os_log_type_enabled(v162, OS_LOG_TYPE_DEFAULT))
                                          {
                                            v163 = nw_endpoint_handler_get_id_string(v45);
                                            v164 = nw_endpoint_handler_dry_run_string(v45);
                                            nw_endpoint_t v165 = nw_endpoint_handler_copy_endpoint(v45);
                                            v166 = nw_endpoint_get_logging_description(v165);
                                            os_log_type_t v167 = v45;
                                            v168 = nw_endpoint_handler_state_string(v45);
                                            nw_endpoint_t v169 = nw_endpoint_handler_mode_string(v167);
                                            id v170 = nw_endpoint_handler_copy_current_path(v167);
                                            *(_DWORD *)buf = 136447746;
                                            os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                            __int16 v356 = 2082;
                                            v357 = (char *)v163;
                                            __int16 v358 = 2082;
                                            __int16 v359 = v164;
                                            __int16 v360 = 2082;
                                            __int16 v361 = (void *)v166;
                                            __int16 v362 = 2082;
                                            __int16 v363 = v168;
                                            __int16 v364 = 2082;
                                            __int16 v365 = v169;
                                            __int16 v366 = 2114;
                                            id v367 = v170;
                                            _os_log_impl(&dword_1830D4000, v162, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Successfully repaired protocol stack after failed TLS insertion", buf, 0x48u);
                                          }
LABEL_226:
                                        }
LABEL_197:
                                        uint64_t started = 0;
LABEL_198:

                                        uint64_t v43 = v342;
LABEL_199:

                                        goto LABEL_200;
                                      }
                                    }
                                    else
                                    {
                                      nw_endpoint_t v217 = __nwlog_obj();
                                      if (os_log_type_enabled(v217, OS_LOG_TYPE_ERROR))
                                      {
                                        *(_DWORD *)buf = 136446466;
                                        os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                                        __int16 v356 = 2048;
                                        v357 = (char *)output_handler;
                                        _os_log_impl(&dword_1830D4000, v217, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
                                      }
                                    }
LABEL_299:
                                    if (nw_endpoint_handler_get_logging_disabled(v45)) {
                                      goto LABEL_197;
                                    }
                                    if (__nwlog_connection_log::onceToken != -1) {
                                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                    }
                                    id logh = (id)gconnectionLogObj;
                                    os_log_type_t v243 = nw_endpoint_handler_get_id_string(v45);
                                    v244 = nw_endpoint_handler_dry_run_string(v45);
                                    nw_endpoint_t v245 = nw_endpoint_handler_copy_endpoint(v45);
                                    nw_endpoint_t v246 = nw_endpoint_get_logging_description(v245);
                                    v247 = nw_endpoint_handler_state_string(v45);
                                    v248 = nw_endpoint_handler_mode_string(v45);
                                    id v249 = nw_endpoint_handler_copy_current_path(v45);
                                    *(_DWORD *)buf = 136447746;
                                    os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                    __int16 v356 = 2082;
                                    v357 = (char *)v243;
                                    __int16 v358 = 2082;
                                    __int16 v359 = v244;
                                    __int16 v360 = 2082;
                                    __int16 v361 = (void *)v246;
                                    __int16 v362 = 2082;
                                    __int16 v363 = v247;
                                    __int16 v364 = 2082;
                                    __int16 v365 = v248;
                                    __int16 v366 = 2114;
                                    id v367 = v249;
                                    v178 = (char *)_os_log_send_and_compose_impl();

                                    type[0] = OS_LOG_TYPE_ERROR;
                                    LOBYTE(v350) = 0;
                                    if (__nwlog_fault(v178, type, &v350))
                                    {
                                      if (type[0] == OS_LOG_TYPE_FAULT)
                                      {
                                        if (__nwlog_connection_log::onceToken != -1) {
                                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                        }
                                        os_log_type_t v179 = (id)gconnectionLogObj;
                                        os_log_type_t v250 = type[0];
                                        if (os_log_type_enabled(v179, type[0]))
                                        {
                                          os_log_type_t v251 = nw_endpoint_handler_get_id_string(v45);
                                          v252 = nw_endpoint_handler_dry_run_string(v45);
                                          logi = v179;
                                          nw_endpoint_t v253 = nw_endpoint_handler_copy_endpoint(v45);
                                          nw_endpoint_t v254 = nw_endpoint_get_logging_description(v253);
                                          v255 = v45;
                                          v256 = nw_endpoint_handler_state_string(v45);
                                          v257 = nw_endpoint_handler_mode_string(v255);
                                          id v258 = nw_endpoint_handler_copy_current_path(v255);
                                          *(_DWORD *)buf = 136447746;
                                          os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                          __int16 v356 = 2082;
                                          v357 = (char *)v251;
                                          __int16 v358 = 2082;
                                          __int16 v359 = v252;
                                          __int16 v360 = 2082;
                                          __int16 v361 = (void *)v254;
                                          __int16 v362 = 2082;
                                          __int16 v363 = v256;
                                          __int16 v364 = 2082;
                                          __int16 v365 = v257;
                                          __int16 v366 = 2114;
                                          id v367 = v258;
                                          _os_log_impl(&dword_1830D4000, logi, v250, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol", buf, 0x48u);

                                          os_log_type_t v179 = logi;
                                        }
LABEL_237:

                                        goto LABEL_326;
                                      }
                                      if ((_BYTE)v350)
                                      {
                                        id v259 = __nw_create_backtrace_string();
                                        if (v259)
                                        {
                                          v193 = (char *)v259;
                                          if (__nwlog_connection_log::onceToken != -1) {
                                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                          }
                                          id v194 = (id)gconnectionLogObj;
                                          os_log_type_t v260 = type[0];
                                          if (os_log_type_enabled(v194, type[0]))
                                          {
                                            logj = v194;
                                            os_log_type_t v261 = nw_endpoint_handler_get_id_string(v45);
                                            BOOL v326 = nw_endpoint_handler_dry_run_string(v45);
                                            nw_endpoint_t v262 = nw_endpoint_handler_copy_endpoint(v45);
                                            v263 = nw_endpoint_get_logging_description(v262);
                                            v264 = v45;
                                            v265 = nw_endpoint_handler_state_string(v45);
                                            v266 = nw_endpoint_handler_mode_string(v45);
                                            id v267 = nw_endpoint_handler_copy_current_path(v264);
                                            *(_DWORD *)buf = 136448002;
                                            os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                            __int16 v356 = 2082;
                                            v357 = (char *)v261;
                                            __int16 v358 = 2082;
                                            __int16 v359 = v326;
                                            __int16 v360 = 2082;
                                            __int16 v361 = (void *)v263;
                                            __int16 v362 = 2082;
                                            __int16 v363 = v265;
                                            __int16 v364 = 2082;
                                            __int16 v365 = v266;
                                            __int16 v366 = 2114;
                                            id v367 = v267;
                                            __int16 v368 = 2082;
                                            __int16 v369 = v193;
                                            _os_log_impl(&dword_1830D4000, logj, v260, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol, dumping backtrace:%{public}s", buf, 0x52u);

                                            id v194 = logj;
                                          }
LABEL_315:

                                          free(v193);
                                          goto LABEL_326;
                                        }
                                        if (__nwlog_connection_log::onceToken != -1) {
                                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                        }
                                        v222 = (id)gconnectionLogObj;
                                        os_log_type_t v277 = type[0];
                                        if (os_log_type_enabled(v222, type[0]))
                                        {
                                          logl = v222;
                                          os_log_type_t v278 = nw_endpoint_handler_get_id_string(v45);
                                          v279 = nw_endpoint_handler_dry_run_string(v45);
                                          nw_endpoint_t v280 = nw_endpoint_handler_copy_endpoint(v45);
                                          nw_endpoint_t v281 = nw_endpoint_get_logging_description(v280);
                                          v282 = v45;
                                          v283 = nw_endpoint_handler_state_string(v45);
                                          os_log_type_t v284 = nw_endpoint_handler_mode_string(v282);
                                          id v285 = nw_endpoint_handler_copy_current_path(v282);
                                          *(_DWORD *)buf = 136447746;
                                          os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                          __int16 v356 = 2082;
                                          v357 = (char *)v278;
                                          __int16 v358 = 2082;
                                          __int16 v359 = v279;
                                          __int16 v360 = 2082;
                                          __int16 v361 = (void *)v281;
                                          __int16 v362 = 2082;
                                          __int16 v363 = v283;
                                          __int16 v364 = 2082;
                                          __int16 v365 = v284;
                                          __int16 v366 = 2114;
                                          id v367 = v285;
                                          _os_log_impl(&dword_1830D4000, logl, v277, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol, no backtrace", buf, 0x48u);

                                          v222 = logl;
                                        }
                                      }
                                      else
                                      {
                                        if (__nwlog_connection_log::onceToken != -1) {
                                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                        }
                                        v222 = (id)gconnectionLogObj;
                                        os_log_type_t v268 = type[0];
                                        if (os_log_type_enabled(v222, type[0]))
                                        {
                                          logk = v222;
                                          v269 = nw_endpoint_handler_get_id_string(v45);
                                          os_log_type_t v270 = nw_endpoint_handler_dry_run_string(v45);
                                          nw_endpoint_t v271 = nw_endpoint_handler_copy_endpoint(v45);
                                          v272 = nw_endpoint_get_logging_description(v271);
                                          os_log_type_t v273 = v45;
                                          BOOL v274 = nw_endpoint_handler_state_string(v45);
                                          v275 = nw_endpoint_handler_mode_string(v273);
                                          id v276 = nw_endpoint_handler_copy_current_path(v273);
                                          *(_DWORD *)buf = 136447746;
                                          os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                          __int16 v356 = 2082;
                                          v357 = (char *)v269;
                                          __int16 v358 = 2082;
                                          __int16 v359 = v270;
                                          __int16 v360 = 2082;
                                          __int16 v361 = (void *)v272;
                                          __int16 v362 = 2082;
                                          __int16 v363 = v274;
                                          __int16 v364 = 2082;
                                          __int16 v365 = v275;
                                          __int16 v366 = 2114;
                                          id v367 = v276;
                                          _os_log_impl(&dword_1830D4000, logk, v268, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not add old input_protocol, backtrace limit exceeded", buf, 0x48u);

                                          v222 = logk;
                                        }
                                      }
LABEL_325:

                                      goto LABEL_326;
                                    }
                                    goto LABEL_326;
                                  }
                                  v203 = __nwlog_obj();
                                  *(_DWORD *)buf = 136446466;
                                  os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                                  __int16 v356 = 2048;
                                  v357 = (char *)v49;
                                  nw_endpoint_t v204 = (char *)_os_log_send_and_compose_impl();

                                  type[0] = OS_LOG_TYPE_ERROR;
                                  LOBYTE(v350) = 0;
                                  if (__nwlog_fault(v204, type, &v350))
                                  {
                                    if (type[0] == OS_LOG_TYPE_FAULT)
                                    {
                                      v205 = __nwlog_obj();
                                      os_log_type_t v206 = type[0];
                                      if (os_log_type_enabled(v205, type[0]))
                                      {
                                        *(_DWORD *)buf = 136446466;
                                        os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                                        __int16 v356 = 2048;
                                        v357 = (char *)v49;
                                        _os_log_impl(&dword_1830D4000, v205, v206, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
                                      }
                                    }
                                    else
                                    {
                                      if ((_BYTE)v350)
                                      {
                                        nw_endpoint_t v218 = (char *)__nw_create_backtrace_string();
                                        v219 = __nwlog_obj();
                                        os_log_type_t v220 = type[0];
                                        BOOL v221 = os_log_type_enabled(v219, type[0]);
                                        if (v218)
                                        {
                                          if (v221)
                                          {
                                            *(_DWORD *)buf = 136446722;
                                            os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                                            __int16 v356 = 2048;
                                            v357 = (char *)v49;
                                            __int16 v358 = 2082;
                                            __int16 v359 = v218;
                                            _os_log_impl(&dword_1830D4000, v219, v220, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                                          }

                                          free(v218);
                                        }
                                        else
                                        {
                                          if (v221)
                                          {
                                            *(_DWORD *)buf = 136446466;
                                            os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                                            __int16 v356 = 2048;
                                            v357 = (char *)v49;
                                            _os_log_impl(&dword_1830D4000, v219, v220, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
                                          }
                                        }
                                        goto LABEL_297;
                                      }
                                      v205 = __nwlog_obj();
                                      os_log_type_t v242 = type[0];
                                      if (os_log_type_enabled(v205, type[0]))
                                      {
                                        *(_DWORD *)buf = 136446466;
                                        os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                                        __int16 v356 = 2048;
                                        v357 = (char *)v49;
                                        _os_log_impl(&dword_1830D4000, v205, v242, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
                                      }
                                    }
                                  }
LABEL_297:
                                  if (v204) {
                                    free(v204);
                                  }
                                  goto LABEL_299;
                                }
                              }
                              else if (v158)
                              {
                                goto LABEL_216;
                              }
                              if (nw_endpoint_handler_get_logging_disabled(v45)) {
                                goto LABEL_197;
                              }
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              id logc = (id)gconnectionLogObj;
                              os_log_type_t v171 = nw_endpoint_handler_get_id_string(v45);
                              id v172 = nw_endpoint_handler_dry_run_string(v45);
                              nw_endpoint_t v173 = nw_endpoint_handler_copy_endpoint(v45);
                              id v174 = nw_endpoint_get_logging_description(v173);
                              v175 = nw_endpoint_handler_state_string(v45);
                              os_log_type_t v176 = nw_endpoint_handler_mode_string(v45);
                              id v177 = nw_endpoint_handler_copy_current_path(v45);
                              *(_DWORD *)buf = 136447746;
                              os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                              __int16 v356 = 2082;
                              v357 = (char *)v171;
                              __int16 v358 = 2082;
                              __int16 v359 = v172;
                              __int16 v360 = 2082;
                              __int16 v361 = (void *)v174;
                              __int16 v362 = 2082;
                              __int16 v363 = v175;
                              __int16 v364 = 2082;
                              __int16 v365 = v176;
                              __int16 v366 = 2114;
                              id v367 = v177;
                              v178 = (char *)_os_log_send_and_compose_impl();

                              type[0] = OS_LOG_TYPE_ERROR;
                              LOBYTE(v350) = 0;
                              if (__nwlog_fault(v178, type, &v350))
                              {
                                if (type[0] == OS_LOG_TYPE_FAULT)
                                {
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                  }
                                  os_log_type_t v179 = (id)gconnectionLogObj;
                                  os_log_type_t v180 = type[0];
                                  if (os_log_type_enabled(v179, type[0]))
                                  {
                                    id v181 = nw_endpoint_handler_get_id_string(v45);
                                    os_log_type_t v182 = nw_endpoint_handler_dry_run_string(v45);
                                    logd = v179;
                                    nw_endpoint_t v183 = nw_endpoint_handler_copy_endpoint(v45);
                                    os_log_type_t v184 = nw_endpoint_get_logging_description(v183);
                                    v185 = v45;
                                    v186 = nw_endpoint_handler_state_string(v45);
                                    nw_endpoint_t v187 = nw_endpoint_handler_mode_string(v185);
                                    id v188 = nw_endpoint_handler_copy_current_path(v185);
                                    *(_DWORD *)buf = 136447746;
                                    os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                    __int16 v356 = 2082;
                                    v357 = (char *)v181;
                                    __int16 v358 = 2082;
                                    __int16 v359 = v182;
                                    __int16 v360 = 2082;
                                    __int16 v361 = (void *)v184;
                                    __int16 v362 = 2082;
                                    __int16 v363 = v186;
                                    __int16 v364 = 2082;
                                    __int16 v365 = v187;
                                    __int16 v366 = 2114;
                                    id v367 = v188;
                                    _os_log_impl(&dword_1830D4000, logd, v180, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new TLS insertion", buf, 0x48u);

                                    os_log_type_t v179 = logd;
                                  }
                                  goto LABEL_237;
                                }
                                if ((_BYTE)v350)
                                {
                                  id v192 = __nw_create_backtrace_string();
                                  if (v192)
                                  {
                                    v193 = (char *)v192;
                                    if (__nwlog_connection_log::onceToken != -1) {
                                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                    }
                                    id v194 = (id)gconnectionLogObj;
                                    os_log_type_t v195 = type[0];
                                    if (os_log_type_enabled(v194, type[0]))
                                    {
                                      loge = v194;
                                      os_log_type_t v196 = nw_endpoint_handler_get_id_string(v45);
                                      os_log_type_t v325 = nw_endpoint_handler_dry_run_string(v45);
                                      nw_endpoint_t v197 = nw_endpoint_handler_copy_endpoint(v45);
                                      BOOL v198 = nw_endpoint_get_logging_description(v197);
                                      v199 = v45;
                                      v200 = nw_endpoint_handler_state_string(v45);
                                      v201 = nw_endpoint_handler_mode_string(v45);
                                      id v202 = nw_endpoint_handler_copy_current_path(v199);
                                      *(_DWORD *)buf = 136448002;
                                      os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                      __int16 v356 = 2082;
                                      v357 = (char *)v196;
                                      __int16 v358 = 2082;
                                      __int16 v359 = v325;
                                      __int16 v360 = 2082;
                                      __int16 v361 = (void *)v198;
                                      __int16 v362 = 2082;
                                      __int16 v363 = v200;
                                      __int16 v364 = 2082;
                                      __int16 v365 = v201;
                                      __int16 v366 = 2114;
                                      id v367 = v202;
                                      __int16 v368 = 2082;
                                      __int16 v369 = v193;
                                      _os_log_impl(&dword_1830D4000, loge, v195, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new TLS insertion, dumping backtrace:%{public}s", buf, 0x52u);

                                      id v194 = loge;
                                    }
                                    goto LABEL_315;
                                  }
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                  }
                                  v222 = (id)gconnectionLogObj;
                                  os_log_type_t v232 = type[0];
                                  if (os_log_type_enabled(v222, type[0]))
                                  {
                                    logg = v222;
                                    v233 = nw_endpoint_handler_get_id_string(v45);
                                    v234 = nw_endpoint_handler_dry_run_string(v45);
                                    nw_endpoint_t v235 = nw_endpoint_handler_copy_endpoint(v45);
                                    v236 = nw_endpoint_get_logging_description(v235);
                                    v237 = v45;
                                    v238 = nw_endpoint_handler_state_string(v45);
                                    id v239 = nw_endpoint_handler_mode_string(v237);
                                    id v240 = nw_endpoint_handler_copy_current_path(v237);
                                    *(_DWORD *)buf = 136447746;
                                    os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                    __int16 v356 = 2082;
                                    v357 = (char *)v233;
                                    __int16 v358 = 2082;
                                    __int16 v359 = v234;
                                    __int16 v360 = 2082;
                                    __int16 v361 = (void *)v236;
                                    __int16 v362 = 2082;
                                    __int16 v363 = v238;
                                    __int16 v364 = 2082;
                                    __int16 v365 = v239;
                                    __int16 v366 = 2114;
                                    id v367 = v240;
                                    _os_log_impl(&dword_1830D4000, logg, v232, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new TLS insertion, no backtrace", buf, 0x48u);

                                    v222 = logg;
                                  }
                                }
                                else
                                {
                                  if (__nwlog_connection_log::onceToken != -1) {
                                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                  }
                                  v222 = (id)gconnectionLogObj;
                                  os_log_type_t v223 = type[0];
                                  if (os_log_type_enabled(v222, type[0]))
                                  {
                                    logf = v222;
                                    os_log_type_t v224 = nw_endpoint_handler_get_id_string(v45);
                                    v225 = nw_endpoint_handler_dry_run_string(v45);
                                    nw_endpoint_t v226 = nw_endpoint_handler_copy_endpoint(v45);
                                    nw_endpoint_t v227 = nw_endpoint_get_logging_description(v226);
                                    id v228 = v45;
                                    v229 = nw_endpoint_handler_state_string(v45);
                                    v230 = nw_endpoint_handler_mode_string(v228);
                                    id v231 = nw_endpoint_handler_copy_current_path(v228);
                                    *(_DWORD *)buf = 136447746;
                                    os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                                    __int16 v356 = 2082;
                                    v357 = (char *)v224;
                                    __int16 v358 = 2082;
                                    __int16 v359 = v225;
                                    __int16 v360 = 2082;
                                    __int16 v361 = (void *)v227;
                                    __int16 v362 = 2082;
                                    __int16 v363 = v229;
                                    __int16 v364 = 2082;
                                    __int16 v365 = v230;
                                    __int16 v366 = 2114;
                                    id v367 = v231;
                                    _os_log_impl(&dword_1830D4000, logf, v223, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to repair protocol stack: Could not undo new TLS insertion, backtrace limit exceeded", buf, 0x48u);

                                    v222 = logf;
                                  }
                                }
                                goto LABEL_325;
                              }
LABEL_326:
                              if (v178) {
                                free(v178);
                              }
                              goto LABEL_197;
                            }
LABEL_213:
                            nw::release_if_needed<nw_protocol *>(&v350);
                            goto LABEL_214;
                          }
                        }
                        else if ((v353 & 1) == 0)
                        {
                          goto LABEL_161;
                        }
                        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                        goto LABEL_161;
                      }
LABEL_157:
                      nw::release_if_needed<nw_protocol *>((uint64_t *)v347);
                      goto LABEL_158;
                    }
                  }
                  else
                  {
                    char v111 = __nwlog_obj();
                    if (os_log_type_enabled(v111, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446466;
                      os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                      __int16 v356 = 2048;
                      v357 = (char *)internal;
                      _os_log_impl(&dword_1830D4000, v111, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
                    }
                  }
LABEL_191:
                  if ((nw_endpoint_handler_get_logging_disabled(v45) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v143 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v143, OS_LOG_TYPE_ERROR))
                    {
                      nw_endpoint_t v144 = nw_endpoint_handler_get_id_string(v45);
                      BOOL v145 = nw_endpoint_handler_dry_run_string(v45);
                      nw_endpoint_t v146 = nw_endpoint_handler_copy_endpoint(v45);
                      v147 = nw_endpoint_get_logging_description(v146);
                      uint64_t v148 = v45;
                      v149 = nw_endpoint_handler_state_string(v45);
                      v150 = nw_endpoint_handler_mode_string(v148);
                      id v151 = nw_endpoint_handler_copy_current_path(v148);
                      *(_DWORD *)buf = 136447746;
                      os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                      __int16 v356 = 2082;
                      v357 = (char *)v144;
                      __int16 v358 = 2082;
                      __int16 v359 = v145;
                      __int16 v360 = 2082;
                      __int16 v361 = (void *)v147;
                      __int16 v362 = 2082;
                      __int16 v363 = v149;
                      __int16 v364 = 2082;
                      __int16 v365 = v150;
                      __int16 v366 = 2114;
                      id v367 = v151;
                      _os_log_impl(&dword_1830D4000, v143, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach TLS protocol", buf, 0x48u);
                    }
                  }
                  goto LABEL_197;
                }
                uint64_t v107 = __nwlog_obj();
                *(_DWORD *)buf = 136446466;
                os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                __int16 v356 = 2048;
                v357 = (char *)v49;
                os_log_type_t v108 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v350) = 0;
                if (__nwlog_fault(v108, type, &v350))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v109 = __nwlog_obj();
                    os_log_type_t v110 = type[0];
                    if (os_log_type_enabled(v109, type[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                      __int16 v356 = 2048;
                      v357 = (char *)v49;
                      _os_log_impl(&dword_1830D4000, v109, v110, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
                    }
                  }
                  else
                  {
                    if ((_BYTE)v350)
                    {
                      uint64_t v112 = (char *)__nw_create_backtrace_string();
                      char v113 = __nwlog_obj();
                      os_log_type_t v114 = type[0];
                      BOOL v115 = os_log_type_enabled(v113, type[0]);
                      if (v112)
                      {
                        if (v115)
                        {
                          *(_DWORD *)buf = 136446722;
                          os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                          __int16 v356 = 2048;
                          v357 = (char *)v49;
                          __int16 v358 = 2082;
                          __int16 v359 = v112;
                          _os_log_impl(&dword_1830D4000, v113, v114, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                        }

                        free(v112);
                      }
                      else
                      {
                        if (v115)
                        {
                          *(_DWORD *)buf = 136446466;
                          os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                          __int16 v356 = 2048;
                          v357 = (char *)v49;
                          _os_log_impl(&dword_1830D4000, v113, v114, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
                        }
                      }
                      goto LABEL_189;
                    }
                    BOOL v109 = __nwlog_obj();
                    os_log_type_t v142 = type[0];
                    if (os_log_type_enabled(v109, type[0]))
                    {
                      *(_DWORD *)buf = 136446466;
                      os_log_type_t v355 = "nw_protocol_utilities_add_input_handler";
                      __int16 v356 = 2048;
                      v357 = (char *)v49;
                      _os_log_impl(&dword_1830D4000, v109, v142, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
                    }
                  }
                }
LABEL_189:
                if (v108) {
                  free(v108);
                }
                goto LABEL_191;
              }
              if (nw_endpoint_handler_get_logging_disabled(v45)) {
                goto LABEL_197;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v63 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                __int16 v99 = nw_endpoint_handler_get_id_string(v45);
                __int16 v100 = nw_endpoint_handler_dry_run_string(v45);
                nw_endpoint_t v101 = nw_endpoint_handler_copy_endpoint(v45);
                __int16 v102 = nw_endpoint_get_logging_description(v101);
                uint64_t v103 = v45;
                uint64_t v104 = nw_endpoint_handler_state_string(v45);
                __int16 v105 = nw_endpoint_handler_mode_string(v103);
                id v106 = nw_endpoint_handler_copy_current_path(v103);
                *(_DWORD *)buf = 136447746;
                os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                __int16 v356 = 2082;
                v357 = (char *)v99;
                __int16 v358 = 2082;
                __int16 v359 = v100;
                __int16 v360 = 2082;
                __int16 v361 = (void *)v102;
                __int16 v362 = 2082;
                __int16 v363 = v104;
                __int16 v364 = 2082;
                __int16 v365 = v105;
                __int16 v366 = 2114;
                id v367 = v106;
                _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find TLS protocol handler", buf, 0x48u);
              }
            }
            else
            {
              if (nw_endpoint_handler_get_logging_disabled(v45)) {
                goto LABEL_197;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v63 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
              {
                char v91 = nw_endpoint_handler_get_id_string(v45);
                uint64_t v92 = nw_endpoint_handler_dry_run_string(v45);
                nw_endpoint_t v93 = nw_endpoint_handler_copy_endpoint(v45);
                uint64_t v94 = nw_endpoint_get_logging_description(v93);
                uint64_t v95 = v45;
                uint64_t v96 = nw_endpoint_handler_state_string(v45);
                id v97 = nw_endpoint_handler_mode_string(v45);
                id v98 = nw_endpoint_handler_copy_current_path(v95);
                *(_DWORD *)buf = 136447746;
                os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
                __int16 v356 = 2082;
                v357 = (char *)v91;
                __int16 v358 = 2082;
                __int16 v359 = v92;
                __int16 v360 = 2082;
                __int16 v361 = (void *)v94;
                __int16 v362 = 2082;
                __int16 v363 = v96;
                __int16 v364 = 2082;
                __int16 v365 = v97;
                __int16 v366 = 2114;
                id v367 = v98;
                _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find TLS protocol identifier", buf, 0x48u);
              }
            }
          }
          else
          {
            uint64_t v74 = v44;
            BOOL v75 = (*((unsigned char *)v74 + 268) & 0x20) == 0;

            if (!v75) {
              goto LABEL_197;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v63 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
            {
              uint64_t v76 = nw_endpoint_handler_get_id_string(v74);
              char v77 = nw_endpoint_handler_dry_run_string(v74);
              nw_endpoint_t v78 = nw_endpoint_handler_copy_endpoint(v74);
              uint64_t v79 = nw_endpoint_get_logging_description(v78);
              unsigned int v80 = nw_endpoint_handler_state_string(v74);
              char v81 = nw_endpoint_handler_mode_string(v74);
              id v82 = nw_endpoint_handler_copy_current_path(v74);
              *(_DWORD *)buf = 136447746;
              os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
              __int16 v356 = 2082;
              v357 = (char *)v76;
              __int16 v358 = 2082;
              __int16 v359 = v77;
              __int16 v360 = 2082;
              __int16 v361 = (void *)v79;
              __int16 v362 = 2082;
              __int16 v363 = v80;
              __int16 v364 = 2082;
              __int16 v365 = v81;
              __int16 v366 = 2114;
              id v367 = v82;
              _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No previous output handler on flow", buf, 0x48u);
            }
          }
        }
        else
        {
          uint64_t v61 = v44;
          BOOL v62 = (*((unsigned char *)v61 + 268) & 0x20) == 0;

          if (!v62) {
            goto LABEL_197;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v63 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v63, OS_LOG_TYPE_ERROR))
          {
            char v64 = v61;

            uint64_t v65 = v64;
            BOOL v66 = (*((unsigned char *)v61 + 268) & 1) == 0;

            if (v66) {
              uint64_t v67 = "";
            }
            else {
              uint64_t v67 = "dry-run ";
            }
            nw_endpoint_t v68 = nw_endpoint_handler_copy_endpoint(v65);
            os_log_type_t v69 = nw_endpoint_get_logging_description(v68);
            BOOL v70 = v65;
            uint64_t v71 = v70;
            uint64_t v72 = v39->state;
            if (v72 > 5) {
              id v73 = "unknown-state";
            }
            else {
              id v73 = off_1E523FB38[v72];
            }

            nw_endpoint_t v83 = v71;
            v84 = v83;
            uint64_t v85 = "path";
            switch(v3[29])
            {
              case 0u:
                break;
              case 1u:
                uint64_t v85 = "resolver";
                break;
              case 2u:
                uint64_t v85 = nw_endpoint_flow_mode_string(v83[31]);
                break;
              case 3u:
                uint64_t v85 = "proxy";
                break;
              case 4u:
                uint64_t v85 = "fallback";
                break;
              case 5u:
                uint64_t v85 = "transform";
                break;
              default:
                uint64_t v85 = "unknown-mode";
                break;
            }

            __int16 v116 = v84;
            os_unfair_lock_lock((os_unfair_lock_t)v116 + 28);
            id v117 = v116[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v116 + 28);

            *(_DWORD *)buf = 136447746;
            os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
            __int16 v356 = 2082;
            v357 = (char *)(v64 + 21);
            __int16 v358 = 2082;
            __int16 v359 = v67;
            __int16 v360 = 2082;
            __int16 v361 = (void *)v69;
            __int16 v362 = 2082;
            __int16 v363 = v73;
            __int16 v364 = 2082;
            __int16 v365 = v85;
            __int16 v366 = 2114;
            id v367 = v117;
            _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] TLS is not configured", buf, 0x48u);
          }
        }

        goto LABEL_197;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v7 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        v207 = nw_endpoint_handler_get_id_string(v3);
        uint64_t v208 = nw_endpoint_handler_dry_run_string(v3);
        nw_endpoint_t v209 = nw_endpoint_handler_copy_endpoint(v3);
        v210 = nw_endpoint_get_logging_description(v209);
        os_log_type_t v211 = nw_endpoint_handler_state_string(v3);
        unsigned int v212 = nw_endpoint_handler_mode_string(v3);
        id v213 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)buf = 136447746;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        __int16 v356 = 2082;
        v357 = (char *)v207;
        __int16 v358 = 2082;
        __int16 v359 = v208;
        __int16 v360 = 2082;
        __int16 v361 = (void *)v210;
        __int16 v362 = 2082;
        __int16 v363 = v211;
        __int16 v364 = 2082;
        __int16 v365 = v212;
        __int16 v366 = 2114;
        id v367 = v213;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);
      }
    }
    else
    {
      uint64_t v5 = v3;
      char v6 = *((unsigned char *)v5 + 268);

      if ((v6 & 0x20) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v7 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_INFO))
      {
        id v8 = v5;

        char v9 = v8;
        char v10 = *((unsigned char *)v5 + 268);

        if (v10) {
          char v11 = "dry-run ";
        }
        else {
          char v11 = "";
        }
        nw_endpoint_t v12 = nw_endpoint_handler_copy_endpoint(v9);
        char v13 = nw_endpoint_get_logging_description(v12);
        os_log_type_t v14 = (char *)(v8 + 42);
        nw_endpoint_t v15 = v9;
        BOOL v16 = v15;
        uint64_t v17 = v15[30];
        if (v17 > 5) {
          os_log_type_t v18 = "unknown-state";
        }
        else {
          os_log_type_t v18 = off_1E523FB38[v17];
        }

        os_log_type_t v30 = v16;
        BOOL v31 = v30;
        nw_endpoint_t v343 = v12;
        char v32 = "path";
        switch(v3[29])
        {
          case 0u:
            break;
          case 1u:
            char v32 = "resolver";
            break;
          case 2u:
            char v32 = nw_endpoint_flow_mode_string(v30[31]);
            break;
          case 3u:
            char v32 = "proxy";
            break;
          case 4u:
            char v32 = "fallback";
            break;
          case 5u:
            char v32 = "transform";
            break;
          default:
            char v32 = "unknown-mode";
            break;
        }

        os_log_type_t v36 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v36 + 28);
        id v37 = v36[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v36 + 28);

        id v38 = v37;
        *(_DWORD *)buf = 136447746;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        __int16 v356 = 2082;
        v357 = v14;
        __int16 v358 = 2082;
        __int16 v359 = v11;
        __int16 v360 = 2082;
        __int16 v361 = (void *)v13;
        __int16 v362 = 2082;
        __int16 v363 = v18;
        __int16 v364 = 2082;
        __int16 v365 = v32;
        __int16 v366 = 2114;
        id v367 = v38;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);
      }
    }

    goto LABEL_45;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v19 = (id)gLogObj;
  uint64_t v20 = v2;
  if (v4 > 5) {
    uint64_t v21 = "unknown-mode";
  }
  else {
    uint64_t v21 = off_1E523FB08[v4];
  }
  *(_DWORD *)buf = 136446722;
  os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
  __int16 v356 = 2082;
  v357 = (char *)v21;
  __int16 v358 = 2082;
  __int16 v359 = "flow";
  id v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v350) = 0;
  if (__nwlog_fault(v22, type, &v350))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        if (v4 > 5) {
          nw_endpoint_t v25 = "unknown-mode";
        }
        else {
          nw_endpoint_t v25 = off_1E523FB08[v4];
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        __int16 v356 = 2082;
        v357 = (char *)v25;
        __int16 v358 = 2082;
        __int16 v359 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if ((_BYTE)v350)
    {
      uint64_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v27 = type[0];
      BOOL v28 = os_log_type_enabled(v23, type[0]);
      if (v26)
      {
        if (v28)
        {
          if (v4 > 5) {
            nw_endpoint_t v29 = "unknown-mode";
          }
          else {
            nw_endpoint_t v29 = off_1E523FB08[v4];
          }
          *(_DWORD *)buf = 136446978;
          os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
          __int16 v356 = 2082;
          v357 = (char *)v29;
          __int16 v358 = 2082;
          __int16 v359 = "flow";
          __int16 v360 = 2082;
          __int16 v361 = v26;
          _os_log_impl(&dword_1830D4000, v23, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v26);
        if (!v22) {
          goto LABEL_95;
        }
        goto LABEL_94;
      }
      if (v28)
      {
        if (v4 > 5) {
          uint64_t v35 = "unknown-mode";
        }
        else {
          uint64_t v35 = off_1E523FB08[v4];
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        __int16 v356 = 2082;
        v357 = (char *)v35;
        __int16 v358 = 2082;
        __int16 v359 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        if (v4 > 5) {
          char v34 = "unknown-mode";
        }
        else {
          char v34 = off_1E523FB08[v4];
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v355 = "nw_endpoint_start_tls_while_connected";
        __int16 v356 = 2082;
        v357 = (char *)v34;
        __int16 v358 = 2082;
        __int16 v359 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
  if (v22) {
LABEL_94:
  }
    free(v22);
LABEL_95:
  uint64_t started = 0;
LABEL_201:

  return started;
}

void sub_183C8CDEC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_channel(void *a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    nw_endpoint_t v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v34 = "nw_endpoint_handler_copy_channel";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v13, &type, &v31)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        char v34 = "nw_endpoint_handler_copy_channel";
        _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v31)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          char v34 = "nw_endpoint_handler_copy_channel";
          __int16 v35 = 2082;
          os_log_type_t v36 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        char v34 = "nw_endpoint_handler_copy_channel";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        char v34 = "nw_endpoint_handler_copy_channel";
        _os_log_impl(&dword_1830D4000, v14, v30, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_42:

    goto LABEL_43;
  }
  id v3 = (unsigned int *)v1;
  uint64_t v4 = v3[29];

  if (v4 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    if (v4 > 5) {
      nw_endpoint_t v12 = "unknown-mode";
    }
    else {
      nw_endpoint_t v12 = off_1E523FB08[v4];
    }
    *(_DWORD *)buf = 136446722;
    char v34 = "nw_endpoint_handler_copy_channel";
    __int16 v35 = 2082;
    os_log_type_t v36 = (void *)v12;
    __int16 v37 = 2082;
    id v38 = "flow";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v13, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          if (v4 > 5) {
            BOOL v16 = "unknown-mode";
          }
          else {
            BOOL v16 = off_1E523FB08[v4];
          }
          *(_DWORD *)buf = 136446722;
          char v34 = "nw_endpoint_handler_copy_channel";
          __int16 v35 = 2082;
          os_log_type_t v36 = (void *)v16;
          __int16 v37 = 2082;
          id v38 = "flow";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v31)
      {
        uint64_t v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v14, type);
        if (v17)
        {
          if (v19)
          {
            if (v4 > 5) {
              uint64_t v20 = "unknown-mode";
            }
            else {
              uint64_t v20 = off_1E523FB08[v4];
            }
            *(_DWORD *)buf = 136446978;
            char v34 = "nw_endpoint_handler_copy_channel";
            __int16 v35 = 2082;
            os_log_type_t v36 = (void *)v20;
            __int16 v37 = 2082;
            id v38 = "flow";
            __int16 v39 = 2082;
            id v40 = v17;
            _os_log_impl(&dword_1830D4000, v14, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v17);
          if (!v13) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }
        if (v19)
        {
          if (v4 > 5) {
            os_log_type_t v23 = "unknown-mode";
          }
          else {
            os_log_type_t v23 = off_1E523FB08[v4];
          }
          *(_DWORD *)buf = 136446722;
          char v34 = "nw_endpoint_handler_copy_channel";
          __int16 v35 = 2082;
          os_log_type_t v36 = (void *)v23;
          __int16 v37 = 2082;
          id v38 = "flow";
          _os_log_impl(&dword_1830D4000, v14, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v14 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v14, type))
        {
          if (v4 > 5) {
            id v22 = "unknown-mode";
          }
          else {
            id v22 = off_1E523FB08[v4];
          }
          *(_DWORD *)buf = 136446722;
          char v34 = "nw_endpoint_handler_copy_channel";
          __int16 v35 = 2082;
          os_log_type_t v36 = (void *)v22;
          __int16 v37 = 2082;
          id v38 = "flow";
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_42;
    }
LABEL_43:
    if (!v13)
    {
LABEL_45:
      id v10 = 0;
      goto LABEL_46;
    }
LABEL_44:
    free(v13);
    goto LABEL_45;
  }
  uint64_t v5 = v3;
  char v6 = v5->parameters;

  id v7 = nw_parameters_copy_context(v6);
  nw_context_assert_queue(v7);

  id v8 = nw_endpoint_handler_copy_flow(v5);
  char v9 = v8;
  if (*((unsigned char *)v8 + 32) & 2) != 0 || (*((unsigned char *)v8 + 33))
  {
    id v10 = *((id *)v8 + 113);
  }
  else
  {
    os_unfair_lock_lock((os_unfair_lock_t)v8 + 220);
    if (*((void *)v9 + 117)) {
      id v10 = (id)nw_endpoint_handler_copy_channel();
    }
    else {
      id v10 = 0;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)v9 + 220);
  }

LABEL_46:
  return v10;
}

void sub_183C8D78C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_remove_all_interface_options(void *a1)
{
  uint64_t v146 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    unsigned int v80 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v133 = "nw_endpoint_handler_remove_all_interface_options";
    id v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v22, type, &v128)) {
      goto LABEL_158;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (os_log_type_enabled(v81, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        _os_log_impl(&dword_1830D4000, v81, v82, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v128)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v81 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v92 = os_log_type_enabled(v81, type[0]);
      if (backtrace_string)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446466;
          char v133 = "nw_endpoint_handler_remove_all_interface_options";
          __int16 v134 = 2082;
          id_str = backtrace_string;
          _os_log_impl(&dword_1830D4000, v81, v91, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_158:
        uint64_t v20 = 0;
        if (!v22) {
          goto LABEL_109;
        }
        goto LABEL_100;
      }
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        _os_log_impl(&dword_1830D4000, v81, v91, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v81 = __nwlog_obj();
      os_log_type_t v100 = type[0];
      if (os_log_type_enabled(v81, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        _os_log_impl(&dword_1830D4000, v81, v100, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_158;
  }
  id v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode == 2)
  {
    char v125 = v2;
    uint64_t v5 = &unk_1EB267000;
    if (nw_endpoint_handler_get_minimize_logging(v3))
    {
      if (nw_endpoint_handler_get_logging_disabled(v3))
      {
LABEL_45:
        id v38 = nw_endpoint_handler_copy_flow(v3);
        __int16 v39 = (void *)*((void *)v38 + 104);
        if (v39)
        {
          nw_path_flow_registration_remove_all_interface_options(v39);
          id v40 = nw_path_flow_registration_copy_path(*((void **)v38 + 104));
          os_unfair_lock_lock((os_unfair_lock_t)v38 + 220);
          objc_storeStrong((id *)v38 + 2, v40);
          if ((*((unsigned char *)v38 + 33) & 4) != 0) {
            objc_storeStrong((id *)v38 + 1, v40);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)v38 + 220);
          uint64_t v41 = (const char *)*((void *)v38 + 51);
          id v42 = *((id *)v38 + 2);
          if (v41 && (uint64_t v43 = *((void *)v41 + 3)) != 0)
          {
            if (*(void *)(v43 + 168)) {
              BOOL v44 = v42 == 0;
            }
            else {
              BOOL v44 = 1;
            }
            int v45 = !v44;

            if (v45)
            {
              id v46 = *((id *)v38 + 2);
              double v47 = v46;
              uint64_t v48 = (void *)*((void *)v41 + 5);
              if (v48 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v62 = *((void *)v41 + 11);
                if (v62) {
                  *((void *)v41 + 11) = v62 + 1;
                }
                char v49 = -1;
              }
              else
              {
                char v49 = 0;
              }
              *(void *)os_log_type_t type = v41;
              char v131 = v49;
              uint64_t v63 = (void *)*((void *)v38 + 52);
              if (v63 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v65 = *((void *)v38 + 58);
                if (v65) {
                  *((void *)v38 + 58) = v65 + 1;
                }
                char v64 = -1;
              }
              else
              {
                char v64 = 0;
              }
              uint64_t v128 = (uint64_t)v38 + 376;
              char v129 = v64;
              if (v46)
              {
                uint64_t v66 = *((void *)v41 + 3);
                if (v66)
                {
                  uint64_t v67 = *(void (**)(const char *, char *, id))(v66 + 168);
                  if (v67)
                  {
                    v67(v41, (char *)v38 + 376, v46);
LABEL_81:
                    if (v63 == &nw_protocol_ref_counted_handle) {
                      nw::release_if_needed<nw_protocol *>(&v128);
                    }
                    if (v48 == &nw_protocol_ref_counted_handle) {
                      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                    }

                    goto LABEL_107;
                  }
                }
                nw_endpoint_t v93 = __nwlog_obj();
                uint64_t v94 = (const char *)*((void *)v41 + 2);
                *(_DWORD *)buf = 136446722;
                char v133 = "__nw_protocol_updated_path";
                if (!v94) {
                  uint64_t v94 = "invalid";
                }
                __int16 v134 = 2082;
                id_str = (void *)v94;
                __int16 v136 = 2048;
                os_log_type_t v137 = v41;
                uint64_t v95 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v127 = OS_LOG_TYPE_ERROR;
                char v126 = 0;
                if (!__nwlog_fault(v95, &v127, &v126)) {
                  goto LABEL_177;
                }
                uint64_t v96 = v95;
                if (v127 == OS_LOG_TYPE_FAULT)
                {
                  id v97 = __nwlog_obj();
                  os_log_type_t v98 = v127;
                  if (os_log_type_enabled(v97, v127))
                  {
                    __int16 v99 = (const char *)*((void *)v41 + 2);
                    if (!v99) {
                      __int16 v99 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    char v133 = "__nw_protocol_updated_path";
                    __int16 v134 = 2082;
                    id_str = (void *)v99;
                    __int16 v136 = 2048;
                    os_log_type_t v137 = v41;
                    _os_log_impl(&dword_1830D4000, v97, v98, "%{public}s protocol %{public}s (%p) has invalid updated_path callback", buf, 0x20u);
                  }
LABEL_134:

LABEL_176:
                  uint64_t v95 = v96;
                  goto LABEL_177;
                }
                if (!v126)
                {
                  id v97 = __nwlog_obj();
                  os_log_type_t v118 = v127;
                  if (os_log_type_enabled(v97, v127))
                  {
                    char v119 = (const char *)*((void *)v41 + 2);
                    if (!v119) {
                      char v119 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    char v133 = "__nw_protocol_updated_path";
                    __int16 v134 = 2082;
                    id_str = (void *)v119;
                    __int16 v136 = 2048;
                    os_log_type_t v137 = v41;
                    _os_log_impl(&dword_1830D4000, v97, v118, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded", buf, 0x20u);
                  }
                  goto LABEL_134;
                }
                char v111 = (char *)__nw_create_backtrace_string();
                uint64_t v112 = __nwlog_obj();
                os_log_type_t v122 = v127;
                BOOL v113 = os_log_type_enabled(v112, v127);
                if (!v111)
                {
                  if (v113)
                  {
                    uint64_t v120 = (const char *)*((void *)v41 + 2);
                    if (!v120) {
                      uint64_t v120 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    char v133 = "__nw_protocol_updated_path";
                    __int16 v134 = 2082;
                    id_str = (void *)v120;
                    __int16 v136 = 2048;
                    os_log_type_t v137 = v41;
                    _os_log_impl(&dword_1830D4000, v112, v122, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace", buf, 0x20u);
                  }

                  goto LABEL_176;
                }
                if (v113)
                {
                  os_log_type_t v114 = (const char *)*((void *)v41 + 2);
                  if (!v114) {
                    os_log_type_t v114 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  char v133 = "__nw_protocol_updated_path";
                  __int16 v134 = 2082;
                  id_str = (void *)v114;
                  __int16 v136 = 2048;
                  os_log_type_t v137 = v41;
                  __int16 v138 = 2082;
                  v139 = v111;
                  _os_log_impl(&dword_1830D4000, v112, v122, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                uint64_t v95 = v96;
                free(v111);
              }
              else
              {
                os_log_type_t v108 = __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                char v133 = "__nw_protocol_updated_path";
                uint64_t v95 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v127 = OS_LOG_TYPE_ERROR;
                char v126 = 0;
                if (__nwlog_fault(v95, &v127, &v126))
                {
                  if (v127 == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v109 = __nwlog_obj();
                    os_log_type_t v110 = v127;
                    if (os_log_type_enabled(v109, v127))
                    {
                      *(_DWORD *)buf = 136446210;
                      char v133 = "__nw_protocol_updated_path";
                      _os_log_impl(&dword_1830D4000, v109, v110, "%{public}s called with null path", buf, 0xCu);
                    }
                  }
                  else if (v126)
                  {
                    BOOL v115 = (char *)__nw_create_backtrace_string();
                    BOOL v109 = __nwlog_obj();
                    os_log_type_t v116 = v127;
                    BOOL v117 = os_log_type_enabled(v109, v127);
                    if (v115)
                    {
                      if (v117)
                      {
                        *(_DWORD *)buf = 136446466;
                        char v133 = "__nw_protocol_updated_path";
                        __int16 v134 = 2082;
                        id_str = v115;
                        _os_log_impl(&dword_1830D4000, v109, v116, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      free(v115);
                      if (!v95) {
                        goto LABEL_81;
                      }
                      goto LABEL_178;
                    }
                    if (v117)
                    {
                      *(_DWORD *)buf = 136446210;
                      char v133 = "__nw_protocol_updated_path";
                      _os_log_impl(&dword_1830D4000, v109, v116, "%{public}s called with null path, no backtrace", buf, 0xCu);
                    }
                  }
                  else
                  {
                    BOOL v109 = __nwlog_obj();
                    os_log_type_t v121 = v127;
                    if (os_log_type_enabled(v109, v127))
                    {
                      *(_DWORD *)buf = 136446210;
                      char v133 = "__nw_protocol_updated_path";
                      _os_log_impl(&dword_1830D4000, v109, v121, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
                    }
                  }
                }
              }
LABEL_177:
              if (!v95) {
                goto LABEL_81;
              }
LABEL_178:
              free(v95);
              goto LABEL_81;
            }
          }
          else
          {
          }
        }
        else if (nw_endpoint_handler_get_minimize_logging(v3))
        {
          if (nw_endpoint_handler_get_logging_disabled(v3)) {
            goto LABEL_108;
          }
          if (v5[191] != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v40 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v3);
            __int16 v102 = nw_endpoint_handler_dry_run_string(v3);
            nw_endpoint_t v103 = nw_endpoint_handler_copy_endpoint(v3);
            logging_description = nw_endpoint_get_logging_description(v103);
            __int16 v105 = nw_endpoint_handler_state_string(v3);
            id v106 = nw_endpoint_handler_mode_string(v3);
            id v107 = nw_endpoint_handler_copy_current_path(v3);
            *(_DWORD *)buf = 136447746;
            char v133 = "nw_endpoint_handler_remove_all_interface_options";
            __int16 v134 = 2082;
            id_str = (void *)id_string;
            __int16 v136 = 2082;
            os_log_type_t v137 = v102;
            __int16 v138 = 2082;
            v139 = (void *)logging_description;
            __int16 v140 = 2082;
            char v141 = v105;
            __int16 v142 = 2082;
            uint64_t v143 = v106;
            __int16 v144 = 2114;
            id v145 = v107;
            _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping removing all interface option details, no active flow registration", buf, 0x48u);
          }
        }
        else
        {
          double v50 = v3;
          BOOL v51 = (*((unsigned char *)v50 + 268) & 0x20) == 0;

          if (!v51)
          {
LABEL_108:

            uint64_t v20 = v125;
            goto LABEL_109;
          }
          if (v5[191] != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v40 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            double v52 = v50;

            uint64_t v53 = v52;
            BOOL v54 = (*((unsigned char *)v50 + 268) & 1) == 0;

            if (v54) {
              uint64_t v55 = "";
            }
            else {
              uint64_t v55 = "dry-run ";
            }
            nw_endpoint_t v56 = nw_endpoint_handler_copy_endpoint(v53);
            uint64_t v57 = nw_endpoint_get_logging_description(v56);
            id v58 = v53;
            id v59 = v58;
            uint64_t v60 = v58[30];
            if (v60 > 5) {
              uint64_t v61 = "unknown-state";
            }
            else {
              uint64_t v61 = off_1E523FB38[v60];
            }

            nw_endpoint_t v68 = v59;
            os_log_type_t v69 = "path";
            switch(v3->mode)
            {
              case 0:
                break;
              case 1:
                os_log_type_t v69 = "resolver";
                break;
              case 2:
                os_log_type_t v69 = nw_endpoint_flow_mode_string(v68[31]);
                break;
              case 3:
                os_log_type_t v69 = "proxy";
                break;
              case 4:
                os_log_type_t v69 = "fallback";
                break;
              case 5:
                os_log_type_t v69 = "transform";
                break;
              default:
                os_log_type_t v69 = "unknown-mode";
                break;
            }
            id v124 = v69;

            BOOL v70 = v52;
            uint64_t v71 = v40;
            nw_endpoint_t v72 = v56;
            id v73 = v61;
            uint64_t v74 = v55;
            BOOL v75 = v57;
            uint64_t v76 = v68;
            os_unfair_lock_lock((os_unfair_lock_t)v76 + 28);
            id v77 = v76[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v76 + 28);

            nw_endpoint_t v78 = v75;
            nw_endpoint_t v79 = v72;
            id v40 = v71;
            *(_DWORD *)buf = 136447746;
            char v133 = "nw_endpoint_handler_remove_all_interface_options";
            __int16 v134 = 2082;
            id_str = v70->id_str;
            __int16 v136 = 2082;
            os_log_type_t v137 = v74;
            __int16 v138 = 2082;
            v139 = (void *)v78;
            __int16 v140 = 2082;
            char v141 = v73;
            __int16 v142 = 2082;
            uint64_t v143 = v124;
            __int16 v144 = 2114;
            id v145 = v77;
            _os_log_impl(&dword_1830D4000, v71, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping removing all interface option details, no active flow registration", buf, 0x48u);
          }
        }
LABEL_107:

        goto LABEL_108;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v8 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
      {
        nw_endpoint_t v83 = nw_endpoint_handler_get_id_string(v3);
        v84 = nw_endpoint_handler_dry_run_string(v3);
        nw_endpoint_t v85 = nw_endpoint_handler_copy_endpoint(v3);
        uint64_t v86 = nw_endpoint_get_logging_description(v85);
        nw_endpoint_t v87 = nw_endpoint_handler_state_string(v3);
        uint64_t v88 = nw_endpoint_handler_mode_string(v3);
        id v89 = nw_endpoint_handler_copy_current_path(v3);
        *(_DWORD *)buf = 136447746;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        __int16 v134 = 2082;
        id_str = (void *)v83;
        __int16 v136 = 2082;
        os_log_type_t v137 = v84;
        __int16 v138 = 2082;
        v139 = (void *)v86;
        __int16 v140 = 2082;
        char v141 = v87;
        __int16 v142 = 2082;
        uint64_t v143 = v88;
        __int16 v144 = 2114;
        id v145 = v89;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removing all interface option details", buf, 0x48u);

        uint64_t v5 = (void *)&unk_1EB267000;
      }
    }
    else
    {
      char v6 = v3;
      char v7 = *((unsigned char *)v6 + 268);

      if ((v7 & 0x20) != 0) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v8 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_INFO))
      {
        char v9 = v6;

        id v10 = v9;
        char v11 = *((unsigned char *)v6 + 268);

        if (v11) {
          nw_endpoint_t v12 = "dry-run ";
        }
        else {
          nw_endpoint_t v12 = "";
        }
        nw_endpoint_t v13 = nw_endpoint_handler_copy_endpoint(v10);
        os_log_type_t v14 = nw_endpoint_get_logging_description(v13);
        BOOL v123 = v9->id_str;
        os_log_type_t v15 = v10;
        BOOL v16 = v15;
        uint64_t v17 = v15[30];
        if (v17 > 5) {
          os_log_type_t v18 = "unknown-state";
        }
        else {
          os_log_type_t v18 = off_1E523FB38[v17];
        }

        os_log_type_t v30 = v16;
        char v31 = v30;
        char v32 = "path";
        switch(v3->mode)
        {
          case 0:
            break;
          case 1:
            char v32 = "resolver";
            break;
          case 2:
            char v32 = nw_endpoint_flow_mode_string(v30[31]);
            break;
          case 3:
            char v32 = "proxy";
            break;
          case 4:
            char v32 = "fallback";
            break;
          case 5:
            char v32 = "transform";
            break;
          default:
            char v32 = "unknown-mode";
            break;
        }

        os_log_type_t v36 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v36 + 28);
        id v37 = v36[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v36 + 28);

        *(_DWORD *)buf = 136447746;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        __int16 v134 = 2082;
        id_str = v123;
        __int16 v136 = 2082;
        os_log_type_t v137 = v12;
        __int16 v138 = 2082;
        v139 = (void *)v14;
        __int16 v140 = 2082;
        char v141 = v18;
        __int16 v142 = 2082;
        uint64_t v143 = v32;
        __int16 v144 = 2114;
        id v145 = v37;
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removing all interface option details", buf, 0x48u);

        uint64_t v5 = &unk_1EB267000;
      }
    }

    goto LABEL_45;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v19 = (id)gLogObj;
  uint64_t v20 = v2;
  if (mode > 5) {
    os_log_type_t v21 = "unknown-mode";
  }
  else {
    os_log_type_t v21 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  char v133 = "nw_endpoint_handler_remove_all_interface_options";
  __int16 v134 = 2082;
  id_str = (void *)v21;
  __int16 v136 = 2082;
  os_log_type_t v137 = "flow";
  id v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v128) = 0;
  if (__nwlog_fault(v22, type, &v128))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        if (mode > 5) {
          nw_endpoint_t v25 = "unknown-mode";
        }
        else {
          nw_endpoint_t v25 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        __int16 v134 = 2082;
        id_str = (void *)v25;
        __int16 v136 = 2082;
        os_log_type_t v137 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if ((_BYTE)v128)
    {
      os_log_type_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v27 = type[0];
      BOOL v28 = os_log_type_enabled(v23, type[0]);
      if (v26)
      {
        if (v28)
        {
          if (mode > 5) {
            BOOL v29 = "unknown-mode";
          }
          else {
            BOOL v29 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446978;
          char v133 = "nw_endpoint_handler_remove_all_interface_options";
          __int16 v134 = 2082;
          id_str = (void *)v29;
          __int16 v136 = 2082;
          os_log_type_t v137 = "flow";
          __int16 v138 = 2082;
          v139 = v26;
          _os_log_impl(&dword_1830D4000, v23, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v26);
        if (v22) {
          goto LABEL_100;
        }
        goto LABEL_109;
      }
      if (v28)
      {
        if (mode > 5) {
          __int16 v35 = "unknown-mode";
        }
        else {
          __int16 v35 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        __int16 v134 = 2082;
        id_str = (void *)v35;
        __int16 v136 = 2082;
        os_log_type_t v137 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        if (mode > 5) {
          char v34 = "unknown-mode";
        }
        else {
          char v34 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        char v133 = "nw_endpoint_handler_remove_all_interface_options";
        __int16 v134 = 2082;
        id_str = (void *)v34;
        __int16 v136 = 2082;
        os_log_type_t v137 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v33, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
  if (v22) {
LABEL_100:
  }
    free(v22);
LABEL_109:
}

void sub_183C8EB20(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_reset_traffic_class(void *a1, int a2)
{
  uint64_t v114 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    uint64_t v57 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
    id v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v96) = 0;
    if (!__nwlog_fault(v22, type, &v96)) {
      goto LABEL_74;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v58 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        _os_log_impl(&dword_1830D4000, v23, v58, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v96)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v60 = type[0];
      BOOL v61 = os_log_type_enabled(v23, type[0]);
      if (backtrace_string)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
          __int16 v102 = 2082;
          nw_endpoint_t v103 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v60, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_74;
      }
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        _os_log_impl(&dword_1830D4000, v23, v60, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v75 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        _os_log_impl(&dword_1830D4000, v23, v75, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_73:

    goto LABEL_74;
  }
  uint64_t v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if (mode == 2)
  {
    char v7 = nw_endpoint_handler_copy_flow(v5);
    id v8 = (void *)*((void *)v7 + 104);
    if (v8)
    {
      char v9 = v8;
      v9[36] = a2;

      id v10 = nw_path_flow_registration_copy_path(*((void **)v7 + 104));
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 220);
      objc_storeStrong((id *)v7 + 2, v10);
      if ((*((unsigned char *)v7 + 33) & 4) != 0) {
        objc_storeStrong((id *)v7 + 1, v10);
      }
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 220);
      char v11 = (const char *)*((void *)v7 + 51);
      id v12 = *((id *)v7 + 2);
      id v13 = v12;
      if (v11 && (uint64_t v14 = *((void *)v11 + 3)) != 0)
      {
        uint64_t v15 = *(void *)(v14 + 168);

        if (v15 && v13)
        {
          id v16 = *((id *)v7 + 2);
          uint64_t v17 = v16;
          os_log_type_t v18 = (void *)*((void *)v11 + 5);
          if (v18 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v45 = *((void *)v11 + 11);
            if (v45) {
              *((void *)v11 + 11) = v45 + 1;
            }
            char v19 = -1;
          }
          else
          {
            char v19 = 0;
          }
          *(void *)os_log_type_t type = v11;
          char v99 = v19;
          id v46 = (void *)*((void *)v7 + 52);
          if (v46 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v48 = *((void *)v7 + 58);
            if (v48) {
              *((void *)v7 + 58) = v48 + 1;
            }
            char v47 = -1;
          }
          else
          {
            char v47 = 0;
          }
          uint64_t v96 = (uint64_t)v7 + 376;
          char v97 = v47;
          if (!v16)
          {
            uint64_t v76 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            nw_endpoint_t v101 = "__nw_protocol_updated_path";
            char v64 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v95 = OS_LOG_TYPE_ERROR;
            char v94 = 0;
            if (__nwlog_fault(v64, &v95, &v94))
            {
              if (v95 == OS_LOG_TYPE_FAULT)
              {
                id v77 = __nwlog_obj();
                os_log_type_t v78 = v95;
                if (os_log_type_enabled(v77, v95))
                {
                  *(_DWORD *)buf = 136446210;
                  nw_endpoint_t v101 = "__nw_protocol_updated_path";
                  _os_log_impl(&dword_1830D4000, v77, v78, "%{public}s called with null path", buf, 0xCu);
                }
              }
              else if (v94)
              {
                nw_endpoint_t v83 = (char *)__nw_create_backtrace_string();
                id v77 = __nwlog_obj();
                os_log_type_t v91 = v95;
                BOOL v84 = os_log_type_enabled(v77, v95);
                if (v83)
                {
                  if (v84)
                  {
                    *(_DWORD *)buf = 136446466;
                    nw_endpoint_t v101 = "__nw_protocol_updated_path";
                    __int16 v102 = 2082;
                    nw_endpoint_t v103 = v83;
                    _os_log_impl(&dword_1830D4000, v77, v91, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v83);
                  if (!v64) {
                    goto LABEL_56;
                  }
                  goto LABEL_146;
                }
                if (v84)
                {
                  *(_DWORD *)buf = 136446210;
                  nw_endpoint_t v101 = "__nw_protocol_updated_path";
                  _os_log_impl(&dword_1830D4000, v77, v91, "%{public}s called with null path, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                id v77 = __nwlog_obj();
                os_log_type_t v88 = v95;
                if (os_log_type_enabled(v77, v95))
                {
                  *(_DWORD *)buf = 136446210;
                  nw_endpoint_t v101 = "__nw_protocol_updated_path";
                  _os_log_impl(&dword_1830D4000, v77, v88, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_145:
            if (!v64) {
              goto LABEL_56;
            }
LABEL_146:
            free(v64);
            goto LABEL_56;
          }
          uint64_t v49 = *((void *)v11 + 3);
          if (v49)
          {
            double v50 = *(void (**)(const char *, char *, id))(v49 + 168);
            if (v50)
            {
              v50(v11, (char *)v7 + 376, v16);
LABEL_56:
              if (v46 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>(&v96);
              }
              if (v18 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              }

              goto LABEL_82;
            }
          }
          uint64_t v62 = __nwlog_obj();
          uint64_t v63 = (const char *)*((void *)v11 + 2);
          *(_DWORD *)buf = 136446722;
          nw_endpoint_t v101 = "__nw_protocol_updated_path";
          if (!v63) {
            uint64_t v63 = "invalid";
          }
          __int16 v102 = 2082;
          nw_endpoint_t v103 = (void *)v63;
          __int16 v104 = 2048;
          __int16 v105 = v11;
          nw_endpoint_t v93 = (const char *)_os_log_send_and_compose_impl();

          os_log_type_t v95 = OS_LOG_TYPE_ERROR;
          char v94 = 0;
          char v64 = (char *)v93;
          if (!__nwlog_fault(v93, &v95, &v94)) {
            goto LABEL_145;
          }
          if (v95 == OS_LOG_TYPE_FAULT)
          {
            uint64_t v65 = __nwlog_obj();
            os_log_type_t v66 = v95;
            if (os_log_type_enabled(v65, v95))
            {
              uint64_t v67 = (const char *)*((void *)v11 + 2);
              if (!v67) {
                uint64_t v67 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              nw_endpoint_t v101 = "__nw_protocol_updated_path";
              __int16 v102 = 2082;
              nw_endpoint_t v103 = (void *)v67;
              __int16 v104 = 2048;
              __int16 v105 = v11;
              _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s protocol %{public}s (%p) has invalid updated_path callback", buf, 0x20u);
            }
          }
          else
          {
            if (v94)
            {
              nw_endpoint_t v79 = (char *)__nw_create_backtrace_string();
              unsigned int v80 = __nwlog_obj();
              os_log_type_t v89 = v95;
              BOOL v81 = os_log_type_enabled(v80, v95);
              if (v79)
              {
                if (v81)
                {
                  os_log_type_t v82 = (const char *)*((void *)v11 + 2);
                  if (!v82) {
                    os_log_type_t v82 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  nw_endpoint_t v101 = "__nw_protocol_updated_path";
                  __int16 v102 = 2082;
                  nw_endpoint_t v103 = (void *)v82;
                  __int16 v104 = 2048;
                  __int16 v105 = v11;
                  __int16 v106 = 2082;
                  id v107 = v79;
                  _os_log_impl(&dword_1830D4000, v80, v89, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                free(v79);
              }
              else
              {
                if (v81)
                {
                  nw_endpoint_t v87 = (const char *)*((void *)v11 + 2);
                  if (!v87) {
                    nw_endpoint_t v87 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  nw_endpoint_t v101 = "__nw_protocol_updated_path";
                  __int16 v102 = 2082;
                  nw_endpoint_t v103 = (void *)v87;
                  __int16 v104 = 2048;
                  __int16 v105 = v11;
                  _os_log_impl(&dword_1830D4000, v80, v89, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, no backtrace", buf, 0x20u);
                }
              }
              goto LABEL_144;
            }
            uint64_t v65 = __nwlog_obj();
            os_log_type_t v85 = v95;
            if (os_log_type_enabled(v65, v95))
            {
              uint64_t v86 = (const char *)*((void *)v11 + 2);
              if (!v86) {
                uint64_t v86 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              nw_endpoint_t v101 = "__nw_protocol_updated_path";
              __int16 v102 = 2082;
              nw_endpoint_t v103 = (void *)v86;
              __int16 v104 = 2048;
              __int16 v105 = v11;
              _os_log_impl(&dword_1830D4000, v65, v85, "%{public}s protocol %{public}s (%p) has invalid updated_path callback, backtrace limit exceeded", buf, 0x20u);
            }
          }

LABEL_144:
          char v64 = (char *)v93;
          goto LABEL_145;
        }
      }
      else
      {
      }
    }
    else if (nw_endpoint_handler_get_minimize_logging(v5))
    {
      if (nw_endpoint_handler_get_logging_disabled(v5)) {
        goto LABEL_83;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        os_log_type_t v69 = nw_endpoint_handler_dry_run_string(v5);
        nw_endpoint_t v70 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v70);
        nw_endpoint_t v72 = nw_endpoint_handler_state_string(v5);
        id v73 = nw_endpoint_handler_mode_string(v5);
        id v74 = nw_endpoint_handler_copy_current_path(v5);
        *(_DWORD *)buf = 136447746;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        __int16 v102 = 2082;
        nw_endpoint_t v103 = (void *)id_string;
        __int16 v104 = 2082;
        __int16 v105 = v69;
        __int16 v106 = 2082;
        id v107 = (void *)logging_description;
        __int16 v108 = 2082;
        BOOL v109 = v72;
        __int16 v110 = 2082;
        char v111 = v73;
        __int16 v112 = 2114;
        id v113 = v74;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping reset of traffic class, no active flow registration", buf, 0x48u);
      }
    }
    else
    {
      os_log_type_t v30 = v5;
      char v31 = *((unsigned char *)v30 + 268);

      if ((v31 & 0x20) != 0)
      {
LABEL_83:

        goto LABEL_84;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        char v32 = v30;

        os_log_type_t v33 = v32;
        char v34 = *((unsigned char *)v30 + 268);

        if (v34) {
          __int16 v35 = "dry-run ";
        }
        else {
          __int16 v35 = "";
        }
        nw_endpoint_t v36 = nw_endpoint_handler_copy_endpoint(v33);
        id v37 = nw_endpoint_get_logging_description(v36);
        nw_endpoint_t v90 = v36;
        id_str = v32->id_str;
        id v38 = v33;
        __int16 v39 = v38;
        uint64_t v40 = v38[30];
        if (v40 > 5) {
          uint64_t v41 = "unknown-state";
        }
        else {
          uint64_t v41 = off_1E523FB38[v40];
        }

        BOOL v51 = v39;
        double v52 = v51;
        int v53 = v5->mode;
        BOOL v54 = "path";
        switch(v53)
        {
          case 0:
            break;
          case 1:
            BOOL v54 = "resolver";
            break;
          case 2:
            BOOL v54 = nw_endpoint_flow_mode_string(v51[31]);
            break;
          case 3:
            BOOL v54 = "proxy";
            break;
          case 4:
            BOOL v54 = "fallback";
            break;
          case 5:
            BOOL v54 = "transform";
            break;
          default:
            BOOL v54 = "unknown-mode";
            break;
        }

        uint64_t v55 = v52;
        os_unfair_lock_lock((os_unfair_lock_t)v55 + 28);
        id v56 = v55[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v55 + 28);

        *(_DWORD *)buf = 136447746;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        __int16 v102 = 2082;
        nw_endpoint_t v103 = id_str;
        __int16 v104 = 2082;
        __int16 v105 = v35;
        __int16 v106 = 2082;
        id v107 = (void *)v37;
        __int16 v108 = 2082;
        BOOL v109 = v41;
        __int16 v110 = 2082;
        char v111 = v54;
        __int16 v112 = 2114;
        id v113 = v56;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping reset of traffic class, no active flow registration", buf, 0x48u);
      }
    }
LABEL_82:

    goto LABEL_83;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v20 = (id)gLogObj;
  if (mode > 5) {
    os_log_type_t v21 = "unknown-mode";
  }
  else {
    os_log_type_t v21 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
  __int16 v102 = 2082;
  nw_endpoint_t v103 = (void *)v21;
  __int16 v104 = 2082;
  __int16 v105 = "flow";
  id v22 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v96) = 0;
  if (__nwlog_fault(v22, type, &v96))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        if (mode > 5) {
          nw_endpoint_t v25 = "unknown-mode";
        }
        else {
          nw_endpoint_t v25 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        __int16 v102 = 2082;
        nw_endpoint_t v103 = (void *)v25;
        __int16 v104 = 2082;
        __int16 v105 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if ((_BYTE)v96)
    {
      os_log_type_t v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v27 = type[0];
      BOOL v28 = os_log_type_enabled(v23, type[0]);
      if (v26)
      {
        if (v28)
        {
          if (mode > 5) {
            BOOL v29 = "unknown-mode";
          }
          else {
            BOOL v29 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446978;
          nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
          __int16 v102 = 2082;
          nw_endpoint_t v103 = (void *)v29;
          __int16 v104 = 2082;
          __int16 v105 = "flow";
          __int16 v106 = 2082;
          id v107 = v26;
          _os_log_impl(&dword_1830D4000, v23, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v26);
        if (v22) {
          goto LABEL_75;
        }
        goto LABEL_84;
      }
      if (v28)
      {
        if (mode > 5) {
          BOOL v44 = "unknown-mode";
        }
        else {
          BOOL v44 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        __int16 v102 = 2082;
        nw_endpoint_t v103 = (void *)v44;
        __int16 v104 = 2082;
        __int16 v105 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v27, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v23 = (id)gLogObj;
      os_log_type_t v42 = type[0];
      if (os_log_type_enabled(v23, type[0]))
      {
        if (mode > 5) {
          uint64_t v43 = "unknown-mode";
        }
        else {
          uint64_t v43 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        nw_endpoint_t v101 = "nw_endpoint_handler_reset_traffic_class";
        __int16 v102 = 2082;
        nw_endpoint_t v103 = (void *)v43;
        __int16 v104 = 2082;
        __int16 v105 = "flow";
        _os_log_impl(&dword_1830D4000, v23, v42, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_73;
  }
LABEL_74:
  if (v22) {
LABEL_75:
  }
    free(v22);
LABEL_84:
}

void sub_183C8FBF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_flow_get_unsent_byte_count_block_invoke(uint64_t a1, int a2)
{
  socklen_t v4 = 4;
  int v5 = 0;
  if (!getsockopt(a2, 0xFFFF, 4132, &v5, &v4)) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v5;
  }
  return 1;
}

uint64_t ___ZL45nw_endpoint_flow_enable_sleep_proxy_if_neededP30NWConcrete_nw_endpoint_handler_block_invoke(uint64_t a1, int a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 880));
  uint64_t v4 = *(void *)(a1 + 32);
  if (!*(void *)(v4 + 920))
  {
    DNSServiceErrorType v5 = DNSServiceSleepKeepalive((DNSServiceRef *)(v4 + 920), 0, a2, *(_DWORD *)(a1 + 48), (DNSServiceSleepKeepaliveReply)nw_endpoint_flow_sleep_proxy_callback, *(void **)(a1 + 40));
    if (v5)
    {
      int v6 = v5;
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v7 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
        {
          id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          char v9 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          nw_endpoint_t v10 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          logging_description = nw_endpoint_get_logging_description(v10);
          id v12 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          id v13 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          id v14 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          int v18 = 136448002;
          char v19 = "nw_endpoint_flow_enable_sleep_proxy_if_needed_block_invoke";
          __int16 v20 = 2082;
          os_log_type_t v21 = id_string;
          __int16 v22 = 2082;
          os_log_type_t v23 = v9;
          __int16 v24 = 2082;
          nw_endpoint_t v25 = logging_description;
          __int16 v26 = 2082;
          os_log_type_t v27 = v12;
          __int16 v28 = 2082;
          BOOL v29 = v13;
          __int16 v30 = 2114;
          id v31 = v14;
          __int16 v32 = 2082;
          string_for_dns_service_error = nwlog_get_string_for_dns_service_error(v6);
          _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] DNSServiceSleepKeepalive failed: %{public}s", (uint8_t *)&v18, 0x52u);
        }
      }
    }
    else
    {
      uint64_t v15 = *(_DNSServiceRef_t **)(*(void *)(a1 + 32) + 920);
      BOOL v16 = nw_queue_copy_current_workloop();
      DNSServiceSetDispatchQueue(v15, (dispatch_queue_t)v16);
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 880));
  return 1;
}

void sub_183C8FF10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_sleep_proxy_callback(_DNSServiceRef_t *a1, int a2, void *a3)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a3;
  DNSServiceErrorType v5 = v4;
  if (v4)
  {
    int v6 = v4;
    uint64_t mode = v6->mode;

    if (mode == 2)
    {
      id v8 = nw_endpoint_handler_copy_flow(v6);
      char v9 = v6;
      char v10 = *((unsigned char *)v9 + 268);

      if (a2)
      {
        if ((v10 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v11 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
          {
            id v12 = v9;

            id v13 = v12;
            char v14 = *((unsigned char *)v9 + 268);

            if (v14) {
              uint64_t v15 = "dry-run ";
            }
            else {
              uint64_t v15 = "";
            }
            nw_endpoint_t v16 = nw_endpoint_handler_copy_endpoint(v13);
            logging_description = nw_endpoint_get_logging_description(v16);
            id_str = v12->id_str;
            int v18 = v13;
            char v19 = v18;
            uint64_t v20 = v18[30];
            if (v20 > 5) {
              os_log_type_t v21 = "unknown-state";
            }
            else {
              os_log_type_t v21 = off_1E523FB38[v20];
            }
            id v56 = v21;

            uint64_t v34 = v19;
            __int16 v35 = v34;
            nw_endpoint_t v55 = v16;
            nw_endpoint_t v36 = "path";
            switch(v6->mode)
            {
              case 0:
                break;
              case 1:
                nw_endpoint_t v36 = "resolver";
                break;
              case 2:
                nw_endpoint_t v36 = nw_endpoint_flow_mode_string(v34[31]);
                break;
              case 3:
                nw_endpoint_t v36 = "proxy";
                break;
              case 4:
                nw_endpoint_t v36 = "fallback";
                break;
              case 5:
                nw_endpoint_t v36 = "transform";
                break;
              default:
                nw_endpoint_t v36 = "unknown-mode";
                break;
            }

            uint64_t v41 = v35;
            os_unfair_lock_lock((os_unfair_lock_t)v41 + 28);
            id v42 = v41[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v41 + 28);

            id v43 = v42;
            *(_DWORD *)buf = 136448002;
            uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
            __int16 v64 = 2082;
            uint64_t v65 = id_str;
            __int16 v66 = 2082;
            uint64_t v67 = v15;
            __int16 v68 = 2082;
            os_log_type_t v69 = logging_description;
            __int16 v70 = 2082;
            uint64_t v71 = v56;
            __int16 v72 = 2082;
            id v73 = v36;
            __int16 v74 = 2114;
            id v75 = v43;
            __int16 v76 = 2082;
            string_for_dns_service_error = nwlog_get_string_for_dns_service_error(a2);
            _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Sleep proxy callback failed: %{public}s", buf, 0x52u);
          }
        }
        char isa = v8[115].isa;
        if (isa)
        {
          DNSServiceRefDeallocate(isa);
          v8[115].char isa = 0;
        }
      }
      else if ((v10 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v23 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          __int16 v24 = v9;

          nw_endpoint_t v25 = v24;
          char v26 = *((unsigned char *)v9 + 268);

          if (v26) {
            os_log_type_t v27 = "dry-run ";
          }
          else {
            os_log_type_t v27 = "";
          }
          nw_endpoint_t v28 = nw_endpoint_handler_copy_endpoint(v25);
          BOOL v29 = nw_endpoint_get_logging_description(v28);
          os_log_type_t v58 = v24->id_str;
          id v59 = v27;
          __int16 v30 = v25;
          id v31 = v30;
          uint64_t v32 = v30[30];
          if (v32 > 5) {
            os_log_type_t v33 = "unknown-state";
          }
          else {
            os_log_type_t v33 = off_1E523FB38[v32];
          }

          id v37 = v31;
          id v38 = v37;
          int v39 = v6->mode;
          uint64_t v40 = "path";
          switch(v39)
          {
            case 0:
              break;
            case 1:
              uint64_t v40 = "resolver";
              break;
            case 2:
              uint64_t v40 = nw_endpoint_flow_mode_string(v37[31]);
              break;
            case 3:
              uint64_t v40 = "proxy";
              break;
            case 4:
              uint64_t v40 = "fallback";
              break;
            case 5:
              uint64_t v40 = "transform";
              break;
            default:
              uint64_t v40 = "unknown-mode";
              break;
          }

          uint64_t v45 = v38;
          os_unfair_lock_lock((os_unfair_lock_t)v45 + 28);
          id v46 = v45[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v45 + 28);

          *(_DWORD *)buf = 136447746;
          uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
          __int16 v64 = 2082;
          uint64_t v65 = v58;
          __int16 v66 = 2082;
          uint64_t v67 = v59;
          __int16 v68 = 2082;
          os_log_type_t v69 = v29;
          __int16 v70 = 2082;
          uint64_t v71 = v33;
          __int16 v72 = 2082;
          id v73 = v40;
          __int16 v74 = 2114;
          id v75 = v46;
          _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Sleep proxy callback, no error", buf, 0x48u);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5) {
          __int16 v22 = "unknown-mode";
        }
        else {
          __int16 v22 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
        __int16 v64 = 2082;
        uint64_t v65 = (void *)v22;
        __int16 v66 = 2082;
        uint64_t v67 = "flow";
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }

    goto LABEL_51;
  }
  char v47 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
  uint64_t v48 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v60 = 0;
  if (__nwlog_fault(v48, &type, &v60))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v49 = __nwlog_obj();
      os_log_type_t v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
        _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v60)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v49 = __nwlog_obj();
      os_log_type_t v52 = type;
      BOOL v53 = os_log_type_enabled(v49, type);
      if (backtrace_string)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
          __int16 v64 = 2082;
          uint64_t v65 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v49, v52, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_68;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
        _os_log_impl(&dword_1830D4000, v49, v52, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v49 = __nwlog_obj();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v63 = "nw_endpoint_flow_sleep_proxy_callback";
        _os_log_impl(&dword_1830D4000, v49, v54, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_68:
  if (v48) {
    free(v48);
  }
LABEL_51:
}

void sub_183C90708(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_rebuild_stack(NWConcrete_nw_endpoint_handler *a1, nw_protocol *a2)
{
  uint64_t v237 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (a2)
  {
    uint64_t v208 = v3;
    DNSServiceErrorType v5 = nw_endpoint_handler_copy_flow(v3);
    if (v5)
    {
      int v6 = v4;
      char v7 = v6;
      if (v6)
      {
        int state = v6->state;

        if ((state & 0xFFFFFFFE) == 4)
        {
          char v9 = v7;
          char v10 = *((unsigned char *)v9 + 268);

          if ((v10 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            char v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              id v12 = v9;

              id v13 = v12;
              char v14 = *((unsigned char *)v9 + 268);

              if (v14) {
                uint64_t v15 = "dry-run ";
              }
              else {
                uint64_t v15 = "";
              }
              nw_endpoint_t v16 = nw_endpoint_handler_copy_endpoint(v13);
              logging_description = nw_endpoint_get_logging_description(v16);
              unsigned int log = v5;
              id_str = v12->id_str;
              char v19 = v13;
              uint64_t v20 = v19;
              uint64_t v21 = v7->state;
              if (v21 > 5) {
                __int16 v22 = "unknown-state";
              }
              else {
                __int16 v22 = off_1E523FB38[v21];
              }

              int v39 = v20;
              uint64_t v40 = v39;
              uint64_t v41 = "path";
              switch(*((_DWORD *)v39 + 29))
              {
                case 0:
                  break;
                case 1:
                  uint64_t v41 = "resolver";
                  break;
                case 2:
                  uint64_t v41 = nw_endpoint_flow_mode_string(v39[31]);
                  break;
                case 3:
                  uint64_t v41 = "proxy";
                  break;
                case 4:
                  uint64_t v41 = "fallback";
                  break;
                case 5:
                  uint64_t v41 = "transform";
                  break;
                default:
                  uint64_t v41 = "unknown-mode";
                  break;
              }

              uint64_t v78 = v40;
              os_unfair_lock_lock((os_unfair_lock_t)v78 + 28);
              id v79 = v78[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v78 + 28);

              *(_DWORD *)buf = 136447746;
              os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
              __int16 v221 = 2082;
              v222 = id_str;
              __int16 v223 = 2082;
              os_log_type_t v224 = (nw_protocol *)v15;
              __int16 v225 = 2082;
              nw_endpoint_t v226 = (void *)logging_description;
              __int16 v227 = 2082;
              id v228 = v22;
              __int16 v229 = 2082;
              v230 = v41;
              __int16 v231 = 2114;
              id v232 = v79;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already cancelled, cannot rebuild stack", buf, 0x48u);

              DNSServiceErrorType v5 = log;
            }
LABEL_72:

            goto LABEL_237;
          }
          goto LABEL_237;
        }
        if ((*((unsigned char *)v5 + 36) & 2) != 0)
        {
          char v26 = v7;
          char v27 = *((unsigned char *)v26 + 268);

          if ((v27 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            char v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              nw_endpoint_t v28 = v26;

              BOOL v29 = v28;
              char v30 = *((unsigned char *)v26 + 268);

              if (v30) {
                id v31 = "dry-run ";
              }
              else {
                id v31 = "";
              }
              nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(v29);
              os_log_type_t v33 = nw_endpoint_get_logging_description(v32);
              nw_endpoint_t loga = v5;
              uint64_t v34 = v28->id_str;
              __int16 v35 = v29;
              nw_endpoint_t v36 = v35;
              uint64_t v37 = v7->state;
              if (v37 > 5) {
                id v38 = "unknown-state";
              }
              else {
                id v38 = off_1E523FB38[v37];
              }

              id v42 = v36;
              id v43 = v42;
              BOOL v44 = "path";
              switch(*((_DWORD *)v42 + 29))
              {
                case 0:
                  break;
                case 1:
                  BOOL v44 = "resolver";
                  break;
                case 2:
                  BOOL v44 = nw_endpoint_flow_mode_string(v42[31]);
                  break;
                case 3:
                  BOOL v44 = "proxy";
                  break;
                case 4:
                  BOOL v44 = "fallback";
                  break;
                case 5:
                  BOOL v44 = "transform";
                  break;
                default:
                  BOOL v44 = "unknown-mode";
                  break;
              }

              os_log_type_t v91 = v43;
              os_unfair_lock_lock((os_unfair_lock_t)v91 + 28);
              id v92 = v91[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v91 + 28);

              *(_DWORD *)buf = 136447746;
              os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
              __int16 v221 = 2082;
              v222 = v34;
              __int16 v223 = 2082;
              os_log_type_t v224 = (nw_protocol *)v31;
              __int16 v225 = 2082;
              nw_endpoint_t v226 = (void *)v33;
              __int16 v227 = 2082;
              id v228 = v38;
              __int16 v229 = 2082;
              v230 = v44;
              __int16 v231 = 2114;
              id v232 = v92;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failing, cannot rebuild stack", buf, 0x48u);

              DNSServiceErrorType v5 = loga;
            }
            goto LABEL_72;
          }
LABEL_237:

          BOOL v109 = v208;
          goto LABEL_238;
        }
LABEL_15:
        output_handler = a2->output_handler;
        if (!output_handler) {
          goto LABEL_46;
        }
        handle = output_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          char v25 = -1;
        }
        else
        {
          char v25 = 0;
        }
        *(void *)os_log_type_t type = output_handler;
        char v218 = v25;
        id v46 = a2->handle;
        if (v46 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v48 = a2[1].callbacks;
          if (v48) {
            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v48->add_input_handler + 1);
          }
          char v47 = -1;
        }
        else
        {
          char v47 = 0;
        }
        os_log_type_t v215 = a2;
        char v216 = v47;
        uint64_t v49 = output_handler->callbacks;
        if (v49)
        {
          remove_input_handler = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t))v49->remove_input_handler;
          if (remove_input_handler)
          {
            char v51 = remove_input_handler(output_handler, a2, 1);
            if (v46 != &nw_protocol_ref_counted_handle) {
              goto LABEL_44;
            }
            goto LABEL_213;
          }
        }
        char v131 = __nwlog_obj();
        name = output_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        os_log_type_t v220 = "__nw_protocol_remove_input_handler";
        if (!name) {
          name = "invalid";
        }
        __int16 v221 = 2082;
        v222 = (char *)name;
        __int16 v223 = 2048;
        os_log_type_t v224 = output_handler;
        nw_endpoint_t logb = (const char *)_os_log_send_and_compose_impl();

        os_log_type_t v214 = OS_LOG_TYPE_ERROR;
        char v213 = 0;
        char v133 = (char *)logb;
        if (!__nwlog_fault(logb, &v214, &v213))
        {
LABEL_210:
          if (v133) {
            free(v133);
          }
          char v51 = 0;
          if (v46 != &nw_protocol_ref_counted_handle)
          {
LABEL_44:
            if (handle != &nw_protocol_ref_counted_handle) {
              goto LABEL_45;
            }
            goto LABEL_214;
          }
LABEL_213:
          nw::release_if_needed<nw_protocol *>((uint64_t *)&v215);
          if (handle != &nw_protocol_ref_counted_handle)
          {
LABEL_45:
            if (v51) {
              goto LABEL_46;
            }
            goto LABEL_215;
          }
LABEL_214:
          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
          if (v51)
          {
LABEL_46:
            os_log_type_t v52 = (void *)*((void *)v5 + 116);
            if (v52)
            {
              nw_endpoint_handler_cancel(v52, 1, 0);
              BOOL v53 = (void *)*((void *)v5 + 116);
              *((void *)v5 + 116) = 0;

              os_log_type_t v54 = (void *)*((void *)v5 + 117);
              *((void *)v5 + 117) = 0;
            }
            *((void *)v5 + 94) = a2;
            if ((*((unsigned char *)v5 + 32) & 2) == 0) {
              goto LABEL_52;
            }
            nw_endpoint_t v55 = (void *)*((void *)v5 + 104);
            *((void *)v5 + 104) = 0;

            id v56 = (void *)*((void *)v5 + 2);
            *((void *)v5 + 2) = 0;

            if ((*((unsigned char *)v5 + 33) & 0x40) == 0) {
              goto LABEL_52;
            }
            uint64_t v57 = (void *)*((void *)v5 + 113);
            *((void *)v5 + 113) = 0;

            *((unsigned char *)v5 + 32) &= ~0x10u;
            if (nw_endpoint_flow_setup_channel(v7))
            {
              if (!*((void *)v5 + 104))
              {
                if ((nw_endpoint_handler_get_logging_disabled(v7) & 1) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  os_log_type_t v95 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v95, OS_LOG_TYPE_ERROR))
                  {
                    id_string = nw_endpoint_handler_get_id_string(v7);
                    char v97 = nw_endpoint_handler_dry_run_string(v7);
                    nw_endpoint_t v98 = nw_endpoint_handler_copy_endpoint(v7);
                    char v99 = nw_endpoint_get_logging_description(v98);
                    os_log_type_t v100 = nw_endpoint_handler_state_string(v7);
                    nw_endpoint_t v101 = nw_endpoint_handler_mode_string(v7);
                    id v102 = nw_endpoint_handler_copy_current_path(v7);
                    *(_DWORD *)buf = 136447746;
                    os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
                    __int16 v221 = 2082;
                    v222 = (char *)id_string;
                    __int16 v223 = 2082;
                    os_log_type_t v224 = (nw_protocol *)v97;
                    __int16 v225 = 2082;
                    nw_endpoint_t v226 = (void *)v99;
                    __int16 v227 = 2082;
                    id v228 = v100;
                    __int16 v229 = 2082;
                    v230 = v101;
                    __int16 v231 = 2114;
                    id v232 = v102;
                    _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] flow_registration is NULL", buf, 0x48u);
                  }
                }
                goto LABEL_237;
              }
LABEL_52:
              char v58 = *((unsigned char *)v5 + 35);
              *((unsigned char *)v5 + 32) = *((unsigned char *)v5 + 32) & 0x1F | 0x20;
              *((unsigned char *)v5 + 35) = v58 & 0x6F;
              *((unsigned char *)v5 + 33) &= ~4u;
              v209[0] = MEMORY[0x1E4F143A8];
              v209[1] = 3221225472;
              v210 = ___Z30nw_endpoint_flow_rebuild_stackP30NWConcrete_nw_endpoint_handlerP11nw_protocol_block_invoke;
              os_log_type_t v211 = &unk_1E524A298;
              id v59 = v7;
              unsigned int v212 = v59;
              char v60 = v5;
              uint64_t v61 = *((void *)v5 + 84);
              do
              {
                if (!v61) {
                  break;
                }
                uint64_t v62 = *(void *)(v61 + 16);
                char v63 = ((uint64_t (*)(void *))v210)(v209);
                uint64_t v61 = v62;
              }
              while ((v63 & 1) != 0);
              DNSServiceErrorType v5 = v60;
              if (nw_endpoint_flow_setup_protocols(v59, a2, 0, 1, 0)) {
                goto LABEL_103;
              }
              __int16 v64 = v59;
              if (v7)
              {
                uint64_t v65 = v64;
                BOOL v66 = (*((unsigned char *)v64 + 268) & 0x20) == 0;

                if (!v66)
                {
LABEL_103:
                  *((unsigned char *)v5 + 32) &= ~0x20u;

                  goto LABEL_237;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v67 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
                {
                  __int16 v68 = v65;

                  os_log_type_t v69 = v68;
                  BOOL v70 = (*((unsigned char *)v65 + 268) & 1) == 0;

                  if (v70) {
                    uint64_t v71 = "";
                  }
                  else {
                    uint64_t v71 = "dry-run ";
                  }
                  nw_endpoint_t v72 = nw_endpoint_handler_copy_endpoint(v69);
                  id v73 = nw_endpoint_get_logging_description(v72);
                  __int16 v74 = v69;
                  id v75 = v74;
                  uint64_t v76 = v74[30];
                  if (v76 > 5) {
                    id v77 = "unknown-state";
                  }
                  else {
                    id v77 = off_1E523FB38[v76];
                  }

                  nw_endpoint_t v93 = v75;
                  char v94 = "path";
                  switch(*((_DWORD *)v93 + 29))
                  {
                    case 0:
                      break;
                    case 1:
                      char v94 = "resolver";
                      break;
                    case 2:
                      char v94 = nw_endpoint_flow_mode_string(v93[31]);
                      break;
                    case 3:
                      char v94 = "proxy";
                      break;
                    case 4:
                      char v94 = "fallback";
                      break;
                    case 5:
                      char v94 = "transform";
                      break;
                    default:
                      char v94 = "unknown-mode";
                      break;
                  }
                  logd = v94;

                  nw_endpoint_t v103 = v72;
                  __int16 v104 = v77;
                  __int16 v105 = v71;
                  __int16 v106 = v73;
                  id v107 = v93;
                  os_unfair_lock_lock((os_unfair_lock_t)v107 + 28);
                  id v108 = v107[8];
                  os_unfair_lock_unlock((os_unfair_lock_t)v107 + 28);

                  *(_DWORD *)buf = 136447746;
                  os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
                  __int16 v221 = 2082;
                  v222 = v68 + 168;
                  __int16 v223 = 2082;
                  os_log_type_t v224 = (nw_protocol *)v105;
                  __int16 v225 = 2082;
                  nw_endpoint_t v226 = (void *)v106;
                  __int16 v227 = 2082;
                  id v228 = v104;
                  __int16 v229 = 2082;
                  v230 = logd;
                  __int16 v231 = 2114;
                  id v232 = v108;
                  _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unable to setup protocols", buf, 0x48u);
                }
LABEL_102:

                goto LABEL_103;
              }
              unsigned int v152 = __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
              uint64_t v153 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v215) = 0;
              if (__nwlog_fault(v153, type, &v215))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  char v154 = __nwlog_obj();
                  os_log_type_t v155 = type[0];
                  if (os_log_type_enabled(v154, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                    _os_log_impl(&dword_1830D4000, v154, v155, "%{public}s called with null handler", buf, 0xCu);
                  }
                }
                else if ((_BYTE)v215)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  char v154 = __nwlog_obj();
                  os_log_type_t v190 = type[0];
                  BOOL v191 = os_log_type_enabled(v154, type[0]);
                  if (backtrace_string)
                  {
                    if (v191)
                    {
                      *(_DWORD *)buf = 136446466;
                      os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                      __int16 v221 = 2082;
                      v222 = backtrace_string;
                      _os_log_impl(&dword_1830D4000, v154, v190, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
                    }

                    free(backtrace_string);
                    goto LABEL_279;
                  }
                  if (v191)
                  {
                    *(_DWORD *)buf = 136446210;
                    os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                    _os_log_impl(&dword_1830D4000, v154, v190, "%{public}s called with null handler, no backtrace", buf, 0xCu);
                  }
                }
                else
                {
                  char v154 = __nwlog_obj();
                  os_log_type_t v197 = type[0];
                  if (os_log_type_enabled(v154, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                    _os_log_impl(&dword_1830D4000, v154, v197, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
                  }
                }
              }
LABEL_279:
              if (v153) {
                free(v153);
              }
              uint64_t v67 = 0;
              DNSServiceErrorType v5 = v60;
              goto LABEL_102;
            }
            unsigned int v80 = v7;
            if (v7)
            {
              BOOL v81 = v80;
              BOOL v82 = (*((unsigned char *)v80 + 268) & 0x20) == 0;

              if (v82)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                nw_endpoint_t v83 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v83, OS_LOG_TYPE_ERROR))
                {
                  BOOL v84 = nw_endpoint_handler_get_id_string(v81);
                  os_log_type_t v85 = nw_endpoint_handler_dry_run_string(v81);
                  nw_endpoint_t v86 = nw_endpoint_handler_copy_endpoint(v81);
                  nw_endpoint_t v87 = nw_endpoint_get_logging_description(v86);
                  os_log_type_t v88 = nw_endpoint_handler_state_string(v81);
                  os_log_type_t v89 = nw_endpoint_handler_mode_string(v81);
                  id v90 = nw_endpoint_handler_copy_current_path(v81);
                  *(_DWORD *)buf = 136447746;
                  os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
                  __int16 v221 = 2082;
                  v222 = (char *)v84;
                  __int16 v223 = 2082;
                  os_log_type_t v224 = (nw_protocol *)v85;
                  __int16 v225 = 2082;
                  nw_endpoint_t v226 = (void *)v87;
                  __int16 v227 = 2082;
                  id v228 = v88;
                  __int16 v229 = 2082;
                  v230 = v89;
                  __int16 v231 = 2114;
                  id v232 = v90;
                  _os_log_impl(&dword_1830D4000, v83, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unable to setup channel", buf, 0x48u);
                }
              }
              goto LABEL_237;
            }
            id v192 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
            v193 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v215) = 0;
            if (__nwlog_fault(v193, type, &v215))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                id v194 = __nwlog_obj();
                os_log_type_t v195 = type[0];
                if (os_log_type_enabled(v194, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                  _os_log_impl(&dword_1830D4000, v194, v195, "%{public}s called with null handler", buf, 0xCu);
                }
              }
              else if ((_BYTE)v215)
              {
                BOOL v198 = (char *)__nw_create_backtrace_string();
                id v194 = __nwlog_obj();
                os_log_type_t v199 = type[0];
                BOOL v200 = os_log_type_enabled(v194, type[0]);
                if (v198)
                {
                  if (v200)
                  {
                    *(_DWORD *)buf = 136446466;
                    os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                    __int16 v221 = 2082;
                    v222 = v198;
                    _os_log_impl(&dword_1830D4000, v194, v199, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v198);
                  goto LABEL_288;
                }
                if (v200)
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                  _os_log_impl(&dword_1830D4000, v194, v199, "%{public}s called with null handler, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                id v194 = __nwlog_obj();
                os_log_type_t v201 = type[0];
                if (os_log_type_enabled(v194, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                  _os_log_impl(&dword_1830D4000, v194, v201, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_288:
            if (v193) {
              free(v193);
            }
            goto LABEL_237;
          }
LABEL_215:
          uint64_t v159 = v7;
          if (v7)
          {
            uint64_t v160 = v159;
            BOOL v161 = (*((unsigned char *)v159 + 268) & 0x20) == 0;

            if (v161)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v162 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v162, OS_LOG_TYPE_ERROR))
              {
                id logc = v162;
                v163 = v160;

                v164 = v163;
                BOOL v165 = (*((unsigned char *)v160 + 268) & 1) == 0;

                if (v165) {
                  v166 = "";
                }
                else {
                  v166 = "dry-run ";
                }
                nw_endpoint_t v167 = nw_endpoint_handler_copy_endpoint(v164);
                v168 = nw_endpoint_get_logging_description(v167);
                nw_endpoint_t v169 = v164;
                id v170 = v169;
                uint64_t v171 = v169[30];
                if (v171 > 5) {
                  id v172 = "unknown-state";
                }
                else {
                  id v172 = off_1E523FB38[v171];
                }
                id v202 = v172;

                nw_endpoint_t v173 = v170;
                id v174 = v173;
                v175 = "path";
                switch(*((_DWORD *)v173 + 29))
                {
                  case 0:
                    break;
                  case 1:
                    v175 = "resolver";
                    break;
                  case 2:
                    v175 = nw_endpoint_flow_mode_string(v173[31]);
                    break;
                  case 3:
                    v175 = "proxy";
                    break;
                  case 4:
                    v175 = "fallback";
                    break;
                  case 5:
                    v175 = "transform";
                    break;
                  default:
                    v175 = "unknown-mode";
                    break;
                }

                os_log_type_t v176 = v174;
                os_unfair_lock_lock((os_unfair_lock_t)v176 + 28);
                id v177 = v176[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v176 + 28);

                id v178 = v177;
                os_log_type_t v179 = v178;
                os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
                os_log_type_t v180 = "invalid";
                identifier = a2->identifier;
                *(_DWORD *)buf = 136448258;
                if (identifier) {
                  os_log_type_t v180 = (const char *)identifier;
                }
                __int16 v221 = 2082;
                v222 = v163 + 168;
                __int16 v223 = 2082;
                os_log_type_t v224 = (nw_protocol *)v166;
                __int16 v225 = 2082;
                nw_endpoint_t v226 = (void *)v168;
                __int16 v227 = 2082;
                id v228 = v202;
                __int16 v229 = 2082;
                v230 = v175;
                __int16 v231 = 2114;
                id v232 = v178;
                __int16 v233 = 2080;
                v234 = v180;
                __int16 v235 = 2048;
                v236 = a2;
                _os_log_impl(&dword_1830D4000, logc, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unable to remove input handler for %s:%p", buf, 0x5Cu);

                int v162 = logc;
              }
            }
            goto LABEL_237;
          }
          os_log_type_t v182 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
          nw_endpoint_t v183 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v215) = 0;
          if (__nwlog_fault(v183, type, &v215))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v184 = __nwlog_obj();
              os_log_type_t v185 = type[0];
              if (os_log_type_enabled(v184, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                _os_log_impl(&dword_1830D4000, v184, v185, "%{public}s called with null handler", buf, 0xCu);
              }
            }
            else if ((_BYTE)v215)
            {
              v186 = (char *)__nw_create_backtrace_string();
              os_log_type_t v184 = __nwlog_obj();
              os_log_type_t v187 = type[0];
              BOOL v188 = os_log_type_enabled(v184, type[0]);
              if (v186)
              {
                if (v188)
                {
                  *(_DWORD *)buf = 136446466;
                  os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                  __int16 v221 = 2082;
                  v222 = v186;
                  _os_log_impl(&dword_1830D4000, v184, v187, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v186);
                goto LABEL_273;
              }
              if (v188)
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                _os_log_impl(&dword_1830D4000, v184, v187, "%{public}s called with null handler, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              os_log_type_t v184 = __nwlog_obj();
              os_log_type_t v196 = type[0];
              if (os_log_type_enabled(v184, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
                _os_log_impl(&dword_1830D4000, v184, v196, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
LABEL_273:
          if (v183) {
            free(v183);
          }
          goto LABEL_237;
        }
        if (v214 == OS_LOG_TYPE_FAULT)
        {
          __int16 v134 = __nwlog_obj();
          os_log_type_t v135 = v214;
          if (os_log_type_enabled(v134, v214))
          {
            __int16 v136 = output_handler->identifier->name;
            if (!v136) {
              __int16 v136 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v220 = "__nw_protocol_remove_input_handler";
            __int16 v221 = 2082;
            v222 = (char *)v136;
            __int16 v223 = 2048;
            os_log_type_t v224 = output_handler;
            _os_log_impl(&dword_1830D4000, v134, v135, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback", buf, 0x20u);
          }
        }
        else if (v213)
        {
          __int16 v140 = (char *)__nw_create_backtrace_string();
          __int16 v134 = __nwlog_obj();
          os_log_type_t v141 = v214;
          BOOL v142 = os_log_type_enabled(v134, v214);
          if (v140)
          {
            if (v142)
            {
              uint64_t v143 = output_handler->identifier->name;
              if (!v143) {
                uint64_t v143 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v220 = "__nw_protocol_remove_input_handler";
              __int16 v221 = 2082;
              v222 = (char *)v143;
              __int16 v223 = 2048;
              os_log_type_t v224 = output_handler;
              __int16 v225 = 2082;
              nw_endpoint_t v226 = v140;
              _os_log_impl(&dword_1830D4000, v134, v141, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v140);
            goto LABEL_209;
          }
          if (v142)
          {
            int v158 = output_handler->identifier->name;
            if (!v158) {
              int v158 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v220 = "__nw_protocol_remove_input_handler";
            __int16 v221 = 2082;
            v222 = (char *)v158;
            __int16 v223 = 2048;
            os_log_type_t v224 = output_handler;
            _os_log_impl(&dword_1830D4000, v134, v141, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          __int16 v134 = __nwlog_obj();
          os_log_type_t v156 = v214;
          if (os_log_type_enabled(v134, v214))
          {
            uint64_t v157 = output_handler->identifier->name;
            if (!v157) {
              uint64_t v157 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v220 = "__nw_protocol_remove_input_handler";
            __int16 v221 = 2082;
            v222 = (char *)v157;
            __int16 v223 = 2048;
            os_log_type_t v224 = output_handler;
            _os_log_impl(&dword_1830D4000, v134, v156, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded", buf, 0x20u);
          }
        }

LABEL_209:
        char v133 = (char *)logb;
        goto LABEL_210;
      }
      os_log_type_t v118 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v220 = "nw_endpoint_handler_get_state";
      char v119 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v215) = 0;
      if (__nwlog_fault(v119, type, &v215))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v120 = __nwlog_obj();
          os_log_type_t v121 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_state";
            _os_log_impl(&dword_1830D4000, v120, v121, "%{public}s called with null handler", buf, 0xCu);
          }
LABEL_171:

          goto LABEL_172;
        }
        if (!(_BYTE)v215)
        {
          uint64_t v120 = __nwlog_obj();
          os_log_type_t v139 = type[0];
          if (os_log_type_enabled(v120, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_state";
            _os_log_impl(&dword_1830D4000, v120, v139, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_171;
        }
        uint64_t v128 = (char *)__nw_create_backtrace_string();
        uint64_t v120 = __nwlog_obj();
        os_log_type_t v129 = type[0];
        BOOL v130 = os_log_type_enabled(v120, type[0]);
        if (!v128)
        {
          if (v130)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_state";
            _os_log_impl(&dword_1830D4000, v120, v129, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
          goto LABEL_171;
        }
        if (v130)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v220 = "nw_endpoint_handler_get_state";
          __int16 v221 = 2082;
          v222 = v128;
          _os_log_impl(&dword_1830D4000, v120, v129, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v128);
      }
LABEL_172:
      if (v119) {
        free(v119);
      }
      if ((*((unsigned char *)v5 + 36) & 2) == 0) {
        goto LABEL_15;
      }
      __int16 v144 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
      id v145 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v215) = 0;
      if (__nwlog_fault(v145, type, &v215))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v146 = __nwlog_obj();
          os_log_type_t v147 = type[0];
          if (os_log_type_enabled(v146, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
            _os_log_impl(&dword_1830D4000, v146, v147, "%{public}s called with null handler", buf, 0xCu);
          }
        }
        else if ((_BYTE)v215)
        {
          uint64_t v148 = (char *)__nw_create_backtrace_string();
          uint64_t v146 = __nwlog_obj();
          os_log_type_t v149 = type[0];
          BOOL v150 = os_log_type_enabled(v146, type[0]);
          if (v148)
          {
            if (v150)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
              __int16 v221 = 2082;
              v222 = v148;
              _os_log_impl(&dword_1830D4000, v146, v149, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v148);
            goto LABEL_201;
          }
          if (v150)
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
            _os_log_impl(&dword_1830D4000, v146, v149, "%{public}s called with null handler, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v146 = __nwlog_obj();
          os_log_type_t v151 = type[0];
          if (os_log_type_enabled(v146, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v220 = "nw_endpoint_handler_get_logging_disabled";
            _os_log_impl(&dword_1830D4000, v146, v151, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_201:
      if (v145) {
        free(v145);
      }
      goto LABEL_237;
    }
    uint64_t v114 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
    BOOL v115 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v215) = 0;
    if (__nwlog_fault(v115, type, &v215))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v116 = __nwlog_obj();
        os_log_type_t v117 = type[0];
        if (os_log_type_enabled(v116, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
          _os_log_impl(&dword_1830D4000, v116, v117, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if ((_BYTE)v215)
      {
        char v125 = (char *)__nw_create_backtrace_string();
        os_log_type_t v116 = __nwlog_obj();
        os_log_type_t v126 = type[0];
        BOOL v127 = os_log_type_enabled(v116, type[0]);
        if (v125)
        {
          if (v127)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
            __int16 v221 = 2082;
            v222 = v125;
            _os_log_impl(&dword_1830D4000, v116, v126, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v125);
          goto LABEL_167;
        }
        if (v127)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
          _os_log_impl(&dword_1830D4000, v116, v126, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v116 = __nwlog_obj();
        os_log_type_t v138 = type[0];
        if (os_log_type_enabled(v116, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
          _os_log_impl(&dword_1830D4000, v116, v138, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_167:
    if (v115) {
      free(v115);
    }
    goto LABEL_237;
  }
  BOOL v109 = v3;
  __int16 v110 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
  char v111 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v215) = 0;
  if (__nwlog_fault(v111, type, &v215))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v112 = __nwlog_obj();
      os_log_type_t v113 = type[0];
      if (os_log_type_enabled(v112, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
        _os_log_impl(&dword_1830D4000, v112, v113, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if ((_BYTE)v215)
    {
      os_log_type_t v122 = (char *)__nw_create_backtrace_string();
      __int16 v112 = __nwlog_obj();
      os_log_type_t v123 = type[0];
      BOOL v124 = os_log_type_enabled(v112, type[0]);
      if (v122)
      {
        if (v124)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
          __int16 v221 = 2082;
          v222 = v122;
          _os_log_impl(&dword_1830D4000, v112, v123, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v122);
        goto LABEL_162;
      }
      if (v124)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
        _os_log_impl(&dword_1830D4000, v112, v123, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v112 = __nwlog_obj();
      os_log_type_t v137 = type[0];
      if (os_log_type_enabled(v112, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v220 = "nw_endpoint_flow_rebuild_stack";
        _os_log_impl(&dword_1830D4000, v112, v137, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_162:
  if (v111) {
    free(v111);
  }
LABEL_238:
}

void sub_183C92724(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16)
{
  _Unwind_Resume(a1);
}

uint64_t ___Z30nw_endpoint_flow_rebuild_stackP30NWConcrete_nw_endpoint_handlerP11nw_protocol_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
      int v6 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
      nw_endpoint_t v7 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
      logging_description = nw_endpoint_get_logging_description(v7);
      char v9 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
      char v10 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
      id v11 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
      int v13 = 136448002;
      char v14 = "nw_endpoint_flow_rebuild_stack_block_invoke";
      __int16 v15 = 2082;
      nw_endpoint_t v16 = id_string;
      __int16 v17 = 2082;
      int v18 = v6;
      __int16 v19 = 2082;
      uint64_t v20 = logging_description;
      __int16 v21 = 2082;
      __int16 v22 = v9;
      __int16 v23 = 2082;
      __int16 v24 = v10;
      __int16 v25 = 2114;
      id v26 = v11;
      __int16 v27 = 1024;
      int v28 = nw_frame_unclaimed_length(v3);
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Finalizing frame of size: %u", (uint8_t *)&v13, 0x4Eu);
    }
  }
  nw_frame_finalize((uint64_t)v3);

  return 1;
}

void sub_183C92A4C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_listener_protocol_on_nw_queue(void *a1, void *a2)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v87 = a2;
  nw_endpoint_t v83 = v3;
  if (!v3)
  {
    uint64_t v76 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (!__nwlog_fault(v48, &type, &v92)) {
      goto LABEL_91;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v49 = __nwlog_obj();
      os_log_type_t v77 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v49, v77, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_115;
    }
    if (!v92)
    {
      uint64_t v49 = __nwlog_obj();
      os_log_type_t v81 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v49, v81, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_115;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v53 = __nwlog_obj();
    os_log_type_t v79 = type;
    BOOL v80 = os_log_type_enabled(v53, type);
    if (backtrace_string)
    {
      if (v80)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        __int16 v96 = 2082;
        char v97 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v53, v79, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
      if (!v48) {
        goto LABEL_93;
      }
      goto LABEL_92;
    }
    if (v80)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
      _os_log_impl(&dword_1830D4000, v53, v79, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_90;
  }
  uint64_t v4 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v4->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v46 = (id)gLogObj;
    if (mode > 5) {
      char v47 = "unknown-mode";
    }
    else {
      char v47 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
    __int16 v96 = 2082;
    char v97 = (char *)v47;
    __int16 v98 = 2082;
    char v99 = "flow";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (!__nwlog_fault(v48, &type, &v92))
    {
LABEL_91:
      if (!v48)
      {
LABEL_93:
        uint64_t v91 = 0;
        goto LABEL_94;
      }
LABEL_92:
      free(v48);
      goto LABEL_93;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v49 = (id)gLogObj;
      os_log_type_t v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        if (mode > 5) {
          char v51 = "unknown-mode";
        }
        else {
          char v51 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        __int16 v96 = 2082;
        char v97 = (char *)v51;
        __int16 v98 = 2082;
        char v99 = "flow";
        _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
LABEL_115:

      goto LABEL_91;
    }
    if (!v92)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v49 = (id)gLogObj;
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v49, type))
      {
        if (mode > 5) {
          char v58 = "unknown-mode";
        }
        else {
          char v58 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        __int16 v96 = 2082;
        char v97 = (char *)v58;
        __int16 v98 = 2082;
        char v99 = "flow";
        _os_log_impl(&dword_1830D4000, v49, v57, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
      goto LABEL_115;
    }
    os_log_type_t v52 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v53 = (id)gLogObj;
    os_log_type_t v54 = type;
    BOOL v55 = os_log_type_enabled(v53, type);
    if (v52)
    {
      if (v55)
      {
        if (mode > 5) {
          id v56 = "unknown-mode";
        }
        else {
          id v56 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        __int16 v96 = 2082;
        char v97 = (char *)v56;
        __int16 v98 = 2082;
        char v99 = "flow";
        __int16 v100 = 2082;
        nw_endpoint_t v101 = v52;
        _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
      }

      free(v52);
      if (!v48) {
        goto LABEL_93;
      }
      goto LABEL_92;
    }
    if (v55)
    {
      if (mode > 5) {
        BOOL v70 = "unknown-mode";
      }
      else {
        BOOL v70 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
      __int16 v96 = 2082;
      char v97 = (char *)v70;
      __int16 v98 = 2082;
      char v99 = "flow";
      _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
LABEL_90:

    goto LABEL_91;
  }
  BOOL v82 = nw_endpoint_handler_copy_flow(v4);
  uint64_t v6 = *((void *)v82 + 51);
  if (!v6)
  {
LABEL_47:
    uint64_t v91 = 0;
    goto LABEL_48;
  }
  id_str = v4->id_str;
  lock = &v4->lock;
  nw_endpoint_t v7 = &unk_1EB267000;
  while (1)
  {
    uint64_t v8 = *(void *)(v6 + 16);
    uint64_t v91 = v6;
    if (*(_DWORD *)(v8 + 36) == 2)
    {
      if (*(void *)(*(void *)(v6 + 24) + 232)) {
        break;
      }
    }
    __int16 v25 = v4;
    BOOL v26 = (*((unsigned char *)v4 + 268) & 0x20) == 0;

    if (v26)
    {
      if (v7[191] != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v12 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        __int16 v27 = v25;

        int v28 = v27;
        BOOL v29 = (*((unsigned char *)v4 + 268) & 1) == 0;

        if (v29) {
          char v30 = "";
        }
        else {
          char v30 = "dry-run ";
        }
        nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v28);
        logging_description = nw_endpoint_get_logging_description(v31);
        nw_endpoint_t v32 = v28;
        os_log_type_t v33 = v32;
        uint64_t state = v4->state;
        __int16 v35 = "unknown-state";
        if (state <= 5) {
          __int16 v35 = off_1E523FB38[state];
        }

        nw_endpoint_t v36 = v33;
        uint64_t v37 = "path";
        switch(v4->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v37 = "resolver";
            break;
          case 2:
            uint64_t v37 = nw_endpoint_flow_mode_string(v4->mode_handler);
            break;
          case 3:
            uint64_t v37 = "proxy";
            break;
          case 4:
            uint64_t v37 = "fallback";
            break;
          case 5:
            uint64_t v37 = "transform";
            break;
          default:
            uint64_t v37 = "unknown-mode";
            break;
        }

        id v38 = v12;
        int v39 = v36;
        os_unfair_lock_lock(lock);
        uint64_t v40 = v4->current_path;
        nw_endpoint_t v41 = v31;
        nw_endpoint_t v7 = (void *)&unk_1EB267000;
        os_unfair_lock_unlock(lock);

        id v12 = v38;
        *(_DWORD *)buf = 136448002;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        __int16 v96 = 2082;
        char v97 = v4->id_str;
        __int16 v98 = 2082;
        char v99 = v30;
        __int16 v100 = 2082;
        nw_endpoint_t v101 = (void *)logging_description;
        __int16 v102 = 2082;
        nw_endpoint_t v103 = v35;
        __int16 v104 = 2082;
        __int16 v105 = v37;
        __int16 v106 = 2114;
        id v107 = v40;
        __int16 v108 = 2082;
        uint64_t v109 = v8;
        _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No listener protocol for %{public}s", buf, 0x52u);
      }
      goto LABEL_42;
    }
LABEL_43:
    uint64_t v6 = *(void *)(v91 + 32);
    if (!v6) {
      goto LABEL_47;
    }
  }
  BOOL has_protocol_in_stack = nw_parameters_has_protocol_in_stack(v87, (void *)v8);
  char v10 = v4;
  char v11 = *((unsigned char *)v4 + 268);

  if (!has_protocol_in_stack)
  {
    if ((v11 & 0x20) == 0)
    {
      if (v7[191] != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v12 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        int v13 = v10;

        char v14 = v13;
        BOOL v15 = (*((unsigned char *)v4 + 268) & 1) == 0;

        if (v15) {
          nw_endpoint_t v16 = "";
        }
        else {
          nw_endpoint_t v16 = "dry-run ";
        }
        nw_endpoint_t v17 = nw_endpoint_handler_copy_endpoint(v14);
        int v18 = nw_endpoint_get_logging_description(v17);
        nw_endpoint_t v88 = v17;
        __int16 v19 = v14;
        uint64_t v20 = v19;
        uint64_t v21 = v4->state;
        __int16 v22 = "unknown-state";
        if (v21 <= 5) {
          __int16 v22 = off_1E523FB38[v21];
        }
        BOOL v84 = v22;

        __int16 v23 = v20;
        __int16 v24 = "path";
        switch(v4->mode)
        {
          case 0:
            break;
          case 1:
            __int16 v24 = "resolver";
            break;
          case 2:
            __int16 v24 = nw_endpoint_flow_mode_string(v4->mode_handler);
            break;
          case 3:
            __int16 v24 = "proxy";
            break;
          case 4:
            __int16 v24 = "fallback";
            break;
          case 5:
            __int16 v24 = "transform";
            break;
          default:
            __int16 v24 = "unknown-mode";
            break;
        }

        id v42 = v18;
        id v43 = v12;
        BOOL v44 = v23;
        os_unfair_lock_lock(lock);
        uint64_t v45 = v4->current_path;
        nw_endpoint_t v7 = (void *)&unk_1EB267000;
        os_unfair_lock_unlock(lock);

        id v12 = v43;
        *(_DWORD *)buf = 136448002;
        os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
        __int16 v96 = 2082;
        char v97 = v4->id_str;
        __int16 v98 = 2082;
        char v99 = v16;
        __int16 v100 = 2082;
        nw_endpoint_t v101 = (void *)v42;
        __int16 v102 = 2082;
        nw_endpoint_t v103 = v84;
        __int16 v104 = 2082;
        __int16 v105 = v24;
        __int16 v106 = 2114;
        id v107 = v45;
        __int16 v108 = 2082;
        uint64_t v109 = v8;
        _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Protocol %{public}s is not listener eligible (not in request stack)", buf, 0x52u);
      }
LABEL_42:

      goto LABEL_43;
    }
    goto LABEL_43;
  }
  if ((v11 & 0x20) == 0)
  {
    if (v7[191] != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v59 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
    {
      char v60 = v10;

      uint64_t v61 = v60;
      BOOL v62 = (*((unsigned char *)v4 + 268) & 1) == 0;

      if (v62) {
        char v63 = "";
      }
      else {
        char v63 = "dry-run ";
      }
      nw_endpoint_t v64 = nw_endpoint_handler_copy_endpoint(v61);
      uint64_t v65 = nw_endpoint_get_logging_description(v64);
      BOOL v66 = v61;
      uint64_t v67 = v66;
      uint64_t v68 = v4->state;
      if (v68 > 5) {
        os_log_type_t v69 = "unknown-state";
      }
      else {
        os_log_type_t v69 = off_1E523FB38[v68];
      }
      id v90 = v69;

      uint64_t v71 = v67;
      nw_endpoint_t v72 = "path";
      switch(v4->mode)
      {
        case 0:
          break;
        case 1:
          nw_endpoint_t v72 = "resolver";
          break;
        case 2:
          nw_endpoint_t v72 = nw_endpoint_flow_mode_string(v4->mode_handler);
          break;
        case 3:
          nw_endpoint_t v72 = "proxy";
          break;
        case 4:
          nw_endpoint_t v72 = "fallback";
          break;
        case 5:
          nw_endpoint_t v72 = "transform";
          break;
        default:
          nw_endpoint_t v72 = "unknown-mode";
          break;
      }

      __int16 v74 = v71;
      os_unfair_lock_lock(lock);
      id v75 = v4->current_path;
      os_unfair_lock_unlock(lock);

      *(_DWORD *)buf = 136448002;
      os_log_type_t v95 = "nw_endpoint_handler_get_listener_protocol_on_nw_queue";
      __int16 v96 = 2082;
      char v97 = id_str;
      __int16 v98 = 2082;
      char v99 = v63;
      __int16 v100 = 2082;
      nw_endpoint_t v101 = (void *)v65;
      __int16 v102 = 2082;
      nw_endpoint_t v103 = v90;
      __int16 v104 = 2082;
      __int16 v105 = v72;
      __int16 v106 = 2114;
      id v107 = v75;
      __int16 v108 = 2082;
      uint64_t v109 = v8;
      _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Found listener protocol %{public}s", buf, 0x52u);
    }
  }
LABEL_48:

LABEL_94:
  return v91;
}

void sub_183C937C4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_handler *nw_endpoint_flow_copy_joinable_clone_handler(void *a1, void *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  DNSServiceErrorType v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t v6 = v5;
  if (!v5)
  {
    nw_endpoint_t v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    nw_endpoint_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v17, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v18 = __nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v18, type);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v18 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_29:
    if (v17) {
      free(v17);
    }
    unsigned int mode = 0;
LABEL_32:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v24 = (id)gLogObj;
    if (mode > 5) {
      __int16 v25 = "unknown-mode";
    }
    else {
      __int16 v25 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_joinable_clone_handler";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v25;
    *(_WORD *)&buf[22] = 2082;
    BOOL v44 = "flow";
    BOOL v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v26, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v27 = (id)gLogObj;
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          if (mode > 5) {
            BOOL v29 = "unknown-mode";
          }
          else {
            BOOL v29 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_joinable_clone_handler";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v29;
          *(_WORD *)&buf[22] = 2082;
          BOOL v44 = "flow";
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v41)
      {
        char v30 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v27 = (id)gLogObj;
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v27, type);
        if (v30)
        {
          if (v32)
          {
            if (mode > 5) {
              os_log_type_t v33 = "unknown-mode";
            }
            else {
              os_log_type_t v33 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_joinable_clone_handler";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v33;
            *(_WORD *)&buf[22] = 2082;
            BOOL v44 = "flow";
            __int16 v45 = 2082;
            id v46 = v30;
            _os_log_impl(&dword_1830D4000, v27, v31, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v30);
          if (!v26) {
            goto LABEL_53;
          }
          goto LABEL_52;
        }
        if (v32)
        {
          if (mode > 5) {
            uint64_t v37 = "unknown-mode";
          }
          else {
            uint64_t v37 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_joinable_clone_handler";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v37;
          *(_WORD *)&buf[22] = 2082;
          BOOL v44 = "flow";
          _os_log_impl(&dword_1830D4000, v27, v31, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v27 = (id)gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v27, type))
        {
          if (mode > 5) {
            __int16 v35 = "unknown-mode";
          }
          else {
            __int16 v35 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_joinable_clone_handler";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v35;
          *(_WORD *)&buf[22] = 2082;
          BOOL v44 = "flow";
          _os_log_impl(&dword_1830D4000, v27, v34, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v26)
    {
LABEL_53:
      char v14 = 0;
      goto LABEL_54;
    }
LABEL_52:
    free(v26);
    goto LABEL_53;
  }
  unsigned int mode = v5->mode;

  if (mode != 2) {
    goto LABEL_32;
  }
  uint64_t v8 = nw_endpoint_handler_copy_flow(v6);
  char v9 = v8;
  if ((*((unsigned char *)v8 + 32) & 2) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)v8 + 220);
    char v10 = v6;
    id v11 = v10[4];

    os_unfair_lock_unlock((os_unfair_lock_t)v9 + 220);
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    LOBYTE(v44) = 0;
    v38[0] = MEMORY[0x1E4F143A8];
    v38[1] = 3221225472;
    v38[2] = __nw_endpoint_flow_copy_joinable_clone_handler_block_invoke;
    v38[3] = &unk_1E524A2C0;
    id v12 = v4;
    id v39 = v12;
    uint64_t v40 = buf;
    nw_parameters_internal_iterate_protocol_stack(v11, 5, 0, v38);
    if (*(unsigned char *)(*(void *)&buf[8] + 24))
    {
      int v13 = v10;
    }
    else
    {
      uint64_t v15 = *((void *)v9 + 117);
      if (!v15)
      {
        char v14 = 0;
        goto LABEL_10;
      }
      int v13 = (id *)nw_endpoint_flow_copy_joinable_clone_handler(v15, v12);
    }
    char v14 = (NWConcrete_nw_endpoint_handler *)v13;
LABEL_10:

    _Block_object_dispose(buf, 8);
    goto LABEL_11;
  }
  char v14 = v6;
LABEL_11:

LABEL_54:
  return v14;
}

void sub_183C93FE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_flow_copy_joinable_clone_handler_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  identifier = nw_protocol_definition_get_identifier(v4);
  if (*((_DWORD *)identifier + 9) != 2)
  {
LABEL_7:
    uint64_t v7 = 1;
    goto LABEL_8;
  }
  uint64_t v6 = identifier;
  if (!nw_parameters_has_protocol_in_stack(*(void **)(a1 + 32), identifier))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v8 = (id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      int v10 = 136446466;
      id v11 = "nw_endpoint_flow_copy_joinable_clone_handler_block_invoke";
      __int16 v12 = 2082;
      int v13 = v6;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s Cannot join protocol %{public}s (not in request stack)", (uint8_t *)&v10, 0x16u);
    }

    goto LABEL_7;
  }
  uint64_t v7 = 0;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
LABEL_8:

  return v7;
}

void sub_183C94160(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_set_metadata_changed_handler(void *a1, void *a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    os_log_type_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
    __int16 v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v12, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v13 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
          _os_log_impl(&dword_1830D4000, v13, v24, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_37;
      }
      if (!v29)
      {
        int v13 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
          _os_log_impl(&dword_1830D4000, v13, v28, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_37;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v13 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v13, type);
      if (!backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
          _os_log_impl(&dword_1830D4000, v13, v26, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_37;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
        __int16 v33 = 2082;
        os_log_type_t v34 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v26, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_38:
    if (!v12) {
      goto LABEL_40;
    }
LABEL_39:
    free(v12);
    goto LABEL_40;
  }
  DNSServiceErrorType v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if (mode == 2)
  {
    uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
    uint64_t v8 = _Block_copy(v4);
    char v9 = (void *)*((void *)v7 + 130);
    *((void *)v7 + 130) = v8;

    if ((*((unsigned char *)v7 + 33) & 4) != 0) {
      nw_endpoint_handler_register_metadata_changed_handler(v5);
    }

    goto LABEL_40;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v10 = (id)gLogObj;
  if (mode > 5) {
    id v11 = "unknown-mode";
  }
  else {
    id v11 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
  __int16 v33 = 2082;
  os_log_type_t v34 = (void *)v11;
  __int16 v35 = 2082;
  nw_endpoint_t v36 = "flow";
  __int16 v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (!__nwlog_fault(v12, &type, &v29)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v13 = (id)gLogObj;
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v13, type))
    {
      if (mode > 5) {
        uint64_t v15 = "unknown-mode";
      }
      else {
        uint64_t v15 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
      __int16 v33 = 2082;
      os_log_type_t v34 = (void *)v15;
      __int16 v35 = 2082;
      nw_endpoint_t v36 = "flow";
      _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_37:

    goto LABEL_38;
  }
  if (!v29)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v13 = (id)gLogObj;
    os_log_type_t v20 = type;
    if (os_log_type_enabled(v13, type))
    {
      if (mode > 5) {
        os_log_type_t v21 = "unknown-mode";
      }
      else {
        os_log_type_t v21 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
      __int16 v33 = 2082;
      os_log_type_t v34 = (void *)v21;
      __int16 v35 = 2082;
      nw_endpoint_t v36 = "flow";
      _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_37;
  }
  nw_endpoint_t v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v13 = (id)gLogObj;
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v13, type);
  if (!v16)
  {
    if (v18)
    {
      if (mode > 5) {
        BOOL v22 = "unknown-mode";
      }
      else {
        BOOL v22 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
      __int16 v33 = 2082;
      os_log_type_t v34 = (void *)v22;
      __int16 v35 = 2082;
      nw_endpoint_t v36 = "flow";
      _os_log_impl(&dword_1830D4000, v13, v17, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    if (mode > 5) {
      os_log_type_t v19 = "unknown-mode";
    }
    else {
      os_log_type_t v19 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    BOOL v32 = "nw_endpoint_handler_set_metadata_changed_handler";
    __int16 v33 = 2082;
    os_log_type_t v34 = (void *)v19;
    __int16 v35 = 2082;
    nw_endpoint_t v36 = "flow";
    __int16 v37 = 2082;
    id v38 = v16;
    _os_log_impl(&dword_1830D4000, v13, v17, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v16);
  if (v12) {
    goto LABEL_39;
  }
LABEL_40:
}

void sub_183C947E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_inject_disconnect_error(void *a1, void *a2, uint64_t a3)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  uint64_t v6 = v5;
  if (!v5)
  {
    nw_endpoint_t v64 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v75 = "nw_endpoint_handler_inject_disconnect_error";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v72 = 0;
    if (!__nwlog_fault(v39, &type, &v72)) {
      goto LABEL_86;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v40 = __nwlog_obj();
      os_log_type_t v65 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)buf = 136446210;
        id v75 = "nw_endpoint_handler_inject_disconnect_error";
        _os_log_impl(&dword_1830D4000, v40, v65, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v72)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v40 = __nwlog_obj();
      os_log_type_t v67 = type;
      BOOL v68 = os_log_type_enabled(v40, type);
      if (backtrace_string)
      {
        if (v68)
        {
          *(_DWORD *)buf = 136446466;
          id v75 = "nw_endpoint_handler_inject_disconnect_error";
          __int16 v76 = 2082;
          os_log_type_t v77 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v40, v67, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_86;
      }
      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        id v75 = "nw_endpoint_handler_inject_disconnect_error";
        _os_log_impl(&dword_1830D4000, v40, v67, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v40 = __nwlog_obj();
      os_log_type_t v69 = type;
      if (os_log_type_enabled(v40, type))
      {
        *(_DWORD *)buf = 136446210;
        id v75 = "nw_endpoint_handler_inject_disconnect_error";
        _os_log_impl(&dword_1830D4000, v40, v69, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_85:

    goto LABEL_86;
  }
  uint64_t v7 = (NWConcrete_nw_endpoint_handler *)v5;
  uint64_t mode = v7->mode;

  if (mode == 2)
  {
    char v9 = nw_endpoint_handler_copy_flow(v7);
    id v10 = v9;
    if (v9)
    {
      if ((*((unsigned char *)v9 + 33) & 4) != 0)
      {
        id v11 = (char *)v9 + 376;
        if (a2)
        {
          __int16 v12 = (char *)*((void *)v9 + 51);
          if (!v12)
          {
LABEL_21:
            os_log_type_t v24 = v7;
            char v25 = *((unsigned char *)v24 + 268);

            if ((v25 & 0x20) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              os_log_type_t v26 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v26, OS_LOG_TYPE_ERROR))
              {
                BOOL v27 = v24;

                os_log_type_t v28 = v27;
                char v29 = *((unsigned char *)v24 + 268);

                if (v29) {
                  char v30 = "dry-run ";
                }
                else {
                  char v30 = "";
                }
                nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v28);
                logging_description = nw_endpoint_get_logging_description(v31);
                id_str = v27->id_str;
                __int16 v33 = v28;
                os_log_type_t v34 = v33;
                uint64_t v35 = v33[30];
                if (v35 > 5) {
                  nw_endpoint_t v36 = "unknown-state";
                }
                else {
                  nw_endpoint_t v36 = off_1E523FB38[v35];
                }
                BOOL v70 = v36;

                char v58 = v34;
                id v59 = v58;
                int v60 = v7->mode;
                uint64_t v61 = "path";
                switch(v60)
                {
                  case 0:
                    break;
                  case 1:
                    uint64_t v61 = "resolver";
                    break;
                  case 2:
                    uint64_t v61 = nw_endpoint_flow_mode_string(v58[31]);
                    break;
                  case 3:
                    uint64_t v61 = "proxy";
                    break;
                  case 4:
                    uint64_t v61 = "fallback";
                    break;
                  case 5:
                    uint64_t v61 = "transform";
                    break;
                  default:
                    uint64_t v61 = "unknown-mode";
                    break;
                }

                BOOL v62 = v59;
                os_unfair_lock_lock((os_unfair_lock_t)v62 + 28);
                id v63 = v62[8];
                os_unfair_lock_unlock((os_unfair_lock_t)v62 + 28);

                *(_DWORD *)buf = 136448002;
                id v75 = "nw_endpoint_handler_inject_disconnect_error";
                __int16 v76 = 2082;
                os_log_type_t v77 = id_str;
                __int16 v78 = 2082;
                os_log_type_t v79 = v30;
                __int16 v80 = 2082;
                os_log_type_t v81 = (void *)logging_description;
                __int16 v82 = 2082;
                nw_endpoint_t v83 = v70;
                __int16 v84 = 2082;
                os_log_type_t v85 = v61;
                __int16 v86 = 2114;
                id v87 = v63;
                __int16 v88 = 1024;
                int v89 = a3;
                _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Inject disconnect error %d failed, could not locate protocol", buf, 0x4Eu);
              }
            }
            goto LABEL_95;
          }
          while (1)
          {
            int v13 = v12;
            os_log_type_t v14 = (uint64_t *)*((void *)v12 + 2);
            uint64_t v15 = *v14;
            uint64_t v16 = v14[1];
            uint64_t v17 = v14[2];
            uint64_t v18 = v14[3];
            uint64_t v19 = v14[4];
            BOOL v20 = *a2 == v15 && a2[1] == v16;
            BOOL v21 = v20 && a2[2] == v17;
            BOOL v22 = v21 && a2[3] == v18;
            if (v22 && a2[4] == v19) {
              break;
            }
            __int16 v12 = (char *)*((void *)v13 + 4);
            id v11 = v13;
            if (!v12) {
              goto LABEL_21;
            }
          }
        }
        else
        {
          int v13 = 0;
        }
        (*(void (**)(char *, char *, uint64_t))(*((void *)v11 + 3) + 56))(v11, v13, a3);
        (*(void (**)(char *, char *))(*((void *)v11 + 3) + 48))(v11, v13);
        (*(void (**)(char *, char *))(*((void *)v11 + 3) + 184))(v11, v13);
      }
LABEL_95:

      goto LABEL_96;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v47 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    id v75 = "nw_endpoint_handler_inject_disconnect_error";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v72 = 0;
    if (__nwlog_fault(v48, &type, &v72))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v49 = (id)gLogObj;
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)buf = 136446210;
          id v75 = "nw_endpoint_handler_inject_disconnect_error";
          _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s No endpoint flow", buf, 0xCu);
        }
      }
      else if (v72)
      {
        BOOL v53 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v49 = (id)gLogObj;
        os_log_type_t v54 = type;
        BOOL v55 = os_log_type_enabled(v49, type);
        if (v53)
        {
          if (v55)
          {
            *(_DWORD *)buf = 136446466;
            id v75 = "nw_endpoint_handler_inject_disconnect_error";
            __int16 v76 = 2082;
            os_log_type_t v77 = v53;
            _os_log_impl(&dword_1830D4000, v49, v54, "%{public}s No endpoint flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v53);
          if (!v48) {
            goto LABEL_95;
          }
          goto LABEL_79;
        }
        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          id v75 = "nw_endpoint_handler_inject_disconnect_error";
          _os_log_impl(&dword_1830D4000, v49, v54, "%{public}s No endpoint flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v49 = (id)gLogObj;
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)buf = 136446210;
          id v75 = "nw_endpoint_handler_inject_disconnect_error";
          _os_log_impl(&dword_1830D4000, v49, v57, "%{public}s No endpoint flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v48) {
      goto LABEL_95;
    }
LABEL_79:
    free(v48);
    goto LABEL_95;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v37 = (id)gLogObj;
  if (mode > 5) {
    id v38 = "unknown-mode";
  }
  else {
    id v38 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  id v75 = "nw_endpoint_handler_inject_disconnect_error";
  __int16 v76 = 2082;
  os_log_type_t v77 = (void *)v38;
  __int16 v78 = 2082;
  os_log_type_t v79 = "flow";
  uint64_t v39 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v72 = 0;
  if (__nwlog_fault(v39, &type, &v72))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v40 = (id)gLogObj;
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v40, type))
      {
        if (mode > 5) {
          id v42 = "unknown-mode";
        }
        else {
          id v42 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        id v75 = "nw_endpoint_handler_inject_disconnect_error";
        __int16 v76 = 2082;
        os_log_type_t v77 = (void *)v42;
        __int16 v78 = 2082;
        os_log_type_t v79 = "flow";
        _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    else if (v72)
    {
      id v43 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v40 = (id)gLogObj;
      os_log_type_t v44 = type;
      BOOL v45 = os_log_type_enabled(v40, type);
      if (v43)
      {
        if (v45)
        {
          if (mode > 5) {
            id v46 = "unknown-mode";
          }
          else {
            id v46 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446978;
          id v75 = "nw_endpoint_handler_inject_disconnect_error";
          __int16 v76 = 2082;
          os_log_type_t v77 = (void *)v46;
          __int16 v78 = 2082;
          os_log_type_t v79 = "flow";
          __int16 v80 = 2082;
          os_log_type_t v81 = v43;
          _os_log_impl(&dword_1830D4000, v40, v44, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v43);
        if (v39) {
          goto LABEL_87;
        }
        goto LABEL_96;
      }
      if (v45)
      {
        if (mode > 5) {
          id v56 = "unknown-mode";
        }
        else {
          id v56 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        id v75 = "nw_endpoint_handler_inject_disconnect_error";
        __int16 v76 = 2082;
        os_log_type_t v77 = (void *)v56;
        __int16 v78 = 2082;
        os_log_type_t v79 = "flow";
        _os_log_impl(&dword_1830D4000, v40, v44, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v40 = (id)gLogObj;
      os_log_type_t v51 = type;
      if (os_log_type_enabled(v40, type))
      {
        if (mode > 5) {
          os_log_type_t v52 = "unknown-mode";
        }
        else {
          os_log_type_t v52 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        id v75 = "nw_endpoint_handler_inject_disconnect_error";
        __int16 v76 = 2082;
        os_log_type_t v77 = (void *)v52;
        __int16 v78 = 2082;
        os_log_type_t v79 = "flow";
        _os_log_impl(&dword_1830D4000, v40, v51, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
      }
    }
    goto LABEL_85;
  }
LABEL_86:
  if (v39) {
LABEL_87:
  }
    free(v39);
LABEL_96:
}

void sub_183C953B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_http2_accept(uint64_t a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v36 = "nw_protocol_http2_accept";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v23, &type, &v33)) {
      goto LABEL_79;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      os_log_type_t v26 = "%{public}s called with null protocol";
      goto LABEL_78;
    }
    if (!v33)
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      os_log_type_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v30 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (!v30) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      os_log_type_t v26 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_78;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446466;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      __int16 v37 = 2082;
      id v38 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_79:
    if (!v23) {
      return 0;
    }
LABEL_80:
    free(v23);
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 40);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    nw_endpoint_t v36 = "nw_protocol_http2_accept";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (!__nwlog_fault(v23, &type, &v33)) {
      goto LABEL_79;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      os_log_type_t v26 = "%{public}s called with null http2";
      goto LABEL_78;
    }
    if (!v33)
    {
      os_log_type_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      os_log_type_t v26 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_78;
    }
    nw_endpoint_t v31 = (char *)__nw_create_backtrace_string();
    os_log_type_t v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v32 = os_log_type_enabled(v24, type);
    if (v31)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        nw_endpoint_t v36 = "nw_protocol_http2_accept";
        __int16 v37 = 2082;
        id v38 = v31;
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v31);
      if (!v23) {
        return 0;
      }
      goto LABEL_80;
    }
    if (v32)
    {
      *(_DWORD *)buf = 136446210;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      os_log_type_t v26 = "%{public}s called with null http2, no backtrace";
LABEL_78:
      _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
      goto LABEL_79;
    }
    goto LABEL_79;
  }
  if ((*(__int16 *)(v1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v27 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v28 = *(_DWORD *)(v1 + 368);
      *(_DWORD *)buf = 136446978;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      __int16 v37 = 2082;
      id v38 = (char *)(v1 + 390);
      __int16 v39 = 2080;
      uint64_t v40 = " ";
      __int16 v41 = 1024;
      int v42 = v28;
      _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if ((*(_WORD *)(v1 + 388) & 4) == 0)
  {
    uint64_t v2 = *(void *)(v1 + 64);
    if (v2)
    {
      uint64_t v3 = mach_continuous_time();
      uint64_t v4 = v3 <= 1 ? 1 : v3;
      unint64_t v5 = nw_delta_nanos(v2, v4);
      int64_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_setup_threshold_seconds, 5);
      if (v5 > 1000000000 * int64_with_default)
      {
        if ((*(__int16 *)(v1 + 388) & 0x80000000) == 0)
        {
          int64_t v7 = int64_with_default;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v8 = gconnectionLogObj;
          BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO);
          if (result)
          {
            int v10 = *(_DWORD *)(v1 + 368);
            *(_DWORD *)buf = 136447234;
            nw_endpoint_t v36 = "nw_protocol_http2_accept";
            __int16 v37 = 2082;
            id v38 = (char *)(v1 + 390);
            __int16 v39 = 2080;
            uint64_t v40 = " ";
            __int16 v41 = 1024;
            int v42 = v10;
            __int16 v43 = 2048;
            int64_t v44 = v7;
            id v11 = "%{public}s %{public}s%s<i%u> denying join attempt because http2 connection not ready within %lld seconds";
            __int16 v12 = v8;
            uint32_t v13 = 48;
LABEL_44:
            _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_INFO, v11, buf, v13);
            return 0;
          }
          return result;
        }
        return 0;
      }
    }
  }
  if (!*(_WORD *)(v1 + 372))
  {
    __int16 v15 = *(_WORD *)(v1 + 388);
LABEL_24:
    if ((v15 & 2) != 0)
    {
      if (v15 < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v19 = gconnectionLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO);
      if (!result) {
        return result;
      }
      int v20 = *(_DWORD *)(v1 + 368);
      *(_DWORD *)buf = 136446978;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      __int16 v37 = 2082;
      id v38 = (char *)(v1 + 390);
      __int16 v39 = 2080;
      uint64_t v40 = " ";
      __int16 v41 = 1024;
      int v42 = v20;
      id v11 = "%{public}s %{public}s%s<i%u> cannot accept new streams after receiving a goaway";
    }
    else if ((v15 & 8) != 0)
    {
      if (v15 < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v19 = gconnectionLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO);
      if (!result) {
        return result;
      }
      int v21 = *(_DWORD *)(v1 + 368);
      *(_DWORD *)buf = 136446978;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      __int16 v37 = 2082;
      id v38 = (char *)(v1 + 390);
      __int16 v39 = 2080;
      uint64_t v40 = " ";
      __int16 v41 = 1024;
      int v42 = v21;
      id v11 = "%{public}s %{public}s%s<i%u> cannot accept new streams after the tunnel is closed";
    }
    else
    {
      if ((v15 & 0x40) == 0) {
        return 1;
      }
      if (v15 < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v19 = gconnectionLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO);
      if (!result) {
        return result;
      }
      int v22 = *(_DWORD *)(v1 + 368);
      *(_DWORD *)buf = 136446978;
      nw_endpoint_t v36 = "nw_protocol_http2_accept";
      __int16 v37 = 2082;
      id v38 = (char *)(v1 + 390);
      __int16 v39 = 2080;
      uint64_t v40 = " ";
      __int16 v41 = 1024;
      int v42 = v22;
      id v11 = "%{public}s %{public}s%s<i%u> denying join attempt because http2 has a better alternate path";
    }
    __int16 v12 = v19;
    uint32_t v13 = 38;
    goto LABEL_44;
  }
  int64_t v14 = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_maximum_stall_count, 5);
  __int16 v15 = *(_WORD *)(v1 + 388);
  if (v14 >= *(unsigned __int16 *)(v1 + 372)) {
    goto LABEL_24;
  }
  if ((*(_WORD *)(v1 + 388) & 0x8000) != 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  uint64_t v16 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO);
  if (result)
  {
    int v17 = *(_DWORD *)(v1 + 368);
    int v18 = *(unsigned __int16 *)(v1 + 372);
    *(_DWORD *)buf = 136447234;
    nw_endpoint_t v36 = "nw_protocol_http2_accept";
    __int16 v37 = 2082;
    id v38 = (char *)(v1 + 390);
    __int16 v39 = 2080;
    uint64_t v40 = " ";
    __int16 v41 = 1024;
    int v42 = v17;
    __int16 v43 = 1024;
    LODWORD(v44) = v18;
    id v11 = "%{public}s %{public}s%s<i%u> denying join attempt because http2 connection has hit %u stalls";
    __int16 v12 = v16;
    uint32_t v13 = 44;
    goto LABEL_44;
  }
  return result;
}

BOOL nw_protocol_http2_create(uint64_t a1, uint64_t a2, uint64_t a3, void *a4)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    id v46 = __nwlog_obj();
    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
      _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)buf, 0xCu);
    }
  }
  uint64_t v6 = (char *)malloc_type_calloc(1uLL, 0x1E0uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_3:
    *((_OWORD *)v6 + 28) = 0u;
    *((_OWORD *)v6 + 29) = 0u;
    *((_OWORD *)v6 + 26) = 0u;
    *((_OWORD *)v6 + 27) = 0u;
    *((_OWORD *)v6 + 24) = 0u;
    *((_OWORD *)v6 + 25) = 0u;
    *((_OWORD *)v6 + 22) = 0u;
    *((_OWORD *)v6 + 23) = 0u;
    *((_OWORD *)v6 + 20) = 0u;
    *((_OWORD *)v6 + 21) = 0u;
    *((_OWORD *)v6 + 18) = 0u;
    *((_OWORD *)v6 + 19) = 0u;
    *((_OWORD *)v6 + 16) = 0u;
    *((_OWORD *)v6 + 17) = 0u;
    *((_OWORD *)v6 + 14) = 0u;
    *((_OWORD *)v6 + 15) = 0u;
    *((_OWORD *)v6 + 12) = 0u;
    *((_OWORD *)v6 + 13) = 0u;
    *((_OWORD *)v6 + 10) = 0u;
    *((_OWORD *)v6 + 11) = 0u;
    *((_OWORD *)v6 + 8) = 0u;
    *((_OWORD *)v6 + 9) = 0u;
    *((_OWORD *)v6 + 6) = 0u;
    *((_OWORD *)v6 + 7) = 0u;
    *((_OWORD *)v6 + 4) = 0u;
    *((_OWORD *)v6 + 5) = 0u;
    *((_OWORD *)v6 + 2) = 0u;
    *((_OWORD *)v6 + 3) = 0u;
    *(_OWORD *)uint64_t v6 = 0u;
    *((_OWORD *)v6 + 1) = 0u;
    *((_DWORD *)v6 + 86) = 1065353216;
    *((void *)v6 + 2) = a1;
    if (nw_protocol_http2_get_callbacks(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_http2_get_callbacks(void)::onceToken, &__block_literal_global_37);
    }
    *((void *)v6 + 3) = &nw_protocol_http2_get_callbacks(void)::protocol_callbacks;
    *((void *)v6 + 5) = v6;
    *((_DWORD *)v6 + 91) = 0;
    *((void *)v6 + 8) = 0;
    *((_DWORD *)v6 + 93) = 0;
    *((_WORD *)v6 + 194) &= 0xFFE2u;
    *((void *)v6 + 10) = 240000;
    if (nw_parameters_get_logging_disabled((uint64_t)a4)) {
      __int16 v7 = 0x8000;
    }
    else {
      __int16 v7 = 0;
    }
    *((_WORD *)v6 + 194) = v7 & 0x8000 | *((_WORD *)v6 + 194) & 0x7FFF;
    *((_DWORD *)v6 + 90) = -1;
    if (nw_parameters_get_server_mode(a4)) {
      __int16 v8 = 128;
    }
    else {
      __int16 v8 = 0;
    }
    *((_WORD *)v6 + 194) = *((_WORD *)v6 + 194) & 0xFF7F | v8;
    nw_frame_cache_init((uint64_t)(v6 + 200), (uint64_t)v6, 20, 0x1000000, 24);
    *((void *)v6 + 21) = 0;
    *((void *)v6 + 23) = 0;
    *((void *)v6 + 22) = v6 + 168;
    *((void *)v6 + 24) = v6 + 184;
    *((void *)v6 + 30) = 0;
    *((void *)v6 + 31) = v6 + 240;
    id v9 = nw_parameters_copy_context(a4);
    char v10 = v6[136];
    if (v10)
    {
      id v11 = (void *)*((void *)v6 + 16);
      if (v11)
      {
        os_release(v11);
        char v10 = v6[136];
      }
    }
    *((void *)v6 + 16) = v9;
    v6[136] = v10 | 1;
    v56[0] = MEMORY[0x1E4F143A8];
    v56[1] = 0x40000000;
    v56[2] = __nw_protocol_http2_create_block_invoke;
    v56[3] = &__block_descriptor_tmp_83106;
    v56[4] = v6;
    v55[0] = MEMORY[0x1E4F143A8];
    v55[1] = 0x40000000;
    v55[2] = __nw_protocol_http2_create_block_invoke_2;
    v55[3] = &__block_descriptor_tmp_8_83107;
    v55[4] = v6;
    metadata = nw_http_connection_create_metadata(v9, v56, v55);
    *((void *)v6 + 32) = metadata;
    nw_http_connection_metadata_set_version(metadata, 4);
    buf[0] = 0;
    buf[1] = buf;
    buf[2] = 0x2000000000;
    uint64_t v58 = (uint64_t)v6;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 0x40000000;
    aBlock[2] = __nw_protocol_http2_create_block_invoke_3;
    aBlock[3] = &unk_1E524A418;
    aBlock[4] = buf;
    *((void *)v6 + 44) = _Block_copy(aBlock);
    _Block_object_dispose(buf, 8);
    uint64_t v53 = 0;
    if (nghttp2_session_callbacks_new())
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = nghttp2_strerror();
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v13;
      int64_t v14 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v52 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v14, type, &v52)) {
        goto LABEL_49;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v15 = gLogObj;
        os_log_type_t v16 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_49;
        }
        uint64_t v17 = nghttp2_strerror();
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v17;
        int v18 = "%{public}s nghttp2_session_callbacks_new: %{public}s failed";
LABEL_47:
        BOOL v32 = v15;
        os_log_type_t v33 = v16;
        uint32_t v34 = 22;
LABEL_48:
        _os_log_impl(&dword_1830D4000, v32, v33, v18, (uint8_t *)buf, v34);
        goto LABEL_49;
      }
      if (v52 == OS_LOG_TYPE_DEFAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v15 = gLogObj;
        os_log_type_t v16 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_49;
        }
        uint64_t v30 = nghttp2_strerror();
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v30;
        int v18 = "%{public}s nghttp2_session_callbacks_new: %{public}s failed, backtrace limit exceeded";
        goto LABEL_47;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v15 = gLogObj;
      os_log_type_t v16 = type[0];
      BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (!backtrace_string)
      {
        if (!v28) {
          goto LABEL_49;
        }
        uint64_t v31 = nghttp2_strerror();
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v31;
        int v18 = "%{public}s nghttp2_session_callbacks_new: %{public}s failed, no backtrace";
        goto LABEL_47;
      }
      if (v28)
      {
        uint64_t v29 = nghttp2_strerror();
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v29;
        HIWORD(buf[2]) = 2082;
        uint64_t v58 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s nghttp2_session_callbacks_new: %{public}s failed, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
      }
      free(backtrace_string);
LABEL_49:
      if (v14) {
LABEL_50:
      }
        free(v14);
LABEL_51:
      std::__destroy_at[abi:nn180100]<nw_protocol_http2,0>((uint64_t)v6);
      free(v6);
      return 0;
    }
    nghttp2_session_callbacks_set_before_frame_send_callback();
    nghttp2_session_callbacks_set_on_header_callback();
    nghttp2_session_callbacks_set_on_begin_headers_callback();
    nghttp2_session_callbacks_set_on_frame_recv_callback();
    nghttp2_session_callbacks_set_on_data_chunk_recv_callback();
    nghttp2_session_callbacks_set_on_stream_close_callback();
    nghttp2_session_callbacks_set_on_frame_send_callback();
    nghttp2_session_callbacks_set_send_callback();
    nghttp2_session_callbacks_set_send_data_callback();
    nghttp2_session_callbacks_set_on_frame_not_send_callback();
    nghttp2_session_callbacks_set_on_invalid_frame_recv_callback();
    nghttp2_session_callbacks_set_error_callback2();
    nghttp2_set_debug_vprintf_callback();
    *(void *)os_log_type_t type = 0;
    nghttp2_option_new();
    nghttp2_option_set_no_auto_window_update();
    nghttp2_option_set_no_rfc9113_leading_and_trailing_ws_validation();
    nghttp2_option_set_peer_max_concurrent_streams();
    nghttp2_option_set_no_closed_streams();
    if ((*((_WORD *)v6 + 194) & 0x80) != 0)
    {
      if ((nghttp2_session_server_new2() & 0x80000000) != 0)
      {
        if (*((__int16 *)v6 + 194) < 0) {
          goto LABEL_51;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        if (v6) {
          uint64_t v19 = " ";
        }
        else {
          uint64_t v19 = "";
        }
        if (v6) {
          int v20 = v6 + 390;
        }
        else {
          int v20 = "";
        }
        int v36 = *((_DWORD *)v6 + 92);
        uint64_t v37 = nghttp2_strerror();
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v20;
        HIWORD(buf[2]) = 2080;
        uint64_t v58 = (uint64_t)v19;
        __int16 v59 = 1024;
        int v60 = v36;
        __int16 v61 = 2082;
        uint64_t v62 = v37;
        int64_t v14 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v52 = OS_LOG_TYPE_ERROR;
        char v50 = 0;
        if (!__nwlog_fault(v14, &v52, &v50)) {
          goto LABEL_49;
        }
        if (v52 == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v23 = gconnectionLogObj;
          os_log_type_t v24 = v52;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v52)) {
            goto LABEL_49;
          }
          goto LABEL_35;
        }
        if (v50)
        {
          id v38 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v23 = gconnectionLogObj;
          os_log_type_t v24 = v52;
          BOOL v40 = os_log_type_enabled((os_log_t)gconnectionLogObj, v52);
          if (v38)
          {
            if (!v40) {
              goto LABEL_80;
            }
            goto LABEL_79;
          }
          if (!v40) {
            goto LABEL_49;
          }
LABEL_93:
          int v44 = *((_DWORD *)v6 + 92);
          uint64_t v45 = nghttp2_strerror();
          LODWORD(buf[0]) = 136447234;
          *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v20;
          HIWORD(buf[2]) = 2080;
          uint64_t v58 = (uint64_t)v19;
          __int16 v59 = 1024;
          int v60 = v44;
          __int16 v61 = 2082;
          uint64_t v62 = v45;
          int v18 = "%{public}s %{public}s%s<i%u> nghttp2_session_server_new2 failed: %{public}s, no backtrace";
          goto LABEL_94;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v23 = gconnectionLogObj;
        os_log_type_t v24 = v52;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v52)) {
          goto LABEL_49;
        }
LABEL_85:
        int v42 = *((_DWORD *)v6 + 92);
        uint64_t v43 = nghttp2_strerror();
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v20;
        HIWORD(buf[2]) = 2080;
        uint64_t v58 = (uint64_t)v19;
        __int16 v59 = 1024;
        int v60 = v42;
        __int16 v61 = 2082;
        uint64_t v62 = v43;
        int v18 = "%{public}s %{public}s%s<i%u> nghttp2_session_server_new2 failed: %{public}s, backtrace limit exceeded";
        goto LABEL_94;
      }
    }
    else if ((nghttp2_session_client_new2() & 0x80000000) != 0)
    {
      if (*((__int16 *)v6 + 194) < 0) {
        goto LABEL_51;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      if (v6) {
        uint64_t v19 = " ";
      }
      else {
        uint64_t v19 = "";
      }
      if (v6) {
        int v20 = v6 + 390;
      }
      else {
        int v20 = "";
      }
      int v21 = *((_DWORD *)v6 + 92);
      uint64_t v22 = nghttp2_strerror();
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v20;
      HIWORD(buf[2]) = 2080;
      uint64_t v58 = (uint64_t)v19;
      __int16 v59 = 1024;
      int v60 = v21;
      __int16 v61 = 2082;
      uint64_t v62 = v22;
      int64_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v52 = OS_LOG_TYPE_ERROR;
      char v50 = 0;
      if (!__nwlog_fault(v14, &v52, &v50)) {
        goto LABEL_49;
      }
      if (v52 == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v23 = gconnectionLogObj;
        os_log_type_t v24 = v52;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v52)) {
          goto LABEL_49;
        }
LABEL_35:
        int v25 = *((_DWORD *)v6 + 92);
        uint64_t v26 = nghttp2_strerror();
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v20;
        HIWORD(buf[2]) = 2080;
        uint64_t v58 = (uint64_t)v19;
        __int16 v59 = 1024;
        int v60 = v25;
        __int16 v61 = 2082;
        uint64_t v62 = v26;
        int v18 = "%{public}s %{public}s%s<i%u> nghttp2_session_server_new2 failed: %{public}s";
LABEL_94:
        BOOL v32 = v23;
        os_log_type_t v33 = v24;
        uint32_t v34 = 48;
        goto LABEL_48;
      }
      if (v50)
      {
        id v38 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v23 = gconnectionLogObj;
        os_log_type_t v24 = v52;
        BOOL v39 = os_log_type_enabled((os_log_t)gconnectionLogObj, v52);
        if (v38)
        {
          if (!v39) {
            goto LABEL_80;
          }
LABEL_79:
          int v49 = *((_DWORD *)v6 + 92);
          uint64_t v41 = nghttp2_strerror();
          LODWORD(buf[0]) = 136447490;
          *(void *)((char *)buf + 4) = "nw_protocol_http2_create";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v20;
          HIWORD(buf[2]) = 2080;
          uint64_t v58 = (uint64_t)v19;
          __int16 v59 = 1024;
          int v60 = v49;
          __int16 v61 = 2082;
          uint64_t v62 = v41;
          __int16 v63 = 2082;
          nw_endpoint_t v64 = v38;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s %{public}s%s<i%u> nghttp2_session_server_new2 failed: %{public}s, dumping backtrace:%{public}s", (uint8_t *)buf, 0x3Au);
LABEL_80:
          free(v38);
          if (!v14) {
            goto LABEL_51;
          }
          goto LABEL_50;
        }
        if (!v39) {
          goto LABEL_49;
        }
        goto LABEL_93;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v23 = gconnectionLogObj;
      os_log_type_t v24 = v52;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v52)) {
        goto LABEL_49;
      }
      goto LABEL_85;
    }
    MEMORY[0x1853174A0](v53);
    MEMORY[0x185317410](*(void *)type);
    return (BOOL)v6;
  }
  id v47 = __nwlog_obj();
  os_log_type_enabled(v47, OS_LOG_TYPE_ERROR);
  LODWORD(buf[0]) = 136446722;
  *(void *)((char *)buf + 4) = "strict_calloc";
  WORD2(buf[1]) = 2048;
  *(void *)((char *)&buf[1] + 6) = 1;
  HIWORD(buf[2]) = 2048;
  uint64_t v58 = 480;
  uint64_t v48 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v48);
  if (!result)
  {
    free(v48);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void __nw_protocol_http2_create_block_invoke(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(nw_protocol **)(a1 + 32);
  if (v1)
  {
    nw_protocol_http2_error(*(nw_protocol **)(a1 + 32), v1, 89);
    nw_http2_connection_close((uint64_t)v1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v11 = "nw_http2_cancel";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      id v11 = "nw_http2_cancel";
      unint64_t v5 = "%{public}s called with null http2";
      goto LABEL_18;
    }
    if (!v8)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_19;
      }
      *(_DWORD *)buf = 136446210;
      id v11 = "nw_http2_cancel";
      unint64_t v5 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_18;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        id v11 = "nw_http2_cancel";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_19;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      id v11 = "nw_http2_cancel";
      unint64_t v5 = "%{public}s called with null http2, no backtrace";
LABEL_18:
      _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_19:
  if (v2) {
    free(v2);
  }
}

void __nw_protocol_http2_create_block_invoke_2(uint64_t a1, void *aBlock)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
    int v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v44, &type, &v55)) {
      goto LABEL_129;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      id v47 = "%{public}s called with null http2";
      goto LABEL_128;
    }
    if (!v55)
    {
      uint64_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      id v47 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_128;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    BOOL v52 = os_log_type_enabled(v45, type);
    if (!backtrace_string)
    {
      if (!v52) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      id v47 = "%{public}s called with null http2, no backtrace";
      goto LABEL_128;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      __int16 v58 = 2082;
      __int16 v59 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_129:
    if (!v44) {
      return;
    }
    goto LABEL_130;
  }
  if (!aBlock)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
    int v44 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (!__nwlog_fault(v44, &type, &v55)) {
      goto LABEL_129;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      id v47 = "%{public}s called with null reply_handler";
      goto LABEL_128;
    }
    if (!v55)
    {
      uint64_t v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (!os_log_type_enabled(v45, type)) {
        goto LABEL_129;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      id v47 = "%{public}s called with null reply_handler, backtrace limit exceeded";
      goto LABEL_128;
    }
    uint64_t v53 = (char *)__nw_create_backtrace_string();
    uint64_t v45 = __nwlog_obj();
    os_log_type_t v46 = type;
    BOOL v54 = os_log_type_enabled(v45, type);
    if (v53)
    {
      if (v54)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
        __int16 v58 = 2082;
        __int16 v59 = v53;
        _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null reply_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v53);
      if (!v44) {
        return;
      }
LABEL_130:
      free(v44);
      return;
    }
    if (v54)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      id v47 = "%{public}s called with null reply_handler, no backtrace";
LABEL_128:
      _os_log_impl(&dword_1830D4000, v45, v46, v47, buf, 0xCu);
      goto LABEL_129;
    }
    goto LABEL_129;
  }
  if ((*(__int16 *)(v3 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v48 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v49 = *(_DWORD *)(v3 + 368);
      uint64_t v50 = *(void *)(v3 + 72);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_http2_send_ping";
      __int16 v58 = 2082;
      __int16 v59 = (char *)(v3 + 390);
      __int16 v60 = 2080;
      __int16 v61 = " ";
      __int16 v62 = 1024;
      int v63 = v49;
      __int16 v64 = 2048;
      uint64_t v65 = v50;
      _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> seq %llu", buf, 0x30u);
    }
  }
  unint64_t v5 = _Block_copy(aBlock);
  unint64_t v6 = *(void *)(v3 + 72);
  unint64_t v7 = *(void *)(v3 + 320);
  if (v7)
  {
    uint8x8_t v8 = (uint8x8_t)vcnt_s8((int8x8_t)v7);
    v8.i16[0] = vaddlv_u8(v8);
    if (v8.u32[0] > 1uLL)
    {
      unint64_t v2 = *(void *)(v3 + 72);
      if (v6 >= v7) {
        unint64_t v2 = v6 % v7;
      }
    }
    else
    {
      unint64_t v2 = (v7 - 1) & v6;
    }
    id v9 = *(void **)(*(void *)(v3 + 312) + 8 * v2);
    if (v9)
    {
      char v10 = (void *)*v9;
      if (v10)
      {
        if (v8.u32[0] < 2uLL)
        {
          while (1)
          {
            uint64_t v12 = v10[1];
            if (v12 == v6)
            {
              if (v10[2] == v6) {
                goto LABEL_86;
              }
            }
            else if ((v12 & (v7 - 1)) != v2)
            {
              goto LABEL_26;
            }
            char v10 = (void *)*v10;
            if (!v10) {
              goto LABEL_26;
            }
          }
        }
        do
        {
          unint64_t v11 = v10[1];
          if (v11 == v6)
          {
            if (v10[2] == v6) {
              goto LABEL_86;
            }
          }
          else
          {
            if (v11 >= v7) {
              v11 %= v7;
            }
            if (v11 != v2) {
              break;
            }
          }
          char v10 = (void *)*v10;
        }
        while (v10);
      }
    }
  }
LABEL_26:
  uint64_t v13 = operator new(0x30uLL);
  *uint64_t v13 = 0;
  v13[1] = v6;
  v13[2] = v6;
  v13[3] = 0;
  void v13[4] = v5;
  *((unsigned char *)v13 + 40) = -1;
  float v14 = (float)(unint64_t)(*(void *)(v3 + 336) + 1);
  float v15 = *(float *)(v3 + 344);
  if (!v7 || (float)(v15 * (float)v7) < v14)
  {
    BOOL v16 = 1;
    if (v7 >= 3) {
      BOOL v16 = (v7 & (v7 - 1)) != 0;
    }
    unint64_t v17 = v16 | (2 * v7);
    unint64_t v18 = vcvtps_u32_f32(v14 / v15);
    if (v17 <= v18) {
      size_t prime = v18;
    }
    else {
      size_t prime = v17;
    }
    if (prime == 1)
    {
      size_t prime = 2;
    }
    else if ((prime & (prime - 1)) != 0)
    {
      size_t prime = std::__next_prime(prime);
      unint64_t v7 = *(void *)(v3 + 320);
    }
    if (prime <= v7)
    {
      if (prime >= v7) {
        goto LABEL_63;
      }
      unint64_t v32 = vcvtps_u32_f32((float)*(unint64_t *)(v3 + 336) / *(float *)(v3 + 344));
      if (v7 < 3 || (uint8x8_t v33 = (uint8x8_t)vcnt_s8((int8x8_t)v7), v33.i16[0] = vaddlv_u8(v33), v33.u32[0] > 1uLL))
      {
        unint64_t v32 = std::__next_prime(v32);
      }
      else
      {
        uint64_t v34 = 1 << -(char)__clz(v32 - 1);
        if (v32 >= 2) {
          unint64_t v32 = v34;
        }
      }
      if (prime <= v32) {
        size_t prime = v32;
      }
      if (prime >= v7)
      {
        unint64_t v7 = *(void *)(v3 + 320);
LABEL_63:
        if ((v7 & (v7 - 1)) != 0)
        {
          if (v6 >= v7) {
            unint64_t v2 = v6 % v7;
          }
          else {
            unint64_t v2 = v6;
          }
        }
        else
        {
          unint64_t v2 = (v7 - 1) & v6;
        }
        goto LABEL_76;
      }
      if (!prime)
      {
        uint64_t v43 = *(void **)(v3 + 312);
        *(void *)(v3 + 312) = 0;
        if (v43) {
          operator delete(v43);
        }
        unint64_t v7 = 0;
        *(void *)(v3 + 320) = 0;
        goto LABEL_63;
      }
    }
    if (prime >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    int v20 = operator new(8 * prime);
    int v21 = *(void **)(v3 + 312);
    *(void *)(v3 + 312) = v20;
    if (v21) {
      operator delete(v21);
    }
    uint64_t v22 = 0;
    *(void *)(v3 + 320) = prime;
    do
      *(void *)(*(void *)(v3 + 312) + 8 * v22++) = 0;
    while (prime != v22);
    os_log_type_t v23 = *(void **)(v3 + 328);
    if (!v23)
    {
LABEL_62:
      unint64_t v7 = prime;
      goto LABEL_63;
    }
    uint64_t v24 = v3 + 328;
    size_t v25 = v23[1];
    size_t v26 = prime - 1;
    if ((prime & (prime - 1)) == 0)
    {
      size_t v27 = v25 & v26;
      *(void *)(*(void *)(v3 + 312) + 8 * v27) = v24;
      for (i = (void *)*v23; *v23; i = (void *)*v23)
      {
        size_t v29 = i[1] & v26;
        if (v29 == v27)
        {
          os_log_type_t v23 = i;
        }
        else
        {
          uint64_t v30 = *(void *)(v3 + 312);
          if (*(void *)(v30 + 8 * v29))
          {
            *os_log_type_t v23 = *i;
            uint64_t v31 = 8 * v29;
            void *i = **(void **)(*(void *)(v3 + 312) + v31);
            **(void **)(*(void *)(v3 + 312) + v31) = i;
          }
          else
          {
            *(void *)(v30 + 8 * v29) = v23;
            os_log_type_t v23 = i;
            size_t v27 = v29;
          }
        }
      }
      goto LABEL_62;
    }
    if (v25 >= prime) {
      v25 %= prime;
    }
    *(void *)(*(void *)(v3 + 312) + 8 * v25) = v24;
    uint64_t v35 = (void *)*v23;
    if (!*v23) {
      goto LABEL_62;
    }
    while (1)
    {
      size_t v37 = v35[1];
      if (v37 >= prime) {
        v37 %= prime;
      }
      if (v37 != v25)
      {
        uint64_t v38 = *(void *)(v3 + 312);
        if (!*(void *)(v38 + 8 * v37))
        {
          *(void *)(v38 + 8 * v37) = v23;
          goto LABEL_67;
        }
        *os_log_type_t v23 = *v35;
        uint64_t v36 = 8 * v37;
        void *v35 = **(void **)(*(void *)(v3 + 312) + v36);
        **(void **)(*(void *)(v3 + 312) + v36) = v35;
        uint64_t v35 = v23;
      }
      size_t v37 = v25;
LABEL_67:
      os_log_type_t v23 = v35;
      uint64_t v35 = (void *)*v35;
      size_t v25 = v37;
      if (!v35) {
        goto LABEL_62;
      }
    }
  }
LABEL_76:
  uint64_t v39 = *(void *)(v3 + 312);
  BOOL v40 = *(void **)(v39 + 8 * v2);
  if (v40)
  {
    *uint64_t v13 = *v40;
  }
  else
  {
    uint64_t v41 = *(void *)(v3 + 328);
    *uint64_t v13 = v41;
    *(void *)(v3 + 328) = v13;
    *(void *)(v39 + 8 * v2) = v3 + 328;
    if (!v41) {
      goto LABEL_85;
    }
    unint64_t v42 = *(void *)(v41 + 8);
    if ((v7 & (v7 - 1)) != 0)
    {
      if (v42 >= v7) {
        v42 %= v7;
      }
    }
    else
    {
      v42 &= v7 - 1;
    }
    BOOL v40 = (void *)(*(void *)(v3 + 312) + 8 * v42);
  }
  void *v40 = v13;
LABEL_85:
  ++*(void *)(v3 + 336);
  unint64_t v6 = *(void *)(v3 + 72);
LABEL_86:
  *(void *)buf = v6;
  nghttp2_submit_ping();
  ++*(void *)(v3 + 72);
  nw_http2_session_send(v3);
}

uint64_t __nw_protocol_http2_create_block_invoke_3(uint64_t a1, char a2)
{
  if ((a2 & 1) == 0) {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 0;
  }
  return *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

void std::__destroy_at[abi:nn180100]<nw_protocol_http2,0>(uint64_t a1)
{
  unint64_t v2 = *(void **)(a1 + 328);
  while (v2)
  {
    unint64_t v6 = v2;
    unint64_t v2 = (void *)*v2;
    if (v6[5])
    {
      unint64_t v7 = (const void *)v6[4];
      if (v7) {
        _Block_release(v7);
      }
    }
    operator delete(v6);
  }
  uint64_t v3 = *(void **)(a1 + 312);
  *(void *)(a1 + 312) = 0;
  if (v3) {
    operator delete(v3);
  }
  if (*(unsigned char *)(a1 + 272))
  {
    os_log_type_t v4 = *(const void **)(a1 + 264);
    if (v4) {
      _Block_release(v4);
    }
  }
  *(void *)(a1 + 264) = 0;
  if (*(unsigned char *)(a1 + 136))
  {
    unint64_t v5 = *(void **)(a1 + 128);
    if (v5) {
      os_release(v5);
    }
  }
  *(void *)(a1 + 128) = 0;
}

void nghttp2_debug_logging_callback(char *a1, va_list a2)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  os_log_type_t v4 = 0;
  vasprintf(&v4, a1, a2);
  unint64_t v2 = v4;
  if (v4)
  {
    if (!gLogDatapath) {
      goto LABEL_3;
    }
    uint64_t v3 = __nwlog_obj();
    if (os_log_type_enabled(v3, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v6 = "nghttp2_debug_logging_callback";
      __int16 v7 = 2082;
      uint8x8_t v8 = v4;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s", buf, 0x16u);
    }
    unint64_t v2 = v4;
    if (v4) {
LABEL_3:
    }
      free(v2);
  }
}

uint64_t nw_http2_get_stream_from_id(uint64_t a1, int a2, void *a3)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  if (a2 <= 0)
  {
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v10 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v11 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447234;
    uint64_t v35 = "nw_http2_get_stream_from_id";
    __int16 v36 = 2082;
    uint64_t v37 = a1 + 390;
    __int16 v38 = 2080;
    uint64_t v39 = " ";
    __int16 v40 = 1024;
    int v41 = v11;
    __int16 v42 = 1024;
    *(_DWORD *)uint64_t v43 = a2;
    uint64_t v12 = "%{public}s %{public}s%s<i%u> requested stream id (%d) is not valid, returning NULL stream";
    uint64_t v13 = v10;
    os_log_type_t v14 = OS_LOG_TYPE_ERROR;
    goto LABEL_12;
  }
  uint64_t stream_node_from_id = nw_http2_get_stream_node_from_id(a1, a2);
  if (!stream_node_from_id)
  {
    uint64_t v8 = 0;
    if (*(__int16 *)(a1 + 388) < 0 || !gLogDatapath) {
      return v8;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v15 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      return 0;
    }
    int v16 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447234;
    uint64_t v35 = "nw_http2_get_stream_from_id";
    __int16 v36 = 2082;
    uint64_t v37 = a1 + 390;
    __int16 v38 = 2080;
    uint64_t v39 = " ";
    __int16 v40 = 1024;
    int v41 = v16;
    __int16 v42 = 1024;
    *(_DWORD *)uint64_t v43 = a2;
    uint64_t v12 = "%{public}s %{public}s%s<i%u> stream %d not found in id based hash table";
    uint64_t v13 = v15;
    os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
LABEL_12:
    _os_log_impl(&dword_1830D4000, v13, v14, v12, buf, 0x2Cu);
    return 0;
  }
  uint64_t v7 = stream_node_from_id;
  uint64_t v8 = *(void *)(stream_node_from_id + 16);
  if (!v8)
  {
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v17 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      uint64_t v35 = "nw_http2_get_stream_from_id";
      __int16 v36 = 2082;
      uint64_t v37 = a1 + 390;
      __int16 v38 = 2080;
      uint64_t v39 = " ";
      __int16 v40 = 1024;
      int v41 = v17;
      __int16 v42 = 2048;
      *(void *)uint64_t v43 = v7;
      unint64_t v18 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (!__nwlog_fault(v18, &type, &v32)) {
        goto LABEL_48;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v19 = gconnectionLogObj;
        os_log_type_t v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_48;
        }
        int v21 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v35 = "nw_http2_get_stream_from_id";
        __int16 v36 = 2082;
        uint64_t v37 = a1 + 390;
        __int16 v38 = 2080;
        uint64_t v39 = " ";
        __int16 v40 = 1024;
        int v41 = v21;
        __int16 v42 = 2048;
        *(void *)uint64_t v43 = v7;
        uint64_t v22 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra";
      }
      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v19 = gconnectionLogObj;
        os_log_type_t v20 = type;
        BOOL v24 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (backtrace_string)
        {
          if (v24)
          {
            int v25 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136447490;
            uint64_t v35 = "nw_http2_get_stream_from_id";
            __int16 v36 = 2082;
            uint64_t v37 = a1 + 390;
            __int16 v38 = 2080;
            uint64_t v39 = " ";
            __int16 v40 = 1024;
            int v41 = v25;
            __int16 v42 = 2048;
            *(void *)uint64_t v43 = v7;
            *(_WORD *)&v43[8] = 2082;
            int v44 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, dumping backtrace:%{public}s", buf, 0x3Au);
          }
          free(backtrace_string);
          goto LABEL_48;
        }
        if (!v24)
        {
LABEL_48:
          if (v18) {
            free(v18);
          }
          return 0;
        }
        int v30 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v35 = "nw_http2_get_stream_from_id";
        __int16 v36 = 2082;
        uint64_t v37 = a1 + 390;
        __int16 v38 = 2080;
        uint64_t v39 = " ";
        __int16 v40 = 1024;
        int v41 = v30;
        __int16 v42 = 2048;
        *(void *)uint64_t v43 = v7;
        uint64_t v22 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v19 = gconnectionLogObj;
        os_log_type_t v20 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_48;
        }
        int v29 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v35 = "nw_http2_get_stream_from_id";
        __int16 v36 = 2082;
        uint64_t v37 = a1 + 390;
        __int16 v38 = 2080;
        uint64_t v39 = " ";
        __int16 v40 = 1024;
        int v41 = v29;
        __int16 v42 = 2048;
        *(void *)uint64_t v43 = v7;
        uint64_t v22 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v19, v20, v22, buf, 0x30u);
      goto LABEL_48;
    }
    return 0;
  }
  if (a3)
  {
    uint64_t v9 = *(void *)(stream_node_from_id + 32);
    if (v9)
    {
      *a3 = v9;
    }
    else if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) == 0 {
           && gLogDatapath)
    }
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      size_t v26 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v28 = *(_DWORD *)(v8 + 176);
        int v27 = *(_DWORD *)(v8 + 180);
        *(_DWORD *)buf = 136447490;
        uint64_t v35 = "nw_http2_get_stream_from_id";
        __int16 v36 = 2082;
        uint64_t v37 = v8 + 191;
        __int16 v38 = 2080;
        uint64_t v39 = " ";
        __int16 v40 = 1024;
        int v41 = v27;
        __int16 v42 = 1024;
        *(_DWORD *)uint64_t v43 = v28;
        *(_WORD *)&void v43[4] = 1024;
        *(_DWORD *)&v43[6] = v28;
        _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> no input handler attached to stream %d, ignoring", buf, 0x32u);
      }
    }
  }
  return v8;
}

void nw_http2_connection_close(uint64_t a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  if (!a1 || (*(__int16 *)(a1 + 388) & 0x80000000) == 0)
  {
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unint64_t v18 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = " ";
        int v20 = *(_DWORD *)(a1 + 368);
        uint64_t v35 = "nw_http2_connection_close";
        __int16 v36 = 2082;
        int v21 = (const char *)(a1 + 390);
        *(_DWORD *)buf = 136446978;
        if (!a1) {
          int v21 = "";
        }
        uint64_t v37 = (void *)v21;
        if (!a1) {
          uint64_t v19 = "";
        }
        __int16 v38 = 2080;
        uint64_t v39 = v19;
        __int16 v40 = 1024;
        int v41 = v20;
        _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        __int16 v2 = *(_WORD *)(a1 + 388);
        if ((v2 & 8) != 0) {
          goto LABEL_48;
        }
        goto LABEL_6;
      }
    }
    if (!a1)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v35 = "nw_http2_connection_close";
      uint64_t v22 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (!__nwlog_fault(v22, &type, &v32)) {
        goto LABEL_69;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (!os_log_type_enabled(v23, type)) {
          goto LABEL_69;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v35 = "nw_http2_connection_close";
        int v25 = "%{public}s called with null http2";
      }
      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v29 = os_log_type_enabled(v23, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v35 = "nw_http2_connection_close";
            __int16 v36 = 2082;
            uint64_t v37 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_69;
        }
        if (!v29)
        {
LABEL_69:
          if (v22) {
            free(v22);
          }
          return;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v35 = "nw_http2_connection_close";
        int v25 = "%{public}s called with null http2, no backtrace";
      }
      else
      {
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (!os_log_type_enabled(v23, type)) {
          goto LABEL_69;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v35 = "nw_http2_connection_close";
        int v25 = "%{public}s called with null http2, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0xCu);
      goto LABEL_69;
    }
  }
  __int16 v2 = *(_WORD *)(a1 + 388);
  if ((v2 & 8) != 0)
  {
LABEL_48:
    if ((v2 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      size_t v26 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v27 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        uint64_t v35 = "nw_http2_connection_close";
        __int16 v36 = 2082;
        uint64_t v37 = (void *)(a1 + 390);
        __int16 v38 = 2080;
        uint64_t v39 = " ";
        __int16 v40 = 1024;
        int v41 = v27;
        _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> tunnel is closed, returning", buf, 0x26u);
      }
    }
    return;
  }
LABEL_6:
  *(_WORD *)(a1 + 388) = v2 & 0xFFF3 | 8;
  nw_protocol_remove_instance(a1);
  uint64_t v3 = *(char **)(a1 + 160);
  if (v3)
  {
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 0x40000000;
    v31[2] = ___ZL25nw_http2_connection_closeP17nw_protocol_http2_block_invoke;
    v31[3] = &__block_descriptor_tmp_21_83372;
    v31[4] = a1;
    nw_hash_table_apply(v3, (uint64_t)v31);
  }
  else if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v4 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v35 = "nw_http2_connection_close";
      __int16 v36 = 2082;
      uint64_t v37 = (void *)(a1 + 390);
      __int16 v38 = 2080;
      uint64_t v39 = " ";
      __int16 v40 = 1024;
      int v41 = v5;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> id table is NULL, cannot close streams", buf, 0x26u);
    }
  }
  nw_http2_send_goaway(a1);
  unint64_t v6 = *(char **)(a1 + 152);
  if (v6)
  {
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 0x40000000;
    v30[2] = ___ZL25nw_http2_connection_closeP17nw_protocol_http2_block_invoke_22;
    v30[3] = &__block_descriptor_tmp_23_83378;
    v30[4] = a1;
    nw_hash_table_apply(v6, (uint64_t)v30);
    return;
  }
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v7 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    uint64_t v35 = "nw_http2_connection_close";
    __int16 v36 = 2082;
    uint64_t v37 = (void *)(a1 + 390);
    __int16 v38 = 2080;
    uint64_t v39 = " ";
    __int16 v40 = 1024;
    int v41 = v7;
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v8, &type, &v32)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v9 = gconnectionLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_38;
      }
      int v11 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v35 = "nw_http2_connection_close";
      __int16 v36 = 2082;
      uint64_t v37 = (void *)(a1 + 390);
      __int16 v38 = 2080;
      uint64_t v39 = " ";
      __int16 v40 = 1024;
      int v41 = v11;
      uint64_t v12 = "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers";
    }
    else if (v32)
    {
      uint64_t v13 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v9 = gconnectionLogObj;
      os_log_type_t v10 = type;
      BOOL v14 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v13)
      {
        if (v14)
        {
          int v15 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          uint64_t v35 = "nw_http2_connection_close";
          __int16 v36 = 2082;
          uint64_t v37 = (void *)(a1 + 390);
          __int16 v38 = 2080;
          uint64_t v39 = " ";
          __int16 v40 = 1024;
          int v41 = v15;
          __int16 v42 = 2082;
          uint64_t v43 = v13;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v13);
        goto LABEL_38;
      }
      if (!v14)
      {
LABEL_38:
        if (v8) {
          free(v8);
        }
        return;
      }
      int v17 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v35 = "nw_http2_connection_close";
      __int16 v36 = 2082;
      uint64_t v37 = (void *)(a1 + 390);
      __int16 v38 = 2080;
      uint64_t v39 = " ";
      __int16 v40 = 1024;
      int v41 = v17;
      uint64_t v12 = "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v9 = gconnectionLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_38;
      }
      int v16 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v35 = "nw_http2_connection_close";
      __int16 v36 = 2082;
      uint64_t v37 = (void *)(a1 + 390);
      __int16 v38 = 2080;
      uint64_t v39 = " ";
      __int16 v40 = 1024;
      int v41 = v16;
      uint64_t v12 = "%{public}s %{public}s%s<i%u> protocol table is NULL, cannot notify input handlers, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v9, v10, v12, buf, 0x26u);
    goto LABEL_38;
  }
}

void nw_http2_stream_close(uint64_t a1, uint64_t a2)
{
  uint64_t v118 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v82 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v84 = *(_DWORD *)(a2 + 176);
        int v83 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447234;
        id v107 = "nw_http2_stream_close";
        __int16 v108 = 2082;
        uint64_t v109 = (const char *)(a2 + 191);
        __int16 v110 = 2080;
        uint64_t v111 = (uint64_t)" ";
        __int16 v112 = 1024;
        *(_DWORD *)os_log_type_t v113 = v83;
        *(_WORD *)&v113[4] = 1024;
        *(_DWORD *)&v113[6] = v84;
        _os_log_impl(&dword_1830D4000, v82, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
      }
    }
  }
  else
  {
    if (a1 && *(__int16 *)(a1 + 388) < 0) {
      goto LABEL_129;
    }
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v74 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        id v75 = (const char *)(a1 + 390);
        int v76 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        id v107 = "nw_http2_stream_close";
        __int16 v108 = 2082;
        if (!a1) {
          id v75 = "";
        }
        uint64_t v109 = v75;
        if (a1) {
          os_log_type_t v77 = " ";
        }
        else {
          os_log_type_t v77 = "";
        }
        __int16 v110 = 2080;
        uint64_t v111 = (uint64_t)v77;
        __int16 v112 = 1024;
        *(_DWORD *)os_log_type_t v113 = v76;
        _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        goto LABEL_129;
      }
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v107 = "nw_http2_stream_close";
    __int16 v78 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v104 = 0;
    if (!__nwlog_fault(v78, &type, &v104)) {
      goto LABEL_180;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v79 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (!os_log_type_enabled(v79, type)) {
        goto LABEL_180;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "nw_http2_stream_close";
      os_log_type_t v81 = "%{public}s called with null http2";
      goto LABEL_179;
    }
    if (!v104)
    {
      os_log_type_t v79 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (!os_log_type_enabled(v79, type)) {
        goto LABEL_180;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "nw_http2_stream_close";
      os_log_type_t v81 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_179;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v79 = __nwlog_obj();
    os_log_type_t v80 = type;
    BOOL v86 = os_log_type_enabled(v79, type);
    if (!backtrace_string)
    {
      if (!v86) {
        goto LABEL_180;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "nw_http2_stream_close";
      os_log_type_t v81 = "%{public}s called with null http2, no backtrace";
      goto LABEL_179;
    }
    if (v86)
    {
      *(_DWORD *)buf = 136446466;
      id v107 = "nw_http2_stream_close";
      __int16 v108 = 2082;
      uint64_t v109 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v79, v80, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
    goto LABEL_180;
  }
  if (!a2)
  {
LABEL_129:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v107 = "nw_http2_stream_close";
    __int16 v78 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v104 = 0;
    if (!__nwlog_fault(v78, &type, &v104)) {
      goto LABEL_180;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v79 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (!os_log_type_enabled(v79, type)) {
        goto LABEL_180;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "nw_http2_stream_close";
      os_log_type_t v81 = "%{public}s called with null stream";
      goto LABEL_179;
    }
    if (!v104)
    {
      os_log_type_t v79 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (!os_log_type_enabled(v79, type)) {
        goto LABEL_180;
      }
      *(_DWORD *)buf = 136446210;
      id v107 = "nw_http2_stream_close";
      os_log_type_t v81 = "%{public}s called with null stream, backtrace limit exceeded";
      goto LABEL_179;
    }
    id v87 = (char *)__nw_create_backtrace_string();
    os_log_type_t v79 = __nwlog_obj();
    os_log_type_t v80 = type;
    BOOL v88 = os_log_type_enabled(v79, type);
    if (v87)
    {
      if (v88)
      {
        *(_DWORD *)buf = 136446466;
        id v107 = "nw_http2_stream_close";
        __int16 v108 = 2082;
        uint64_t v109 = v87;
        _os_log_impl(&dword_1830D4000, v79, v80, "%{public}s called with null stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v87);
      if (!v78) {
        return;
      }
LABEL_181:
      free(v78);
      return;
    }
    if (v88)
    {
      *(_DWORD *)buf = 136446210;
      id v107 = "nw_http2_stream_close";
      os_log_type_t v81 = "%{public}s called with null stream, no backtrace";
LABEL_179:
      _os_log_impl(&dword_1830D4000, v79, v80, v81, buf, 0xCu);
    }
LABEL_180:
    if (!v78) {
      return;
    }
    goto LABEL_181;
  }
  os_log_type_t v4 = (int *)(a2 + 176);
  int v5 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
  if (*(_DWORD *)(a2 + 176) != -1)
  {
    if ((*(_WORD *)(a2 + 188) & 1) == 0)
    {
      if ((v5 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        unint64_t v6 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v8 = *(_DWORD *)(a2 + 176);
          int v7 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447234;
          id v107 = "nw_http2_stream_close";
          __int16 v108 = 2082;
          uint64_t v109 = (const char *)(a2 + 191);
          __int16 v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          __int16 v112 = 1024;
          *(_DWORD *)os_log_type_t v113 = v7;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v8;
          _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> not sending RST_STREAM, since we are already closed from nghttp2's perspective", buf, 0x2Cu);
        }
      }
LABEL_38:
      if ((*(_WORD *)(a2 + 188) & 0x400) == 0)
      {
        uint64_t v27 = *(void *)(a2 + 32);
        if (v27)
        {
          uint64_t v28 = mach_continuous_approximate_time();
          uint64_t v29 = v28 <= 1 ? 1 : v28;
          unint64_t v30 = nw_delta_nanos(v27, v29);
          if (v30 > 1000000000
                   * networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_setup_threshold_seconds, 5))
          {
            int v31 = (unsigned __int16)(*(_WORD *)(a1 + 372))++ + 1;
            if ((v31 & 0x10000) != 0)
            {
              if (gLogDatapath)
              {
                __int16 v102 = __nwlog_obj();
                if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                {
                  uint64_t v103 = *(unsigned __int16 *)(a1 + 372);
                  *(_DWORD *)buf = 136446978;
                  id v107 = "nw_http2_stream_close";
                  __int16 v108 = 2082;
                  uint64_t v109 = "http2->stream_stall_count";
                  __int16 v110 = 2048;
                  uint64_t v111 = 1;
                  __int16 v112 = 2048;
                  *(void *)os_log_type_t v113 = v103;
                  _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
                }
              }
              *(_WORD *)(a1 + 372) = -1;
            }
            if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              char v32 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
              {
                int v34 = *(_DWORD *)(a2 + 176);
                int v33 = *(_DWORD *)(a2 + 180);
                int v35 = *(unsigned __int16 *)(a1 + 372);
                *(_DWORD *)buf = 136447490;
                id v107 = "nw_http2_stream_close";
                __int16 v108 = 2082;
                uint64_t v109 = (const char *)(a2 + 191);
                __int16 v110 = 2080;
                uint64_t v111 = (uint64_t)" ";
                __int16 v112 = 1024;
                *(_DWORD *)os_log_type_t v113 = v33;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v34;
                __int16 v114 = 1024;
                int v115 = v35;
                _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> stream setup stalls incremented to %u", buf, 0x32u);
              }
            }
          }
        }
      }
      int v36 = (*(unsigned __int8 *)(a2 + 190) >> 3) & 1;
      if (!gLogDatapath) {
        LOBYTE(v36) = 1;
      }
      if (*(_DWORD *)(a2 + 176) != -1)
      {
        if ((v36 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v92 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v94 = *(_DWORD *)(a2 + 176);
            int v93 = *(_DWORD *)(a2 + 180);
            *(_DWORD *)buf = 136447746;
            id v107 = "nw_http2_remove_from_id_table";
            __int16 v108 = 2082;
            uint64_t v109 = (const char *)(a2 + 191);
            __int16 v110 = 2080;
            uint64_t v111 = (uint64_t)" ";
            __int16 v112 = 1024;
            *(_DWORD *)os_log_type_t v113 = v93;
            *(_WORD *)&v113[4] = 1024;
            *(_DWORD *)&v113[6] = v94;
            __int16 v114 = 1024;
            int v115 = v94;
            __int16 v116 = 2048;
            uint64_t v117 = a2;
            _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d (%p)", buf, 0x3Cu);
          }
        }
        uint64_t v37 = *(void *)(a1 + 160);
        if (v37)
        {
          BOOL node = nw_hash_table_get_node(v37, a2 + 176, 4);
          if (node)
          {
            BOOL v39 = nw_hash_table_remove_node(*(void *)(a1 + 160), node);
            int v40 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
            if (v39)
            {
              if ((v40 & 0x80000) != 0 || !gLogDatapath) {
                goto LABEL_113;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v41 = gconnectionLogObj;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_113;
              }
              int v43 = *(_DWORD *)(a2 + 176);
              int v42 = *(_DWORD *)(a2 + 180);
              *(_DWORD *)buf = 136447490;
              id v107 = "nw_http2_remove_from_id_table";
              __int16 v108 = 2082;
              uint64_t v109 = (const char *)(a2 + 191);
              __int16 v110 = 2080;
              uint64_t v111 = (uint64_t)" ";
              __int16 v112 = 1024;
              *(_DWORD *)os_log_type_t v113 = v42;
              *(_WORD *)&v113[4] = 1024;
              *(_DWORD *)&v113[6] = v43;
              __int16 v114 = 1024;
              int v115 = v43;
              uint64_t v44 = "%{public}s %{public}s%s<i%u:s%d> removed stream %d from id based table";
LABEL_112:
              _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, v44, buf, 0x32u);
LABEL_113:
              if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v89 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v91 = *(_DWORD *)(a2 + 176);
                  int v90 = *(_DWORD *)(a2 + 180);
                  *(_DWORD *)buf = 136447490;
                  id v107 = "nw_http2_stream_close";
                  __int16 v108 = 2082;
                  uint64_t v109 = (const char *)(a2 + 191);
                  __int16 v110 = 2080;
                  uint64_t v111 = (uint64_t)" ";
                  __int16 v112 = 1024;
                  *(_DWORD *)os_log_type_t v113 = v90;
                  *(_WORD *)&v113[4] = 1024;
                  *(_DWORD *)&v113[6] = v91;
                  __int16 v114 = 1024;
                  int v115 = v91;
                  _os_log_impl(&dword_1830D4000, v89, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> removed stream %d from id based table", buf, 0x32u);
                }
              }
              int *v4 = -1;
              return;
            }
            if ((v40 & 0x80000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v57 = *(_DWORD *)(a2 + 176);
              int v56 = *(_DWORD *)(a2 + 180);
              *(_DWORD *)buf = 136447490;
              id v107 = "nw_http2_remove_from_id_table";
              __int16 v108 = 2082;
              uint64_t v109 = (const char *)(a2 + 191);
              __int16 v110 = 2080;
              uint64_t v111 = (uint64_t)" ";
              __int16 v112 = 1024;
              *(_DWORD *)os_log_type_t v113 = v56;
              *(_WORD *)&v113[4] = 1024;
              *(_DWORD *)&v113[6] = v57;
              __int16 v114 = 1024;
              int v115 = v57;
              __int16 v58 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v104 = 0;
              if (!__nwlog_fault(v58, &type, &v104)) {
                goto LABEL_105;
              }
              if (type == OS_LOG_TYPE_FAULT)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                __int16 v59 = gconnectionLogObj;
                os_log_type_t v60 = type;
                if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                  goto LABEL_105;
                }
                int v62 = *(_DWORD *)(a2 + 176);
                int v61 = *(_DWORD *)(a2 + 180);
                *(_DWORD *)buf = 136447490;
                id v107 = "nw_http2_remove_from_id_table";
                __int16 v108 = 2082;
                uint64_t v109 = (const char *)(a2 + 191);
                __int16 v110 = 2080;
                uint64_t v111 = (uint64_t)" ";
                __int16 v112 = 1024;
                *(_DWORD *)os_log_type_t v113 = v61;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v62;
                __int16 v114 = 1024;
                int v115 = v62;
                int v63 = "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table";
              }
              else if (v104)
              {
                __int16 v64 = (char *)__nw_create_backtrace_string();
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                __int16 v59 = gconnectionLogObj;
                os_log_type_t v60 = type;
                BOOL v65 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
                if (v64)
                {
                  if (v65)
                  {
                    int v67 = *(_DWORD *)(a2 + 176);
                    int v66 = *(_DWORD *)(a2 + 180);
                    *(_DWORD *)buf = 136447746;
                    id v107 = "nw_http2_remove_from_id_table";
                    __int16 v108 = 2082;
                    uint64_t v109 = (const char *)(a2 + 191);
                    __int16 v110 = 2080;
                    uint64_t v111 = (uint64_t)" ";
                    __int16 v112 = 1024;
                    *(_DWORD *)os_log_type_t v113 = v66;
                    *(_WORD *)&v113[4] = 1024;
                    *(_DWORD *)&v113[6] = v67;
                    __int16 v114 = 1024;
                    int v115 = v67;
                    __int16 v116 = 2082;
                    uint64_t v117 = (uint64_t)v64;
                    _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table, dumping backtrace:%{public}s", buf, 0x3Cu);
                  }
                  free(v64);
                  goto LABEL_105;
                }
                if (!v65)
                {
LABEL_105:
                  if (v58) {
                    free(v58);
                  }
                  goto LABEL_107;
                }
                int v71 = *(_DWORD *)(a2 + 176);
                int v70 = *(_DWORD *)(a2 + 180);
                *(_DWORD *)buf = 136447490;
                id v107 = "nw_http2_remove_from_id_table";
                __int16 v108 = 2082;
                uint64_t v109 = (const char *)(a2 + 191);
                __int16 v110 = 2080;
                uint64_t v111 = (uint64_t)" ";
                __int16 v112 = 1024;
                *(_DWORD *)os_log_type_t v113 = v70;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v71;
                __int16 v114 = 1024;
                int v115 = v71;
                int v63 = "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table, no backtrace";
              }
              else
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                __int16 v59 = gconnectionLogObj;
                os_log_type_t v60 = type;
                if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                  goto LABEL_105;
                }
                int v69 = *(_DWORD *)(a2 + 176);
                int v68 = *(_DWORD *)(a2 + 180);
                *(_DWORD *)buf = 136447490;
                id v107 = "nw_http2_remove_from_id_table";
                __int16 v108 = 2082;
                uint64_t v109 = (const char *)(a2 + 191);
                __int16 v110 = 2080;
                uint64_t v111 = (uint64_t)" ";
                __int16 v112 = 1024;
                *(_DWORD *)os_log_type_t v113 = v68;
                *(_WORD *)&v113[4] = 1024;
                *(_DWORD *)&v113[6] = v69;
                __int16 v114 = 1024;
                int v115 = v69;
                int v63 = "%{public}s %{public}s%s<i%u:s%d> failed to remove id node for stream %d from table, backtrace limit exceeded";
              }
              _os_log_impl(&dword_1830D4000, v59, v60, v63, buf, 0x32u);
              goto LABEL_105;
            }
LABEL_107:
            if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) != 0) {
              goto LABEL_113;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v41 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_113;
            }
            int v73 = *(_DWORD *)(a2 + 176);
            int v72 = *(_DWORD *)(a2 + 180);
            *(_DWORD *)buf = 136447490;
            id v107 = "nw_http2_stream_close";
            __int16 v108 = 2082;
            uint64_t v109 = (const char *)(a2 + 191);
            __int16 v110 = 2080;
            uint64_t v111 = (uint64_t)" ";
            __int16 v112 = 1024;
            *(_DWORD *)os_log_type_t v113 = v72;
            *(_WORD *)&v113[4] = 1024;
            *(_DWORD *)&v113[6] = v73;
            __int16 v114 = 1024;
            int v115 = v73;
            uint64_t v44 = "%{public}s %{public}s%s<i%u:s%d> did not remove stream %d from id table";
            goto LABEL_112;
          }
          if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) != 0) {
            goto LABEL_107;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v53 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
            goto LABEL_107;
          }
          int v55 = *(_DWORD *)(a2 + 176);
          int v54 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447490;
          id v107 = "nw_http2_remove_from_id_table";
          __int16 v108 = 2082;
          uint64_t v109 = (const char *)(a2 + 191);
          __int16 v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          __int16 v112 = 1024;
          *(_DWORD *)os_log_type_t v113 = v54;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v55;
          __int16 v114 = 1024;
          int v115 = v55;
          uint64_t v50 = "%{public}s %{public}s%s<i%u:s%d> stream %d is not present in id based table, will not remove";
          os_log_type_t v51 = v53;
          os_log_type_t v52 = OS_LOG_TYPE_INFO;
        }
        else
        {
          if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) != 0) {
            goto LABEL_107;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v47 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
            goto LABEL_107;
          }
          int v49 = *(_DWORD *)(a2 + 176);
          int v48 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447490;
          id v107 = "nw_http2_remove_from_id_table";
          __int16 v108 = 2082;
          uint64_t v109 = (const char *)(a2 + 191);
          __int16 v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          __int16 v112 = 1024;
          *(_DWORD *)os_log_type_t v113 = v48;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v49;
          __int16 v114 = 1024;
          int v115 = v49;
          uint64_t v50 = "%{public}s %{public}s%s<i%u:s%d> id based table is NULL, cannot remove stream %d";
          os_log_type_t v51 = v47;
          os_log_type_t v52 = OS_LOG_TYPE_ERROR;
        }
        _os_log_impl(&dword_1830D4000, v51, v52, v50, buf, 0x32u);
        goto LABEL_107;
      }
      if ((v36 & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v9 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v46 = *(_DWORD *)(a2 + 176);
          int v45 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447234;
          id v107 = "nw_http2_stream_close";
          __int16 v108 = 2082;
          uint64_t v109 = (const char *)(a2 + 191);
          __int16 v110 = 2080;
          uint64_t v111 = (uint64_t)" ";
          __int16 v112 = 1024;
          *(_DWORD *)os_log_type_t v113 = v45;
          *(_WORD *)&v113[4] = 1024;
          *(_DWORD *)&v113[6] = v46;
          uint64_t v12 = "%{public}s %{public}s%s<i%u:s%d> stream id is -1, skipping removal from id based table";
          goto LABEL_70;
        }
      }
      return;
    }
    *(unsigned char *)(a2 + 190) = BYTE2(v5);
    *(_WORD *)(a2 + 188) = v5 & 0xFFFE;
    if ((v5 & 0x80000) != 0 || !gLogDatapath) {
      goto LABEL_22;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v95 = gconnectionLogObj;
    BOOL v96 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
    int v97 = *v4;
    if (v96)
    {
      int v98 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447234;
      id v107 = "nw_http2_stream_send_rst_stream";
      __int16 v108 = 2082;
      uint64_t v109 = (const char *)(a2 + 191);
      __int16 v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      __int16 v112 = 1024;
      *(_DWORD *)os_log_type_t v113 = v98;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v97;
      _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
      int v97 = *(_DWORD *)(a2 + 176);
    }
    if (v97 == -1)
    {
      if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) != 0) {
        goto LABEL_37;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v99 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_37;
      }
      int v101 = *(_DWORD *)(a2 + 176);
      int v100 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      id v107 = "nw_http2_stream_send_rst_stream";
      __int16 v108 = 2082;
      uint64_t v109 = (const char *)(a2 + 191);
      __int16 v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      __int16 v112 = 1024;
      *(_DWORD *)os_log_type_t v113 = v100;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v101;
      __int16 v114 = 1024;
      int v115 = v101;
      int v20 = "%{public}s %{public}s%s<i%u:s%d> cannot send RST_STREAM for stream with invalid stream id %d";
      int v21 = v99;
      os_log_type_t v22 = OS_LOG_TYPE_ERROR;
    }
    else
    {
LABEL_22:
      uint64_t v13 = *(void *)(a1 + 264);
      if (v13) {
        (*(void (**)(void))(v13 + 16))();
      }
      int v14 = nghttp2_submit_rst_stream();
      int v15 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
      if (v14)
      {
        if ((v15 & 0x80000) != 0) {
          goto LABEL_37;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v16 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_37;
        }
        int v18 = *(_DWORD *)(a2 + 176);
        int v17 = *(_DWORD *)(a2 + 180);
        uint64_t v19 = nghttp2_strerror();
        *(_DWORD *)buf = 136447746;
        id v107 = "nw_http2_stream_send_rst_stream";
        __int16 v108 = 2082;
        uint64_t v109 = (const char *)(a2 + 191);
        __int16 v110 = 2080;
        uint64_t v111 = (uint64_t)" ";
        __int16 v112 = 1024;
        *(_DWORD *)os_log_type_t v113 = v17;
        *(_WORD *)&v113[4] = 1024;
        *(_DWORD *)&v113[6] = v18;
        __int16 v114 = 1024;
        int v115 = v18;
        __int16 v116 = 2082;
        uint64_t v117 = v19;
        int v20 = "%{public}s %{public}s%s<i%u:s%d> Failed to submit RST_STREAM on stream %d: %{public}s";
        int v21 = v16;
        os_log_type_t v22 = OS_LOG_TYPE_ERROR;
        uint32_t v23 = 60;
LABEL_36:
        _os_log_impl(&dword_1830D4000, v21, v22, v20, buf, v23);
LABEL_37:
        nw_http2_session_send(a1);
        goto LABEL_38;
      }
      if ((v15 & 0x80000) != 0) {
        goto LABEL_37;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v24 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_37;
      }
      int v26 = *(_DWORD *)(a2 + 176);
      int v25 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      id v107 = "nw_http2_stream_send_rst_stream";
      __int16 v108 = 2082;
      uint64_t v109 = (const char *)(a2 + 191);
      __int16 v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      __int16 v112 = 1024;
      *(_DWORD *)os_log_type_t v113 = v25;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v26;
      __int16 v114 = 1024;
      int v115 = v26;
      int v20 = "%{public}s %{public}s%s<i%u:s%d> Submitted RST_STREAM on stream %d";
      int v21 = v24;
      os_log_type_t v22 = OS_LOG_TYPE_INFO;
    }
    uint32_t v23 = 50;
    goto LABEL_36;
  }
  *(unsigned char *)(a2 + 190) = BYTE2(v5);
  *(_WORD *)(a2 + 188) = v5 & 0xFFFE;
  *(_DWORD *)(a2 + 176) = -1;
  if ((v5 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v9 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *(_DWORD *)(a2 + 176);
      int v10 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447234;
      id v107 = "nw_http2_stream_close";
      __int16 v108 = 2082;
      uint64_t v109 = (const char *)(a2 + 191);
      __int16 v110 = 2080;
      uint64_t v111 = (uint64_t)" ";
      __int16 v112 = 1024;
      *(_DWORD *)os_log_type_t v113 = v10;
      *(_WORD *)&v113[4] = 1024;
      *(_DWORD *)&v113[6] = v11;
      uint64_t v12 = "%{public}s %{public}s%s<i%u:s%d> stream id is -1, skipping rst_stream and removal from id based table";
LABEL_70:
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, v12, buf, 0x2Cu);
    }
  }
}

void nw_http2_session_send(uint64_t a1)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  if (a1 && *(__int16 *)(a1 + 388) < 0)
  {
LABEL_5:
    __int16 v2 = *(_WORD *)(a1 + 388);
    if ((v2 & 0x100) != 0) {
      goto LABEL_83;
    }
    goto LABEL_6;
  }
  if (!gLogDatapath) {
    goto LABEL_4;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  int v41 = gconnectionLogObj;
  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
  {
LABEL_4:
    if (a1) {
      goto LABEL_5;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http2_session_send";
    int v45 = (char *)_os_log_send_and_compose_impl();
    v57[0] = 16;
    char v55 = 0;
    if (__nwlog_fault(v45, v57, &v55))
    {
      if (v57[0] == 17)
      {
        int v46 = __nwlog_obj();
        os_log_type_t v47 = v57[0];
        if (!os_log_type_enabled(v46, (os_log_type_t)v57[0])) {
          goto LABEL_109;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        int v48 = "%{public}s called with null http2";
        goto LABEL_108;
      }
      if (!v55)
      {
        int v46 = __nwlog_obj();
        os_log_type_t v47 = v57[0];
        if (!os_log_type_enabled(v46, (os_log_type_t)v57[0])) {
          goto LABEL_109;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        int v48 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_108;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v46 = __nwlog_obj();
      os_log_type_t v47 = v57[0];
      BOOL v51 = os_log_type_enabled(v46, (os_log_type_t)v57[0]);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_http2_session_send";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_109;
      }
      if (v51)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        int v48 = "%{public}s called with null http2, no backtrace";
LABEL_108:
        _os_log_impl(&dword_1830D4000, v46, v47, v48, buf, 0xCu);
      }
    }
LABEL_109:
    if (v45) {
      free(v45);
    }
    return;
  }
  int v42 = " ";
  int v43 = *(_DWORD *)(a1 + 368);
  *(void *)&uint8_t buf[4] = "nw_http2_session_send";
  *(_WORD *)&unsigned char buf[12] = 2082;
  uint64_t v44 = (const char *)(a1 + 390);
  *(_DWORD *)buf = 136446978;
  if (!a1) {
    uint64_t v44 = "";
  }
  *(void *)&buf[14] = v44;
  if (!a1) {
    int v42 = "";
  }
  *(_WORD *)&buf[22] = 2080;
  *(void *)&unsigned char buf[24] = v42;
  *(_WORD *)&uint8_t buf[32] = 1024;
  *(_DWORD *)&buf[34] = v43;
  _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
  __int16 v2 = *(_WORD *)(a1 + 388);
  if ((v2 & 0x100) != 0)
  {
LABEL_83:
    if ((v2 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v38 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v49 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        *(_WORD *)&uint8_t buf[32] = 1024;
        *(_DWORD *)&buf[34] = v49;
        int v40 = "%{public}s %{public}s%s<i%u> already in session send, skipping";
        goto LABEL_94;
      }
    }
    return;
  }
LABEL_6:
  if ((v2 & 0x200) == 0)
  {
    char v3 = 0;
    *(_WORD *)(a1 + 388) = v2 | 0x100;
    while (1)
    {
      int v5 = nghttp2_session_want_write();
      int v6 = *(__int16 *)(a1 + 388);
      if (!v5)
      {
LABEL_73:
        *(_WORD *)(a1 + 388) = v6 & 0xFEFF;
        if (v3) {
          nw_http2_connection_close(a1);
        }
        return;
      }
      if ((v6 & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v34 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v35 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http2_session_send";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 390;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          *(_WORD *)&uint8_t buf[32] = 1024;
          *(_DWORD *)&buf[34] = v35;
          _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> nghttp2 wants to write", buf, 0x26u);
        }
      }
      *(_WORD *)(a1 + 388) &= ~0x2000u;
      int v7 = nghttp2_session_send();
      if (!v7) {
        goto LABEL_40;
      }
      int v8 = v7;
      if (v7 != -902 || (*(_WORD *)(a1 + 388) & 0x10) == 0) {
        break;
      }
      if ((*(_WORD *)(a1 + 388) & 0x8000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v18 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
        {
          int v19 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http2_session_send";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 390;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          *(_WORD *)&uint8_t buf[32] = 1024;
          *(_DWORD *)&buf[34] = v19;
          _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s%s<i%u> tunnel error, send failed, closing", buf, 0x26u);
        }
      }
LABEL_39:
      char v3 = 1;
LABEL_40:
      if ((*(_WORD *)(a1 + 388) & 0x2000) != 0)
      {
        if ((*(_WORD *)(a1 + 388) & 0x8000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v52 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v53 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_http2_session_send";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 390;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            *(_WORD *)&uint8_t buf[32] = 1024;
            *(_DWORD *)&buf[34] = v53;
            _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> cannot send any more, returning", buf, 0x26u);
          }
        }
        LOWORD(v6) = *(_WORD *)(a1 + 388);
        goto LABEL_73;
      }
      if (*(unsigned __int16 *)(a1 + 374) < 6u)
      {
        if ((*(_WORD *)(a1 + 388) & 0x4000) == 0)
        {
          *(_WORD *)(a1 + 388) |= 0x4000u;
          uint64_t v29 = *(void *)(a1 + 352);
          unint64_t v30 = *(void **)(a1 + 128);
          v54[0] = MEMORY[0x1E4F143A8];
          v54[1] = 0x40000000;
          v54[2] = ___ZL21nw_http2_session_sendP17nw_protocol_http2_block_invoke;
          v54[3] = &unk_1E524A4C0;
          v54[4] = v29;
          nw_queue_context_async(v30, v54);
        }
      }
      else
      {
        nw_http2_finalize_written_output_frames(a1);
      }
      nw_http2_drain_output_frames(a1);
      int v31 = *(__int16 *)(a1 + 388);
      if (v31 < 0)
      {
        if ((v31 & 0x800) == 0) {
          goto LABEL_48;
        }
LABEL_8:
        *(_WORD *)(a1 + 388) = v31 & 0xF7FF;
        os_log_type_t v4 = *(char **)(a1 + 152);
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL41nw_http2_deliver_pending_output_availableP17nw_protocol_http2_block_invoke;
        *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_31_83214;
        *(void *)&uint8_t buf[32] = a1;
        nw_hash_table_apply(v4, (uint64_t)buf);
      }
      else
      {
        if (gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v36 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v37 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)int v57 = 136446978;
            __int16 v58 = "nw_http2_deliver_pending_output_available";
            __int16 v59 = 2082;
            uint64_t v60 = a1 + 390;
            __int16 v61 = 2080;
            int v62 = " ";
            __int16 v63 = 1024;
            int v64 = v37;
            _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", v57, 0x26u);
          }
        }
        LOWORD(v31) = *(_WORD *)(a1 + 388);
        if ((v31 & 0x800) != 0) {
          goto LABEL_8;
        }
LABEL_48:
        if ((v31 & 0x8000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v32 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v33 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)int v57 = 136446978;
            __int16 v58 = "nw_http2_deliver_pending_output_available";
            __int16 v59 = 2082;
            uint64_t v60 = a1 + 390;
            __int16 v61 = 2080;
            int v62 = " ";
            __int16 v63 = 1024;
            int v64 = v33;
            _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> no streams have output available pending, nothing to do", v57, 0x26u);
          }
        }
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = nghttp2_strerror();
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_http2_session_send";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v8;
    *(_WORD *)&buf[18] = 2082;
    *(void *)&buf[20] = v10;
    int v11 = (char *)_os_log_send_and_compose_impl();
    v57[0] = 16;
    char v55 = 0;
    if (__nwlog_fault(v11, v57, &v55))
    {
      if (v57[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = gLogObj;
        uint8_t v13 = v57[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v57[0])) {
          goto LABEL_37;
        }
        uint64_t v14 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v14;
        int v15 = v12;
        os_log_type_t v16 = v13;
        int v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed";
        goto LABEL_36;
      }
      if (!v55)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = gLogObj;
        uint8_t v26 = v57[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v57[0])) {
          goto LABEL_37;
        }
        uint64_t v27 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v27;
        int v15 = v25;
        os_log_type_t v16 = v26;
        int v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, backtrace limit exceeded";
        goto LABEL_36;
      }
      int v20 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v21 = gLogObj;
      os_log_type_t v22 = v57[0];
      BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v57[0]);
      if (v20)
      {
        if (v23)
        {
          uint64_t v24 = nghttp2_strerror();
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_http2_session_send";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v8;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v24;
          *(_WORD *)&buf[28] = 2082;
          *(void *)&buf[30] = v20;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, dumping backtrace:%{public}s", buf, 0x26u);
        }
        free(v20);
        goto LABEL_37;
      }
      if (v23)
      {
        uint64_t v28 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_http2_session_send";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        *(_WORD *)&buf[18] = 2082;
        *(void *)&buf[20] = v28;
        int v15 = v21;
        os_log_type_t v16 = v22;
        int v17 = "%{public}s nghttp2_session_send failed: %d (%{public}s) failed, no backtrace";
LABEL_36:
        _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0x1Cu);
      }
    }
LABEL_37:
    if (v11) {
      free(v11);
    }
    goto LABEL_39;
  }
  if ((v2 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v38 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v39 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_http2_session_send";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      *(_WORD *)&uint8_t buf[32] = 1024;
      *(_DWORD *)&buf[34] = v39;
      int v40 = "%{public}s %{public}s%s<i%u> in mem recv, skipping";
LABEL_94:
      _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, v40, buf, 0x26u);
    }
  }
}

void nw_http2_finalize_written_output_frames(uint64_t a1)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  if (!a1 || (*(__int16 *)(a1 + 388) & 0x80000000) == 0)
  {
    if (!gLogDatapath) {
      goto LABEL_4;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v15 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      os_log_type_t v16 = " ";
      int v17 = *(_DWORD *)(a1 + 368);
      int v41 = "nw_http2_finalize_written_output_frames";
      __int16 v42 = 2082;
      int v18 = (const char *)(a1 + 390);
      *(_DWORD *)buf = 136446978;
      if (!a1) {
        int v18 = "";
      }
      int v43 = (void *)v18;
      if (!a1) {
        os_log_type_t v16 = "";
      }
      __int16 v44 = 2080;
      int v45 = v16;
      __int16 v46 = 1024;
      int v47 = v17;
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
    else
    {
LABEL_4:
      if (!a1)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        int v41 = "nw_http2_finalize_written_output_frames";
        int v19 = (char *)_os_log_send_and_compose_impl();
        v37[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v19, v37, &type)) {
          goto LABEL_98;
        }
        if (v37[0] == OS_LOG_TYPE_FAULT)
        {
          int v20 = __nwlog_obj();
          os_log_type_t v21 = v37[0];
          if (!os_log_type_enabled(v20, v37[0])) {
            goto LABEL_98;
          }
          *(_DWORD *)buf = 136446210;
          int v41 = "nw_http2_finalize_written_output_frames";
          os_log_type_t v22 = "%{public}s called with null http2";
          goto LABEL_97;
        }
        if (type == OS_LOG_TYPE_DEFAULT)
        {
          int v20 = __nwlog_obj();
          os_log_type_t v21 = v37[0];
          if (!os_log_type_enabled(v20, v37[0])) {
            goto LABEL_98;
          }
          *(_DWORD *)buf = 136446210;
          int v41 = "nw_http2_finalize_written_output_frames";
          os_log_type_t v22 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_97;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v20 = __nwlog_obj();
        os_log_type_t v21 = v37[0];
        BOOL v29 = os_log_type_enabled(v20, v37[0]);
        if (!backtrace_string)
        {
          if (!v29) {
            goto LABEL_98;
          }
          *(_DWORD *)buf = 136446210;
          int v41 = "nw_http2_finalize_written_output_frames";
          os_log_type_t v22 = "%{public}s called with null http2, no backtrace";
          goto LABEL_97;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          int v41 = "nw_http2_finalize_written_output_frames";
          __int16 v42 = 2082;
          int v43 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_98:
        if (!v19) {
          return;
        }
        goto LABEL_99;
      }
    }
  }
  char v3 = (uint64_t *)(a1 + 240);
  uint64_t v2 = *(void *)(a1 + 240);
  *(_WORD *)(a1 + 374) = 0;
  if (!v2)
  {
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unint64_t v30 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v31 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        int v41 = "nw_http2_finalize_written_output_frames";
        __int16 v42 = 2082;
        int v43 = (void *)(a1 + 390);
        __int16 v44 = 2080;
        int v45 = " ";
        __int16 v46 = 1024;
        int v47 = v31;
        _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> no written output frames, nothing to finalize", buf, 0x26u);
      }
    }
    return;
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
  }
  if (!_nw_signposts_enabled || !kdebug_is_enabled())
  {
    uint64_t v4 = *(void *)(a1 + 32);
    if (v4) {
      goto LABEL_11;
    }
LABEL_64:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v41 = "nw_http2_finalize_written_output_frames";
    int v19 = (char *)_os_log_send_and_compose_impl();
    v37[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v19, v37, &type)) {
      goto LABEL_98;
    }
    if (v37[0] == OS_LOG_TYPE_FAULT)
    {
      int v20 = __nwlog_obj();
      os_log_type_t v21 = v37[0];
      if (!os_log_type_enabled(v20, v37[0])) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      int v41 = "nw_http2_finalize_written_output_frames";
      os_log_type_t v22 = "%{public}s called with null output_handler";
      goto LABEL_97;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      int v20 = __nwlog_obj();
      os_log_type_t v21 = v37[0];
      if (!os_log_type_enabled(v20, v37[0])) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446210;
      int v41 = "nw_http2_finalize_written_output_frames";
      os_log_type_t v22 = "%{public}s called with null output_handler, backtrace limit exceeded";
      goto LABEL_97;
    }
    char v32 = (char *)__nw_create_backtrace_string();
    int v20 = __nwlog_obj();
    os_log_type_t v21 = v37[0];
    BOOL v33 = os_log_type_enabled(v20, v37[0]);
    if (v32)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        int v41 = "nw_http2_finalize_written_output_frames";
        __int16 v42 = 2082;
        int v43 = v32;
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null output_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v32);
      if (!v19) {
        return;
      }
LABEL_99:
      free(v19);
      return;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      int v41 = "nw_http2_finalize_written_output_frames";
      os_log_type_t v22 = "%{public}s called with null output_handler, no backtrace";
LABEL_97:
      _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
      goto LABEL_98;
    }
    goto LABEL_98;
  }
  kdebug_trace();
  uint64_t v4 = *(void *)(a1 + 32);
  if (!v4) {
    goto LABEL_64;
  }
LABEL_11:
  *(void *)int v37 = 0;
  __int16 v38 = v37;
  uint64_t v5 = *v3;
  if (*v3)
  {
    *(void *)(v5 + 40) = v37;
    int v6 = *(os_log_type_t **)(a1 + 248);
    *(void *)int v37 = v5;
    __int16 v38 = v6;
  }
  *(void *)(a1 + 240) = 0;
  *(void *)(a1 + 248) = v3;
  uint64_t v7 = *(void *)(v4 + 24);
  if (!v7 || (int v8 = *(void (**)(uint64_t, os_log_type_t *))(v7 + 96)) == 0)
  {
    __nwlog_obj();
    uint64_t v9 = *(const char **)(v4 + 16);
    if (!v9) {
      uint64_t v9 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    int v41 = "nw_http2_finalize_written_output_frames";
    __int16 v42 = 2082;
    int v43 = (void *)v9;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v10, &type, &v36)) {
      goto LABEL_89;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_89;
      }
      uint8_t v13 = *(const char **)(v4 + 16);
      if (!v13) {
        uint8_t v13 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      int v41 = "nw_http2_finalize_written_output_frames";
      __int16 v42 = 2082;
      int v43 = (void *)v13;
      uint64_t v14 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
    }
    else if (v36)
    {
      uint64_t v25 = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v26 = os_log_type_enabled(v11, type);
      if (v25)
      {
        if (v26)
        {
          uint64_t v27 = *(const char **)(v4 + 16);
          if (!v27) {
            uint64_t v27 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          int v41 = "nw_http2_finalize_written_output_frames";
          __int16 v42 = 2082;
          int v43 = (void *)v27;
          __int16 v44 = 2082;
          int v45 = v25;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v25);
        goto LABEL_89;
      }
      if (!v26)
      {
LABEL_89:
        if (v10) {
          free(v10);
        }
        goto LABEL_16;
      }
      int v35 = *(const char **)(v4 + 16);
      if (!v35) {
        int v35 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      int v41 = "nw_http2_finalize_written_output_frames";
      __int16 v42 = 2082;
      int v43 = (void *)v35;
      uint64_t v14 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_89;
      }
      int v34 = *(const char **)(v4 + 16);
      if (!v34) {
        int v34 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      int v41 = "nw_http2_finalize_written_output_frames";
      __int16 v42 = 2082;
      int v43 = (void *)v34;
      uint64_t v14 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v11, v12, v14, buf, 0x16u);
    goto LABEL_89;
  }
  v8(v4, v37);
LABEL_16:
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v23 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v24 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136446978;
      int v41 = "nw_http2_finalize_written_output_frames";
      __int16 v42 = 2082;
      int v43 = (void *)(a1 + 390);
      __int16 v44 = 2080;
      int v45 = " ";
      __int16 v46 = 1024;
      int v47 = v24;
      _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> finalized written output frames", buf, 0x26u);
    }
  }
  if (_nw_signposts_once == -1)
  {
    if (!_nw_signposts_enabled) {
      return;
    }
  }
  else
  {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
    if (!_nw_signposts_enabled) {
      return;
    }
  }
  if (kdebug_is_enabled()) {
    kdebug_trace();
  }
}

void ___ZL21nw_http2_session_sendP17nw_protocol_http2_block_invoke(uint64_t a1)
{
  uint64_t v1 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  if (v1)
  {
    *(_WORD *)(v1 + 388) &= ~0x4000u;
    nw_http2_finalize_written_output_frames(v1);
  }
}

void nw_http2_drain_output_frames(uint64_t a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a1 && *(__int16 *)(a1 + 388) < 0) {
    goto LABEL_5;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v4 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v5 = " ";
      int v6 = *(_DWORD *)(a1 + 368);
      os_log_type_t v22 = "nw_http2_drain_output_frames";
      __int16 v23 = 2082;
      uint64_t v7 = (const char *)(a1 + 390);
      *(_DWORD *)buf = 136446978;
      if (!a1) {
        uint64_t v7 = "";
      }
      int v24 = (void *)v7;
      if (!a1) {
        uint64_t v5 = "";
      }
      __int16 v25 = 2080;
      BOOL v26 = v5;
      __int16 v27 = 1024;
      int v28 = v6;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      __int16 v2 = *(_WORD *)(a1 + 388);
      if ((v2 & 0x400) != 0) {
        goto LABEL_17;
      }
      goto LABEL_6;
    }
  }
  if (a1)
  {
LABEL_5:
    __int16 v2 = *(_WORD *)(a1 + 388);
    if ((v2 & 0x400) != 0)
    {
LABEL_17:
      if ((v2 & 0x8000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v14 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v15 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          os_log_type_t v22 = "nw_http2_drain_output_frames";
          __int16 v23 = 2082;
          int v24 = (void *)(a1 + 390);
          __int16 v25 = 2080;
          BOOL v26 = " ";
          __int16 v27 = 1024;
          int v28 = v15;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> already draining output frames, skipping", buf, 0x26u);
        }
      }
      return;
    }
LABEL_6:
    *(_WORD *)(a1 + 388) = v2 | 0x400;
    if ((v2 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v12 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v13 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v22 = "nw_http2_drain_output_frames";
        __int16 v23 = 2082;
        int v24 = (void *)(a1 + 390);
        __int16 v25 = 2080;
        BOOL v26 = " ";
        __int16 v27 = 1024;
        int v28 = v13;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> draining output frames", buf, 0x26u);
      }
    }
    char v3 = *(char **)(a1 + 152);
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 0x40000000;
    v18[2] = ___ZL28nw_http2_drain_output_framesP17nw_protocol_http2_block_invoke;
    v18[3] = &__block_descriptor_tmp_29_83236;
    void v18[4] = a1;
    nw_hash_table_apply(v3, (uint64_t)v18);
    *(_WORD *)(a1 + 388) &= ~0x400u;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v22 = "nw_http2_drain_output_frames";
  int v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v22 = "nw_http2_drain_output_frames";
      int v11 = "%{public}s called with null http2";
      goto LABEL_41;
    }
    if (!v19)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v22 = "nw_http2_drain_output_frames";
      int v11 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v17 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v22 = "nw_http2_drain_output_frames";
        __int16 v23 = 2082;
        int v24 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_42;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v22 = "nw_http2_drain_output_frames";
      int v11 = "%{public}s called with null http2, no backtrace";
LABEL_41:
      _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
    }
  }
LABEL_42:
  if (v8) {
    free(v8);
  }
}

uint64_t ___ZL41nw_http2_deliver_pending_output_availableP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  if (!object)
  {
    uint64_t v11 = *(void *)(a1 + 32);
    if (v11 && *(__int16 *)(v11 + 388) < 0) {
      return 1;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v12 = *(void *)(a1 + 32);
    int v13 = (const char *)(v12 + 390);
    BOOL v14 = v12 == 0;
    int v15 = *(_DWORD *)(v12 + 368);
    if (v14) {
      int v13 = "";
    }
    *(_DWORD *)buf = 136447234;
    int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
    if (v14) {
      os_log_type_t v16 = "";
    }
    else {
      os_log_type_t v16 = " ";
    }
    __int16 v70 = 2082;
    int v71 = v13;
    __int16 v72 = 2080;
    int v73 = v16;
    __int16 v74 = 1024;
    int v75 = v15;
    __int16 v76 = 2048;
    *(void *)os_log_type_t v77 = a2;
    BOOL v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (__nwlog_fault(v17, &type, &v66))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v18 = gconnectionLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_68;
        }
        uint64_t v20 = *(void *)(a1 + 32);
        os_log_type_t v21 = (const char *)(v20 + 390);
        BOOL v22 = v20 == 0;
        if (!v20) {
          os_log_type_t v21 = "";
        }
        int v23 = *(_DWORD *)(v20 + 368);
        if (v22) {
          int v24 = "";
        }
        else {
          int v24 = " ";
        }
        *(_DWORD *)buf = 136447234;
        int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
        __int16 v70 = 2082;
        int v71 = v21;
        __int16 v72 = 2080;
        int v73 = v24;
        __int16 v74 = 1024;
        int v75 = v23;
        __int16 v76 = 2048;
        *(void *)os_log_type_t v77 = a2;
        __int16 v25 = "%{public}s %{public}s%s<i%u> no object for hash node %p, not triggering output_available";
        goto LABEL_67;
      }
      if (!v66)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v18 = gconnectionLogObj;
        os_log_type_t v19 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_68;
        }
        uint64_t v40 = *(void *)(a1 + 32);
        int v41 = (const char *)(v40 + 390);
        BOOL v42 = v40 == 0;
        if (!v40) {
          int v41 = "";
        }
        int v43 = *(_DWORD *)(v40 + 368);
        if (v42) {
          __int16 v44 = "";
        }
        else {
          __int16 v44 = " ";
        }
        *(_DWORD *)buf = 136447234;
        int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
        __int16 v70 = 2082;
        int v71 = v41;
        __int16 v72 = 2080;
        int v73 = v44;
        __int16 v74 = 1024;
        int v75 = v43;
        __int16 v76 = 2048;
        *(void *)os_log_type_t v77 = a2;
        __int16 v25 = "%{public}s %{public}s%s<i%u> no object for hash node %p, not triggering output_available, backtrace limit exceeded";
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v18 = gconnectionLogObj;
      os_log_type_t v19 = type;
      BOOL v34 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (backtrace_string)
      {
        if (v34)
        {
          uint64_t v35 = *(void *)(a1 + 32);
          char v36 = (const char *)(v35 + 390);
          BOOL v37 = v35 == 0;
          if (!v35) {
            char v36 = "";
          }
          int v38 = *(_DWORD *)(v35 + 368);
          if (v37) {
            int v39 = "";
          }
          else {
            int v39 = " ";
          }
          *(_DWORD *)buf = 136447490;
          int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
          __int16 v70 = 2082;
          int v71 = v36;
          __int16 v72 = 2080;
          int v73 = v39;
          __int16 v74 = 1024;
          int v75 = v38;
          __int16 v76 = 2048;
          *(void *)os_log_type_t v77 = a2;
          *(_WORD *)&v77[8] = 2082;
          *(void *)&v77[10] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s %{public}s%s<i%u> no object for hash node %p, not triggering output_available, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(backtrace_string);
        goto LABEL_68;
      }
      if (v34)
      {
        uint64_t v45 = *(void *)(a1 + 32);
        __int16 v46 = (const char *)(v45 + 390);
        BOOL v47 = v45 == 0;
        if (!v45) {
          __int16 v46 = "";
        }
        int v48 = *(_DWORD *)(v45 + 368);
        if (v47) {
          int v49 = "";
        }
        else {
          int v49 = " ";
        }
        *(_DWORD *)buf = 136447234;
        int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
        __int16 v70 = 2082;
        int v71 = v46;
        __int16 v72 = 2080;
        int v73 = v49;
        __int16 v74 = 1024;
        int v75 = v48;
        __int16 v76 = 2048;
        *(void *)os_log_type_t v77 = a2;
        __int16 v25 = "%{public}s %{public}s%s<i%u> no object for hash node %p, not triggering output_available, no backtrace";
LABEL_67:
        _os_log_impl(&dword_1830D4000, v18, v19, v25, buf, 0x30u);
      }
    }
LABEL_68:
    if (!v17) {
      return 1;
    }
    uint64_t v50 = (char *)v17;
LABEL_70:
    free(v50);
    return 1;
  }
  uint64_t v5 = object;
  uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
  if (v6)
  {
    int v7 = *(unsigned __int16 *)(v6 + 188);
    int v8 = v7 | (*(unsigned __int8 *)(v6 + 190) << 16);
    if ((v7 & 0x20) != 0)
    {
      *(_WORD *)(v6 + 188) = v7 & 0xFFDF;
      *(unsigned char *)(v6 + 190) = (v8 & 0xFFFFFFDF) >> 16;
      if ((v8 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v58 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v60 = *(_DWORD *)(v6 + 176);
          int v59 = *(_DWORD *)(v6 + 180);
          *(_DWORD *)buf = 136447746;
          int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
          __int16 v70 = 2082;
          int v71 = (const char *)(v6 + 191);
          __int16 v72 = 2080;
          int v73 = " ";
          __int16 v74 = 1024;
          int v75 = v59;
          __int16 v76 = 1024;
          *(_DWORD *)os_log_type_t v77 = v60;
          *(_WORD *)&v77[4] = 2048;
          *(void *)&v77[6] = v5;
          *(_WORD *)&v77[14] = 1024;
          *(_DWORD *)&v77[16] = v60;
          _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> delivering output_available to protocol %p for stream %d", buf, 0x3Cu);
        }
      }
      uint64_t v9 = *(void *)(v5 + 24);
      if (v9)
      {
        os_log_type_t v10 = *(void (**)(uint64_t, void))(v9 + 72);
        if (v10)
        {
          v10(v5, *(void *)(a1 + 32));
          return 1;
        }
      }
      __nwlog_obj();
      os_log_type_t v52 = *(const char **)(v5 + 16);
      if (!v52) {
        os_log_type_t v52 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
      __int16 v70 = 2082;
      int v71 = v52;
      int v53 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v66 = 0;
      if (!__nwlog_fault(v53, &type, &v66)) {
        goto LABEL_100;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v54 = __nwlog_obj();
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v54, type))
        {
          int v56 = *(const char **)(v5 + 16);
          if (!v56) {
            int v56 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
          __int16 v70 = 2082;
          int v71 = v56;
          int v57 = "%{public}s protocol %{public}s has invalid output_available callback";
LABEL_99:
          _os_log_impl(&dword_1830D4000, v54, v55, v57, buf, 0x16u);
        }
      }
      else if (v66)
      {
        __int16 v61 = (char *)__nw_create_backtrace_string();
        int v54 = __nwlog_obj();
        os_log_type_t v55 = type;
        BOOL v62 = os_log_type_enabled(v54, type);
        if (v61)
        {
          if (v62)
          {
            __int16 v63 = *(const char **)(v5 + 16);
            if (!v63) {
              __int16 v63 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
            __int16 v70 = 2082;
            int v71 = v63;
            __int16 v72 = 2082;
            int v73 = v61;
            _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s protocol %{public}s has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v61);
          goto LABEL_100;
        }
        if (v62)
        {
          uint64_t v65 = *(const char **)(v5 + 16);
          if (!v65) {
            uint64_t v65 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
          __int16 v70 = 2082;
          int v71 = v65;
          int v57 = "%{public}s protocol %{public}s has invalid output_available callback, no backtrace";
          goto LABEL_99;
        }
      }
      else
      {
        int v54 = __nwlog_obj();
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v54, type))
        {
          int v64 = *(const char **)(v5 + 16);
          if (!v64) {
            int v64 = "invalid";
          }
          *(_DWORD *)buf = 136446466;
          int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
          __int16 v70 = 2082;
          int v71 = v64;
          int v57 = "%{public}s protocol %{public}s has invalid output_available callback, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
LABEL_100:
      if (!v53) {
        return 1;
      }
      uint64_t v50 = (char *)v53;
      goto LABEL_70;
    }
  }
  else
  {
    uint64_t v26 = *(void *)(a1 + 32);
    if (!v26 || (*(__int16 *)(v26 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v27 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v28 = *(void *)(a1 + 32);
        uint64_t v29 = (const char *)(v28 + 390);
        unint64_t v30 = "";
        BOOL v31 = v28 == 0;
        int v32 = *(_DWORD *)(v28 + 368);
        if (v31) {
          uint64_t v29 = "";
        }
        int v69 = "nw_http2_deliver_pending_output_available_block_invoke";
        __int16 v70 = 2082;
        *(_DWORD *)buf = 136446978;
        if (!v31) {
          unint64_t v30 = " ";
        }
        int v71 = v29;
        __int16 v72 = 2080;
        int v73 = v30;
        __int16 v74 = 1024;
        int v75 = v32;
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> input protocol has no stream, not triggering output_available", buf, 0x26u);
      }
    }
  }
  return 1;
}

uint64_t ___ZL28nw_http2_drain_output_framesP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
    if (v6)
    {
      if ((*(_WORD *)(v6 + 188) & 2) != 0)
      {
        while ((nw_http2_drain_next_frame_for_stream(*(void *)(a1 + 32), v5, v6, 1) & 1) != 0)
          ;
      }
      return 1;
    }
    uint64_t v17 = *(void *)(a1 + 32);
    if (!v17 || (*(__int16 *)(v17 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v18 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v19 = *(void *)(a1 + 32);
        uint64_t v20 = (const char *)(v19 + 390);
        os_log_type_t v21 = "";
        BOOL v22 = v19 == 0;
        int v23 = *(_DWORD *)(v19 + 368);
        uint64_t v26 = "nw_http2_drain_output_frames_block_invoke";
        if (v22) {
          uint64_t v20 = "";
        }
        __int16 v27 = 2082;
        int v25 = 136447234;
        if (!v22) {
          os_log_type_t v21 = " ";
        }
        uint64_t v28 = v20;
        __int16 v29 = 2080;
        unint64_t v30 = v21;
        __int16 v31 = 1024;
        int v32 = v23;
        __int16 v33 = 2048;
        uint64_t v34 = v5;
        BOOL v14 = "%{public}s %{public}s%s<i%u> stream not found for input protocol %p, not draining output frames";
        int v15 = v18;
        os_log_type_t v16 = OS_LOG_TYPE_INFO;
LABEL_26:
        _os_log_impl(&dword_1830D4000, v15, v16, v14, (uint8_t *)&v25, 0x30u);
      }
    }
  }
  else
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (!v7 || (*(__int16 *)(v7 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v8 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v9 = *(void *)(a1 + 32);
        os_log_type_t v10 = (const char *)(v9 + 390);
        uint64_t v11 = "";
        BOOL v12 = v9 == 0;
        int v13 = *(_DWORD *)(v9 + 368);
        uint64_t v26 = "nw_http2_drain_output_frames_block_invoke";
        if (v12) {
          os_log_type_t v10 = "";
        }
        __int16 v27 = 2082;
        int v25 = 136447234;
        if (!v12) {
          uint64_t v11 = " ";
        }
        uint64_t v28 = v10;
        __int16 v29 = 2080;
        unint64_t v30 = v11;
        __int16 v31 = 1024;
        int v32 = v13;
        __int16 v33 = 2048;
        uint64_t v34 = a2;
        BOOL v14 = "%{public}s %{public}s%s<i%u> input protocol in node %p in protocol table is NULL, skipping";
        int v15 = v8;
        os_log_type_t v16 = OS_LOG_TYPE_ERROR;
        goto LABEL_26;
      }
    }
  }
  return 1;
}

uint64_t nw_http2_drain_next_frame_for_stream(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  uint64_t v163 = *MEMORY[0x1E4F143B8];
  p_cache = NWConcrete_nw_resolution_report.cache;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v58 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v60 = *(_DWORD *)(a3 + 176);
      int v59 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447234;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      __int16 v154 = 2082;
      uint64_t v155 = a3 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v59;
      __int16 v158 = 1024;
      int v159 = v60;
      _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
    }
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
    int v54 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v54, v149, &type)) {
      goto LABEL_201;
    }
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v55 = __nwlog_obj();
      os_log_type_t v56 = v149[0];
      if (!os_log_type_enabled(v55, v149[0])) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null http2";
      goto LABEL_200;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v55 = __nwlog_obj();
      os_log_type_t v56 = v149[0];
      if (!os_log_type_enabled(v55, v149[0])) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v55 = __nwlog_obj();
    os_log_type_t v56 = v149[0];
    BOOL v69 = os_log_type_enabled(v55, v149[0]);
    if (!backtrace_string)
    {
      if (!v69) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null http2, no backtrace";
      goto LABEL_200;
    }
    if (!v69) {
      goto LABEL_152;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
    __int16 v154 = 2082;
    uint64_t v155 = (uint64_t)backtrace_string;
    __int16 v70 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_151:
    _os_log_impl(&dword_1830D4000, v55, v56, v70, buf, 0x16u);
    goto LABEL_152;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
    int v54 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v54, v149, &type)) {
      goto LABEL_201;
    }
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v55 = __nwlog_obj();
      os_log_type_t v56 = v149[0];
      if (!os_log_type_enabled(v55, v149[0])) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null input_handler";
      goto LABEL_200;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v55 = __nwlog_obj();
      os_log_type_t v56 = v149[0];
      if (!os_log_type_enabled(v55, v149[0])) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null input_handler, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v55 = __nwlog_obj();
    os_log_type_t v56 = v149[0];
    BOOL v71 = os_log_type_enabled(v55, v149[0]);
    if (!backtrace_string)
    {
      if (!v71) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null input_handler, no backtrace";
      goto LABEL_200;
    }
    if (!v71) {
      goto LABEL_152;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
    __int16 v154 = 2082;
    uint64_t v155 = (uint64_t)backtrace_string;
    __int16 v70 = "%{public}s called with null input_handler, dumping backtrace:%{public}s";
    goto LABEL_151;
  }
  uint64_t v9 = (uint64_t *)(a3 + 16);
  int v10 = (*(unsigned __int8 *)(a3 + 190) >> 3) & 1;
  if (!gLogDatapath) {
    LOBYTE(v10) = 1;
  }
  if (!*(void *)(a3 + 16))
  {
    if ((v10 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v72 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v74 = *(_DWORD *)(a3 + 176);
        int v73 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447490;
        uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
        __int16 v154 = 2082;
        uint64_t v155 = a3 + 191;
        __int16 v156 = 2080;
        *(void *)uint64_t v157 = " ";
        *(_WORD *)&v157[8] = 1024;
        *(_DWORD *)&v157[10] = v73;
        __int16 v158 = 1024;
        int v159 = v74;
        __int16 v160 = 1024;
        *(_DWORD *)BOOL v161 = v74;
        int v75 = "%{public}s %{public}s%s<i%u:s%d> no next frame to drain for stream %d";
        __int16 v76 = v72;
        os_log_type_t v77 = OS_LOG_TYPE_DEBUG;
        uint32_t v78 = 50;
LABEL_246:
        _os_log_impl(&dword_1830D4000, v76, v77, v75, buf, v78);
        return 0;
      }
    }
    return 0;
  }
  if ((v10 & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v61 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v63 = *(_DWORD *)(a3 + 176);
      int v62 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447490;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      __int16 v154 = 2082;
      uint64_t v155 = a3 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v62;
      __int16 v158 = 1024;
      int v159 = v63;
      __int16 v160 = 1024;
      *(_DWORD *)BOOL v161 = v63;
      _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> draining next frame for stream %d", buf, 0x32u);
    }
  }
  uint64_t v11 = *v9;
  if (!*v9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
    int v54 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v54, v149, &type)) {
      goto LABEL_201;
    }
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v55 = __nwlog_obj();
      os_log_type_t v56 = v149[0];
      if (!os_log_type_enabled(v55, v149[0])) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null frame";
      goto LABEL_200;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v55 = __nwlog_obj();
      os_log_type_t v56 = v149[0];
      if (!os_log_type_enabled(v55, v149[0])) {
        goto LABEL_201;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      int v57 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_200;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v55 = __nwlog_obj();
    os_log_type_t v56 = v149[0];
    BOOL v87 = os_log_type_enabled(v55, v149[0]);
    if (backtrace_string)
    {
      if (v87)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
        __int16 v154 = 2082;
        uint64_t v155 = (uint64_t)backtrace_string;
        __int16 v70 = "%{public}s called with null frame, dumping backtrace:%{public}s";
        goto LABEL_151;
      }
LABEL_152:
      free(backtrace_string);
      goto LABEL_201;
    }
    if (!v87) {
      goto LABEL_201;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
    int v57 = "%{public}s called with null frame, no backtrace";
LABEL_200:
    _os_log_impl(&dword_1830D4000, v55, v56, v57, buf, 0xCu);
LABEL_201:
    if (v54) {
      free(v54);
    }
    return 0;
  }
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v64 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v65 = *(_DWORD *)(a3 + 176);
      int v66 = *(_DWORD *)(a3 + 180);
      int v67 = *(_DWORD *)(v11 + 52);
      if (v67) {
        v67 -= *(_DWORD *)(v11 + 56) + *(_DWORD *)(v11 + 60);
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      __int16 v154 = 2082;
      uint64_t v155 = a3 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v66;
      __int16 v158 = 1024;
      int v159 = v65;
      __int16 v160 = 1024;
      *(_DWORD *)BOOL v161 = v67;
      _os_log_impl(&dword_1830D4000, v64, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> draining output frame of %u bytes", buf, 0x32u);
    }
  }
  uint64_t v12 = *(void *)(v11 + 16);
  int v13 = *(void **)(v11 + 24);
  BOOL v14 = (void *)(v11 + 16);
  if (v12)
  {
    *(void *)(v12 + 24) = v13;
    int v13 = *(void **)(v11 + 24);
  }
  else
  {
    *(void *)(a3 + 24) = v13;
  }
  *int v13 = v12;
  void *v14 = 0;
  *(void *)(v11 + 24) = 0;
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  int v16 = *(_DWORD *)(v11 + 52);
  uint64_t v146 = a2;
  if (!v16 || v16 == *(_DWORD *)(v11 + 56) + *(_DWORD *)(v11 + 60))
  {
    uint64_t v17 = *(void *)(v11 + 64);
    if (!v17 || (*(unsigned char *)(v17 + 66) & 0x40) == 0)
    {
      if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v88 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v89 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          uint64_t v153 = "nw_http2_submit_data";
          __int16 v154 = 2082;
          uint64_t v155 = a1 + 390;
          __int16 v156 = 2080;
          *(void *)uint64_t v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v89;
          _os_log_impl(&dword_1830D4000, v88, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> skipping empty frame body", buf, 0x26u);
        }
      }
      nw_frame_cache_return_frame(a1 + 200, v11);
      uint64_t v15 = 1;
      goto LABEL_248;
    }
  }
  if ((*(_WORD *)(v11 + 204) & 4) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_submit_data";
    os_log_type_t v79 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v79, v149, &type)) {
      goto LABEL_226;
    }
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v80 = __nwlog_obj();
      os_log_type_t v81 = v149[0];
      if (!os_log_type_enabled(v80, v149[0])) {
        goto LABEL_226;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v82 = "%{public}s called with null output_context";
LABEL_225:
      _os_log_impl(&dword_1830D4000, v80, v81, v82, buf, 0xCu);
      goto LABEL_226;
    }
    int v90 = a4;
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v80 = __nwlog_obj();
      os_log_type_t v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null output_context, backtrace limit exceeded";
        goto LABEL_225;
      }
      goto LABEL_226;
    }
    int v91 = (char *)__nw_create_backtrace_string();
    os_log_type_t v80 = __nwlog_obj();
    os_log_type_t v81 = v149[0];
    BOOL v92 = os_log_type_enabled(v80, v149[0]);
    if (!v91)
    {
      a4 = v90;
      if (v92)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null output_context, no backtrace";
        goto LABEL_225;
      }
      goto LABEL_226;
    }
    if (!v92) {
      goto LABEL_174;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v153 = "nw_http2_submit_data";
    __int16 v154 = 2082;
    uint64_t v155 = (uint64_t)v91;
    int v93 = "%{public}s called with null output_context, dumping backtrace:%{public}s";
LABEL_173:
    _os_log_impl(&dword_1830D4000, v80, v81, v93, buf, 0x16u);
    goto LABEL_174;
  }
  uint64_t v18 = *(void *)(v11 + 216);
  if (!v18)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_submit_data";
    os_log_type_t v79 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v79, v149, &type)) {
      goto LABEL_226;
    }
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v80 = __nwlog_obj();
      os_log_type_t v81 = v149[0];
      if (!os_log_type_enabled(v80, v149[0])) {
        goto LABEL_226;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v82 = "%{public}s called with null input_protocol";
      goto LABEL_225;
    }
    int v90 = a4;
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v80 = __nwlog_obj();
      os_log_type_t v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_225;
      }
      goto LABEL_226;
    }
    int v91 = (char *)__nw_create_backtrace_string();
    os_log_type_t v80 = __nwlog_obj();
    os_log_type_t v81 = v149[0];
    BOOL v94 = os_log_type_enabled(v80, v149[0]);
    if (!v91)
    {
      a4 = v90;
      if (v94)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_225;
      }
      goto LABEL_226;
    }
    if (!v94) {
      goto LABEL_174;
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v153 = "nw_http2_submit_data";
    __int16 v154 = 2082;
    uint64_t v155 = (uint64_t)v91;
    int v93 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_173;
  }
  uint64_t v19 = *(void *)(v18 + 56);
  if (!v19)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_submit_data";
    os_log_type_t v79 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v79, v149, &type)) {
      goto LABEL_226;
    }
    if (v149[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v80 = __nwlog_obj();
      os_log_type_t v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null node";
        goto LABEL_225;
      }
LABEL_226:
      if (v79) {
        free(v79);
      }
      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
LABEL_235:
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v111 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v113 = *(_DWORD *)(a3 + 176);
          int v112 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447490;
          uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
          __int16 v154 = 2082;
          uint64_t v155 = a3 + 191;
          __int16 v156 = 2080;
          *(void *)uint64_t v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v112;
          __int16 v158 = 1024;
          int v159 = v113;
          __int16 v160 = 2048;
          *(void *)BOOL v161 = v11;
          _os_log_impl(&dword_1830D4000, v111, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> couldn't send frame %p, unknown error, dropping", buf, 0x36u);
        }
      }
      nw_frame_cache_return_frame(a1 + 200, v11);
      if ((*(_WORD *)(a1 + 388) & 4) != 0)
      {
        uint64_t v15 = 0;
        goto LABEL_248;
      }
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v114 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v116 = *(_DWORD *)(a3 + 176);
          int v115 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447234;
          uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
          __int16 v154 = 2082;
          uint64_t v155 = a3 + 191;
          __int16 v156 = 2080;
          *(void *)uint64_t v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v115;
          __int16 v158 = 1024;
          int v159 = v116;
          int v75 = "%{public}s %{public}s%s<i%u:s%d> tunnel is no longer connected";
          __int16 v76 = v114;
          os_log_type_t v77 = OS_LOG_TYPE_ERROR;
          uint32_t v78 = 44;
          goto LABEL_246;
        }
      }
      return 0;
    }
    int v90 = a4;
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v80 = __nwlog_obj();
      os_log_type_t v81 = v149[0];
      if (os_log_type_enabled(v80, v149[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_225;
      }
      goto LABEL_226;
    }
    int v91 = (char *)__nw_create_backtrace_string();
    os_log_type_t v80 = __nwlog_obj();
    os_log_type_t v81 = v149[0];
    BOOL v95 = os_log_type_enabled(v80, v149[0]);
    if (!v91)
    {
      a4 = v90;
      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v82 = "%{public}s called with null node, no backtrace";
        goto LABEL_225;
      }
      goto LABEL_226;
    }
    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v154 = 2082;
      uint64_t v155 = (uint64_t)v91;
      int v93 = "%{public}s called with null node, dumping backtrace:%{public}s";
      goto LABEL_173;
    }
LABEL_174:
    free(v91);
    a4 = v90;
    goto LABEL_226;
  }
  int v147 = a4;
  uint64_t v20 = *(void *)(v19 + 32);
  if (!v20)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v153 = "nw_http2_submit_data";
    int v83 = (char *)_os_log_send_and_compose_impl();
    v149[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    a4 = v147;
    if (__nwlog_fault(v83, v149, &type))
    {
      if (v149[0] == OS_LOG_TYPE_FAULT)
      {
        int v84 = __nwlog_obj();
        os_log_type_t v85 = v149[0];
        if (os_log_type_enabled(v84, v149[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v153 = "nw_http2_submit_data";
          BOOL v86 = "%{public}s called with null stream";
LABEL_231:
          _os_log_impl(&dword_1830D4000, v84, v85, v86, buf, 0xCu);
        }
      }
      else if (type)
      {
        BOOL v96 = (char *)__nw_create_backtrace_string();
        int v84 = __nwlog_obj();
        os_log_type_t v85 = v149[0];
        BOOL v97 = os_log_type_enabled(v84, v149[0]);
        if (v96)
        {
          if (v97)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v153 = "nw_http2_submit_data";
            __int16 v154 = 2082;
            uint64_t v155 = (uint64_t)v96;
            _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s called with null stream, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v96);
          a4 = v147;
          goto LABEL_232;
        }
        a4 = v147;
        if (v97)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v153 = "nw_http2_submit_data";
          BOOL v86 = "%{public}s called with null stream, no backtrace";
          goto LABEL_231;
        }
      }
      else
      {
        int v84 = __nwlog_obj();
        os_log_type_t v85 = v149[0];
        a4 = v147;
        if (os_log_type_enabled(v84, v149[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v153 = "nw_http2_submit_data";
          BOOL v86 = "%{public}s called with null stream, backtrace limit exceeded";
          goto LABEL_231;
        }
      }
    }
LABEL_232:
    if (v83) {
      free(v83);
    }
    p_cache = NWConcrete_nw_resolution_report.cache;
    goto LABEL_235;
  }
  int v21 = *(_DWORD *)(v20 + 176);
  *(void *)os_log_type_t v149 = v11;
  BOOL v150 = data_source_read_callback;
  uint64_t v22 = *(void *)(v11 + 64);
  if (v22)
  {
    char v23 = *(unsigned char *)(v22 + 66);
    int v24 = (unsigned __int16 *)(v20 + 188);
    unsigned int v25 = *(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16);
    if ((v23 & 0x40) != 0)
    {
      int v26 = (v25 >> 19) & 1;
      if (!gLogDatapath) {
        LOBYTE(v26) = 1;
      }
      if ((*(_WORD *)(v20 + 188) & 0x200) == 0)
      {
        if ((v26 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v106 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v108 = *(_DWORD *)(v20 + 176);
            int v107 = *(_DWORD *)(v20 + 180);
            *(_DWORD *)buf = 136447234;
            uint64_t v153 = "nw_http2_submit_data";
            __int16 v154 = 2082;
            uint64_t v155 = v20 + 191;
            __int16 v156 = 2080;
            *(void *)uint64_t v157 = " ";
            *(_WORD *)&v157[8] = 1024;
            *(_DWORD *)&v157[10] = v107;
            __int16 v158 = 1024;
            int v159 = v108;
            _os_log_impl(&dword_1830D4000, v106, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> frame is complete, marking end stream", buf, 0x2Cu);
          }
        }
        goto LABEL_49;
      }
      if ((v26 & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v27 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v110 = *(_DWORD *)(v20 + 176);
          int v109 = *(_DWORD *)(v20 + 180);
          *(_DWORD *)buf = 136447234;
          uint64_t v153 = "nw_http2_submit_data";
          __int16 v154 = 2082;
          uint64_t v155 = v20 + 191;
          __int16 v156 = 2080;
          *(void *)uint64_t v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v109;
          __int16 v158 = 1024;
          int v159 = v110;
          unint64_t v30 = "%{public}s %{public}s%s<i%u:s%d> stream is in CONNECT mode, not marking end stream";
          goto LABEL_47;
        }
      }
      goto LABEL_49;
    }
  }
  else
  {
    int v24 = (unsigned __int16 *)(v20 + 188);
    unsigned int v25 = *(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16);
  }
  if ((v25 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v27 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v29 = *(_DWORD *)(v20 + 176);
      int v28 = *(_DWORD *)(v20 + 180);
      *(_DWORD *)buf = 136447234;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v154 = 2082;
      uint64_t v155 = v20 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v28;
      __int16 v158 = 1024;
      int v159 = v29;
      unint64_t v30 = "%{public}s %{public}s%s<i%u:s%d> frame is not complete, not marking end stream";
LABEL_47:
      _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, v30, buf, 0x2Cu);
    }
  }
LABEL_49:
  int v31 = nghttp2_submit_data();
  if (!v31)
  {
    if (((*v24 | (*((unsigned __int8 *)v24 + 2) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v102 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v103 = *(_DWORD *)(v20 + 176);
        int v104 = *(_DWORD *)(v20 + 180);
        int v105 = *(_DWORD *)(v11 + 52);
        if (v105) {
          v105 -= *(_DWORD *)(v11 + 56) + *(_DWORD *)(v11 + 60);
        }
        *(_DWORD *)buf = 136447746;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v154 = 2082;
        uint64_t v155 = v20 + 191;
        __int16 v156 = 2080;
        *(void *)uint64_t v157 = " ";
        *(_WORD *)&v157[8] = 1024;
        *(_DWORD *)&v157[10] = v104;
        __int16 v158 = 1024;
        int v159 = v103;
        __int16 v160 = 1024;
        *(_DWORD *)BOOL v161 = v105;
        *(_WORD *)&v161[4] = 1024;
        *(_DWORD *)&v161[6] = v21;
        _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> submitted %u bytes on stream %d", buf, 0x38u);
        p_cache = NWConcrete_nw_resolution_report.cache;
      }
    }
    uint64_t v15 = 1;
    goto LABEL_90;
  }
  int v32 = v31;
  if (v31 == -510)
  {
    p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
    if (((*v24 | (*((unsigned __int8 *)v24 + 2) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v33 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        int v35 = *(_DWORD *)(v20 + 176);
        int v34 = *(_DWORD *)(v20 + 180);
        *(_DWORD *)buf = 136447490;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v154 = 2082;
        uint64_t v155 = v20 + 191;
        __int16 v156 = 2080;
        *(void *)uint64_t v157 = " ";
        *(_WORD *)&v157[8] = 1024;
        *(_DWORD *)&v157[10] = v34;
        __int16 v158 = 1024;
        int v159 = v35;
        __int16 v160 = 1024;
        *(_DWORD *)BOOL v161 = v21;
        _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> stream %d is closed, cannot send frames", buf, 0x32u);
      }
    }
    a4 = v147;
    goto LABEL_235;
  }
  if (v31 == -529)
  {
    p_cache = NWConcrete_nw_resolution_report.cache;
    if (((*v24 | (*((unsigned __int8 *)v24 + 2) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v98 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v99 = *(_DWORD *)(v20 + 176);
        int v100 = *(_DWORD *)(v20 + 180);
        int v101 = *(_DWORD *)(v11 + 52);
        if (v101) {
          v101 -= *(_DWORD *)(v11 + 56) + *(_DWORD *)(v11 + 60);
        }
        *(_DWORD *)buf = 136447746;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v154 = 2082;
        uint64_t v155 = v20 + 191;
        __int16 v156 = 2080;
        *(void *)uint64_t v157 = " ";
        *(_WORD *)&v157[8] = 1024;
        *(_DWORD *)&v157[10] = v100;
        __int16 v158 = 1024;
        int v159 = v99;
        __int16 v160 = 1024;
        *(_DWORD *)BOOL v161 = v21;
        *(_WORD *)&v161[4] = 1024;
        *(_DWORD *)&v161[6] = v101;
        _os_log_impl(&dword_1830D4000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> already have data outgoing on stream %d, cannot send %u bytes", buf, 0x38u);
        p_cache = NWConcrete_nw_resolution_report.cache;
      }
    }
    a4 = v147;
    goto LABEL_81;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v36 = nghttp2_strerror();
  *(_DWORD *)buf = 136446722;
  uint64_t v153 = "nw_http2_submit_data";
  __int16 v154 = 2082;
  uint64_t v155 = v36;
  __int16 v156 = 1024;
  *(_DWORD *)uint64_t v157 = v21;
  BOOL v37 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v148 = 0;
  if (__nwlog_fault(v37, &type, &v148))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v38 = gLogObj;
      os_log_type_t v39 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_77;
      }
      uint64_t v40 = nghttp2_strerror();
      *(_DWORD *)buf = 136446722;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v154 = 2082;
      uint64_t v155 = v40;
      __int16 v156 = 1024;
      *(_DWORD *)uint64_t v157 = v21;
      int v41 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed";
LABEL_75:
      __int16 v46 = v38;
LABEL_76:
      _os_log_impl(&dword_1830D4000, v46, v39, v41, buf, 0x1Cu);
      goto LABEL_77;
    }
    if (!v148)
    {
      int v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_77;
      }
      uint64_t v45 = nghttp2_strerror();
      *(_DWORD *)buf = 136446722;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v154 = 2082;
      uint64_t v155 = v45;
      __int16 v156 = 1024;
      *(_DWORD *)uint64_t v157 = v21;
      int v41 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, backtrace limit exceeded";
      goto LABEL_75;
    }
    BOOL v42 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v39 = type;
    unsigned int log = gLogObj;
    BOOL v43 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v42)
    {
      if (v43)
      {
        uint64_t v44 = nghttp2_strerror();
        *(_DWORD *)buf = 136446978;
        uint64_t v153 = "nw_http2_submit_data";
        __int16 v154 = 2082;
        uint64_t v155 = v44;
        __int16 v156 = 1024;
        *(_DWORD *)uint64_t v157 = v21;
        *(_WORD *)&v157[4] = 2082;
        *(void *)&v157[6] = v42;
        _os_log_impl(&dword_1830D4000, log, v39, "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, dumping backtrace:%{public}s", buf, 0x26u);
      }
      free(v42);
    }
    else if (v43)
    {
      uint64_t v53 = nghttp2_strerror();
      *(_DWORD *)buf = 136446722;
      uint64_t v153 = "nw_http2_submit_data";
      __int16 v154 = 2082;
      uint64_t v155 = v53;
      __int16 v156 = 1024;
      *(_DWORD *)uint64_t v157 = v21;
      int v41 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, no backtrace";
      __int16 v46 = log;
      goto LABEL_76;
    }
  }
LABEL_77:
  if (v37) {
    free(v37);
  }
  BOOL v47 = v32 == -529;
  p_cache = NWConcrete_nw_resolution_report.cache;
  a4 = v147;
  if (!v47) {
    goto LABEL_235;
  }
LABEL_81:
  uint64_t v15 = 0;
  uint64_t v48 = *(void *)(a3 + 16);
  *(void *)(v11 + 16) = v48;
  if (!v48) {
    uint64_t v48 = a3;
  }
  *(void *)(v48 + 24) = v14;
  *(void *)(a3 + 16) = v11;
  *(void *)(v11 + 24) = v9;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v49 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v51 = *(_DWORD *)(a3 + 176);
      int v50 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)(a3 + 16), 0, buf);
      int v52 = *(_DWORD *)buf;
      *(_DWORD *)buf = 136447746;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      __int16 v154 = 2082;
      uint64_t v155 = a3 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v50;
      __int16 v158 = 1024;
      int v159 = v51;
      __int16 v160 = 2048;
      *(void *)BOOL v161 = v11;
      *(_WORD *)&v161[8] = 1024;
      int v162 = v52;
      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> couldn't send frame, prepending frame %p to waiting_output_frames, stream now has %u bytes pending", buf, 0x3Cu);
    }
    uint64_t v15 = 0;
    p_cache = NWConcrete_nw_resolution_report.cache;
LABEL_90:
    a4 = v147;
  }
LABEL_248:
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
    && *((unsigned char *)p_cache + 3665))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v124 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v125 = a4;
      os_log_type_t v126 = p_cache;
      int v128 = *(_DWORD *)(a3 + 176);
      int v127 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)(a3 + 16), 0, buf);
      int v129 = *(_DWORD *)buf;
      *(_DWORD *)buf = 136447490;
      uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
      __int16 v154 = 2082;
      uint64_t v155 = a3 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v127;
      __int16 v158 = 1024;
      int v159 = v128;
      p_cache = v126;
      a4 = v125;
      __int16 v160 = 1024;
      *(_DWORD *)BOOL v161 = v129;
      _os_log_impl(&dword_1830D4000, v124, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream now has %u bytes pending", buf, 0x32u);
    }
  }
  if (a4) {
    nw_http2_session_send(a1);
  }
  uint64_t v117 = *v9;
  if (v15)
  {
    int v118 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
    if (v117)
    {
      if ((v118 & 0x80000) != 0)
      {
LABEL_265:
        if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
          && *((unsigned char *)p_cache + 3665))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v133 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v135 = *(_DWORD *)(a3 + 176);
            int v134 = *(_DWORD *)(a3 + 180);
            *(_DWORD *)buf = 136447746;
            uint64_t v153 = "nw_http2_set_stream_output_available_pending";
            __int16 v154 = 2082;
            uint64_t v155 = a3 + 191;
            __int16 v156 = 2080;
            *(void *)uint64_t v157 = " ";
            *(_WORD *)&v157[8] = 1024;
            *(_DWORD *)&v157[10] = v134;
            __int16 v158 = 1024;
            int v159 = v135;
            __int16 v160 = 1024;
            *(_DWORD *)BOOL v161 = v135;
            *(_WORD *)&v161[4] = 1024;
            *(_DWORD *)&v161[6] = 0;
            _os_log_impl(&dword_1830D4000, v133, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, needs output available: %{BOOL}d", buf, 0x38u);
          }
        }
        int v121 = *(unsigned __int16 *)(a3 + 188);
        uint64_t v120 = a3 + 188;
        int v122 = *(unsigned __int8 *)(v120 + 2);
        *(_WORD *)uint64_t v120 = v121 & 0xFFDF;
        *(unsigned char *)(v120 + 2) = (v121 & 0xFFFFFFDF | (v122 << 16)) >> 16;
        return v15;
      }
LABEL_264:
      if (*((unsigned char *)p_cache + 3665))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v130 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v132 = *(_DWORD *)(a3 + 176);
          int v131 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
          __int16 v154 = 2082;
          uint64_t v155 = a3 + 191;
          __int16 v156 = 2080;
          *(void *)uint64_t v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v131;
          __int16 v158 = 1024;
          int v159 = v132;
          __int16 v160 = 2048;
          *(void *)BOOL v161 = v146;
          *(_WORD *)&v161[8] = 1024;
          int v162 = v132;
          _os_log_impl(&dword_1830D4000, v130, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> clearing output available from protocol %p for stream %d", buf, 0x3Cu);
        }
      }
      goto LABEL_265;
    }
    if ((*(_WORD *)(a3 + 188) & 0x10) == 0)
    {
      if ((*(unsigned __int8 *)(a3 + 190) >> 3)) {
        goto LABEL_270;
      }
LABEL_269:
      if (*((unsigned char *)p_cache + 3665))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v136 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v138 = *(_DWORD *)(a3 + 176);
          int v137 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)buf = 136447746;
          uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
          __int16 v154 = 2082;
          uint64_t v155 = a3 + 191;
          __int16 v156 = 2080;
          *(void *)uint64_t v157 = " ";
          *(_WORD *)&v157[8] = 1024;
          *(_DWORD *)&v157[10] = v137;
          __int16 v158 = 1024;
          int v159 = v138;
          __int16 v160 = 2048;
          *(void *)BOOL v161 = v146;
          *(_WORD *)&v161[8] = 1024;
          int v162 = v138;
          _os_log_impl(&dword_1830D4000, v136, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> enqueueing output available to protocol %p for stream %d", buf, 0x3Cu);
        }
      }
      goto LABEL_270;
    }
    if ((v118 & 0x80000) == 0 && *((unsigned char *)p_cache + 3665))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v142 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v144 = *(_DWORD *)(a3 + 176);
        int v143 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)buf = 136447234;
        uint64_t v153 = "nw_http2_drain_next_frame_for_stream";
        __int16 v154 = 2082;
        uint64_t v155 = a3 + 191;
        __int16 v156 = 2080;
        *(void *)uint64_t v157 = " ";
        *(_WORD *)&v157[8] = 1024;
        *(_DWORD *)&v157[10] = v143;
        __int16 v158 = 1024;
        int v159 = v144;
        _os_log_impl(&dword_1830D4000, v142, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> sending deferred end stream", buf, 0x2Cu);
      }
    }
    nw_http2_send_end_stream(a1, a3);
    uint64_t v117 = *(void *)(a3 + 16);
  }
  unsigned int v119 = *(unsigned __int8 *)(a3 + 190);
  if (v117)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (v119 << 16)) & 0x80000) != 0) {
      goto LABEL_265;
    }
    goto LABEL_264;
  }
  if (((v119 >> 3) & 1) == 0) {
    goto LABEL_269;
  }
LABEL_270:
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
    && *((unsigned char *)p_cache + 3665))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v139 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v141 = *(_DWORD *)(a3 + 176);
      int v140 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)buf = 136447746;
      uint64_t v153 = "nw_http2_set_stream_output_available_pending";
      __int16 v154 = 2082;
      uint64_t v155 = a3 + 191;
      __int16 v156 = 2080;
      *(void *)uint64_t v157 = " ";
      *(_WORD *)&v157[8] = 1024;
      *(_DWORD *)&v157[10] = v140;
      __int16 v158 = 1024;
      int v159 = v141;
      __int16 v160 = 1024;
      *(_DWORD *)BOOL v161 = v141;
      *(_WORD *)&v161[4] = 1024;
      *(_DWORD *)&v161[6] = 1;
      _os_log_impl(&dword_1830D4000, v139, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, needs output available: %{BOOL}d", buf, 0x38u);
    }
  }
  *(_WORD *)(a3 + 188) |= 0x20u;
  *(_WORD *)(a1 + 388) |= 0x800u;
  return v15;
}

void nw_http2_send_end_stream(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v31 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v33 = *(_DWORD *)(a2 + 176);
      int v32 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447234;
      BOOL v47 = "nw_http2_send_end_stream";
      __int16 v48 = 2082;
      uint64_t v49 = a2 + 191;
      __int16 v50 = 2080;
      int v51 = " ";
      __int16 v52 = 1024;
      int v53 = v32;
      __int16 v54 = 1024;
      int v55 = v33;
      _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
    }
  }
  int v4 = *(unsigned __int16 *)(a2 + 188);
  unsigned int v5 = v4 | (*(unsigned __int8 *)(a2 + 190) << 16);
  if ((v4 & 1) == 0)
  {
    if ((v5 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v8 = *(_DWORD *)(a2 + 176);
        int v7 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447234;
        BOOL v47 = "nw_http2_send_end_stream";
        __int16 v48 = 2082;
        uint64_t v49 = a2 + 191;
        __int16 v50 = 2080;
        int v51 = " ";
        __int16 v52 = 1024;
        int v53 = v7;
        __int16 v54 = 1024;
        int v55 = v8;
        _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> ERROR: Cannot send end stream on a closed stream", buf, 0x2Cu);
      }
    }
    return;
  }
  int v9 = (v5 >> 19) & 1;
  if (!gLogDatapath) {
    LOBYTE(v9) = 1;
  }
  if (*(void *)(a2 + 16))
  {
    if (v9) {
      goto LABEL_13;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v34 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_13;
    }
    int v36 = *(_DWORD *)(a2 + 176);
    int v35 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)buf = 0;
    nw_frame_array_get_frame_count((uint64_t *)(a2 + 16), 0, buf);
    int v37 = *(_DWORD *)buf;
    *(_DWORD *)buf = 136447490;
    BOOL v47 = "nw_http2_send_end_stream";
    __int16 v48 = 2082;
    uint64_t v49 = a2 + 191;
    __int16 v50 = 2080;
    int v51 = " ";
    __int16 v52 = 1024;
    int v53 = v35;
    __int16 v54 = 1024;
    int v55 = v36;
    __int16 v56 = 1024;
    int v57 = v37;
    uint64_t v17 = "%{public}s %{public}s%s<i%u:s%d> deferring end stream until all pending bytes (%u) are sent";
    uint64_t v18 = v34;
    uint32_t v19 = 50;
LABEL_51:
    _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, v17, buf, v19);
LABEL_13:
    *(_WORD *)(a2 + 188) |= 0x10u;
    return;
  }
  if ((v9 & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v38 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v40 = *(_DWORD *)(a2 + 176);
      int v39 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      BOOL v47 = "nw_http2_send_end_stream";
      __int16 v48 = 2082;
      uint64_t v49 = a2 + 191;
      __int16 v50 = 2080;
      int v51 = " ";
      __int16 v52 = 1024;
      int v53 = v39;
      __int16 v54 = 1024;
      int v55 = v40;
      __int16 v56 = 1024;
      int v57 = v40;
      _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> writing end stream on stream %d", buf, 0x32u);
    }
  }
  int v10 = nghttp2_submit_data();
  if ((v10 & 0x80000000) == 0)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v41 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v43 = *(_DWORD *)(a2 + 176);
        int v42 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        BOOL v47 = "nw_http2_send_end_stream";
        __int16 v48 = 2082;
        uint64_t v49 = a2 + 191;
        __int16 v50 = 2080;
        int v51 = " ";
        __int16 v52 = 1024;
        int v53 = v42;
        __int16 v54 = 1024;
        int v55 = v43;
        __int16 v56 = 1024;
        int v57 = v43;
        _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> submitted end stream for stream %d", buf, 0x32u);
      }
    }
    int v12 = *(unsigned __int16 *)(a2 + 188);
    uint64_t v11 = a2 + 188;
    unsigned int v13 = v12 & 0xFFFFFFEF | (*(unsigned __int8 *)(v11 + 2) << 16);
    *(_WORD *)uint64_t v11 = v12 & 0xBFEF | 0x4000;
    *(unsigned char *)(v11 + 2) = BYTE2(v13);
    nw_http2_session_send(a1);
    return;
  }
  if (v10 == -529)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) != 0 || !gLogDatapath) {
      goto LABEL_13;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v14 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_13;
    }
    int v16 = *(_DWORD *)(a2 + 176);
    int v15 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)buf = 136447234;
    BOOL v47 = "nw_http2_send_end_stream";
    __int16 v48 = 2082;
    uint64_t v49 = a2 + 191;
    __int16 v50 = 2080;
    int v51 = " ";
    __int16 v52 = 1024;
    int v53 = v15;
    __int16 v54 = 1024;
    int v55 = v16;
    uint64_t v17 = "%{public}s %{public}s%s<i%u:s%d> continuing (or starting) to defer end stream until all pending bytes are sent";
    uint64_t v18 = v14;
    uint32_t v19 = 44;
    goto LABEL_51;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v20 = nghttp2_strerror();
  *(_DWORD *)buf = 136446466;
  BOOL v47 = "nw_http2_send_end_stream";
  __int16 v48 = 2082;
  uint64_t v49 = v20;
  int v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v44 = 0;
  if (__nwlog_fault(v21, &type, &v44))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = gLogObj;
      os_log_type_t v23 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_41;
      }
      uint64_t v24 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      BOOL v47 = "nw_http2_send_end_stream";
      __int16 v48 = 2082;
      uint64_t v49 = v24;
      unsigned int v25 = "%{public}s nghttp2_submit_data: %{public}s failed";
      goto LABEL_40;
    }
    if (!v44)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_41;
      }
      uint64_t v29 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      BOOL v47 = "nw_http2_send_end_stream";
      __int16 v48 = 2082;
      uint64_t v49 = v29;
      unsigned int v25 = "%{public}s nghttp2_submit_data: %{public}s failed, backtrace limit exceeded";
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v27 = os_log_type_enabled(v22, type);
    if (backtrace_string)
    {
      if (v27)
      {
        uint64_t v28 = nghttp2_strerror();
        *(_DWORD *)buf = 136446722;
        BOOL v47 = "nw_http2_send_end_stream";
        __int16 v48 = 2082;
        uint64_t v49 = v28;
        __int16 v50 = 2082;
        int v51 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s nghttp2_submit_data: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_41;
    }
    if (v27)
    {
      uint64_t v30 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      BOOL v47 = "nw_http2_send_end_stream";
      __int16 v48 = 2082;
      uint64_t v49 = v30;
      unsigned int v25 = "%{public}s nghttp2_submit_data: %{public}s failed, no backtrace";
LABEL_40:
      _os_log_impl(&dword_1830D4000, v22, v23, v25, buf, 0x16u);
    }
  }
LABEL_41:
  if (v21) {
    free(v21);
  }
}

void nw_http2_set_stream_output_available_pending(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v7 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v9 = *(_DWORD *)(a2 + 176);
      int v8 = *(_DWORD *)(a2 + 180);
      int v10 = 136447746;
      uint64_t v11 = "nw_http2_set_stream_output_available_pending";
      __int16 v12 = 2082;
      uint64_t v13 = a2 + 191;
      __int16 v14 = 2080;
      int v15 = " ";
      __int16 v16 = 1024;
      int v17 = v8;
      __int16 v18 = 1024;
      int v19 = v9;
      __int16 v20 = 1024;
      int v21 = v9;
      __int16 v22 = 1024;
      int v23 = a3;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, needs output available: %{BOOL}d", (uint8_t *)&v10, 0x38u);
    }
  }
  int v6 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
  *(unsigned char *)(a2 + 190) = BYTE2(v6);
  if (a3)
  {
    *(_WORD *)(a2 + 188) = v6 | 0x20;
    *(_WORD *)(a1 + 388) |= 0x800u;
  }
  else
  {
    *(_WORD *)(a2 + 188) = v6 & 0xFFDF;
  }
}

uint64_t nw_http2_empty_frame_data_source_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a5)
  {
    *a5 = 1;
    return 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v15 = "nw_http2_empty_frame_data_source_callback";
  int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      int v15 = "nw_http2_empty_frame_data_source_callback";
      int v9 = "%{public}s called with null data_flags";
      goto LABEL_17;
    }
    if (!v12)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      int v15 = "nw_http2_empty_frame_data_source_callback";
      int v9 = "%{public}s called with null data_flags, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        int v15 = "nw_http2_empty_frame_data_source_callback";
        __int16 v16 = 2082;
        int v17 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null data_flags, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      int v15 = "nw_http2_empty_frame_data_source_callback";
      int v9 = "%{public}s called with null data_flags, no backtrace";
LABEL_17:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_18:
  if (v6) {
    free(v6);
  }
  return 0;
}

uint64_t data_source_read_callback(uint64_t a1, int a2, uint64_t a3, unsigned int a4, _DWORD *a5, uint64_t *a6, uint64_t a7)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v72 = "data_source_read_callback";
    int v53 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v70 = 0;
    if (__nwlog_fault(v53, type, &v70))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v54 = __nwlog_obj();
        os_log_type_t v55 = type[0];
        if (os_log_type_enabled(v54, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v72 = "data_source_read_callback";
          __int16 v56 = "%{public}s nghttp2 user data is NULL, not http2";
LABEL_119:
          _os_log_impl(&dword_1830D4000, v54, v55, v56, buf, 0xCu);
        }
      }
      else if (v70)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v54 = __nwlog_obj();
        os_log_type_t v55 = type[0];
        BOOL v63 = os_log_type_enabled(v54, type[0]);
        if (backtrace_string)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v72 = "data_source_read_callback";
            __int16 v73 = 2082;
            uint64_t v74 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_120;
        }
        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v72 = "data_source_read_callback";
          __int16 v56 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
          goto LABEL_119;
        }
      }
      else
      {
        __int16 v54 = __nwlog_obj();
        os_log_type_t v55 = type[0];
        if (os_log_type_enabled(v54, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v72 = "data_source_read_callback";
          __int16 v56 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
          goto LABEL_119;
        }
      }
    }
LABEL_120:
    if (v53) {
      free(v53);
    }
    return -902;
  }
  if ((*(__int16 *)(a7 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v57 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v58 = *(_DWORD *)(a7 + 368);
      *(_DWORD *)buf = 136446978;
      uint64_t v72 = "data_source_read_callback";
      __int16 v73 = 2082;
      uint64_t v74 = a7 + 390;
      __int16 v75 = 2080;
      __int16 v76 = " ";
      __int16 v77 = 1024;
      int v78 = v58;
      _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  uint64_t v12 = *a6;
  if (!v12)
  {
    if ((*(__int16 *)(a7 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unsigned int v25 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v26 = *(_DWORD *)(a7 + 368);
        *(_DWORD *)buf = 136446978;
        uint64_t v72 = "data_source_read_callback";
        __int16 v73 = 2082;
        uint64_t v74 = a7 + 390;
        __int16 v75 = 2080;
        __int16 v76 = " ";
        __int16 v77 = 1024;
        int v78 = v26;
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> received unexpected NULL frame in data source", buf, 0x26u);
      }
    }
    uint64_t v27 = 0;
    *a5 |= 1u;
    return v27;
  }
  *(void *)os_log_type_t type = 0;
  uint64_t stream_from_id = nw_http2_get_stream_from_id(a7, a2, type);
  int v14 = 0;
  if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x20000) == 0) {
    goto LABEL_64;
  }
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  id v15 = (id)nw_protocol_copy_http_definition_http_definition;
  __int16 v16 = nw_frame_copy_metadata_for_protocol(v12, (uint64_t)v15);
  if (v15) {
    os_release(v15);
  }
  if (!v16 || !nw_http_metadata_is_capsule(v16))
  {
    if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x40000) != 0)
    {
      metadata_for_capsule = nw_http_create_metadata_for_capsule(0, MEMORY[0x1E4F14410]);
      nw_frame_set_metadata(v12, metadata_for_capsule, 0, 1);
      if (metadata_for_capsule) {
        os_release(metadata_for_capsule);
      }
      int v29 = *(_DWORD *)(v12 + 52);
      if (v29 && (unsigned int v30 = v29 - (*(_DWORD *)(v12 + 56) + *(_DWORD *)(v12 + 60)), v30 >= 0x40))
      {
        if (v30 >= 0x4000)
        {
          if (v30 >> 30) {
            int v14 = 10;
          }
          else {
            int v14 = 6;
          }
        }
        else
        {
          int v14 = 4;
        }
      }
      else
      {
        int v14 = 3;
      }
    }
    else
    {
      int v14 = 0;
    }
    if (v16) {
      goto LABEL_63;
    }
LABEL_64:
    int v36 = *(_DWORD *)(v12 + 52);
    if (v36) {
      v36 -= *(_DWORD *)(v12 + 56) + *(_DWORD *)(v12 + 60);
    }
    int v37 = v36 + v14;
    if (v36 + v14 >= a4) {
      unsigned int v38 = a4;
    }
    else {
      unsigned int v38 = v36 + v14;
    }
    if (v38 >= 0x3FF6) {
      uint64_t v27 = 16374;
    }
    else {
      uint64_t v27 = v38;
    }
    uint64_t v39 = *(void *)(v12 + 64);
    if (v39)
    {
      char v40 = *(unsigned char *)(v39 + 66);
      unsigned int v41 = *(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16);
      if ((v40 & 0x40) != 0)
      {
        int v42 = (v41 >> 19) & 1;
        if (!gLogDatapath) {
          LOBYTE(v42) = 1;
        }
        if ((*(_WORD *)(stream_from_id + 188) & 0x200) == 0)
        {
          if ((v42 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v43 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v45 = *(_DWORD *)(stream_from_id + 176);
              int v44 = *(_DWORD *)(stream_from_id + 180);
              *(_DWORD *)buf = 136447490;
              uint64_t v72 = "data_source_read_callback";
              __int16 v73 = 2082;
              uint64_t v74 = stream_from_id + 191;
              __int16 v75 = 2080;
              __int16 v76 = " ";
              __int16 v77 = 1024;
              int v78 = v44;
              __int16 v79 = 1024;
              int v80 = v45;
              __int16 v81 = 2048;
              uint64_t v82 = v12;
              _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> omitting no_end_stream flag and allowing end stream to be set because frame %p is complete", buf, 0x36u);
            }
          }
          goto LABEL_92;
        }
        if (v42) {
          goto LABEL_91;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v64 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
LABEL_91:
          *a5 |= 2u;
LABEL_92:
          if (v27 == v37) {
            int v52 = 5;
          }
          else {
            int v52 = 4;
          }
          *a5 |= v52;
          if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v59 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v61 = *(_DWORD *)(stream_from_id + 176);
              int v60 = *(_DWORD *)(stream_from_id + 180);
              *(_DWORD *)buf = 136447490;
              uint64_t v72 = "data_source_read_callback";
              __int16 v73 = 2082;
              uint64_t v74 = stream_from_id + 191;
              __int16 v75 = 2080;
              __int16 v76 = " ";
              __int16 v77 = 1024;
              int v78 = v60;
              __int16 v79 = 1024;
              int v80 = v61;
              __int16 v81 = 1024;
              LODWORD(v82) = v27;
              _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> skipped copying %u bytes in data_source_read_callback", buf, 0x32u);
            }
          }
          return v27;
        }
        int v66 = *(_DWORD *)(stream_from_id + 176);
        int v65 = *(_DWORD *)(stream_from_id + 180);
        *(_DWORD *)buf = 136447234;
        uint64_t v72 = "data_source_read_callback";
        __int16 v73 = 2082;
        uint64_t v74 = stream_from_id + 191;
        __int16 v75 = 2080;
        __int16 v76 = " ";
        __int16 v77 = 1024;
        int v78 = v65;
        __int16 v79 = 1024;
        int v80 = v66;
        uint64_t v49 = "%{public}s %{public}s%s<i%u:s%d> setting no_end_stream flag because stream is in CONNECT mode";
        __int16 v50 = v64;
        uint32_t v51 = 44;
LABEL_89:
        _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_DEBUG, v49, buf, v51);
        goto LABEL_91;
      }
    }
    else
    {
      unsigned int v41 = *(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16);
    }
    if ((v41 & 0x80000) != 0 || !gLogDatapath) {
      goto LABEL_91;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v46 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_91;
    }
    int v48 = *(_DWORD *)(stream_from_id + 176);
    int v47 = *(_DWORD *)(stream_from_id + 180);
    *(_DWORD *)buf = 136447490;
    uint64_t v72 = "data_source_read_callback";
    __int16 v73 = 2082;
    uint64_t v74 = stream_from_id + 191;
    __int16 v75 = 2080;
    __int16 v76 = " ";
    __int16 v77 = 1024;
    int v78 = v47;
    __int16 v79 = 1024;
    int v80 = v48;
    __int16 v81 = 2048;
    uint64_t v82 = v12;
    uint64_t v49 = "%{public}s %{public}s%s<i%u:s%d> setting no_end_stream flag because frame %p is not complete";
    __int16 v50 = v46;
    uint32_t v51 = 54;
    goto LABEL_89;
  }
  capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(v16);
  uint64_t v18 = nw_http_metadata_copy_capsule_data(v16);
  int v19 = v18;
  if (v18)
  {
    size_t size = dispatch_data_get_size(v18);
    if (!(size | capsule_type)) {
      goto LABEL_14;
    }
  }
  else
  {
    size_t size = 0;
    if (!capsule_type)
    {
LABEL_14:
      unsigned int v21 = *(_DWORD *)(v12 + 52);
      if (v21) {
        v21 -= *(_DWORD *)(v12 + 56) + *(_DWORD *)(v12 + 60);
      }
      unint64_t v22 = v21;
      int v23 = 1;
      if (v21 < 0x40uLL) {
        goto LABEL_17;
      }
      goto LABEL_50;
    }
  }
  if (capsule_type >= 0x40)
  {
    if (capsule_type >= 0x4000)
    {
      if (capsule_type >> 30)
      {
        if (capsule_type >> 62)
        {
          int v31 = __nwlog_obj();
          os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          uint64_t v72 = "_http_vle_length";
          __int16 v73 = 2048;
          uint64_t v74 = capsule_type;
          int v32 = (void *)_os_log_send_and_compose_impl();
          uint64_t result = __nwlog_abort((uint64_t)v32);
          if (result) {
            goto LABEL_127;
          }
          free(v32);
          int v23 = 0;
        }
        else
        {
          int v23 = 8;
        }
      }
      else
      {
        int v23 = 4;
      }
    }
    else
    {
      int v23 = 2;
    }
  }
  else
  {
    int v23 = 1;
  }
  unint64_t v22 = size;
  if (size < 0x40)
  {
LABEL_17:
    int v24 = 1;
    goto LABEL_58;
  }
LABEL_50:
  if (v22 < 0x4000)
  {
    int v24 = 2;
    goto LABEL_58;
  }
  if (!(v22 >> 30))
  {
    int v24 = 4;
    goto LABEL_58;
  }
  if (!(v22 >> 62))
  {
    int v24 = 8;
    goto LABEL_58;
  }
  int v67 = v23;
  int v68 = __nwlog_obj();
  os_log_type_enabled(v68, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  uint64_t v72 = "_http_vle_length";
  __int16 v73 = 2048;
  uint64_t v74 = v22;
  uint64_t v34 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v34);
  if (!result)
  {
    free(v34);
    int v24 = 0;
    int v23 = v67;
LABEL_58:
    if (capsule_type) {
      int v35 = size;
    }
    else {
      int v35 = size + 1;
    }
    int v14 = v35 + v23 + v24;
    if (v19) {
      dispatch_release(v19);
    }
LABEL_63:
    os_release(v16);
    goto LABEL_64;
  }
LABEL_127:
  __break(1u);
  return result;
}

BOOL ___ZL24__nw_signpost_is_enabledv_block_invoke_83345()
{
  BOOL result = networkd_settings_get_BOOL((const char *)nw_setting_enable_signposts);
  _nw_signposts_enabled = result;
  return result;
}

uint64_t ___ZL25nw_http2_connection_closeP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
    int v7 = *(_DWORD *)(v5 + 176);
    if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v24 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v26 = *(_DWORD *)(v5 + 176);
        int v25 = *(_DWORD *)(v5 + 180);
        int v30 = 136447490;
        int v31 = "nw_http2_connection_close_block_invoke";
        __int16 v32 = 2082;
        int v33 = (const char *)(v5 + 191);
        __int16 v34 = 2080;
        int v35 = " ";
        __int16 v36 = 1024;
        int v37 = v25;
        __int16 v38 = 1024;
        *(_DWORD *)uint64_t v39 = v26;
        *(_WORD *)&void v39[4] = 1024;
        *(_DWORD *)&v39[6] = v26;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> closing stream %d", (uint8_t *)&v30, 0x32u);
      }
    }
    nw_http2_stream_close(*(void *)(a1 + 32), v5);
    int v8 = (*(unsigned __int8 *)(v5 + 190) >> 3) & 1;
    if (!gLogDatapath) {
      LOBYTE(v8) = 1;
    }
    if (v6)
    {
      if ((v8 & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v9 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v11 = *(_DWORD *)(v5 + 176);
          int v10 = *(_DWORD *)(v5 + 180);
          int v30 = 136447746;
          int v31 = "nw_http2_connection_close_block_invoke";
          __int16 v32 = 2082;
          int v33 = (const char *)(v5 + 191);
          __int16 v34 = 2080;
          int v35 = " ";
          __int16 v36 = 1024;
          int v37 = v10;
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v11;
          *(_WORD *)&void v39[4] = 1024;
          *(_DWORD *)&v39[6] = v7;
          __int16 v40 = 2048;
          uint64_t v41 = v5;
          uint64_t v12 = "%{public}s %{public}s%s<i%u:s%d> deferring release of stream %d (%p), has associated input handler";
          uint64_t v13 = v9;
          os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
          uint32_t v15 = 60;
LABEL_22:
          _os_log_impl(&dword_1830D4000, v13, v14, v12, (uint8_t *)&v30, v15);
        }
      }
    }
    else
    {
      if ((v8 & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v27 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v29 = *(_DWORD *)(v5 + 176);
          int v28 = *(_DWORD *)(v5 + 180);
          int v30 = 136447746;
          int v31 = "nw_http2_connection_close_block_invoke";
          __int16 v32 = 2082;
          int v33 = (const char *)(v5 + 191);
          __int16 v34 = 2080;
          int v35 = " ";
          __int16 v36 = 1024;
          int v37 = v28;
          __int16 v38 = 1024;
          *(_DWORD *)uint64_t v39 = v29;
          *(_WORD *)&void v39[4] = 1024;
          *(_DWORD *)&v39[6] = v7;
          __int16 v40 = 2048;
          uint64_t v41 = v5;
          _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> destroying stream %d (%p) immediately, no associated input handler", (uint8_t *)&v30, 0x3Cu);
        }
      }
      nw_http2_stream_destroy((void **)v5);
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (!v16 || (*(__int16 *)(v16 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = *(void *)(a1 + 32);
        int v19 = (const char *)(v18 + 390);
        __int16 v20 = "";
        BOOL v21 = v18 == 0;
        int v22 = *(_DWORD *)(v18 + 368);
        int v31 = "nw_http2_connection_close_block_invoke";
        if (v21) {
          int v19 = "";
        }
        __int16 v32 = 2082;
        int v30 = 136447234;
        if (!v21) {
          __int16 v20 = " ";
        }
        int v33 = v19;
        __int16 v34 = 2080;
        int v35 = v20;
        __int16 v36 = 1024;
        int v37 = v22;
        __int16 v38 = 2048;
        *(void *)uint64_t v39 = a2;
        uint64_t v12 = "%{public}s %{public}s%s<i%u> stream in node %p in id table is NULL, skipping rst stream";
        uint64_t v13 = v17;
        os_log_type_t v14 = OS_LOG_TYPE_ERROR;
        uint32_t v15 = 48;
        goto LABEL_22;
      }
    }
  }
  return 1;
}

void nw_http2_send_goaway(uint64_t a1)
{
  *(void *)&v61[13] = *MEMORY[0x1E4F143B8];
  if (a1 && *(__int16 *)(a1 + 388) < 0) {
    goto LABEL_5;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v25 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      if (a1) {
        int v26 = " ";
      }
      else {
        int v26 = "";
      }
      if (a1) {
        uint64_t v27 = (const char *)(a1 + 390);
      }
      else {
        uint64_t v27 = "";
      }
      int v28 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447490;
      uint32_t v51 = "nw_http2_send_goaway";
      __int16 v52 = 2082;
      uint64_t v53 = (uint64_t)v27;
      __int16 v54 = 2080;
      os_log_type_t v55 = v26;
      __int16 v56 = 1024;
      int v57 = v28;
      __int16 v58 = 1024;
      int v59 = 0;
      __int16 v60 = 2082;
      *(void *)int v61 = nghttp2_http2_strerror();
      _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with error %u (%{public}s)", buf, 0x36u);
      __int16 v2 = *(_WORD *)(a1 + 388);
      if (v2)
      {
LABEL_53:
        if ((v2 & 0x8000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v34 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v35 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136446978;
            uint32_t v51 = "nw_http2_send_goaway";
            __int16 v52 = 2082;
            uint64_t v53 = a1 + 390;
            __int16 v54 = 2080;
            os_log_type_t v55 = " ";
            __int16 v56 = 1024;
            int v57 = v35;
            _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> already sent goaway, skipping", buf, 0x26u);
          }
        }
        return;
      }
LABEL_6:
      int v3 = *(_DWORD *)(a1 + 364);
      if (!v3) {
        goto LABEL_19;
      }
      if ((v2 & 0x80) != 0)
      {
        if ((v3 & 1) == 0 && (v2 & 0x8000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v36 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          uint32_t v51 = "nw_http2_send_goaway";
          __int16 v52 = 2082;
          uint64_t v53 = a1 + 390;
          __int16 v54 = 2080;
          os_log_type_t v55 = " ";
          __int16 v56 = 1024;
          int v57 = v36;
          __int16 v58 = 1024;
          int v59 = v3;
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v48 = 0;
          uint64_t v5 = (char *)_os_log_send_and_compose_impl();
          if (!__nwlog_fault(v5, &type, &v48)) {
            goto LABEL_113;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v6 = gconnectionLogObj;
            os_log_type_t v7 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              int v37 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447234;
              uint32_t v51 = "nw_http2_send_goaway";
              __int16 v52 = 2082;
              uint64_t v53 = a1 + 390;
              __int16 v54 = 2080;
              os_log_type_t v55 = " ";
              __int16 v56 = 1024;
              int v57 = v37;
              __int16 v58 = 1024;
              int v59 = v3;
              uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is even, but we are the server";
              goto LABEL_112;
            }
LABEL_113:
            if (!v5) {
              goto LABEL_19;
            }
            goto LABEL_114;
          }
          if (!v48)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v6 = gconnectionLogObj;
            os_log_type_t v7 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              int v45 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447234;
              uint32_t v51 = "nw_http2_send_goaway";
              __int16 v52 = 2082;
              uint64_t v53 = a1 + 390;
              __int16 v54 = 2080;
              os_log_type_t v55 = " ";
              __int16 v56 = 1024;
              int v57 = v45;
              __int16 v58 = 1024;
              int v59 = v3;
              uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is even, but we are the server, backtrace limit exceeded";
              goto LABEL_112;
            }
            goto LABEL_113;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v6 = gconnectionLogObj;
          os_log_type_t v7 = type;
          BOOL v42 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (!backtrace_string)
          {
            if (!v42) {
              goto LABEL_113;
            }
            int v47 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136447234;
            uint32_t v51 = "nw_http2_send_goaway";
            __int16 v52 = 2082;
            uint64_t v53 = a1 + 390;
            __int16 v54 = 2080;
            os_log_type_t v55 = " ";
            __int16 v56 = 1024;
            int v57 = v47;
            __int16 v58 = 1024;
            int v59 = v3;
            uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is even, but we are the server, no backtrace";
            goto LABEL_112;
          }
          if (v42)
          {
            int v43 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136447490;
            uint32_t v51 = "nw_http2_send_goaway";
            __int16 v52 = 2082;
            uint64_t v53 = a1 + 390;
            __int16 v54 = 2080;
            os_log_type_t v55 = " ";
            __int16 v56 = 1024;
            int v57 = v43;
            __int16 v58 = 1024;
            int v59 = v3;
            __int16 v60 = 2082;
            *(void *)int v61 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s %{public}s%s<i%u> Last stream value %d is even, but we are the server, dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(backtrace_string);
          if (v5) {
LABEL_114:
          }
            free(v5);
        }
      }
      else if ((v3 & 1) != 0 && (v2 & 0x8000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v4 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        uint32_t v51 = "nw_http2_send_goaway";
        __int16 v52 = 2082;
        uint64_t v53 = a1 + 390;
        __int16 v54 = 2080;
        os_log_type_t v55 = " ";
        __int16 v56 = 1024;
        int v57 = v4;
        __int16 v58 = 1024;
        int v59 = v3;
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v48 = 0;
        uint64_t v5 = (char *)_os_log_send_and_compose_impl();
        if (__nwlog_fault(v5, &type, &v48))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v6 = gconnectionLogObj;
            os_log_type_t v7 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              int v8 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447234;
              uint32_t v51 = "nw_http2_send_goaway";
              __int16 v52 = 2082;
              uint64_t v53 = a1 + 390;
              __int16 v54 = 2080;
              os_log_type_t v55 = " ";
              __int16 v56 = 1024;
              int v57 = v8;
              __int16 v58 = 1024;
              int v59 = v3;
              uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is odd, but we are the client";
LABEL_112:
              _os_log_impl(&dword_1830D4000, v6, v7, v9, buf, 0x2Cu);
              goto LABEL_113;
            }
          }
          else if (v48)
          {
            __int16 v38 = (char *)__nw_create_backtrace_string();
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v6 = gconnectionLogObj;
            os_log_type_t v7 = type;
            BOOL v39 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
            if (!v38)
            {
              if (!v39) {
                goto LABEL_113;
              }
              int v46 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447234;
              uint32_t v51 = "nw_http2_send_goaway";
              __int16 v52 = 2082;
              uint64_t v53 = a1 + 390;
              __int16 v54 = 2080;
              os_log_type_t v55 = " ";
              __int16 v56 = 1024;
              int v57 = v46;
              __int16 v58 = 1024;
              int v59 = v3;
              uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is odd, but we are the client, no backtrace";
              goto LABEL_112;
            }
            if (v39)
            {
              int v40 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447490;
              uint32_t v51 = "nw_http2_send_goaway";
              __int16 v52 = 2082;
              uint64_t v53 = a1 + 390;
              __int16 v54 = 2080;
              os_log_type_t v55 = " ";
              __int16 v56 = 1024;
              int v57 = v40;
              __int16 v58 = 1024;
              int v59 = v3;
              __int16 v60 = 2082;
              *(void *)int v61 = v38;
              _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s %{public}s%s<i%u> Last stream value %d is odd, but we are the client, dumping backtrace:%{public}s", buf, 0x36u);
            }
            free(v38);
          }
          else
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v6 = gconnectionLogObj;
            os_log_type_t v7 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
            {
              int v44 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)buf = 136447234;
              uint32_t v51 = "nw_http2_send_goaway";
              __int16 v52 = 2082;
              uint64_t v53 = a1 + 390;
              __int16 v54 = 2080;
              os_log_type_t v55 = " ";
              __int16 v56 = 1024;
              int v57 = v44;
              __int16 v58 = 1024;
              int v59 = v3;
              uint64_t v9 = "%{public}s %{public}s%s<i%u> Last stream value %d is odd, but we are the client, backtrace limit exceeded";
              goto LABEL_112;
            }
          }
        }
        goto LABEL_113;
      }
LABEL_19:
      *(_WORD *)(a1 + 388) |= 1u;
      if (!nghttp2_submit_goaway())
      {
LABEL_36:
        if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v31 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v32 = *(_DWORD *)(a1 + 368);
            uint64_t v33 = nghttp2_http2_strerror();
            *(_DWORD *)buf = 136447746;
            uint32_t v51 = "nw_http2_send_goaway";
            __int16 v52 = 2082;
            uint64_t v53 = a1 + 390;
            __int16 v54 = 2080;
            os_log_type_t v55 = " ";
            __int16 v56 = 1024;
            int v57 = v32;
            __int16 v58 = 1024;
            int v59 = v3;
            __int16 v60 = 1024;
            *(_DWORD *)int v61 = 0;
            v61[2] = 2082;
            *(void *)&v61[3] = v33;
            _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> submitted GOAWAY frame with last_stream %d and error %u (%{public}s)", buf, 0x3Cu);
          }
        }
        nw_http2_session_send(a1);
        return;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = nghttp2_strerror();
      *(_DWORD *)buf = 136446466;
      uint32_t v51 = "nw_http2_send_goaway";
      __int16 v52 = 2082;
      uint64_t v53 = v10;
      int v11 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (__nwlog_fault(v11, &type, &v48))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v12 = gLogObj;
          os_log_type_t v13 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_34;
          }
          uint64_t v14 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          uint32_t v51 = "nw_http2_send_goaway";
          __int16 v52 = 2082;
          uint64_t v53 = v14;
          uint32_t v15 = "%{public}s nghttp2_submit_goaway: %{public}s failed";
          goto LABEL_33;
        }
        if (!v48)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v12 = gLogObj;
          os_log_type_t v13 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_34;
          }
          uint64_t v19 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          uint32_t v51 = "nw_http2_send_goaway";
          __int16 v52 = 2082;
          uint64_t v53 = v19;
          uint32_t v15 = "%{public}s nghttp2_submit_goaway: %{public}s failed, backtrace limit exceeded";
          goto LABEL_33;
        }
        uint64_t v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = gLogObj;
        os_log_type_t v13 = type;
        BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v16)
        {
          if (v17)
          {
            uint64_t v18 = nghttp2_strerror();
            *(_DWORD *)buf = 136446722;
            uint32_t v51 = "nw_http2_send_goaway";
            __int16 v52 = 2082;
            uint64_t v53 = v18;
            __int16 v54 = 2082;
            os_log_type_t v55 = v16;
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s nghttp2_submit_goaway: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v16);
          goto LABEL_34;
        }
        if (v17)
        {
          uint64_t v20 = nghttp2_strerror();
          *(_DWORD *)buf = 136446466;
          uint32_t v51 = "nw_http2_send_goaway";
          __int16 v52 = 2082;
          uint64_t v53 = v20;
          uint32_t v15 = "%{public}s nghttp2_submit_goaway: %{public}s failed, no backtrace";
LABEL_33:
          _os_log_impl(&dword_1830D4000, v12, v13, v15, buf, 0x16u);
        }
      }
LABEL_34:
      if (v11) {
        free(v11);
      }
      goto LABEL_36;
    }
  }
  if (a1)
  {
LABEL_5:
    __int16 v2 = *(_WORD *)(a1 + 388);
    if (v2) {
      goto LABEL_53;
    }
    goto LABEL_6;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint32_t v51 = "nw_http2_send_goaway";
  BOOL v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v48 = 0;
  if (__nwlog_fault(v21, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v51 = "nw_http2_send_goaway";
      int v24 = "%{public}s called with null http2";
      goto LABEL_82;
    }
    if (!v48)
    {
      int v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_83;
      }
      *(_DWORD *)buf = 136446210;
      uint32_t v51 = "nw_http2_send_goaway";
      int v24 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_82;
    }
    int v29 = (char *)__nw_create_backtrace_string();
    int v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v30 = os_log_type_enabled(v22, type);
    if (v29)
    {
      if (v30)
      {
        *(_DWORD *)buf = 136446466;
        uint32_t v51 = "nw_http2_send_goaway";
        __int16 v52 = 2082;
        uint64_t v53 = (uint64_t)v29;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v29);
      goto LABEL_83;
    }
    if (v30)
    {
      *(_DWORD *)buf = 136446210;
      uint32_t v51 = "nw_http2_send_goaway";
      int v24 = "%{public}s called with null http2, no backtrace";
LABEL_82:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
    }
  }
LABEL_83:
  if (v21) {
    free(v21);
  }
}

uint64_t ___ZL25nw_http2_connection_closeP17nw_protocol_http2_block_invoke_22(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v5 = *(void *)(a1 + 32);
  if (object)
  {
    uint64_t stream_from_protocol = nw_http2_get_stream_from_protocol(v5, object);
    nw_http2_protocol_close(*(void *)(a1 + 32), stream_from_protocol, object);
  }
  else if (!v5 || (*(__int16 *)(v5 + 388) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v7 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v8 = *(void *)(a1 + 32);
      uint64_t v9 = (const char *)(v8 + 390);
      uint64_t v10 = "";
      BOOL v11 = v8 == 0;
      int v12 = *(_DWORD *)(v8 + 368);
      uint32_t v15 = "nw_http2_connection_close_block_invoke";
      if (v11) {
        uint64_t v9 = "";
      }
      __int16 v16 = 2082;
      int v14 = 136447234;
      if (!v11) {
        uint64_t v10 = " ";
      }
      BOOL v17 = v9;
      __int16 v18 = 2080;
      uint64_t v19 = v10;
      __int16 v20 = 1024;
      int v21 = v12;
      __int16 v22 = 2048;
      uint64_t v23 = a2;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> input protocol in node %p in protocol table is NULL, skipping", (uint8_t *)&v14, 0x30u);
    }
  }
  return 1;
}

uint64_t nw_http2_get_stream_from_protocol(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v33 = "nw_http2_get_stream_from_protocol";
    uint64_t v24 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v24, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          uint64_t v27 = "%{public}s called with null http2";
LABEL_68:
          _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0xCu);
        }
      }
      else if (v30)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v33 = "nw_http2_get_stream_from_protocol";
            __int16 v34 = 2082;
            int v35 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_69;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          uint64_t v27 = "%{public}s called with null http2, no backtrace";
          goto LABEL_68;
        }
      }
      else
      {
        int v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          uint64_t v27 = "%{public}s called with null http2, backtrace limit exceeded";
          goto LABEL_68;
        }
      }
    }
LABEL_69:
    if (!v24) {
      return 0;
    }
    uint64_t v23 = (char *)v24;
    goto LABEL_52;
  }
  uint64_t v3 = *(void *)(a2 + 56);
  if (v3)
  {
    uint64_t result = *(void *)(v3 + 32);
    if (result) {
      return result;
    }
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v5 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    uint64_t v33 = "nw_http2_get_stream_from_protocol";
    __int16 v34 = 2082;
    int v35 = (char *)(a1 + 390);
    __int16 v36 = 2080;
    int v37 = " ";
    __int16 v38 = 1024;
    int v39 = v5;
    uint64_t v6 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v6, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v7 = gconnectionLogObj;
        os_log_type_t v8 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          int v9 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          __int16 v34 = 2082;
          int v35 = (char *)(a1 + 390);
          __int16 v36 = 2080;
          int v37 = " ";
          __int16 v38 = 1024;
          int v39 = v9;
          uint64_t v10 = "%{public}s %{public}s%s<i%u> stream not found";
LABEL_49:
          _os_log_impl(&dword_1830D4000, v7, v8, v10, buf, 0x26u);
        }
      }
      else if (v30)
      {
        __int16 v16 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v7 = gconnectionLogObj;
        os_log_type_t v8 = type;
        BOOL v17 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (!v16)
        {
          if (!v17) {
            goto LABEL_50;
          }
          int v22 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          __int16 v34 = 2082;
          int v35 = (char *)(a1 + 390);
          __int16 v36 = 2080;
          int v37 = " ";
          __int16 v38 = 1024;
          int v39 = v22;
          uint64_t v10 = "%{public}s %{public}s%s<i%u> stream not found, no backtrace";
          goto LABEL_49;
        }
        if (v17)
        {
          int v18 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136447234;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          __int16 v34 = 2082;
          int v35 = (char *)(a1 + 390);
          __int16 v36 = 2080;
          int v37 = " ";
          __int16 v38 = 1024;
          int v39 = v18;
          __int16 v40 = 2082;
          uint64_t v41 = v16;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s %{public}s%s<i%u> stream not found, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v16);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v7 = gconnectionLogObj;
        os_log_type_t v8 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          int v21 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)buf = 136446978;
          uint64_t v33 = "nw_http2_get_stream_from_protocol";
          __int16 v34 = 2082;
          int v35 = (char *)(a1 + 390);
          __int16 v36 = 2080;
          int v37 = " ";
          __int16 v38 = 1024;
          int v39 = v21;
          uint64_t v10 = "%{public}s %{public}s%s<i%u> stream not found, backtrace limit exceeded";
          goto LABEL_49;
        }
      }
    }
  }
  else
  {
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v11 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136446978;
    uint64_t v33 = "nw_http2_get_stream_from_protocol";
    __int16 v34 = 2082;
    int v35 = (char *)(a1 + 390);
    __int16 v36 = 2080;
    int v37 = " ";
    __int16 v38 = 1024;
    int v39 = v11;
    uint64_t v6 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v6, &type, &v30)) {
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v7 = gconnectionLogObj;
      os_log_type_t v8 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        int v12 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        uint64_t v33 = "nw_http2_get_stream_from_protocol";
        __int16 v34 = 2082;
        int v35 = (char *)(a1 + 390);
        __int16 v36 = 2080;
        int v37 = " ";
        __int16 v38 = 1024;
        int v39 = v12;
        uint64_t v10 = "%{public}s %{public}s%s<i%u> node not found";
        goto LABEL_49;
      }
    }
    else
    {
      if (v30)
      {
        os_log_type_t v13 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v7 = gconnectionLogObj;
        os_log_type_t v8 = type;
        BOOL v14 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v13)
        {
          if (v14)
          {
            int v15 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)buf = 136447234;
            uint64_t v33 = "nw_http2_get_stream_from_protocol";
            __int16 v34 = 2082;
            int v35 = (char *)(a1 + 390);
            __int16 v36 = 2080;
            int v37 = " ";
            __int16 v38 = 1024;
            int v39 = v15;
            __int16 v40 = 2082;
            uint64_t v41 = v13;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s %{public}s%s<i%u> node not found, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v13);
          if (!v6) {
            return 0;
          }
          goto LABEL_51;
        }
        if (!v14) {
          goto LABEL_50;
        }
        int v20 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        uint64_t v33 = "nw_http2_get_stream_from_protocol";
        __int16 v34 = 2082;
        int v35 = (char *)(a1 + 390);
        __int16 v36 = 2080;
        int v37 = " ";
        __int16 v38 = 1024;
        int v39 = v20;
        uint64_t v10 = "%{public}s %{public}s%s<i%u> node not found, no backtrace";
        goto LABEL_49;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v7 = gconnectionLogObj;
      os_log_type_t v8 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        int v19 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136446978;
        uint64_t v33 = "nw_http2_get_stream_from_protocol";
        __int16 v34 = 2082;
        int v35 = (char *)(a1 + 390);
        __int16 v36 = 2080;
        int v37 = " ";
        __int16 v38 = 1024;
        int v39 = v19;
        uint64_t v10 = "%{public}s %{public}s%s<i%u> node not found, backtrace limit exceeded";
        goto LABEL_49;
      }
    }
  }
LABEL_50:
  if (v6)
  {
LABEL_51:
    uint64_t v23 = (char *)v6;
LABEL_52:
    free(v23);
  }
  return 0;
}

void nw_http2_protocol_close(uint64_t a1, uint64_t a2, uint64_t a3)
{
  v80[4] = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v34 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v36 = *(_DWORD *)(a2 + 176);
        int v35 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447234;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)(a2 + 191);
        __int16 v75 = 2080;
        __int16 v76 = " ";
        __int16 v77 = 1024;
        int v78 = v35;
        __int16 v79 = 1024;
        LODWORD(v80[0]) = v36;
        _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", buf, 0x2Cu);
      }
    }
    goto LABEL_4;
  }
  if (a1 && *(__int16 *)(a1 + 388) < 0)
  {
LABEL_47:
    if (a3) {
      goto LABEL_15;
    }
    goto LABEL_48;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v26 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v27 = " ";
      int v28 = *(_DWORD *)(a1 + 368);
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      BOOL v29 = (const char *)(a1 + 390);
      *(_DWORD *)buf = 136446978;
      if (!a1) {
        BOOL v29 = "";
      }
      uint64_t v74 = (void *)v29;
      if (!a1) {
        uint64_t v27 = "";
      }
      __int16 v75 = 2080;
      __int16 v76 = v27;
      __int16 v77 = 1024;
      int v78 = v28;
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      goto LABEL_47;
    }
  }
LABEL_4:
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v72 = "nw_http2_protocol_close";
    char v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v69 = 0;
    if (!__nwlog_fault(v30, &type, &v69)) {
      goto LABEL_131;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v72 = "nw_http2_protocol_close";
      uint64_t v33 = "%{public}s called with null http2";
      goto LABEL_130;
    }
    if (!v69)
    {
      int v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v72 = "nw_http2_protocol_close";
      uint64_t v33 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_130;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v48 = os_log_type_enabled(v31, type);
    if (!backtrace_string)
    {
      if (!v48) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v72 = "nw_http2_protocol_close";
      uint64_t v33 = "%{public}s called with null http2, no backtrace";
      goto LABEL_130;
    }
    if (v48)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      uint64_t v74 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
    goto LABEL_131;
  }
  if (!a3)
  {
LABEL_48:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v72 = "nw_http2_protocol_close";
    char v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v69 = 0;
    if (!__nwlog_fault(v30, &type, &v69)) {
      goto LABEL_131;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v72 = "nw_http2_protocol_close";
      uint64_t v33 = "%{public}s called with null input_protocol";
      goto LABEL_130;
    }
    if (!v69)
    {
      int v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_131;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v72 = "nw_http2_protocol_close";
      uint64_t v33 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_130;
    }
    uint64_t v49 = (char *)__nw_create_backtrace_string();
    int v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v50 = os_log_type_enabled(v31, type);
    if (v49)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = v49;
        _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v49);
      if (!v30) {
        return;
      }
LABEL_132:
      free(v30);
      return;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v72 = "nw_http2_protocol_close";
      uint64_t v33 = "%{public}s called with null input_protocol, no backtrace";
LABEL_130:
      _os_log_impl(&dword_1830D4000, v31, v32, v33, buf, 0xCu);
    }
LABEL_131:
    if (!v30) {
      return;
    }
    goto LABEL_132;
  }
  if (a2)
  {
    int v6 = *(unsigned __int16 *)(a2 + 188);
    if ((v6 & 4) == 0)
    {
      if (((v6 | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v7 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v9 = *(_DWORD *)(a2 + 176);
          int v8 = *(_DWORD *)(a2 + 180);
          *(_DWORD *)buf = 136447234;
          uint64_t v72 = "nw_http2_protocol_close";
          __int16 v73 = 2082;
          uint64_t v74 = (void *)(a2 + 191);
          __int16 v75 = 2080;
          __int16 v76 = " ";
          __int16 v77 = 1024;
          int v78 = v8;
          __int16 v79 = 1024;
          LODWORD(v80[0]) = v9;
          uint64_t v10 = "%{public}s %{public}s%s<i%u:s%d> protocol already closed, skipping callbacks";
          int v11 = v7;
          uint32_t v12 = 44;
LABEL_111:
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, v10, buf, v12);
          return;
        }
      }
      return;
    }
    unsigned int v13 = v6 & 0xFFFFFFFB | (*(unsigned __int8 *)(a2 + 190) << 16);
    *(_WORD *)(a2 + 188) = v6 & 0xFFFB;
    *(unsigned char *)(a2 + 190) = BYTE2(v13);
  }
LABEL_15:
  uint64_t v14 = *(void *)(a3 + 24);
  if (v14)
  {
    int v15 = *(void (**)(uint64_t, uint64_t))(v14 + 184);
    if (v15)
    {
      v15(a3, a1);
      goto LABEL_18;
    }
  }
  __nwlog_obj();
  int v20 = *(const char **)(a3 + 16);
  if (!v20) {
    int v20 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  uint64_t v72 = "nw_http2_protocol_close";
  __int16 v73 = 2082;
  uint64_t v74 = (void *)v20;
  int v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v69 = 0;
  if (__nwlog_fault(v21, &type, &v69))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_124;
      }
      uint64_t v24 = *(const char **)(a3 + 16);
      if (!v24) {
        uint64_t v24 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      uint64_t v74 = (void *)v24;
      int v25 = "%{public}s protocol %{public}s has invalid input_finished callback";
      goto LABEL_123;
    }
    if (!v69)
    {
      int v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_124;
      }
      int v57 = *(const char **)(a3 + 16);
      if (!v57) {
        int v57 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      uint64_t v74 = (void *)v57;
      int v25 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
      goto LABEL_123;
    }
    uint64_t v41 = (char *)__nw_create_backtrace_string();
    int v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v42 = os_log_type_enabled(v22, type);
    if (v41)
    {
      if (v42)
      {
        int v43 = *(const char **)(a3 + 16);
        if (!v43) {
          int v43 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)v43;
        __int16 v75 = 2082;
        __int16 v76 = v41;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v41);
      goto LABEL_124;
    }
    if (v42)
    {
      uint64_t v64 = *(const char **)(a3 + 16);
      if (!v64) {
        uint64_t v64 = "invalid";
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      uint64_t v74 = (void *)v64;
      int v25 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
LABEL_123:
      _os_log_impl(&dword_1830D4000, v22, v23, v25, buf, 0x16u);
    }
  }
LABEL_124:
  if (v21) {
    free(v21);
  }
LABEL_18:
  if (!a2)
  {
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v67 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v68 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)buf = 136447234;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)(a1 + 390);
        __int16 v75 = 2080;
        __int16 v76 = " ";
        __int16 v77 = 1024;
        int v78 = v68;
        __int16 v79 = 2048;
        v80[0] = a3;
        _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> sent input_finished to protocol %p", buf, 0x30u);
      }
    }
LABEL_62:
    int v37 = *(unsigned __int16 *)(a2 + 188);
    int v38 = v37 | (*(unsigned __int8 *)(a2 + 190) << 16);
    if ((v37 & 0x40) != 0) {
      return;
    }
    *(unsigned char *)(a2 + 190) = BYTE2(v38);
    *(_WORD *)(a2 + 188) = v38 | 0x40;
    uint64_t v39 = *(void *)(a3 + 24);
    if (v39)
    {
      __int16 v40 = *(void (**)(uint64_t, uint64_t))(v39 + 48);
      if (v40)
      {
        v40(a3, a1);
        goto LABEL_66;
      }
    }
    __nwlog_obj();
    uint32_t v51 = *(const char **)(a3 + 16);
    if (!v51) {
      uint32_t v51 = "invalid";
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v72 = "nw_http2_protocol_close";
    __int16 v73 = 2082;
    uint64_t v74 = (void *)v51;
    __int16 v52 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v69 = 0;
    if (__nwlog_fault(v52, &type, &v69))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v53 = __nwlog_obj();
        os_log_type_t v54 = type;
        if (!os_log_type_enabled(v53, type)) {
          goto LABEL_142;
        }
        os_log_type_t v55 = *(const char **)(a3 + 16);
        if (!v55) {
          os_log_type_t v55 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)v55;
        __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback";
        goto LABEL_141;
      }
      if (!v69)
      {
        uint64_t v53 = __nwlog_obj();
        os_log_type_t v54 = type;
        if (!os_log_type_enabled(v53, type)) {
          goto LABEL_142;
        }
        int v65 = *(const char **)(a3 + 16);
        if (!v65) {
          int v65 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)v65;
        __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_141;
      }
      int v61 = (char *)__nw_create_backtrace_string();
      uint64_t v53 = __nwlog_obj();
      os_log_type_t v54 = type;
      BOOL v62 = os_log_type_enabled(v53, type);
      if (v61)
      {
        if (v62)
        {
          BOOL v63 = *(const char **)(a3 + 16);
          if (!v63) {
            BOOL v63 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v72 = "nw_http2_protocol_close";
          __int16 v73 = 2082;
          uint64_t v74 = (void *)v63;
          __int16 v75 = 2082;
          __int16 v76 = v61;
          _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v61);
        goto LABEL_142;
      }
      if (v62)
      {
        int v66 = *(const char **)(a3 + 16);
        if (!v66) {
          int v66 = "invalid";
        }
        *(_DWORD *)buf = 136446466;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)v66;
        __int16 v56 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
LABEL_141:
        _os_log_impl(&dword_1830D4000, v53, v54, v56, buf, 0x16u);
      }
    }
LABEL_142:
    if (v52) {
      free(v52);
    }
LABEL_66:
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v58 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v60 = *(_DWORD *)(a2 + 176);
        int v59 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)buf = 136447490;
        uint64_t v72 = "nw_http2_protocol_close";
        __int16 v73 = 2082;
        uint64_t v74 = (void *)(a2 + 191);
        __int16 v75 = 2080;
        __int16 v76 = " ";
        __int16 v77 = 1024;
        int v78 = v59;
        __int16 v79 = 1024;
        LODWORD(v80[0]) = v60;
        WORD2(v80[0]) = 2048;
        *(void *)((char *)v80 + 6) = a3;
        uint64_t v10 = "%{public}s %{public}s%s<i%u:s%d> sent disconnected to protocol %p";
        int v11 = v58;
        uint32_t v12 = 54;
        goto LABEL_111;
      }
    }
    return;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v44 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v46 = *(_DWORD *)(a2 + 176);
      int v45 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447490;
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      uint64_t v74 = (void *)(a2 + 191);
      __int16 v75 = 2080;
      __int16 v76 = " ";
      __int16 v77 = 1024;
      int v78 = v45;
      __int16 v79 = 1024;
      LODWORD(v80[0]) = v46;
      WORD2(v80[0]) = 2048;
      *(void *)((char *)v80 + 6) = a3;
      _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> sent input_finished to protocol %p", buf, 0x36u);
    }
  }
  int v16 = *(unsigned __int16 *)(a2 + 188);
  if ((~v16 & 0x5000) != 0) {
    goto LABEL_62;
  }
  if (((v16 | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v17 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v19 = *(_DWORD *)(a2 + 176);
      int v18 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)buf = 136447746;
      uint64_t v72 = "nw_http2_protocol_close";
      __int16 v73 = 2082;
      uint64_t v74 = (void *)(a2 + 191);
      __int16 v75 = 2080;
      __int16 v76 = " ";
      __int16 v77 = 1024;
      int v78 = v18;
      __int16 v79 = 1024;
      LODWORD(v80[0]) = v19;
      WORD2(v80[0]) = 1024;
      *(_DWORD *)((char *)v80 + 6) = v19;
      WORD1(v80[1]) = 2048;
      *(void *)((char *)&v80[1] + 4) = a3;
      uint64_t v10 = "%{public}s %{public}s%s<i%u:s%d> skipping disconnected for stream %d, protocol %p because stream is already "
            "gracefully closed";
      int v11 = v17;
      uint32_t v12 = 60;
      goto LABEL_111;
    }
  }
}

void nw_http2_stream_destroy(void **a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (((*((unsigned __int16 *)a1 + 94) | (*((unsigned __int8 *)a1 + 190) << 16)) & 0x100000) != 0) {
    nw_http_transaction_metadata_set_event_handler(a1[12], 0);
  }
  if (gLogDatapath)
  {
    int v15 = __nwlog_obj();
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v17) = 136446210;
      *(void *)((char *)&v17 + 4) = "nw_protocol_finalize_temp_frame_array";
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v17, 0xCu);
    }
  }
  *(void *)&long long v17 = MEMORY[0x1E4F143A8];
  *((void *)&v17 + 1) = 0x40000000;
  int v18 = (uint64_t (*)(long long *))___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_83451;
  int v19 = &__block_descriptor_tmp_33_83452;
  int v20 = a1;
  char v21 = 0;
  __int16 v2 = *a1;
  do
  {
    if (!v2) {
      break;
    }
    uint64_t v3 = (void *)v2[4];
    char v4 = v18(&v17);
    __int16 v2 = v3;
  }
  while ((v4 & 1) != 0);
  if (gLogDatapath)
  {
    int v16 = __nwlog_obj();
    if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
    {
      LODWORD(v17) = 136446210;
      *(void *)((char *)&v17 + 4) = "nw_protocol_release_master_frame_array";
      _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v17, 0xCu);
    }
  }
  *(void *)&long long v17 = MEMORY[0x1E4F143A8];
  *((void *)&v17 + 1) = 0x40000000;
  int v18 = (uint64_t (*)(long long *))___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke;
  int v19 = &__block_descriptor_tmp_34_83454;
  int v20 = a1 + 2;
  int v5 = a1[2];
  do
  {
    if (!v5) {
      break;
    }
    int v6 = (void *)v5[2];
    char v7 = v18(&v17);
    int v5 = v6;
  }
  while ((v7 & 1) != 0);
  int v8 = a1[12];
  if (v8)
  {
    os_release(v8);
    a1[12] = 0;
  }
  int v9 = a1[13];
  if (v9)
  {
    os_release(v9);
    a1[13] = 0;
  }
  uint64_t v10 = a1[14];
  if (v10)
  {
    os_release(v10);
    a1[14] = 0;
  }
  __int16 v11 = *((_WORD *)a1 + 94);
  *((_DWORD *)a1 + 44) = -1;
  *((_WORD *)a1 + 94) = v11 & 0xEF66;
  if ((_BYTE)a1[21])
  {
    uint32_t v12 = a1[20];
    if (v12) {
      os_release(v12);
    }
  }
  a1[20] = 0;
  if ((_BYTE)a1[19])
  {
    unsigned int v13 = a1[18];
    if (v13) {
      os_release(v13);
    }
  }
  a1[18] = 0;
  uint64_t v14 = a1[15];
  if (v14)
  {
    a1[16] = v14;
    operator delete(v14);
  }
  free(a1);
}

uint64_t ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_83451(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 32);
  uint64_t v3 = *(void **)(a2 + 40);
  if (v2)
  {
    *(void *)(v2 + 40) = v3;
    uint64_t v3 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 32) + 8) = v3;
  }
  void *v3 = v2;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke(uint64_t a1, void *object)
{
  uint64_t v2 = object[2];
  uint64_t v3 = (void *)object[3];
  if (v2)
  {
    *(void *)(v2 + 24) = v3;
    uint64_t v3 = (void *)object[3];
  }
  else
  {
    *(void *)(*(void *)(a1 + 32) + 8) = v3;
  }
  void *v3 = v2;
  object[2] = 0;
  object[3] = 0;
  os_release(object);
  return 1;
}

uint64_t nw_http2_get_stream_node_from_id(uint64_t a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  int v12 = a2;
  if (a2 <= 0)
  {
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v10 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v11 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)buf = 136447234;
    uint64_t v14 = "nw_http2_get_stream_node_from_id";
    __int16 v15 = 2082;
    uint64_t v16 = a1 + 390;
    __int16 v17 = 2080;
    int v18 = " ";
    __int16 v19 = 1024;
    int v20 = v11;
    __int16 v21 = 1024;
    int v22 = a2;
    int v6 = "%{public}s %{public}s%s<i%u> requested stream id (%d) is not valid, returning NULL hash node";
    char v7 = v10;
    os_log_type_t v8 = OS_LOG_TYPE_ERROR;
    goto LABEL_14;
  }
  uint64_t result = *(void *)(a1 + 160);
  if (result)
  {
    uint64_t result = nw_hash_table_get_node(result, (uint64_t)&v12, 4);
    if (!result)
    {
      if (*(__int16 *)(a1 + 388) < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v4 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        return 0;
      }
      int v5 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)buf = 136447234;
      uint64_t v14 = "nw_http2_get_stream_node_from_id";
      __int16 v15 = 2082;
      uint64_t v16 = a1 + 390;
      __int16 v17 = 2080;
      int v18 = " ";
      __int16 v19 = 1024;
      int v20 = v5;
      __int16 v21 = 1024;
      int v22 = v12;
      int v6 = "%{public}s %{public}s%s<i%u> requested stream id (%d) not found, returning NULL";
      char v7 = v4;
      os_log_type_t v8 = OS_LOG_TYPE_DEBUG;
LABEL_14:
      _os_log_impl(&dword_1830D4000, v7, v8, v6, buf, 0x2Cu);
      return 0;
    }
  }
  return result;
}

uint64_t send_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD **a5, uint64_t a6)
{
  uint64_t v238 = *MEMORY[0x1E4F143B8];
  if (!a6)
  {
    __nwlog_obj();
    int buf = 136446210;
    nw_endpoint_t v226 = "send_data_callback";
    BOOL v94 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v219) = 16;
    LOBYTE(v215) = 0;
    if (!__nwlog_fault(v94, &v219, &v215)) {
      goto LABEL_264;
    }
    if (v219 == 17)
    {
      BOOL v95 = __nwlog_obj();
      os_log_type_t v96 = v219;
      if (!os_log_type_enabled(v95, (os_log_type_t)v219)) {
        goto LABEL_264;
      }
      int buf = 136446210;
      nw_endpoint_t v226 = "send_data_callback";
      BOOL v97 = "%{public}s nghttp2 user data is NULL, not http2";
    }
    else if ((_BYTE)v215)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v95 = __nwlog_obj();
      os_log_type_t v96 = v219;
      BOOL v111 = os_log_type_enabled(v95, (os_log_type_t)v219);
      if (backtrace_string)
      {
        if (v111)
        {
          int buf = 136446466;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = (unint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
        }
        free(backtrace_string);
LABEL_264:
        if (v94)
        {
          int v127 = (char *)v94;
LABEL_280:
          free(v127);
        }
        return 4294966394;
      }
      if (!v111) {
        goto LABEL_264;
      }
      int buf = 136446210;
      nw_endpoint_t v226 = "send_data_callback";
      BOOL v97 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }
    else
    {
      BOOL v95 = __nwlog_obj();
      os_log_type_t v96 = v219;
      if (!os_log_type_enabled(v95, (os_log_type_t)v219)) {
        goto LABEL_264;
      }
      int buf = 136446210;
      nw_endpoint_t v226 = "send_data_callback";
      BOOL v97 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v95, v96, v97, (uint8_t *)&buf, 0xCu);
    goto LABEL_264;
  }
  if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v98 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v99 = *(_DWORD *)(a6 + 368);
      int buf = 136446978;
      nw_endpoint_t v226 = "send_data_callback";
      __int16 v227 = 2082;
      unint64_t v228 = a6 + 390;
      __int16 v229 = 2080;
      v230 = " ";
      __int16 v231 = 1024;
      int v232 = v99;
      _os_log_impl(&dword_1830D4000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", (uint8_t *)&buf, 0x26u);
    }
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
  }
  if (!_nw_signposts_enabled || !kdebug_is_enabled())
  {
    if (a3) {
      goto LABEL_9;
    }
LABEL_204:
    __nwlog_obj();
    int buf = 136446210;
    nw_endpoint_t v226 = "send_data_callback";
    int v100 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v219) = 16;
    LOBYTE(v215) = 0;
    if (!__nwlog_fault(v100, &v219, &v215)) {
      goto LABEL_273;
    }
    if (v219 == 17)
    {
      int v101 = __nwlog_obj();
      os_log_type_t v102 = v219;
      if (os_log_type_enabled(v101, (os_log_type_t)v219))
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null framehd";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    if (!(_BYTE)v215)
    {
      int v101 = __nwlog_obj();
      os_log_type_t v102 = v219;
      if (os_log_type_enabled(v101, (os_log_type_t)v219))
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null framehd, backtrace limit exceeded";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    int v112 = (char *)__nw_create_backtrace_string();
    int v101 = __nwlog_obj();
    os_log_type_t v102 = v219;
    BOOL v113 = os_log_type_enabled(v101, (os_log_type_t)v219);
    if (!v112)
    {
      if (v113)
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null framehd, no backtrace";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    if (!v113) {
      goto LABEL_226;
    }
    int buf = 136446466;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = (unint64_t)v112;
    uint64_t v114 = "%{public}s called with null framehd, dumping backtrace:%{public}s";
    goto LABEL_225;
  }
  kdebug_trace();
  if (!a3) {
    goto LABEL_204;
  }
LABEL_9:
  if (!a2)
  {
    __nwlog_obj();
    int buf = 136446210;
    nw_endpoint_t v226 = "send_data_callback";
    int v100 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v219) = 16;
    LOBYTE(v215) = 0;
    if (!__nwlog_fault(v100, &v219, &v215)) {
      goto LABEL_273;
    }
    if (v219 == 17)
    {
      int v101 = __nwlog_obj();
      os_log_type_t v102 = v219;
      if (os_log_type_enabled(v101, (os_log_type_t)v219))
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null frame";
LABEL_272:
        _os_log_impl(&dword_1830D4000, v101, v102, v103, (uint8_t *)&buf, 0xCu);
      }
LABEL_273:
      if (!v100) {
        return 4294966775;
      }
      __int16 v52 = (char *)v100;
      goto LABEL_90;
    }
    if (!(_BYTE)v215)
    {
      int v101 = __nwlog_obj();
      os_log_type_t v102 = v219;
      if (os_log_type_enabled(v101, (os_log_type_t)v219))
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    int v112 = (char *)__nw_create_backtrace_string();
    int v101 = __nwlog_obj();
    os_log_type_t v102 = v219;
    BOOL v115 = os_log_type_enabled(v101, (os_log_type_t)v219);
    if (!v112)
    {
      if (v115)
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null frame, no backtrace";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    if (!v115) {
      goto LABEL_226;
    }
    int buf = 136446466;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = (unint64_t)v112;
    uint64_t v114 = "%{public}s called with null frame, dumping backtrace:%{public}s";
LABEL_225:
    _os_log_impl(&dword_1830D4000, v101, v102, v114, (uint8_t *)&buf, 0x16u);
    goto LABEL_226;
  }
  if (!a5)
  {
    __nwlog_obj();
    int buf = 136446210;
    nw_endpoint_t v226 = "send_data_callback";
    int v100 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v219) = 16;
    LOBYTE(v215) = 0;
    if (!__nwlog_fault(v100, &v219, &v215)) {
      goto LABEL_273;
    }
    if (v219 == 17)
    {
      int v101 = __nwlog_obj();
      os_log_type_t v102 = v219;
      if (os_log_type_enabled(v101, (os_log_type_t)v219))
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null source";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    if (!(_BYTE)v215)
    {
      int v101 = __nwlog_obj();
      os_log_type_t v102 = v219;
      if (os_log_type_enabled(v101, (os_log_type_t)v219))
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    int v112 = (char *)__nw_create_backtrace_string();
    int v101 = __nwlog_obj();
    os_log_type_t v102 = v219;
    BOOL v116 = os_log_type_enabled(v101, (os_log_type_t)v219);
    if (!v112)
    {
      if (v116)
      {
        int buf = 136446210;
        nw_endpoint_t v226 = "send_data_callback";
        int v103 = "%{public}s called with null source, no backtrace";
        goto LABEL_272;
      }
      goto LABEL_273;
    }
    if (v116)
    {
      int buf = 136446466;
      nw_endpoint_t v226 = "send_data_callback";
      __int16 v227 = 2082;
      unint64_t v228 = (unint64_t)v112;
      uint64_t v114 = "%{public}s called with null source, dumping backtrace:%{public}s";
      goto LABEL_225;
    }
LABEL_226:
    free(v112);
    goto LABEL_273;
  }
  unint64_t v11 = *(void *)(a2 + 16);
  if (v11) {
    int v12 = 10;
  }
  else {
    int v12 = 9;
  }
  if (v11 <= 1) {
    int v13 = 0;
  }
  else {
    int v13 = v11 - 1;
  }
  unint64_t v14 = (v13 + v12);
  if (0xFFFFFFFFLL - a4 < v14)
  {
    if (*(__int16 *)(a6 + 388) < 0) {
      return 4294966775;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v15 = *(_DWORD *)(a6 + 368);
    int buf = 136446978;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = a6 + 390;
    __int16 v229 = 2080;
    v230 = " ";
    __int16 v231 = 1024;
    int v232 = v15;
    uint64_t v16 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v219) = 16;
    LOBYTE(v215) = 0;
    if (__nwlog_fault(v16, &v219, &v215))
    {
      if (v219 == 17)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v17 = gconnectionLogObj;
        os_log_type_t v18 = v219;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v219))
        {
          int v19 = *(_DWORD *)(a6 + 368);
          int buf = 136446978;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v19;
          int v20 = "%{public}s %{public}s%s<i%u> bytes_to_send overflow";
LABEL_87:
          _os_log_impl(&dword_1830D4000, v17, v18, v20, (uint8_t *)&buf, 0x26u);
        }
      }
      else if ((_BYTE)v215)
      {
        int v36 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v17 = gconnectionLogObj;
        os_log_type_t v18 = v219;
        BOOL v37 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v219);
        if (!v36)
        {
          if (!v37) {
            goto LABEL_88;
          }
          int v51 = *(_DWORD *)(a6 + 368);
          int buf = 136446978;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v51;
          int v20 = "%{public}s %{public}s%s<i%u> bytes_to_send overflow, no backtrace";
          goto LABEL_87;
        }
        if (v37)
        {
          int v38 = *(_DWORD *)(a6 + 368);
          int buf = 136447234;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v38;
          __int16 v233 = 2082;
          *(void *)v234 = v36;
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s %{public}s%s<i%u> bytes_to_send overflow, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x30u);
        }
        free(v36);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v17 = gconnectionLogObj;
        os_log_type_t v18 = v219;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v219))
        {
          int v42 = *(_DWORD *)(a6 + 368);
          int buf = 136446978;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v42;
          int v20 = "%{public}s %{public}s%s<i%u> bytes_to_send overflow, backtrace limit exceeded";
          goto LABEL_87;
        }
      }
    }
LABEL_88:
    if (v16)
    {
      __int16 v52 = (char *)v16;
LABEL_90:
      free(v52);
    }
    return 4294966775;
  }
  __int16 v21 = *a5;
  if (!*a5)
  {
    if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v39 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v40 = *(_DWORD *)(a6 + 368);
        int buf = 136446978;
        nw_endpoint_t v226 = "send_data_callback";
        __int16 v227 = 2082;
        unint64_t v228 = a6 + 390;
        __int16 v229 = 2080;
        v230 = " ";
        __int16 v231 = 1024;
        int v232 = v40;
        _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Received unexpected NULL frame from data source", (uint8_t *)&buf, 0x26u);
        return 4294966394;
      }
    }
    return 4294966394;
  }
  int v22 = v21[13];
  if (v22) {
    v22 -= v21[14] + v21[15];
  }
  if (v22 != a4 && (*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v121 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v122 = *(_DWORD *)(a6 + 368);
      int v123 = v21[13];
      if (v123) {
        v123 -= v21[14] + v21[15];
      }
      int buf = 136447746;
      nw_endpoint_t v226 = "send_data_callback";
      __int16 v227 = 2082;
      unint64_t v228 = a6 + 390;
      __int16 v229 = 2080;
      v230 = " ";
      __int16 v231 = 1024;
      int v232 = v122;
      __int16 v233 = 2048;
      *(void *)v234 = v21;
      *(_WORD *)&v234[8] = 1024;
      int v235 = v123;
      __int16 v236 = 1024;
      int v237 = a4;
      _os_log_impl(&dword_1830D4000, v121, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> source frame %p has length %u, asked to send %u", (uint8_t *)&buf, 0x3Cu);
    }
  }
  v224[0] = 0;
  v224[1] = (uint64_t)v224;
  v223[0] = 0;
  v223[1] = v223;
  if (*(void *)(a6 + 240)) {
    BOOL v23 = 0;
  }
  else {
    BOOL v23 = (*(_WORD *)(a6 + 388) & 0x100) == 0;
  }
  if (v23) {
    uint64_t v24 = v223;
  }
  else {
    uint64_t v24 = (void *)(a6 + 240);
  }
  uint64_t v25 = *(void *)(a6 + 32);
  if (!v25
    || (uint64_t v26 = *(void *)(v25 + 24)) == 0
    || (uint64_t v27 = *(uint64_t (**)(uint64_t, uint64_t, void, void, uint64_t, uint64_t *))(v26 + 88)) == 0)
  {
    if ((*(_WORD *)(a6 + 388) & 0x8000) != 0) {
      return 4294966394;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v104 = *(_DWORD *)(a6 + 368);
    int buf = 136446978;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = a6 + 390;
    __int16 v229 = 2080;
    v230 = " ";
    __int16 v231 = 1024;
    int v232 = v104;
    int v105 = (const char *)_os_log_send_and_compose_impl();
    LOBYTE(v219) = 16;
    LOBYTE(v215) = 0;
    if (!__nwlog_fault(v105, &v219, &v215)) {
      goto LABEL_278;
    }
    if (v219 == 17)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v106 = gconnectionLogObj;
      os_log_type_t v107 = v219;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v219))
      {
        int v108 = *(_DWORD *)(a6 + 368);
        int buf = 136446978;
        nw_endpoint_t v226 = "send_data_callback";
        __int16 v227 = 2082;
        unint64_t v228 = a6 + 390;
        __int16 v229 = 2080;
        v230 = " ";
        __int16 v231 = 1024;
        int v232 = v108;
        int v109 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback";
LABEL_277:
        _os_log_impl(&dword_1830D4000, v106, v107, v109, (uint8_t *)&buf, 0x26u);
      }
    }
    else if ((_BYTE)v215)
    {
      uint64_t v117 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v106 = gconnectionLogObj;
      os_log_type_t v107 = v219;
      BOOL v118 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v219);
      if (!v117)
      {
        if (!v118) {
          goto LABEL_278;
        }
        int v128 = *(_DWORD *)(a6 + 368);
        int buf = 136446978;
        nw_endpoint_t v226 = "send_data_callback";
        __int16 v227 = 2082;
        unint64_t v228 = a6 + 390;
        __int16 v229 = 2080;
        v230 = " ";
        __int16 v231 = 1024;
        int v232 = v128;
        int v109 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, no backtrace";
        goto LABEL_277;
      }
      if (v118)
      {
        int v119 = *(_DWORD *)(a6 + 368);
        int buf = 136447234;
        nw_endpoint_t v226 = "send_data_callback";
        __int16 v227 = 2082;
        unint64_t v228 = a6 + 390;
        __int16 v229 = 2080;
        v230 = " ";
        __int16 v231 = 1024;
        int v232 = v119;
        __int16 v233 = 2082;
        *(void *)v234 = v117;
        _os_log_impl(&dword_1830D4000, v106, v107, "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x30u);
      }
      free(v117);
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v106 = gconnectionLogObj;
      os_log_type_t v107 = v219;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)v219))
      {
        int v120 = *(_DWORD *)(a6 + 368);
        int buf = 136446978;
        nw_endpoint_t v226 = "send_data_callback";
        __int16 v227 = 2082;
        unint64_t v228 = a6 + 390;
        __int16 v229 = 2080;
        v230 = " ";
        __int16 v231 = 1024;
        int v232 = v120;
        int v109 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, backtrace limit exceeded";
        goto LABEL_277;
      }
    }
LABEL_278:
    if (v105)
    {
      int v127 = (char *)v105;
      goto LABEL_280;
    }
    return 4294966394;
  }
  uint64_t v164 = *(void *)(a6 + 240);
  BOOL v165 = v24;
  unsigned int v166 = v14 + a4;
  int v28 = v27(v25, a6, (v14 + a4), (v14 + a4), 0xFFFFFFFFLL, v224);
  if (!v28 || !v224[0])
  {
    if (*(__int16 *)(a6 + 388) < 0 || !gLogDatapath) {
      goto LABEL_67;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v125 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_67;
    }
    int v126 = *(_DWORD *)(a6 + 368);
    int buf = 136446978;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = a6 + 390;
    __int16 v229 = 2080;
    v230 = " ";
    __int16 v231 = 1024;
    int v232 = v126;
    uint64_t v33 = "%{public}s %{public}s%s<i%u> got back zero frames, cannot send data, returning NGHTTP2_ERR_WOULDBLOCK";
    __int16 v34 = v125;
    uint32_t v35 = 38;
    goto LABEL_260;
  }
  int v29 = v28;
  int buf = 0;
  nw_frame_array_get_frame_count(v224, 1, &buf);
  unsigned int v30 = buf;
  if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    nw_endpoint_t logb = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v124 = *(_DWORD *)(a6 + 368);
      int buf = 136447490;
      nw_endpoint_t v226 = "send_data_callback";
      __int16 v227 = 2082;
      unint64_t v228 = a6 + 390;
      __int16 v229 = 2080;
      v230 = " ";
      __int16 v231 = 1024;
      int v232 = v124;
      __int16 v233 = 1024;
      *(_DWORD *)v234 = v29;
      *(_WORD *)&v234[4] = 1024;
      *(_DWORD *)&v234[6] = v30;
      _os_log_impl(&dword_1830D4000, logb, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> got back %u frames from output handler (%u bytes)", (uint8_t *)&buf, 0x32u);
    }
  }
  if (v30 < v166)
  {
    if (*(__int16 *)(a6 + 388) < 0 || !gLogDatapath) {
      goto LABEL_67;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v31 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_67;
    }
    int v32 = *(_DWORD *)(a6 + 368);
    int buf = 136447490;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = a6 + 390;
    __int16 v229 = 2080;
    v230 = " ";
    __int16 v231 = 1024;
    int v232 = v32;
    __int16 v233 = 1024;
    *(_DWORD *)v234 = v30;
    *(_WORD *)&v234[4] = 1024;
    *(_DWORD *)&v234[6] = v166;
    uint64_t v33 = "%{public}s %{public}s%s<i%u> got back fewer bytes than necessary (%u / %u), returing E_WOULDBLOCK";
    __int16 v34 = v31;
    uint32_t v35 = 50;
LABEL_260:
    _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, v33, (uint8_t *)&buf, v35);
LABEL_67:
    *(_WORD *)(a6 + 388) |= 0x2000u;
    return 4294966792;
  }
  uint64_t v219 = 0;
  os_log_type_t v220 = &v219;
  int v222 = 0;
  uint64_t v221 = 0x2000000000;
  uint64_t v215 = 0;
  char v216 = &v215;
  int v218 = 0;
  uint64_t v217 = 0x2000000000;
  v213[0] = 0;
  v213[1] = v213;
  int v214 = 0;
  v213[2] = 0x2000000000;
  int v212 = 0;
  v210 = &v209;
  uint64_t v211 = 0x2000000000;
  uint64_t v205 = 0;
  os_log_type_t v206 = &v205;
  uint64_t v207 = 0x2000000000;
  uint64_t v208 = 0;
  uint64_t v209 = 0;
  v203[0] = 0;
  v203[1] = v203;
  v203[2] = 0x2000000000;
  char v204 = 0;
  v201[0] = 0;
  v201[1] = v201;
  v201[2] = 0x2000000000;
  char v202 = 0;
  v199[0] = 0;
  v199[1] = v199;
  v199[2] = 0x2000000000;
  char v200 = 0;
  if (nw_protocol_copy_http_definition_onceToken != -1) {
    dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
  }
  id v43 = (id)nw_protocol_copy_http_definition_http_definition;
  int v44 = nw_frame_copy_metadata_for_protocol((uint64_t)v21, (uint64_t)v43);
  if (v43) {
    os_release(v43);
  }
  uint64_t object = v44;
  if (!v44 || !nw_http_metadata_is_capsule(v44))
  {
    capsule_os_log_type_t type = 0;
    unint64_t v54 = 0;
    os_log_type_t v55 = 0;
    __int16 v56 = 0;
    size_t size = 0;
    LOBYTE(v49) = 0;
    LOBYTE(v57) = 0;
    BOOL v47 = 0;
    LOBYTE(v50) = 0;
    BOOL v58 = 0;
LABEL_116:
    v169[0] = MEMORY[0x1E4F143A8];
    v169[1] = 0x40000000;
    id v170 = ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke_83522;
    uint64_t v171 = &unk_1E524A950;
    uint64_t v180 = a3;
    uint64_t v181 = a6;
    unsigned int v193 = v166;
    uint64_t v182 = a2;
    uint64_t v183 = a4;
    id v172 = &v219;
    nw_endpoint_t v173 = &v215;
    char v194 = v49;
    os_log_t loga = v55;
    os_log_type_t v184 = v55;
    unint64_t v185 = capsule_type;
    char v195 = v57;
    id v174 = v203;
    v175 = v201;
    BOOL v196 = v47;
    char v197 = v50;
    unint64_t v186 = v54;
    uint64_t v187 = 0;
    BOOL v198 = v58;
    BOOL v188 = v56;
    size_t v189 = size;
    size_t v63 = size;
    os_log_type_t v176 = v199;
    id v177 = &v205;
    os_log_type_t v190 = v21;
    BOOL v191 = v224;
    id v192 = v165;
    id v178 = v213;
    os_log_type_t v179 = &v209;
    uint64_t v64 = v224[0];
    char v65 = v58;
    int v66 = v56;
    do
    {
      if (!v64) {
        break;
      }
      uint64_t v67 = *(void *)(v64 + 32);
      char v68 = ((uint64_t (*)(void *))v170)(v169);
      uint64_t v64 = v67;
    }
    while ((v68 & 1) != 0);
    if (v66) {
      dispatch_release(v66);
    }
    if (object) {
      os_release(object);
    }
    if ((*(_WORD *)(a6 + 388) & 0x100) != 0 || v164)
    {
      os_log_t v71 = loga;
      if ((*(_WORD *)(a6 + 388) & 0x8000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v138 = gconnectionLogObj;
        BOOL v139 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        os_log_t v71 = loga;
        if (v139)
        {
          int v140 = *(_DWORD *)(a6 + 368);
          int v141 = *((_DWORD *)v220 + 6);
          int v142 = *((_DWORD *)v210 + 6);
          int buf = 136447490;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v140;
          __int16 v233 = 1024;
          *(_DWORD *)v234 = v141;
          *(_WORD *)&v234[4] = 1024;
          *(_DWORD *)&v234[6] = v142;
          __int16 v76 = "%{public}s %{public}s%s<i%u> wrote %u bytes (pending %u frames)";
          __int16 v77 = v138;
          uint32_t v78 = 50;
          goto LABEL_298;
        }
      }
LABEL_136:
      int v79 = v21[13];
      if (!v79 || (int v80 = v21[14] + v21[15], v81 = v79 - v80, v79 == v80))
      {
        if (v71) {
          char v82 = v65;
        }
        else {
          char v82 = 1;
        }
        if ((v82 & 1) != 0 || v206[3] == v63)
        {
          if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v146 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v147 = *(_DWORD *)(a6 + 368);
              int v148 = *((_DWORD *)v216 + 6);
              int buf = 136447490;
              nw_endpoint_t v226 = "send_data_callback";
              __int16 v227 = 2082;
              unint64_t v228 = a6 + 390;
              __int16 v229 = 2080;
              v230 = " ";
              __int16 v231 = 1024;
              int v232 = v147;
              __int16 v233 = 2048;
              *(void *)v234 = v21;
              *(_WORD *)&v234[8] = 1024;
              int v235 = v148;
              _os_log_impl(&dword_1830D4000, v146, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> finished writing complete frame %p, final length %u", (uint8_t *)&buf, 0x36u);
            }
          }
          http2_output_frame_metadata_reset((uint64_t)v21, 0, 0);
          nw_frame_cache_return_frame(a6 + 200, (uint64_t)v21);
          *a5 = 0;
          goto LABEL_149;
        }
        int v81 = 0;
      }
      if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v135 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v136 = *(_DWORD *)(a6 + 368);
          int v137 = *((_DWORD *)v216 + 6);
          int buf = 136447490;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v136;
          __int16 v233 = 1024;
          *(_DWORD *)v234 = v137;
          *(_WORD *)&v234[4] = 1024;
          *(_DWORD *)&v234[6] = v81;
          _os_log_impl(&dword_1830D4000, v135, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote partial frame, %u bytes, %u remaining", (uint8_t *)&buf, 0x32u);
        }
      }
LABEL_149:
      if (*((_DWORD *)v220 + 6) == v166)
      {
        uint64_t v41 = 0;
LABEL_177:
        _Block_object_dispose(v199, 8);
        _Block_object_dispose(v201, 8);
        _Block_object_dispose(v203, 8);
        _Block_object_dispose(&v205, 8);
        _Block_object_dispose(&v209, 8);
        _Block_object_dispose(v213, 8);
        _Block_object_dispose(&v215, 8);
        _Block_object_dispose(&v219, 8);
        return v41;
      }
      if (*(__int16 *)(a6 + 388) < 0)
      {
LABEL_176:
        uint64_t v41 = 4294966394;
        goto LABEL_177;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v83 = *(_DWORD *)(a6 + 368);
      int buf = 136446978;
      nw_endpoint_t v226 = "send_data_callback";
      __int16 v227 = 2082;
      unint64_t v228 = a6 + 390;
      __int16 v229 = 2080;
      v230 = " ";
      __int16 v231 = 1024;
      int v232 = v83;
      int v84 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v167 = 0;
      if (__nwlog_fault(v84, &type, &v167))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v85 = gconnectionLogObj;
          os_log_type_t v86 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_174;
          }
          int v87 = *(_DWORD *)(a6 + 368);
          int buf = 136446978;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v87;
          BOOL v88 = "%{public}s %{public}s%s<i%u> did not write complete frame";
          goto LABEL_173;
        }
        if (!v167)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v85 = gconnectionLogObj;
          os_log_type_t v86 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_174;
          }
          int v92 = *(_DWORD *)(a6 + 368);
          int buf = 136446978;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v92;
          BOOL v88 = "%{public}s %{public}s%s<i%u> did not write complete frame, backtrace limit exceeded";
          goto LABEL_173;
        }
        int v89 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v85 = gconnectionLogObj;
        os_log_type_t v86 = type;
        BOOL v90 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v89)
        {
          if (v90)
          {
            int v91 = *(_DWORD *)(a6 + 368);
            int buf = 136447234;
            nw_endpoint_t v226 = "send_data_callback";
            __int16 v227 = 2082;
            unint64_t v228 = a6 + 390;
            __int16 v229 = 2080;
            v230 = " ";
            __int16 v231 = 1024;
            int v232 = v91;
            __int16 v233 = 2082;
            *(void *)v234 = v89;
            _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s %{public}s%s<i%u> did not write complete frame, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x30u);
          }
          free(v89);
          goto LABEL_174;
        }
        if (v90)
        {
          int v93 = *(_DWORD *)(a6 + 368);
          int buf = 136446978;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = a6 + 390;
          __int16 v229 = 2080;
          v230 = " ";
          __int16 v231 = 1024;
          int v232 = v93;
          BOOL v88 = "%{public}s %{public}s%s<i%u> did not write complete frame, no backtrace";
LABEL_173:
          _os_log_impl(&dword_1830D4000, v85, v86, v88, (uint8_t *)&buf, 0x26u);
        }
      }
LABEL_174:
      if (v84) {
        free(v84);
      }
      goto LABEL_176;
    }
    uint64_t v69 = *(void *)(v25 + 24);
    if (v69)
    {
      char v70 = *(void (**)(uint64_t, void *))(v69 + 96);
      if (v70)
      {
        v70(v25, v223);
        goto LABEL_128;
      }
    }
    char v159 = v65;
    __nwlog_obj();
    int v129 = *(const char **)(v25 + 16);
    if (!v129) {
      int v129 = "invalid";
    }
    int buf = 136446466;
    nw_endpoint_t v226 = "send_data_callback";
    __int16 v227 = 2082;
    unint64_t v228 = (unint64_t)v129;
    BOOL v130 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v167 = 0;
    if (__nwlog_fault(v130, &type, &v167))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v131 = __nwlog_obj();
        os_log_type_t v132 = type;
        if (os_log_type_enabled(v131, type))
        {
          char v133 = *(const char **)(v25 + 16);
          if (!v133) {
            char v133 = "invalid";
          }
          int buf = 136446466;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = (unint64_t)v133;
          int v134 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
LABEL_318:
          _os_log_impl(&dword_1830D4000, v131, v132, v134, (uint8_t *)&buf, 0x16u);
        }
      }
      else if (v167)
      {
        int v143 = (char *)__nw_create_backtrace_string();
        int v131 = __nwlog_obj();
        os_log_type_t v132 = type;
        BOOL v144 = os_log_type_enabled(v131, type);
        if (v143)
        {
          if (v144)
          {
            id v145 = *(const char **)(v25 + 16);
            if (!v145) {
              id v145 = "invalid";
            }
            int buf = 136446722;
            nw_endpoint_t v226 = "send_data_callback";
            __int16 v227 = 2082;
            unint64_t v228 = (unint64_t)v145;
            __int16 v229 = 2082;
            v230 = v143;
            _os_log_impl(&dword_1830D4000, v131, v132, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
          }
          free(v143);
          goto LABEL_319;
        }
        if (v144)
        {
          BOOL v150 = *(const char **)(v25 + 16);
          if (!v150) {
            BOOL v150 = "invalid";
          }
          int buf = 136446466;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = (unint64_t)v150;
          int v134 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
          goto LABEL_318;
        }
      }
      else
      {
        int v131 = __nwlog_obj();
        os_log_type_t v132 = type;
        if (os_log_type_enabled(v131, type))
        {
          os_log_type_t v149 = *(const char **)(v25 + 16);
          if (!v149) {
            os_log_type_t v149 = "invalid";
          }
          int buf = 136446466;
          nw_endpoint_t v226 = "send_data_callback";
          __int16 v227 = 2082;
          unint64_t v228 = (unint64_t)v149;
          int v134 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
          goto LABEL_318;
        }
      }
    }
LABEL_319:
    if (v130) {
      free(v130);
    }
    char v65 = v159;
LABEL_128:
    os_log_t v71 = loga;
    if ((*(__int16 *)(a6 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v72 = gconnectionLogObj;
      BOOL v73 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      os_log_t v71 = loga;
      if (v73)
      {
        int v74 = *(_DWORD *)(a6 + 368);
        int v75 = *((_DWORD *)v220 + 6);
        int buf = 136447234;
        nw_endpoint_t v226 = "send_data_callback";
        __int16 v227 = 2082;
        unint64_t v228 = a6 + 390;
        __int16 v229 = 2080;
        v230 = " ";
        __int16 v231 = 1024;
        int v232 = v74;
        __int16 v233 = 1024;
        *(_DWORD *)v234 = v75;
        __int16 v76 = "%{public}s %{public}s%s<i%u> wrote %u bytes";
        __int16 v77 = v72;
        uint32_t v78 = 44;
LABEL_298:
        _os_log_impl(&dword_1830D4000, v77, OS_LOG_TYPE_DEBUG, v76, (uint8_t *)&buf, v78);
        os_log_t v71 = loga;
        goto LABEL_136;
      }
    }
    goto LABEL_136;
  }
  capsule_os_log_type_t type = nw_http_metadata_get_capsule_type(v44);
  size_t size = (size_t)nw_http_metadata_copy_capsule_data(v44);
  os_log_t log = (os_log_t)size;
  if (size) {
    size_t size = dispatch_data_get_size((dispatch_data_t)size);
  }
  BOOL v47 = capsule_type == 0;
  BOOL v158 = (size | capsule_type) == 0;
  if (!(size | capsule_type))
  {
    unsigned int v48 = v21[13];
    if (v48) {
      v48 -= v21[14] + v21[15];
    }
    size_t size = v48;
LABEL_84:
    capsule_os_log_type_t type = 0;
    int v49 = 1;
    unsigned int v50 = 1;
    goto LABEL_105;
  }
  if (capsule_type < 0x40)
  {
    if (capsule_type)
    {
      unsigned int v50 = 0;
      int v49 = 1;
      goto LABEL_105;
    }
    goto LABEL_84;
  }
  if (capsule_type >> 14)
  {
    if (capsule_type >> 30)
    {
      if (capsule_type >> 62)
      {
        BOOL v154 = capsule_type == 0;
        size_t v156 = size;
        int v59 = __nwlog_obj();
        os_log_type_enabled(v59, OS_LOG_TYPE_ERROR);
        int buf = 136446466;
        nw_endpoint_t v226 = "_http_vle_encode";
        __int16 v227 = 2048;
        unint64_t v228 = capsule_type;
        int v60 = (void *)_os_log_send_and_compose_impl();
        uint64_t result = __nwlog_abort((uint64_t)v60);
        if (result) {
          goto LABEL_322;
        }
        free(v60);
        int v49 = 0;
        capsule_os_log_type_t type = 0;
        unsigned int v50 = 0;
        size_t size = v156;
        BOOL v47 = v154;
      }
      else
      {
        unsigned int v50 = 0;
        capsule_os_log_type_t type = bswap64(capsule_type | 0xC000000000000000);
        int v49 = 8;
      }
    }
    else
    {
      unsigned int v50 = 0;
      capsule_os_log_type_t type = bswap32(capsule_type | 0x80000000);
      int v49 = 4;
    }
  }
  else
  {
    unsigned int v50 = 0;
    capsule_os_log_type_t type = bswap32(capsule_type | 0x4000) >> 16;
    int v49 = 2;
  }
LABEL_105:
  unint64_t v61 = size + v50;
  if (v61 < 0x40)
  {
    int v57 = 1;
    unint64_t v54 = size + v50;
LABEL_115:
    os_log_type_t v55 = (v61 + (v57 + v49));
    BOOL v58 = v158;
    __int16 v56 = log;
    goto LABEL_116;
  }
  if (!(v61 >> 14))
  {
    unint64_t v54 = bswap32(v61 | 0x4000) >> 16;
    int v57 = 2;
    goto LABEL_115;
  }
  if (!(v61 >> 30))
  {
    unint64_t v54 = bswap32(v61 | 0x80000000);
    int v57 = 4;
    goto LABEL_115;
  }
  if (!(v61 >> 62))
  {
    unint64_t v54 = bswap64(v61 | 0xC000000000000000);
    int v57 = 8;
    goto LABEL_115;
  }
  int v151 = v49;
  char v152 = v50;
  BOOL v155 = v47;
  size_t v157 = size;
  BOOL v62 = __nwlog_obj();
  os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
  int buf = 136446466;
  nw_endpoint_t v226 = "_http_vle_encode";
  __int16 v227 = 2048;
  unint64_t v228 = v61;
  uint64_t v153 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v153);
  if (!result)
  {
    free(v153);
    unint64_t v54 = 0;
    int v57 = 0;
    size_t size = v157;
    BOOL v47 = v155;
    int v49 = v151;
    LOBYTE(v50) = v152;
    goto LABEL_115;
  }
LABEL_322:
  __break(1u);
  return result;
}

uint64_t ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke_83522(uint64_t a1, uint64_t a2)
{
  uint64_t v263 = *MEMORY[0x1E4F143B8];
  unsigned int v254 = 0;
  uint64_t v4 = (unsigned char *)nw_frame_unclaimed_bytes(a2, &v254);
  int v6 = v4;
  uint64_t v7 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  if (v7 > 8)
  {
    LODWORD(v8) = 0;
  }
  else
  {
    if (!v254)
    {
      LODWORD(v8) = 0;
      goto LABEL_278;
    }
    if (9 - (int)v7 >= v254) {
      size_t v8 = v254;
    }
    else {
      size_t v8 = (9 - v7);
    }
    memcpy(v4, (const void *)(*(void *)(a1 + 96) + v7), v8);
    uint64_t v9 = *(void *)(a1 + 104);
    if ((!v9 || (*(__int16 *)(v9 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v172 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v173 = *(void *)(a1 + 104);
        id v174 = "";
        BOOL v175 = v173 == 0;
        int v176 = *(_DWORD *)(v173 + 368);
        id v177 = (const char *)(v173 + 390);
        v256 = "send_data_callback_block_invoke";
        __int16 v257 = 2082;
        if (v175) {
          id v177 = "";
        }
        *(_DWORD *)int buf = 136447234;
        if (!v175) {
          id v174 = " ";
        }
        id v258 = v177;
        __int16 v259 = 2080;
        size_t v260 = (size_t)v174;
        __int16 v261 = 1024;
        *(_DWORD *)nw_endpoint_t v262 = v176;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = v8;
        _os_log_impl(&dword_1830D4000, v172, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of frame header", buf, 0x2Cu);
      }
    }
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v8;
    LODWORD(v7) = *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  unint64_t v10 = *(void *)(*(void *)(a1 + 112) + 16);
  if (!v10)
  {
    if (v7 >= *(_DWORD *)(a1 + 200) || v254 <= v8) {
      goto LABEL_278;
    }
    if (*(_DWORD *)(a1 + 120) - *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) >= v254 - v8) {
      LODWORD(v21) = v254 - v8;
    }
    else {
      LODWORD(v21) = *(_DWORD *)(a1 + 120) - *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
    }
    if (!*(void *)(a1 + 128)) {
      goto LABEL_269;
    }
    uint64_t v22 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
    unsigned int v23 = *(unsigned __int8 *)(a1 + 204) - v22;
    if (v23 >= v21) {
      size_t v24 = v21;
    }
    else {
      size_t v24 = v23;
    }
    if (!v24)
    {
LABEL_99:
      uint64_t v45 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
      unsigned int v46 = *(unsigned __int8 *)(a1 + 205) - v45;
      if (v46 >= v21) {
        size_t v47 = v21;
      }
      else {
        size_t v47 = v46;
      }
      if (!v47) {
        goto LABEL_150;
      }
      memcpy(&v6[v8], (const void *)(a1 + v45 + 144), v47);
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v47;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v47;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v47;
      BOOL v16 = v21 >= v47;
      uint64_t v48 = (v21 - v47);
      LODWORD(v21) = v21 - v47;
      if (v16)
      {
LABEL_146:
        LODWORD(v8) = v47 + v8;
        uint64_t v66 = *(void *)(a1 + 104);
        if ((!v66 || (*(__int16 *)(v66 + 388) & 0x80000000) == 0) && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v221 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v222 = *(void *)(a1 + 104);
            __int16 v223 = "";
            BOOL v224 = v222 == 0;
            int v225 = *(_DWORD *)(v222 + 368);
            nw_endpoint_t v226 = (const char *)(v222 + 390);
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            if (v224) {
              nw_endpoint_t v226 = "";
            }
            *(_DWORD *)int buf = 136447234;
            if (!v224) {
              __int16 v223 = " ";
            }
            id v258 = v226;
            __int16 v259 = 2080;
            size_t v260 = (size_t)v223;
            __int16 v261 = 1024;
            *(_DWORD *)nw_endpoint_t v262 = v225;
            *(_WORD *)&v262[4] = 1024;
            *(_DWORD *)&v262[6] = v47;
            _os_log_impl(&dword_1830D4000, v221, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule length", buf, 0x2Cu);
          }
        }
        if (v254 <= v8) {
          goto LABEL_278;
        }
LABEL_150:
        if (!*(unsigned char *)(a1 + 206)) {
          goto LABEL_267;
        }
        uint64_t v67 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
        unsigned int v68 = *(unsigned __int8 *)(a1 + 207) - v67;
        size_t v69 = v68 >= v21 ? v21 : v68;
        if (!v69) {
          goto LABEL_267;
        }
        memcpy(&v6[v8], (const void *)(a1 + v67 + 152), v69);
        *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v69;
        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v69;
        *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v69;
        BOOL v16 = v21 >= v69;
        uint64_t v70 = (v21 - v69);
        LODWORD(v21) = v21 - v69;
        if (v16)
        {
LABEL_263:
          LODWORD(v8) = v69 + v8;
          uint64_t v128 = *(void *)(a1 + 104);
          if ((!v128 || (*(__int16 *)(v128 + 388) & 0x80000000) == 0) && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v233 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v234 = *(void *)(a1 + 104);
              int v235 = "";
              BOOL v236 = v234 == 0;
              int v237 = *(_DWORD *)(v234 + 368);
              uint64_t v238 = (const char *)(v234 + 390);
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              if (v236) {
                uint64_t v238 = "";
              }
              *(_DWORD *)int buf = 136447234;
              if (!v236) {
                int v235 = " ";
              }
              id v258 = v238;
              __int16 v259 = 2080;
              size_t v260 = (size_t)v235;
              __int16 v261 = 1024;
              *(_DWORD *)nw_endpoint_t v262 = v237;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v69;
              _os_log_impl(&dword_1830D4000, v233, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of datagram context", buf, 0x2Cu);
            }
          }
          if (v254 <= v8) {
            goto LABEL_278;
          }
LABEL_267:
          int v129 = *(NSObject **)(a1 + 160);
          if (!v129 || *(unsigned char *)(a1 + 208)) {
            goto LABEL_269;
          }
          uint64_t v149 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
          unsigned int v150 = *(_DWORD *)(a1 + 168) - v149;
          uint64_t v151 = v150 >= v21 ? v21 : v150;
          if (!v151) {
            goto LABEL_269;
          }
          nw_dispatch_data_copyout_from_offset(v129, (uint64_t)&v6[v8], v151, v149);
          *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v151;
          *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v151;
          *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) += v151;
          BOOL v16 = v21 >= v151;
          uint64_t v152 = (v21 - v151);
          LODWORD(v21) = v21 - v151;
          if (v16) {
            goto LABEL_388;
          }
          __nwlog_obj();
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v151;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v152;
          uint64_t v153 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v153, type, &v253))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              BOOL v154 = __nwlog_obj();
              os_log_type_t v155 = type[0];
              if (os_log_type_enabled(v154, type[0]))
              {
                *(_DWORD *)int buf = 136446978;
                v256 = "send_data_callback_block_invoke";
                __int16 v257 = 2082;
                id v258 = "bodyCopySize";
                __int16 v259 = 2048;
                size_t v260 = v151;
                __int16 v261 = 2048;
                *(void *)nw_endpoint_t v262 = v152;
                size_t v156 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_384:
                _os_log_impl(&dword_1830D4000, v154, v155, v156, buf, 0x2Au);
              }
            }
            else if (v253)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              BOOL v154 = __nwlog_obj();
              os_log_type_t v155 = type[0];
              BOOL v164 = os_log_type_enabled(v154, type[0]);
              if (backtrace_string)
              {
                if (v164)
                {
                  *(_DWORD *)int buf = 136447234;
                  v256 = "send_data_callback_block_invoke";
                  __int16 v257 = 2082;
                  id v258 = "bodyCopySize";
                  __int16 v259 = 2048;
                  size_t v260 = v151;
                  __int16 v261 = 2048;
                  *(void *)nw_endpoint_t v262 = v152;
                  *(_WORD *)&v262[8] = 2082;
                  *(void *)&v262[10] = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v154, v155, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(backtrace_string);
                goto LABEL_385;
              }
              if (v164)
              {
                *(_DWORD *)int buf = 136446978;
                v256 = "send_data_callback_block_invoke";
                __int16 v257 = 2082;
                id v258 = "bodyCopySize";
                __int16 v259 = 2048;
                size_t v260 = v151;
                __int16 v261 = 2048;
                *(void *)nw_endpoint_t v262 = v152;
                size_t v156 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
                goto LABEL_384;
              }
            }
            else
            {
              BOOL v154 = __nwlog_obj();
              os_log_type_t v155 = type[0];
              if (os_log_type_enabled(v154, type[0]))
              {
                *(_DWORD *)int buf = 136446978;
                v256 = "send_data_callback_block_invoke";
                __int16 v257 = 2082;
                id v258 = "bodyCopySize";
                __int16 v259 = 2048;
                size_t v260 = v151;
                __int16 v261 = 2048;
                *(void *)nw_endpoint_t v262 = v152;
                size_t v156 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
                goto LABEL_384;
              }
            }
          }
LABEL_385:
          if (v153) {
            free(v153);
          }
          LODWORD(v21) = 0;
LABEL_388:
          LODWORD(v8) = v151 + v8;
          uint64_t v178 = *(void *)(a1 + 104);
          if ((!v178 || (*(__int16 *)(v178 + 388) & 0x80000000) == 0) && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            nw_endpoint_t v245 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v246 = *(void *)(a1 + 104);
              v247 = "";
              BOOL v248 = v246 == 0;
              int v249 = *(_DWORD *)(v246 + 368);
              os_log_type_t v250 = (const char *)(v246 + 390);
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              if (v248) {
                os_log_type_t v250 = "";
              }
              *(_DWORD *)int buf = 136447234;
              if (!v248) {
                v247 = " ";
              }
              id v258 = v250;
              __int16 v259 = 2080;
              size_t v260 = (size_t)v247;
              __int16 v261 = 1024;
              *(_DWORD *)nw_endpoint_t v262 = v249;
              *(_WORD *)&v262[4] = 1024;
              *(_DWORD *)&v262[6] = v151;
              _os_log_impl(&dword_1830D4000, v245, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule body", buf, 0x2Cu);
            }
          }
          if (v254 <= v8) {
            goto LABEL_278;
          }
LABEL_269:
          *(_DWORD *)os_log_type_t type = 0;
          BOOL v130 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 176), type);
          if (v130)
          {
            if (v21 >= *(_DWORD *)type) {
              size_t v85 = *(unsigned int *)type;
            }
            else {
              size_t v85 = v21;
            }
            memcpy(&v6[v8], v130, v85);
            uint64_t v132 = *(void *)(a1 + 104);
            if ((!v132 || (*(__int16 *)(v132 + 388) & 0x80000000) == 0) && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v209 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v210 = *(void *)(a1 + 104);
                uint64_t v211 = "";
                BOOL v212 = v210 == 0;
                int v213 = *(_DWORD *)(v210 + 368);
                int v214 = (const char *)(v210 + 390);
                v256 = "send_data_callback_block_invoke";
                __int16 v257 = 2082;
                if (v212) {
                  int v214 = "";
                }
                *(_DWORD *)int buf = 136447234;
                if (!v212) {
                  uint64_t v211 = " ";
                }
                id v258 = v214;
                __int16 v259 = 2080;
                size_t v260 = (size_t)v211;
                __int16 v261 = 1024;
                *(_DWORD *)nw_endpoint_t v262 = v213;
                *(_WORD *)&v262[4] = 1024;
                *(_DWORD *)&v262[6] = v85;
                _os_log_impl(&dword_1830D4000, v209, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of body data (no padding)", buf, 0x2Cu);
              }
            }
            nw_frame_claim(*(void *)(a1 + 176), v131, v85, 0);
            LODWORD(v8) = v85 + v8;
            *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v85;
            uint64_t v87 = *(void *)(a1 + 40);
LABEL_277:
            *(_DWORD *)(*(void *)(v87 + 8) + 24) += v85;
            goto LABEL_278;
          }
          if (*(void *)(a1 + 128)) {
            goto LABEL_278;
          }
          uint64_t v141 = *(void *)(a1 + 104);
          if (!v141 || (*(__int16 *)(v141 + 388) & 0x80000000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v142 = *(void *)(a1 + 104);
            int v143 = (const char *)(v142 + 390);
            BOOL v144 = v142 == 0;
            int v145 = *(_DWORD *)(v142 + 368);
            *(_DWORD *)int buf = 136446978;
            if (v144) {
              int v143 = "";
            }
            v256 = "send_data_callback_block_invoke";
            if (v144) {
              uint64_t v146 = "";
            }
            else {
              uint64_t v146 = " ";
            }
            __int16 v257 = 2082;
            id v258 = v143;
            __int16 v259 = 2080;
            size_t v260 = (size_t)v146;
            __int16 v261 = 1024;
            *(_DWORD *)nw_endpoint_t v262 = v145;
            BOOL v94 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t v253 = OS_LOG_TYPE_ERROR;
            char v251 = 0;
            if (!__nwlog_fault(v94, &v253, &v251)) {
              goto LABEL_343;
            }
            if (v253 == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              BOOL v95 = gconnectionLogObj;
              os_log_type_t v96 = v253;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253)) {
                goto LABEL_343;
              }
              uint64_t v147 = *(void *)(a1 + 104);
              int v98 = (const char *)(v147 + 390);
              BOOL v148 = v147 == 0;
              if (!v147) {
                int v98 = "";
              }
              int v100 = *(_DWORD *)(v147 + 368);
              if (v148) {
                int v101 = "";
              }
              else {
                int v101 = " ";
              }
LABEL_219:
              *(_DWORD *)int buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              id v258 = v98;
              __int16 v259 = 2080;
              size_t v260 = (size_t)v101;
              __int16 v261 = 1024;
              *(_DWORD *)nw_endpoint_t v262 = v100;
              os_log_type_t v102 = "%{public}s %{public}s%s<i%u> unexpected NULL in source frame";
LABEL_342:
              _os_log_impl(&dword_1830D4000, v95, v96, v102, buf, 0x26u);
LABEL_343:
              if (v94) {
                free(v94);
              }
              return 0;
            }
            if (v251)
            {
              BOOL v111 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              BOOL v95 = gconnectionLogObj;
              os_log_type_t v96 = v253;
              BOOL v157 = os_log_type_enabled((os_log_t)gconnectionLogObj, v253);
              if (v111)
              {
                if (v157)
                {
                  uint64_t v113 = *(void *)(a1 + 104);
                  uint64_t v114 = (const char *)(v113 + 390);
                  if (v113)
                  {
                    BOOL v115 = " ";
                  }
                  else
                  {
                    uint64_t v114 = "";
                    BOOL v115 = "";
                  }
                  goto LABEL_325;
                }
LABEL_326:
                free(v111);
                goto LABEL_343;
              }
              if (!v157) {
                goto LABEL_343;
              }
              uint64_t v161 = *(void *)(a1 + 104);
              int v122 = (const char *)(v161 + 390);
              BOOL v162 = v161 == 0;
              if (!v161) {
                int v122 = "";
              }
              int v124 = *(_DWORD *)(v161 + 368);
              if (v162) {
                uint64_t v125 = "";
              }
              else {
                uint64_t v125 = " ";
              }
LABEL_341:
              *(_DWORD *)int buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              id v258 = v122;
              __int16 v259 = 2080;
              size_t v260 = (size_t)v125;
              __int16 v261 = 1024;
              *(_DWORD *)nw_endpoint_t v262 = v124;
              os_log_type_t v102 = "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, no backtrace";
              goto LABEL_342;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v95 = gconnectionLogObj;
            os_log_type_t v96 = v253;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253)) {
              goto LABEL_343;
            }
            uint64_t v159 = *(void *)(a1 + 104);
            uint64_t v117 = (const char *)(v159 + 390);
            BOOL v160 = v159 == 0;
            if (!v159) {
              uint64_t v117 = "";
            }
            int v119 = *(_DWORD *)(v159 + 368);
            if (v160) {
              int v120 = "";
            }
            else {
              int v120 = " ";
            }
LABEL_245:
            *(_DWORD *)int buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = v117;
            __int16 v259 = 2080;
            size_t v260 = (size_t)v120;
            __int16 v261 = 1024;
            *(_DWORD *)nw_endpoint_t v262 = v119;
            os_log_type_t v102 = "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, backtrace limit exceeded";
            goto LABEL_342;
          }
          return 0;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        __int16 v257 = 2082;
        id v258 = "bodyCopySize";
        __int16 v259 = 2048;
        size_t v260 = v69;
        __int16 v261 = 2048;
        *(void *)nw_endpoint_t v262 = v70;
        os_log_t v71 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v71, type, &v253))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            uint64_t v72 = __nwlog_obj();
            os_log_type_t v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              *(_DWORD *)int buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              id v258 = "bodyCopySize";
              __int16 v259 = 2048;
              size_t v260 = v69;
              __int16 v261 = 2048;
              *(void *)nw_endpoint_t v262 = v70;
              int v74 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_259:
              _os_log_impl(&dword_1830D4000, v72, v73, v74, buf, 0x2Au);
            }
          }
          else if (v253)
          {
            int v75 = (char *)__nw_create_backtrace_string();
            uint64_t v72 = __nwlog_obj();
            os_log_type_t v73 = type[0];
            BOOL v76 = os_log_type_enabled(v72, type[0]);
            if (v75)
            {
              if (v76)
              {
                *(_DWORD *)int buf = 136447234;
                v256 = "send_data_callback_block_invoke";
                __int16 v257 = 2082;
                id v258 = "bodyCopySize";
                __int16 v259 = 2048;
                size_t v260 = v69;
                __int16 v261 = 2048;
                *(void *)nw_endpoint_t v262 = v70;
                *(_WORD *)&v262[8] = 2082;
                *(void *)&v262[10] = v75;
                _os_log_impl(&dword_1830D4000, v72, v73, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v75);
              goto LABEL_260;
            }
            if (v76)
            {
              *(_DWORD *)int buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              id v258 = "bodyCopySize";
              __int16 v259 = 2048;
              size_t v260 = v69;
              __int16 v261 = 2048;
              *(void *)nw_endpoint_t v262 = v70;
              int v74 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
              goto LABEL_259;
            }
          }
          else
          {
            uint64_t v72 = __nwlog_obj();
            os_log_type_t v73 = type[0];
            if (os_log_type_enabled(v72, type[0]))
            {
              *(_DWORD *)int buf = 136446978;
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              id v258 = "bodyCopySize";
              __int16 v259 = 2048;
              size_t v260 = v69;
              __int16 v261 = 2048;
              *(void *)nw_endpoint_t v262 = v70;
              int v74 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
              goto LABEL_259;
            }
          }
        }
LABEL_260:
        if (v71) {
          free(v71);
        }
        LODWORD(v21) = 0;
        goto LABEL_263;
      }
      __nwlog_obj();
      *(_DWORD *)int buf = 136446978;
      v256 = "send_data_callback_block_invoke";
      __int16 v257 = 2082;
      id v258 = "bodyCopySize";
      __int16 v259 = 2048;
      size_t v260 = v47;
      __int16 v261 = 2048;
      *(void *)nw_endpoint_t v262 = v48;
      int v49 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v49, type, &v253))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          unsigned int v50 = __nwlog_obj();
          os_log_type_t v51 = type[0];
          if (os_log_type_enabled(v50, type[0]))
          {
            *(_DWORD *)int buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v47;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v48;
            __int16 v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_142:
            _os_log_impl(&dword_1830D4000, v50, v51, v52, buf, 0x2Au);
          }
        }
        else if (v253)
        {
          uint64_t v53 = (char *)__nw_create_backtrace_string();
          unsigned int v50 = __nwlog_obj();
          os_log_type_t v51 = type[0];
          BOOL v54 = os_log_type_enabled(v50, type[0]);
          if (v53)
          {
            if (v54)
            {
              *(_DWORD *)int buf = 136447234;
              v256 = "send_data_callback_block_invoke";
              __int16 v257 = 2082;
              id v258 = "bodyCopySize";
              __int16 v259 = 2048;
              size_t v260 = v47;
              __int16 v261 = 2048;
              *(void *)nw_endpoint_t v262 = v48;
              *(_WORD *)&v262[8] = 2082;
              *(void *)&v262[10] = v53;
              _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(v53);
            goto LABEL_143;
          }
          if (v54)
          {
            *(_DWORD *)int buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v47;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v48;
            __int16 v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_142;
          }
        }
        else
        {
          unsigned int v50 = __nwlog_obj();
          os_log_type_t v51 = type[0];
          if (os_log_type_enabled(v50, type[0]))
          {
            *(_DWORD *)int buf = 136446978;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v47;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v48;
            __int16 v52 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_142;
          }
        }
      }
LABEL_143:
      if (v49) {
        free(v49);
      }
      LODWORD(v21) = 0;
      goto LABEL_146;
    }
    memcpy(&v6[v8], (const void *)(a1 + v22 + 136), v24);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v24;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v24;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += v24;
    BOOL v16 = v21 >= v24;
    uint64_t v21 = (v21 - v24);
    if (v16)
    {
LABEL_95:
      LODWORD(v8) = v24 + v8;
      uint64_t v44 = *(void *)(a1 + 104);
      if ((!v44 || (*(__int16 *)(v44 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v203 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v204 = *(void *)(a1 + 104);
          uint64_t v205 = "";
          BOOL v206 = v204 == 0;
          int v207 = *(_DWORD *)(v204 + 368);
          uint64_t v208 = (const char *)(v204 + 390);
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          if (v206) {
            uint64_t v208 = "";
          }
          *(_DWORD *)int buf = 136447234;
          if (!v206) {
            uint64_t v205 = " ";
          }
          id v258 = v208;
          __int16 v259 = 2080;
          size_t v260 = (size_t)v205;
          __int16 v261 = 1024;
          *(_DWORD *)nw_endpoint_t v262 = v207;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v24;
          _os_log_impl(&dword_1830D4000, v203, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule type", buf, 0x2Cu);
        }
      }
      if (v254 <= v8) {
        goto LABEL_278;
      }
      goto LABEL_99;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    __int16 v257 = 2082;
    id v258 = "bodyCopySize";
    __int16 v259 = 2048;
    size_t v260 = v24;
    __int16 v261 = 2048;
    *(void *)nw_endpoint_t v262 = v21;
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v25, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v24;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v21;
          int v28 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_91:
          _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        uint64_t v31 = (char *)__nw_create_backtrace_string();
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v27 = type[0];
        BOOL v32 = os_log_type_enabled(v26, type[0]);
        if (v31)
        {
          if (v32)
          {
            *(_DWORD *)int buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v24;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v21;
            *(_WORD *)&v262[8] = 2082;
            *(void *)&v262[10] = v31;
            _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v31);
          goto LABEL_92;
        }
        if (v32)
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v24;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v21;
          int v28 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_91;
        }
      }
      else
      {
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v24;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v21;
          int v28 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_91;
        }
      }
    }
LABEL_92:
    if (v25) {
      free(v25);
    }
    LODWORD(v21) = 0;
    goto LABEL_95;
  }
  if (v7 <= 9)
  {
    if (v254 <= v8) {
      goto LABEL_278;
    }
    v6[v8] = v10 - 1;
    uint64_t v11 = *(void *)(a1 + 104);
    if ((!v11 || (*(__int16 *)(v11 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v179 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v180 = *(void *)(a1 + 104);
        uint64_t v181 = (const char *)(v180 + 390);
        uint64_t v182 = "";
        BOOL v183 = v180 == 0;
        int v184 = *(_DWORD *)(v180 + 368);
        v256 = "send_data_callback_block_invoke";
        if (v183) {
          uint64_t v181 = "";
        }
        __int16 v257 = 2082;
        *(_DWORD *)int buf = 136447234;
        if (!v183) {
          uint64_t v182 = " ";
        }
        id v258 = v181;
        __int16 v259 = 2080;
        size_t v260 = (size_t)v182;
        __int16 v261 = 1024;
        *(_DWORD *)nw_endpoint_t v262 = v184;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = 1;
        _os_log_impl(&dword_1830D4000, v179, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u byte of padding length", buf, 0x2Cu);
      }
    }
    LODWORD(v8) = v8 + 1;
    LODWORD(v7) = ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
    unint64_t v10 = *(void *)(*(void *)(a1 + 112) + 16);
  }
  if (v7 >= *(_DWORD *)(a1 + 200) + ~v10) {
    goto LABEL_191;
  }
  if (v254 <= v8) {
    goto LABEL_278;
  }
  if (*(_DWORD *)(a1 + 120) - *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) >= v254 - v8) {
    LODWORD(v12) = v254 - v8;
  }
  else {
    LODWORD(v12) = *(_DWORD *)(a1 + 120) - *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  }
  if (!*(void *)(a1 + 128))
  {
LABEL_181:
    *(_DWORD *)os_log_type_t type = 0;
    int v79 = (const void *)nw_frame_unclaimed_bytes(*(void *)(a1 + 176), type);
    if (v79)
    {
      if (v12 >= *(_DWORD *)type) {
        size_t v80 = *(unsigned int *)type;
      }
      else {
        size_t v80 = v12;
      }
      memcpy(&v6[v8], v79, v80);
      uint64_t v82 = *(void *)(a1 + 104);
      if ((!v82 || (*(__int16 *)(v82 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v197 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v198 = *(void *)(a1 + 104);
          os_log_type_t v199 = "";
          BOOL v200 = v198 == 0;
          int v201 = *(_DWORD *)(v198 + 368);
          char v202 = (const char *)(v198 + 390);
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          if (v200) {
            char v202 = "";
          }
          *(_DWORD *)int buf = 136447234;
          if (!v200) {
            os_log_type_t v199 = " ";
          }
          id v258 = v202;
          __int16 v259 = 2080;
          size_t v260 = (size_t)v199;
          __int16 v261 = 1024;
          *(_DWORD *)nw_endpoint_t v262 = v201;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v80;
          _os_log_impl(&dword_1830D4000, v197, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of body data (padding)", buf, 0x2Cu);
        }
      }
      nw_frame_claim(*(void *)(a1 + 176), v81, v80, 0);
      LODWORD(v8) = v80 + v8;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v80;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v80;
      goto LABEL_190;
    }
    if (*(void *)(a1 + 128))
    {
LABEL_190:
      unint64_t v10 = *(void *)(*(void *)(a1 + 112) + 16);
LABEL_191:
      if (v10 < 2) {
        goto LABEL_278;
      }
      unsigned int v83 = v254 - v8;
      if (v254 <= v8) {
        goto LABEL_278;
      }
      unsigned int v84 = ~*(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) + v10;
      if (v84 >= v83) {
        size_t v85 = v83;
      }
      else {
        size_t v85 = v84;
      }
      bzero(&v6[v8], v85);
      uint64_t v86 = *(void *)(a1 + 104);
      if ((!v86 || (*(__int16 *)(v86 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        unint64_t v185 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v186 = *(void *)(a1 + 104);
          uint64_t v187 = "";
          BOOL v188 = v186 == 0;
          int v189 = *(_DWORD *)(v186 + 368);
          os_log_type_t v190 = (const char *)(v186 + 390);
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          if (v188) {
            os_log_type_t v190 = "";
          }
          *(_DWORD *)int buf = 136447234;
          if (!v188) {
            uint64_t v187 = " ";
          }
          id v258 = v190;
          __int16 v259 = 2080;
          size_t v260 = (size_t)v187;
          __int16 v261 = 1024;
          *(_DWORD *)nw_endpoint_t v262 = v189;
          *(_WORD *)&v262[4] = 1024;
          *(_DWORD *)&v262[6] = v85;
          _os_log_impl(&dword_1830D4000, v185, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of padding", buf, 0x2Cu);
        }
      }
      LODWORD(v8) = v85 + v8;
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v85;
      uint64_t v87 = *(void *)(a1 + 80);
      goto LABEL_277;
    }
    uint64_t v88 = *(void *)(a1 + 104);
    if (!v88 || (*(__int16 *)(v88 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v89 = *(void *)(a1 + 104);
      BOOL v90 = (const char *)(v89 + 390);
      BOOL v91 = v89 == 0;
      int v92 = *(_DWORD *)(v89 + 368);
      *(_DWORD *)int buf = 136446978;
      if (v91) {
        BOOL v90 = "";
      }
      v256 = "send_data_callback_block_invoke";
      if (v91) {
        int v93 = "";
      }
      else {
        int v93 = " ";
      }
      __int16 v257 = 2082;
      id v258 = v90;
      __int16 v259 = 2080;
      size_t v260 = (size_t)v93;
      __int16 v261 = 1024;
      *(_DWORD *)nw_endpoint_t v262 = v92;
      BOOL v94 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v253 = OS_LOG_TYPE_ERROR;
      char v251 = 0;
      if (!__nwlog_fault(v94, &v253, &v251)) {
        goto LABEL_343;
      }
      if (v253 == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v95 = gconnectionLogObj;
        os_log_type_t v96 = v253;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253)) {
          goto LABEL_343;
        }
        uint64_t v97 = *(void *)(a1 + 104);
        int v98 = (const char *)(v97 + 390);
        BOOL v99 = v97 == 0;
        if (!v97) {
          int v98 = "";
        }
        int v100 = *(_DWORD *)(v97 + 368);
        if (v99) {
          int v101 = "";
        }
        else {
          int v101 = " ";
        }
        goto LABEL_219;
      }
      if (v251)
      {
        BOOL v111 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v95 = gconnectionLogObj;
        os_log_type_t v96 = v253;
        BOOL v112 = os_log_type_enabled((os_log_t)gconnectionLogObj, v253);
        if (v111)
        {
          if (v112)
          {
            uint64_t v113 = *(void *)(a1 + 104);
            uint64_t v114 = (const char *)(v113 + 390);
            if (v113)
            {
              BOOL v115 = " ";
            }
            else
            {
              uint64_t v114 = "";
              BOOL v115 = "";
            }
LABEL_325:
            int v158 = *(_DWORD *)(v113 + 368);
            *(_DWORD *)int buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = v114;
            __int16 v259 = 2080;
            size_t v260 = (size_t)v115;
            __int16 v261 = 1024;
            *(_DWORD *)nw_endpoint_t v262 = v158;
            *(_WORD *)&v262[4] = 2082;
            *(void *)&v262[6] = v111;
            _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s %{public}s%s<i%u> unexpected NULL in source frame, dumping backtrace:%{public}s", buf, 0x30u);
            goto LABEL_326;
          }
          goto LABEL_326;
        }
        if (!v112) {
          goto LABEL_343;
        }
        uint64_t v121 = *(void *)(a1 + 104);
        int v122 = (const char *)(v121 + 390);
        BOOL v123 = v121 == 0;
        if (!v121) {
          int v122 = "";
        }
        int v124 = *(_DWORD *)(v121 + 368);
        if (v123) {
          uint64_t v125 = "";
        }
        else {
          uint64_t v125 = " ";
        }
        goto LABEL_341;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v95 = gconnectionLogObj;
      os_log_type_t v96 = v253;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v253)) {
        goto LABEL_343;
      }
      uint64_t v116 = *(void *)(a1 + 104);
      uint64_t v117 = (const char *)(v116 + 390);
      BOOL v118 = v116 == 0;
      if (!v116) {
        uint64_t v117 = "";
      }
      int v119 = *(_DWORD *)(v116 + 368);
      if (v118) {
        int v120 = "";
      }
      else {
        int v120 = " ";
      }
      goto LABEL_245;
    }
    return 0;
  }
  uint64_t v13 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 48) + 8) + 24);
  unsigned int v14 = *(unsigned __int8 *)(a1 + 204) - v13;
  if (v14 >= v12) {
    size_t v15 = v12;
  }
  else {
    size_t v15 = v14;
  }
  if (!v15) {
    goto LABEL_73;
  }
  memcpy(&v6[v8], (const void *)(a1 + v13 + 136), v15);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v15;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v15;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) += v15;
  BOOL v16 = v12 >= v15;
  uint64_t v12 = (v12 - v15);
  if (!v16)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    __int16 v257 = 2082;
    id v258 = "bodyCopySize";
    __int16 v259 = 2048;
    size_t v260 = v15;
    __int16 v261 = 2048;
    *(void *)nw_endpoint_t v262 = v12;
    __int16 v17 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v17, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v18 = __nwlog_obj();
        os_log_type_t v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v15;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v12;
          int v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_65:
          _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        int v29 = (char *)__nw_create_backtrace_string();
        os_log_type_t v18 = __nwlog_obj();
        os_log_type_t v19 = type[0];
        BOOL v30 = os_log_type_enabled(v18, type[0]);
        if (v29)
        {
          if (v30)
          {
            *(_DWORD *)int buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v15;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v12;
            *(_WORD *)&v262[8] = 2082;
            *(void *)&v262[10] = v29;
            _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v29);
          goto LABEL_66;
        }
        if (v30)
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v15;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v12;
          int v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_65;
        }
      }
      else
      {
        os_log_type_t v18 = __nwlog_obj();
        os_log_type_t v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v15;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v12;
          int v20 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_65;
        }
      }
    }
LABEL_66:
    if (v17) {
      free(v17);
    }
    LODWORD(v12) = 0;
  }
  LODWORD(v8) = v15 + v8;
  uint64_t v33 = *(void *)(a1 + 104);
  if ((!v33 || (*(__int16 *)(v33 + 388) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v191 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v192 = *(void *)(a1 + 104);
      unsigned int v193 = "";
      BOOL v194 = v192 == 0;
      int v195 = *(_DWORD *)(v192 + 368);
      BOOL v196 = (const char *)(v192 + 390);
      v256 = "send_data_callback_block_invoke";
      __int16 v257 = 2082;
      if (v194) {
        BOOL v196 = "";
      }
      *(_DWORD *)int buf = 136447234;
      if (!v194) {
        unsigned int v193 = " ";
      }
      id v258 = v196;
      __int16 v259 = 2080;
      size_t v260 = (size_t)v193;
      __int16 v261 = 1024;
      *(_DWORD *)nw_endpoint_t v262 = v195;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v15;
      _os_log_impl(&dword_1830D4000, v191, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule type", buf, 0x2Cu);
    }
  }
  if (v254 <= v8) {
    goto LABEL_278;
  }
LABEL_73:
  uint64_t v34 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 56) + 8) + 24);
  unsigned int v35 = *(unsigned __int8 *)(a1 + 205) - v34;
  if (v35 >= v12) {
    size_t v36 = v12;
  }
  else {
    size_t v36 = v35;
  }
  if (!v36) {
    goto LABEL_125;
  }
  memcpy(&v6[v8], (const void *)(a1 + v34 + 144), v36);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v36;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v36;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v36;
  BOOL v16 = v12 >= v36;
  uint64_t v37 = (v12 - v36);
  LODWORD(v12) = v12 - v36;
  if (!v16)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    __int16 v257 = 2082;
    id v258 = "bodyCopySize";
    __int16 v259 = 2048;
    size_t v260 = v36;
    __int16 v261 = 2048;
    *(void *)nw_endpoint_t v262 = v37;
    int v38 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v38, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v39 = __nwlog_obj();
        os_log_type_t v40 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v36;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v37;
          uint64_t v41 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_117:
          _os_log_impl(&dword_1830D4000, v39, v40, v41, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        int v42 = (char *)__nw_create_backtrace_string();
        uint64_t v39 = __nwlog_obj();
        os_log_type_t v40 = type[0];
        BOOL v43 = os_log_type_enabled(v39, type[0]);
        if (v42)
        {
          if (v43)
          {
            *(_DWORD *)int buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v36;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v37;
            *(_WORD *)&v262[8] = 2082;
            *(void *)&v262[10] = v42;
            _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v42);
          goto LABEL_118;
        }
        if (v43)
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v36;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v37;
          uint64_t v41 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_117;
        }
      }
      else
      {
        uint64_t v39 = __nwlog_obj();
        os_log_type_t v40 = type[0];
        if (os_log_type_enabled(v39, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v36;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v37;
          uint64_t v41 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_117;
        }
      }
    }
LABEL_118:
    if (v38) {
      free(v38);
    }
    LODWORD(v12) = 0;
  }
  LODWORD(v8) = v36 + v8;
  uint64_t v55 = *(void *)(a1 + 104);
  if ((!v55 || (*(__int16 *)(v55 + 388) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v215 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v216 = *(void *)(a1 + 104);
      uint64_t v217 = "";
      BOOL v218 = v216 == 0;
      int v219 = *(_DWORD *)(v216 + 368);
      os_log_type_t v220 = (const char *)(v216 + 390);
      v256 = "send_data_callback_block_invoke";
      __int16 v257 = 2082;
      if (v218) {
        os_log_type_t v220 = "";
      }
      *(_DWORD *)int buf = 136447234;
      if (!v218) {
        uint64_t v217 = " ";
      }
      id v258 = v220;
      __int16 v259 = 2080;
      size_t v260 = (size_t)v217;
      __int16 v261 = 1024;
      *(_DWORD *)nw_endpoint_t v262 = v219;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v36;
      _os_log_impl(&dword_1830D4000, v215, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule length", buf, 0x2Cu);
    }
  }
  if (v254 <= v8) {
    goto LABEL_278;
  }
LABEL_125:
  if (!*(unsigned char *)(a1 + 206)) {
    goto LABEL_179;
  }
  uint64_t v56 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  unsigned int v57 = *(unsigned __int8 *)(a1 + 207) - v56;
  size_t v58 = v57 >= v12 ? v12 : v57;
  if (!v58) {
    goto LABEL_179;
  }
  memcpy(&v6[v8], (const void *)(a1 + v56 + 152), v58);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v58;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v58;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 56) + 8) + 24) += v58;
  BOOL v16 = v12 >= v58;
  uint64_t v59 = (v12 - v58);
  LODWORD(v12) = v12 - v58;
  if (v16) {
    goto LABEL_175;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446978;
  v256 = "send_data_callback_block_invoke";
  __int16 v257 = 2082;
  id v258 = "bodyCopySize";
  __int16 v259 = 2048;
  size_t v260 = v58;
  __int16 v261 = 2048;
  *(void *)nw_endpoint_t v262 = v59;
  int v60 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v60, type, &v253))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unint64_t v61 = __nwlog_obj();
      os_log_type_t v62 = type[0];
      if (os_log_type_enabled(v61, type[0]))
      {
        *(_DWORD *)int buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        __int16 v257 = 2082;
        id v258 = "bodyCopySize";
        __int16 v259 = 2048;
        size_t v260 = v58;
        __int16 v261 = 2048;
        *(void *)nw_endpoint_t v262 = v59;
        size_t v63 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_171:
        _os_log_impl(&dword_1830D4000, v61, v62, v63, buf, 0x2Au);
      }
    }
    else if (v253)
    {
      uint64_t v64 = (char *)__nw_create_backtrace_string();
      unint64_t v61 = __nwlog_obj();
      os_log_type_t v62 = type[0];
      BOOL v65 = os_log_type_enabled(v61, type[0]);
      if (v64)
      {
        if (v65)
        {
          *(_DWORD *)int buf = 136447234;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v58;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v59;
          *(_WORD *)&v262[8] = 2082;
          *(void *)&v262[10] = v64;
          _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
        }
        free(v64);
        goto LABEL_172;
      }
      if (v65)
      {
        *(_DWORD *)int buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        __int16 v257 = 2082;
        id v258 = "bodyCopySize";
        __int16 v259 = 2048;
        size_t v260 = v58;
        __int16 v261 = 2048;
        *(void *)nw_endpoint_t v262 = v59;
        size_t v63 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
        goto LABEL_171;
      }
    }
    else
    {
      unint64_t v61 = __nwlog_obj();
      os_log_type_t v62 = type[0];
      if (os_log_type_enabled(v61, type[0]))
      {
        *(_DWORD *)int buf = 136446978;
        v256 = "send_data_callback_block_invoke";
        __int16 v257 = 2082;
        id v258 = "bodyCopySize";
        __int16 v259 = 2048;
        size_t v260 = v58;
        __int16 v261 = 2048;
        *(void *)nw_endpoint_t v262 = v59;
        size_t v63 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
        goto LABEL_171;
      }
    }
  }
LABEL_172:
  if (v60) {
    free(v60);
  }
  LODWORD(v12) = 0;
LABEL_175:
  LODWORD(v8) = v58 + v8;
  uint64_t v77 = *(void *)(a1 + 104);
  if ((!v77 || (*(__int16 *)(v77 + 388) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v227 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v228 = *(void *)(a1 + 104);
      __int16 v229 = "";
      BOOL v230 = v228 == 0;
      int v231 = *(_DWORD *)(v228 + 368);
      int v232 = (const char *)(v228 + 390);
      v256 = "send_data_callback_block_invoke";
      __int16 v257 = 2082;
      if (v230) {
        int v232 = "";
      }
      *(_DWORD *)int buf = 136447234;
      if (!v230) {
        __int16 v229 = " ";
      }
      id v258 = v232;
      __int16 v259 = 2080;
      size_t v260 = (size_t)v229;
      __int16 v261 = 1024;
      *(_DWORD *)nw_endpoint_t v262 = v231;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v58;
      _os_log_impl(&dword_1830D4000, v227, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of datagram context", buf, 0x2Cu);
    }
  }
  if (v254 > v8)
  {
LABEL_179:
    uint32_t v78 = *(NSObject **)(a1 + 160);
    if (!v78 || *(unsigned char *)(a1 + 208)) {
      goto LABEL_181;
    }
    uint64_t v103 = *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
    unsigned int v104 = *(_DWORD *)(a1 + 168) - v103;
    uint64_t v105 = v104 >= v12 ? v12 : v104;
    if (!v105) {
      goto LABEL_181;
    }
    nw_dispatch_data_copyout_from_offset(v78, (uint64_t)&v6[v8], v105, v103);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v105;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v105;
    *(void *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) += v105;
    BOOL v16 = v12 >= v105;
    uint64_t v106 = (v12 - v105);
    LODWORD(v12) = v12 - v105;
    if (v16) {
      goto LABEL_369;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446978;
    v256 = "send_data_callback_block_invoke";
    __int16 v257 = 2082;
    id v258 = "bodyCopySize";
    __int16 v259 = 2048;
    size_t v260 = v105;
    __int16 v261 = 2048;
    *(void *)nw_endpoint_t v262 = v106;
    os_log_type_t v107 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v253 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v107, type, &v253))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        int v108 = __nwlog_obj();
        os_log_type_t v109 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v105;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v106;
          int v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_365:
          _os_log_impl(&dword_1830D4000, v108, v109, v110, buf, 0x2Au);
        }
      }
      else if (v253)
      {
        int v126 = (char *)__nw_create_backtrace_string();
        int v108 = __nwlog_obj();
        os_log_type_t v109 = type[0];
        BOOL v127 = os_log_type_enabled(v108, type[0]);
        if (v126)
        {
          if (v127)
          {
            *(_DWORD *)int buf = 136447234;
            v256 = "send_data_callback_block_invoke";
            __int16 v257 = 2082;
            id v258 = "bodyCopySize";
            __int16 v259 = 2048;
            size_t v260 = v105;
            __int16 v261 = 2048;
            *(void *)nw_endpoint_t v262 = v106;
            *(_WORD *)&v262[8] = 2082;
            *(void *)&v262[10] = v126;
            _os_log_impl(&dword_1830D4000, v108, v109, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v126);
          goto LABEL_366;
        }
        if (v127)
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v105;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v106;
          int v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_365;
        }
      }
      else
      {
        int v108 = __nwlog_obj();
        os_log_type_t v109 = type[0];
        if (os_log_type_enabled(v108, type[0]))
        {
          *(_DWORD *)int buf = 136446978;
          v256 = "send_data_callback_block_invoke";
          __int16 v257 = 2082;
          id v258 = "bodyCopySize";
          __int16 v259 = 2048;
          size_t v260 = v105;
          __int16 v261 = 2048;
          *(void *)nw_endpoint_t v262 = v106;
          int v110 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_365;
        }
      }
    }
LABEL_366:
    if (v107) {
      free(v107);
    }
    LODWORD(v12) = 0;
LABEL_369:
    LODWORD(v8) = v105 + v8;
    uint64_t v171 = *(void *)(a1 + 104);
    if ((!v171 || (*(__int16 *)(v171 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v239 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v240 = *(void *)(a1 + 104);
        os_log_type_t v241 = "";
        BOOL v242 = v240 == 0;
        int v243 = *(_DWORD *)(v240 + 368);
        v244 = (const char *)(v240 + 390);
        v256 = "send_data_callback_block_invoke";
        __int16 v257 = 2082;
        if (v242) {
          v244 = "";
        }
        *(_DWORD *)int buf = 136447234;
        if (!v242) {
          os_log_type_t v241 = " ";
        }
        id v258 = v244;
        __int16 v259 = 2080;
        size_t v260 = (size_t)v241;
        __int16 v261 = 1024;
        *(_DWORD *)nw_endpoint_t v262 = v243;
        *(_WORD *)&v262[4] = 1024;
        *(_DWORD *)&v262[6] = v105;
        _os_log_impl(&dword_1830D4000, v239, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> wrote %u bytes of capsule body", buf, 0x2Cu);
      }
    }
    if (v254 <= v8) {
      goto LABEL_278;
    }
    goto LABEL_181;
  }
LABEL_278:
  nw_frame_claim(a2, v5, v8, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v133, v8, 0);
  uint64_t v135 = *(void *)(a2 + 32);
  int v136 = *(void **)(a2 + 40);
  int v134 = (void *)(a2 + 32);
  if (v135)
  {
    *(void *)(v135 + 40) = v136;
    int v136 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 184) + 8) = v136;
  }
  void *v136 = v135;
  void *v134 = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v137 = *(void *)(a1 + 192);
  uint64_t v138 = *(uint64_t **)(v137 + 8);
  *(void *)(a2 + 40) = v138;
  *uint64_t v138 = a2;
  *(void *)(v137 + 8) = v134;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 88) + 8) + 24);
  uint64_t v139 = *(void *)(a1 + 104);
  if (!v139)
  {
    if (!gLogDatapath) {
      return 1;
    }
LABEL_351:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v165 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v166 = *(void *)(a1 + 104);
      char v167 = "";
      BOOL v168 = v166 == 0;
      int v169 = *(_DWORD *)(v166 + 368);
      id v170 = (const char *)(v166 + 390);
      v256 = "send_data_callback_block_invoke";
      __int16 v257 = 2082;
      if (v168) {
        id v170 = "";
      }
      *(_DWORD *)int buf = 136447234;
      if (!v168) {
        char v167 = " ";
      }
      id v258 = v170;
      __int16 v259 = 2080;
      size_t v260 = (size_t)v167;
      __int16 v261 = 1024;
      *(_DWORD *)nw_endpoint_t v262 = v169;
      *(_WORD *)&v262[4] = 1024;
      *(_DWORD *)&v262[6] = v8;
      _os_log_impl(&dword_1830D4000, v165, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> copied %u bytes into output frame", buf, 0x2Cu);
    }
    return 1;
  }
  uint64_t result = 1;
  if ((*(__int16 *)(v139 + 388) & 0x80000000) == 0 && gLogDatapath) {
    goto LABEL_351;
  }
  return result;
}

void http2_output_frame_metadata_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v26 = "__nw_frame_get_metadata";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v17, &type, &v23)) {
      goto LABEL_50;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v26 = "__nw_frame_get_metadata";
      int v20 = "%{public}s called with null frame";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v26 = "__nw_frame_get_metadata";
          __int16 v27 = 2082;
          int v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_50;
      }
      if (!v22)
      {
LABEL_50:
        if (v17) {
          free(v17);
        }
        goto LABEL_3;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v26 = "__nw_frame_get_metadata";
      int v20 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      os_log_type_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_50;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v26 = "__nw_frame_get_metadata";
      int v20 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0xCu);
    goto LABEL_50;
  }
  if ((*(_WORD *)(a1 + 204) & 4) != 0)
  {
    *(void *)(a1 + 208) = a2;
    *(void *)(a1 + 216) = a3;
    return;
  }
LABEL_3:
  if (a2)
  {
    if (*(__int16 *)(a2 + 388) < 0) {
      return;
    }
    uint64_t v4 = " ";
  }
  else
  {
    uint64_t v4 = "";
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  if (a2) {
    uint64_t v5 = (const char *)(a2 + 390);
  }
  else {
    uint64_t v5 = "";
  }
  int v6 = *(_DWORD *)(a2 + 368);
  *(_DWORD *)int buf = 136446978;
  uint64_t v26 = "http2_output_frame_metadata_reset";
  __int16 v27 = 2082;
  int v28 = (void *)v5;
  __int16 v29 = 2080;
  BOOL v30 = v4;
  __int16 v31 = 1024;
  int v32 = v6;
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v7, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      size_t v8 = gconnectionLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_33;
      }
      int v10 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)int buf = 136446978;
      uint64_t v26 = "http2_output_frame_metadata_reset";
      __int16 v27 = 2082;
      int v28 = (void *)v5;
      __int16 v29 = 2080;
      BOOL v30 = v4;
      __int16 v31 = 1024;
      int v32 = v10;
      uint64_t v11 = "%{public}s %{public}s%s<i%u> frame has no metadata";
      goto LABEL_32;
    }
    if (!v23)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      size_t v8 = gconnectionLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_33;
      }
      int v15 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)int buf = 136446978;
      uint64_t v26 = "http2_output_frame_metadata_reset";
      __int16 v27 = 2082;
      int v28 = (void *)v5;
      __int16 v29 = 2080;
      BOOL v30 = v4;
      __int16 v31 = 1024;
      int v32 = v15;
      uint64_t v11 = "%{public}s %{public}s%s<i%u> frame has no metadata, backtrace limit exceeded";
      goto LABEL_32;
    }
    uint64_t v12 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    size_t v8 = gconnectionLogObj;
    os_log_type_t v9 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (v12)
    {
      if (v13)
      {
        int v14 = *(_DWORD *)(a2 + 368);
        *(_DWORD *)int buf = 136447234;
        uint64_t v26 = "http2_output_frame_metadata_reset";
        __int16 v27 = 2082;
        int v28 = (void *)v5;
        __int16 v29 = 2080;
        BOOL v30 = v4;
        __int16 v31 = 1024;
        int v32 = v14;
        __int16 v33 = 2082;
        uint64_t v34 = v12;
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s %{public}s%s<i%u> frame has no metadata, dumping backtrace:%{public}s", buf, 0x30u);
      }
      free(v12);
      goto LABEL_33;
    }
    if (v13)
    {
      int v16 = *(_DWORD *)(a2 + 368);
      *(_DWORD *)int buf = 136446978;
      uint64_t v26 = "http2_output_frame_metadata_reset";
      __int16 v27 = 2082;
      int v28 = (void *)v5;
      __int16 v29 = 2080;
      BOOL v30 = v4;
      __int16 v31 = 1024;
      int v32 = v16;
      uint64_t v11 = "%{public}s %{public}s%s<i%u> frame has no metadata, no backtrace";
LABEL_32:
      _os_log_impl(&dword_1830D4000, v8, v9, v11, buf, 0x26u);
    }
  }
LABEL_33:
  if (v7) {
    free(v7);
  }
}

uint64_t send_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5)
{
  uint64_t v95 = *MEMORY[0x1E4F143B8];
  if (!a5)
  {
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "send_callback";
    uint64_t v39 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v79) = 0;
    if (!__nwlog_fault(v39, type, &v79)) {
      goto LABEL_114;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v41 = type[0];
      if (!os_log_type_enabled(v40, type[0])) {
        goto LABEL_114;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "send_callback";
      int v42 = "%{public}s nghttp2 user data is NULL, not http2";
    }
    else if ((_BYTE)v79)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v41 = type[0];
      BOOL v49 = os_log_type_enabled(v40, type[0]);
      if (backtrace_string)
      {
        if (v49)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "send_callback";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(backtrace_string);
LABEL_114:
        if (v39)
        {
          unsigned int v57 = (char *)v39;
          goto LABEL_116;
        }
        return -902;
      }
      if (!v49) {
        goto LABEL_114;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "send_callback";
      int v42 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }
    else
    {
      os_log_type_t v40 = __nwlog_obj();
      os_log_type_t v41 = type[0];
      if (!os_log_type_enabled(v40, type[0])) {
        goto LABEL_114;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "send_callback";
      int v42 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v40, v41, v42, (uint8_t *)buf, 0xCu);
    goto LABEL_114;
  }
  if ((*(__int16 *)(a5 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v43 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v44 = *(_DWORD *)(a5 + 368);
      LODWORD(buf[0]) = 136446978;
      *(void *)((char *)buf + 4) = "send_callback";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = a5 + 390;
      HIWORD(buf[2]) = 2080;
      BOOL v90 = " ";
      LOWORD(v91) = 1024;
      *(_DWORD *)((char *)&v91 + 2) = v44;
      _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", (uint8_t *)buf, 0x26u);
    }
    if ((*(__int16 *)(a5 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v45 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v46 = *(_DWORD *)(a5 + 368);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a5 + 390;
        HIWORD(buf[2]) = 2080;
        BOOL v90 = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v46;
        HIWORD(v91) = 2048;
        v92[0] = a3;
        _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> asked to write %lu bytes by nghttp2", (uint8_t *)buf, 0x30u);
      }
    }
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  v88[0] = 0;
  v88[1] = v88;
  v87[0] = 0;
  v87[1] = v87;
  uint64_t v8 = *(void *)(a5 + 240);
  if (v8) {
    BOOL v9 = 0;
  }
  else {
    BOOL v9 = (*(_WORD *)(a5 + 388) & 0x100) == 0;
  }
  if (v9) {
    int v10 = v87;
  }
  else {
    int v10 = (void *)(a5 + 240);
  }
  uint64_t v11 = *(void *)(a5 + 32);
  if (!v11
    || (uint64_t v12 = *(void *)(v11 + 24)) == 0
    || (BOOL v13 = *(unsigned int (**)(void, uint64_t, uint64_t, uint64_t, uint64_t, void *))(v12 + 88)) == 0)
  {
    if ((*(_WORD *)(a5 + 388) & 0x8000) != 0) {
      return -902;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v30 = *(_DWORD *)(a5 + 368);
    LODWORD(buf[0]) = 136446978;
    *(void *)((char *)buf + 4) = "send_callback";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = a5 + 390;
    HIWORD(buf[2]) = 2080;
    BOOL v90 = " ";
    LOWORD(v91) = 1024;
    *(_DWORD *)((char *)&v91 + 2) = v30;
    __int16 v31 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v79) = 0;
    if (!__nwlog_fault(v31, type, &v79)) {
      goto LABEL_92;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v32 = gconnectionLogObj;
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
      {
        int v34 = *(_DWORD *)(a5 + 368);
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a5 + 390;
        HIWORD(buf[2]) = 2080;
        BOOL v90 = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v34;
        uint64_t v35 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback";
LABEL_91:
        _os_log_impl(&dword_1830D4000, v32, v33, v35, (uint8_t *)buf, 0x26u);
      }
    }
    else if ((_BYTE)v79)
    {
      size_t v36 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v32 = gconnectionLogObj;
      os_log_type_t v33 = type[0];
      BOOL v37 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
      if (!v36)
      {
        if (!v37) {
          goto LABEL_92;
        }
        int v56 = *(_DWORD *)(a5 + 368);
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a5 + 390;
        HIWORD(buf[2]) = 2080;
        BOOL v90 = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v56;
        uint64_t v35 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, no backtrace";
        goto LABEL_91;
      }
      if (v37)
      {
        int v38 = *(_DWORD *)(a5 + 368);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a5 + 390;
        HIWORD(buf[2]) = 2080;
        BOOL v90 = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v38;
        HIWORD(v91) = 2082;
        v92[0] = v36;
        _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x30u);
      }
      free(v36);
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v32 = gconnectionLogObj;
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
      {
        int v47 = *(_DWORD *)(a5 + 368);
        LODWORD(buf[0]) = 136446978;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a5 + 390;
        HIWORD(buf[2]) = 2080;
        BOOL v90 = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v47;
        uint64_t v35 = "%{public}s %{public}s%s<i%u> output handler has no get_output_frames callback, backtrace limit exceeded";
        goto LABEL_91;
      }
    }
LABEL_92:
    if (v31)
    {
      unsigned int v57 = (char *)v31;
LABEL_116:
      free(v57);
      return -902;
    }
    return -902;
  }
  if (!v13(*(void *)(a5 + 32), a5, 1, a3, 0xFFFFFFFFLL, v88) || (uint64_t v14 = v88[0]) == 0)
  {
    *(_WORD *)(a5 + 388) |= 0x2000u;
    return -504;
  }
  *(void *)os_log_type_t type = 0;
  int v86 = 0;
  unsigned int v84 = type;
  uint64_t v85 = 0x2000000000;
  uint64_t v79 = 0;
  size_t v80 = &v79;
  int v82 = 0;
  uint64_t v81 = 0x2000000000;
  v69[0] = MEMORY[0x1E4F143A8];
  v69[1] = 0x40000000;
  uint64_t v70 = ___ZL13send_callbackP15nghttp2_sessionPKhmiPv_block_invoke_83628;
  os_log_t v71 = &unk_1E524A8E8;
  uint64_t v74 = a3;
  uint64_t v75 = a2;
  uint64_t v76 = a5;
  uint64_t v77 = v88;
  uint32_t v78 = v10;
  uint64_t v72 = type;
  os_log_type_t v73 = &v79;
  do
  {
    if (!v14) {
      break;
    }
    uint64_t v15 = *(void *)(v14 + 32);
    char v16 = ((uint64_t (*)(void *))v70)(v69);
    uint64_t v14 = v15;
  }
  while ((v16 & 1) != 0);
  if ((*(_WORD *)(a5 + 388) & 0x100) == 0 && !v8)
  {
    uint64_t v17 = *(void *)(v11 + 24);
    if (v17)
    {
      os_log_type_t v18 = *(void (**)(uint64_t, void *))(v17 + 96);
      if (v18)
      {
        v18(v11, v10);
        goto LABEL_28;
      }
    }
    __nwlog_obj();
    unsigned int v50 = *(const char **)(v11 + 16);
    if (!v50) {
      unsigned int v50 = "invalid";
    }
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "send_callback";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v50;
    os_log_type_t v51 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v93) = 16;
    char v68 = 0;
    if (__nwlog_fault(v51, &v93, &v68))
    {
      if (v93 == 17)
      {
        __int16 v52 = __nwlog_obj();
        os_log_type_t v53 = v93;
        if (!os_log_type_enabled(v52, (os_log_type_t)v93)) {
          goto LABEL_127;
        }
        BOOL v54 = *(const char **)(v11 + 16);
        if (!v54) {
          BOOL v54 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v54;
        uint64_t v55 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
        goto LABEL_126;
      }
      if (!v68)
      {
        __int16 v52 = __nwlog_obj();
        os_log_type_t v53 = v93;
        if (!os_log_type_enabled(v52, (os_log_type_t)v93)) {
          goto LABEL_127;
        }
        uint64_t v66 = *(const char **)(v11 + 16);
        if (!v66) {
          uint64_t v66 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v66;
        uint64_t v55 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
        goto LABEL_126;
      }
      size_t v63 = (char *)__nw_create_backtrace_string();
      __int16 v52 = __nwlog_obj();
      os_log_type_t v53 = v93;
      BOOL v64 = os_log_type_enabled(v52, (os_log_type_t)v93);
      if (v63)
      {
        if (v64)
        {
          BOOL v65 = *(const char **)(v11 + 16);
          if (!v65) {
            BOOL v65 = "invalid";
          }
          LODWORD(buf[0]) = 136446722;
          *(void *)((char *)buf + 4) = "send_callback";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v65;
          HIWORD(buf[2]) = 2082;
          BOOL v90 = v63;
          _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
        }
        free(v63);
        goto LABEL_127;
      }
      if (v64)
      {
        uint64_t v67 = *(const char **)(v11 + 16);
        if (!v67) {
          uint64_t v67 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v67;
        uint64_t v55 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_126:
        _os_log_impl(&dword_1830D4000, v52, v53, v55, (uint8_t *)buf, 0x16u);
      }
    }
LABEL_127:
    if (v51) {
      free(v51);
    }
LABEL_28:
    if ((*(__int16 *)(a5 + 388) & 0x80000000) == 0)
    {
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v19 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
          goto LABEL_99;
        }
        int v20 = *(_DWORD *)(a5 + 368);
        int v21 = *((_DWORD *)v84 + 6);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "send_callback";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a5 + 390;
        HIWORD(buf[2]) = 2080;
        BOOL v90 = " ";
        LOWORD(v91) = 1024;
        *(_DWORD *)((char *)&v91 + 2) = v20;
        HIWORD(v91) = 1024;
        LODWORD(v92[0]) = v21;
        BOOL v22 = "%{public}s %{public}s%s<i%u> wrote %u bytes";
        char v23 = v19;
        uint32_t v24 = 44;
        goto LABEL_98;
      }
      goto LABEL_37;
    }
LABEL_99:
    if (gLogDatapath)
    {
      os_log_type_t v62 = __nwlog_obj();
      if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
      {
        int v93 = 136446210;
        BOOL v94 = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEBUG, "%{public}s called", (uint8_t *)&v93, 0xCu);
      }
    }
    goto LABEL_37;
  }
  if ((*(_WORD *)(a5 + 388) & 0x8000) != 0) {
    goto LABEL_99;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v58 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_99;
    }
    int v59 = *(_DWORD *)(a5 + 368);
    int v60 = *((_DWORD *)v84 + 6);
    int v61 = *((_DWORD *)v80 + 6);
    LODWORD(buf[0]) = 136447490;
    *(void *)((char *)buf + 4) = "send_callback";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = a5 + 390;
    HIWORD(buf[2]) = 2080;
    BOOL v90 = " ";
    LOWORD(v91) = 1024;
    *(_DWORD *)((char *)&v91 + 2) = v59;
    HIWORD(v91) = 1024;
    LODWORD(v92[0]) = v60;
    WORD2(v92[0]) = 1024;
    *(_DWORD *)((char *)v92 + 6) = v61;
    BOOL v22 = "%{public}s %{public}s%s<i%u> wrote %u bytes (pending %u frames)";
    char v23 = v58;
    uint32_t v24 = 50;
LABEL_98:
    _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, v22, (uint8_t *)buf, v24);
    goto LABEL_99;
  }
LABEL_37:
  buf[0] = MEMORY[0x1E4F143A8];
  buf[1] = 0x40000000;
  buf[2] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_83451;
  BOOL v90 = (const char *)&__block_descriptor_tmp_33_83452;
  BOOL v91 = v88;
  LOBYTE(v92[0]) = 0;
  uint64_t v26 = v88[0];
  do
  {
    if (!v26) {
      break;
    }
    uint64_t v27 = *(void *)(v26 + 32);
    char v28 = ((uint64_t (*)(void *))buf[2])(buf);
    uint64_t v26 = v27;
  }
  while ((v28 & 1) != 0);
  uint64_t v25 = *((unsigned int *)v84 + 6);
  _Block_object_dispose(&v79, 8);
  _Block_object_dispose(type, 8);
  return v25;
}

uint64_t ___ZL13send_callbackP15nghttp2_sessionPKhmiPv_block_invoke_83628(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unsigned int v23 = 0;
  uint64_t v4 = (void *)nw_frame_unclaimed_bytes(a2, &v23);
  uint64_t v5 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  unsigned int v6 = *(_DWORD *)(a1 + 48) - v5;
  if (v6 >= v23) {
    size_t v7 = v23;
  }
  else {
    size_t v7 = v6;
  }
  memcpy(v4, (const void *)(*(void *)(a1 + 56) + v5), v7);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v7;
  nw_frame_claim(a2, v8, v7, 0);
  nw_frame_collapse(a2);
  nw_frame_unclaim(a2, v9, v7, 0);
  uint64_t v11 = *(void *)(a2 + 32);
  uint64_t v12 = *(void **)(a2 + 40);
  int v10 = (void *)(a2 + 32);
  if (v11)
  {
    *(void *)(v11 + 40) = v12;
    uint64_t v12 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 72) + 8) = v12;
  }
  void *v12 = v11;
  *int v10 = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v13 = *(void *)(a1 + 80);
  uint64_t v14 = *(uint64_t **)(v13 + 8);
  *(void *)(a2 + 40) = v14;
  uint64_t *v14 = a2;
  *(void *)(v13 + 8) = v10;
  ++*(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  uint64_t v15 = *(void *)(a1 + 64);
  if ((!v15 || (*(__int16 *)(v15 + 388) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v17 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = *(void *)(a1 + 64);
      uint64_t v19 = "";
      BOOL v20 = v18 == 0;
      int v21 = *(_DWORD *)(v18 + 368);
      BOOL v22 = (const char *)(v18 + 390);
      uint64_t v25 = "send_callback_block_invoke";
      __int16 v26 = 2082;
      if (v20) {
        BOOL v22 = "";
      }
      *(_DWORD *)int buf = 136447234;
      if (!v20) {
        uint64_t v19 = " ";
      }
      uint64_t v27 = v22;
      __int16 v28 = 2080;
      __int16 v29 = v19;
      __int16 v30 = 1024;
      int v31 = v21;
      __int16 v32 = 1024;
      int v33 = v7;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> copied %u bytes into output frame", buf, 0x2Cu);
    }
  }
  return 1;
}

uint64_t on_frame_recv_callback(uint64_t a1, uint64_t *a2, uint64_t a3)
{
  uint64_t v247 = *MEMORY[0x1E4F143B8];
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
    BOOL v127 = (char *)_os_log_send_and_compose_impl();
    v237[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v127, v237, &type))
    {
      if (v237[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v128 = __nwlog_obj();
        os_log_type_t v129 = v237[0];
        if (os_log_type_enabled(v128, v237[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          BOOL v130 = "%{public}s nghttp2 user data is NULL, not http2";
LABEL_260:
          _os_log_impl(&dword_1830D4000, v128, v129, v130, buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v128 = __nwlog_obj();
        os_log_type_t v129 = v237[0];
        BOOL v136 = os_log_type_enabled(v128, v237[0]);
        if (backtrace_string)
        {
          if (v136)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v128, v129, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_261;
        }
        if (v136)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          BOOL v130 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
          goto LABEL_260;
        }
      }
      else
      {
        uint64_t v128 = __nwlog_obj();
        os_log_type_t v129 = v237[0];
        if (os_log_type_enabled(v128, v237[0]))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          BOOL v130 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
          goto LABEL_260;
        }
      }
    }
LABEL_261:
    if (v127) {
      free(v127);
    }
    return 4294966394;
  }
  if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v131 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v132 = *(_DWORD *)(a3 + 368);
      int v133 = *((unsigned __int8 *)a2 + 12);
      int v134 = *((unsigned __int8 *)a2 + 13);
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      __int16 v239 = 2082;
      uint64_t v240 = (void *)(a3 + 390);
      __int16 v241 = 2080;
      BOOL v242 = " ";
      __int16 v243 = 1024;
      int v244 = v132;
      __int16 v245 = 1024;
      *(_DWORD *)uint64_t v246 = v133;
      *(_WORD *)&v246[4] = 1024;
      *(_DWORD *)&v246[6] = v134;
      _os_log_impl(&dword_1830D4000, v131, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with frame type %d flags %d", buf, 0x32u);
    }
  }
  switch(*((unsigned char *)a2 + 12))
  {
    case 0:
      *(void *)int v237 = 0;
      uint64_t stream_from_id = nw_http2_get_stream_from_id(a3, *((_DWORD *)a2 + 2), v237);
      if (!stream_from_id)
      {
        if (*(__int16 *)(a3 + 388) < 0) {
          return 0;
        }
        if (gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v229 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v230 = *(_DWORD *)(a3 + 368);
            int v231 = *((_DWORD *)a2 + 2);
            uint64_t v232 = *a2;
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(a3 + 390);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v230;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v231;
            *(_WORD *)&v246[4] = 2048;
            *(void *)&v246[6] = v232;
            _os_log_impl(&dword_1830D4000, v229, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received a complete DATA frame on stream %d, length %zu", buf, 0x36u);
          }
          if (*(__int16 *)(a3 + 388) < 0) {
            return 0;
          }
          if (__nwlog_connection_log::onceToken == -1)
          {
LABEL_267:
            int v137 = *(_DWORD *)(a3 + 368);
            int v138 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(a3 + 390);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v137;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v138;
            uint64_t v139 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v235 = 0;
            if (!__nwlog_fault(v139, &type, &v235)) {
              goto LABEL_369;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v140 = gconnectionLogObj;
              os_log_type_t v141 = type;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                goto LABEL_369;
              }
              int v142 = *(_DWORD *)(a3 + 368);
              int v143 = *((_DWORD *)a2 + 2);
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v142;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v143;
              BOOL v144 = "%{public}s %{public}s%s<i%u> failed to find stream %d, dropping DATA";
            }
            else if (v235)
            {
              uint64_t v171 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v140 = gconnectionLogObj;
              os_log_type_t v141 = type;
              BOOL v172 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
              if (v171)
              {
                if (v172)
                {
                  int v173 = *(_DWORD *)(a3 + 368);
                  int v174 = *((_DWORD *)a2 + 2);
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
                  __int16 v239 = 2082;
                  uint64_t v240 = (void *)(a3 + 390);
                  __int16 v241 = 2080;
                  BOOL v242 = " ";
                  __int16 v243 = 1024;
                  int v244 = v173;
                  __int16 v245 = 1024;
                  *(_DWORD *)uint64_t v246 = v174;
                  *(_WORD *)&v246[4] = 2082;
                  *(void *)&v246[6] = v171;
                  _os_log_impl(&dword_1830D4000, v140, v141, "%{public}s %{public}s%s<i%u> failed to find stream %d, dropping DATA, dumping backtrace:%{public}s", buf, 0x36u);
                }
                free(v171);
                goto LABEL_369;
              }
              if (!v172)
              {
LABEL_369:
                if (v139) {
                  free(v139);
                }
                return 0;
              }
              int v212 = *(_DWORD *)(a3 + 368);
              int v213 = *((_DWORD *)a2 + 2);
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v212;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v213;
              BOOL v144 = "%{public}s %{public}s%s<i%u> failed to find stream %d, dropping DATA, no backtrace";
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v140 = gconnectionLogObj;
              os_log_type_t v141 = type;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                goto LABEL_369;
              }
              int v198 = *(_DWORD *)(a3 + 368);
              int v199 = *((_DWORD *)a2 + 2);
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v198;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v199;
              BOOL v144 = "%{public}s %{public}s%s<i%u> failed to find stream %d, dropping DATA, backtrace limit exceeded";
            }
            _os_log_impl(&dword_1830D4000, v140, v141, v144, buf, 0x2Cu);
            goto LABEL_369;
          }
        }
        else if (__nwlog_connection_log::onceToken == -1)
        {
          goto LABEL_267;
        }
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        goto LABEL_267;
      }
      uint64_t v6 = stream_from_id;
      if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x80000) == 0
        && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        unsigned int v150 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v152 = *(_DWORD *)(v6 + 176);
          int v151 = *(_DWORD *)(v6 + 180);
          int v153 = *((_DWORD *)a2 + 2);
          uint64_t v154 = *a2;
          *(_DWORD *)int buf = 136447746;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(v6 + 191);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v151;
          __int16 v245 = 1024;
          *(_DWORD *)uint64_t v246 = v152;
          *(_WORD *)&v246[4] = 1024;
          *(_DWORD *)&v246[6] = v153;
          *(_WORD *)&v246[10] = 2048;
          *(void *)&v246[12] = v154;
          _os_log_impl(&dword_1830D4000, v150, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> received a complete DATA frame on stream %d, length %zu", buf, 0x3Cu);
        }
      }
      nw_http_transaction_metadata_increment_inbound_body_transfer_size(*(void **)(v6 + 96), *a2 + 9);
      if ((*((unsigned char *)a2 + 13) & 1) == 0) {
        return 0;
      }
      if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v167 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v169 = *(_DWORD *)(v6 + 176);
          int v168 = *(_DWORD *)(v6 + 180);
          int v170 = *((_DWORD *)a2 + 2);
          *(_DWORD *)int buf = 136447746;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(v6 + 191);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v168;
          __int16 v245 = 1024;
          *(_DWORD *)uint64_t v246 = v169;
          *(_WORD *)&v246[4] = 1024;
          *(_DWORD *)&v246[6] = v170;
          *(_WORD *)&v246[10] = 1024;
          *(_DWORD *)&v246[12] = v170;
          _os_log_impl(&dword_1830D4000, v167, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream id %d end stream flag detected, delivering input_finished for stream %d", buf, 0x38u);
        }
      }
      int v7 = *(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16);
      if (*(void *)v237)
      {
        if ((*(_WORD *)(v6 + 188) & 0x1000) == 0)
        {
          if ((v7 & 0x80000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v200 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v202 = *(_DWORD *)(v6 + 176);
              int v201 = *(_DWORD *)(v6 + 180);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(v6 + 191);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v201;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v202;
              *(_WORD *)&v246[4] = 1024;
              *(_DWORD *)&v246[6] = v202;
              _os_log_impl(&dword_1830D4000, v200, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> detected end stream on data frame for stream %d, stream newly complete", buf, 0x32u);
            }
          }
          *(_WORD *)(v6 + 188) |= 0x1000u;
        }
        nw_http_transaction_metadata_mark_inbound_message_end(*(void **)(v6 + 96));
        if (!*(unsigned char *)(v6 + 72) || *(void *)(v6 + 64) == *(void *)(v6 + 80))
        {
          if (*(void *)v237)
          {
            uint64_t v8 = *(void *)(*(void *)v237 + 24);
            if (v8)
            {
              uint64_t v9 = *(void (**)(void))(v8 + 184);
              if (v9)
              {
                v9();
                return 0;
              }
            }
          }
          if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) != 0) {
            return 4294966775;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v156 = *(_DWORD *)(v6 + 176);
          int v155 = *(_DWORD *)(v6 + 180);
          int v157 = *((_DWORD *)a2 + 2);
          *(_DWORD *)int buf = 136447746;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(v6 + 191);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v155;
          __int16 v245 = 1024;
          *(_DWORD *)uint64_t v246 = v156;
          *(_WORD *)&v246[4] = 2048;
          *(void *)&v246[6] = *(void *)v237;
          *(_WORD *)&v246[14] = 1024;
          *(_DWORD *)&v246[16] = v157;
          int v158 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v235 = 0;
          if (!__nwlog_fault(v158, &type, &v235)) {
            goto LABEL_382;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v159 = gconnectionLogObj;
            os_log_type_t v160 = type;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
              goto LABEL_382;
            }
            int v162 = *(_DWORD *)(v6 + 176);
            int v161 = *(_DWORD *)(v6 + 180);
            int v163 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447746;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(v6 + 191);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v161;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v162;
            *(_WORD *)&v246[4] = 2048;
            *(void *)&v246[6] = *(void *)v237;
            *(_WORD *)&v246[14] = 1024;
            *(_DWORD *)&v246[16] = v163;
            BOOL v164 = "%{public}s %{public}s%s<i%u:s%d> no input finished callback for protocol %p attached to stream %d";
          }
          else if (v235)
          {
            BOOL v183 = (char *)__nw_create_backtrace_string();
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v159 = gconnectionLogObj;
            os_log_type_t v160 = type;
            BOOL v184 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
            if (v183)
            {
              if (v184)
              {
                int v186 = *(_DWORD *)(v6 + 176);
                int v185 = *(_DWORD *)(v6 + 180);
                int v187 = *((_DWORD *)a2 + 2);
                *(_DWORD *)int buf = 136448002;
                *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
                __int16 v239 = 2082;
                uint64_t v240 = (void *)(v6 + 191);
                __int16 v241 = 2080;
                BOOL v242 = " ";
                __int16 v243 = 1024;
                int v244 = v185;
                __int16 v245 = 1024;
                *(_DWORD *)uint64_t v246 = v186;
                *(_WORD *)&v246[4] = 2048;
                *(void *)&v246[6] = *(void *)v237;
                *(_WORD *)&v246[14] = 1024;
                *(_DWORD *)&v246[16] = v187;
                *(_WORD *)&v246[20] = 2082;
                *(void *)&v246[22] = v183;
                _os_log_impl(&dword_1830D4000, v159, v160, "%{public}s %{public}s%s<i%u:s%d> no input finished callback for protocol %p attached to stream %d, dumping backtrace:%{public}s", buf, 0x46u);
              }
              free(v183);
              goto LABEL_382;
            }
            if (!v184)
            {
LABEL_382:
              if (!v158) {
                return 4294966775;
              }
              BOOL v111 = (char *)v158;
LABEL_197:
              free(v111);
              return 4294966775;
            }
            int v220 = *(_DWORD *)(v6 + 176);
            int v219 = *(_DWORD *)(v6 + 180);
            int v221 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447746;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(v6 + 191);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v219;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v220;
            *(_WORD *)&v246[4] = 2048;
            *(void *)&v246[6] = *(void *)v237;
            *(_WORD *)&v246[14] = 1024;
            *(_DWORD *)&v246[16] = v221;
            BOOL v164 = "%{public}s %{public}s%s<i%u:s%d> no input finished callback for protocol %p attached to stream %d, no backtrace";
          }
          else
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v159 = gconnectionLogObj;
            os_log_type_t v160 = type;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
              goto LABEL_382;
            }
            int v210 = *(_DWORD *)(v6 + 176);
            int v209 = *(_DWORD *)(v6 + 180);
            int v211 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447746;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(v6 + 191);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v209;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v210;
            *(_WORD *)&v246[4] = 2048;
            *(void *)&v246[6] = *(void *)v237;
            *(_WORD *)&v246[14] = 1024;
            *(_DWORD *)&v246[16] = v211;
            BOOL v164 = "%{public}s %{public}s%s<i%u:s%d> no input finished callback for protocol %p attached to stream %d, ba"
                   "cktrace limit exceeded";
          }
          _os_log_impl(&dword_1830D4000, v159, v160, v164, buf, 0x3Cu);
          goto LABEL_382;
        }
        if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v87 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            int v88 = *(_DWORD *)(a3 + 368);
            if (*(unsigned char *)(v6 + 72)) {
              uint64_t v89 = *(void *)(v6 + 64);
            }
            else {
              uint64_t v89 = -1;
            }
            goto LABEL_240;
          }
        }
        goto LABEL_241;
      }
      if ((v7 & 0x80000) != 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v61 = gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v63 = *(_DWORD *)(v6 + 176);
        int v62 = *(_DWORD *)(v6 + 180);
        int v64 = *((_DWORD *)a2 + 2);
        *(_DWORD *)int buf = 136447490;
        *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)(v6 + 191);
        __int16 v241 = 2080;
        BOOL v242 = " ";
        __int16 v243 = 1024;
        int v244 = v62;
        __int16 v245 = 1024;
        *(_DWORD *)uint64_t v246 = v63;
        *(_WORD *)&v246[4] = 1024;
        *(_DWORD *)&v246[6] = v64;
        uint64_t v17 = "%{public}s %{public}s%s<i%u:s%d> no input handler found for stream %d, dropping DATA";
        uint64_t v18 = v61;
        os_log_type_t v19 = OS_LOG_TYPE_ERROR;
        goto LABEL_98;
      }
      return result;
    case 1:
      if ((*((unsigned char *)a2 + 13) & 5) == 0) {
        goto LABEL_219;
      }
      *(void *)int v237 = 0;
      uint64_t v27 = nw_http2_get_stream_from_id(a3, *((_DWORD *)a2 + 2), v237);
      if (v27)
      {
        uint64_t v6 = v27;
        if (*(void *)(v27 + 112))
        {
          BOOL v28 = nw_http_parsed_fields_copy_trailer_fields(*(void **)(v27 + 144));
          if (v28)
          {
            __int16 v29 = (void *)v28;
            nw_http_metadata_set_trailer_fields(*(void **)(v6 + 112), (void *)v28);
            os_release(v29);
            goto LABEL_201;
          }
          if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) != 0) {
            return 4294966775;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v90 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
            return 4294966775;
          }
          int v92 = *(_DWORD *)(v6 + 176);
          int v91 = *(_DWORD *)(v6 + 180);
          int v93 = *((_DWORD *)a2 + 2);
          *(_DWORD *)int buf = 136447490;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(v6 + 191);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v91;
          __int16 v245 = 1024;
          *(_DWORD *)uint64_t v246 = v92;
          *(_WORD *)&v246[4] = 1024;
          *(_DWORD *)&v246[6] = v93;
          BOOL v94 = "%{public}s %{public}s%s<i%u:s%d> invalid trailer fields received on stream %d";
LABEL_237:
          _os_log_impl(&dword_1830D4000, v90, OS_LOG_TYPE_ERROR, v94, buf, 0x32u);
          return 4294966775;
        }
        *(_WORD *)(v27 + 188) |= 0x400u;
        uint64_t v79 = *(void **)(v27 + 144);
        if (*((_DWORD *)a2 + 14))
        {
          BOOL v80 = nw_http_parsed_fields_copy_response(v79);
          if (!v80)
          {
            if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) != 0) {
              return 4294966775;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v90 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
              return 4294966775;
            }
            int v101 = *(_DWORD *)(v6 + 176);
            int v100 = *(_DWORD *)(v6 + 180);
            int v102 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(v6 + 191);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v100;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v101;
            *(_WORD *)&v246[4] = 1024;
            *(_DWORD *)&v246[6] = v102;
            BOOL v94 = "%{public}s %{public}s%s<i%u:s%d> invalid response received on stream %d";
            goto LABEL_237;
          }
          uint64_t v81 = (void *)v80;
          *(void *)(v6 + 112) = nw_http_create_metadata_for_response((void *)v80);
          BOOL v82 = (nw_http_response_get_status_code(v81) - 100) < 0x64;
        }
        else
        {
          BOOL v95 = nw_http_parsed_fields_copy_request(v79);
          if (!v95)
          {
            if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) != 0) {
              return 4294966775;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v90 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
              return 4294966775;
            }
            int v122 = *(_DWORD *)(v6 + 176);
            int v121 = *(_DWORD *)(v6 + 180);
            int v123 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(v6 + 191);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v121;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v122;
            *(_WORD *)&v246[4] = 1024;
            *(_DWORD *)&v246[6] = v123;
            BOOL v94 = "%{public}s %{public}s%s<i%u:s%d> invalid request received on stream %d";
            goto LABEL_237;
          }
          uint64_t v81 = (void *)v95;
          if (nw_http_request_has_method((void *)v95, (uint64_t)"CONNECT"))
          {
            int v96 = *(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16);
            if ((v96 & 0x10000) == 0)
            {
              v234[0] = MEMORY[0x1E4F143A8];
              v234[1] = 0x40000000;
              v234[2] = ___ZL22on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke;
              v234[3] = &__block_descriptor_tmp_95;
              v234[4] = v6;
              nw_http_fields_access_value_by_name(v81, (unint64_t)"Capsule-Protocol", v234);
              v233[0] = MEMORY[0x1E4F143A8];
              v233[1] = 0x40000000;
              v233[2] = ___ZL22on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2;
              v233[3] = &__block_descriptor_tmp_96_83812;
              v233[4] = v6;
              nw_http_request_access_extended_connect_protocol(v81, v233);
              int v96 = *(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16);
            }
            *(unsigned char *)(v6 + 190) = BYTE2(v96);
            *(_WORD *)(v6 + 188) = v96 | 0x200;
          }
          BOOL v82 = 0;
          *(void *)(v6 + 112) = nw_http_create_metadata_for_request(v81);
        }
        os_release(v81);
        nw_http_metadata_set_version(*(void **)(v6 + 112), 4);
        if (*(_WORD *)(a3 + 372)) {
          *(_WORD *)(a3 + 372) = 0;
        }
        if ((*((unsigned char *)a2 + 13) & 4) != 0)
        {
          if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v225 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v227 = *(_DWORD *)(v6 + 176);
              int v226 = *(_DWORD *)(v6 + 180);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(v6 + 191);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v226;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v227;
              *(_WORD *)&v246[4] = 1024;
              *(_DWORD *)&v246[6] = v227;
              _os_log_impl(&dword_1830D4000, v225, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> detected end headers on header frame for stream %d", buf, 0x32u);
            }
          }
          nw_http_transaction_metadata_set_inbound_message(*(void **)(v6 + 96), *(void **)(v6 + 112));
          if (v82)
          {
            nw_array_append(*(void *)(v6 + 160), *(void **)(v6 + 112));
            uint64_t v97 = *(void **)(v6 + 112);
            if (v97)
            {
              os_release(v97);
              *(void *)(v6 + 112) = 0;
            }
          }
          else
          {
            *(_WORD *)(v6 + 188) |= 0x800u;
            nw::http::content_length_manager::set_inbound_message((nw::http::content_length_manager *)(v6 + 40), *(nw_protocol_metadata **)(v6 + 112));
          }
        }
        nw_http_transaction_metadata_increment_inbound_header_size(*(void **)(v6 + 96), 9 * ((unint64_t)(*a2 + 0x3FFF) >> 14) + *a2);
LABEL_201:
        if (*((unsigned char *)a2 + 13))
        {
          if (((*(unsigned __int16 *)(v6 + 188) | (*(unsigned __int8 *)(v6 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v206 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v208 = *(_DWORD *)(v6 + 176);
              int v207 = *(_DWORD *)(v6 + 180);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(v6 + 191);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v207;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v208;
              *(_WORD *)&v246[4] = 1024;
              *(_DWORD *)&v246[6] = v208;
              _os_log_impl(&dword_1830D4000, v206, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> detected end stream on header frame for stream %d", buf, 0x32u);
            }
          }
          *(_WORD *)(v6 + 188) |= 0x1000u;
          nw_http_transaction_metadata_mark_inbound_message_end(*(void **)(v6 + 96));
          if (*(unsigned char *)(v6 + 72))
          {
            if (*(void *)(v6 + 64) != *(void *)(v6 + 80))
            {
              if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v87 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  int v88 = *(_DWORD *)(a3 + 368);
                  if (*(unsigned char *)(v6 + 72)) {
                    uint64_t v89 = *(void *)(v6 + 64);
                  }
                  else {
                    uint64_t v89 = -1;
                  }
LABEL_240:
                  uint64_t v124 = *(void *)(v6 + 80);
                  *(_DWORD *)int buf = 136447490;
                  *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
                  __int16 v239 = 2082;
                  uint64_t v240 = (void *)(a3 + 390);
                  __int16 v241 = 2080;
                  BOOL v242 = " ";
                  __int16 v243 = 1024;
                  int v244 = v88;
                  __int16 v245 = 2048;
                  *(void *)uint64_t v246 = v89;
                  *(_WORD *)&v246[8] = 2048;
                  *(void *)&v246[10] = v124;
                  _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> Content length header %llu does not equal body size %llu", buf, 0x3Au);
                }
              }
LABEL_241:
              int v125 = *(unsigned __int16 *)(v6 + 188);
              int v126 = v125 | (*(unsigned __int8 *)(v6 + 190) << 16);
              if ((v125 & 0x40) == 0)
              {
                *(unsigned char *)(v6 + 190) = BYTE2(v126);
                *(_WORD *)(v6 + 188) = v126 | 0x40;
                nw_protocol_error(*(void **)v237, a3);
                nw_protocol_disconnected(*(void **)v237, a3);
              }
              return 0;
            }
          }
        }
        int v112 = (*(unsigned __int8 *)(v6 + 190) >> 3) & 1;
        if (!gLogDatapath) {
          LOBYTE(v112) = 1;
        }
        if ((*(_WORD *)(v6 + 188) & 1) == 0)
        {
          if ((v112 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v113 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v115 = *(_DWORD *)(v6 + 176);
              int v114 = *(_DWORD *)(v6 + 180);
              *(_DWORD *)int buf = 136447746;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(v6 + 191);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v114;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v115;
              *(_WORD *)&v246[4] = 2048;
              *(void *)&v246[6] = *(void *)v237;
              *(_WORD *)&v246[14] = 1024;
              *(_DWORD *)&v246[16] = v115;
              _os_log_impl(&dword_1830D4000, v113, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> suppressing input_available on protocol %p for stream %d that is not yet open", buf, 0x3Cu);
            }
          }
          goto LABEL_219;
        }
        if ((v112 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v214 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v216 = *(_DWORD *)(v6 + 176);
            int v215 = *(_DWORD *)(v6 + 180);
            *(_DWORD *)int buf = 136447746;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(v6 + 191);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v215;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v216;
            *(_WORD *)&v246[4] = 2048;
            *(void *)&v246[6] = *(void *)v237;
            *(_WORD *)&v246[14] = 1024;
            *(_DWORD *)&v246[16] = v216;
            _os_log_impl(&dword_1830D4000, v214, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling input_available on protocol %p for stream %d", buf, 0x3Cu);
          }
        }
        if (*(void *)v237)
        {
          uint64_t v116 = *(void *)(*(void *)v237 + 24);
          if (v116)
          {
            uint64_t v117 = *(void (**)(void))(v116 + 64);
            if (v117)
            {
              v117();
              goto LABEL_219;
            }
          }
        }
        __nwlog_obj();
        BOOL v188 = "invalid";
        if (*(void *)v237 && *(void *)(*(void *)v237 + 16)) {
          BOOL v188 = *(const char **)(*(void *)v237 + 16);
        }
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)v188;
        int v189 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v235 = 0;
        if (__nwlog_fault(v189, &type, &v235))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v190 = __nwlog_obj();
            os_log_type_t v191 = type;
            if (!os_log_type_enabled(v190, type)) {
              goto LABEL_404;
            }
            uint64_t v192 = "invalid";
            if (*(void *)v237 && *(void *)(*(void *)v237 + 16)) {
              uint64_t v192 = *(const char **)(*(void *)v237 + 16);
            }
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)v192;
            unsigned int v193 = "%{public}s protocol %{public}s has invalid input_available callback";
            goto LABEL_403;
          }
          if (!v235)
          {
            os_log_type_t v190 = __nwlog_obj();
            os_log_type_t v191 = type;
            if (!os_log_type_enabled(v190, type)) {
              goto LABEL_404;
            }
            uint64_t v222 = "invalid";
            if (*(void *)v237 && *(void *)(*(void *)v237 + 16)) {
              uint64_t v222 = *(const char **)(*(void *)v237 + 16);
            }
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)v222;
            unsigned int v193 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
            goto LABEL_403;
          }
          v203 = (char *)__nw_create_backtrace_string();
          os_log_type_t v190 = __nwlog_obj();
          os_log_type_t v191 = type;
          BOOL v204 = os_log_type_enabled(v190, type);
          if (v203)
          {
            if (v204)
            {
              uint64_t v205 = "invalid";
              if (*(void *)v237 && *(void *)(*(void *)v237 + 16)) {
                uint64_t v205 = *(const char **)(*(void *)v237 + 16);
              }
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)v205;
              __int16 v241 = 2082;
              BOOL v242 = v203;
              _os_log_impl(&dword_1830D4000, v190, v191, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v203);
            goto LABEL_404;
          }
          if (v204)
          {
            uint64_t v228 = "invalid";
            if (*(void *)v237 && *(void *)(*(void *)v237 + 16)) {
              uint64_t v228 = *(const char **)(*(void *)v237 + 16);
            }
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)v228;
            unsigned int v193 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_403:
            _os_log_impl(&dword_1830D4000, v190, v191, v193, buf, 0x16u);
          }
        }
LABEL_404:
        if (v189) {
          free(v189);
        }
LABEL_219:
        uint64_t result = 0;
        if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v118 = gconnectionLogObj;
          uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
          if (result)
          {
            int v119 = *(_DWORD *)(a3 + 368);
            int v120 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(a3 + 390);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v119;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v120;
            uint64_t v17 = "%{public}s %{public}s%s<i%u> received incoming HEADERS frame for stream %d";
            uint64_t v18 = v118;
            goto LABEL_225;
          }
        }
        return result;
      }
      if (*(__int16 *)(a3 + 388) < 0) {
        return 4294966775;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v53 = *(_DWORD *)(a3 + 368);
      int v54 = *((_DWORD *)a2 + 2);
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      __int16 v239 = 2082;
      uint64_t v240 = (void *)(a3 + 390);
      __int16 v241 = 2080;
      BOOL v242 = " ";
      __int16 v243 = 1024;
      int v244 = v53;
      __int16 v245 = 1024;
      *(_DWORD *)uint64_t v246 = v54;
      uint64_t v55 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v235 = 0;
      if (!__nwlog_fault(v55, &type, &v235)) {
        goto LABEL_195;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v56 = gconnectionLogObj;
        os_log_type_t v57 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_195;
        }
        int v58 = *(_DWORD *)(a3 + 368);
        int v59 = *((_DWORD *)a2 + 2);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)(a3 + 390);
        __int16 v241 = 2080;
        BOOL v242 = " ";
        __int16 v243 = 1024;
        int v244 = v58;
        __int16 v245 = 1024;
        *(_DWORD *)uint64_t v246 = v59;
        int v60 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
      }
      else if (v235)
      {
        unsigned int v83 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v56 = gconnectionLogObj;
        os_log_type_t v57 = type;
        BOOL v84 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v83)
        {
          if (v84)
          {
            int v85 = *(_DWORD *)(a3 + 368);
            int v86 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(a3 + 390);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v85;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v86;
            *(_WORD *)&v246[4] = 2082;
            *(void *)&v246[6] = v83;
            _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s %{public}s%s<i%u> failed to find stream %d, dumping backtrace:%{public}s", buf, 0x36u);
          }
          free(v83);
          goto LABEL_195;
        }
        if (!v84)
        {
LABEL_195:
          if (!v55) {
            return 4294966775;
          }
          BOOL v111 = (char *)v55;
          goto LABEL_197;
        }
        int v109 = *(_DWORD *)(a3 + 368);
        int v110 = *((_DWORD *)a2 + 2);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)(a3 + 390);
        __int16 v241 = 2080;
        BOOL v242 = " ";
        __int16 v243 = 1024;
        int v244 = v109;
        __int16 v245 = 1024;
        *(_DWORD *)uint64_t v246 = v110;
        int v60 = "%{public}s %{public}s%s<i%u> failed to find stream %d, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v56 = gconnectionLogObj;
        os_log_type_t v57 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_195;
        }
        int v98 = *(_DWORD *)(a3 + 368);
        int v99 = *((_DWORD *)a2 + 2);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)(a3 + 390);
        __int16 v241 = 2080;
        BOOL v242 = " ";
        __int16 v243 = 1024;
        int v244 = v98;
        __int16 v245 = 1024;
        *(_DWORD *)uint64_t v246 = v99;
        int v60 = "%{public}s %{public}s%s<i%u> failed to find stream %d, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v56, v57, v60, buf, 0x2Cu);
      goto LABEL_195;
    case 2:
      uint64_t result = 0;
      if (*(__int16 *)(a3 + 388) < 0 || !gLogDatapath) {
        return result;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v15 = gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      int v16 = *(_DWORD *)(a3 + 368);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      __int16 v239 = 2082;
      uint64_t v240 = (void *)(a3 + 390);
      __int16 v241 = 2080;
      BOOL v242 = " ";
      __int16 v243 = 1024;
      int v244 = v16;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received complete PRIORITY frame, ignoring";
      uint64_t v18 = v15;
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
      uint32_t v20 = 38;
      goto LABEL_133;
    case 3:
      if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v147 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v148 = *(_DWORD *)(a3 + 368);
          int v149 = *((_DWORD *)a2 + 2);
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(a3 + 390);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v148;
          __int16 v245 = 1024;
          *(_DWORD *)uint64_t v246 = v149;
          _os_log_impl(&dword_1830D4000, v147, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> stream %d received RST_STREAM frame, setting error to ECONNRESET", buf, 0x2Cu);
        }
      }
      int v21 = *((_DWORD *)a2 + 2);
      if (v21 <= 0)
      {
        if (*(__int16 *)(a3 + 388) < 0) {
          return 0;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v42 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
          goto LABEL_127;
        }
        int v43 = *(_DWORD *)(a3 + 368);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_http2_get_protocol_from_stream_id";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)(a3 + 390);
        __int16 v241 = 2080;
        BOOL v242 = " ";
        __int16 v243 = 1024;
        int v244 = v43;
        __int16 v245 = 1024;
        *(_DWORD *)uint64_t v246 = v21;
        int v44 = "%{public}s %{public}s%s<i%u> requested stream id (%d) is not valid, returning NULL protocol";
        uint64_t v45 = v42;
        os_log_type_t v46 = OS_LOG_TYPE_ERROR;
        uint32_t v47 = 44;
      }
      else
      {
        *(void *)int v237 = 0;
        uint64_t v22 = nw_http2_get_stream_from_id(a3, v21, v237);
        if (v22)
        {
          uint64_t v23 = *(void *)v237;
          if (*(void *)v237)
          {
            uint64_t v24 = *(void *)(*(void *)v237 + 24);
            if (v24)
            {
              uint64_t v25 = *(void (**)(void, uint64_t, uint64_t))(v24 + 56);
              if (v25)
              {
                int v26 = *((_DWORD *)a2 + 4);
                if (v26 == 7)
                {
                  v25(*(void *)v237, a3, 35);
                }
                else if (v26 == 13)
                {
                  v25(*(void *)v237, a3, 43);
                }
                else
                {
                  v25(*(void *)v237, a3, 54);
                }
                return 0;
              }
            }
            if (*(__int16 *)(a3 + 388) < 0) {
              return 4294966775;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v175 = *(_DWORD *)(a3 + 368);
            int v176 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(a3 + 390);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v175;
            __int16 v245 = 2048;
            *(void *)uint64_t v246 = v23;
            *(_WORD *)&v246[8] = 1024;
            *(_DWORD *)&v246[10] = v176;
            id v177 = (const char *)_os_log_send_and_compose_impl();
            v237[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t type = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v177, v237, &type)) {
              goto LABEL_392;
            }
            if (v237[0] == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v178 = gconnectionLogObj;
              os_log_type_t v179 = v237[0];
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v237[0])) {
                goto LABEL_392;
              }
              int v180 = *(_DWORD *)(a3 + 368);
              int v181 = *((_DWORD *)a2 + 2);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v180;
              __int16 v245 = 2048;
              *(void *)uint64_t v246 = v23;
              *(_WORD *)&v246[8] = 1024;
              *(_DWORD *)&v246[10] = v181;
              uint64_t v182 = "%{public}s %{public}s%s<i%u> no error callback for protocol %p attached to stream %d";
            }
            else if (type)
            {
              BOOL v194 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v178 = gconnectionLogObj;
              os_log_type_t v179 = v237[0];
              BOOL v195 = os_log_type_enabled((os_log_t)gconnectionLogObj, v237[0]);
              if (v194)
              {
                if (v195)
                {
                  int v196 = *(_DWORD *)(a3 + 368);
                  int v197 = *((_DWORD *)a2 + 2);
                  *(_DWORD *)int buf = 136447746;
                  *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
                  __int16 v239 = 2082;
                  uint64_t v240 = (void *)(a3 + 390);
                  __int16 v241 = 2080;
                  BOOL v242 = " ";
                  __int16 v243 = 1024;
                  int v244 = v196;
                  __int16 v245 = 2048;
                  *(void *)uint64_t v246 = v23;
                  *(_WORD *)&v246[8] = 1024;
                  *(_DWORD *)&v246[10] = v197;
                  *(_WORD *)&v246[14] = 2082;
                  *(void *)&v246[16] = v194;
                  _os_log_impl(&dword_1830D4000, v178, v179, "%{public}s %{public}s%s<i%u> no error callback for protocol %p attached to stream %d, dumping backtrace:%{public}s", buf, 0x40u);
                }
                free(v194);
                goto LABEL_392;
              }
              if (!v195)
              {
LABEL_392:
                if (!v177) {
                  return 4294966775;
                }
                BOOL v111 = (char *)v177;
                goto LABEL_197;
              }
              int v223 = *(_DWORD *)(a3 + 368);
              int v224 = *((_DWORD *)a2 + 2);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v223;
              __int16 v245 = 2048;
              *(void *)uint64_t v246 = v23;
              *(_WORD *)&v246[8] = 1024;
              *(_DWORD *)&v246[10] = v224;
              uint64_t v182 = "%{public}s %{public}s%s<i%u> no error callback for protocol %p attached to stream %d, no backtrace";
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v178 = gconnectionLogObj;
              os_log_type_t v179 = v237[0];
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v237[0])) {
                goto LABEL_392;
              }
              int v217 = *(_DWORD *)(a3 + 368);
              int v218 = *((_DWORD *)a2 + 2);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v217;
              __int16 v245 = 2048;
              *(void *)uint64_t v246 = v23;
              *(_WORD *)&v246[8] = 1024;
              *(_DWORD *)&v246[10] = v218;
              uint64_t v182 = "%{public}s %{public}s%s<i%u> no error callback for protocol %p attached to stream %d, backtrace limit exceeded";
            }
            _os_log_impl(&dword_1830D4000, v178, v179, v182, buf, 0x36u);
            goto LABEL_392;
          }
          uint64_t v72 = v22;
          if (((*(unsigned __int16 *)(v22 + 188) | (*(unsigned __int8 *)(v22 + 190) << 16)) & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v73 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            {
              int v75 = *(_DWORD *)(v72 + 176);
              int v74 = *(_DWORD *)(v72 + 180);
              *(_DWORD *)int buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_http2_get_protocol_from_stream_id";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(v72 + 191);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v74;
              __int16 v245 = 1024;
              *(_DWORD *)uint64_t v246 = v75;
              *(_WORD *)&v246[4] = 1024;
              *(_DWORD *)&v246[6] = v75;
              int v44 = "%{public}s %{public}s%s<i%u:s%d> no input handler attached to stream %d";
              uint64_t v45 = v73;
              os_log_type_t v46 = OS_LOG_TYPE_INFO;
              uint32_t v47 = 50;
              goto LABEL_126;
            }
          }
LABEL_127:
          if (*(__int16 *)(a3 + 388) < 0) {
            return 0;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v76 = gconnectionLogObj;
          uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO);
          if (result)
          {
            int v77 = *(_DWORD *)(a3 + 368);
            int v78 = *((_DWORD *)a2 + 2);
            *(_DWORD *)int buf = 136447234;
            *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
            __int16 v239 = 2082;
            uint64_t v240 = (void *)(a3 + 390);
            __int16 v241 = 2080;
            BOOL v242 = " ";
            __int16 v243 = 1024;
            int v244 = v77;
            __int16 v245 = 1024;
            *(_DWORD *)uint64_t v246 = v78;
            uint64_t v17 = "%{public}s %{public}s%s<i%u> no input handler found for stream %d, ignoring RST_STREAM";
            uint64_t v18 = v76;
            os_log_type_t v19 = OS_LOG_TYPE_INFO;
            goto LABEL_132;
          }
          return result;
        }
        if (*(__int16 *)(a3 + 388) < 0) {
          goto LABEL_127;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v51 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
          goto LABEL_127;
        }
        int v52 = *(_DWORD *)(a3 + 368);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_http2_get_protocol_from_stream_id";
        __int16 v239 = 2082;
        uint64_t v240 = (void *)(a3 + 390);
        __int16 v241 = 2080;
        BOOL v242 = " ";
        __int16 v243 = 1024;
        int v244 = v52;
        __int16 v245 = 1024;
        *(_DWORD *)uint64_t v246 = v21;
        int v44 = "%{public}s %{public}s%s<i%u> could not find stream for stream %d";
        uint64_t v45 = v51;
        os_log_type_t v46 = OS_LOG_TYPE_INFO;
        uint32_t v47 = 44;
      }
LABEL_126:
      _os_log_impl(&dword_1830D4000, v45, v46, v44, buf, v47);
      goto LABEL_127;
    case 4:
      if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v145 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v146 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(a3 + 390);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v146;
          _os_log_impl(&dword_1830D4000, v145, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received complete SETTINGS frame", buf, 0x26u);
        }
      }
      uint64_t v10 = a2[2];
      if (!v10) {
        return 0;
      }
      uint64_t v11 = 0;
      uint64_t v12 = (int *)a2[3];
      while (1)
      {
        int v13 = *v12;
        v12 += 2;
        if (v13 == 11104) {
          break;
        }
        if (v10 == ++v11) {
          return 0;
        }
      }
      uint64_t result = 0;
      if (*(__int16 *)(a3 + 388) < 0 || !gLogDatapath) {
        return result;
      }
      int v48 = *(_DWORD *)(a2[3] + 8 * v11 + 4);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v49 = gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      int v50 = *(_DWORD *)(a3 + 368);
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      __int16 v239 = 2082;
      uint64_t v240 = (void *)(a3 + 390);
      __int16 v241 = 2080;
      BOOL v242 = " ";
      __int16 v243 = 1024;
      int v244 = v50;
      __int16 v245 = 1024;
      *(_DWORD *)uint64_t v246 = v48;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received remote max webtransport session update: %u, ignoring for now";
      uint64_t v18 = v49;
LABEL_225:
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
LABEL_132:
      uint32_t v20 = 44;
LABEL_133:
      _os_log_impl(&dword_1830D4000, v18, v19, v17, buf, v20);
      return 0;
    case 5:
      if (*(__int16 *)(a3 + 388) < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v30 = gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (!result) {
        return result;
      }
      int v31 = *(_DWORD *)(a3 + 368);
      int v32 = *((_DWORD *)a2 + 2);
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      __int16 v239 = 2082;
      uint64_t v240 = (void *)(a3 + 390);
      __int16 v241 = 2080;
      BOOL v242 = " ";
      __int16 v243 = 1024;
      int v244 = v31;
      __int16 v245 = 1024;
      *(_DWORD *)uint64_t v246 = v32;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received a complete PUSH_PROMISE frame on stream %d -- currently not supported";
      uint64_t v18 = v30;
      os_log_type_t v19 = OS_LOG_TYPE_ERROR;
      goto LABEL_132;
    case 6:
      if ((*((unsigned char *)a2 + 13) & 1) == 0) {
        return 0;
      }
      unint64_t v33 = a2[2];
      if ((*(__int16 *)(a3 + 388) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v165 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v166 = *(_DWORD *)(a3 + 368);
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_http2_received_ping_ack";
          __int16 v239 = 2082;
          uint64_t v240 = (void *)(a3 + 390);
          __int16 v241 = 2080;
          BOOL v242 = " ";
          __int16 v243 = 1024;
          int v244 = v166;
          __int16 v245 = 2048;
          *(void *)uint64_t v246 = v33;
          _os_log_impl(&dword_1830D4000, v165, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> seq %llu", buf, 0x30u);
        }
      }
      int8x8_t v34 = *(int8x8_t *)(a3 + 320);
      if (!*(void *)&v34) {
        goto LABEL_116;
      }
      uint64_t v35 = (void *)(a3 + 312);
      uint8x8_t v36 = (uint8x8_t)vcnt_s8(v34);
      v36.i16[0] = vaddlv_u8(v36);
      if (v36.u32[0] > 1uLL)
      {
        unint64_t v37 = v33;
        if (*(void *)&v34 <= v33) {
          unint64_t v37 = v33 % *(void *)&v34;
        }
      }
      else
      {
        unint64_t v37 = (*(void *)&v34 - 1) & v33;
      }
      BOOL v65 = *(void ***)(*v35 + 8 * v37);
      if (!v65) {
        goto LABEL_116;
      }
      uint64_t v66 = *v65;
      if (!*v65) {
        goto LABEL_116;
      }
      if (v36.u32[0] < 2uLL)
      {
        uint64_t v67 = *(void *)&v34 - 1;
        while (1)
        {
          uint64_t v69 = v66[1];
          if (v69 == v33)
          {
            if (v66[2] == v33) {
              goto LABEL_182;
            }
          }
          else if ((v69 & v67) != v37)
          {
            goto LABEL_116;
          }
          uint64_t v66 = (void *)*v66;
          if (!v66) {
            goto LABEL_116;
          }
        }
      }
      while (2)
      {
        unint64_t v68 = v66[1];
        if (v68 == v33)
        {
          if (v66[2] == v33)
          {
LABEL_182:
            uint64_t v104 = v66[3];
            uint64_t v103 = (void (**)(void, void, void))v66[4];
            v66[4] = 0;
            std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>>>::remove((uint64_t)buf, v35, v66);
            uint64_t v105 = *(void **)buf;
            if (*(void *)buf)
            {
              if (BYTE2(v240))
              {
                if (*(unsigned char *)(*(void *)buf + 40))
                {
                  uint64_t v106 = *(const void **)(*(void *)buf + 32);
                  if (v106) {
                    _Block_release(v106);
                  }
                }
              }
              operator delete(v105);
            }
            uint64_t v107 = mach_continuous_time();
            if (v107 <= 1) {
              uint64_t v108 = 1;
            }
            else {
              uint64_t v108 = v107;
            }
            v103[2](v103, 1, v108 - v104);
            _Block_release(v103);
            return 0;
          }
        }
        else
        {
          if (v68 >= *(void *)&v34) {
            v68 %= *(void *)&v34;
          }
          if (v68 != v37)
          {
LABEL_116:
            if (*(__int16 *)(a3 + 388) < 0) {
              return 0;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v70 = gconnectionLogObj;
            uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
            if (result)
            {
              int v71 = *(_DWORD *)(a3 + 368);
              *(_DWORD *)int buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_http2_received_ping_ack";
              __int16 v239 = 2082;
              uint64_t v240 = (void *)(a3 + 390);
              __int16 v241 = 2080;
              BOOL v242 = " ";
              __int16 v243 = 1024;
              int v244 = v71;
              __int16 v245 = 2048;
              *(void *)uint64_t v246 = v33;
              uint64_t v17 = "%{public}s %{public}s%s<i%u> unrecognized ping ack data %llu";
              uint64_t v18 = v70;
              os_log_type_t v19 = OS_LOG_TYPE_ERROR;
              uint32_t v20 = 48;
              goto LABEL_133;
            }
            return result;
          }
        }
        uint64_t v66 = (void *)*v66;
        if (!v66) {
          goto LABEL_116;
        }
        continue;
      }
    case 7:
      nw_http2_connection_receive_goaway(a3, *((_DWORD *)a2 + 4));
      return 0;
    case 8:
      uint64_t result = 0;
      if (*(__int16 *)(a3 + 388) < 0 || !gLogDatapath) {
        return result;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v38 = gconnectionLogObj;
      uint64_t result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      if (!result) {
        return result;
      }
      int v39 = *(_DWORD *)(a3 + 368);
      int v40 = *((_DWORD *)a2 + 2);
      int v41 = *((_DWORD *)a2 + 4);
      *(_DWORD *)int buf = 136447490;
      *(void *)&uint8_t buf[4] = "on_frame_recv_callback";
      __int16 v239 = 2082;
      uint64_t v240 = (void *)(a3 + 390);
      __int16 v241 = 2080;
      BOOL v242 = " ";
      __int16 v243 = 1024;
      int v244 = v39;
      __int16 v245 = 1024;
      *(_DWORD *)uint64_t v246 = v40;
      *(_WORD *)&v246[4] = 1024;
      *(_DWORD *)&v246[6] = v41;
      uint64_t v17 = "%{public}s %{public}s%s<i%u> received window update frame for stream %d, window size increment %d";
      uint64_t v18 = v38;
      os_log_type_t v19 = OS_LOG_TYPE_DEBUG;
LABEL_98:
      uint32_t v20 = 50;
      goto LABEL_133;
    default:
      return 0;
  }
}

uint64_t ___ZL22on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    uint64_t result = strcmp(__s1, "?1");
    int v3 = (result == 0) << 17;
  }
  else
  {
    int v3 = 0;
  }
  uint64_t v4 = *(void *)(v2 + 32);
  int v5 = *(unsigned __int16 *)(v4 + 188);
  v4 += 188;
  unsigned int v6 = (v5 | (*(unsigned __int8 *)(v4 + 2) << 16)) & 0xFFFDFFFF | v3;
  *(_WORD *)uint64_t v4 = v6;
  *(unsigned char *)(v4 + 2) = BYTE2(v6);
  return result;
}

uint64_t ___ZL22on_frame_recv_callbackP15nghttp2_sessionPK13nghttp2_framePv_block_invoke_2(uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    uint64_t result = strcmp(__s1, "connect-udp");
    if (result)
    {
      uint64_t result = strcmp(__s1, "connect-ip");
      int v4 = (result == 0) << 18;
    }
    else
    {
      int v4 = 0x40000;
    }
  }
  else
  {
    int v4 = 0;
  }
  uint64_t v5 = *(void *)(v2 + 32);
  int v6 = *(unsigned __int16 *)(v5 + 188);
  v5 += 188;
  unsigned int v7 = (v6 | (*(unsigned __int8 *)(v5 + 2) << 16)) & 0xFFFBFFFF | v4;
  *(_WORD *)uint64_t v5 = v7;
  *(unsigned char *)(v5 + 2) = BYTE2(v7);
  return result;
}

uint64_t std::__hash_table<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::__unordered_map_hasher<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::hash<unsigned long long>,std::equal_to<unsigned long long>,true>,std::__unordered_map_equal<unsigned long long,std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>,std::equal_to<unsigned long long>,std::hash<unsigned long long>,true>,std::allocator<std::__hash_value_type<unsigned long long,std::pair<unsigned long long,nw::retained_ptr<void({block_pointer})(BOOL,unsigned long long)>>>>>::remove(uint64_t result, void *a2, void *a3)
{
  int8x8_t v3 = (int8x8_t)a2[1];
  unint64_t v4 = a3[1];
  uint8x8_t v5 = (uint8x8_t)vcnt_s8(v3);
  v5.i16[0] = vaddlv_u8(v5);
  if (v5.u32[0] > 1uLL)
  {
    if (v4 >= *(void *)&v3) {
      v4 %= *(void *)&v3;
    }
  }
  else
  {
    v4 &= *(void *)&v3 - 1;
  }
  int v6 = *(void **)(*a2 + 8 * v4);
  do
  {
    unsigned int v7 = v6;
    int v6 = (void *)*v6;
  }
  while (v6 != a3);
  if (v7 == a2 + 2) {
    goto LABEL_18;
  }
  unint64_t v8 = v7[1];
  if (v5.u32[0] > 1uLL)
  {
    if (v8 >= *(void *)&v3) {
      v8 %= *(void *)&v3;
    }
  }
  else
  {
    v8 &= *(void *)&v3 - 1;
  }
  if (v8 != v4)
  {
LABEL_18:
    if (!*a3) {
      goto LABEL_19;
    }
    unint64_t v9 = *(void *)(*a3 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v9 >= *(void *)&v3) {
        v9 %= *(void *)&v3;
      }
    }
    else
    {
      v9 &= *(void *)&v3 - 1;
    }
    if (v9 != v4) {
LABEL_19:
    }
      *(void *)(*a2 + 8 * v4) = 0;
  }
  uint64_t v10 = *a3;
  if (*a3)
  {
    unint64_t v11 = *(void *)(v10 + 8);
    if (v5.u32[0] > 1uLL)
    {
      if (v11 >= *(void *)&v3) {
        v11 %= *(void *)&v3;
      }
    }
    else
    {
      v11 &= *(void *)&v3 - 1;
    }
    if (v11 != v4)
    {
      *(void *)(*a2 + 8 * v11) = v7;
      uint64_t v10 = *a3;
    }
  }
  *unsigned int v7 = v10;
  *a3 = 0;
  --a2[3];
  *(void *)uint64_t result = a3;
  *(void *)(result + 8) = a2 + 2;
  *(unsigned char *)(result + 16) = 1;
  return result;
}

void nw_http2_connection_receive_goaway(uint64_t a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447234;
      unint64_t v11 = "nw_http2_connection_receive_goaway";
      __int16 v12 = 2082;
      uint64_t v13 = a1 + 390;
      __int16 v14 = 2080;
      uint64_t v15 = " ";
      __int16 v16 = 1024;
      int v17 = v7;
      __int16 v18 = 1024;
      int v19 = a2;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received complete GOAWAY frame, last_stream_id %d", buf, 0x2Cu);
    }
  }
  *(_WORD *)(a1 + 388) |= 2u;
  unint64_t v4 = *(char **)(a1 + 160);
  if (v4)
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 0x40000000;
    void v8[2] = ___ZL34nw_http2_connection_receive_goawayP17nw_protocol_http2i_block_invoke;
    v8[3] = &__block_descriptor_tmp_59_83865;
    v8[4] = a1;
    int v9 = a2;
    nw_hash_table_apply(v4, (uint64_t)v8);
  }
  uint64_t v5 = *(void *)(a1 + 88);
  if (v5)
  {
    if (*(void *)v5)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v5, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    }
    else
    {
      *(_OWORD *)(v5 + 32) = xmmword_183D5CD50;
      if (*(unsigned char *)(v5 + 48))
      {
        if (*(unsigned char *)(v5 + 49)) {
          nw_queue_source_run_timer(v5);
        }
      }
    }
  }
}

uint64_t ___ZL34nw_http2_connection_receive_goawayP17nw_protocol_http2i_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    if (*(_DWORD *)(object + 176) <= *(_DWORD *)(a1 + 40))
    {
      if (((*(unsigned __int16 *)(object + 188) | (*(unsigned __int8 *)(object + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v23 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v25 = *(_DWORD *)(v5 + 176);
          int v24 = *(_DWORD *)(v5 + 180);
          int v26 = *(_DWORD *)(a1 + 40);
          int v34 = 136448002;
          uint64_t v35 = "nw_http2_connection_receive_goaway_block_invoke";
          __int16 v36 = 2082;
          unint64_t v37 = (const char *)(v5 + 191);
          __int16 v38 = 2080;
          int v39 = " ";
          __int16 v40 = 1024;
          int v41 = v24;
          __int16 v42 = 1024;
          *(_DWORD *)int v43 = v25;
          *(_WORD *)&void v43[4] = 2048;
          *(void *)&v43[6] = a2;
          *(_WORD *)&v43[14] = 1024;
          *(_DWORD *)&v43[16] = v25;
          __int16 v44 = 1024;
          int v45 = v26;
          __int16 v12 = "%{public}s %{public}s%s<i%u:s%d> stream in node %p in id table will remain active because its stream id "
                "(%d) is less than %d, skipping";
          uint64_t v13 = v23;
          os_log_type_t v14 = OS_LOG_TYPE_ERROR;
          uint32_t v15 = 66;
          goto LABEL_28;
        }
      }
    }
    else
    {
      uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
      int v7 = *(_DWORD *)(v5 + 176);
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v28 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v30 = *(_DWORD *)(v5 + 176);
          int v29 = *(_DWORD *)(v5 + 180);
          int v34 = 136447490;
          uint64_t v35 = "nw_http2_connection_receive_goaway_block_invoke";
          __int16 v36 = 2082;
          unint64_t v37 = (const char *)(v5 + 191);
          __int16 v38 = 2080;
          int v39 = " ";
          __int16 v40 = 1024;
          int v41 = v29;
          __int16 v42 = 1024;
          *(_DWORD *)int v43 = v30;
          *(_WORD *)&void v43[4] = 1024;
          *(_DWORD *)&v43[6] = v30;
          _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> closing stream %d", (uint8_t *)&v34, 0x32u);
        }
      }
      nw_http2_stream_close(*(void *)(a1 + 32), v5);
      int v8 = (*(unsigned __int8 *)(v5 + 190) >> 3) & 1;
      if (!gLogDatapath) {
        LOBYTE(v8) = 1;
      }
      if (v6)
      {
        if ((v8 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v9 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v11 = *(_DWORD *)(v5 + 176);
            int v10 = *(_DWORD *)(v5 + 180);
            int v34 = 136447746;
            uint64_t v35 = "nw_http2_connection_receive_goaway_block_invoke";
            __int16 v36 = 2082;
            unint64_t v37 = (const char *)(v5 + 191);
            __int16 v38 = 2080;
            int v39 = " ";
            __int16 v40 = 1024;
            int v41 = v10;
            __int16 v42 = 1024;
            *(_DWORD *)int v43 = v11;
            *(_WORD *)&void v43[4] = 1024;
            *(_DWORD *)&v43[6] = v7;
            *(_WORD *)&unsigned char v43[10] = 2048;
            *(void *)&v43[12] = v5;
            __int16 v12 = "%{public}s %{public}s%s<i%u:s%d> deferring release of stream %d (%p), has associated input handler";
            uint64_t v13 = v9;
            os_log_type_t v14 = OS_LOG_TYPE_DEBUG;
            uint32_t v15 = 60;
LABEL_28:
            _os_log_impl(&dword_1830D4000, v13, v14, v12, (uint8_t *)&v34, v15);
          }
        }
      }
      else
      {
        if ((v8 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v31 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v33 = *(_DWORD *)(v5 + 176);
            int v32 = *(_DWORD *)(v5 + 180);
            int v34 = 136447746;
            uint64_t v35 = "nw_http2_connection_receive_goaway_block_invoke";
            __int16 v36 = 2082;
            unint64_t v37 = (const char *)(v5 + 191);
            __int16 v38 = 2080;
            int v39 = " ";
            __int16 v40 = 1024;
            int v41 = v32;
            __int16 v42 = 1024;
            *(_DWORD *)int v43 = v33;
            *(_WORD *)&void v43[4] = 1024;
            *(_DWORD *)&v43[6] = v7;
            *(_WORD *)&unsigned char v43[10] = 2048;
            *(void *)&v43[12] = v5;
            _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> destroying stream %d (%p) immediately, no associated input handler", (uint8_t *)&v34, 0x3Cu);
          }
        }
        nw_http2_stream_destroy((void **)v5);
      }
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 32);
    if (!v16 || (*(__int16 *)(v16 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v17 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v18 = *(void *)(a1 + 32);
        int v19 = (const char *)(v18 + 390);
        uint64_t v20 = "";
        BOOL v21 = v18 == 0;
        int v22 = *(_DWORD *)(v18 + 368);
        uint64_t v35 = "nw_http2_connection_receive_goaway_block_invoke";
        if (v21) {
          int v19 = "";
        }
        __int16 v36 = 2082;
        int v34 = 136447234;
        if (!v21) {
          uint64_t v20 = " ";
        }
        unint64_t v37 = v19;
        __int16 v38 = 2080;
        int v39 = v20;
        __int16 v40 = 1024;
        int v41 = v22;
        __int16 v42 = 2048;
        *(void *)int v43 = a2;
        __int16 v12 = "%{public}s %{public}s%s<i%u> stream in node %p in id table is NULL, skipping";
        uint64_t v13 = v17;
        os_log_type_t v14 = OS_LOG_TYPE_ERROR;
        uint32_t v15 = 48;
        goto LABEL_28;
      }
    }
  }
  return 1;
}

void sub_183CB27AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void std::destroy_at[abi:nn180100]<http2_stream,0>(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 168))
  {
    uint64_t v2 = *(void **)(a1 + 160);
    if (v2) {
      os_release(v2);
    }
  }
  *(void *)(a1 + 160) = 0;
  if (*(unsigned char *)(a1 + 152))
  {
    int8x8_t v3 = *(void **)(a1 + 144);
    if (v3) {
      os_release(v3);
    }
  }
  *(void *)(a1 + 144) = 0;
  unint64_t v4 = *(void **)(a1 + 120);
  if (v4)
  {
    *(void *)(a1 + 128) = v4;
    operator delete(v4);
  }
}

void nw_http2_stream_init(uint64_t a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)a1 = 0;
    *(void *)(a1 + 8) = a1;
    *(void *)(a1 + 16) = 0;
    *(void *)(a1 + 24) = a1 + 16;
    *(void *)(a1 + 104) = 0;
    *(void *)(a1 + 112) = 0;
    int v2 = *(_WORD *)(a1 + 188) & 0xEFFF | (*(unsigned __int8 *)(a1 + 190) << 16);
    *(_WORD *)(a1 + 188) &= ~0x1000u;
    *(unsigned char *)(a1 + 190) = BYTE2(v2);
    uint64_t v3 = _nw_http_parsed_fields_create();
    char v4 = *(unsigned char *)(a1 + 152);
    if (v4)
    {
      uint64_t v5 = *(void **)(a1 + 144);
      if (v5)
      {
        os_release(v5);
        char v4 = *(unsigned char *)(a1 + 152);
      }
    }
    *(void *)(a1 + 144) = v3;
    *(unsigned char *)(a1 + 152) = v4 | 1;
    BOOL v6 = nw_array_create();
    char v7 = *(unsigned char *)(a1 + 168);
    if (v7)
    {
      int v8 = *(void **)(a1 + 160);
      if (v8)
      {
        os_release(v8);
        char v7 = *(unsigned char *)(a1 + 168);
      }
    }
    __int16 v10 = *(_WORD *)(a1 + 188);
    uint64_t v9 = (_WORD *)(a1 + 188);
    *(void *)(v9 - 14) = v6;
    *((unsigned char *)v9 - 20) = v7 | 1;
    *((_DWORD *)v9 - 3) = -1;
    *((_DWORD *)v9 - 1) = 0x200000;
    *uint64_t v9 = v10 & 0xFE62 | 4;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v20 = "nw_http2_stream_init";
  int v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_http2_stream_init";
      os_log_type_t v14 = "%{public}s called with null stream";
      goto LABEL_23;
    }
    if (!v17)
    {
      __int16 v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (!os_log_type_enabled(v12, type)) {
        goto LABEL_24;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_http2_stream_init";
      os_log_type_t v14 = "%{public}s called with null stream, backtrace limit exceeded";
      goto LABEL_23;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    BOOL v16 = os_log_type_enabled(v12, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v20 = "nw_http2_stream_init";
        __int16 v21 = 2082;
        int v22 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_24;
    }
    if (v16)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_http2_stream_init";
      os_log_type_t v14 = "%{public}s called with null stream, no backtrace";
LABEL_23:
      _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
    }
  }
LABEL_24:
  if (v11) {
    free(v11);
  }
}

uint64_t nw_http2_add_to_id_table(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v53 = "nw_http2_add_to_id_table";
    int v22 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t v51 = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, &v51, &type)) {
      goto LABEL_52;
    }
    if (v51 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v24 = v51;
      if (!os_log_type_enabled(v23, v51)) {
        goto LABEL_52;
      }
      *(_DWORD *)int buf = 136446210;
      int v53 = "nw_http2_add_to_id_table";
      int v25 = "%{public}s called with null stream";
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v24 = v51;
      BOOL v45 = os_log_type_enabled(v23, v51);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)int buf = 136446466;
          int v53 = "nw_http2_add_to_id_table";
          __int16 v54 = 2082;
          uint64_t v55 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null stream, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_52;
      }
      if (!v45) {
        goto LABEL_52;
      }
      *(_DWORD *)int buf = 136446210;
      int v53 = "nw_http2_add_to_id_table";
      int v25 = "%{public}s called with null stream, no backtrace";
    }
    else
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v24 = v51;
      if (!os_log_type_enabled(v23, v51)) {
        goto LABEL_52;
      }
      *(_DWORD *)int buf = 136446210;
      int v53 = "nw_http2_add_to_id_table";
      int v25 = "%{public}s called with null stream, backtrace limit exceeded";
    }
LABEL_50:
    uint64_t v35 = v23;
    os_log_type_t v36 = v24;
LABEL_51:
    _os_log_impl(&dword_1830D4000, v35, v36, v25, buf, 0xCu);
    goto LABEL_52;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v38 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v40 = *(_DWORD *)(a2 + 176);
      int v39 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)int buf = 136447746;
      int v53 = "nw_http2_add_to_id_table";
      __int16 v54 = 2082;
      uint64_t v55 = (char *)(a2 + 191);
      __int16 v56 = 2080;
      os_log_type_t v57 = " ";
      __int16 v58 = 1024;
      int v59 = v39;
      __int16 v60 = 1024;
      int v61 = v40;
      __int16 v62 = 1024;
      *(_DWORD *)int v63 = v40;
      *(_WORD *)&v63[4] = 2048;
      *(void *)&v63[6] = a2;
      _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d (%p)", buf, 0x3Cu);
    }
  }
  os_log_type_t v51 = OS_LOG_TYPE_DEFAULT;
  uint64_t internal = *(void *)(a1 + 160);
  if (!internal)
  {
    uint64_t internal = nw_hash_table_create_internal(0x11u, 8, (const void *(*)(const void *, unsigned int *))stream_get_key, (unsigned int (*)(const void *, unsigned int))stream_key_hash, (BOOL (*)(const void *, const void *, unsigned int))stream_matches_key, 0);
    if (internal)
    {
      *(_DWORD *)(internal + 48) &= ~2u;
      *(void *)(a1 + 160) = internal;
      goto LABEL_7;
    }
    *(void *)(a1 + 160) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    int v53 = "nw_http2_add_to_id_table";
    int v22 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (__nwlog_fault(v22, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = gLogObj;
        os_log_type_t v24 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)int buf = 136446210;
        int v53 = "nw_http2_add_to_id_table";
        int v25 = "%{public}s nw_hash_table_create_no_lock failed";
        goto LABEL_50;
      }
      if (!v49)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v23 = gLogObj;
        os_log_type_t v24 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_52;
        }
        *(_DWORD *)int buf = 136446210;
        int v53 = "nw_http2_add_to_id_table";
        int v25 = "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded";
        goto LABEL_50;
      }
      int v26 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = gLogObj;
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v26)
      {
        if (v29)
        {
          *(_DWORD *)int buf = 136446466;
          int v53 = "nw_http2_add_to_id_table";
          __int16 v54 = 2082;
          uint64_t v55 = v26;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v26);
      }
      else if (v29)
      {
        *(_DWORD *)int buf = 136446210;
        int v53 = "nw_http2_add_to_id_table";
        int v25 = "%{public}s nw_hash_table_create_no_lock failed, no backtrace";
        uint64_t v35 = v27;
        os_log_type_t v36 = v28;
        goto LABEL_51;
      }
    }
LABEL_52:
    if (v22)
    {
      int v34 = (char *)v22;
      goto LABEL_54;
    }
    return 0;
  }
LABEL_7:
  BOOL v7 = nw_hash_table_add_object(internal, a2, (char *)&v51);
  int v8 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
  if (v51 == OS_LOG_TYPE_DEFAULT)
  {
    if ((v8 & 0x80000) != 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v11 = *(_DWORD *)(a2 + 176);
    int v10 = *(_DWORD *)(a2 + 180);
    *(_DWORD *)int buf = 136447490;
    int v53 = "nw_http2_add_to_id_table";
    __int16 v54 = 2082;
    uint64_t v55 = (char *)(a2 + 191);
    __int16 v56 = 2080;
    os_log_type_t v57 = " ";
    __int16 v58 = 1024;
    int v59 = v10;
    __int16 v60 = 1024;
    int v61 = v11;
    __int16 v62 = 1024;
    *(_DWORD *)int v63 = v11;
    __int16 v12 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (!__nwlog_fault(v12, &type, &v49)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v13 = gconnectionLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        int v16 = *(_DWORD *)(a2 + 176);
        int v15 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136447490;
        int v53 = "nw_http2_add_to_id_table";
        __int16 v54 = 2082;
        uint64_t v55 = (char *)(a2 + 191);
        __int16 v56 = 2080;
        os_log_type_t v57 = " ";
        __int16 v58 = 1024;
        int v59 = v15;
        __int16 v60 = 1024;
        int v61 = v16;
        __int16 v62 = 1024;
        *(_DWORD *)int v63 = v16;
        char v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d";
LABEL_45:
        _os_log_impl(&dword_1830D4000, v13, v14, v17, buf, 0x32u);
      }
    }
    else if (v49)
    {
      uint64_t v18 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v13 = gconnectionLogObj;
      os_log_type_t v14 = type;
      BOOL v19 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_46;
        }
        int v33 = *(_DWORD *)(a2 + 176);
        int v32 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136447490;
        int v53 = "nw_http2_add_to_id_table";
        __int16 v54 = 2082;
        uint64_t v55 = (char *)(a2 + 191);
        __int16 v56 = 2080;
        os_log_type_t v57 = " ";
        __int16 v58 = 1024;
        int v59 = v32;
        __int16 v60 = 1024;
        int v61 = v33;
        __int16 v62 = 1024;
        *(_DWORD *)int v63 = v33;
        char v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, no backtrace";
        goto LABEL_45;
      }
      if (v19)
      {
        int v21 = *(_DWORD *)(a2 + 176);
        int v20 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136447746;
        int v53 = "nw_http2_add_to_id_table";
        __int16 v54 = 2082;
        uint64_t v55 = (char *)(a2 + 191);
        __int16 v56 = 2080;
        os_log_type_t v57 = " ";
        __int16 v58 = 1024;
        int v59 = v20;
        __int16 v60 = 1024;
        int v61 = v21;
        __int16 v62 = 1024;
        *(_DWORD *)int v63 = v21;
        *(_WORD *)&v63[4] = 2082;
        *(void *)&v63[6] = v18;
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, dumping backtrace:%{public}s", buf, 0x3Cu);
      }
      free(v18);
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v13 = gconnectionLogObj;
      os_log_type_t v14 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        int v31 = *(_DWORD *)(a2 + 176);
        int v30 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136447490;
        int v53 = "nw_http2_add_to_id_table";
        __int16 v54 = 2082;
        uint64_t v55 = (char *)(a2 + 191);
        __int16 v56 = 2080;
        os_log_type_t v57 = " ";
        __int16 v58 = 1024;
        int v59 = v30;
        __int16 v60 = 1024;
        int v61 = v31;
        __int16 v62 = 1024;
        *(_DWORD *)int v63 = v31;
        char v17 = "%{public}s %{public}s%s<i%u:s%d> http2 already has stream id registered for %d, backtrace limit exceeded";
        goto LABEL_45;
      }
    }
LABEL_46:
    if (v12)
    {
      int v34 = (char *)v12;
LABEL_54:
      free(v34);
      return 0;
    }
    return 0;
  }
  uint64_t v9 = v7;
  if ((v8 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v41 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v43 = *(_DWORD *)(a2 + 176);
      int v42 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)int buf = 136447490;
      int v53 = "nw_http2_add_to_id_table";
      __int16 v54 = 2082;
      uint64_t v55 = (char *)(a2 + 191);
      __int16 v56 = 2080;
      os_log_type_t v57 = " ";
      __int16 v58 = 1024;
      int v59 = v42;
      __int16 v60 = 1024;
      int v61 = v43;
      __int16 v62 = 1024;
      *(_DWORD *)int v63 = v43;
      _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> added stream %d to stream id hash table", buf, 0x32u);
    }
  }
  if (a3)
  {
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v46 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v48 = *(_DWORD *)(a2 + 176);
        int v47 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136448002;
        int v53 = "nw_http2_add_to_id_table";
        __int16 v54 = 2082;
        uint64_t v55 = (char *)(a2 + 191);
        __int16 v56 = 2080;
        os_log_type_t v57 = " ";
        __int16 v58 = 1024;
        int v59 = v47;
        __int16 v60 = 1024;
        int v61 = v48;
        __int16 v62 = 2048;
        *(void *)int v63 = a2;
        *(_WORD *)&v63[8] = 2048;
        *(void *)&v63[10] = v9;
        __int16 v64 = 2048;
        uint64_t v65 = a3;
        _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> connecting stream %p node %p with protocol %p", buf, 0x4Au);
      }
    }
    *(void *)nw_hash_node_get_extra(v9) = a3;
  }
  return v9;
}

BOOL stream_matches_key(uint64_t a1, _DWORD *a2)
{
  return *(_DWORD *)(a1 + 176) == *a2;
}

uint64_t stream_get_key(uint64_t a1, _DWORD *a2)
{
  *a2 = 4;
  return a1 + 176;
}

uint64_t on_header_callback(uint64_t a1, uint64_t a2, unint64_t a3, uint64_t a4, const char *a5, int64_t a6, uint64_t a7, uint64_t a8)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    char v49 = __nwlog_obj();
    if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)int buf = 136446722;
      int v63 = "on_header_callback";
      __int16 v64 = 2082;
      uint64_t v65 = a3;
      __int16 v66 = 2082;
      uint64_t v67 = a5;
      _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s called name %{public}s value %{public}s", buf, 0x20u);
    }
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v63 = "on_header_callback";
    int v50 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (!__nwlog_fault(v50, &type, &v60)) {
      goto LABEL_82;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v51 = __nwlog_obj();
      os_log_type_t v52 = type;
      if (!os_log_type_enabled(v51, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)int buf = 136446210;
      int v63 = "on_header_callback";
      int v53 = "%{public}s nghttp2 user data is NULL, not http2";
    }
    else if (v60)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v51 = __nwlog_obj();
      os_log_type_t v52 = type;
      BOOL v55 = os_log_type_enabled(v51, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)int buf = 136446466;
          int v63 = "on_header_callback";
          __int16 v64 = 2082;
          uint64_t v65 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s nghttp2 user data is NULL, not http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_82;
      }
      if (!v55)
      {
LABEL_82:
        if (v50) {
          free(v50);
        }
        return 4294966394;
      }
      *(_DWORD *)int buf = 136446210;
      int v63 = "on_header_callback";
      int v53 = "%{public}s nghttp2 user data is NULL, not http2, no backtrace";
    }
    else
    {
      os_log_type_t v51 = __nwlog_obj();
      os_log_type_t v52 = type;
      if (!os_log_type_enabled(v51, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)int buf = 136446210;
      int v63 = "on_header_callback";
      int v53 = "%{public}s nghttp2 user data is NULL, not http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v51, v52, v53, buf, 0xCu);
    goto LABEL_82;
  }
  int v14 = *(unsigned __int8 *)(a2 + 12);
  if (v14 == 5)
  {
    if (*(__int16 *)(a8 + 388) < 0) {
      return 4294966775;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v19 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775;
    }
    int v20 = *(_DWORD *)(a8 + 368);
    *(_DWORD *)int buf = 136446978;
    int v63 = "on_header_callback";
    __int16 v64 = 2082;
    uint64_t v65 = a8 + 390;
    __int16 v66 = 2080;
    uint64_t v67 = " ";
    __int16 v68 = 1024;
    int v69 = v20;
    int v21 = "%{public}s %{public}s%s<i%u> push promise frames are currently not supported";
    int v22 = v19;
    uint32_t v23 = 38;
    goto LABEL_42;
  }
  if (v14 != 1)
  {
    if ((*(__int16 *)(a8 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v24 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v25 = *(_DWORD *)(a8 + 368);
        *(_DWORD *)int buf = 136446978;
        int v63 = "on_header_callback";
        __int16 v64 = 2082;
        uint64_t v65 = a8 + 390;
        __int16 v66 = 2080;
        uint64_t v67 = " ";
        __int16 v68 = 1024;
        int v69 = v25;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> returning callback failure with unknown error", buf, 0x26u);
      }
    }
    return 4294966394;
  }
  unsigned int v15 = *(_DWORD *)(a2 + 56);
  if (v15 > 3 || v15 == 2)
  {
    if (*(__int16 *)(a8 + 388) < 0) {
      return 4294966775;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v34 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775;
    }
    int v35 = *(_DWORD *)(a8 + 368);
    int v36 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)int buf = 136447234;
    int v63 = "on_header_callback";
    __int16 v64 = 2082;
    uint64_t v65 = a8 + 390;
    __int16 v66 = 2080;
    uint64_t v67 = " ";
    __int16 v68 = 1024;
    int v69 = v35;
    __int16 v70 = 1024;
    int v71 = v36;
    int v21 = "%{public}s %{public}s%s<i%u> ERROR: Got headers for stream %d, a stream that doesn't exist.";
    int v22 = v34;
    uint32_t v23 = 44;
    goto LABEL_42;
  }
  uint64_t stream_from_id = nw_http2_get_stream_from_id(a8, *(_DWORD *)(a2 + 8), 0);
  if (stream_from_id)
  {
    uint64_t v17 = stream_from_id;
    if (((*(unsigned __int16 *)(stream_from_id + 188) | (*(unsigned __int8 *)(stream_from_id + 190) << 16)) & 0x80000) == 0
      && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v56 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v58 = *(_DWORD *)(v17 + 176);
        int v57 = *(_DWORD *)(v17 + 180);
        int v59 = "response";
        if (!*(_DWORD *)(a2 + 56)) {
          int v59 = "request";
        }
        *(_DWORD *)int buf = 136448258;
        int v63 = "on_header_callback";
        __int16 v64 = 2082;
        uint64_t v65 = v17 + 191;
        __int16 v66 = 2080;
        uint64_t v67 = " ";
        __int16 v68 = 1024;
        int v69 = v57;
        __int16 v70 = 1024;
        int v71 = v58;
        __int16 v72 = 2080;
        *(void *)uint64_t v73 = v59;
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v58;
        __int16 v74 = 2082;
        unint64_t v75 = a3;
        __int16 v76 = 2082;
        int v77 = a5;
        _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> received header %s on stream %d: (%{public}s: %{public}s)", buf, 0x50u);
      }
    }
    if (nw_http_parsed_fields_add(*(void **)(v17 + 144), a3, a4, a5, a6, 1)) {
      return 0;
    }
    if (((*(unsigned __int16 *)(v17 + 188) | (*(unsigned __int8 *)(v17 + 190) << 16)) & 0x80000) != 0) {
      return 4294966775;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v37 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 4294966775;
    }
    int v39 = *(_DWORD *)(v17 + 176);
    int v38 = *(_DWORD *)(v17 + 180);
    int v40 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)int buf = 136448002;
    int v63 = "on_header_callback";
    __int16 v64 = 2082;
    uint64_t v65 = v17 + 191;
    __int16 v66 = 2080;
    uint64_t v67 = " ";
    __int16 v68 = 1024;
    int v69 = v38;
    __int16 v70 = 1024;
    int v71 = v39;
    __int16 v72 = 1040;
    *(_DWORD *)uint64_t v73 = a4;
    *(_WORD *)&v73[4] = 2080;
    *(void *)&v73[6] = a3;
    __int16 v74 = 1024;
    LODWORD(v75) = v40;
    int v21 = "%{public}s %{public}s%s<i%u:s%d> invalid header field %.*s received on stream %d";
    int v22 = v37;
    uint32_t v23 = 66;
LABEL_42:
    _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_ERROR, v21, buf, v23);
    return 4294966775;
  }
  if ((*(__int16 *)(a8 + 388) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v26 = *(_DWORD *)(a8 + 368);
    int v27 = *(_DWORD *)(a2 + 8);
    *(_DWORD *)int buf = 136447234;
    int v63 = "on_header_callback";
    __int16 v64 = 2082;
    uint64_t v65 = a8 + 390;
    __int16 v66 = 2080;
    uint64_t v67 = " ";
    __int16 v68 = 1024;
    int v69 = v26;
    __int16 v70 = 1024;
    int v71 = v27;
    os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (!__nwlog_fault(v28, &type, &v60)) {
      goto LABEL_58;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v29 = gconnectionLogObj;
      os_log_type_t v30 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_58;
      }
      int v31 = *(_DWORD *)(a8 + 368);
      int v32 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)int buf = 136447234;
      int v63 = "on_header_callback";
      __int16 v64 = 2082;
      uint64_t v65 = a8 + 390;
      __int16 v66 = 2080;
      uint64_t v67 = " ";
      __int16 v68 = 1024;
      int v69 = v31;
      __int16 v70 = 1024;
      int v71 = v32;
      int v33 = "%{public}s %{public}s%s<i%u> failed to find stream %d";
    }
    else if (v60)
    {
      int v41 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v29 = gconnectionLogObj;
      os_log_type_t v30 = type;
      BOOL v42 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v41)
      {
        if (v42)
        {
          int v43 = *(_DWORD *)(a8 + 368);
          int v44 = *(_DWORD *)(a2 + 8);
          *(_DWORD *)int buf = 136447490;
          int v63 = "on_header_callback";
          __int16 v64 = 2082;
          uint64_t v65 = a8 + 390;
          __int16 v66 = 2080;
          uint64_t v67 = " ";
          __int16 v68 = 1024;
          int v69 = v43;
          __int16 v70 = 1024;
          int v71 = v44;
          __int16 v72 = 2082;
          *(void *)uint64_t v73 = v41;
          _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s %{public}s%s<i%u> failed to find stream %d, dumping backtrace:%{public}s", buf, 0x36u);
        }
        free(v41);
        goto LABEL_58;
      }
      if (!v42)
      {
LABEL_58:
        if (v28) {
          free(v28);
        }
        return 4294966775;
      }
      int v47 = *(_DWORD *)(a8 + 368);
      int v48 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)int buf = 136447234;
      int v63 = "on_header_callback";
      __int16 v64 = 2082;
      uint64_t v65 = a8 + 390;
      __int16 v66 = 2080;
      uint64_t v67 = " ";
      __int16 v68 = 1024;
      int v69 = v47;
      __int16 v70 = 1024;
      int v71 = v48;
      int v33 = "%{public}s %{public}s%s<i%u> failed to find stream %d, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v29 = gconnectionLogObj;
      os_log_type_t v30 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_58;
      }
      int v45 = *(_DWORD *)(a8 + 368);
      int v46 = *(_DWORD *)(a2 + 8);
      *(_DWORD *)int buf = 136447234;
      int v63 = "on_header_callback";
      __int16 v64 = 2082;
      uint64_t v65 = a8 + 390;
      __int16 v66 = 2080;
      uint64_t v67 = " ";
      __int16 v68 = 1024;
      int v69 = v45;
      __int16 v70 = 1024;
      int v71 = v46;
      int v33 = "%{public}s %{public}s%s<i%u> failed to find stream %d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v29, v30, v33, buf, 0x2Cu);
    goto LABEL_58;
  }
  return 4294966775;
}

void nw_protocol_http2_error(nw_protocol *a1, nw_protocol *a2, int a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_protocol_http2_error";
    int v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_protocol_http2_error";
      uint64_t v17 = "%{public}s called with null protocol";
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v29 = "nw_protocol_http2_error";
          __int16 v30 = 2082;
          int v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_61:
        if (!v14) {
          return;
        }
        goto LABEL_62;
      }
      if (!v19) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_protocol_http2_error";
      uint64_t v17 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      unsigned int v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_protocol_http2_error";
      uint64_t v17 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_60;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_protocol_http2_error";
    int v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26)) {
      goto LABEL_61;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        unsigned int v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (!os_log_type_enabled(v15, type)) {
          goto LABEL_61;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_protocol_http2_error";
        uint64_t v17 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_60;
      }
      int v20 = (char *)__nw_create_backtrace_string();
      unsigned int v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v21 = os_log_type_enabled(v15, type);
      if (!v20)
      {
        if (!v21) {
          goto LABEL_61;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v29 = "nw_protocol_http2_error";
        uint64_t v17 = "%{public}s called with null http2, no backtrace";
        goto LABEL_60;
      }
      if (v21)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v29 = "nw_protocol_http2_error";
        __int16 v30 = 2082;
        int v31 = v20;
        int v22 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_45:
        _os_log_impl(&dword_1830D4000, v15, v16, v22, buf, 0x16u);
      }
LABEL_46:
      free(v20);
      if (!v14) {
        return;
      }
LABEL_62:
      free(v14);
      return;
    }
    unsigned int v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    if (!os_log_type_enabled(v15, type)) {
      goto LABEL_61;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_protocol_http2_error";
    uint64_t v17 = "%{public}s called with null http2";
LABEL_60:
    _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
    goto LABEL_61;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v29 = "nw_protocol_http2_error";
    int v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_protocol_http2_error";
      uint64_t v17 = "%{public}s called with null other_protocol";
      goto LABEL_60;
    }
    if (!v26)
    {
      unsigned int v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (!os_log_type_enabled(v15, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_protocol_http2_error";
      uint64_t v17 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_60;
    }
    int v20 = (char *)__nw_create_backtrace_string();
    unsigned int v15 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v23 = os_log_type_enabled(v15, type);
    if (!v20)
    {
      if (!v23) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v29 = "nw_protocol_http2_error";
      uint64_t v17 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_60;
    }
    if (v23)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v29 = "nw_protocol_http2_error";
      __int16 v30 = 2082;
      int v31 = v20;
      int v22 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  if (a3)
  {
    uint64_t v5 = (char *)*((void *)handle + 19);
    if (v5)
    {
      v24[0] = MEMORY[0x1E4F143A8];
      v24[1] = 0x40000000;
      v24[2] = ___ZL23nw_protocol_http2_errorP11nw_protocolS0_i_block_invoke;
      v24[3] = &__block_descriptor_tmp_20_84026;
      int v25 = a3;
      v24[4] = handle;
      v24[5] = a2;
      nw_hash_table_apply(v5, (uint64_t)v24);
      return;
    }
    if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v12 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v13 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447234;
        BOOL v29 = "nw_protocol_http2_error";
        __int16 v30 = 2082;
        int v31 = handle + 390;
        __int16 v32 = 2080;
        int v33 = " ";
        __int16 v34 = 1024;
        int v35 = v13;
        __int16 v36 = 1024;
        int v37 = a3;
        int v8 = "%{public}s %{public}s%s<i%u> cannot pass error %d up the stack, protocol table is NULL";
        uint64_t v9 = v12;
        os_log_type_t v10 = OS_LOG_TYPE_ERROR;
        uint32_t v11 = 44;
        goto LABEL_18;
      }
    }
  }
  else if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v7 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      BOOL v29 = "nw_protocol_http2_error";
      __int16 v30 = 2082;
      int v31 = handle + 390;
      __int16 v32 = 2080;
      int v33 = " ";
      __int16 v34 = 1024;
      int v35 = v7;
      int v8 = "%{public}s %{public}s%s<i%u> suppressing error 0";
      uint64_t v9 = v6;
      os_log_type_t v10 = OS_LOG_TYPE_DEBUG;
      uint32_t v11 = 38;
LABEL_18:
      _os_log_impl(&dword_1830D4000, v9, v10, v8, buf, v11);
    }
  }
}

uint64_t ___ZL23nw_protocol_http2_errorP11nw_protocolS0_i_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v99 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  uint64_t v5 = *(void *)nw_hash_node_get_extra(a2);
  if (!object)
  {
    if (v5)
    {
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) != 0) {
        return 1;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v8 = *(_DWORD *)(v5 + 176);
      int v7 = *(_DWORD *)(v5 + 180);
      *(_DWORD *)int buf = 136447490;
      BOOL v90 = "nw_protocol_http2_error_block_invoke";
      __int16 v91 = 2082;
      int v92 = (const char *)(v5 + 191);
      __int16 v93 = 2080;
      BOOL v94 = " ";
      __int16 v95 = 1024;
      int v96 = v7;
      __int16 v97 = 1024;
      *(_DWORD *)int v98 = v8;
      *(_WORD *)&v98[4] = 2048;
      *(void *)&v98[6] = a2;
      uint64_t v9 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v87 = 0;
      if (!__nwlog_fault(v9, &type, &v87)) {
        goto LABEL_32;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v10 = gconnectionLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_32;
        }
        int v13 = *(_DWORD *)(v5 + 176);
        int v12 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)int buf = 136447490;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = (const char *)(v5 + 191);
        __int16 v93 = 2080;
        BOOL v94 = " ";
        __int16 v95 = 1024;
        int v96 = v12;
        __int16 v97 = 1024;
        *(_DWORD *)int v98 = v13;
        *(_WORD *)&v98[4] = 2048;
        *(void *)&v98[6] = a2;
        int v14 = "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol";
      }
      else if (v87)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v10 = gconnectionLogObj;
        os_log_type_t v11 = type;
        BOOL v16 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (backtrace_string)
        {
          if (v16)
          {
            int v18 = *(_DWORD *)(v5 + 176);
            int v17 = *(_DWORD *)(v5 + 180);
            *(_DWORD *)int buf = 136447746;
            BOOL v90 = "nw_protocol_http2_error_block_invoke";
            __int16 v91 = 2082;
            int v92 = (const char *)(v5 + 191);
            __int16 v93 = 2080;
            BOOL v94 = " ";
            __int16 v95 = 1024;
            int v96 = v17;
            __int16 v97 = 1024;
            *(_DWORD *)int v98 = v18;
            *(_WORD *)&v98[4] = 2048;
            *(void *)&v98[6] = a2;
            *(_WORD *)&v98[14] = 2082;
            *(void *)&v98[16] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol, dumping backtrace:%{public}s", buf, 0x40u);
          }
          free(backtrace_string);
          goto LABEL_32;
        }
        if (!v16)
        {
LABEL_32:
          if (!v9) {
            return 1;
          }
          BOOL v23 = (char *)v9;
LABEL_34:
          free(v23);
          return 1;
        }
        int v22 = *(_DWORD *)(v5 + 176);
        int v21 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)int buf = 136447490;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = (const char *)(v5 + 191);
        __int16 v93 = 2080;
        BOOL v94 = " ";
        __int16 v95 = 1024;
        int v96 = v21;
        __int16 v97 = 1024;
        *(_DWORD *)int v98 = v22;
        *(_WORD *)&v98[4] = 2048;
        *(void *)&v98[6] = a2;
        int v14 = "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v10 = gconnectionLogObj;
        os_log_type_t v11 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_32;
        }
        int v20 = *(_DWORD *)(v5 + 176);
        int v19 = *(_DWORD *)(v5 + 180);
        *(_DWORD *)int buf = 136447490;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = (const char *)(v5 + 191);
        __int16 v93 = 2080;
        BOOL v94 = " ";
        __int16 v95 = 1024;
        int v96 = v19;
        __int16 v97 = 1024;
        *(_DWORD *)int v98 = v20;
        *(_WORD *)&v98[4] = 2048;
        *(void *)&v98[6] = a2;
        int v14 = "%{public}s %{public}s%s<i%u:s%d> node %p did not contain protocol, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v10, v11, v14, buf, 0x36u);
      goto LABEL_32;
    }
    uint64_t v47 = *(void *)(a1 + 32);
    if (v47 && *(__int16 *)(v47 + 388) < 0) {
      return 1;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v48 = *(void *)(a1 + 32);
    char v49 = (const char *)(v48 + 390);
    BOOL v50 = v48 == 0;
    int v51 = *(_DWORD *)(v48 + 368);
    if (v50) {
      char v49 = "";
    }
    *(_DWORD *)int buf = 136447234;
    BOOL v90 = "nw_protocol_http2_error_block_invoke";
    if (v50) {
      os_log_type_t v52 = "";
    }
    else {
      os_log_type_t v52 = " ";
    }
    __int16 v91 = 2082;
    int v92 = v49;
    __int16 v93 = 2080;
    BOOL v94 = v52;
    __int16 v95 = 1024;
    int v96 = v51;
    __int16 v97 = 2048;
    *(void *)int v98 = a2;
    int v53 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v87 = 0;
    if (__nwlog_fault(v53, &type, &v87))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v54 = gconnectionLogObj;
        os_log_type_t v55 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_109;
        }
        uint64_t v56 = *(void *)(a1 + 32);
        int v57 = (const char *)(v56 + 390);
        BOOL v58 = v56 == 0;
        if (!v56) {
          int v57 = "";
        }
        int v59 = *(_DWORD *)(v56 + 368);
        if (v58) {
          char v60 = "";
        }
        else {
          char v60 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = v57;
        __int16 v93 = 2080;
        BOOL v94 = v60;
        __int16 v95 = 1024;
        int v96 = v59;
        __int16 v97 = 2048;
        *(void *)int v98 = a2;
        int v61 = "%{public}s %{public}s%s<i%u> node %p did not contain protocol";
        goto LABEL_108;
      }
      if (!v87)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v54 = gconnectionLogObj;
        os_log_type_t v55 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_109;
        }
        uint64_t v69 = *(void *)(a1 + 32);
        __int16 v70 = (const char *)(v69 + 390);
        BOOL v71 = v69 == 0;
        if (!v69) {
          __int16 v70 = "";
        }
        int v72 = *(_DWORD *)(v69 + 368);
        if (v71) {
          uint64_t v73 = "";
        }
        else {
          uint64_t v73 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = v70;
        __int16 v93 = 2080;
        BOOL v94 = v73;
        __int16 v95 = 1024;
        int v96 = v72;
        __int16 v97 = 2048;
        *(void *)int v98 = a2;
        int v61 = "%{public}s %{public}s%s<i%u> node %p did not contain protocol, backtrace limit exceeded";
        goto LABEL_108;
      }
      __int16 v62 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v54 = gconnectionLogObj;
      os_log_type_t v55 = type;
      BOOL v63 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v62)
      {
        if (v63)
        {
          uint64_t v64 = *(void *)(a1 + 32);
          uint64_t v65 = (const char *)(v64 + 390);
          BOOL v66 = v64 == 0;
          if (!v64) {
            uint64_t v65 = "";
          }
          int v67 = *(_DWORD *)(v64 + 368);
          if (v66) {
            __int16 v68 = "";
          }
          else {
            __int16 v68 = " ";
          }
          *(_DWORD *)int buf = 136447490;
          BOOL v90 = "nw_protocol_http2_error_block_invoke";
          __int16 v91 = 2082;
          int v92 = v65;
          __int16 v93 = 2080;
          BOOL v94 = v68;
          __int16 v95 = 1024;
          int v96 = v67;
          __int16 v97 = 2048;
          *(void *)int v98 = a2;
          *(_WORD *)&v98[8] = 2082;
          *(void *)&v98[10] = v62;
          _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s %{public}s%s<i%u> node %p did not contain protocol, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(v62);
        goto LABEL_109;
      }
      if (v63)
      {
        uint64_t v74 = *(void *)(a1 + 32);
        unint64_t v75 = (const char *)(v74 + 390);
        BOOL v76 = v74 == 0;
        if (!v74) {
          unint64_t v75 = "";
        }
        int v77 = *(_DWORD *)(v74 + 368);
        if (v76) {
          uint64_t v78 = "";
        }
        else {
          uint64_t v78 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = v75;
        __int16 v93 = 2080;
        BOOL v94 = v78;
        __int16 v95 = 1024;
        int v96 = v77;
        __int16 v97 = 2048;
        *(void *)int v98 = a2;
        int v61 = "%{public}s %{public}s%s<i%u> node %p did not contain protocol, no backtrace";
LABEL_108:
        _os_log_impl(&dword_1830D4000, v54, v55, v61, buf, 0x30u);
      }
    }
LABEL_109:
    if (!v53) {
      return 1;
    }
    BOOL v23 = (char *)v53;
    goto LABEL_34;
  }
  uint64_t v6 = *(void *)(object + 24);
  if (v6 && *(void *)(v6 + 56))
  {
    if (v5)
    {
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) != 0 || !gLogDatapath) {
        goto LABEL_7;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v43 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_7;
      }
      int v45 = *(_DWORD *)(v5 + 176);
      int v44 = *(_DWORD *)(v5 + 180);
      int v46 = *(_DWORD *)(a1 + 48);
      *(_DWORD *)int buf = 136447746;
      BOOL v90 = "nw_protocol_http2_error_block_invoke";
      __int16 v91 = 2082;
      int v92 = (const char *)(v5 + 191);
      __int16 v93 = 2080;
      BOOL v94 = " ";
      __int16 v95 = 1024;
      int v96 = v44;
      __int16 v97 = 1024;
      *(_DWORD *)int v98 = v45;
      *(_WORD *)&v98[4] = 1024;
      *(_DWORD *)&v98[6] = v46;
      *(_WORD *)&v98[10] = 2048;
      *(void *)&v98[12] = object;
      int v40 = "%{public}s %{public}s%s<i%u:s%d> passing error %d to input protocol %p";
      int v41 = v43;
      uint32_t v42 = 60;
    }
    else
    {
      uint64_t v32 = *(void *)(a1 + 32);
      if (v32 && *(__int16 *)(v32 + 388) < 0 || !gLogDatapath) {
        goto LABEL_7;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v33 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_7;
      }
      uint64_t v34 = *(void *)(a1 + 32);
      int v35 = "";
      int v36 = *(_DWORD *)(v34 + 368);
      BOOL v37 = v34 == 0;
      if (v34) {
        uint64_t v38 = (const char *)(v34 + 390);
      }
      else {
        uint64_t v38 = "";
      }
      int v39 = *(_DWORD *)(a1 + 48);
      if (!v37) {
        int v35 = " ";
      }
      *(_DWORD *)int buf = 136447490;
      BOOL v90 = "nw_protocol_http2_error_block_invoke";
      __int16 v91 = 2082;
      int v92 = v38;
      __int16 v93 = 2080;
      BOOL v94 = v35;
      __int16 v95 = 1024;
      int v96 = v36;
      __int16 v97 = 1024;
      *(_DWORD *)int v98 = v39;
      *(_WORD *)&v98[4] = 2048;
      *(void *)&v98[6] = object;
      int v40 = "%{public}s %{public}s%s<i%u> passing error %d to input protocol %p";
      int v41 = v33;
      uint32_t v42 = 54;
    }
    _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, v40, buf, v42);
LABEL_7:
    (*(void (**)(uint64_t, void, void))(*(void *)(object + 24) + 56))(object, *(void *)(a1 + 40), *(unsigned int *)(a1 + 48));
    return 1;
  }
  if (v5)
  {
    if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v25 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v27 = *(_DWORD *)(v5 + 176);
        int v26 = *(_DWORD *)(v5 + 180);
        int v28 = *(_DWORD *)(a1 + 48);
        *(_DWORD *)int buf = 136447746;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = (const char *)(v5 + 191);
        __int16 v93 = 2080;
        BOOL v94 = " ";
        __int16 v95 = 1024;
        int v96 = v26;
        __int16 v97 = 1024;
        *(_DWORD *)int v98 = v27;
        *(_WORD *)&v98[4] = 2048;
        *(void *)&v98[6] = object;
        *(_WORD *)&v98[14] = 1024;
        *(_DWORD *)&v98[16] = v28;
        BOOL v29 = "%{public}s %{public}s%s<i%u:s%d> callbacks on protocol %p not set, cannot pass error %d";
        __int16 v30 = v25;
        uint32_t v31 = 60;
LABEL_42:
        _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      }
    }
  }
  else
  {
    uint64_t v79 = *(void *)(a1 + 32);
    if (!v79 || (*(__int16 *)(v79 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v80 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v81 = *(void *)(a1 + 32);
        BOOL v82 = "";
        int v83 = *(_DWORD *)(v81 + 368);
        BOOL v84 = v81 == 0;
        if (v81) {
          int v85 = (const char *)(v81 + 390);
        }
        else {
          int v85 = "";
        }
        int v86 = *(_DWORD *)(a1 + 48);
        if (!v84) {
          BOOL v82 = " ";
        }
        *(_DWORD *)int buf = 136447490;
        BOOL v90 = "nw_protocol_http2_error_block_invoke";
        __int16 v91 = 2082;
        int v92 = v85;
        __int16 v93 = 2080;
        BOOL v94 = v82;
        __int16 v95 = 1024;
        int v96 = v83;
        __int16 v97 = 2048;
        *(void *)int v98 = object;
        *(_WORD *)&v98[8] = 1024;
        *(_DWORD *)&v98[10] = v86;
        BOOL v29 = "%{public}s %{public}s%s<i%u> callbacks on protocol %p not set, cannot pass error %d";
        __int16 v30 = v80;
        uint32_t v31 = 54;
        goto LABEL_42;
      }
    }
  }
  return 1;
}

void ___ZL31nw_protocol_http2_get_callbacksv_block_invoke()
{
  qword_1E8F6ACF8 = (uint64_t)nw_protocol_default_input_flush;
  qword_1E8F6AC58 = (uint64_t)nw_protocol_default_link_state;
  qword_1E8F6AC70 = (uint64_t)nw_protocol_default_get_local;
  qword_1E8F6AC68 = (uint64_t)nw_protocol_default_get_path;
  qword_1E8F6AC98 = (uint64_t)nw_protocol_default_updated_path;
  qword_1E8F6ACB8 = (uint64_t)nw_protocol_default_get_output_local;
  qword_1E8F6ACC0 = (uint64_t)nw_protocol_default_get_output_interface;
  qword_1E8F6ACF0 = (uint64_t)nw_protocol_default_reset;
  qword_1E8F6ACA0 = (uint64_t)nw_protocol_default_supports_external_data;
  qword_1E8F6ACC8 = (uint64_t)nw_protocol_default_waiting_for_output;
  qword_1E8F6AC80 = (uint64_t)nw_protocol_default_register_notification;
  qword_1E8F6AC88 = (uint64_t)nw_protocol_default_unregister_notification;
  qword_1E8F6AC08 = (uint64_t)nw_protocol_http2_connect;
  qword_1E8F6AC18 = (uint64_t)nw_protocol_http2_connected;
  qword_1E8F6AC10 = (uint64_t)nw_protocol_http2_disconnect;
  qword_1E8F6AC20 = (uint64_t)nw_protocol_http2_disconnected;
  qword_1E8F6ACB0 = (uint64_t)nw_protocol_http2_output_finished;
  qword_1E8F6ACA8 = (uint64_t)nw_protocol_http2_input_finished;
  nw_protocol_http2_get_callbacks(void)::protocol_callbacks = (uint64_t)nw_protocol_http2_add_input_handler;
  qword_1E8F6ABF8 = (uint64_t)nw_protocol_http2_remove_input_handler;
  qword_1E8F6AC00 = (uint64_t)nw_protocol_http2_replace_input_handler;
  qword_1E8F6AC30 = (uint64_t)nw_protocol_http2_input_available;
  qword_1E8F6AC38 = (uint64_t)nw_protocol_http2_output_available;
  qword_1E8F6AC40 = (uint64_t)nw_protocol_http2_get_input_frames;
  qword_1E8F6AC48 = (uint64_t)nw_protocol_http2_get_output_frames;
  qword_1E8F6AC60 = (uint64_t)nw_protocol_http2_get_parameters;
  qword_1E8F6ACE8 = (uint64_t)nw_protocol_http2_stream_get_message_properties;
  qword_1E8F6AC50 = (uint64_t)nw_protocol_http2_finalize_output_frames;
  qword_1E8F6ACD8 = (uint64_t)nw_protocol_http2_add_listen_handler;
  qword_1E8F6ACE0 = (uint64_t)nw_protocol_http2_remove_listen_handler;
  qword_1E8F6AC78 = (uint64_t)nw_protocol_http2_get_remote_endpoint;
  qword_1E8F6AC28 = (uint64_t)nw_protocol_http2_error;
  qword_1E8F6AC90 = (uint64_t)nw_protocol_http2_notify;
  qword_1E8F6ACD0 = (uint64_t)nw_protocol_http2_copy_info;
}

uint64_t nw_protocol_http2_copy_info(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v32 = "nw_protocol_http2_copy_info";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v13, &type, &v29)) {
      goto LABEL_51;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null protocol";
LABEL_50:
        _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
      }
LABEL_51:
      if (v13) {
        free(v13);
      }
      return 0;
    }
    if (!v29)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v18 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v32 = "nw_protocol_http2_copy_info";
      __int16 v33 = 2082;
      uint64_t v34 = backtrace_string;
      int v19 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_32:
      _os_log_impl(&dword_1830D4000, v14, v15, v19, buf, 0x16u);
    }
LABEL_33:
    free(backtrace_string);
    goto LABEL_51;
  }
  uint64_t v3 = *(void *)(a1 + 40);
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v32 = "nw_protocol_http2_copy_info";
    int v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v13, &type, &v29)) {
      goto LABEL_51;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null http2";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (!v29)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = __nwlog_obj();
    os_log_type_t v15 = type;
    BOOL v20 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v16 = "%{public}s called with null http2, no backtrace";
        goto LABEL_50;
      }
      goto LABEL_51;
    }
    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v32 = "nw_protocol_http2_copy_info";
      __int16 v33 = 2082;
      uint64_t v34 = backtrace_string;
      int v19 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_32;
    }
    goto LABEL_33;
  }
  if (a2 == 253) {
    return *(void *)(v3 + 144);
  }
  uint64_t v7 = nw_protocol_common_copy_info(a1, a2);
  BOOL v5 = v7;
  if (a2 == 255)
  {
    if (!v7) {
      BOOL v5 = nw_array_create();
    }
    int v8 = *(void **)(v3 + 256);
    if (v8) {
      nw_array_append(v5, v8);
    }
    if (a3)
    {
      uint64_t v9 = *(void *)(a3 + 56);
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 32);
        if (v10)
        {
          os_log_type_t v11 = *(void **)(v10 + 96);
          if (v11) {
            nw_array_append(v5, v11);
          }
          return v5;
        }
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v29 = 0;
        int v28 = (char *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault(v28, &type, &v29)) {
          goto LABEL_73;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v21 = __nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_73;
          }
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_protocol_http2_copy_info";
          BOOL v23 = "%{public}s called with null stream";
          goto LABEL_72;
        }
        if (!v29)
        {
          int v21 = __nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_73;
          }
          *(_DWORD *)int buf = 136446210;
          uint64_t v32 = "nw_protocol_http2_copy_info";
          BOOL v23 = "%{public}s called with null stream, backtrace limit exceeded";
          goto LABEL_72;
        }
        os_log_type_t v24 = (char *)__nw_create_backtrace_string();
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v27 = os_log_type_enabled(v21, type);
        if (v24)
        {
          if (v27)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v32 = "nw_protocol_http2_copy_info";
            __int16 v33 = 2082;
            uint64_t v34 = v24;
            int v26 = "%{public}s called with null stream, dumping backtrace:%{public}s";
            goto LABEL_62;
          }
          goto LABEL_63;
        }
        if (!v27) {
          goto LABEL_73;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v23 = "%{public}s called with null stream, no backtrace";
      }
      else
      {
        __nwlog_obj();
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v29 = 0;
        int v28 = (char *)_os_log_send_and_compose_impl();
        if (!__nwlog_fault(v28, &type, &v29)) {
          goto LABEL_73;
        }
        if (type != OS_LOG_TYPE_FAULT)
        {
          if (!v29)
          {
            int v21 = __nwlog_obj();
            os_log_type_t v22 = type;
            if (!os_log_type_enabled(v21, type)) {
              goto LABEL_73;
            }
            *(_DWORD *)int buf = 136446210;
            uint64_t v32 = "nw_protocol_http2_copy_info";
            BOOL v23 = "%{public}s called with null node, backtrace limit exceeded";
            goto LABEL_72;
          }
          os_log_type_t v24 = (char *)__nw_create_backtrace_string();
          int v21 = __nwlog_obj();
          os_log_type_t v22 = type;
          BOOL v25 = os_log_type_enabled(v21, type);
          if (!v24)
          {
            if (!v25) {
              goto LABEL_73;
            }
            *(_DWORD *)int buf = 136446210;
            uint64_t v32 = "nw_protocol_http2_copy_info";
            BOOL v23 = "%{public}s called with null node, no backtrace";
            goto LABEL_72;
          }
          if (v25)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v32 = "nw_protocol_http2_copy_info";
            __int16 v33 = 2082;
            uint64_t v34 = v24;
            int v26 = "%{public}s called with null node, dumping backtrace:%{public}s";
LABEL_62:
            _os_log_impl(&dword_1830D4000, v21, v22, v26, buf, 0x16u);
          }
LABEL_63:
          free(v24);
          goto LABEL_73;
        }
        int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (!os_log_type_enabled(v21, type)) {
          goto LABEL_73;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v32 = "nw_protocol_http2_copy_info";
        BOOL v23 = "%{public}s called with null node";
      }
LABEL_72:
      _os_log_impl(&dword_1830D4000, v21, v22, v23, buf, 0xCu);
LABEL_73:
      if (v28) {
        free(v28);
      }
    }
  }
  return v5;
}

void nw_protocol_http2_notify(uint64_t a1, uint64_t a2, unsigned int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v35 = "nw_protocol_http2_notify";
    int v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32)) {
      goto LABEL_80;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null protocol";
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v24 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v35 = "nw_protocol_http2_notify";
          __int16 v36 = 2082;
          BOOL v37 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_80:
        if (!v17) {
          return;
        }
        goto LABEL_81;
      }
      if (!v24) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_79;
  }
  uint64_t v6 = *(void *)(a1 + 40);
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v35 = "nw_protocol_http2_notify";
    int v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32)) {
      goto LABEL_80;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v32)
      {
        BOOL v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_80;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v35 = "nw_protocol_http2_notify";
        BOOL v20 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_79;
      }
      BOOL v25 = (char *)__nw_create_backtrace_string();
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (!v25)
      {
        if (!v26) {
          goto LABEL_80;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v35 = "nw_protocol_http2_notify";
        BOOL v20 = "%{public}s called with null http2, no backtrace";
        goto LABEL_79;
      }
      if (!v26) {
        goto LABEL_61;
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v35 = "nw_protocol_http2_notify";
      __int16 v36 = 2082;
      BOOL v37 = v25;
      BOOL v27 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_60;
    }
    BOOL v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_80;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v35 = "nw_protocol_http2_notify";
    BOOL v20 = "%{public}s called with null http2";
LABEL_79:
    _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0xCu);
    goto LABEL_80;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v35 = "nw_protocol_http2_notify";
    int v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32)) {
      goto LABEL_80;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null other_protocol";
      goto LABEL_79;
    }
    if (!v32)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_79;
    }
    BOOL v25 = (char *)__nw_create_backtrace_string();
    BOOL v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v28 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v28) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_79;
    }
    if (!v28) {
      goto LABEL_61;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v35 = "nw_protocol_http2_notify";
    __int16 v36 = 2082;
    BOOL v37 = v25;
    BOOL v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
LABEL_60:
    _os_log_impl(&dword_1830D4000, v18, v19, v27, buf, 0x16u);
    goto LABEL_61;
  }
  if (!*(void *)(v6 + 152))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v35 = "nw_protocol_http2_notify";
    int v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v17, &type, &v32)) {
      goto LABEL_80;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null http2->http2_streams_protocol";
      goto LABEL_79;
    }
    if (!v32)
    {
      BOOL v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null http2->http2_streams_protocol, backtrace limit exceeded";
      goto LABEL_79;
    }
    BOOL v25 = (char *)__nw_create_backtrace_string();
    BOOL v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v29 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v29) {
        goto LABEL_80;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v35 = "nw_protocol_http2_notify";
      BOOL v20 = "%{public}s called with null http2->http2_streams_protocol, no backtrace";
      goto LABEL_79;
    }
    if (v29)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v35 = "nw_protocol_http2_notify";
      __int16 v36 = 2082;
      BOOL v37 = v25;
      BOOL v27 = "%{public}s called with null http2->http2_streams_protocol, dumping backtrace:%{public}s";
      goto LABEL_60;
    }
LABEL_61:
    free(v25);
    if (!v17) {
      return;
    }
LABEL_81:
    free(v17);
    return;
  }
  if ((*(__int16 *)(v6 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v21 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v22 = *(_DWORD *)(v6 + 368);
      *(_DWORD *)int buf = 136446978;
      uint64_t v35 = "nw_protocol_http2_notify";
      __int16 v36 = 2082;
      BOOL v37 = (char *)(v6 + 390);
      __int16 v38 = 2080;
      int v39 = " ";
      __int16 v40 = 1024;
      int v41 = v22;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if (a3 > 0x16) {
    goto LABEL_21;
  }
  if (((1 << a3) & 0x208080) != 0) {
    return;
  }
  if (((1 << a3) & 0x12000) == 0)
  {
    if (a3 == 22)
    {
      if ((*(__int16 *)(v6 + 388) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v14 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          int v15 = *(_DWORD *)(v6 + 368);
          *(_DWORD *)int buf = 136446978;
          uint64_t v35 = "nw_protocol_http2_notify";
          __int16 v36 = 2082;
          BOOL v37 = (char *)(v6 + 390);
          __int16 v38 = 2080;
          int v39 = " ";
          __int16 v40 = 1024;
          int v41 = v15;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> restarting all streams", buf, 0x26u);
        }
      }
      *(_WORD *)(v6 + 388) |= 8u;
    }
LABEL_21:
    BOOL v16 = *(char **)(v6 + 152);
    v30[0] = MEMORY[0x1E4F143A8];
    v30[1] = 0x40000000;
    v30[2] = ___ZL24nw_protocol_http2_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke;
    v30[3] = &__block_descriptor_tmp_93_84085;
    v30[4] = v6;
    void v30[5] = a2;
    unsigned int v31 = a3;
    v30[6] = a4;
    v30[7] = a5;
    nw_hash_table_apply(v16, (uint64_t)v30);
    return;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11)
  {
    uint64_t v12 = *(void *)(v11 + 24);
    if (v12)
    {
      int v13 = *(void (**)(void))(v12 + 160);
      if (v13) {
        v13();
      }
    }
  }
}

uint64_t ___ZL24nw_protocol_http2_notifyP11nw_protocolS0_31nw_protocol_notification_type_tPvm_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v68 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v57 = "nw_protocol_http2_notify_block_invoke";
    uint64_t v48 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (__nwlog_fault(v48, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v49 = __nwlog_obj();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v57 = "nw_protocol_http2_notify_block_invoke";
          int v51 = "%{public}s called with null node";
LABEL_82:
          _os_log_impl(&dword_1830D4000, v49, v50, v51, buf, 0xCu);
        }
      }
      else if (v54)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v49 = __nwlog_obj();
        os_log_type_t v50 = type;
        BOOL v53 = os_log_type_enabled(v49, type);
        if (backtrace_string)
        {
          if (v53)
          {
            *(_DWORD *)int buf = 136446466;
            int v57 = "nw_protocol_http2_notify_block_invoke";
            __int16 v58 = 2082;
            int v59 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_83;
        }
        if (v53)
        {
          *(_DWORD *)int buf = 136446210;
          int v57 = "nw_protocol_http2_notify_block_invoke";
          int v51 = "%{public}s called with null node, no backtrace";
          goto LABEL_82;
        }
      }
      else
      {
        char v49 = __nwlog_obj();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v49, type))
        {
          *(_DWORD *)int buf = 136446210;
          int v57 = "nw_protocol_http2_notify_block_invoke";
          int v51 = "%{public}s called with null node, backtrace limit exceeded";
          goto LABEL_82;
        }
      }
    }
LABEL_83:
    if (!v48) {
      return 1;
    }
    int v39 = (char *)v48;
    goto LABEL_57;
  }
  uint64_t v4 = *(void *)(a2 + 16);
  if (!v4)
  {
    uint64_t v7 = *(void *)(a1 + 32);
    if (v7 && *(__int16 *)(v7 + 388) < 0) {
      return 1;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v9 = (const char *)(v8 + 390);
    BOOL v10 = v8 == 0;
    int v11 = *(_DWORD *)(v8 + 368);
    if (v10) {
      uint64_t v9 = "";
    }
    *(_DWORD *)int buf = 136447234;
    int v57 = "nw_protocol_http2_notify_block_invoke";
    if (v10) {
      uint64_t v12 = "";
    }
    else {
      uint64_t v12 = " ";
    }
    __int16 v58 = 2082;
    int v59 = (void *)v9;
    __int16 v60 = 2080;
    int v61 = v12;
    __int16 v62 = 1024;
    int v63 = v11;
    __int16 v64 = 2048;
    uint64_t v65 = a2;
    int v13 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v13, &type, &v54)) {
      goto LABEL_55;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v14 = gconnectionLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_55;
      }
      uint64_t v16 = *(void *)(a1 + 32);
      int v17 = (const char *)(v16 + 390);
      BOOL v18 = v16 == 0;
      if (!v16) {
        int v17 = "";
      }
      int v19 = *(_DWORD *)(v16 + 368);
      if (v18) {
        BOOL v20 = "";
      }
      else {
        BOOL v20 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      int v57 = "nw_protocol_http2_notify_block_invoke";
      __int16 v58 = 2082;
      int v59 = (void *)v17;
      __int16 v60 = 2080;
      int v61 = v20;
      __int16 v62 = 1024;
      int v63 = v19;
      __int16 v64 = 2048;
      uint64_t v65 = a2;
      int v21 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify";
    }
    else if (v54)
    {
      int v22 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v14 = gconnectionLogObj;
      os_log_type_t v15 = type;
      BOOL v23 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v22)
      {
        if (v23)
        {
          uint64_t v24 = *(void *)(a1 + 32);
          BOOL v25 = (const char *)(v24 + 390);
          BOOL v26 = v24 == 0;
          if (!v24) {
            BOOL v25 = "";
          }
          int v27 = *(_DWORD *)(v24 + 368);
          if (v26) {
            BOOL v28 = "";
          }
          else {
            BOOL v28 = " ";
          }
          *(_DWORD *)int buf = 136447490;
          int v57 = "nw_protocol_http2_notify_block_invoke";
          __int16 v58 = 2082;
          int v59 = (void *)v25;
          __int16 v60 = 2080;
          int v61 = v28;
          __int16 v62 = 1024;
          int v63 = v27;
          __int16 v64 = 2048;
          uint64_t v65 = a2;
          __int16 v66 = 2082;
          int v67 = v22;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(v22);
        goto LABEL_55;
      }
      if (!v23)
      {
LABEL_55:
        if (!v13) {
          return 1;
        }
        int v39 = (char *)v13;
LABEL_57:
        free(v39);
        return 1;
      }
      uint64_t v34 = *(void *)(a1 + 32);
      uint64_t v35 = (const char *)(v34 + 390);
      BOOL v36 = v34 == 0;
      if (!v34) {
        uint64_t v35 = "";
      }
      int v37 = *(_DWORD *)(v34 + 368);
      if (v36) {
        __int16 v38 = "";
      }
      else {
        __int16 v38 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      int v57 = "nw_protocol_http2_notify_block_invoke";
      __int16 v58 = 2082;
      int v59 = (void *)v35;
      __int16 v60 = 2080;
      int v61 = v38;
      __int16 v62 = 1024;
      int v63 = v37;
      __int16 v64 = 2048;
      uint64_t v65 = a2;
      int v21 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v14 = gconnectionLogObj;
      os_log_type_t v15 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_55;
      }
      uint64_t v29 = *(void *)(a1 + 32);
      __int16 v30 = (const char *)(v29 + 390);
      BOOL v31 = v29 == 0;
      if (!v29) {
        __int16 v30 = "";
      }
      int v32 = *(_DWORD *)(v29 + 368);
      if (v31) {
        __int16 v33 = "";
      }
      else {
        __int16 v33 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      int v57 = "nw_protocol_http2_notify_block_invoke";
      __int16 v58 = 2082;
      int v59 = (void *)v30;
      __int16 v60 = 2080;
      int v61 = v33;
      __int16 v62 = 1024;
      int v63 = v32;
      __int16 v64 = 2048;
      uint64_t v65 = a2;
      int v21 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping notify, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v14, v15, v21, buf, 0x30u);
    goto LABEL_55;
  }
  uint64_t v5 = *(void *)(v4 + 24);
  if (v5 && (uint64_t v6 = *(void (**)(uint64_t, void, void, void, void))(v5 + 160)) != 0)
  {
    v6(v4, *(void *)(a1 + 40), *(unsigned int *)(a1 + 64), *(void *)(a1 + 48), *(void *)(a1 + 56));
  }
  else
  {
    uint64_t v41 = *(void *)(a1 + 32);
    if (!v41 || (*(__int16 *)(v41 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v42 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v43 = *(void *)(a1 + 32);
        int v44 = (const char *)(v43 + 390);
        int v45 = "";
        BOOL v46 = v43 == 0;
        int v47 = *(_DWORD *)(v43 + 368);
        int v57 = "nw_protocol_http2_notify_block_invoke";
        if (v46) {
          int v44 = "";
        }
        __int16 v58 = 2082;
        *(_DWORD *)int buf = 136447234;
        if (!v46) {
          int v45 = " ";
        }
        int v59 = (void *)v44;
        __int16 v60 = 2080;
        int v61 = v45;
        __int16 v62 = 1024;
        int v63 = v47;
        __int16 v64 = 2048;
        uint64_t v65 = v4;
        _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> notify callback not set on input handler %p, skipping notify", buf, 0x30u);
      }
    }
  }
  return 1;
}

uint64_t nw_protocol_http2_get_remote_endpoint(nw_protocol *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      uint64_t v2 = handle[6];
      if (!v2) {
        return handle[14];
      }
      uint64_t v3 = *(void *)(v2 + 24);
      if (!v3) {
        return handle[14];
      }
      uint64_t v4 = *(uint64_t (**)(nw_protocol *))(v3 + 136);
      if (!v4) {
        return handle[14];
      }
      default_input_handler = a1->default_input_handler;
      return v4(default_input_handler);
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
        BOOL v10 = "%{public}s called with null http2";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (!v15)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
        BOOL v10 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
        BOOL v10 = "%{public}s called with null http2, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v14)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
      __int16 v19 = 2082;
      BOOL v20 = backtrace_string;
      int v13 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_26;
    }
    goto LABEL_27;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15)) {
    goto LABEL_37;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
        BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)int buf = 136446210;
        BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
        BOOL v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_36;
      }
      goto LABEL_37;
    }
    if (v12)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
      __int16 v19 = 2082;
      BOOL v20 = backtrace_string;
      int v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_26:
      _os_log_impl(&dword_1830D4000, v8, v9, v13, buf, 0x16u);
    }
LABEL_27:
    free(backtrace_string);
    goto LABEL_37;
  }
  uint64_t v8 = __nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)int buf = 136446210;
    BOOL v18 = "nw_protocol_http2_get_remote_endpoint";
    BOOL v10 = "%{public}s called with null protocol";
LABEL_36:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
  }
LABEL_37:
  if (v7) {
    free(v7);
  }
  return 0;
}

uint64_t nw_protocol_http2_remove_listen_handler(nw_protocol *a1, nw_listen_protocol *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v11 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v12 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136447234;
          int v22 = "nw_protocol_http2_remove_listen_handler";
          __int16 v23 = 2082;
          uint64_t v24 = handle + 390;
          __int16 v25 = 2080;
          BOOL v26 = " ";
          __int16 v27 = 1024;
          int v28 = v12;
          __int16 v29 = 2048;
          __int16 v30 = a2;
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with listen_protocol %p", buf, 0x30u);
        }
      }
      if (*((nw_listen_protocol **)handle + 18) == a2)
      {
        *((void *)handle + 18) = 0;
        a2->uint64_t protocol_handler = 0;
        if (*((__int16 *)handle + 194) < 0)
        {
LABEL_10:
          __int16 v4 = *((_WORD *)handle + 194);
          if ((v4 & 0x80) != 0)
          {
            nw_http2_send_goaway((uint64_t)handle);
          }
          else
          {
            *((_WORD *)handle + 194) = v4 | 2;
            uint64_t v5 = *((void *)handle + 11);
            if (v5)
            {
              if (*(void *)v5)
              {
                dispatch_source_set_timer(*(dispatch_source_t *)v5, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
              }
              else
              {
                *(_OWORD *)(v5 + 32) = xmmword_183D5CD50;
                if (*(unsigned char *)(v5 + 48))
                {
                  if (*(unsigned char *)(v5 + 49)) {
                    nw_queue_source_run_timer(v5);
                  }
                }
              }
            }
          }
          return 1;
        }
      }
      else if (*((__int16 *)handle + 194) < 0)
      {
        goto LABEL_10;
      }
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v13 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v14 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          int v22 = "nw_protocol_http2_remove_listen_handler";
          __int16 v23 = 2082;
          uint64_t v24 = handle + 390;
          __int16 v25 = 2080;
          BOOL v26 = " ";
          __int16 v27 = 1024;
          int v28 = v14;
          _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removed protocol listen handler", buf, 0x26u);
        }
      }
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v22 = "nw_protocol_http2_remove_listen_handler";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v7, &type, &v19)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v22 = "nw_protocol_http2_remove_listen_handler";
        BOOL v10 = "%{public}s called with null http2";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (!v19)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v22 = "nw_protocol_http2_remove_listen_handler";
        BOOL v10 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v18 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)int buf = 136446210;
        int v22 = "nw_protocol_http2_remove_listen_handler";
        BOOL v10 = "%{public}s called with null http2, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      int v22 = "nw_protocol_http2_remove_listen_handler";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      int v17 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_43;
    }
    goto LABEL_44;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  int v22 = "nw_protocol_http2_remove_listen_handler";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v7, &type, &v19)) {
    goto LABEL_54;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v19)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)int buf = 136446210;
        int v22 = "nw_protocol_http2_remove_listen_handler";
        BOOL v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v16 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)int buf = 136446210;
        int v22 = "nw_protocol_http2_remove_listen_handler";
        BOOL v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_53;
      }
      goto LABEL_54;
    }
    if (v16)
    {
      *(_DWORD *)int buf = 136446466;
      int v22 = "nw_protocol_http2_remove_listen_handler";
      __int16 v23 = 2082;
      uint64_t v24 = backtrace_string;
      int v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_1830D4000, v8, v9, v17, buf, 0x16u);
    }
LABEL_44:
    free(backtrace_string);
    goto LABEL_54;
  }
  uint64_t v8 = __nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)int buf = 136446210;
    int v22 = "nw_protocol_http2_remove_listen_handler";
    BOOL v10 = "%{public}s called with null protocol";
LABEL_53:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
  }
LABEL_54:
  if (v7) {
    free(v7);
  }
  return 0;
}

BOOL nw_protocol_http2_add_listen_handler(nw_protocol *a1, nw_listen_protocol *a2, char a3)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v76 = "nw_protocol_http2_add_listen_handler";
    int v22 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v74 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, type, &v74)) {
      goto LABEL_97;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v74 == OS_LOG_TYPE_DEFAULT)
      {
        __int16 v23 = __nwlog_obj();
        os_log_type_t v24 = type[0];
        if (!os_log_type_enabled(v23, type[0])) {
          goto LABEL_97;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v76 = "nw_protocol_http2_add_listen_handler";
        __int16 v25 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_96;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v23 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      BOOL v33 = os_log_type_enabled(v23, type[0]);
      if (!backtrace_string)
      {
        if (!v33) {
          goto LABEL_97;
        }
        *(_DWORD *)int buf = 136446210;
        BOOL v76 = "nw_protocol_http2_add_listen_handler";
        __int16 v25 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_96;
      }
      if (v33)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v76 = "nw_protocol_http2_add_listen_handler";
        __int16 v77 = 2082;
        uint64_t v78 = backtrace_string;
        uint64_t v34 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_1830D4000, v23, v24, v34, buf, 0x16u);
      }
LABEL_75:
      free(backtrace_string);
      goto LABEL_97;
    }
    __int16 v23 = __nwlog_obj();
    os_log_type_t v24 = type[0];
    if (!os_log_type_enabled(v23, type[0])) {
      goto LABEL_97;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v76 = "nw_protocol_http2_add_listen_handler";
    __int16 v25 = "%{public}s called with null protocol";
LABEL_96:
    _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0xCu);
LABEL_97:
    if (v22) {
      free(v22);
    }
    return 0;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v76 = "nw_protocol_http2_add_listen_handler";
    int v22 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v74 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, type, &v74)) {
      goto LABEL_97;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v25 = "%{public}s called with null http2";
      goto LABEL_96;
    }
    if (v74 == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v23 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      if (!os_log_type_enabled(v23, type[0])) {
        goto LABEL_97;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v25 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_96;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v23 = __nwlog_obj();
    os_log_type_t v24 = type[0];
    BOOL v35 = os_log_type_enabled(v23, type[0]);
    if (backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v76 = "nw_protocol_http2_add_listen_handler";
        __int16 v77 = 2082;
        uint64_t v78 = backtrace_string;
        uint64_t v34 = "%{public}s called with null http2, dumping backtrace:%{public}s";
        goto LABEL_74;
      }
      goto LABEL_75;
    }
    if (!v35) {
      goto LABEL_97;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v76 = "nw_protocol_http2_add_listen_handler";
    __int16 v25 = "%{public}s called with null http2, no backtrace";
    goto LABEL_96;
  }
  __int16 v7 = *((_WORD *)handle + 194);
  if (v7 < 0 || !gLogDatapath)
  {
    if (*((void *)handle + 18)) {
      goto LABEL_6;
    }
LABEL_50:
    if ((v7 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v36 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v37 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        BOOL v76 = "nw_protocol_http2_add_listen_handler";
        __int16 v77 = 2082;
        uint64_t v78 = handle + 390;
        __int16 v79 = 2080;
        uint64_t v80 = " ";
        __int16 v81 = 1024;
        int v82 = v37;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol listen handler", buf, 0x26u);
      }
    }
    *((void *)handle + 18) = a2;
    a2->uint64_t protocol_handler = a1;
    if (a3) {
      nw_protocol_remove_instance((uint64_t)a1);
    }
    if ((*((_WORD *)handle + 194) & 0x1000) == 0) {
      return 1;
    }
    if ((*((_WORD *)handle + 194) & 0x8000) == 0)
    {
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v38 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v39 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          BOOL v76 = "nw_protocol_http2_add_listen_handler";
          __int16 v77 = 2082;
          uint64_t v78 = handle + 390;
          __int16 v79 = 2080;
          uint64_t v80 = " ";
          __int16 v81 = 1024;
          int v82 = v39;
          _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> waiting for listen handler, resuming processing of connected", buf, 0x26u);
        }
      }
      int v28 = *((__int16 *)handle + 194);
      if (v28 < 0)
      {
        if ((v28 & 0x80) == 0)
        {
LABEL_60:
          if ((v28 & 0x8000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v29 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v30 = *((_DWORD *)handle + 92);
              *(_DWORD *)int buf = 136446978;
              BOOL v76 = "nw_protocol_http2_process_connected";
              __int16 v77 = 2082;
              uint64_t v78 = handle + 390;
              __int16 v79 = 2080;
              uint64_t v80 = " ";
              __int16 v81 = 1024;
              int v82 = v30;
              uint64_t v31 = "%{public}s %{public}s%s<i%u> not server, processing input without waiting";
LABEL_159:
              _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, v31, buf, 0x26u);
              goto LABEL_104;
            }
          }
          goto LABEL_104;
        }
LABEL_101:
        if (!*((void *)handle + 18))
        {
          if ((v28 & 0x8000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v51 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            {
              int v52 = *((_DWORD *)handle + 92);
              *(_DWORD *)int buf = 136446978;
              BOOL v76 = "nw_protocol_http2_process_connected";
              __int16 v77 = 2082;
              uint64_t v78 = handle + 390;
              __int16 v79 = 2080;
              uint64_t v80 = " ";
              __int16 v81 = 1024;
              int v82 = v52;
              _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> no listen handler on server, deferring processing of input and connected state until listen handler is present", buf, 0x26u);
            }
          }
          *((_WORD *)handle + 194) |= 0x1000u;
          return 1;
        }
        if ((v28 & 0x8000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v29 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v65 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            BOOL v76 = "nw_protocol_http2_process_connected";
            __int16 v77 = 2082;
            uint64_t v78 = handle + 390;
            __int16 v79 = 2080;
            uint64_t v80 = " ";
            __int16 v81 = 1024;
            int v82 = v65;
            uint64_t v31 = "%{public}s %{public}s%s<i%u> listen handler present, processing input without waiting";
            goto LABEL_159;
          }
        }
LABEL_104:
        __int16 v42 = *((_WORD *)handle + 194);
        *((_WORD *)handle + 194) = v42 & 0xEFFF;
        if ((v42 & 0xC) != 0)
        {
          if ((v42 & 0x8000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v43 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v44 = *((_DWORD *)handle + 92);
              *(_DWORD *)int buf = 136446978;
              BOOL v76 = "nw_protocol_http2_process_connected";
              __int16 v77 = 2082;
              uint64_t v78 = handle + 390;
              __int16 v79 = 2080;
              uint64_t v80 = " ";
              __int16 v81 = 1024;
              int v82 = v44;
              _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> tunnel already connected or closed, ignoring connected event", buf, 0x26u);
            }
          }
          return 1;
        }
        nw_http2_send_settings((uint64_t)handle);
        int v45 = *((__int16 *)handle + 194);
        *((_WORD *)handle + 194) |= 4u;
        if ((v45 & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v66 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v67 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            BOOL v76 = "nw_protocol_http2_process_connected";
            __int16 v77 = 2082;
            uint64_t v78 = handle + 390;
            __int16 v79 = 2080;
            uint64_t v80 = " ";
            __int16 v81 = 1024;
            int v82 = v67;
            _os_log_impl(&dword_1830D4000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2 tunnel is now connected", buf, 0x26u);
          }
        }
        BOOL v46 = (void *)*((void *)handle + 14);
        if (v46)
        {
          int v47 = v46;
          BOOL v48 = (v47[231] & 4) == 0;

          if (v48)
          {
            if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              char v49 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v50 = *((_DWORD *)handle + 92);
                *(_DWORD *)int buf = 136446978;
                BOOL v76 = "nw_protocol_http2_process_connected";
                __int16 v77 = 2082;
                uint64_t v78 = handle + 390;
                __int16 v79 = 2080;
                uint64_t v80 = " ";
                __int16 v81 = 1024;
                int v82 = v50;
                _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered", buf, 0x26u);
              }
            }
          }
          else
          {
            nw_endpoint_add_edges_for_instance(v47, handle, 1);
          }
          goto LABEL_152;
        }
        if (*((__int16 *)handle + 194) < 0)
        {
LABEL_152:
          nw_protocol_http2_process_input((uint64_t)handle);
          __int16 v64 = (char *)*((void *)handle + 19);
          *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
          uint64_t v69 = 0x40000000;
          __int16 v70 = ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke;
          BOOL v71 = &__block_descriptor_tmp_50_84149;
          int v72 = handle;
          nw_hash_table_apply(v64, (uint64_t)type);
          return 1;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v53 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        BOOL v76 = "nw_protocol_http2_process_connected";
        __int16 v77 = 2082;
        uint64_t v78 = handle + 390;
        __int16 v79 = 2080;
        uint64_t v80 = " ";
        __int16 v81 = 1024;
        int v82 = v53;
        char v54 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v74 = OS_LOG_TYPE_ERROR;
        char v73 = 0;
        if (__nwlog_fault(v54, &v74, &v73))
        {
          if (v74 == OS_LOG_TYPE_FAULT)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v55 = gconnectionLogObj;
            os_log_type_t v56 = v74;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v74)) {
              goto LABEL_150;
            }
            int v57 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            BOOL v76 = "nw_protocol_http2_process_connected";
            __int16 v77 = 2082;
            uint64_t v78 = handle + 390;
            __int16 v79 = 2080;
            uint64_t v80 = " ";
            __int16 v81 = 1024;
            int v82 = v57;
            __int16 v58 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
            goto LABEL_149;
          }
          if (!v73)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v55 = gconnectionLogObj;
            os_log_type_t v56 = v74;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v74)) {
              goto LABEL_150;
            }
            int v62 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            BOOL v76 = "nw_protocol_http2_process_connected";
            __int16 v77 = 2082;
            uint64_t v78 = handle + 390;
            __int16 v79 = 2080;
            uint64_t v80 = " ";
            __int16 v81 = 1024;
            int v82 = v62;
            __int16 v58 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
            goto LABEL_149;
          }
          int v59 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v55 = gconnectionLogObj;
          os_log_type_t v56 = v74;
          BOOL v60 = os_log_type_enabled((os_log_t)gconnectionLogObj, v74);
          if (v59)
          {
            if (v60)
            {
              int v61 = *((_DWORD *)handle + 92);
              *(_DWORD *)int buf = 136447234;
              BOOL v76 = "nw_protocol_http2_process_connected";
              __int16 v77 = 2082;
              uint64_t v78 = handle + 390;
              __int16 v79 = 2080;
              uint64_t v80 = " ";
              __int16 v81 = 1024;
              int v82 = v61;
              __int16 v83 = 2082;
              BOOL v84 = (nw_listen_protocol *)v59;
              _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s", buf, 0x30u);
            }
            free(v59);
            goto LABEL_150;
          }
          if (v60)
          {
            int v63 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            BOOL v76 = "nw_protocol_http2_process_connected";
            __int16 v77 = 2082;
            uint64_t v78 = handle + 390;
            __int16 v79 = 2080;
            uint64_t v80 = " ";
            __int16 v81 = 1024;
            int v82 = v63;
            __int16 v58 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_149:
            _os_log_impl(&dword_1830D4000, v55, v56, v58, buf, 0x26u);
          }
        }
LABEL_150:
        if (v54) {
          free(v54);
        }
        goto LABEL_152;
      }
      if (gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v40 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v41 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          BOOL v76 = "nw_protocol_http2_process_connected";
          __int16 v77 = 2082;
          uint64_t v78 = handle + 390;
          __int16 v79 = 2080;
          uint64_t v80 = " ";
          __int16 v81 = 1024;
          int v82 = v41;
          _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
    }
    LOWORD(v28) = *((_WORD *)handle + 194);
    if ((v28 & 0x80) == 0) {
      goto LABEL_60;
    }
    goto LABEL_101;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  BOOL v26 = gconnectionLogObj;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
  {
    int v27 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136447234;
    BOOL v76 = "nw_protocol_http2_add_listen_handler";
    __int16 v77 = 2082;
    uint64_t v78 = handle + 390;
    __int16 v79 = 2080;
    uint64_t v80 = " ";
    __int16 v81 = 1024;
    int v82 = v27;
    __int16 v83 = 2048;
    BOOL v84 = a2;
    _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with listen_protocol %p", buf, 0x30u);
  }
  __int16 v7 = *((_WORD *)handle + 194);
  if (!*((void *)handle + 18)) {
    goto LABEL_50;
  }
LABEL_6:
  if ((v7 & 0x9000) != 0x1000) {
    goto LABEL_32;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  int v8 = *((_DWORD *)handle + 92);
  *(_DWORD *)int buf = 136446978;
  BOOL v76 = "nw_protocol_http2_add_listen_handler";
  __int16 v77 = 2082;
  uint64_t v78 = handle + 390;
  __int16 v79 = 2080;
  uint64_t v80 = " ";
  __int16 v81 = 1024;
  int v82 = v8;
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v74 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v9, type, &v74))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v10 = gconnectionLogObj;
      os_log_type_t v11 = type[0];
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
        goto LABEL_29;
      }
      int v12 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      BOOL v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v77 = 2082;
      uint64_t v78 = handle + 390;
      __int16 v79 = 2080;
      uint64_t v80 = " ";
      __int16 v81 = 1024;
      int v82 = v12;
      int v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time";
      goto LABEL_28;
    }
    if (v74 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v10 = gconnectionLogObj;
      os_log_type_t v11 = type[0];
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
        goto LABEL_29;
      }
      int v17 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      BOOL v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v77 = 2082;
      uint64_t v78 = handle + 390;
      __int16 v79 = 2080;
      uint64_t v80 = " ";
      __int16 v81 = 1024;
      int v82 = v17;
      int v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, "
            "backtrace limit exceeded";
      goto LABEL_28;
    }
    int v14 = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v10 = gconnectionLogObj;
    os_log_type_t v11 = type[0];
    BOOL v15 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
    if (v14)
    {
      if (v15)
      {
        int v16 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447234;
        BOOL v76 = "nw_protocol_http2_add_listen_handler";
        __int16 v77 = 2082;
        uint64_t v78 = handle + 390;
        __int16 v79 = 2080;
        uint64_t v80 = " ";
        __int16 v81 = 1024;
        int v82 = v16;
        __int16 v83 = 2082;
        BOOL v84 = (nw_listen_protocol *)v14;
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, dumping backtrace:%{public}s", buf, 0x30u);
      }
      free(v14);
      goto LABEL_29;
    }
    if (v15)
    {
      int v18 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      BOOL v76 = "nw_protocol_http2_add_listen_handler";
      __int16 v77 = 2082;
      uint64_t v78 = handle + 390;
      __int16 v79 = 2080;
      uint64_t v80 = " ";
      __int16 v81 = 1024;
      int v82 = v18;
      int v13 = "%{public}s %{public}s%s<i%u> cannot have listen handler and be waiting for listen handler at the same time, no backtrace";
LABEL_28:
      _os_log_impl(&dword_1830D4000, v10, v11, v13, buf, 0x26u);
    }
  }
LABEL_29:
  if (v9) {
    free(v9);
  }
  __int16 v7 = *((_WORD *)handle + 194);
LABEL_32:
  if (v7 < 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  char v19 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v21 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136446978;
    BOOL v76 = "nw_protocol_http2_add_listen_handler";
    __int16 v77 = 2082;
    uint64_t v78 = handle + 390;
    __int16 v79 = 2080;
    uint64_t v80 = " ";
    __int16 v81 = 1024;
    int v82 = v21;
    _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> already have a listen handler, ignoring add", buf, 0x26u);
    return 0;
  }
  return result;
}

void nw_http2_send_settings(uint64_t a1)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v26 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v27 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)__int16 v42 = 136446978;
      *(void *)&v42[4] = "nw_http2_send_settings";
      *(_WORD *)&v42[12] = 2082;
      *(void *)&v42[14] = a1 + 390;
      *(_WORD *)&v42[22] = 2080;
      *(void *)&long long v43 = " ";
      WORD4(v43) = 1024;
      *(_DWORD *)((char *)&v43 + 10) = v27;
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", v42, 0x26u);
    }
  }
  *(_OWORD *)__int16 v42 = xmmword_183D5CDD0;
  int v2 = *(_DWORD *)(a1 + 376);
  *(_DWORD *)&v42[16] = 4;
  *(_DWORD *)&v42[20] = v2;
  long long v43 = xmmword_183D5CDE0;
  int v3 = *(_DWORD *)(a1 + 384);
  if (v3)
  {
    int v44 = 11104;
    int v45 = v3;
  }
  if (nghttp2_submit_settings())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v4 = nghttp2_strerror();
    *(_DWORD *)int buf = 136446466;
    BOOL v35 = "nw_http2_send_settings";
    __int16 v36 = 2082;
    uint64_t v37 = v4;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (!__nwlog_fault(v5, &type, &v32)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      uint64_t v8 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = v8;
      os_log_type_t v9 = "%{public}s nghttp2_submit_settings: %{public}s failed";
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v11)
        {
          uint64_t v12 = nghttp2_strerror();
          *(_DWORD *)int buf = 136446722;
          BOOL v35 = "nw_http2_send_settings";
          __int16 v36 = 2082;
          uint64_t v37 = v12;
          __int16 v38 = 2082;
          int v39 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s nghttp2_submit_settings: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (!v11)
      {
LABEL_20:
        if (v5) {
          free(v5);
        }
        goto LABEL_22;
      }
      uint64_t v14 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = v14;
      os_log_type_t v9 = "%{public}s nghttp2_submit_settings: %{public}s failed, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      uint64_t v13 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = v13;
      os_log_type_t v9 = "%{public}s nghttp2_submit_settings: %{public}s failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v9, buf, 0x16u);
    goto LABEL_20;
  }
LABEL_22:
  if (*(_DWORD *)(a1 + 380) == 0xFFFF || !nghttp2_session_set_local_window_size()) {
    goto LABEL_40;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v15 = nghttp2_strerror();
  *(_DWORD *)int buf = 136446466;
  BOOL v35 = "nw_http2_send_settings";
  __int16 v36 = 2082;
  uint64_t v37 = v15;
  int v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v16, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      uint64_t v19 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = v19;
      BOOL v20 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed";
      goto LABEL_37;
    }
    if (!v32)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v17 = gLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_38;
      }
      uint64_t v24 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = v24;
      BOOL v20 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, backtrace limit exceeded";
      goto LABEL_37;
    }
    int v21 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v17 = gLogObj;
    os_log_type_t v18 = type;
    BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v21)
    {
      if (v22)
      {
        uint64_t v23 = nghttp2_strerror();
        *(_DWORD *)int buf = 136446722;
        BOOL v35 = "nw_http2_send_settings";
        __int16 v36 = 2082;
        uint64_t v37 = v23;
        __int16 v38 = 2082;
        int v39 = v21;
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v21);
      goto LABEL_38;
    }
    if (v22)
    {
      uint64_t v25 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = v25;
      BOOL v20 = "%{public}s nghttp2_session_set_local_window_size: %{public}s failed, no backtrace";
LABEL_37:
      _os_log_impl(&dword_1830D4000, v17, v18, v20, buf, 0x16u);
    }
  }
LABEL_38:
  if (v16) {
    free(v16);
  }
LABEL_40:
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v28 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v29 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136446978;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = a1 + 390;
      __int16 v38 = 2080;
      int v39 = " ";
      __int16 v40 = 1024;
      int v41 = v29;
      _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> submitted settings to nghttp2", buf, 0x26u);
    }
  }
  nw_http2_session_send(a1);
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v30 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v31 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136446978;
      BOOL v35 = "nw_http2_send_settings";
      __int16 v36 = 2082;
      uint64_t v37 = a1 + 390;
      __int16 v38 = 2080;
      int v39 = " ";
      __int16 v40 = 1024;
      int v41 = v31;
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> nghttp2_session_send complete with settings", buf, 0x26u);
    }
  }
}

void nw_protocol_http2_process_input(uint64_t a1)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  int v2 = "nw_protocol_http2_process_input";
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v52 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v53 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_input";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v53;
      _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  *(_WORD *)(a1 + 388) |= 0x200u;
  while (1)
  {
    v67[0] = 0;
    v67[1] = v67;
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(v3 + 24);
    if (!v4) {
      break;
    }
    uint64_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 80);
    if (!v5) {
      break;
    }
    int v6 = v5(v3, a1);
    if (!v6) {
      goto LABEL_78;
    }
    int v7 = v6;
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v36 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v37 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = v2;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v37;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v7;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> received %u frames from output_handler", buf, 0x2Cu);
      }
    }
    *(void *)os_log_type_t type = 0;
    __int16 v64 = type;
    int v66 = 0;
    uint64_t v65 = 0x2000000000;
    v58[0] = MEMORY[0x1E4F143A8];
    v58[1] = 0x40000000;
    int v59 = ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke;
    BOOL v60 = &unk_1E524A670;
    int v61 = type;
    uint64_t v62 = a1;
    uint64_t v8 = v67[0];
    do
    {
      if (!v8) {
        break;
      }
      uint64_t v9 = *(void *)(v8 + 32);
      char v10 = ((uint64_t (*)(void *))v59)(v58);
      uint64_t v8 = v9;
    }
    while ((v10 & 1) != 0);
    if (nghttp2_session_consume_connection())
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = nghttp2_strerror();
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = v2;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v11;
      uint64_t v12 = (char *)_os_log_send_and_compose_impl();
      v72[0] = 16;
      char v57 = 0;
      if (!__nwlog_fault(v12, v72, &v57)) {
        goto LABEL_29;
      }
      if (v72[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = gLogObj;
        uint8_t v14 = v72[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v72[0]))
        {
          uint64_t v15 = nghttp2_strerror();
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = v2;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v15;
          int v16 = v13;
          os_log_type_t v17 = v14;
          os_log_type_t v18 = "%{public}s nghttp2_session_consume_connection: %{public}s failed";
          goto LABEL_28;
        }
        goto LABEL_29;
      }
      if (v57)
      {
        uint64_t v19 = v2;
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v21 = gLogObj;
        os_log_type_t v22 = v72[0];
        BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v72[0]);
        if (backtrace_string)
        {
          if (v23)
          {
            uint64_t v24 = nghttp2_strerror();
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = v19;
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v24;
            *(_WORD *)&buf[22] = 2082;
            uint64_t v69 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s nghttp2_session_consume_connection: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          int v2 = v19;
          goto LABEL_29;
        }
        int v2 = v19;
        if (!v23)
        {
LABEL_29:
          if (v12) {
            free(v12);
          }
          goto LABEL_31;
        }
        uint64_t v28 = nghttp2_strerror();
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v19;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v28;
        int v16 = v21;
        os_log_type_t v17 = v22;
        os_log_type_t v18 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = gLogObj;
        uint8_t v26 = v72[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v72[0])) {
          goto LABEL_29;
        }
        uint64_t v27 = nghttp2_strerror();
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = v2;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v27;
        int v16 = v25;
        os_log_type_t v17 = v26;
        os_log_type_t v18 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, backtrace limit exceeded";
      }
LABEL_28:
      _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0x16u);
      goto LABEL_29;
    }
LABEL_31:
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v38 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v39 = *(_DWORD *)(a1 + 368);
        int v40 = *((_DWORD *)v64 + 6);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = v2;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v39;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v40;
        _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> consumed %u bytes on connection", buf, 0x2Cu);
      }
    }
    int v29 = *(char **)(a1 + 152);
    v56[0] = MEMORY[0x1E4F143A8];
    v56[1] = 0x40000000;
    v56[2] = ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke_52;
    v56[3] = &__block_descriptor_tmp_53_84227;
    v56[4] = a1;
    nw_hash_table_apply(v29, (uint64_t)v56);
    if (gLogDatapath)
    {
      BOOL v35 = __nwlog_obj();
      if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int v72 = 136446210;
        char v73 = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s called", v72, 0xCu);
      }
    }
    *(void *)int buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_83451;
    uint64_t v69 = (const char *)&__block_descriptor_tmp_33_83452;
    __int16 v70 = v67;
    LOBYTE(v71) = 1;
    uint64_t v30 = v67[0];
    do
    {
      if (!v30) {
        break;
      }
      uint64_t v31 = *(void *)(v30 + 32);
      char v32 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
      uint64_t v30 = v31;
    }
    while ((v32 & 1) != 0);
    if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v33 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v34 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)int buf = 136447234;
        *(void *)&uint8_t buf[4] = v2;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 390;
        *(_WORD *)&buf[22] = 2080;
        uint64_t v69 = " ";
        LOWORD(v70) = 1024;
        *(_DWORD *)((char *)&v70 + 2) = v34;
        HIWORD(v70) = 1024;
        LODWORD(v71) = v7;
        _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> processed %u frames", buf, 0x2Cu);
      }
    }
    _Block_object_dispose(type, 8);
  }
  if (*(__int16 *)(a1 + 388) < 0) {
    goto LABEL_80;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  int v41 = *(_DWORD *)(a1 + 368);
  *(_DWORD *)int buf = 136446978;
  *(void *)&uint8_t buf[4] = v2;
  *(_WORD *)&unsigned char buf[12] = 2082;
  *(void *)&buf[14] = a1 + 390;
  *(_WORD *)&buf[22] = 2080;
  uint64_t v69 = " ";
  LOWORD(v70) = 1024;
  *(_DWORD *)((char *)&v70 + 2) = v41;
  __int16 v42 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  v72[0] = 0;
  if (!__nwlog_fault(v42, type, v72)) {
    goto LABEL_76;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    long long v43 = gconnectionLogObj;
    os_log_type_t v44 = type[0];
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]))
    {
      int v45 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = v2;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v45;
      uint64_t v46 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback";
      goto LABEL_75;
    }
    goto LABEL_76;
  }
  if (!v72[0])
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    long long v43 = gconnectionLogObj;
    os_log_type_t v44 = type[0];
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
      goto LABEL_76;
    }
    int v50 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = v2;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = a1 + 390;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v69 = " ";
    LOWORD(v70) = 1024;
    *(_DWORD *)((char *)&v70 + 2) = v50;
    uint64_t v46 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, backtrace limit exceeded";
    goto LABEL_75;
  }
  int v47 = (char *)__nw_create_backtrace_string();
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  long long v43 = gconnectionLogObj;
  os_log_type_t v44 = type[0];
  BOOL v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
  if (v47)
  {
    if (v48)
    {
      int v49 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447234;
      *(void *)&uint8_t buf[4] = v2;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v49;
      HIWORD(v70) = 2082;
      BOOL v71 = v47;
      _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, dumping backtrace:%{public}s", buf, 0x30u);
    }
    free(v47);
    goto LABEL_76;
  }
  if (v48)
  {
    int v51 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = v2;
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = a1 + 390;
    *(_WORD *)&buf[22] = 2080;
    uint64_t v69 = " ";
    LOWORD(v70) = 1024;
    *(_DWORD *)((char *)&v70 + 2) = v51;
    uint64_t v46 = "%{public}s %{public}s%s<i%u> output handler has no get_input_frames callback, no backtrace";
LABEL_75:
    _os_log_impl(&dword_1830D4000, v43, v44, v46, buf, 0x26u);
  }
LABEL_76:
  if (v42) {
    free(v42);
  }
LABEL_78:
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    char v54 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v55 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = v2;
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 390;
      *(_WORD *)&buf[22] = 2080;
      uint64_t v69 = " ";
      LOWORD(v70) = 1024;
      *(_DWORD *)((char *)&v70 + 2) = v55;
      _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> about to allow http2 to send pending data", buf, 0x26u);
    }
  }
LABEL_80:
  *(_WORD *)(a1 + 388) &= ~0x200u;
  nw_http2_session_send(a1);
}

uint64_t ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v78 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)nw_hash_node_get_extra(a2);
  if (!v4)
  {
    uint64_t v10 = *(void *)(a1 + 32);
    if (v10 && *(__int16 *)(v10 + 388) < 0) {
      return 1;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v11 = *(void *)(a1 + 32);
    uint64_t v12 = (const char *)(v11 + 390);
    BOOL v13 = v11 == 0;
    int v14 = *(_DWORD *)(v11 + 368);
    if (v13) {
      uint64_t v12 = "";
    }
    *(_DWORD *)int buf = 136447234;
    uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
    if (v13) {
      uint64_t v15 = "";
    }
    else {
      uint64_t v15 = " ";
    }
    __int16 v70 = 2082;
    BOOL v71 = v12;
    __int16 v72 = 2080;
    char v73 = v15;
    __int16 v74 = 1024;
    int v75 = v14;
    __int16 v76 = 2048;
    *(void *)__int16 v77 = a2;
    int v16 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (!__nwlog_fault(v16, &type, &v66)) {
      goto LABEL_79;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v17 = gconnectionLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_79;
      }
      uint64_t v19 = *(void *)(a1 + 32);
      BOOL v20 = (const char *)(v19 + 390);
      BOOL v21 = v19 == 0;
      if (!v19) {
        BOOL v20 = "";
      }
      int v22 = *(_DWORD *)(v19 + 368);
      if (v21) {
        BOOL v23 = "";
      }
      else {
        BOOL v23 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = v20;
      __int16 v72 = 2080;
      char v73 = v23;
      __int16 v74 = 1024;
      int v75 = v22;
      __int16 v76 = 2048;
      *(void *)__int16 v77 = a2;
      uint64_t v24 = "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra";
    }
    else if (v66)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v17 = gconnectionLogObj;
      os_log_type_t v18 = type;
      BOOL v26 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (backtrace_string)
      {
        if (v26)
        {
          uint64_t v27 = *(void *)(a1 + 32);
          uint64_t v28 = (const char *)(v27 + 390);
          BOOL v29 = v27 == 0;
          if (!v27) {
            uint64_t v28 = "";
          }
          int v30 = *(_DWORD *)(v27 + 368);
          if (v29) {
            uint64_t v31 = "";
          }
          else {
            uint64_t v31 = " ";
          }
          *(_DWORD *)int buf = 136447490;
          uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
          __int16 v70 = 2082;
          BOOL v71 = v28;
          __int16 v72 = 2080;
          char v73 = v31;
          __int16 v74 = 1024;
          int v75 = v30;
          __int16 v76 = 2048;
          *(void *)__int16 v77 = a2;
          *(_WORD *)&v77[8] = 2082;
          *(void *)&v77[10] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra, dumping backtrace:%{public}s", buf, 0x3Au);
        }
        free(backtrace_string);
        goto LABEL_79;
      }
      if (!v26)
      {
LABEL_79:
        if (!v16) {
          return 1;
        }
        char v54 = (char *)v16;
LABEL_90:
        free(v54);
        return 1;
      }
      uint64_t v49 = *(void *)(a1 + 32);
      int v50 = (const char *)(v49 + 390);
      BOOL v51 = v49 == 0;
      if (!v49) {
        int v50 = "";
      }
      int v52 = *(_DWORD *)(v49 + 368);
      if (v51) {
        int v53 = "";
      }
      else {
        int v53 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = v50;
      __int16 v72 = 2080;
      char v73 = v53;
      __int16 v74 = 1024;
      int v75 = v52;
      __int16 v76 = 2048;
      *(void *)__int16 v77 = a2;
      uint64_t v24 = "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v17 = gconnectionLogObj;
      os_log_type_t v18 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_79;
      }
      uint64_t v40 = *(void *)(a1 + 32);
      int v41 = (const char *)(v40 + 390);
      BOOL v42 = v40 == 0;
      if (!v40) {
        int v41 = "";
      }
      int v43 = *(_DWORD *)(v40 + 368);
      if (v42) {
        os_log_type_t v44 = "";
      }
      else {
        os_log_type_t v44 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = v41;
      __int16 v72 = 2080;
      char v73 = v44;
      __int16 v74 = 1024;
      int v75 = v43;
      __int16 v76 = 2048;
      *(void *)__int16 v77 = a2;
      uint64_t v24 = "%{public}s %{public}s%s<i%u> protocol hash node %p didn't have stream extra, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v17, v18, v24, buf, 0x30u);
    goto LABEL_79;
  }
  if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v60 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v62 = *(_DWORD *)(v4 + 176);
      int v61 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)int buf = 136447490;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = (const char *)(v4 + 191);
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 1024;
      int v75 = v61;
      __int16 v76 = 1024;
      *(_DWORD *)__int16 v77 = v62;
      *(_WORD *)&v77[4] = 1024;
      *(_DWORD *)&v77[6] = v62;
      _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> checking existing stream %d to see if waiting_for_connect", buf, 0x32u);
    }
  }
  int v5 = *(unsigned __int16 *)(v4 + 188);
  if ((v5 & 8) != 0)
  {
    if (((v5 | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v63 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v65 = *(_DWORD *)(v4 + 176);
        int v64 = *(_DWORD *)(v4 + 180);
        *(_DWORD *)int buf = 136447490;
        uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
        __int16 v70 = 2082;
        BOOL v71 = (const char *)(v4 + 191);
        __int16 v72 = 2080;
        char v73 = " ";
        __int16 v74 = 1024;
        int v75 = v64;
        __int16 v76 = 1024;
        *(_DWORD *)__int16 v77 = v65;
        *(_WORD *)&v77[4] = 1024;
        *(_DWORD *)&v77[6] = v65;
        _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling connect on waiting stream %d", buf, 0x32u);
      }
    }
    uint64_t object = nw_hash_node_get_object(a2);
    if (object)
    {
      if (!nw_http2_stream_connect(*(void *)(a1 + 32), v4, object)
        && ((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v7 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v9 = *(_DWORD *)(v4 + 176);
          int v8 = *(_DWORD *)(v4 + 180);
          *(_DWORD *)int buf = 136447746;
          uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
          __int16 v70 = 2082;
          BOOL v71 = (const char *)(v4 + 191);
          __int16 v72 = 2080;
          char v73 = " ";
          __int16 v74 = 1024;
          int v75 = v8;
          __int16 v76 = 1024;
          *(_DWORD *)__int16 v77 = v9;
          *(_WORD *)&v77[4] = 1024;
          *(_DWORD *)&v77[6] = v9;
          *(_WORD *)&v77[10] = 2048;
          *(void *)&v77[12] = v4;
          _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> nw_http2_stream_connect failed for stream id %d (%p)", buf, 0x3Cu);
        }
      }
      return 1;
    }
    if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) != 0) {
      return 1;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v33 = *(_DWORD *)(v4 + 176);
    int v32 = *(_DWORD *)(v4 + 180);
    *(_DWORD *)int buf = 136447490;
    uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
    __int16 v70 = 2082;
    BOOL v71 = (const char *)(v4 + 191);
    __int16 v72 = 2080;
    char v73 = " ";
    __int16 v74 = 1024;
    int v75 = v32;
    __int16 v76 = 1024;
    *(_DWORD *)__int16 v77 = v33;
    *(_WORD *)&v77[4] = 2048;
    *(void *)&v77[6] = a2;
    int v34 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (!__nwlog_fault(v34, &type, &v66)) {
      goto LABEL_88;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v35 = gconnectionLogObj;
      os_log_type_t v36 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_88;
      }
      int v38 = *(_DWORD *)(v4 + 176);
      int v37 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)int buf = 136447490;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = (const char *)(v4 + 191);
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 1024;
      int v75 = v37;
      __int16 v76 = 1024;
      *(_DWORD *)__int16 v77 = v38;
      *(_WORD *)&v77[4] = 2048;
      *(void *)&v77[6] = a2;
      int v39 = "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object";
    }
    else if (v66)
    {
      int v45 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v35 = gconnectionLogObj;
      os_log_type_t v36 = type;
      BOOL v46 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v45)
      {
        if (v46)
        {
          int v48 = *(_DWORD *)(v4 + 176);
          int v47 = *(_DWORD *)(v4 + 180);
          *(_DWORD *)int buf = 136447746;
          uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
          __int16 v70 = 2082;
          BOOL v71 = (const char *)(v4 + 191);
          __int16 v72 = 2080;
          char v73 = " ";
          __int16 v74 = 1024;
          int v75 = v47;
          __int16 v76 = 1024;
          *(_DWORD *)__int16 v77 = v48;
          *(_WORD *)&v77[4] = 2048;
          *(void *)&v77[6] = a2;
          *(_WORD *)&v77[14] = 2082;
          *(void *)&v77[16] = v45;
          _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object, dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v45);
        goto LABEL_88;
      }
      if (!v46)
      {
LABEL_88:
        if (!v34) {
          return 1;
        }
        char v54 = (char *)v34;
        goto LABEL_90;
      }
      int v58 = *(_DWORD *)(v4 + 176);
      int v57 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)int buf = 136447490;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = (const char *)(v4 + 191);
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 1024;
      int v75 = v57;
      __int16 v76 = 1024;
      *(_DWORD *)__int16 v77 = v58;
      *(_WORD *)&v77[4] = 2048;
      *(void *)&v77[6] = a2;
      int v39 = "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v35 = gconnectionLogObj;
      os_log_type_t v36 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_88;
      }
      int v56 = *(_DWORD *)(v4 + 176);
      int v55 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)int buf = 136447490;
      uint64_t v69 = "nw_protocol_http2_process_connected_block_invoke";
      __int16 v70 = 2082;
      BOOL v71 = (const char *)(v4 + 191);
      __int16 v72 = 2080;
      char v73 = " ";
      __int16 v74 = 1024;
      int v75 = v55;
      __int16 v76 = 1024;
      *(_DWORD *)__int16 v77 = v56;
      *(_WORD *)&v77[4] = 2048;
      *(void *)&v77[6] = a2;
      int v39 = "%{public}s %{public}s%s<i%u:s%d> protocol hash node %p didn't have object, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v35, v36, v39, buf, 0x36u);
    goto LABEL_88;
  }
  return 1;
}

BOOL nw_http2_stream_connect(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v51 = "nw_http2_stream_connect";
    int v22 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v22, &type, &v48)) {
      goto LABEL_87;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v51 = "nw_http2_stream_connect";
      uint64_t v25 = "%{public}s called with null http2";
    }
    else if (v48)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v31 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v31)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v51 = "nw_http2_stream_connect";
          __int16 v52 = 2082;
          int v53 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_87:
        if (v22)
        {
          int v45 = (char *)v22;
LABEL_100:
          free(v45);
          return a1 != 0;
        }
        return a1 != 0;
      }
      if (!v31) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v51 = "nw_http2_stream_connect";
      uint64_t v25 = "%{public}s called with null http2, no backtrace";
    }
    else
    {
      BOOL v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v51 = "nw_http2_stream_connect";
      uint64_t v25 = "%{public}s called with null http2, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0xCu);
    goto LABEL_87;
  }
  if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v27 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v29 = *(_DWORD *)(a2 + 176);
      int v28 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)int buf = 136447746;
      BOOL v51 = "nw_http2_stream_connect";
      __int16 v52 = 2082;
      int v53 = (void *)(a2 + 191);
      __int16 v54 = 2080;
      int v55 = " ";
      __int16 v56 = 1024;
      int v57 = v28;
      __int16 v58 = 1024;
      int v59 = v29;
      __int16 v60 = 1024;
      int v61 = v29;
      __int16 v62 = 2048;
      uint64_t v63 = a2;
      _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d (%p)", buf, 0x3Cu);
    }
  }
  int v6 = *(unsigned __int16 *)(a2 + 188);
  int v7 = v6 | (*(unsigned __int8 *)(a2 + 190) << 16);
  if ((v6 & 1) == 0)
  {
    if (!*(void *)(a2 + 32))
    {
      uint64_t v8 = mach_continuous_approximate_time();
      if (v8 <= 1) {
        uint64_t v9 = 1;
      }
      else {
        uint64_t v9 = v8;
      }
      *(void *)(a2 + 32) = v9;
      int v7 = *(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16);
    }
    unsigned int v10 = v7 & 0xFFEFFFF6 | 0x100001;
    *(_WORD *)(a2 + 188) = v10;
    *(unsigned char *)(a2 + 190) = BYTE2(v10);
    uint64_t v11 = *(void **)(a2 + 96);
    v47[0] = MEMORY[0x1E4F143A8];
    v47[1] = 0x40000000;
    v47[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke;
    v47[3] = &__block_descriptor_tmp_49_84181;
    v47[4] = a2;
    v47[5] = a1;
    nw_http_transaction_metadata_set_event_handler(v11, v47);
    if (((*(unsigned __int16 *)(a2 + 188) | (*(unsigned __int8 *)(a2 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v32 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v34 = *(_DWORD *)(a2 + 176);
        int v33 = *(_DWORD *)(a2 + 180);
        *(_DWORD *)int buf = 136447490;
        BOOL v51 = "nw_http2_stream_connect";
        __int16 v52 = 2082;
        int v53 = (void *)(a2 + 191);
        __int16 v54 = 2080;
        int v55 = " ";
        __int16 v56 = 1024;
        int v57 = v33;
        __int16 v58 = 1024;
        int v59 = v34;
        __int16 v60 = 1024;
        int v61 = v34;
        _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> connect complete for stream %d, calling connected", buf, 0x32u);
      }
    }
    uint64_t v12 = *(void *)(a3 + 24);
    if (!v12 || (BOOL v13 = *(void (**)(uint64_t, uint64_t))(v12 + 40)) == 0)
    {
      __nwlog_obj();
      int v14 = *(const char **)(a3 + 16);
      if (!v14) {
        int v14 = "invalid";
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v51 = "nw_http2_stream_connect";
      __int16 v52 = 2082;
      int v53 = (void *)v14;
      uint64_t v15 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (__nwlog_fault(v15, &type, &v48))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_98;
          }
          os_log_type_t v18 = *(const char **)(a3 + 16);
          if (!v18) {
            os_log_type_t v18 = "invalid";
          }
LABEL_21:
          *(_DWORD *)int buf = 136446466;
          BOOL v51 = "nw_http2_stream_connect";
          __int16 v52 = 2082;
          int v53 = (void *)v18;
          uint64_t v19 = "%{public}s protocol %{public}s has invalid connected callback";
LABEL_97:
          _os_log_impl(&dword_1830D4000, v16, v17, v19, buf, 0x16u);
          goto LABEL_98;
        }
        if (v48)
        {
          int v38 = (char *)__nw_create_backtrace_string();
          int v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          BOOL v39 = os_log_type_enabled(v16, type);
          if (v38)
          {
            if (v39)
            {
              if (*(void *)(a3 + 16)) {
                uint64_t v40 = *(const char **)(a3 + 16);
              }
              else {
                uint64_t v40 = "invalid";
              }
              *(_DWORD *)int buf = 136446722;
              BOOL v51 = "nw_http2_stream_connect";
              __int16 v52 = 2082;
              int v53 = (void *)v40;
              __int16 v54 = 2082;
              int v55 = v38;
              _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
            }
            free(v38);
            goto LABEL_98;
          }
          if (!v39) {
            goto LABEL_98;
          }
          BOOL v46 = *(const char **)(a3 + 16);
          if (!v46) {
            BOOL v46 = "invalid";
          }
LABEL_96:
          *(_DWORD *)int buf = 136446466;
          BOOL v51 = "nw_http2_stream_connect";
          __int16 v52 = 2082;
          int v53 = (void *)v46;
          uint64_t v19 = "%{public}s protocol %{public}s has invalid connected callback, no backtrace";
          goto LABEL_97;
        }
        int v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_98;
        }
        os_log_type_t v44 = *(const char **)(a3 + 16);
        if (!v44) {
          os_log_type_t v44 = "invalid";
        }
LABEL_79:
        *(_DWORD *)int buf = 136446466;
        BOOL v51 = "nw_http2_stream_connect";
        __int16 v52 = 2082;
        int v53 = (void *)v44;
        uint64_t v19 = "%{public}s protocol %{public}s has invalid connected callback, backtrace limit exceeded";
        goto LABEL_97;
      }
      goto LABEL_98;
    }
LABEL_26:
    v13(a3, a1);
    return a1 != 0;
  }
  if ((v7 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v35 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v37 = *(_DWORD *)(a2 + 176);
      int v36 = *(_DWORD *)(a2 + 180);
      *(_DWORD *)int buf = 136447490;
      BOOL v51 = "nw_http2_stream_connect";
      __int16 v52 = 2082;
      int v53 = (void *)(a2 + 191);
      __int16 v54 = 2080;
      int v55 = " ";
      __int16 v56 = 1024;
      int v57 = v36;
      __int16 v58 = 1024;
      int v59 = v37;
      __int16 v60 = 1024;
      int v61 = v37;
      _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream %d is already connected", buf, 0x32u);
    }
  }
  uint64_t v20 = *(void *)(a3 + 24);
  if (v20)
  {
    BOOL v13 = *(void (**)(uint64_t, uint64_t))(v20 + 40);
    if (v13) {
      goto LABEL_26;
    }
  }
  __nwlog_obj();
  BOOL v26 = *(const char **)(a3 + 16);
  if (!v26) {
    BOOL v26 = "invalid";
  }
  *(_DWORD *)int buf = 136446466;
  BOOL v51 = "nw_http2_stream_connect";
  __int16 v52 = 2082;
  int v53 = (void *)v26;
  uint64_t v15 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v48 = 0;
  if (__nwlog_fault(v15, &type, &v48))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_98;
      }
      os_log_type_t v18 = *(const char **)(a3 + 16);
      if (!v18) {
        os_log_type_t v18 = "invalid";
      }
      goto LABEL_21;
    }
    if (!v48)
    {
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_98;
      }
      os_log_type_t v44 = *(const char **)(a3 + 16);
      if (!v44) {
        os_log_type_t v44 = "invalid";
      }
      goto LABEL_79;
    }
    int v41 = (char *)__nw_create_backtrace_string();
    int v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v42 = os_log_type_enabled(v16, type);
    if (v41)
    {
      if (v42)
      {
        if (*(void *)(a3 + 16)) {
          int v43 = *(const char **)(a3 + 16);
        }
        else {
          int v43 = "invalid";
        }
        *(_DWORD *)int buf = 136446722;
        BOOL v51 = "nw_http2_stream_connect";
        __int16 v52 = 2082;
        int v53 = (void *)v43;
        __int16 v54 = 2082;
        int v55 = v41;
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s protocol %{public}s has invalid connected callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(v41);
      if (v15) {
        goto LABEL_99;
      }
      return a1 != 0;
    }
    if (v42)
    {
      BOOL v46 = *(const char **)(a3 + 16);
      if (!v46) {
        BOOL v46 = "invalid";
      }
      goto LABEL_96;
    }
  }
LABEL_98:
  if (v15)
  {
LABEL_99:
    int v45 = (char *)v15;
    goto LABEL_100;
  }
  return a1 != 0;
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke(uint64_t a1, void *a2, int a3)
{
  v113[2] = *MEMORY[0x1E4F143B8];
  switch(a3)
  {
    case 0:
      id outbound_message = nw_http_transaction_metadata_get_outbound_message(a2);
      id v6 = nw_http_metadata_copy_request(outbound_message);
      id v7 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v102[0] = MEMORY[0x1E4F143A8];
        v102[1] = 0x40000000;
        v102[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_2;
        v102[3] = &__block_descriptor_tmp_40_84189;
        long long v103 = *(_OWORD *)(a1 + 32);
        id v8 = v6;
        uint64_t v9 = v102;
        _nw_http_request_access_method((uint64_t)v8, v9);
      }
      if (!v7) {
        goto LABEL_46;
      }
      id v10 = v7;
      int status_code = _nw_http_response_get_status_code();

      uint64_t v12 = *(void *)(a1 + 32);
      if (v12)
      {
        if (((*(unsigned __int16 *)(v12 + 188) | (*(unsigned __int8 *)(v12 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          uint64_t v13 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v14 = *(void *)(a1 + 32);
            uint64_t v15 = (const char *)(v14 + 191);
            int v16 = "";
            BOOL v17 = v14 == 0;
            if (!v14) {
              uint64_t v15 = "";
            }
            uint64_t v20 = v14 + 176;
            int v18 = *(_DWORD *)(v14 + 176);
            int v19 = *(_DWORD *)(v20 + 4);
            if (!v17) {
              int v16 = " ";
            }
            *(_DWORD *)int buf = 136447490;
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            __int16 v106 = 2082;
            uint64_t v107 = v15;
            __int16 v108 = 2080;
            int v109 = v16;
            __int16 v110 = 1024;
            int v111 = v19;
            __int16 v112 = 1024;
            LODWORD(v113[0]) = v18;
            WORD2(v113[0]) = 1024;
            *(_DWORD *)((char *)v113 + 6) = status_code;
            BOOL v21 = "%{public}s %{public}s%s<i%u:s%d> sending response header {status=%hu}";
            goto LABEL_43;
          }
        }
      }
      else
      {
        uint64_t v80 = *(void *)(a1 + 40);
        if (!v80 || (*(__int16 *)(v80 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          uint64_t v81 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v82 = *(void *)(a1 + 40);
            __int16 v83 = "";
            BOOL v84 = v82 == 0;
            int v85 = *(_DWORD *)(v82 + 368);
            int v86 = (const char *)(v82 + 390);
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            __int16 v106 = 2082;
            if (v84) {
              int v86 = "";
            }
            *(_DWORD *)int buf = 136447234;
            if (!v84) {
              __int16 v83 = " ";
            }
            uint64_t v107 = v86;
            __int16 v108 = 2080;
            int v109 = v83;
            __int16 v110 = 1024;
            int v111 = v85;
            __int16 v112 = 1024;
            LODWORD(v113[0]) = status_code;
            BOOL v21 = "%{public}s %{public}s%s<i%u> sending response header {status=%hu}";
            goto LABEL_123;
          }
        }
      }
      goto LABEL_45;
    case 1:
      outbound_body_size_t size = nw_http_transaction_metadata_get_outbound_body_size(a2);
      uint64_t v28 = *(void *)(a1 + 32);
      if (v28)
      {
        if (((*(unsigned __int16 *)(v28 + 188) | (*(unsigned __int8 *)(v28 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          int v29 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v30 = *(void *)(a1 + 32);
            BOOL v31 = (const char *)(v30 + 191);
            int v32 = "";
            BOOL v33 = v30 == 0;
            if (!v30) {
              BOOL v31 = "";
            }
            uint64_t v36 = v30 + 176;
            int v34 = *(_DWORD *)(v30 + 176);
            int v35 = *(_DWORD *)(v36 + 4);
            if (!v33) {
              int v32 = " ";
            }
            *(_DWORD *)int buf = 136447490;
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            __int16 v106 = 2082;
            uint64_t v107 = v31;
            __int16 v108 = 2080;
            int v109 = v32;
            __int16 v110 = 1024;
            int v111 = v35;
            __int16 v112 = 1024;
            LODWORD(v113[0]) = v34;
            WORD2(v113[0]) = 2048;
            *(void *)((char *)v113 + 6) = outbound_body_size;
            int v37 = "%{public}s %{public}s%s<i%u:s%d> finished sending {body_bytes=%llu}";
            goto LABEL_60;
          }
        }
      }
      else
      {
        uint64_t v66 = *(void *)(a1 + 40);
        if (!v66 || (*(__int16 *)(v66 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          int v67 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v68 = *(void *)(a1 + 40);
            uint64_t v69 = (const char *)(v68 + 390);
            __int16 v70 = "";
            BOOL v71 = v68 == 0;
            int v72 = *(_DWORD *)(v68 + 368);
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            if (v71) {
              uint64_t v69 = "";
            }
            __int16 v106 = 2082;
            *(_DWORD *)int buf = 136447234;
            if (!v71) {
              __int16 v70 = " ";
            }
            uint64_t v107 = v69;
            __int16 v108 = 2080;
            int v109 = v70;
            __int16 v110 = 1024;
            int v111 = v72;
            __int16 v112 = 2048;
            v113[0] = outbound_body_size;
            char v73 = "%{public}s %{public}s%s<i%u> finished sending {body_bytes=%llu}";
            goto LABEL_102;
          }
        }
      }
      return;
    case 2:
      id outbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
      id v6 = nw_http_metadata_copy_request(outbound_message);
      id v38 = nw_http_metadata_copy_response(outbound_message);
      if (v6)
      {
        v100[0] = MEMORY[0x1E4F143A8];
        v100[1] = 0x40000000;
        v100[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_41;
        v100[3] = &__block_descriptor_tmp_42_84194;
        long long v101 = *(_OWORD *)(a1 + 32);
        id v39 = v6;
        uint64_t v40 = v100;
        _nw_http_request_access_method((uint64_t)v39, v40);
      }
      if (!v38) {
        goto LABEL_46;
      }
      id v10 = v38;
      int v41 = _nw_http_response_get_status_code();

      uint64_t v42 = *(void *)(a1 + 32);
      if (v42)
      {
        if (((*(unsigned __int16 *)(v42 + 188) | (*(unsigned __int8 *)(v42 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          uint64_t v13 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v43 = *(void *)(a1 + 32);
            os_log_type_t v44 = (const char *)(v43 + 191);
            int v45 = "";
            BOOL v46 = v43 == 0;
            if (!v43) {
              os_log_type_t v44 = "";
            }
            uint64_t v49 = v43 + 176;
            int v47 = *(_DWORD *)(v43 + 176);
            int v48 = *(_DWORD *)(v49 + 4);
            if (!v46) {
              int v45 = " ";
            }
            *(_DWORD *)int buf = 136447490;
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            __int16 v106 = 2082;
            uint64_t v107 = v44;
            __int16 v108 = 2080;
            int v109 = v45;
            __int16 v110 = 1024;
            int v111 = v48;
            __int16 v112 = 1024;
            LODWORD(v113[0]) = v47;
            WORD2(v113[0]) = 1024;
            *(_DWORD *)((char *)v113 + 6) = v41;
            BOOL v21 = "%{public}s %{public}s%s<i%u:s%d> receiving response header {status=%hu}";
LABEL_43:
            int v50 = v13;
            uint32_t v51 = 50;
LABEL_44:
            _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_INFO, v21, buf, v51);
          }
        }
      }
      else
      {
        uint64_t v87 = *(void *)(a1 + 40);
        if (!v87 || (*(__int16 *)(v87 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          uint64_t v81 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v88 = *(void *)(a1 + 40);
            uint64_t v89 = "";
            BOOL v90 = v88 == 0;
            int v91 = *(_DWORD *)(v88 + 368);
            int v92 = (const char *)(v88 + 390);
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            __int16 v106 = 2082;
            if (v90) {
              int v92 = "";
            }
            *(_DWORD *)int buf = 136447234;
            if (!v90) {
              uint64_t v89 = " ";
            }
            uint64_t v107 = v92;
            __int16 v108 = 2080;
            int v109 = v89;
            __int16 v110 = 1024;
            int v111 = v91;
            __int16 v112 = 1024;
            LODWORD(v113[0]) = v41;
            BOOL v21 = "%{public}s %{public}s%s<i%u> receiving response header {status=%hu}";
LABEL_123:
            int v50 = v81;
            uint32_t v51 = 44;
            goto LABEL_44;
          }
        }
      }
LABEL_45:
      os_release(v10);
LABEL_46:
      if (v6) {
        os_release(v6);
      }
      if (!outbound_message) {
        return;
      }
      __int16 v52 = outbound_message;
      goto LABEL_77;
    case 3:
      inbound_body_size_t size = nw_http_transaction_metadata_get_inbound_body_size(a2);
      uint64_t v54 = *(void *)(a1 + 32);
      if (v54)
      {
        if (((*(unsigned __int16 *)(v54 + 188) | (*(unsigned __int8 *)(v54 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          int v29 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v55 = *(void *)(a1 + 32);
            __int16 v56 = (const char *)(v55 + 191);
            int v57 = "";
            BOOL v58 = v55 == 0;
            if (!v55) {
              __int16 v56 = "";
            }
            uint64_t v61 = v55 + 176;
            int v59 = *(_DWORD *)(v55 + 176);
            int v60 = *(_DWORD *)(v61 + 4);
            if (!v58) {
              int v57 = " ";
            }
            *(_DWORD *)int buf = 136447490;
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            __int16 v106 = 2082;
            uint64_t v107 = v56;
            __int16 v108 = 2080;
            int v109 = v57;
            __int16 v110 = 1024;
            int v111 = v60;
            __int16 v112 = 1024;
            LODWORD(v113[0]) = v59;
            WORD2(v113[0]) = 2048;
            *(void *)((char *)v113 + 6) = inbound_body_size;
            int v37 = "%{public}s %{public}s%s<i%u:s%d> finished receiving {body_bytes=%llu}";
LABEL_60:
            _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_INFO, v37, buf, 0x36u);
          }
        }
      }
      else
      {
        uint64_t v74 = *(void *)(a1 + 40);
        if (!v74 || (*(__int16 *)(v74 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_http_log::onceToken != -1) {
            dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
          }
          int v67 = ghttpLogObj;
          if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
          {
            uint64_t v75 = *(void *)(a1 + 40);
            __int16 v76 = (const char *)(v75 + 390);
            __int16 v77 = "";
            BOOL v78 = v75 == 0;
            int v79 = *(_DWORD *)(v75 + 368);
            uint64_t v105 = "nw_http2_stream_connect_block_invoke";
            if (v78) {
              __int16 v76 = "";
            }
            __int16 v106 = 2082;
            *(_DWORD *)int buf = 136447234;
            if (!v78) {
              __int16 v77 = " ";
            }
            uint64_t v107 = v76;
            __int16 v108 = 2080;
            int v109 = v77;
            __int16 v110 = 1024;
            int v111 = v79;
            __int16 v112 = 2048;
            v113[0] = inbound_body_size;
            char v73 = "%{public}s %{public}s%s<i%u> finished receiving {body_bytes=%llu}";
LABEL_102:
            _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_INFO, v73, buf, 0x30u);
          }
        }
      }
      return;
    case 4:
      v95[0] = MEMORY[0x1E4F143A8];
      v95[1] = 0x40000000;
      int v96 = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_43;
      __int16 v97 = &__block_descriptor_tmp_45_84199;
      int v98 = a2;
      long long v99 = *(_OWORD *)(a1 + 32);
      id v22 = nw_http_transaction_metadata_get_outbound_message(a2);
      BOOL v23 = v22;
      if (v22)
      {
        id v24 = nw_http_metadata_copy_request(v22);
        id v25 = nw_http_metadata_copy_response(v23);
        id inbound_message = nw_http_transaction_metadata_get_inbound_message(a2);
        if (!inbound_message) {
          goto LABEL_65;
        }
        if (v24)
        {
          if (v25) {
            goto LABEL_66;
          }
          goto LABEL_64;
        }
      }
      else
      {
        id v62 = nw_http_transaction_metadata_get_inbound_message(a2);
        id v25 = 0;
        if (!v62)
        {
          uint64_t v63 = 0;
          id inbound_message = 0;
          goto LABEL_80;
        }
        id inbound_message = v62;
      }
      id v24 = nw_http_metadata_copy_request(inbound_message);
      if (v25) {
        goto LABEL_66;
      }
LABEL_64:
      id v25 = nw_http_metadata_copy_response(inbound_message);
LABEL_65:
      if (!v25)
      {
        uint64_t v63 = 0;
        if (!v24) {
          goto LABEL_80;
        }
LABEL_69:
        v93[0] = MEMORY[0x1E4F143A8];
        v93[1] = 0x40000000;
        v93[2] = ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_46;
        v93[3] = &unk_1E524A608;
        v93[4] = v95;
        __int16 v94 = v63;
        id v64 = v24;
        int v65 = v93;
        _nw_http_request_access_method((uint64_t)v64, v65);

        if (!inbound_message) {
          goto LABEL_71;
        }
        goto LABEL_70;
      }
LABEL_66:
      id v25 = v25;
      uint64_t v63 = _nw_http_response_get_status_code();

      if (v24) {
        goto LABEL_69;
      }
LABEL_80:
      v96((uint64_t)v95, (uint64_t)"", v63);
      id v64 = 0;
      if (inbound_message) {
LABEL_70:
      }
        os_release(inbound_message);
LABEL_71:
      if (v23) {
        os_release(v23);
      }
      if (v25) {
        os_release(v25);
      }
      if (v64)
      {
        __int16 v52 = v64;
LABEL_77:
        os_release(v52);
      }
      return;
    default:
      return;
  }
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_2(uint64_t a1, uint64_t a2)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      uint64_t v5 = ghttpLogObj;
      if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        id v7 = (const char *)(v6 + 191);
        id v8 = "";
        BOOL v9 = v6 == 0;
        if (!v6) {
          id v7 = "";
        }
        uint64_t v12 = v6 + 176;
        int v10 = *(_DWORD *)(v6 + 176);
        int v11 = *(_DWORD *)(v12 + 4);
        if (!v9) {
          id v8 = " ";
        }
        int v23 = 136447490;
        id v24 = "nw_http2_stream_connect_block_invoke";
        __int16 v25 = 2082;
        BOOL v26 = v7;
        __int16 v27 = 2080;
        uint64_t v28 = v8;
        __int16 v29 = 1024;
        int v30 = v11;
        __int16 v31 = 1024;
        LODWORD(v32[0]) = v10;
        WORD2(v32[0]) = 2082;
        *(void *)((char *)v32 + 6) = a2;
        uint64_t v13 = "%{public}s %{public}s%s<i%u:s%d> sending request header {method=\"%{public}s\"}";
        uint64_t v14 = v5;
        uint32_t v15 = 54;
LABEL_11:
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_INFO, v13, (uint8_t *)&v23, v15);
      }
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 40);
    if (!v16 || (*(__int16 *)(v16 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      uint64_t v17 = ghttpLogObj;
      if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v18 = *(void *)(a1 + 40);
        int v19 = "";
        uint64_t v20 = (const char *)(v18 + 390);
        BOOL v21 = v18 == 0;
        int v22 = *(_DWORD *)(v18 + 368);
        if (v21) {
          uint64_t v20 = "";
        }
        int v23 = 136447234;
        id v24 = "nw_http2_stream_connect_block_invoke_2";
        if (!v21) {
          int v19 = " ";
        }
        __int16 v25 = 2082;
        BOOL v26 = v20;
        __int16 v27 = 2080;
        uint64_t v28 = v19;
        __int16 v29 = 1024;
        int v30 = v22;
        __int16 v31 = 2082;
        v32[0] = a2;
        uint64_t v13 = "%{public}s %{public}s%s<i%u> sending request header {method=\"%{public}s\"}";
        uint64_t v14 = v17;
        uint32_t v15 = 48;
        goto LABEL_11;
      }
    }
  }
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_41(uint64_t a1, uint64_t a2)
{
  v32[2] = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    if (((*(unsigned __int16 *)(v4 + 188) | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      uint64_t v5 = ghttpLogObj;
      if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v6 = *(void *)(a1 + 32);
        id v7 = (const char *)(v6 + 191);
        id v8 = "";
        BOOL v9 = v6 == 0;
        if (!v6) {
          id v7 = "";
        }
        uint64_t v12 = v6 + 176;
        int v10 = *(_DWORD *)(v6 + 176);
        int v11 = *(_DWORD *)(v12 + 4);
        if (!v9) {
          id v8 = " ";
        }
        int v23 = 136447490;
        id v24 = "nw_http2_stream_connect_block_invoke";
        __int16 v25 = 2082;
        BOOL v26 = v7;
        __int16 v27 = 2080;
        uint64_t v28 = v8;
        __int16 v29 = 1024;
        int v30 = v11;
        __int16 v31 = 1024;
        LODWORD(v32[0]) = v10;
        WORD2(v32[0]) = 2082;
        *(void *)((char *)v32 + 6) = a2;
        uint64_t v13 = "%{public}s %{public}s%s<i%u:s%d> receiving request header {method=\"%{public}s\"}";
        uint64_t v14 = v5;
        uint32_t v15 = 54;
LABEL_11:
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_INFO, v13, (uint8_t *)&v23, v15);
      }
    }
  }
  else
  {
    uint64_t v16 = *(void *)(a1 + 40);
    if (!v16 || (*(__int16 *)(v16 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      uint64_t v17 = ghttpLogObj;
      if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v18 = *(void *)(a1 + 40);
        int v19 = "";
        uint64_t v20 = (const char *)(v18 + 390);
        BOOL v21 = v18 == 0;
        int v22 = *(_DWORD *)(v18 + 368);
        if (v21) {
          uint64_t v20 = "";
        }
        int v23 = 136447234;
        id v24 = "nw_http2_stream_connect_block_invoke";
        if (!v21) {
          int v19 = " ";
        }
        __int16 v25 = 2082;
        BOOL v26 = v20;
        __int16 v27 = 2080;
        uint64_t v28 = v19;
        __int16 v29 = 1024;
        int v30 = v22;
        __int16 v31 = 2082;
        v32[0] = a2;
        uint64_t v13 = "%{public}s %{public}s%s<i%u> receiving request header {method=\"%{public}s\"}";
        uint64_t v14 = v17;
        uint32_t v15 = 48;
        goto LABEL_11;
      }
    }
  }
}

void ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_43(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v89 = *MEMORY[0x1E4F143B8];
  int start_reason = nw_http_transaction_metadata_get_start_reason(*(void **)(a1 + 32));
  uint64_t start_time = nw_http_transaction_metadata_get_start_time(*(void **)(a1 + 32));
  uint64_t end_time = nw_http_transaction_metadata_get_end_time(*(void **)(a1 + 32));
  outbound_message_uint64_t start_time = nw_http_transaction_metadata_get_outbound_message_start_time(*(void **)(a1 + 32));
  outbound_message_uint64_t end_time = nw_http_transaction_metadata_get_outbound_message_end_time(*(void **)(a1 + 32));
  inbound_message_uint64_t start_time = nw_http_transaction_metadata_get_inbound_message_start_time(*(void **)(a1 + 32));
  inbound_message_uint64_t end_time = nw_http_transaction_metadata_get_inbound_message_end_time(*(void **)(a1 + 32));
  outbound_body_size_t size = nw_http_transaction_metadata_get_outbound_body_size(*(void **)(a1 + 32));
  inbound_body_size_t size = nw_http_transaction_metadata_get_inbound_body_size(*(void **)(a1 + 32));
  uint64_t v12 = *(void *)(a1 + 40);
  if (v12)
  {
    if (((*(unsigned __int16 *)(v12 + 188) | (*(unsigned __int8 *)(v12 + 190) << 16)) & 0x80000) == 0)
    {
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      uint64_t v13 = ghttpLogObj;
      if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v14 = *(void *)(a1 + 40);
        uint32_t v15 = "";
        if (v14) {
          uint64_t v16 = (const char *)(v14 + 191);
        }
        else {
          uint64_t v16 = "";
        }
        if (v14) {
          uint32_t v15 = " ";
        }
        uint64_t v60 = outbound_body_size;
        uint64_t v62 = a2;
        __int16 v56 = v16;
        BOOL v58 = v15;
        if ((start_reason - 1) > 2) {
          uint64_t v17 = "initial";
        }
        else {
          uint64_t v17 = off_1E52492C0[start_reason - 1];
        }
        uint64_t v54 = v17;
        int v18 = *(_DWORD *)(v14 + 180);
        int v53 = *(_DWORD *)(v14 + 176);
        int v19 = -1;
        if (start_time && end_time)
        {
          unint64_t v20 = nw_delta_nanos(start_time, end_time);
          if (v20 > 0xF423FFFFFFFFFLL) {
            int v19 = -1;
          }
          else {
            int v19 = v20 / 0xF4240;
          }
        }
        int v21 = -1;
        uint64_t v22 = outbound_message_end_time;
        if (start_time && outbound_message_start_time)
        {
          unint64_t v23 = nw_delta_nanos(start_time, outbound_message_start_time);
          if (v23 > 0xF423FFFFFFFFFLL) {
            int v21 = -1;
          }
          else {
            int v21 = v23 / 0xF4240;
          }
          uint64_t v22 = outbound_message_end_time;
        }
        int v24 = -1;
        if (outbound_message_start_time)
        {
          uint64_t v25 = inbound_message_start_time;
          if (v22)
          {
            unint64_t v26 = nw_delta_nanos(outbound_message_start_time, v22);
            if (v26 > 0xF423FFFFFFFFFLL) {
              int v24 = -1;
            }
            else {
              int v24 = v26 / 0xF4240;
            }
          }
          int v27 = -1;
          if (!start_time) {
            goto LABEL_37;
          }
        }
        else
        {
          uint64_t v25 = inbound_message_start_time;
          int v27 = -1;
          if (!start_time)
          {
LABEL_37:
            LODWORD(v29) = -1;
            if (v25 && inbound_message_end_time)
            {
              unint64_t v30 = nw_delta_nanos(v25, inbound_message_end_time);
              unint64_t v29 = v30 / 0xF4240;
              if (v30 > 0xF423FFFFFFFFFLL) {
                LODWORD(v29) = -1;
              }
            }
            *(_DWORD *)int buf = 136449794;
            uint64_t v68 = "nw_http2_stream_connect_block_invoke";
            __int16 v69 = 2082;
            __int16 v70 = v56;
            __int16 v71 = 2080;
            int v72 = v58;
            __int16 v73 = 1024;
            int v74 = v18;
            __int16 v75 = 1024;
            *(_DWORD *)__int16 v76 = v53;
            *(_WORD *)&v76[4] = 2080;
            *(void *)&v76[6] = v54;
            __int16 v77 = 1024;
            *(_DWORD *)BOOL v78 = v19;
            *(_WORD *)&v78[4] = 2082;
            *(void *)&v78[6] = v62;
            __int16 v79 = 1024;
            int v80 = a3;
            __int16 v81 = 1024;
            int v82 = v21;
            __int16 v83 = 1024;
            int v84 = v24;
            __int16 v85 = 1024;
            int v86 = v27;
            __int16 v87 = 1024;
            *(_DWORD *)uint64_t v88 = v29;
            *(_WORD *)&v88[4] = 2048;
            *(void *)&v88[6] = v60;
            *(_WORD *)&v88[14] = 2048;
            *(void *)&v88[16] = inbound_body_size;
            __int16 v31 = "%{public}s %{public}s%s<i%u:s%d> transaction summary {start_reason=\"%s\", duration_ms=%d, request_met"
                  "hod=\"%{public}s\", response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_"
                  "ms=%d, inbound_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}";
            int v32 = v13;
            uint32_t v33 = 120;
LABEL_42:
            _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEFAULT, v31, buf, v33);
            return;
          }
        }
        if (v25)
        {
          unint64_t v28 = nw_delta_nanos(start_time, v25);
          if (v28 > 0xF423FFFFFFFFFLL) {
            int v27 = -1;
          }
          else {
            int v27 = v28 / 0xF4240;
          }
        }
        goto LABEL_37;
      }
    }
  }
  else
  {
    uint64_t v34 = *(void *)(a1 + 48);
    if (!v34 || (*(__int16 *)(v34 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_http_log::onceToken != -1) {
        dispatch_once(&__nwlog_http_log::onceToken, &__block_literal_global_36);
      }
      uint64_t v35 = ghttpLogObj;
      if (os_log_type_enabled((os_log_t)ghttpLogObj, OS_LOG_TYPE_DEFAULT))
      {
        uint64_t v36 = *(void *)(a1 + 48);
        if (v36) {
          int v37 = (const char *)(v36 + 390);
        }
        else {
          int v37 = "";
        }
        id v38 = " ";
        if (!v36) {
          id v38 = "";
        }
        int v57 = v37;
        int v59 = v38;
        uint64_t v61 = outbound_body_size;
        uint64_t v63 = a2;
        if ((start_reason - 1) > 2) {
          id v39 = "initial";
        }
        else {
          id v39 = off_1E52492C0[start_reason - 1];
        }
        uint64_t v55 = v39;
        int v40 = *(_DWORD *)(v36 + 368);
        int v41 = -1;
        if (start_time && end_time)
        {
          unint64_t v42 = nw_delta_nanos(start_time, end_time);
          if (v42 > 0xF423FFFFFFFFFLL) {
            int v41 = -1;
          }
          else {
            int v41 = v42 / 0xF4240;
          }
        }
        int v43 = -1;
        uint64_t v44 = outbound_message_end_time;
        if (start_time && outbound_message_start_time)
        {
          unint64_t v45 = nw_delta_nanos(start_time, outbound_message_start_time);
          if (v45 > 0xF423FFFFFFFFFLL) {
            int v43 = -1;
          }
          else {
            int v43 = v45 / 0xF4240;
          }
          uint64_t v44 = outbound_message_end_time;
        }
        int v46 = -1;
        if (outbound_message_start_time)
        {
          uint64_t v47 = inbound_message_start_time;
          if (v44)
          {
            unint64_t v48 = nw_delta_nanos(outbound_message_start_time, v44);
            if (v48 > 0xF423FFFFFFFFFLL) {
              int v46 = -1;
            }
            else {
              int v46 = v48 / 0xF4240;
            }
          }
        }
        else
        {
          uint64_t v47 = inbound_message_start_time;
        }
        int v49 = -1;
        if (start_time && v47)
        {
          unint64_t v50 = nw_delta_nanos(start_time, v47);
          if (v50 > 0xF423FFFFFFFFFLL) {
            int v49 = -1;
          }
          else {
            int v49 = v50 / 0xF4240;
          }
        }
        LODWORD(v51) = -1;
        if (v47)
        {
          if (inbound_message_end_time)
          {
            unint64_t v52 = nw_delta_nanos(v47, inbound_message_end_time);
            unint64_t v51 = v52 / 0xF4240;
            if (v52 > 0xF423FFFFFFFFFLL) {
              LODWORD(v51) = -1;
            }
          }
        }
        *(_DWORD *)int buf = 136449538;
        uint64_t v68 = "nw_http2_stream_connect_block_invoke";
        __int16 v69 = 2082;
        __int16 v70 = v57;
        __int16 v71 = 2080;
        int v72 = v59;
        __int16 v73 = 1024;
        int v74 = v40;
        __int16 v75 = 2080;
        *(void *)__int16 v76 = v55;
        *(_WORD *)&v76[8] = 1024;
        *(_DWORD *)&v76[10] = v41;
        __int16 v77 = 2082;
        *(void *)BOOL v78 = v63;
        *(_WORD *)&v78[8] = 1024;
        *(_DWORD *)&v78[10] = a3;
        __int16 v79 = 1024;
        int v80 = v43;
        __int16 v81 = 1024;
        int v82 = v46;
        __int16 v83 = 1024;
        int v84 = v49;
        __int16 v85 = 1024;
        int v86 = v51;
        __int16 v87 = 2048;
        *(void *)uint64_t v88 = v61;
        *(_WORD *)&v88[8] = 2048;
        *(void *)&v88[10] = inbound_body_size;
        __int16 v31 = "%{public}s %{public}s%s<i%u> transaction summary {start_reason=\"%s\", duration_ms=%d, request_method=\"%{"
              "public}s\", response_status=%hu, outbound_start_ms=%d, outbound_duration_ms=%d, inbound_start_ms=%d, inbou"
              "nd_duration_ms=%d, outbound_body_bytes=%llu, inbound_body_bytes=%llu}";
        int v32 = v35;
        uint32_t v33 = 114;
        goto LABEL_42;
      }
    }
  }
}

uint64_t ___ZL23nw_http2_stream_connectP17nw_protocol_http2P12http2_streamP11nw_protocol_block_invoke_46(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void, uint64_t, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), a2, *(unsigned __int16 *)(a1 + 40));
}

uint64_t ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  unsigned int v43 = 0;
  uint64_t v3 = nw_frame_unclaimed_bytes(a2, &v43);
  unsigned int v4 = v43;
  if (v3) {
    BOOL v5 = v43 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  uint64_t v6 = !v5;
  if (!v5)
  {
    uint64_t v7 = v3;
    uint64_t v8 = *(void *)(a1 + 40);
    if ((!v8 || (*(__int16 *)(v8 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v36 = gconnectionLogObj;
      BOOL v37 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      unsigned int v4 = v43;
      if (v37)
      {
        uint64_t v38 = *(void *)(a1 + 40);
        id v39 = (const char *)(v38 + 390);
        BOOL v40 = v38 == 0;
        int v41 = "";
        if (!v38) {
          id v39 = "";
        }
        int v42 = *(_DWORD *)(v38 + 368);
        if (!v40) {
          int v41 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        unint64_t v45 = "nw_protocol_http2_process_input_block_invoke";
        __int16 v46 = 2082;
        uint64_t v47 = v39;
        __int16 v48 = 2080;
        int v49 = v41;
        __int16 v50 = 1024;
        int v51 = v42;
        __int16 v52 = 1024;
        int v53 = v43;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> processing frame of length %u bytes", buf, 0x2Cu);
        unsigned int v4 = v43;
      }
      if (!v4)
      {
        unsigned int v9 = 0;
        goto LABEL_55;
      }
    }
    unsigned int v9 = 0;
    while (1)
    {
      uint64_t v10 = MEMORY[0x1853175E0](*(void *)(*(void *)(a1 + 40) + 96), v7 + v9, v4 - v9);
      int v11 = v10;
      if (v10 < 0) {
        break;
      }
      v9 += v10;
      uint64_t v12 = *(void *)(a1 + 40);
      if ((!v12 || (*(__int16 *)(v12 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v13 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v14 = *(void *)(a1 + 40);
          uint32_t v15 = (const char *)(v14 + 390);
          BOOL v16 = v14 == 0;
          uint64_t v17 = "";
          if (!v14) {
            uint32_t v15 = "";
          }
          int v18 = *(_DWORD *)(v14 + 368);
          if (!v16) {
            uint64_t v17 = " ";
          }
          *(_DWORD *)int buf = 136447234;
          unint64_t v45 = "nw_protocol_http2_process_input_block_invoke";
          __int16 v46 = 2082;
          uint64_t v47 = v15;
          __int16 v48 = 2080;
          int v49 = v17;
          __int16 v50 = 1024;
          int v51 = v18;
          __int16 v52 = 1024;
          int v53 = v9;
          _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> nghttp2_session_mem_recv consumed %u bytes", buf, 0x2Cu);
        }
      }
      unsigned int v4 = v43;
      if (v9 >= v43) {
        goto LABEL_55;
      }
    }
    if (v10 != -902 || (*(_WORD *)(*(void *)(a1 + 40) + 388) & 0x10) == 0)
    {
      if ((*(_WORD *)(*(void *)(a1 + 40) + 388) & 0x8000) != 0) {
        goto LABEL_54;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v20 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_54;
      }
      uint64_t v21 = *(void *)(a1 + 40);
      if (v21) {
        uint64_t v22 = (const char *)(v21 + 390);
      }
      else {
        uint64_t v22 = "";
      }
      if (v21) {
        unint64_t v23 = " ";
      }
      else {
        unint64_t v23 = "";
      }
      int v24 = *(_DWORD *)(v21 + 368);
      uint64_t v25 = nghttp2_strerror();
      *(_DWORD *)int buf = 136447490;
      unint64_t v45 = "nw_protocol_http2_process_input_block_invoke";
      __int16 v46 = 2082;
      uint64_t v47 = v22;
      __int16 v48 = 2080;
      int v49 = v23;
      __int16 v50 = 1024;
      int v51 = v24;
      __int16 v52 = 1024;
      int v53 = v11;
      __int16 v54 = 2082;
      uint64_t v55 = v25;
      unint64_t v26 = "%{public}s %{public}s%s<i%u> ERROR: Could not process incoming data: %d (%{public}s)";
      int v27 = v20;
      os_log_type_t v28 = OS_LOG_TYPE_ERROR;
    }
    else
    {
      if ((*(_WORD *)(*(void *)(a1 + 40) + 388) & 0x8000) != 0) {
        goto LABEL_54;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v29 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_54;
      }
      uint64_t v30 = *(void *)(a1 + 40);
      if (v30) {
        __int16 v31 = (const char *)(v30 + 390);
      }
      else {
        __int16 v31 = "";
      }
      if (v30) {
        int v32 = " ";
      }
      else {
        int v32 = "";
      }
      int v33 = *(_DWORD *)(v30 + 368);
      uint64_t v34 = nghttp2_strerror();
      *(_DWORD *)int buf = 136447490;
      unint64_t v45 = "nw_protocol_http2_process_input_block_invoke";
      __int16 v46 = 2082;
      uint64_t v47 = v31;
      __int16 v48 = 2080;
      int v49 = v32;
      __int16 v50 = 1024;
      int v51 = v33;
      __int16 v52 = 1024;
      int v53 = -902;
      __int16 v54 = 2082;
      uint64_t v55 = v34;
      unint64_t v26 = "%{public}s %{public}s%s<i%u> Could not process incoming data: %d (%{public}s), closing";
      int v27 = v29;
      os_log_type_t v28 = OS_LOG_TYPE_DEFAULT;
    }
    _os_log_impl(&dword_1830D4000, v27, v28, v26, buf, 0x36u);
LABEL_54:
    nw_http2_connection_close(*(void *)(a1 + 40));
LABEL_55:
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v9;
  }
  return v6;
}

uint64_t ___ZL31nw_protocol_http2_process_inputP17nw_protocol_http2_block_invoke_52(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)nw_hash_node_get_extra(a2);
  uint64_t object = nw_hash_node_get_object(a2);
  int v6 = *(unsigned __int16 *)(v4 + 188);
  if ((v6 & 1) == 0 || !*(void *)v4) {
    return 1;
  }
  uint64_t v7 = object;
  if (((v6 | (*(unsigned __int8 *)(v4 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v20 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v22 = *(_DWORD *)(v4 + 176);
      int v21 = *(_DWORD *)(v4 + 180);
      *(_DWORD *)int buf = 136447490;
      os_log_type_t v28 = "nw_protocol_http2_process_input_block_invoke";
      __int16 v29 = 2082;
      uint64_t v30 = (const char *)(v4 + 191);
      __int16 v31 = 2080;
      int v32 = " ";
      __int16 v33 = 1024;
      int v34 = v21;
      __int16 v35 = 1024;
      int v36 = v22;
      __int16 v37 = 1024;
      int v38 = v22;
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> calling input_available on stream %d", buf, 0x32u);
    }
  }
  if (v7)
  {
    uint64_t v8 = *(void *)(v7 + 24);
    if (v8)
    {
      unsigned int v9 = *(void (**)(uint64_t, void))(v8 + 64);
      if (v9)
      {
        v9(v7, *(void *)(a1 + 32));
        return 1;
      }
    }
    __nwlog_obj();
    int v11 = *(const char **)(v7 + 16);
    if (!v11) {
      int v11 = "invalid";
    }
  }
  else
  {
    __nwlog_obj();
    int v11 = "invalid";
  }
  *(_DWORD *)int buf = 136446466;
  os_log_type_t v28 = "nw_protocol_http2_process_input_block_invoke";
  __int16 v29 = 2082;
  uint64_t v30 = v11;
  uint64_t v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v12, &type, &v25))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_44;
      }
      uint32_t v15 = "invalid";
      if (v7 && *(void *)(v7 + 16)) {
        uint32_t v15 = *(const char **)(v7 + 16);
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v28 = "nw_protocol_http2_process_input_block_invoke";
      __int16 v29 = 2082;
      uint64_t v30 = v15;
      BOOL v16 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_43;
    }
    if (!v25)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_44;
      }
      unint64_t v23 = "invalid";
      if (v7 && *(void *)(v7 + 16)) {
        unint64_t v23 = *(const char **)(v7 + 16);
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v28 = "nw_protocol_http2_process_input_block_invoke";
      __int16 v29 = 2082;
      uint64_t v30 = v23;
      BOOL v16 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_43;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v18 = os_log_type_enabled(v13, type);
    if (backtrace_string)
    {
      if (v18)
      {
        int v19 = "invalid";
        if (v7 && *(void *)(v7 + 16)) {
          int v19 = *(const char **)(v7 + 16);
        }
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v28 = "nw_protocol_http2_process_input_block_invoke";
        __int16 v29 = 2082;
        uint64_t v30 = v19;
        __int16 v31 = 2082;
        int v32 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_44;
    }
    if (v18)
    {
      int v24 = "invalid";
      if (v7 && *(void *)(v7 + 16)) {
        int v24 = *(const char **)(v7 + 16);
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v28 = "nw_protocol_http2_process_input_block_invoke";
      __int16 v29 = 2082;
      uint64_t v30 = v24;
      BOOL v16 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_43:
      _os_log_impl(&dword_1830D4000, v13, v14, v16, buf, 0x16u);
    }
  }
LABEL_44:
  if (v12) {
    free(v12);
  }
  return 1;
}

uint64_t nw_protocol_http2_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v12 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v13 = handle[92];
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = (char *)handle + 390;
          *(_WORD *)&buf[22] = 2080;
          os_log_type_t v28 = " ";
          LOWORD(v29) = 1024;
          *(_DWORD *)((char *)&v29 + 2) = v13;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled())
      {
        kdebug_trace();
        if (a2)
        {
LABEL_10:
          if (gLogDatapath)
          {
            os_log_type_t v14 = __nwlog_obj();
            if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
              _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }
          *(void *)int buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_83451;
          os_log_type_t v28 = (const char *)&__block_descriptor_tmp_33_83452;
          __int16 v29 = a2;
          char v30 = 1;
          tqh_first = a2->tqh_first;
          do
          {
            if (!tqh_first) {
              break;
            }
            BOOL v5 = (nw_frame *)*((void *)tqh_first + 4);
            char v6 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
            tqh_first = v5;
          }
          while ((v6 & 1) != 0);
LABEL_14:
          nw_http2_session_send((uint64_t)handle);
          return 1;
        }
      }
      else if (a2)
      {
        goto LABEL_10;
      }
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
      uint32_t v15 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v25 = 0;
      if (__nwlog_fault(v15, &type, &v25))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_66;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          BOOL v18 = "%{public}s called with null array";
          goto LABEL_65;
        }
        if (!v25)
        {
          BOOL v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (!os_log_type_enabled(v16, type)) {
            goto LABEL_66;
          }
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          BOOL v18 = "%{public}s called with null array, backtrace limit exceeded";
          goto LABEL_65;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        BOOL v24 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v24)
          {
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_66;
        }
        if (v24)
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          BOOL v18 = "%{public}s called with null array, no backtrace";
LABEL_65:
          _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0xCu);
        }
      }
LABEL_66:
      if (v15) {
        free(v15);
      }
      goto LABEL_14;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v8, &type, &v25)) {
      goto LABEL_60;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
        int v11 = "%{public}s called with null http2";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (!v25)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
        int v11 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    int v19 = (char *)__nw_create_backtrace_string();
    unsigned int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v22 = os_log_type_enabled(v9, type);
    if (!v19)
    {
      if (v22)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
        int v11 = "%{public}s called with null http2, no backtrace";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v19;
      int v21 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25)) {
    goto LABEL_60;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v25)
    {
      unsigned int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
        int v11 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    int v19 = (char *)__nw_create_backtrace_string();
    unsigned int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v20 = os_log_type_enabled(v9, type);
    if (!v19)
    {
      if (v20)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
        int v11 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_59;
      }
      goto LABEL_60;
    }
    if (v20)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v19;
      int v21 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_1830D4000, v9, v10, v21, buf, 0x16u);
    }
LABEL_43:
    free(v19);
    goto LABEL_60;
  }
  unsigned int v9 = __nwlog_obj();
  os_log_type_t v10 = type;
  if (os_log_type_enabled(v9, type))
  {
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_finalize_output_frames";
    int v11 = "%{public}s called with null protocol";
LABEL_59:
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
  }
LABEL_60:
  if (v8) {
    free(v8);
  }
  return 0;
}

void nw_protocol_http2_stream_get_message_properties(uint64_t a1, uint64_t a2, _DWORD *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
      uint64_t v7 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)int buf = 136446466;
          uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v4) {
          return;
        }
LABEL_35:
        free(v4);
        return;
      }
      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
      uint64_t v7 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)int buf = 136446210;
      uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
      uint64_t v7 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }
  if (*(void *)(a1 + 40))
  {
    if (a3)
    {
      unsigned int v3 = a3[1] & 0xFFFFFFF8;
      *a3 = -1;
      a3[1] = v3;
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12)) {
    goto LABEL_34;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)int buf = 136446210;
    uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
    uint64_t v7 = "%{public}s called with null http2";
    goto LABEL_33;
  }
  if (!v12)
  {
    BOOL v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)int buf = 136446210;
    uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
    uint64_t v7 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_33;
  }
  os_log_type_t v10 = (char *)__nw_create_backtrace_string();
  BOOL v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)int buf = 136446210;
    uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
    uint64_t v7 = "%{public}s called with null http2, no backtrace";
    goto LABEL_33;
  }
  if (v11)
  {
    *(_DWORD *)int buf = 136446466;
    uint32_t v15 = "nw_protocol_http2_stream_get_message_properties";
    __int16 v16 = 2082;
    os_log_type_t v17 = v10;
    _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v4) {
    goto LABEL_35;
  }
}

uint64_t nw_protocol_http2_get_parameters(nw_protocol *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle) {
      return handle[13];
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v14 = "nw_protocol_http2_get_parameters";
    unsigned int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_protocol_http2_get_parameters";
        os_log_type_t v6 = "%{public}s called with null http2";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_protocol_http2_get_parameters";
        os_log_type_t v6 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_protocol_http2_get_parameters";
        os_log_type_t v6 = "%{public}s called with null http2, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v14 = "nw_protocol_http2_get_parameters";
      __int16 v15 = 2082;
      __int16 v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null http2, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  os_log_type_t v14 = "nw_protocol_http2_get_parameters";
  unsigned int v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_protocol_http2_get_parameters";
        os_log_type_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v14 = "nw_protocol_http2_get_parameters";
        os_log_type_t v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v14 = "nw_protocol_http2_get_parameters";
      __int16 v15 = 2082;
      __int16 v16 = backtrace_string;
      BOOL v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v14 = "nw_protocol_http2_get_parameters";
    os_log_type_t v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3) {
    free(v3);
  }
  return 0;
}

BOOL nw_protocol_http2_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v115 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    uint64_t v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103)) {
      goto LABEL_148;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null protocol";
      goto LABEL_147;
    }
    if (!v103)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v57 = __nwlog_obj();
    os_log_type_t v58 = type;
    BOOL v63 = os_log_type_enabled(v57, type);
    if (!backtrace_string)
    {
      if (!v63) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_147;
    }
    if (!v63) {
      goto LABEL_130;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    __int16 v107 = 2082;
    __int16 v108 = backtrace_string;
    id v64 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_129:
    _os_log_impl(&dword_1830D4000, v57, v58, v64, buf, 0x16u);
    goto LABEL_130;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    uint64_t v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103)) {
      goto LABEL_148;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null http2";
      goto LABEL_147;
    }
    if (!v103)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v57 = __nwlog_obj();
    os_log_type_t v58 = type;
    BOOL v65 = os_log_type_enabled(v57, type);
    if (!backtrace_string)
    {
      if (!v65) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null http2, no backtrace";
      goto LABEL_147;
    }
    if (!v65) {
      goto LABEL_130;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    __int16 v107 = 2082;
    __int16 v108 = backtrace_string;
    id v64 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_129;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    uint64_t v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103)) {
      goto LABEL_148;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null input_protocol";
      goto LABEL_147;
    }
    if (!v103)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v57 = __nwlog_obj();
    os_log_type_t v58 = type;
    BOOL v66 = os_log_type_enabled(v57, type);
    if (!backtrace_string)
    {
      if (!v66) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null input_protocol, no backtrace";
      goto LABEL_147;
    }
    if (!v66) {
      goto LABEL_130;
    }
    *(_DWORD *)int buf = 136446466;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    __int16 v107 = 2082;
    __int16 v108 = backtrace_string;
    id v64 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
    goto LABEL_129;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    uint64_t v56 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v103 = 0;
    if (!__nwlog_fault(v56, &type, &v103)) {
      goto LABEL_148;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null return_array";
      goto LABEL_147;
    }
    if (!v103)
    {
      int v57 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (!os_log_type_enabled(v57, type)) {
        goto LABEL_148;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      int v59 = "%{public}s called with null return_array, backtrace limit exceeded";
      goto LABEL_147;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v57 = __nwlog_obj();
    os_log_type_t v58 = type;
    BOOL v67 = os_log_type_enabled(v57, type);
    if (backtrace_string)
    {
      if (v67)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v106 = "nw_protocol_http2_get_output_frames";
        __int16 v107 = 2082;
        __int16 v108 = backtrace_string;
        id v64 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
        goto LABEL_129;
      }
LABEL_130:
      free(backtrace_string);
      goto LABEL_148;
    }
    if (!v67) {
      goto LABEL_148;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    int v59 = "%{public}s called with null return_array, no backtrace";
LABEL_147:
    _os_log_impl(&dword_1830D4000, v57, v58, v59, buf, 0xCu);
LABEL_148:
    if (v56) {
      free(v56);
    }
    return 0;
  }
  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v60 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v61 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      __int16 v107 = 2082;
      __int16 v108 = handle + 390;
      __int16 v109 = 2080;
      __int16 v110 = " ";
      __int16 v111 = 1024;
      int v112 = v61;
      _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v19 = gconnectionLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v20 = *((_DWORD *)handle + 92);
        identifier = a2->identifier;
        *(_DWORD *)int buf = 136447490;
        __int16 v106 = "nw_protocol_http2_get_output_frames";
        __int16 v107 = 2082;
        __int16 v108 = handle + 390;
        __int16 v109 = 2080;
        __int16 v110 = " ";
        __int16 v111 = 1024;
        int v112 = v20;
        __int16 v113 = 2048;
        *(void *)int v114 = a2;
        *(_WORD *)&v114[8] = 2080;
        *(void *)&v114[10] = identifier;
        uint64_t v18 = "%{public}s %{public}s%s<i%u> cannot get output frames for protocol %p (%s) without proper output handler context";
        BOOL v22 = v19;
        os_log_type_t v23 = OS_LOG_TYPE_ERROR;
        uint32_t v24 = 58;
LABEL_31:
        _os_log_impl(&dword_1830D4000, v22, v23, v18, buf, v24);
        return 0;
      }
      return result;
    }
    return 0;
  }
  uint64_t v11 = output_handler_context[4];
  if (v11)
  {
    int v12 = *(unsigned __int16 *)(v11 + 188);
    int v13 = v12 | (*(unsigned __int8 *)(v11 + 190) << 16);
    if ((v12 & 1) == 0)
    {
      if ((v13 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v14 = gconnectionLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          int v17 = *(_DWORD *)(v11 + 176);
          int v16 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)int buf = 136447490;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = (char *)(v11 + 191);
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v16;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v17;
          *(_WORD *)&v114[4] = 2048;
          *(void *)&v114[6] = a2;
          uint64_t v18 = "%{public}s %{public}s%s<i%u:s%d> cannot get output frames for stream that is not yet open, protocol (%p)";
LABEL_30:
          BOOL v22 = v14;
          os_log_type_t v23 = OS_LOG_TYPE_ERROR;
          uint32_t v24 = 54;
          goto LABEL_31;
        }
        return result;
      }
      return 0;
    }
    if ((v12 & 0x2000) != 0)
    {
      BOOL result = 0;
      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v29 = gconnectionLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          int v30 = *((_DWORD *)handle + 92);
          int v31 = *(_DWORD *)(v11 + 176);
          *(_DWORD *)int buf = 136447234;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = handle + 390;
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v30;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v31;
          uint64_t v18 = "%{public}s %{public}s%s<i%u> stream %d sending informational response, not allowing output frames";
          BOOL v22 = v29;
          os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
          uint32_t v24 = 44;
          goto LABEL_31;
        }
      }
      return result;
    }
    if (*(void *)(v11 + 16))
    {
      BOOL result = 0;
      if ((v13 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v26 = gconnectionLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
        if (result)
        {
          int v28 = *(_DWORD *)(v11 + 176);
          int v27 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)int buf = 136447490;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = (char *)(v11 + 191);
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v27;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v28;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v28;
          uint64_t v18 = "%{public}s %{public}s%s<i%u:s%d> stream %d already has waiting output frames, cannot get more";
          BOOL v22 = v26;
          os_log_type_t v23 = OS_LOG_TYPE_DEBUG;
          uint32_t v24 = 50;
          goto LABEL_31;
        }
      }
      return result;
    }
    if (a4 >= 0x1000000) {
      size_t v32 = 0x1000000;
    }
    else {
      size_t v32 = a4;
    }
    if ((v13 & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v72 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v74 = *(_DWORD *)(v11 + 176);
        int v73 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)int buf = 136447746;
        __int16 v106 = "nw_protocol_http2_get_output_frames";
        __int16 v107 = 2082;
        __int16 v108 = (char *)(v11 + 191);
        __int16 v109 = 2080;
        __int16 v110 = " ";
        __int16 v111 = 1024;
        int v112 = v73;
        __int16 v113 = 1024;
        *(_DWORD *)int v114 = v74;
        *(_WORD *)&v114[4] = 1024;
        *(_DWORD *)&v114[6] = v32;
        *(_WORD *)&v114[10] = 1024;
        *(_DWORD *)&v114[12] = a4;
        _os_log_impl(&dword_1830D4000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> h2 was asked for frame of adjusted size %u (original %u)", buf, 0x38u);
      }
    }
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v75 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v77 = *(_DWORD *)(v11 + 176);
        int v76 = *(_DWORD *)(v11 + 180);
        *(_DWORD *)int buf = 136447490;
        __int16 v106 = "nw_protocol_http2_get_output_frames";
        __int16 v107 = 2082;
        __int16 v108 = (char *)(v11 + 191);
        __int16 v109 = 2080;
        __int16 v110 = " ";
        __int16 v111 = 1024;
        int v112 = v76;
        __int16 v113 = 1024;
        *(_DWORD *)int v114 = v77;
        *(_WORD *)&v114[4] = 1024;
        *(_DWORD *)&v114[6] = v32;
        _os_log_impl(&dword_1830D4000, v75, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> adding frame of size %u", buf, 0x32u);
      }
    }
    if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v78 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v79 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447234;
        __int16 v106 = "http2_create_output_frame";
        __int16 v107 = 2082;
        __int16 v108 = handle + 390;
        __int16 v109 = 2080;
        __int16 v110 = " ";
        __int16 v111 = 1024;
        int v112 = v79;
        __int16 v113 = 1024;
        *(_DWORD *)int v114 = v32;
        _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> requested output frame of length %u", buf, 0x2Cu);
      }
    }
    uint64_t frame = nw_frame_cache_create_frame((uint64_t *)handle + 25, v32);
    if (frame)
    {
      uint64_t v34 = frame;
      *(void *)(frame + 16) = 0;
      __int16 v35 = (uint64_t *)*((void *)handle + 24);
      *(void *)(frame + 24) = v35;
      uint64_t *v35 = frame;
      *((void *)handle + 24) = frame + 16;
      *(void *)(frame + 80) = nw_protocol_http2_frame_output_finalizer;
      *(void *)(frame + 88) = 0;
      http2_output_frame_metadata_reset(frame, (uint64_t)handle, (uint64_t)a2);
      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v80 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v81 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136447490;
          __int16 v106 = "http2_create_output_frame";
          __int16 v107 = 2082;
          __int16 v108 = handle + 390;
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v81;
          __int16 v113 = 2048;
          *(void *)int v114 = v34;
          *(_WORD *)&v114[8] = 1024;
          *(_DWORD *)&v114[10] = v32;
          _os_log_impl(&dword_1830D4000, v80, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> output_frame_create returning frame %p for requested length %u", buf, 0x36u);
        }
      }
      int v36 = *(_DWORD *)(v34 + 52);
      if (v36) {
        int v37 = v36 - (*(_DWORD *)(v34 + 56) + *(_DWORD *)(v34 + 60));
      }
      else {
        int v37 = 0;
      }
      int v38 = *(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16);
      if (v37 == v32)
      {
        if ((v38 & 0x80000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v84 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v86 = *(_DWORD *)(v11 + 176);
            int v85 = *(_DWORD *)(v11 + 180);
            *(_DWORD *)int buf = 136447490;
            __int16 v106 = "nw_protocol_http2_get_output_frames";
            __int16 v107 = 2082;
            __int16 v108 = (char *)(v11 + 191);
            __int16 v109 = 2080;
            __int16 v110 = " ";
            __int16 v111 = 1024;
            int v112 = v85;
            __int16 v113 = 1024;
            *(_DWORD *)int v114 = v86;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v32;
            _os_log_impl(&dword_1830D4000, v84, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> returning frame of %u bytes", buf, 0x32u);
          }
        }
        *(void *)(v34 + 32) = 0;
        tqh_last = a6->tqh_last;
        *(void *)(v34 + 40) = tqh_last;
        *tqh_last = (nw_frame *)v34;
        a6->tqh_last = (nw_frame **)(v34 + 32);
        return 1;
      }
      if ((v38 & 0x80000) != 0)
      {
LABEL_92:
        nw_frame_finalize(v34);
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v41 = *(_DWORD *)(v11 + 176);
      int v40 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)int buf = 136447746;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      __int16 v107 = 2082;
      __int16 v108 = (char *)(v11 + 191);
      __int16 v109 = 2080;
      __int16 v110 = " ";
      __int16 v111 = 1024;
      int v112 = v40;
      __int16 v113 = 1024;
      *(_DWORD *)int v114 = v41;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v37;
      *(_WORD *)&v114[10] = 1024;
      *(_DWORD *)&v114[12] = v32;
      int v42 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v103 = 0;
      if (__nwlog_fault(v42, &type, &v103))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          unsigned int v43 = gconnectionLogObj;
          os_log_type_t v44 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_90;
          }
          int v46 = *(_DWORD *)(v11 + 176);
          int v45 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)int buf = 136447746;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = (char *)(v11 + 191);
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v45;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v46;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          uint64_t v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_create_output_frame";
          goto LABEL_89;
        }
        if (!v103)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          unsigned int v43 = gconnectionLogObj;
          os_log_type_t v44 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_90;
          }
          int v53 = *(_DWORD *)(v11 + 176);
          int v52 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)int buf = 136447746;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = (char *)(v11 + 191);
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v52;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v53;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          uint64_t v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_creat"
                "e_output_frame, backtrace limit exceeded";
          goto LABEL_89;
        }
        __int16 v48 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        unsigned int v43 = gconnectionLogObj;
        os_log_type_t v44 = type;
        BOOL v49 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v48)
        {
          if (v49)
          {
            int v51 = *(_DWORD *)(v11 + 176);
            int v50 = *(_DWORD *)(v11 + 180);
            *(_DWORD *)int buf = 136448002;
            __int16 v106 = "nw_protocol_http2_get_output_frames";
            __int16 v107 = 2082;
            __int16 v108 = (char *)(v11 + 191);
            __int16 v109 = 2080;
            __int16 v110 = " ";
            __int16 v111 = 1024;
            int v112 = v50;
            __int16 v113 = 1024;
            *(_DWORD *)int v114 = v51;
            *(_WORD *)&v114[4] = 1024;
            *(_DWORD *)&v114[6] = v37;
            *(_WORD *)&v114[10] = 1024;
            *(_DWORD *)&v114[12] = v32;
            *(_WORD *)&v114[16] = 2082;
            *(void *)&v114[18] = v48;
            _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_create_output_frame, dumping backtrace:%{public}s", buf, 0x42u);
          }
          free(v48);
          goto LABEL_90;
        }
        if (v49)
        {
          int v55 = *(_DWORD *)(v11 + 176);
          int v54 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)int buf = 136447746;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = (char *)(v11 + 191);
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v54;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v55;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v37;
          *(_WORD *)&v114[10] = 1024;
          *(_DWORD *)&v114[12] = v32;
          uint64_t v47 = "%{public}s %{public}s%s<i%u:s%d> got output frame with wrong size (got %u != wanted %u) from http2_creat"
                "e_output_frame, no backtrace";
LABEL_89:
          _os_log_impl(&dword_1830D4000, v43, v44, v47, buf, 0x38u);
        }
      }
LABEL_90:
      if (v42) {
        free(v42);
      }
      goto LABEL_92;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v106 = "http2_create_output_frame";
    uint64_t v68 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v103 = 0;
    if (__nwlog_fault(v68, &type, &v103))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v69 = __nwlog_obj();
        os_log_type_t v70 = type;
        if (!os_log_type_enabled(v69, type)) {
          goto LABEL_184;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v106 = "http2_create_output_frame";
        __int16 v71 = "%{public}s called with null frame";
LABEL_183:
        _os_log_impl(&dword_1830D4000, v69, v70, v71, buf, 0xCu);
        goto LABEL_184;
      }
      if (!v103)
      {
        __int16 v69 = __nwlog_obj();
        os_log_type_t v70 = type;
        if (!os_log_type_enabled(v69, type)) {
          goto LABEL_184;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v106 = "http2_create_output_frame";
        __int16 v71 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_183;
      }
      int v82 = (char *)__nw_create_backtrace_string();
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      BOOL v83 = os_log_type_enabled(v69, type);
      if (!v82)
      {
        if (!v83) {
          goto LABEL_184;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v106 = "http2_create_output_frame";
        __int16 v71 = "%{public}s called with null frame, no backtrace";
        goto LABEL_183;
      }
      if (v83)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v106 = "http2_create_output_frame";
        __int16 v107 = 2082;
        __int16 v108 = v82;
        _os_log_impl(&dword_1830D4000, v69, v70, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v82);
    }
LABEL_184:
    if (v68) {
      free(v68);
    }
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) != 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v88 = *(_DWORD *)(v11 + 176);
    int v87 = *(_DWORD *)(v11 + 180);
    *(_DWORD *)int buf = 136447490;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    __int16 v107 = 2082;
    __int16 v108 = (char *)(v11 + 191);
    __int16 v109 = 2080;
    __int16 v110 = " ";
    __int16 v111 = 1024;
    int v112 = v87;
    __int16 v113 = 1024;
    *(_DWORD *)int v114 = v88;
    *(_WORD *)&v114[4] = 1024;
    *(_DWORD *)&v114[6] = v32;
    uint64_t v89 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v103 = 0;
    if (!__nwlog_fault(v89, &type, &v103)) {
      goto LABEL_209;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v90 = gconnectionLogObj;
      os_log_type_t v91 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_209;
      }
      int v93 = *(_DWORD *)(v11 + 176);
      int v92 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)int buf = 136447490;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      __int16 v107 = 2082;
      __int16 v108 = (char *)(v11 + 191);
      __int16 v109 = 2080;
      __int16 v110 = " ";
      __int16 v111 = 1024;
      int v112 = v92;
      __int16 v113 = 1024;
      *(_DWORD *)int v114 = v93;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v32;
      __int16 v94 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u";
    }
    else if (v103)
    {
      __int16 v95 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v90 = gconnectionLogObj;
      os_log_type_t v91 = type;
      BOOL v96 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v95)
      {
        if (v96)
        {
          int v98 = *(_DWORD *)(v11 + 176);
          int v97 = *(_DWORD *)(v11 + 180);
          *(_DWORD *)int buf = 136447746;
          __int16 v106 = "nw_protocol_http2_get_output_frames";
          __int16 v107 = 2082;
          __int16 v108 = (char *)(v11 + 191);
          __int16 v109 = 2080;
          __int16 v110 = " ";
          __int16 v111 = 1024;
          int v112 = v97;
          __int16 v113 = 1024;
          *(_DWORD *)int v114 = v98;
          *(_WORD *)&v114[4] = 1024;
          *(_DWORD *)&v114[6] = v32;
          *(_WORD *)&v114[10] = 2082;
          *(void *)&v114[12] = v95;
          _os_log_impl(&dword_1830D4000, v90, v91, "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u, dumping backtrace:%{public}s", buf, 0x3Cu);
        }
        free(v95);
        goto LABEL_209;
      }
      if (!v96)
      {
LABEL_209:
        if (v89) {
          free(v89);
        }
        return 0;
      }
      int v102 = *(_DWORD *)(v11 + 176);
      int v101 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)int buf = 136447490;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      __int16 v107 = 2082;
      __int16 v108 = (char *)(v11 + 191);
      __int16 v109 = 2080;
      __int16 v110 = " ";
      __int16 v111 = 1024;
      int v112 = v101;
      __int16 v113 = 1024;
      *(_DWORD *)int v114 = v102;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v32;
      __int16 v94 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u, no backtrace";
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v90 = gconnectionLogObj;
      os_log_type_t v91 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_209;
      }
      int v100 = *(_DWORD *)(v11 + 176);
      int v99 = *(_DWORD *)(v11 + 180);
      *(_DWORD *)int buf = 136447490;
      __int16 v106 = "nw_protocol_http2_get_output_frames";
      __int16 v107 = 2082;
      __int16 v108 = (char *)(v11 + 191);
      __int16 v109 = 2080;
      __int16 v110 = " ";
      __int16 v111 = 1024;
      int v112 = v99;
      __int16 v113 = 1024;
      *(_DWORD *)int v114 = v100;
      *(_WORD *)&v114[4] = 1024;
      *(_DWORD *)&v114[6] = v32;
      __int16 v94 = "%{public}s %{public}s%s<i%u:s%d> failed to create/reuse output frame of length %u, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v90, v91, v94, buf, 0x32u);
    goto LABEL_209;
  }
  if (*((__int16 *)handle + 194) < 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  uint64_t v14 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v25 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136447490;
    __int16 v106 = "nw_protocol_http2_get_output_frames";
    __int16 v107 = 2082;
    __int16 v108 = handle + 390;
    __int16 v109 = 2080;
    __int16 v110 = " ";
    __int16 v111 = 1024;
    int v112 = v25;
    __int16 v113 = 1042;
    *(_DWORD *)int v114 = 16;
    *(_WORD *)&v114[4] = 2098;
    *(void *)&v114[6] = a2;
    uint64_t v18 = "%{public}s %{public}s%s<i%u> cannot find hash table entry for %{public,uuid_t}.16P";
    goto LABEL_30;
  }
  return result;
}

void nw_protocol_http2_frame_output_finalizer(nw_frame *a1, int a2, void *a3)
{
  uint64_t v121 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)int buf = 136446210;
      uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
      unsigned int v3 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(type) = 16;
      LOBYTE(v113) = 0;
      if (!__nwlog_fault(v3, &type, &v113)) {
        goto LABEL_40;
      }
      if (type == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type)) {
          goto LABEL_40;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
        os_log_type_t v6 = "%{public}s http2 output frames should no longer have nonnull context";
      }
      else
      {
        if ((_BYTE)v113)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v15 = gLogObj;
          os_log_type_t v16 = type;
          BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type);
          if (backtrace_string)
          {
            if (v17)
            {
              *(_DWORD *)int buf = 136446466;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2082;
              *(void *)uint64_t v118 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s http2 output frames should no longer have nonnull context, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            if (v3) {
              goto LABEL_41;
            }
            return;
          }
          if (!v17) {
            goto LABEL_40;
          }
          *(_DWORD *)int buf = 136446210;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          os_log_type_t v6 = "%{public}s http2 output frames should no longer have nonnull context, no backtrace";
          int v31 = v15;
          os_log_type_t v32 = v16;
          goto LABEL_39;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)type)) {
          goto LABEL_40;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
        os_log_type_t v6 = "%{public}s http2 output frames should no longer have nonnull context, backtrace limit exceeded";
      }
LABEL_38:
      int v31 = v4;
      os_log_type_t v32 = v5;
LABEL_39:
      _os_log_impl(&dword_1830D4000, v31, v32, v6, buf, 0xCu);
      goto LABEL_40;
    }
    if (gLogDatapath)
    {
      int v98 = __nwlog_obj();
      if (os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446978;
        uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
        __int16 v117 = 2048;
        *(void *)uint64_t v118 = a1;
        *(_WORD *)&v118[8] = 1024;
        *(_DWORD *)&v118[10] = a2;
        *(_WORD *)&v118[14] = 2048;
        *(void *)&v118[16] = 0;
        _os_log_impl(&dword_1830D4000, v98, OS_LOG_TYPE_DEBUG, "%{public}s called with frame %p success %d context %p", buf, 0x26u);
      }
    }
    __int16 v9 = *((_WORD *)a1 + 102);
    BOOL v10 = (uint64_t *)((char *)a1 + 208);
    if ((v9 & 4) != 0)
    {
      uint64_t v11 = *v10;
      if (*v10)
      {
        uint64_t v12 = *((void *)a1 + 2);
        int v13 = (void *)*((void *)a1 + 3);
        if (v12)
        {
          *(void *)(v12 + 24) = v13;
          int v13 = (void *)*((void *)a1 + 3);
        }
        else
        {
          *(void *)(v11 + 192) = v13;
        }
        *int v13 = v12;
        *((void *)a1 + 2) = 0;
        *((void *)a1 + 3) = 0;
        if (!a2)
        {
          if (*(__int16 *)(v11 + 388) < 0 || !gLogDatapath) {
            goto LABEL_142;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v29 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_142;
          }
          int v30 = *(_DWORD *)(v11 + 368);
          *(_DWORD *)int buf = 136446978;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v11 + 390;
          *(_WORD *)&v118[8] = 2080;
          *(void *)&v118[10] = " ";
          *(_WORD *)&v118[18] = 1024;
          *(_DWORD *)&v118[20] = v30;
          int v25 = "%{public}s %{public}s%s<i%u> disposing of output frame, finalizer called with success == false";
          uint64_t v26 = v29;
          os_log_type_t v27 = OS_LOG_TYPE_DEBUG;
          uint32_t v28 = 38;
LABEL_29:
          _os_log_impl(&dword_1830D4000, v26, v27, v25, buf, v28);
          goto LABEL_142;
        }
        uint64_t v18 = (void *)*((void *)a1 + 27);
        if (v18)
        {
          uint64_t stream_from_protocol = nw_http2_get_stream_from_protocol(v11, *((void *)a1 + 27));
          if (stream_from_protocol)
          {
            uint64_t v20 = stream_from_protocol;
            int v21 = *(unsigned __int16 *)(stream_from_protocol + 188);
            if ((v21 & 1) == 0 && *(int *)(stream_from_protocol + 176) >= 1)
            {
              if (((v21 | (*(unsigned __int8 *)(stream_from_protocol + 190) << 16)) & 0x80000) != 0) {
                goto LABEL_142;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v22 = gconnectionLogObj;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
                goto LABEL_142;
              }
              int v24 = *(_DWORD *)(v20 + 176);
              int v23 = *(_DWORD *)(v20 + 180);
              *(_DWORD *)int buf = 136447234;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2082;
              *(void *)uint64_t v118 = v20 + 191;
              *(_WORD *)&v118[8] = 2080;
              *(void *)&v118[10] = " ";
              *(_WORD *)&v118[18] = 1024;
              *(_DWORD *)&v118[20] = v23;
              *(_WORD *)&v118[24] = 1024;
              *(_DWORD *)&v118[26] = v24;
              int v25 = "%{public}s %{public}s%s<i%u:s%d> Cannot send data on a stream that is not open but has a greater tha"
                    "n zero stream id";
              uint64_t v26 = v22;
              os_log_type_t v27 = OS_LOG_TYPE_ERROR;
              uint32_t v28 = 44;
              goto LABEL_29;
            }
            uint64_t v39 = *(void *)(stream_from_protocol + 104);
            if (nw_protocol_copy_http_definition_onceToken != -1) {
              dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
            }
            id v40 = (id)nw_protocol_copy_http_definition_http_definition;
            int v41 = nw_frame_copy_metadata_for_protocol((uint64_t)a1, (uint64_t)v40);
            int v42 = v41;
            if (v39)
            {
              if (v40) {
                os_release(v40);
              }
              if (v42)
              {
                long long type = 0uLL;
                nw_protocol_metadata_copy_identifier(v42, &type);
                long long v113 = 0uLL;
                nw_protocol_metadata_copy_identifier(*(void **)(v20 + 104), &v113);
                if (v113 == type)
                {
                  os_release(v42);
                  goto LABEL_124;
                }
                __nwlog_obj();
                *(_DWORD *)int buf = 136447234;
                uint64_t v116 = "nw_http2_save_metadata_from_frame";
                __int16 v117 = 1040;
                *(_DWORD *)uint64_t v118 = 16;
                *(_WORD *)&v118[4] = 2096;
                *(void *)&v118[6] = &v113;
                *(_WORD *)&v118[14] = 1040;
                *(_DWORD *)&v118[16] = 16;
                *(_WORD *)&v118[20] = 2096;
                *(void *)&v118[22] = &type;
                BOOL v63 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t v112 = OS_LOG_TYPE_ERROR;
                char v111 = 0;
                if (!__nwlog_fault(v63, &v112, &v111)) {
                  goto LABEL_177;
                }
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  id v64 = __nwlog_obj();
                  os_log_type_t v65 = v112;
                  if (os_log_type_enabled(v64, v112))
                  {
                    *(_DWORD *)int buf = 136447234;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    __int16 v117 = 1040;
                    *(_DWORD *)uint64_t v118 = 16;
                    *(_WORD *)&v118[4] = 2096;
                    *(void *)&v118[6] = &v113;
                    *(_WORD *)&v118[14] = 1040;
                    *(_DWORD *)&v118[16] = 16;
                    *(_WORD *)&v118[20] = 2096;
                    *(void *)&v118[22] = &type;
                    BOOL v66 = "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uui"
                          "d_t}.16P != new %{uuid_t}.16P)";
LABEL_176:
                    _os_log_impl(&dword_1830D4000, v64, v65, v66, buf, 0x2Cu);
                  }
                }
                else if (v111)
                {
                  int v84 = (char *)__nw_create_backtrace_string();
                  id v64 = __nwlog_obj();
                  os_log_type_t v65 = v112;
                  BOOL v85 = os_log_type_enabled(v64, v112);
                  if (v84)
                  {
                    if (v85)
                    {
                      *(_DWORD *)int buf = 136447490;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      __int16 v117 = 1040;
                      *(_DWORD *)uint64_t v118 = 16;
                      *(_WORD *)&v118[4] = 2096;
                      *(void *)&v118[6] = &v113;
                      *(_WORD *)&v118[14] = 1040;
                      *(_DWORD *)&v118[16] = 16;
                      *(_WORD *)&v118[20] = 2096;
                      *(void *)&v118[22] = &type;
                      *(_WORD *)&v118[30] = 2082;
                      *(void *)&v118[32] = v84;
                      _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uuid_t}.16P != new %{uuid_t}.16P), dumping backtrace:%{public}s", buf, 0x36u);
                    }
                    free(v84);
                    goto LABEL_177;
                  }
                  if (v85)
                  {
                    *(_DWORD *)int buf = 136447234;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    __int16 v117 = 1040;
                    *(_DWORD *)uint64_t v118 = 16;
                    *(_WORD *)&v118[4] = 2096;
                    *(void *)&v118[6] = &v113;
                    *(_WORD *)&v118[14] = 1040;
                    *(_DWORD *)&v118[16] = 16;
                    *(_WORD *)&v118[20] = 2096;
                    *(void *)&v118[22] = &type;
                    BOOL v66 = "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uui"
                          "d_t}.16P != new %{uuid_t}.16P), no backtrace";
                    goto LABEL_176;
                  }
                }
                else
                {
                  id v64 = __nwlog_obj();
                  os_log_type_t v65 = v112;
                  if (os_log_type_enabled(v64, v112))
                  {
                    *(_DWORD *)int buf = 136447234;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    __int16 v117 = 1040;
                    *(_DWORD *)uint64_t v118 = 16;
                    *(_WORD *)&v118[4] = 2096;
                    *(void *)&v118[6] = &v113;
                    *(_WORD *)&v118[14] = 1040;
                    *(_DWORD *)&v118[16] = 16;
                    *(_WORD *)&v118[20] = 2096;
                    *(void *)&v118[22] = &type;
                    BOOL v66 = "%{public}s existing metadata identifier does not match new metadata identifier (existing %{uui"
                          "d_t}.16P != new %{uuid_t}.16P), backtrace limit exceeded";
                    goto LABEL_176;
                  }
                }
LABEL_177:
                if (v63) {
                  free(v63);
                }
                os_release(v42);
                goto LABEL_208;
              }
              if (((*(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16)) & 0x80000) == 0
                && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v60 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v62 = *(_DWORD *)(v20 + 176);
                  int v61 = *(_DWORD *)(v20 + 180);
                  *(_DWORD *)int buf = 136447490;
                  uint64_t v116 = "nw_http2_save_metadata_from_frame";
                  __int16 v117 = 2082;
                  *(void *)uint64_t v118 = v20 + 191;
                  *(_WORD *)&v118[8] = 2080;
                  *(void *)&v118[10] = " ";
                  *(_WORD *)&v118[18] = 1024;
                  *(_DWORD *)&v118[20] = v61;
                  *(_WORD *)&v118[24] = 1024;
                  *(_DWORD *)&v118[26] = v62;
                  *(_WORD *)&v118[30] = 2048;
                  *(void *)&v118[32] = a1;
                  _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> no http metadata on frame %p, sending body data only", buf, 0x36u);
                }
              }
LABEL_124:
              if (nw_http2_submit_message(v11, v18, v20, (uint64_t)a1))
              {
                ++*(_WORD *)(v11 + 374);
                nw_http2_session_send(v11);
                return;
              }
              __nwlog_obj();
              int v72 = *(_DWORD *)(v20 + 176);
              *(_DWORD *)int buf = 136447234;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2048;
              *(void *)uint64_t v118 = v18;
              *(_WORD *)&v118[8] = 2048;
              *(void *)&v118[10] = v20;
              *(_WORD *)&v118[18] = 1024;
              *(_DWORD *)&v118[20] = v72;
              *(_WORD *)&v118[24] = 2048;
              *(void *)&v118[26] = a1;
              int v73 = (const char *)_os_log_send_and_compose_impl();
              LOBYTE(type) = 16;
              LOBYTE(v113) = 0;
              if (!__nwlog_fault(v73, &type, &v113)) {
                goto LABEL_170;
              }
              if (type == 17)
              {
                int v74 = __nwlog_obj();
                os_log_type_t v75 = type;
                if (os_log_type_enabled(v74, (os_log_type_t)type))
                {
                  int v76 = *(_DWORD *)(v20 + 176);
                  *(_DWORD *)int buf = 136447234;
                  uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
                  __int16 v117 = 2048;
                  *(void *)uint64_t v118 = v18;
                  *(_WORD *)&v118[8] = 2048;
                  *(void *)&v118[10] = v20;
                  *(_WORD *)&v118[18] = 1024;
                  *(_DWORD *)&v118[20] = v76;
                  *(_WORD *)&v118[24] = 2048;
                  *(void *)&v118[26] = a1;
                  int v77 = "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame %p";
LABEL_169:
                  _os_log_impl(&dword_1830D4000, v74, v75, v77, buf, 0x30u);
                }
              }
              else if ((_BYTE)v113)
              {
                BOOL v78 = (char *)__nw_create_backtrace_string();
                int v74 = __nwlog_obj();
                os_log_type_t v75 = type;
                BOOL v79 = os_log_type_enabled(v74, (os_log_type_t)type);
                if (v78)
                {
                  if (v79)
                  {
                    int v80 = *(_DWORD *)(v20 + 176);
                    *(_DWORD *)int buf = 136447490;
                    uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
                    __int16 v117 = 2048;
                    *(void *)uint64_t v118 = v18;
                    *(_WORD *)&v118[8] = 2048;
                    *(void *)&v118[10] = v20;
                    *(_WORD *)&v118[18] = 1024;
                    *(_DWORD *)&v118[20] = v80;
                    *(_WORD *)&v118[24] = 2048;
                    *(void *)&v118[26] = a1;
                    *(_WORD *)&v118[34] = 2082;
                    *(void *)&v118[36] = v78;
                    _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame %p, dumping backtrace:%{public}s", buf, 0x3Au);
                  }
                  free(v78);
                  goto LABEL_170;
                }
                if (v79)
                {
                  int v89 = *(_DWORD *)(v20 + 176);
                  *(_DWORD *)int buf = 136447234;
                  uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
                  __int16 v117 = 2048;
                  *(void *)uint64_t v118 = v18;
                  *(_WORD *)&v118[8] = 2048;
                  *(void *)&v118[10] = v20;
                  *(_WORD *)&v118[18] = 1024;
                  *(_DWORD *)&v118[20] = v89;
                  *(_WORD *)&v118[24] = 2048;
                  *(void *)&v118[26] = a1;
                  int v77 = "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame "
                        "%p, no backtrace";
                  goto LABEL_169;
                }
              }
              else
              {
                int v74 = __nwlog_obj();
                os_log_type_t v75 = type;
                if (os_log_type_enabled(v74, (os_log_type_t)type))
                {
                  int v88 = *(_DWORD *)(v20 + 176);
                  *(_DWORD *)int buf = 136447234;
                  uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
                  __int16 v117 = 2048;
                  *(void *)uint64_t v118 = v18;
                  *(_WORD *)&v118[8] = 2048;
                  *(void *)&v118[10] = v20;
                  *(_WORD *)&v118[18] = 1024;
                  *(_DWORD *)&v118[20] = v88;
                  *(_WORD *)&v118[24] = 2048;
                  *(void *)&v118[26] = a1;
                  int v77 = "%{public}s failed to submit request for protocol %p, stream %p (might have stream id %d), frame "
                        "%p, backtrace limit exceeded";
                  goto LABEL_169;
                }
              }
LABEL_170:
              if (!v73) {
                goto LABEL_142;
              }
              int v82 = (char *)v73;
              goto LABEL_141;
            }
            *(void *)(v20 + 104) = v41;
            if (v40)
            {
              os_release(v40);
              int v42 = *(void **)(v20 + 104);
            }
            if (v42)
            {
              if (nw_protocol_metadata_is_http(v42))
              {
                int v53 = *(void **)(v20 + 104);
                if ((*(_WORD *)(v11 + 388) & 0x80) != 0)
                {
                  id v54 = nw_http_metadata_copy_response(v53);
                  if (!v54)
                  {
                    __nwlog_obj();
                    *(_DWORD *)int buf = 136446210;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    int v55 = (char *)_os_log_send_and_compose_impl();
                    LOBYTE(type) = 16;
                    LOBYTE(v113) = 0;
                    if (!__nwlog_fault(v55, &type, &v113)) {
                      goto LABEL_206;
                    }
                    if (type == 17)
                    {
                      uint64_t v56 = __nwlog_obj();
                      os_log_type_t v57 = type;
                      if (!os_log_type_enabled(v56, (os_log_type_t)type)) {
                        goto LABEL_206;
                      }
                      *(_DWORD *)int buf = 136446210;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      os_log_type_t v58 = "%{public}s did not find response on frame";
                      goto LABEL_205;
                    }
                    if (!(_BYTE)v113)
                    {
                      uint64_t v56 = __nwlog_obj();
                      os_log_type_t v57 = type;
                      if (!os_log_type_enabled(v56, (os_log_type_t)type)) {
                        goto LABEL_206;
                      }
                      *(_DWORD *)int buf = 136446210;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      os_log_type_t v58 = "%{public}s did not find response on frame, backtrace limit exceeded";
                      goto LABEL_205;
                    }
                    BOOL v90 = (char *)__nw_create_backtrace_string();
                    uint64_t v56 = __nwlog_obj();
                    os_log_type_t v57 = type;
                    BOOL v93 = os_log_type_enabled(v56, (os_log_type_t)type);
                    if (!v90)
                    {
                      if (!v93) {
                        goto LABEL_206;
                      }
                      *(_DWORD *)int buf = 136446210;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      os_log_type_t v58 = "%{public}s did not find response on frame, no backtrace";
                      goto LABEL_205;
                    }
                    if (v93)
                    {
                      *(_DWORD *)int buf = 136446466;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      __int16 v117 = 2082;
                      *(void *)uint64_t v118 = v90;
                      int v92 = "%{public}s did not find response on frame, dumping backtrace:%{public}s";
                      goto LABEL_188;
                    }
LABEL_189:
                    free(v90);
                    if (!v55)
                    {
LABEL_208:
                      if (((*(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16)) & 0x80000) == 0
                        && gLogDatapath)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        char v103 = gconnectionLogObj;
                        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                        {
                          int v105 = *(_DWORD *)(v20 + 176);
                          int v104 = *(_DWORD *)(v20 + 180);
                          *(_DWORD *)int buf = 136447490;
                          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
                          __int16 v117 = 2082;
                          *(void *)uint64_t v118 = v20 + 191;
                          *(_WORD *)&v118[8] = 2080;
                          *(void *)&v118[10] = " ";
                          *(_WORD *)&v118[18] = 1024;
                          *(_DWORD *)&v118[20] = v104;
                          *(_WORD *)&v118[24] = 1024;
                          *(_DWORD *)&v118[26] = v105;
                          *(_WORD *)&v118[30] = 2048;
                          *(void *)&v118[32] = a1;
                          _os_log_impl(&dword_1830D4000, v103, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> cannot send on a new stream without outbound metadata for frame %p", buf, 0x36u);
                        }
                      }
                      int v94 = *(unsigned __int16 *)(v20 + 188);
                      int v95 = v94 | (*(unsigned __int8 *)(v20 + 190) << 16);
                      if ((v94 & 0x40) != 0) {
                        return;
                      }
                      *(unsigned char *)(v20 + 190) = BYTE2(v95);
                      *(_WORD *)(v20 + 188) = v95 | 0x40;
                      nw_protocol_error(v18, v11);
                      nw_protocol_disconnected(v18, v11);
LABEL_142:
                      if ((*((_WORD *)a1 + 102) & 0x100) == 0
                        || !g_channel_check_validity
                        || g_channel_check_validity(a1, *((void *)a1 + 11)))
                      {
                        BOOL v83 = (void *)*((void *)a1 + 14);
                        if (v83) {
                          free(v83);
                        }
                      }
                      nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
                      os_release(a1);
                      return;
                    }
LABEL_207:
                    free(v55);
                    goto LABEL_208;
                  }
                }
                else
                {
                  id v54 = nw_http_metadata_copy_request(v53);
                  if (!v54)
                  {
                    __nwlog_obj();
                    *(_DWORD *)int buf = 136446210;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    int v55 = (char *)_os_log_send_and_compose_impl();
                    LOBYTE(type) = 16;
                    LOBYTE(v113) = 0;
                    if (!__nwlog_fault(v55, &type, &v113)) {
                      goto LABEL_206;
                    }
                    if (type == 17)
                    {
                      uint64_t v56 = __nwlog_obj();
                      os_log_type_t v57 = type;
                      if (!os_log_type_enabled(v56, (os_log_type_t)type)) {
                        goto LABEL_206;
                      }
                      *(_DWORD *)int buf = 136446210;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      os_log_type_t v58 = "%{public}s did not find request on frame";
                      goto LABEL_205;
                    }
                    if (!(_BYTE)v113)
                    {
                      uint64_t v56 = __nwlog_obj();
                      os_log_type_t v57 = type;
                      if (!os_log_type_enabled(v56, (os_log_type_t)type)) {
                        goto LABEL_206;
                      }
                      *(_DWORD *)int buf = 136446210;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      os_log_type_t v58 = "%{public}s did not find request on frame, backtrace limit exceeded";
                      goto LABEL_205;
                    }
                    BOOL v90 = (char *)__nw_create_backtrace_string();
                    uint64_t v56 = __nwlog_obj();
                    os_log_type_t v57 = type;
                    BOOL v91 = os_log_type_enabled(v56, (os_log_type_t)type);
                    if (!v90)
                    {
                      if (!v91) {
                        goto LABEL_206;
                      }
                      *(_DWORD *)int buf = 136446210;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      os_log_type_t v58 = "%{public}s did not find request on frame, no backtrace";
                      goto LABEL_205;
                    }
                    if (v91)
                    {
                      *(_DWORD *)int buf = 136446466;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      __int16 v117 = 2082;
                      *(void *)uint64_t v118 = v90;
                      int v92 = "%{public}s did not find request on frame, dumping backtrace:%{public}s";
LABEL_188:
                      _os_log_impl(&dword_1830D4000, v56, v57, v92, buf, 0x16u);
                      goto LABEL_189;
                    }
                    goto LABEL_189;
                  }
                }
                os_release(v54);
                if (((*(unsigned __int16 *)(v20 + 188) | (*(unsigned __int8 *)(v20 + 190) << 16)) & 0x80000) == 0
                  && gLogDatapath)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  __int16 v106 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    int v108 = *(_DWORD *)(v20 + 176);
                    int v107 = *(_DWORD *)(v20 + 180);
                    uint64_t v109 = *(void *)(v20 + 104);
                    *(_DWORD *)int buf = 136448002;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    __int16 v117 = 2082;
                    *(void *)uint64_t v118 = v20 + 191;
                    *(_WORD *)&v118[8] = 2080;
                    *(void *)&v118[10] = " ";
                    *(_WORD *)&v118[18] = 1024;
                    *(_DWORD *)&v118[20] = v107;
                    *(_WORD *)&v118[24] = 1024;
                    *(_DWORD *)&v118[26] = v108;
                    *(_WORD *)&v118[30] = 2048;
                    *(void *)&v118[32] = v109;
                    *(_WORD *)&v118[40] = 2048;
                    *(void *)&v118[42] = v20;
                    __int16 v119 = 1024;
                    int v120 = v108;
                    _os_log_impl(&dword_1830D4000, v106, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> saved outbound metadata %p for stream %p (%d)", buf, 0x46u);
                  }
                }
                nw_http_transaction_metadata_set_outbound_message(*(void **)(v20 + 96), *(void **)(v20 + 104));
                nw::http::content_length_manager::set_outbound_message((nw::http::content_length_manager *)(v20 + 40), *(nw_protocol_metadata **)(v20 + 104));
                goto LABEL_124;
              }
              __nwlog_obj();
              *(_DWORD *)int buf = 136446210;
              uint64_t v116 = "nw_http2_save_metadata_from_frame";
              int v55 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(type) = 16;
              LOBYTE(v113) = 0;
              if (__nwlog_fault(v55, &type, &v113))
              {
                if (type == 17)
                {
                  uint64_t v56 = __nwlog_obj();
                  os_log_type_t v57 = type;
                  if (os_log_type_enabled(v56, (os_log_type_t)type))
                  {
                    *(_DWORD *)int buf = 136446210;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    os_log_type_t v58 = "%{public}s metadata must be http";
LABEL_205:
                    _os_log_impl(&dword_1830D4000, v56, v57, v58, buf, 0xCu);
                  }
                }
                else if ((_BYTE)v113)
                {
                  BOOL v90 = (char *)__nw_create_backtrace_string();
                  uint64_t v56 = __nwlog_obj();
                  os_log_type_t v57 = type;
                  BOOL v110 = os_log_type_enabled(v56, (os_log_type_t)type);
                  if (v90)
                  {
                    if (v110)
                    {
                      *(_DWORD *)int buf = 136446466;
                      uint64_t v116 = "nw_http2_save_metadata_from_frame";
                      __int16 v117 = 2082;
                      *(void *)uint64_t v118 = v90;
                      int v92 = "%{public}s metadata must be http, dumping backtrace:%{public}s";
                      goto LABEL_188;
                    }
                    goto LABEL_189;
                  }
                  if (v110)
                  {
                    *(_DWORD *)int buf = 136446210;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    os_log_type_t v58 = "%{public}s metadata must be http, no backtrace";
                    goto LABEL_205;
                  }
                }
                else
                {
                  uint64_t v56 = __nwlog_obj();
                  os_log_type_t v57 = type;
                  if (os_log_type_enabled(v56, (os_log_type_t)type))
                  {
                    *(_DWORD *)int buf = 136446210;
                    uint64_t v116 = "nw_http2_save_metadata_from_frame";
                    os_log_type_t v58 = "%{public}s metadata must be http, backtrace limit exceeded";
                    goto LABEL_205;
                  }
                }
              }
            }
            else
            {
              __nwlog_obj();
              *(_DWORD *)int buf = 136446210;
              uint64_t v116 = "nw_http2_save_metadata_from_frame";
              int v55 = (char *)_os_log_send_and_compose_impl();
              LOBYTE(type) = 16;
              LOBYTE(v113) = 0;
              if (!__nwlog_fault(v55, &type, &v113)) {
                goto LABEL_206;
              }
              if (type == 17)
              {
                uint64_t v56 = __nwlog_obj();
                os_log_type_t v57 = type;
                if (!os_log_type_enabled(v56, (os_log_type_t)type)) {
                  goto LABEL_206;
                }
                *(_DWORD *)int buf = 136446210;
                uint64_t v116 = "nw_http2_save_metadata_from_frame";
                os_log_type_t v58 = "%{public}s cannot send on a new stream without outbound metadata";
                goto LABEL_205;
              }
              if (!(_BYTE)v113)
              {
                uint64_t v56 = __nwlog_obj();
                os_log_type_t v57 = type;
                if (!os_log_type_enabled(v56, (os_log_type_t)type)) {
                  goto LABEL_206;
                }
                *(_DWORD *)int buf = 136446210;
                uint64_t v116 = "nw_http2_save_metadata_from_frame";
                os_log_type_t v58 = "%{public}s cannot send on a new stream without outbound metadata, backtrace limit exceeded";
                goto LABEL_205;
              }
              int v86 = (char *)__nw_create_backtrace_string();
              uint64_t v56 = __nwlog_obj();
              os_log_type_t v57 = type;
              BOOL v87 = os_log_type_enabled(v56, (os_log_type_t)type);
              if (!v86)
              {
                if (!v87) {
                  goto LABEL_206;
                }
                *(_DWORD *)int buf = 136446210;
                uint64_t v116 = "nw_http2_save_metadata_from_frame";
                os_log_type_t v58 = "%{public}s cannot send on a new stream without outbound metadata, no backtrace";
                goto LABEL_205;
              }
              if (v87)
              {
                *(_DWORD *)int buf = 136446466;
                uint64_t v116 = "nw_http2_save_metadata_from_frame";
                __int16 v117 = 2082;
                *(void *)uint64_t v118 = v86;
                _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s cannot send on a new stream without outbound metadata, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v86);
            }
LABEL_206:
            if (!v55) {
              goto LABEL_208;
            }
            goto LABEL_207;
          }
          if (*(__int16 *)(v11 + 388) < 0) {
            goto LABEL_142;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v43 = *(_DWORD *)(v11 + 368);
          *(_DWORD *)int buf = 136447234;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v11 + 390;
          *(_WORD *)&v118[8] = 2080;
          *(void *)&v118[10] = " ";
          *(_WORD *)&v118[18] = 1024;
          *(_DWORD *)&v118[20] = v43;
          *(_WORD *)&v118[24] = 2048;
          *(void *)&v118[26] = a1;
          uint64_t v34 = (const char *)_os_log_send_and_compose_impl();
          LOBYTE(type) = 16;
          LOBYTE(v113) = 0;
          if (!__nwlog_fault(v34, &type, &v113)) {
            goto LABEL_139;
          }
          if (type == 17)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v44 = gconnectionLogObj;
            os_log_type_t v45 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type))
            {
              int v46 = *(_DWORD *)(v11 + 368);
              *(_DWORD *)int buf = 136447234;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2082;
              *(void *)uint64_t v118 = v11 + 390;
              *(_WORD *)&v118[8] = 2080;
              *(void *)&v118[10] = " ";
              *(_WORD *)&v118[18] = 1024;
              *(_DWORD *)&v118[20] = v46;
              *(_WORD *)&v118[24] = 2048;
              *(void *)&v118[26] = a1;
              int v38 = "%{public}s %{public}s%s<i%u> stream not found for frame %p";
LABEL_137:
              uint64_t v68 = v44;
              os_log_type_t v69 = v45;
              uint32_t v70 = 48;
              goto LABEL_138;
            }
          }
          else if ((_BYTE)v113)
          {
            int v50 = (char *)__nw_create_backtrace_string();
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v44 = gconnectionLogObj;
            os_log_type_t v45 = type;
            BOOL v51 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type);
            if (v50)
            {
              if (v51)
              {
                int v52 = *(_DWORD *)(v11 + 368);
                *(_DWORD *)int buf = 136447490;
                uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
                __int16 v117 = 2082;
                *(void *)uint64_t v118 = v11 + 390;
                *(_WORD *)&v118[8] = 2080;
                *(void *)&v118[10] = " ";
                *(_WORD *)&v118[18] = 1024;
                *(_DWORD *)&v118[20] = v52;
                *(_WORD *)&v118[24] = 2048;
                *(void *)&v118[26] = a1;
                *(_WORD *)&v118[34] = 2082;
                *(void *)&v118[36] = v50;
                _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s %{public}s%s<i%u> stream not found for frame %p, dumping backtrace:%{public}s", buf, 0x3Au);
              }
              free(v50);
              if (!v34) {
                goto LABEL_142;
              }
LABEL_140:
              int v82 = (char *)v34;
LABEL_141:
              free(v82);
              goto LABEL_142;
            }
            if (v51)
            {
              int v81 = *(_DWORD *)(v11 + 368);
              *(_DWORD *)int buf = 136447234;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2082;
              *(void *)uint64_t v118 = v11 + 390;
              *(_WORD *)&v118[8] = 2080;
              *(void *)&v118[10] = " ";
              *(_WORD *)&v118[18] = 1024;
              *(_DWORD *)&v118[20] = v81;
              *(_WORD *)&v118[24] = 2048;
              *(void *)&v118[26] = a1;
              int v38 = "%{public}s %{public}s%s<i%u> stream not found for frame %p, no backtrace";
              goto LABEL_137;
            }
          }
          else
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v44 = gconnectionLogObj;
            os_log_type_t v45 = type;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type))
            {
              int v71 = *(_DWORD *)(v11 + 368);
              *(_DWORD *)int buf = 136447234;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2082;
              *(void *)uint64_t v118 = v11 + 390;
              *(_WORD *)&v118[8] = 2080;
              *(void *)&v118[10] = " ";
              *(_WORD *)&v118[18] = 1024;
              *(_DWORD *)&v118[20] = v71;
              *(_WORD *)&v118[24] = 2048;
              *(void *)&v118[26] = a1;
              int v38 = "%{public}s %{public}s%s<i%u> stream not found for frame %p, backtrace limit exceeded";
              goto LABEL_137;
            }
          }
LABEL_139:
          if (!v34) {
            goto LABEL_142;
          }
          goto LABEL_140;
        }
        if (*(__int16 *)(v11 + 388) < 0) {
          goto LABEL_142;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v33 = *(_DWORD *)(v11 + 368);
        *(_DWORD *)int buf = 136446978;
        uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
        __int16 v117 = 2082;
        *(void *)uint64_t v118 = v11 + 390;
        *(_WORD *)&v118[8] = 2080;
        *(void *)&v118[10] = " ";
        *(_WORD *)&v118[18] = 1024;
        *(_DWORD *)&v118[20] = v33;
        uint64_t v34 = (const char *)_os_log_send_and_compose_impl();
        LOBYTE(type) = 16;
        LOBYTE(v113) = 0;
        if (!__nwlog_fault(v34, &type, &v113)) {
          goto LABEL_139;
        }
        if (type == 17)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v35 = gconnectionLogObj;
          os_log_type_t v36 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type)) {
            goto LABEL_139;
          }
          int v37 = *(_DWORD *)(v11 + 368);
          *(_DWORD *)int buf = 136446978;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v11 + 390;
          *(_WORD *)&v118[8] = 2080;
          *(void *)&v118[10] = " ";
          *(_WORD *)&v118[18] = 1024;
          *(_DWORD *)&v118[20] = v37;
          int v38 = "%{public}s %{public}s%s<i%u> input_protocol not found";
        }
        else if ((_BYTE)v113)
        {
          uint64_t v47 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v35 = gconnectionLogObj;
          os_log_type_t v36 = type;
          BOOL v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type);
          if (v47)
          {
            if (v48)
            {
              int v49 = *(_DWORD *)(v11 + 368);
              *(_DWORD *)int buf = 136447234;
              uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
              __int16 v117 = 2082;
              *(void *)uint64_t v118 = v11 + 390;
              *(_WORD *)&v118[8] = 2080;
              *(void *)&v118[10] = " ";
              *(_WORD *)&v118[18] = 1024;
              *(_DWORD *)&v118[20] = v49;
              *(_WORD *)&v118[24] = 2082;
              *(void *)&v118[26] = v47;
              _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s %{public}s%s<i%u> input_protocol not found, dumping backtrace:%{public}s", buf, 0x30u);
            }
            free(v47);
            goto LABEL_139;
          }
          if (!v48) {
            goto LABEL_139;
          }
          int v67 = *(_DWORD *)(v11 + 368);
          *(_DWORD *)int buf = 136446978;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v11 + 390;
          *(_WORD *)&v118[8] = 2080;
          *(void *)&v118[10] = " ";
          *(_WORD *)&v118[18] = 1024;
          *(_DWORD *)&v118[20] = v67;
          int v38 = "%{public}s %{public}s%s<i%u> input_protocol not found, no backtrace";
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v35 = gconnectionLogObj;
          os_log_type_t v36 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, (os_log_type_t)type)) {
            goto LABEL_139;
          }
          int v59 = *(_DWORD *)(v11 + 368);
          *(_DWORD *)int buf = 136446978;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v11 + 390;
          *(_WORD *)&v118[8] = 2080;
          *(void *)&v118[10] = " ";
          *(_WORD *)&v118[18] = 1024;
          *(_DWORD *)&v118[20] = v59;
          int v38 = "%{public}s %{public}s%s<i%u> input_protocol not found, backtrace limit exceeded";
        }
        uint64_t v68 = v35;
        os_log_type_t v69 = v36;
        uint32_t v70 = 38;
LABEL_138:
        _os_log_impl(&dword_1830D4000, v68, v69, v38, buf, v70);
        goto LABEL_139;
      }
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
      unsigned int v3 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(type) = 16;
      LOBYTE(v113) = 0;
      if (__nwlog_fault(v3, &type, &v113))
      {
        if (type == 17)
        {
          uint64_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, (os_log_type_t)type))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
            os_log_type_t v6 = "%{public}s called with null http2";
            goto LABEL_38;
          }
          goto LABEL_40;
        }
        if (!(_BYTE)v113)
        {
          uint64_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, (os_log_type_t)type))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
            os_log_type_t v6 = "%{public}s called with null http2, backtrace limit exceeded";
            goto LABEL_38;
          }
          goto LABEL_40;
        }
        int v99 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v102 = os_log_type_enabled(v4, (os_log_type_t)type);
        if (!v99)
        {
          if (v102)
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
            os_log_type_t v6 = "%{public}s called with null http2, no backtrace";
            goto LABEL_38;
          }
          goto LABEL_40;
        }
        if (v102)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v99;
          int v101 = "%{public}s called with null http2, dumping backtrace:%{public}s";
          goto LABEL_237;
        }
        goto LABEL_238;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
      unsigned int v3 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(type) = 16;
      LOBYTE(v113) = 0;
      if (!__nwlog_fault(v3, &type, &v113)) {
        goto LABEL_40;
      }
      if (type != 17)
      {
        if (!(_BYTE)v113)
        {
          uint64_t v4 = __nwlog_obj();
          os_log_type_t v5 = type;
          if (os_log_type_enabled(v4, (os_log_type_t)type))
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
            os_log_type_t v6 = "%{public}s called with null output_metadata, backtrace limit exceeded";
            goto LABEL_38;
          }
          goto LABEL_40;
        }
        int v99 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v100 = os_log_type_enabled(v4, (os_log_type_t)type);
        if (!v99)
        {
          if (v100)
          {
            *(_DWORD *)int buf = 136446210;
            uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
            os_log_type_t v6 = "%{public}s called with null output_metadata, no backtrace";
            goto LABEL_38;
          }
          goto LABEL_40;
        }
        if (v100)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          __int16 v117 = 2082;
          *(void *)uint64_t v118 = v99;
          int v101 = "%{public}s called with null output_metadata, dumping backtrace:%{public}s";
LABEL_237:
          _os_log_impl(&dword_1830D4000, v4, v5, v101, buf, 0x16u);
        }
LABEL_238:
        free(v99);
        if (v3) {
          goto LABEL_41;
        }
        return;
      }
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, (os_log_type_t)type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
        os_log_type_t v6 = "%{public}s called with null output_metadata";
        goto LABEL_38;
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
    unsigned int v3 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(type) = 16;
    LOBYTE(v113) = 0;
    if (__nwlog_fault(v3, &type, &v113))
    {
      if (type == 17)
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          os_log_type_t v6 = "%{public}s called with null frame";
          goto LABEL_38;
        }
      }
      else if ((_BYTE)v113)
      {
        BOOL v96 = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v97 = os_log_type_enabled(v4, (os_log_type_t)type);
        if (v96)
        {
          if (v97)
          {
            *(_DWORD *)int buf = 136446466;
            uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
            __int16 v117 = 2082;
            *(void *)uint64_t v118 = v96;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v96);
        }
        else if (v97)
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          os_log_type_t v6 = "%{public}s called with null frame, no backtrace";
          goto LABEL_38;
        }
      }
      else
      {
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        if (os_log_type_enabled(v4, (os_log_type_t)type))
        {
          *(_DWORD *)int buf = 136446210;
          uint64_t v116 = "nw_protocol_http2_frame_output_finalizer";
          os_log_type_t v6 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_38;
        }
      }
    }
  }
LABEL_40:
  if (v3) {
LABEL_41:
  }
    free(v3);
}

BOOL nw_http2_submit_message(uint64_t a1, void *a2, uint64_t a3, uint64_t a4)
{
  uint64_t v377 = *MEMORY[0x1E4F143B8];
  p_cache = NWConcrete_nw_resolution_report.cache;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v209 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v211 = *(_DWORD *)(a3 + 176);
      int v210 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(void *)&long long v369 = " ";
      WORD4(v369) = 1024;
      *(_DWORD *)((char *)&v369 + 10) = v210;
      HIWORD(v369) = 1024;
      LODWORD(v370[0]) = v211;
      _os_log_impl(&dword_1830D4000, v209, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", (uint8_t *)buf, 0x2Cu);
    }
  }
  int v9 = *(unsigned __int16 *)(a3 + 188);
  int v10 = v9 | (*(unsigned __int8 *)(a3 + 190) << 16);
  if ((v9 & 1) == 0)
  {
    if ((v10 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v11 = gconnectionLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v14 = *(_DWORD *)(a3 + 176);
        int v13 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447746;
        *(void *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v13;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v14;
        WORD2(v370[0]) = 2048;
        *(void **)((char *)v370 + 6) = a2;
        HIWORD(v370[1]) = 2048;
        v370[2] = (void *)a3;
        __int16 v15 = "%{public}s %{public}s%s<i%u:s%d> ERROR: Cannot send headers on a stream that is not considered open (proto"
              "col %p, stream %p)";
        os_log_type_t v16 = v11;
        os_log_type_t v17 = OS_LOG_TYPE_ERROR;
        uint32_t v18 = 64;
LABEL_9:
        _os_log_impl(&dword_1830D4000, v16, v17, v15, (uint8_t *)buf, v18);
        return 0;
      }
      return result;
    }
    return 0;
  }
  if (!*(void *)(a3 + 104))
  {
    if ((v10 & 0x80000) != 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v25 = *(_DWORD *)(a3 + 176);
    int v24 = *(_DWORD *)(a3 + 180);
    LODWORD(buf[0]) = 136447234;
    *(void *)((char *)buf + 4) = "nw_http2_submit_message";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = a3 + 191;
    HIWORD(buf[2]) = 2080;
    *(void *)&long long v369 = " ";
    WORD4(v369) = 1024;
    *(_DWORD *)((char *)&v369 + 10) = v24;
    HIWORD(v369) = 1024;
    LODWORD(v370[0]) = v25;
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v373[0]) = 0;
    if (__nwlog_fault(v26, type, v373))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v27 = gconnectionLogObj;
        os_log_type_t v28 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
          goto LABEL_97;
        }
        int v30 = *(_DWORD *)(a3 + 176);
        int v29 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v29;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v30;
        int v31 = "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata";
        goto LABEL_96;
      }
      if (!LOBYTE(v373[0]))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v27 = gconnectionLogObj;
        os_log_type_t v28 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
          goto LABEL_97;
        }
        int v64 = *(_DWORD *)(a3 + 176);
        int v63 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v63;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v64;
        int v31 = "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata, backtrace limit exceeded";
        goto LABEL_96;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v27 = gconnectionLogObj;
      os_log_type_t v28 = type[0];
      BOOL v35 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
      if (backtrace_string)
      {
        if (v35)
        {
          int v37 = *(_DWORD *)(a3 + 176);
          int v36 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(void *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(void *)&long long v369 = " ";
          WORD4(v369) = 1024;
          *(_DWORD *)((char *)&v369 + 10) = v36;
          HIWORD(v369) = 1024;
          LODWORD(v370[0]) = v37;
          WORD2(v370[0]) = 2082;
          *(void **)((char *)v370 + 6) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata, dumping backtrace:%{public}s", (uint8_t *)buf, 0x36u);
        }
        free(backtrace_string);
        goto LABEL_97;
      }
      if (v35)
      {
        int v71 = *(_DWORD *)(a3 + 176);
        int v70 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447234;
        *(void *)((char *)buf + 4) = "nw_http2_submit_message";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v70;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v71;
        int v31 = "%{public}s %{public}s%s<i%u:s%d> Cannot send on a stream without outbound_metadata, no backtrace";
LABEL_96:
        _os_log_impl(&dword_1830D4000, v27, v28, v31, (uint8_t *)buf, 0x2Cu);
      }
    }
LABEL_97:
    if (v26) {
      free(v26);
    }
    return 0;
  }
  if ((v9 & 0x100) != 0)
  {
    if (a4)
    {
      int v32 = *(_DWORD *)(a4 + 52);
      if (v32 && v32 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60)
        || (uint64_t v33 = *(void *)(a4 + 64)) != 0 && (*(unsigned char *)(v33 + 66) & 0x40) != 0)
      {
LABEL_185:
        if (*(void *)(a3 + 16))
        {
          if ((v10 & 0x80000) != 0 || !*((unsigned char *)p_cache + 3665)) {
            goto LABEL_195;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v127 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_195;
          }
          int v129 = *(_DWORD *)(a3 + 176);
          int v128 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(void *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(void *)&long long v369 = " ";
          WORD4(v369) = 1024;
          *(_DWORD *)((char *)&v369 + 10) = v128;
          HIWORD(v369) = 1024;
          LODWORD(v370[0]) = v129;
          WORD2(v370[0]) = 2048;
          *(void **)((char *)v370 + 6) = (void *)a4;
          BOOL v130 = "%{public}s %{public}s%s<i%u:s%d> stream already has pending data, pending frame %p for future send";
          goto LABEL_465;
        }
        if ((v10 & 2) == 0)
        {
          if ((v10 & 0x80000) != 0 || !*((unsigned char *)p_cache + 3665)) {
            goto LABEL_195;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v127 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_195;
          }
          int v295 = *(_DWORD *)(a3 + 176);
          int v294 = *(_DWORD *)(a3 + 180);
          LODWORD(buf[0]) = 136447490;
          *(void *)((char *)buf + 4) = "nw_http2_submit_message";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a3 + 191;
          HIWORD(buf[2]) = 2080;
          *(void *)&long long v369 = " ";
          WORD4(v369) = 1024;
          *(_DWORD *)((char *)&v369 + 10) = v294;
          HIWORD(v369) = 1024;
          LODWORD(v370[0]) = v295;
          WORD2(v370[0]) = 2048;
          *(void **)((char *)v370 + 6) = (void *)a4;
          BOOL v130 = "%{public}s %{public}s%s<i%u:s%d> stream is not open yet, cannot submit frame %p, pending for future send";
LABEL_465:
          uint64_t v222 = v127;
          uint32_t v223 = 54;
LABEL_466:
          _os_log_impl(&dword_1830D4000, v222, OS_LOG_TYPE_DEBUG, v130, (uint8_t *)buf, v223);
LABEL_195:
          nw_http2_enqueue_frame_for_stream(a3, a4);
          return 1;
        }
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
        }
        if (_nw_signposts_enabled && kdebug_is_enabled())
        {
          kdebug_trace();
          int v131 = *(_DWORD *)(a4 + 52);
          if (v131)
          {
LABEL_203:
            if (v131 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60)) {
              goto LABEL_212;
            }
          }
        }
        else
        {
          int v131 = *(_DWORD *)(a4 + 52);
          if (v131) {
            goto LABEL_203;
          }
        }
        uint64_t v132 = *(void *)(a4 + 64);
        if (!v132 || (*(unsigned char *)(v132 + 66) & 0x40) == 0)
        {
          if (*(__int16 *)(a1 + 388) < 0 || !*((unsigned char *)p_cache + 3665)) {
            goto LABEL_37;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v133 = gconnectionLogObj;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_37;
          }
          int v134 = *(_DWORD *)(a1 + 368);
          LODWORD(buf[0]) = 136446978;
          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = a1 + 390;
          HIWORD(buf[2]) = 2080;
          *(void *)&long long v369 = " ";
          WORD4(v369) = 1024;
          *(_DWORD *)((char *)&v369 + 10) = v134;
          uint64_t v135 = "%{public}s %{public}s%s<i%u> skipping empty frame body";
          BOOL v136 = v133;
          os_log_type_t v137 = OS_LOG_TYPE_DEBUG;
          uint32_t v138 = 38;
          goto LABEL_643;
        }
LABEL_212:
        if ((*(_WORD *)(a4 + 204) & 4) != 0)
        {
          uint64_t v139 = *(void *)(a4 + 216);
          if (v139)
          {
            uint64_t v140 = *(void *)(v139 + 56);
            if (v140)
            {
              uint64_t v141 = *(void *)(v140 + 32);
              if (v141)
              {
                int v142 = *(_DWORD *)(v141 + 176);
                v373[0] = a4;
                v373[1] = data_source_read_callback;
                uint64_t v143 = *(void *)(a4 + 64);
                if (v143)
                {
                  char v144 = *(unsigned char *)(v143 + 66);
                  int v145 = (unsigned __int16 *)(v141 + 188);
                  unsigned int v146 = *(unsigned __int16 *)(v141 + 188) | (*(unsigned __int8 *)(v141 + 190) << 16);
                  if ((v144 & 0x40) != 0)
                  {
                    int v147 = (v146 >> 19) & 1;
                    if (!*((unsigned char *)p_cache + 3665)) {
                      LOBYTE(v147) = 1;
                    }
                    if ((*(_WORD *)(v141 + 188) & 0x200) == 0)
                    {
                      if ((v147 & 1) == 0)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        BOOL v338 = gconnectionLogObj;
                        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                        {
                          int v340 = *(_DWORD *)(v141 + 176);
                          int v339 = *(_DWORD *)(v141 + 180);
                          LODWORD(buf[0]) = 136447234;
                          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                          WORD2(buf[1]) = 2082;
                          *(void *)((char *)&buf[1] + 6) = v141 + 191;
                          HIWORD(buf[2]) = 2080;
                          *(void *)&long long v369 = " ";
                          WORD4(v369) = 1024;
                          *(_DWORD *)((char *)&v369 + 10) = v339;
                          HIWORD(v369) = 1024;
                          LODWORD(v370[0]) = v340;
                          _os_log_impl(&dword_1830D4000, v338, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> frame is complete, marking end stream", (uint8_t *)buf, 0x2Cu);
                        }
                      }
                      goto LABEL_268;
                    }
                    if ((v147 & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      int v162 = gconnectionLogObj;
                      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                      {
                        int v342 = *(_DWORD *)(v141 + 176);
                        int v341 = *(_DWORD *)(v141 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = v141 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(void *)&long long v369 = " ";
                        WORD4(v369) = 1024;
                        *(_DWORD *)((char *)&v369 + 10) = v341;
                        HIWORD(v369) = 1024;
                        LODWORD(v370[0]) = v342;
                        BOOL v165 = "%{public}s %{public}s%s<i%u:s%d> stream is in CONNECT mode, not marking end stream";
                        goto LABEL_251;
                      }
                    }
                    goto LABEL_268;
                  }
                }
                else
                {
                  int v145 = (unsigned __int16 *)(v141 + 188);
                  unsigned int v146 = *(unsigned __int16 *)(v141 + 188) | (*(unsigned __int8 *)(v141 + 190) << 16);
                }
                if ((v146 & 0x80000) == 0 && *((unsigned char *)p_cache + 3665))
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  int v162 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    int v164 = *(_DWORD *)(v141 + 176);
                    int v163 = *(_DWORD *)(v141 + 180);
                    LODWORD(buf[0]) = 136447234;
                    *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = v141 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(void *)&long long v369 = " ";
                    WORD4(v369) = 1024;
                    *(_DWORD *)((char *)&v369 + 10) = v163;
                    HIWORD(v369) = 1024;
                    LODWORD(v370[0]) = v164;
                    BOOL v165 = "%{public}s %{public}s%s<i%u:s%d> frame is not complete, not marking end stream";
LABEL_251:
                    _os_log_impl(&dword_1830D4000, v162, OS_LOG_TYPE_DEBUG, v165, (uint8_t *)buf, 0x2Cu);
                  }
                }
LABEL_268:
                int v174 = nghttp2_submit_data();
                if (!v174)
                {
                  if (((*v145 | (*((unsigned __int8 *)v145 + 2) << 16)) & 0x80000) == 0 && *((unsigned char *)p_cache + 3665))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v180 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      int v181 = *(_DWORD *)(v141 + 176);
                      int v182 = *(_DWORD *)(v141 + 180);
                      int v183 = *(_DWORD *)(a4 + 52);
                      if (v183) {
                        v183 -= *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60);
                      }
                      LODWORD(buf[0]) = 136447746;
                      *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = v141 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v182;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v181;
                      WORD2(v370[0]) = 1024;
                      *(_DWORD *)((char *)v370 + 6) = v183;
                      WORD1(v370[1]) = 1024;
                      HIDWORD(v370[1]) = v142;
                      _os_log_impl(&dword_1830D4000, v180, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> submitted %u bytes on stream %d", (uint8_t *)buf, 0x38u);
                    }
                  }
                  return 1;
                }
                int v175 = v174;
                if (v174 == -510)
                {
                  if (((*v145 | (*((unsigned __int8 *)v145 + 2) << 16)) & 0x80000) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    BOOL v184 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
                    {
                      int v186 = *(_DWORD *)(v141 + 176);
                      int v185 = *(_DWORD *)(v141 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = v141 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v185;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v186;
                      WORD2(v370[0]) = 1024;
                      *(_DWORD *)((char *)v370 + 6) = v142;
                      _os_log_impl(&dword_1830D4000, v184, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> stream %d is closed, cannot send frames", (uint8_t *)buf, 0x32u);
                    }
                  }
                  goto LABEL_637;
                }
                if (v174 == -529)
                {
                  if (((*v145 | (*((unsigned __int8 *)v145 + 2) << 16)) & 0x80000) == 0 && *((unsigned char *)p_cache + 3665))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v176 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      int v177 = *(_DWORD *)(v141 + 176);
                      int v178 = *(_DWORD *)(v141 + 180);
                      int v179 = *(_DWORD *)(a4 + 52);
                      if (v179) {
                        v179 -= *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60);
                      }
                      LODWORD(buf[0]) = 136447746;
                      *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = v141 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v178;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v177;
                      WORD2(v370[0]) = 1024;
                      *(_DWORD *)((char *)v370 + 6) = v142;
                      WORD1(v370[1]) = 1024;
                      HIDWORD(v370[1]) = v179;
                      _os_log_impl(&dword_1830D4000, v176, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> already have data outgoing on stream %d, cannot send %u bytes", (uint8_t *)buf, 0x38u);
                    }
                  }
LABEL_345:
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0
                    || !*((unsigned char *)p_cache + 3665))
                  {
                    goto LABEL_195;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  uint64_t v219 = gconnectionLogObj;
                  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_195;
                  }
                  int v221 = *(_DWORD *)(a3 + 176);
                  int v220 = *(_DWORD *)(a3 + 180);
                  LODWORD(buf[0]) = 136447746;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = a3 + 191;
                  HIWORD(buf[2]) = 2080;
                  *(void *)&long long v369 = " ";
                  WORD4(v369) = 1024;
                  *(_DWORD *)((char *)&v369 + 10) = v220;
                  HIWORD(v369) = 1024;
                  LODWORD(v370[0]) = v221;
                  WORD2(v370[0]) = 1024;
                  *(_DWORD *)((char *)v370 + 6) = v221;
                  WORD1(v370[1]) = 2048;
                  *(void **)((char *)&v370[1] + 4) = (void *)a4;
                  BOOL v130 = "%{public}s %{public}s%s<i%u:s%d> couldn't send frame on stream %d, adding frame %p to waiting_output_frames";
                  uint64_t v222 = v219;
                  uint32_t v223 = 60;
                  goto LABEL_466;
                }
                __nwlog_obj();
                uint64_t v187 = nghttp2_strerror();
                LODWORD(buf[0]) = 136446722;
                *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                WORD2(buf[1]) = 2082;
                *(void *)((char *)&buf[1] + 6) = v187;
                HIWORD(buf[2]) = 1024;
                LODWORD(v369) = v142;
                BOOL v188 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v365[0]) = 16;
                LOBYTE(v364[0]) = 0;
                if (!__nwlog_fault(v188, v365, v364)) {
                  goto LABEL_342;
                }
                if (LOBYTE(v365[0]) == 17)
                {
                  int v189 = __nwlog_obj();
                  os_log_type_t v190 = v365[0];
                  if (!os_log_type_enabled(v189, v365[0])) {
                    goto LABEL_342;
                  }
                  uint64_t v191 = nghttp2_strerror();
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v191;
                  HIWORD(buf[2]) = 1024;
                  LODWORD(v369) = v142;
                  uint64_t v192 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed";
                }
                else if (LOBYTE(v364[0]))
                {
                  int v197 = (char *)__nw_create_backtrace_string();
                  int v189 = __nwlog_obj();
                  os_log_type_t v190 = v365[0];
                  BOOL v198 = os_log_type_enabled(v189, v365[0]);
                  if (v197)
                  {
                    if (v198)
                    {
                      uint64_t v199 = nghttp2_strerror();
                      LODWORD(buf[0]) = 136446978;
                      *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = v199;
                      HIWORD(buf[2]) = 1024;
                      LODWORD(v369) = v142;
                      WORD2(v369) = 2082;
                      *(void *)((char *)&v369 + 6) = v197;
                      _os_log_impl(&dword_1830D4000, v189, v190, "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, dumping backtrace:%{public}s", (uint8_t *)buf, 0x26u);
                    }
                    free(v197);
LABEL_342:
                    if (v188) {
                      free(v188);
                    }
                    if (v175 == -529) {
                      goto LABEL_345;
                    }
                    if ((*(_WORD *)(a1 + 388) & 8) == 0)
                    {
                      if (v175 != -1)
                      {
                        if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0)
                        {
LABEL_37:
                          nw_frame_cache_return_frame(a1 + 200, a4);
                          return 1;
                        }
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        uint64_t v224 = a3 + 191;
                        int v226 = *(_DWORD *)(a3 + 176);
                        int v225 = *(_DWORD *)(a3 + 180);
                        int v227 = (void *)nghttp2_strerror();
                        LODWORD(buf[0]) = 136447746;
                        *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(void *)&long long v369 = " ";
                        WORD4(v369) = 1024;
                        *(_DWORD *)((char *)&v369 + 10) = v225;
                        HIWORD(v369) = 1024;
                        LODWORD(v370[0]) = v226;
                        WORD2(v370[0]) = 2080;
                        *(void **)((char *)v370 + 6) = v227;
                        HIWORD(v370[1]) = 2048;
                        v370[2] = (void *)a4;
                        uint64_t v228 = (char *)_os_log_send_and_compose_impl();
                        LOBYTE(v373[0]) = 16;
                        LOBYTE(v365[0]) = 0;
                        if (__nwlog_fault(v228, v373, v365))
                        {
                          if (LOBYTE(v373[0]) == 17)
                          {
                            if (__nwlog_connection_log::onceToken != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                            }
                            __int16 v229 = gconnectionLogObj;
                            os_log_type_t v230 = v373[0];
                            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0])) {
                              goto LABEL_405;
                            }
                            uint64_t v233 = a3 + 176;
                            int v231 = *(_DWORD *)(a3 + 176);
                            int v232 = *(_DWORD *)(v233 + 4);
                            uint64_t v234 = (void *)nghttp2_strerror();
                            LODWORD(buf[0]) = 136447746;
                            *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                            WORD2(buf[1]) = 2082;
                            *(void *)((char *)&buf[1] + 6) = v224;
                            HIWORD(buf[2]) = 2080;
                            *(void *)&long long v369 = " ";
                            WORD4(v369) = 1024;
                            *(_DWORD *)((char *)&v369 + 10) = v232;
                            HIWORD(v369) = 1024;
                            LODWORD(v370[0]) = v231;
                            WORD2(v370[0]) = 2080;
                            *(void **)((char *)v370 + 6) = v234;
                            HIWORD(v370[1]) = 2048;
                            v370[2] = (void *)a4;
                            char v235 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to cache";
                            goto LABEL_404;
                          }
                          if (!LOBYTE(v365[0]))
                          {
                            if (__nwlog_connection_log::onceToken != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                            }
                            __int16 v229 = gconnectionLogObj;
                            os_log_type_t v230 = v373[0];
                            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0])) {
                              goto LABEL_405;
                            }
                            uint64_t v251 = a3 + 176;
                            int v249 = *(_DWORD *)(a3 + 176);
                            int v250 = *(_DWORD *)(v251 + 4);
                            v252 = (void *)nghttp2_strerror();
                            LODWORD(buf[0]) = 136447746;
                            *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                            WORD2(buf[1]) = 2082;
                            *(void *)((char *)&buf[1] + 6) = v224;
                            HIWORD(buf[2]) = 2080;
                            *(void *)&long long v369 = " ";
                            WORD4(v369) = 1024;
                            *(_DWORD *)((char *)&v369 + 10) = v250;
                            HIWORD(v369) = 1024;
                            LODWORD(v370[0]) = v249;
                            WORD2(v370[0]) = 2080;
                            *(void **)((char *)v370 + 6) = v252;
                            HIWORD(v370[1]) = 2048;
                            v370[2] = (void *)a4;
                            char v235 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to ca"
                                   "che, backtrace limit exceeded";
                            goto LABEL_404;
                          }
                          BOOL v236 = (char *)__nw_create_backtrace_string();
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          __int16 v229 = gconnectionLogObj;
                          os_log_type_t v230 = v373[0];
                          BOOL v237 = os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0]);
                          if (v236)
                          {
                            if (v237)
                            {
                              uint64_t v240 = a3 + 176;
                              int v238 = *(_DWORD *)(a3 + 176);
                              int v239 = *(_DWORD *)(v240 + 4);
                              __int16 v241 = (void *)nghttp2_strerror();
                              LODWORD(buf[0]) = 136448002;
                              *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                              WORD2(buf[1]) = 2082;
                              *(void *)((char *)&buf[1] + 6) = v224;
                              HIWORD(buf[2]) = 2080;
                              *(void *)&long long v369 = " ";
                              WORD4(v369) = 1024;
                              *(_DWORD *)((char *)&v369 + 10) = v239;
                              HIWORD(v369) = 1024;
                              LODWORD(v370[0]) = v238;
                              WORD2(v370[0]) = 2080;
                              *(void **)((char *)v370 + 6) = v241;
                              HIWORD(v370[1]) = 2048;
                              v370[2] = (void *)a4;
                              __int16 v371 = 2082;
                              nw_protocol_definition_t v372 = v236;
                              _os_log_impl(&dword_1830D4000, v229, v230, "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to cache, dumping backtrace:%{public}s", (uint8_t *)buf, 0x4Au);
                            }
                            free(v236);
                            goto LABEL_405;
                          }
                          if (v237)
                          {
                            uint64_t v270 = a3 + 176;
                            int v268 = *(_DWORD *)(a3 + 176);
                            int v269 = *(_DWORD *)(v270 + 4);
                            nw_endpoint_t v271 = (void *)nghttp2_strerror();
                            LODWORD(buf[0]) = 136447746;
                            *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                            WORD2(buf[1]) = 2082;
                            *(void *)((char *)&buf[1] + 6) = v224;
                            HIWORD(buf[2]) = 2080;
                            *(void *)&long long v369 = " ";
                            WORD4(v369) = 1024;
                            *(_DWORD *)((char *)&v369 + 10) = v269;
                            HIWORD(v369) = 1024;
                            LODWORD(v370[0]) = v268;
                            WORD2(v370[0]) = 2080;
                            *(void **)((char *)v370 + 6) = v271;
                            HIWORD(v370[1]) = 2048;
                            v370[2] = (void *)a4;
                            char v235 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data (%s), returning frame %p to ca"
                                   "che, no backtrace";
LABEL_404:
                            _os_log_impl(&dword_1830D4000, v229, v230, v235, (uint8_t *)buf, 0x40u);
                          }
                        }
LABEL_405:
                        if (v228) {
                          free(v228);
                        }
                        goto LABEL_37;
                      }
                      goto LABEL_632;
                    }
                    goto LABEL_637;
                  }
                  if (!v198) {
                    goto LABEL_342;
                  }
                  uint64_t v218 = nghttp2_strerror();
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v218;
                  HIWORD(buf[2]) = 1024;
                  LODWORD(v369) = v142;
                  uint64_t v192 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, no backtrace";
                }
                else
                {
                  int v189 = __nwlog_obj();
                  os_log_type_t v190 = v365[0];
                  if (!os_log_type_enabled(v189, v365[0])) {
                    goto LABEL_342;
                  }
                  uint64_t v217 = nghttp2_strerror();
                  LODWORD(buf[0]) = 136446722;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v217;
                  HIWORD(buf[2]) = 1024;
                  LODWORD(v369) = v142;
                  uint64_t v192 = "%{public}s nghttp2_submit_data: %{public}s, stream id %d failed, backtrace limit exceeded";
                }
                _os_log_impl(&dword_1830D4000, v189, v190, v192, (uint8_t *)buf, 0x1Cu);
                goto LABEL_342;
              }
              __nwlog_obj();
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v313 = (void *)_os_log_send_and_compose_impl();
              LOBYTE(v373[0]) = 16;
              LOBYTE(v365[0]) = 0;
              if (__nwlog_fault((const char *)v313, v373, v365))
              {
                if (LOBYTE(v373[0]) == 17)
                {
                  v314 = __nwlog_obj();
                  os_log_type_t v315 = v373[0];
                  if (!os_log_type_enabled(v314, v373[0])) {
                    goto LABEL_629;
                  }
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  v316 = "%{public}s called with null stream";
                  goto LABEL_628;
                }
                if (!LOBYTE(v365[0]))
                {
                  v314 = __nwlog_obj();
                  os_log_type_t v315 = v373[0];
                  if (!os_log_type_enabled(v314, v373[0])) {
                    goto LABEL_629;
                  }
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  v316 = "%{public}s called with null stream, backtrace limit exceeded";
                  goto LABEL_628;
                }
                os_log_type_t v333 = (char *)__nw_create_backtrace_string();
                v314 = __nwlog_obj();
                os_log_type_t v315 = v373[0];
                BOOL v337 = os_log_type_enabled(v314, v373[0]);
                if (!v333)
                {
                  if (!v337) {
                    goto LABEL_629;
                  }
                  LODWORD(buf[0]) = 136446210;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  v316 = "%{public}s called with null stream, no backtrace";
                  goto LABEL_628;
                }
                if (v337)
                {
                  LODWORD(buf[0]) = 136446466;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_data";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = v333;
                  os_log_type_t v335 = "%{public}s called with null stream, dumping backtrace:%{public}s";
                  goto LABEL_583;
                }
LABEL_584:
                free(v333);
                if (!v313)
                {
LABEL_631:
                  if ((*(_WORD *)(a1 + 388) & 8) == 0)
                  {
LABEL_632:
                    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0) {
                      goto LABEL_37;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v343 = gconnectionLogObj;
                    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
                      goto LABEL_37;
                    }
                    int v345 = *(_DWORD *)(a3 + 176);
                    int v344 = *(_DWORD *)(a3 + 180);
                    LODWORD(buf[0]) = 136447490;
                    *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = a3 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(void *)&long long v369 = " ";
                    WORD4(v369) = 1024;
                    *(_DWORD *)((char *)&v369 + 10) = v344;
                    HIWORD(v369) = 1024;
                    LODWORD(v370[0]) = v345;
                    WORD2(v370[0]) = 2048;
                    *(void **)((char *)v370 + 6) = (void *)a4;
                    uint64_t v135 = "%{public}s %{public}s%s<i%u:s%d> failed to submit data, returning frame %p to cache";
                    goto LABEL_642;
                  }
LABEL_637:
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0) {
                    goto LABEL_37;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  uint64_t v343 = gconnectionLogObj;
                  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
                    goto LABEL_37;
                  }
                  int v347 = *(_DWORD *)(a3 + 176);
                  int v346 = *(_DWORD *)(a3 + 180);
                  LODWORD(buf[0]) = 136447490;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_message";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = a3 + 191;
                  HIWORD(buf[2]) = 2080;
                  *(void *)&long long v369 = " ";
                  WORD4(v369) = 1024;
                  *(_DWORD *)((char *)&v369 + 10) = v346;
                  HIWORD(v369) = 1024;
                  LODWORD(v370[0]) = v347;
                  WORD2(v370[0]) = 2048;
                  *(void **)((char *)v370 + 6) = (void *)a4;
                  uint64_t v135 = "%{public}s %{public}s%s<i%u:s%d> tunnel is no longer connected or stream is closed, returning f"
                         "rame %p to cache";
LABEL_642:
                  BOOL v136 = v343;
                  os_log_type_t v137 = OS_LOG_TYPE_ERROR;
                  uint32_t v138 = 54;
LABEL_643:
                  _os_log_impl(&dword_1830D4000, v136, v137, v135, (uint8_t *)buf, v138);
                  goto LABEL_37;
                }
LABEL_630:
                free(v313);
                goto LABEL_631;
              }
LABEL_629:
              if (!v313) {
                goto LABEL_631;
              }
              goto LABEL_630;
            }
            __nwlog_obj();
            LODWORD(buf[0]) = 136446210;
            *(void *)((char *)buf + 4) = "nw_http2_submit_data";
            v313 = (void *)_os_log_send_and_compose_impl();
            LOBYTE(v373[0]) = 16;
            LOBYTE(v365[0]) = 0;
            if (!__nwlog_fault((const char *)v313, v373, v365)) {
              goto LABEL_629;
            }
            if (LOBYTE(v373[0]) == 17)
            {
              v314 = __nwlog_obj();
              os_log_type_t v315 = v373[0];
              if (!os_log_type_enabled(v314, v373[0])) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null node";
              goto LABEL_628;
            }
            if (!LOBYTE(v365[0]))
            {
              v314 = __nwlog_obj();
              os_log_type_t v315 = v373[0];
              if (!os_log_type_enabled(v314, v373[0])) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null node, backtrace limit exceeded";
              goto LABEL_628;
            }
            os_log_type_t v333 = (char *)__nw_create_backtrace_string();
            v314 = __nwlog_obj();
            os_log_type_t v315 = v373[0];
            BOOL v336 = os_log_type_enabled(v314, v373[0]);
            if (!v333)
            {
              if (!v336) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null node, no backtrace";
              goto LABEL_628;
            }
            if (!v336) {
              goto LABEL_584;
            }
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_http2_submit_data";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v333;
            os_log_type_t v335 = "%{public}s called with null node, dumping backtrace:%{public}s";
LABEL_583:
            _os_log_impl(&dword_1830D4000, v314, v315, v335, (uint8_t *)buf, 0x16u);
            goto LABEL_584;
          }
          __nwlog_obj();
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
          v313 = (void *)_os_log_send_and_compose_impl();
          LOBYTE(v373[0]) = 16;
          LOBYTE(v365[0]) = 0;
          if (!__nwlog_fault((const char *)v313, v373, v365)) {
            goto LABEL_629;
          }
          if (LOBYTE(v373[0]) != 17)
          {
            if (!LOBYTE(v365[0]))
            {
              v314 = __nwlog_obj();
              os_log_type_t v315 = v373[0];
              if (!os_log_type_enabled(v314, v373[0])) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null input_protocol, backtrace limit exceeded";
              goto LABEL_628;
            }
            os_log_type_t v333 = (char *)__nw_create_backtrace_string();
            v314 = __nwlog_obj();
            os_log_type_t v315 = v373[0];
            BOOL v334 = os_log_type_enabled(v314, v373[0]);
            if (!v333)
            {
              if (!v334) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null input_protocol, no backtrace";
              goto LABEL_628;
            }
            if (!v334) {
              goto LABEL_584;
            }
            LODWORD(buf[0]) = 136446466;
            *(void *)((char *)buf + 4) = "nw_http2_submit_data";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = v333;
            os_log_type_t v335 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
            goto LABEL_583;
          }
          v314 = __nwlog_obj();
          os_log_type_t v315 = v373[0];
          if (!os_log_type_enabled(v314, v373[0])) {
            goto LABEL_629;
          }
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
          v316 = "%{public}s called with null input_protocol";
        }
        else
        {
          __nwlog_obj();
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
          v313 = (void *)_os_log_send_and_compose_impl();
          LOBYTE(v373[0]) = 16;
          LOBYTE(v365[0]) = 0;
          if (!__nwlog_fault((const char *)v313, v373, v365)) {
            goto LABEL_629;
          }
          if (LOBYTE(v373[0]) != 17)
          {
            if (!LOBYTE(v365[0]))
            {
              v314 = __nwlog_obj();
              os_log_type_t v315 = v373[0];
              if (!os_log_type_enabled(v314, v373[0])) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null output_context, backtrace limit exceeded";
              goto LABEL_628;
            }
            os_log_type_t v331 = (char *)__nw_create_backtrace_string();
            v314 = __nwlog_obj();
            os_log_type_t v315 = v373[0];
            BOOL v332 = os_log_type_enabled(v314, v373[0]);
            if (!v331)
            {
              if (!v332) {
                goto LABEL_629;
              }
              LODWORD(buf[0]) = 136446210;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              v316 = "%{public}s called with null output_context, no backtrace";
              goto LABEL_628;
            }
            if (v332)
            {
              LODWORD(buf[0]) = 136446466;
              *(void *)((char *)buf + 4) = "nw_http2_submit_data";
              WORD2(buf[1]) = 2082;
              *(void *)((char *)&buf[1] + 6) = v331;
              _os_log_impl(&dword_1830D4000, v314, v315, "%{public}s called with null output_context, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
            }
            free(v331);
            goto LABEL_629;
          }
          v314 = __nwlog_obj();
          os_log_type_t v315 = v373[0];
          if (!os_log_type_enabled(v314, v373[0])) {
            goto LABEL_629;
          }
          LODWORD(buf[0]) = 136446210;
          *(void *)((char *)buf + 4) = "nw_http2_submit_data";
          v316 = "%{public}s called with null output_context";
        }
LABEL_628:
        _os_log_impl(&dword_1830D4000, v314, v315, v316, (uint8_t *)buf, 0xCu);
        goto LABEL_629;
      }
LABEL_35:
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0
        || !*((unsigned char *)p_cache + 3665))
      {
        goto LABEL_37;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v253 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_37;
      }
      int v255 = *(_DWORD *)(a3 + 176);
      int v254 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(void *)&long long v369 = " ";
      WORD4(v369) = 1024;
      *(_DWORD *)((char *)&v369 + 10) = v254;
      HIWORD(v369) = 1024;
      LODWORD(v370[0]) = v255;
      uint64_t v135 = "%{public}s %{public}s%s<i%u:s%d> skipping empty frame body";
      BOOL v136 = v253;
      os_log_type_t v137 = OS_LOG_TYPE_DEBUG;
      uint32_t v138 = 44;
      goto LABEL_643;
    }
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
    BOOL v242 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v373[0]) = 0;
    if (__nwlog_fault(v242, type, v373))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        __int16 v243 = __nwlog_obj();
        os_log_type_t v244 = type[0];
        if (!os_log_type_enabled(v243, type[0])) {
          goto LABEL_443;
        }
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        __int16 v245 = "%{public}s called with null frame";
LABEL_442:
        _os_log_impl(&dword_1830D4000, v243, v244, v245, (uint8_t *)buf, 0xCu);
        goto LABEL_443;
      }
      if (!LOBYTE(v373[0]))
      {
        __int16 v243 = __nwlog_obj();
        os_log_type_t v244 = type[0];
        if (!os_log_type_enabled(v243, type[0])) {
          goto LABEL_443;
        }
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        __int16 v245 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_442;
      }
      v266 = (char *)__nw_create_backtrace_string();
      __int16 v243 = __nwlog_obj();
      os_log_type_t v244 = type[0];
      BOOL v267 = os_log_type_enabled(v243, type[0]);
      if (!v266)
      {
        if (!v267) {
          goto LABEL_443;
        }
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        __int16 v245 = "%{public}s called with null frame, no backtrace";
        goto LABEL_442;
      }
      if (v267)
      {
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v266;
        _os_log_impl(&dword_1830D4000, v243, v244, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
      }
      free(v266);
    }
LABEL_443:
    if (v242) {
      free(v242);
    }
    __nwlog_obj();
    LODWORD(buf[0]) = 136446210;
    *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
    nw_endpoint_t v288 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v373[0]) = 0;
    if (!__nwlog_fault(v288, type, v373)) {
      goto LABEL_459;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v289 = __nwlog_obj();
      os_log_type_t v290 = type[0];
      if (!os_log_type_enabled(v289, type[0])) {
        goto LABEL_459;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
      os_log_type_t v291 = "%{public}s called with null frame";
    }
    else if (LOBYTE(v373[0]))
    {
      id v292 = (char *)__nw_create_backtrace_string();
      os_log_type_t v289 = __nwlog_obj();
      os_log_type_t v290 = type[0];
      BOOL v293 = os_log_type_enabled(v289, type[0]);
      if (v292)
      {
        if (v293)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v292;
          _os_log_impl(&dword_1830D4000, v289, v290, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(v292);
        goto LABEL_459;
      }
      if (!v293)
      {
LABEL_459:
        if (v288) {
          free(v288);
        }
        goto LABEL_35;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
      os_log_type_t v291 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      os_log_type_t v289 = __nwlog_obj();
      os_log_type_t v290 = type[0];
      if (!os_log_type_enabled(v289, type[0])) {
        goto LABEL_459;
      }
      LODWORD(buf[0]) = 136446210;
      *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
      os_log_type_t v291 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v289, v290, v291, (uint8_t *)buf, 0xCu);
    goto LABEL_459;
  }
  if ((v10 & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v246 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v248 = *(_DWORD *)(a3 + 176);
      int v247 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(void *)&long long v369 = " ";
      WORD4(v369) = 1024;
      *(_DWORD *)((char *)&v369 + 10) = v247;
      HIWORD(v369) = 1024;
      LODWORD(v370[0]) = v248;
      _os_log_impl(&dword_1830D4000, v246, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", (uint8_t *)buf, 0x2Cu);
    }
  }
  int v19 = *(unsigned __int16 *)(a3 + 188);
  int v20 = v19 | (*(unsigned __int8 *)(a3 + 190) << 16);
  if ((v19 & 0x100) != 0)
  {
    if ((v20 & 0x80000) != 0) {
      goto LABEL_149;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v39 = *(_DWORD *)(a3 + 176);
    int v38 = *(_DWORD *)(a3 + 180);
    LODWORD(buf[0]) = 136447490;
    *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = a3 + 191;
    HIWORD(buf[2]) = 2080;
    *(void *)&long long v369 = " ";
    WORD4(v369) = 1024;
    *(_DWORD *)((char *)&v369 + 10) = v38;
    HIWORD(v369) = 1024;
    LODWORD(v370[0]) = v39;
    WORD2(v370[0]) = 1024;
    *(_DWORD *)((char *)v370 + 6) = v39;
    id v40 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v373[0]) = 0;
    if (__nwlog_fault(v40, type, v373))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v41 = gconnectionLogObj;
        os_log_type_t v42 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
          goto LABEL_147;
        }
        int v44 = *(_DWORD *)(a3 + 176);
        int v43 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447490;
        *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v43;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v44;
        WORD2(v370[0]) = 1024;
        *(_DWORD *)((char *)v370 + 6) = v44;
        os_log_type_t v45 = "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again";
      }
      else if (LOBYTE(v373[0]))
      {
        int v59 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v41 = gconnectionLogObj;
        os_log_type_t v42 = type[0];
        BOOL v60 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
        if (v59)
        {
          if (v60)
          {
            int v62 = *(_DWORD *)(a3 + 176);
            int v61 = *(_DWORD *)(a3 + 180);
            LODWORD(buf[0]) = 136447746;
            *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
            WORD2(buf[1]) = 2082;
            *(void *)((char *)&buf[1] + 6) = a3 + 191;
            HIWORD(buf[2]) = 2080;
            *(void *)&long long v369 = " ";
            WORD4(v369) = 1024;
            *(_DWORD *)((char *)&v369 + 10) = v61;
            HIWORD(v369) = 1024;
            LODWORD(v370[0]) = v62;
            WORD2(v370[0]) = 1024;
            *(_DWORD *)((char *)v370 + 6) = v62;
            WORD1(v370[1]) = 2082;
            *(void **)((char *)&v370[1] + 4) = v59;
            _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again, dumping backtrace:%{public}s", (uint8_t *)buf, 0x3Cu);
          }
          free(v59);
          goto LABEL_147;
        }
        if (!v60) {
          goto LABEL_147;
        }
        int v111 = *(_DWORD *)(a3 + 176);
        int v110 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447490;
        *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v110;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v111;
        WORD2(v370[0]) = 1024;
        *(_DWORD *)((char *)v370 + 6) = v111;
        os_log_type_t v45 = "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v41 = gconnectionLogObj;
        os_log_type_t v42 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
          goto LABEL_147;
        }
        int v73 = *(_DWORD *)(a3 + 176);
        int v72 = *(_DWORD *)(a3 + 180);
        LODWORD(buf[0]) = 136447490;
        *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = a3 + 191;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = " ";
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v72;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v73;
        WORD2(v370[0]) = 1024;
        *(_DWORD *)((char *)v370 + 6) = v73;
        os_log_type_t v45 = "%{public}s %{public}s%s<i%u:s%d> already sent headers for stream %d, cannot send again, backtrace limit exceeded";
      }
      os_log_type_t v112 = v41;
      os_log_type_t v113 = v42;
      uint32_t v114 = 50;
LABEL_146:
      _os_log_impl(&dword_1830D4000, v112, v113, v45, (uint8_t *)buf, v114);
    }
LABEL_147:
    if (!v40) {
      goto LABEL_149;
    }
    goto LABEL_148;
  }
  *(unsigned char *)(a3 + 190) = BYTE2(v20);
  *(_WORD *)(a3 + 188) = v20 | 0x100;
  if (a4)
  {
    uint64_t v21 = *(void *)(a4 + 64);
    BOOL v23 = v21
       && (*(unsigned char *)(v21 + 66) & 0x40) != 0
       && ((int v22 = *(_DWORD *)(a4 + 52)) == 0 || v22 == *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60))
       && (v20 & 0x200) == 0;
    goto LABEL_55;
  }
  __nwlog_obj();
  LODWORD(buf[0]) = 136446210;
  *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
  v256 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v373[0]) = 0;
  if (__nwlog_fault(v256, type, v373))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v257 = __nwlog_obj();
      os_log_type_t v258 = type[0];
      if (os_log_type_enabled(v257, type[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        __int16 v259 = "%{public}s called with null frame";
LABEL_487:
        _os_log_impl(&dword_1830D4000, v257, v258, v259, (uint8_t *)buf, 0xCu);
      }
    }
    else if (LOBYTE(v373[0]))
    {
      os_log_type_t v278 = (char *)__nw_create_backtrace_string();
      __int16 v257 = __nwlog_obj();
      os_log_type_t v258 = type[0];
      BOOL v279 = os_log_type_enabled(v257, type[0]);
      if (v278)
      {
        if (v279)
        {
          LODWORD(buf[0]) = 136446466;
          *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
          WORD2(buf[1]) = 2082;
          *(void *)((char *)&buf[1] + 6) = v278;
          _os_log_impl(&dword_1830D4000, v257, v258, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
        }
        free(v278);
        goto LABEL_488;
      }
      if (v279)
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        __int16 v259 = "%{public}s called with null frame, no backtrace";
        goto LABEL_487;
      }
    }
    else
    {
      __int16 v257 = __nwlog_obj();
      os_log_type_t v258 = type[0];
      if (os_log_type_enabled(v257, type[0]))
      {
        LODWORD(buf[0]) = 136446210;
        *(void *)((char *)buf + 4) = "__nw_frame_is_metadata_complete";
        __int16 v259 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_487;
      }
    }
  }
LABEL_488:
  if (v256) {
    free(v256);
  }
  BOOL v23 = 0;
LABEL_55:
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_28_83258);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  uint64_t v366 = a3;
  uint64_t v46 = a3;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
  {
    uint64_t v46 = a3;
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      size_t v260 = gconnectionLogObj;
      BOOL v261 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      uint64_t v46 = v366;
      if (v261)
      {
        nw_endpoint_t v262 = "";
        int v264 = *(_DWORD *)(v366 + 176);
        int v263 = *(_DWORD *)(v366 + 180);
        v265 = (const char *)(v366 + 191);
        *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        if (!v366) {
          v265 = "";
        }
        LODWORD(buf[0]) = 136447234;
        if (v366) {
          nw_endpoint_t v262 = " ";
        }
        *(void *)((char *)&buf[1] + 6) = v265;
        HIWORD(buf[2]) = 2080;
        *(void *)&long long v369 = v262;
        WORD4(v369) = 1024;
        *(_DWORD *)((char *)&v369 + 10) = v263;
        HIWORD(v369) = 1024;
        LODWORD(v370[0]) = v264;
        _os_log_impl(&dword_1830D4000, v260, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called", (uint8_t *)buf, 0x2Cu);
        uint64_t v46 = v366;
      }
    }
  }
  if (*(void *)(v46 + 120) == *(void *)(v46 + 128))
  {
    BOOL v349 = v23;
    id v65 = nw_http_metadata_copy_request(*(void **)(v46 + 104));
    BOOL v66 = v65;
    if (v65)
    {
      BOOL has_method = nw_http_request_has_method(v65, (uint64_t)"CONNECT");
      uint64_t v68 = v366;
      if (has_method)
      {
        int v69 = *(unsigned __int16 *)(v366 + 188) | (*(unsigned __int8 *)(v366 + 190) << 16);
        if ((v69 & 0x10000) == 0)
        {
          v365[0] = MEMORY[0x1E4F143A8];
          v365[1] = 0x40000000;
          v365[2] = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke;
          v365[3] = &__block_descriptor_tmp_81_84441;
          v365[4] = v366;
          nw_http_fields_access_value_by_name(v66, (unint64_t)"Capsule-Protocol", v365);
          v364[0] = MEMORY[0x1E4F143A8];
          v364[1] = 0x40000000;
          v364[2] = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_2;
          v364[3] = &__block_descriptor_tmp_84_84442;
          v364[4] = v366;
          nw_http_request_access_extended_connect_protocol(v66, v364);
          uint64_t v68 = v366;
          int v69 = *(unsigned __int16 *)(v366 + 188) | (*(unsigned __int8 *)(v366 + 190) << 16);
        }
        *(unsigned char *)(v68 + 190) = BYTE2(v69);
        *(_WORD *)(v68 + 188) = v69 | 0x200;
      }
    }
    else
    {
      uint64_t v68 = v366;
    }
    id v74 = nw_http_metadata_copy_response(*(void **)(v68 + 104));
    uint64_t object = v74;
    if (v74)
    {
      __int16 v75 = (nw_http_response_get_status_code(v74) - 100) < 0x64;
      uint64_t v76 = v366;
      int v78 = *(unsigned __int16 *)(v366 + 188);
      uint64_t v77 = v366 + 188;
      unsigned int v79 = v78 & 0xFFFFDFFF | (*(unsigned __int8 *)(v366 + 190) << 16);
      *(_WORD *)(v366 + 188) = v78 & 0xDFFF | (v75 << 13);
      *(unsigned char *)(v77 + 2) = BYTE2(v79);
    }
    else
    {
      uint64_t v76 = v366;
    }
    buf[0] = 0;
    buf[1] = buf;
    buf[2] = 0x4002000000;
    *(void *)&long long v369 = __Block_byref_object_copy__84443;
    *((void *)&v369 + 1) = __Block_byref_object_dispose__84444;
    memset(v370, 0, sizeof(v370));
    uint64_t v362 = a1;
    v363[0] = 0;
    v363[1] = v363;
    v363[2] = 0x2000000000;
    v363[3] = 0;
    int v80 = *(void **)(v76 + 104);
    *(void *)long long type = MEMORY[0x1E4F143A8];
    uint64_t v356 = 0x40000000;
    v357 = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_85;
    __int16 v358 = &unk_1E524A870;
    __int16 v360 = v363;
    uint64_t v361 = v76;
    __int16 v359 = buf;
    id v81 = v80;
    int v82 = type;
    if (v81)
    {
      BOOL v83 = (id *)v81;
      id v84 = v83[1];

      if (nw_protocol_copy_http_definition_onceToken != -1) {
        dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
      }
      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v84, nw_protocol_copy_http_definition_http_definition);

      if (is_equal_unsafe)
      {
        v373[0] = MEMORY[0x1E4F143A8];
        v373[1] = 3221225472;
        v373[2] = __nw_http_metadata_enumerate_modern_header_fields_block_invoke;
        char v374 = &unk_1E5248ED8;
        int v86 = v82;
        uint64_t v375 = v86;
        if (v83[4])
        {
          ((void (*)(void *))v373[2])(v373);
          int v86 = v375;
        }

        goto LABEL_115;
      }
      v283 = __nwlog_obj();
      LODWORD(v373[0]) = 136446210;
      *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
      char v348 = (void *)_os_log_send_and_compose_impl();

      v353[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v367 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault((const char *)v348, v353, &v367))
      {
LABEL_593:
        if (v348) {
          free(v348);
        }
LABEL_115:

        BOOL v87 = *(char **)(buf[1] + 40);
        int v88 = *(char **)(buf[1] + 48);
        p_cache = NWConcrete_nw_resolution_report.cache;
        if (v87 == v88) {
          goto LABEL_122;
        }
        uint64_t v89 = *(void *)(v366 + 120);
        unint64_t v90 = v88 - v87 - 40;
        if (v90 > 0x27)
        {
          unint64_t v91 = v90 / 0x28 + 1;
          int v92 = v87 + 48;
          uint64_t v93 = v91 & 0xFFFFFFFFFFFFFFELL;
          do
          {
            uint64_t v94 = *(v92 - 5);
            uint64_t v95 = *(v92 - 6) + v89;
            *(v92 - 1) += v89;
            uint64_t v96 = *v92 + v89;
            *(v92 - 6) = v95;
            *(v92 - 5) = v94 + v89;
            void *v92 = v96;
            v92 += 10;
            v93 -= 2;
          }
          while (v93);
          if (v91 == (v91 & 0xFFFFFFFFFFFFFFELL))
          {
LABEL_122:
            if (v349
              && (*(_WORD *)(v366 + 188) & 0x2000) == 0
              && ((*(unsigned __int16 *)(v366 + 188) | (*(unsigned __int8 *)(v366 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v98 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v99 = (const char *)(v366 + 191);
                BOOL v100 = "";
                if (!v366) {
                  int v99 = "";
                }
                int v101 = *(_DWORD *)(v366 + 176);
                int v102 = *(_DWORD *)(v366 + 180);
                if (v366) {
                  BOOL v100 = " ";
                }
                LODWORD(v373[0]) = 136447234;
                *(void *)((char *)v373 + 4) = "nw_http2_stream_make_and_submit_headers";
                WORD2(v373[1]) = 2082;
                *(void *)((char *)&v373[1] + 6) = v99;
                HIWORD(v373[2]) = 2080;
                char v374 = (void *)v100;
                LOWORD(v375) = 1024;
                *(_DWORD *)((char *)&v375 + 2) = v102;
                HIWORD(v375) = 1024;
                int v376 = v101;
                _os_log_impl(&dword_1830D4000, v98, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting end stream flag for headers", (uint8_t *)v373, 0x2Cu);
              }
              p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
            }
            int v354 = 0;
            *(void *)char v353 = 0;
            if ((*(unsigned char *)(a1 + 388) & 0x80) == 0)
            {
              v373[0] = 0;
              v373[1] = v373;
              LODWORD(v374) = 16;
              v373[2] = 0x2000000000;
              if (v66)
              {
                v352[0] = MEMORY[0x1E4F143A8];
                v352[1] = 0x40000000;
                v352[2] = ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_88;
                v352[3] = &unk_1E524A8A0;
                v352[4] = v373;
                nw_http_fields_access_value_by_name(v66, (unint64_t)"Priority", v352);
              }
              nghttp2_priority_spec_init();
              _Block_object_dispose(v373, 8);
            }
            int v103 = nghttp2_submit_headers();
            if ((v103 & 0x80000000) == 0)
            {
LABEL_167:
              _Block_object_dispose(v363, 8);
              _Block_object_dispose(buf, 8);
              if (v370[0])
              {
                v370[1] = v370[0];
                operator delete(v370[0]);
              }
              if (object) {
                os_release(object);
              }
              if (v66) {
                os_release(v66);
              }
              if (v103 < 0) {
                goto LABEL_149;
              }
              if (v103
                && ((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
                && *((unsigned char *)p_cache + 3665))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                os_log_type_t v301 = gconnectionLogObj;
                p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v303 = *(_DWORD *)(a3 + 176);
                  int v302 = *(_DWORD *)(a3 + 180);
                  LODWORD(buf[0]) = 136447746;
                  *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
                  WORD2(buf[1]) = 2082;
                  *(void *)((char *)&buf[1] + 6) = a3 + 191;
                  HIWORD(buf[2]) = 2080;
                  *(void *)&long long v369 = " ";
                  WORD4(v369) = 1024;
                  *(_DWORD *)((char *)&v369 + 10) = v302;
                  HIWORD(v369) = 1024;
                  LODWORD(v370[0]) = v303;
                  WORD2(v370[0]) = 2048;
                  *(void **)((char *)v370 + 6) = 0;
                  HIWORD(v370[1]) = 1024;
                  LODWORD(v370[2]) = v103;
                  _os_log_impl(&dword_1830D4000, v301, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> submitted %llu headers, assigned stream %d", (uint8_t *)buf, 0x3Cu);
                }
              }
              int v124 = *(_DWORD *)(a3 + 176);
              int v125 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
              if (v124 == -1)
              {
                if ((*(_WORD *)(a3 + 188) & 0x80) != 0)
                {
                  if ((v125 & 0x80000) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v157 = *(_DWORD *)(a3 + 176);
                    int v156 = *(_DWORD *)(a3 + 180);
                    LODWORD(buf[0]) = 136447234;
                    *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = a3 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(void *)&long long v369 = " ";
                    WORD4(v369) = 1024;
                    *(_DWORD *)((char *)&v369 + 10) = v156;
                    HIWORD(v369) = 1024;
                    LODWORD(v370[0]) = v157;
                    unsigned int v150 = (char *)_os_log_send_and_compose_impl();
                    LOBYTE(v373[0]) = 16;
                    LOBYTE(v365[0]) = 0;
                    if (__nwlog_fault(v150, v373, v365))
                    {
                      if (LOBYTE(v373[0]) == 17)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        int v158 = gconnectionLogObj;
                        os_log_type_t v159 = v373[0];
                        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0])) {
                          goto LABEL_328;
                        }
                        int v161 = *(_DWORD *)(a3 + 176);
                        int v160 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(void *)&long long v369 = " ";
                        WORD4(v369) = 1024;
                        *(_DWORD *)((char *)&v369 + 10) = v160;
                        HIWORD(v369) = 1024;
                        LODWORD(v370[0]) = v161;
                        int v155 = "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening";
                      }
                      else if (LOBYTE(v365[0]))
                      {
                        int v170 = (char *)__nw_create_backtrace_string();
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        int v158 = gconnectionLogObj;
                        os_log_type_t v159 = v373[0];
                        BOOL v171 = os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0]);
                        if (v170)
                        {
                          if (v171)
                          {
                            int v173 = *(_DWORD *)(a3 + 176);
                            int v172 = *(_DWORD *)(a3 + 180);
                            LODWORD(buf[0]) = 136447490;
                            *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                            WORD2(buf[1]) = 2082;
                            *(void *)((char *)&buf[1] + 6) = a3 + 191;
                            HIWORD(buf[2]) = 2080;
                            *(void *)&long long v369 = " ";
                            WORD4(v369) = 1024;
                            *(_DWORD *)((char *)&v369 + 10) = v172;
                            HIWORD(v369) = 1024;
                            LODWORD(v370[0]) = v173;
                            WORD2(v370[0]) = 2082;
                            *(void **)((char *)v370 + 6) = v170;
                            _os_log_impl(&dword_1830D4000, v158, v159, "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening, dumping backtrace:%{public}s", (uint8_t *)buf, 0x36u);
                          }
                          free(v170);
                          goto LABEL_328;
                        }
                        if (!v171) {
                          goto LABEL_328;
                        }
                        int v213 = *(_DWORD *)(a3 + 176);
                        int v212 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(void *)&long long v369 = " ";
                        WORD4(v369) = 1024;
                        *(_DWORD *)((char *)&v369 + 10) = v212;
                        HIWORD(v369) = 1024;
                        LODWORD(v370[0]) = v213;
                        int v155 = "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening, no backtrace";
                      }
                      else
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        int v158 = gconnectionLogObj;
                        os_log_type_t v159 = v373[0];
                        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0])) {
                          goto LABEL_328;
                        }
                        int v203 = *(_DWORD *)(a3 + 176);
                        int v202 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447234;
                        *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(void *)&long long v369 = " ";
                        WORD4(v369) = 1024;
                        *(_DWORD *)((char *)&v369 + 10) = v202;
                        HIWORD(v369) = 1024;
                        LODWORD(v370[0]) = v203;
                        int v155 = "%{public}s %{public}s%s<i%u:s%d> Responder stream cannot have id of -1 after opening, bac"
                               "ktrace limit exceeded";
                      }
                      BOOL v206 = v158;
                      os_log_type_t v207 = v159;
                      uint32_t v208 = 44;
                      goto LABEL_327;
                    }
LABEL_328:
                    if (!v150)
                    {
LABEL_330:
                      p_cache = NWConcrete_nw_resolution_report.cache;
                      goto LABEL_331;
                    }
LABEL_329:
                    free(v150);
                    goto LABEL_330;
                  }
LABEL_331:
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
                    && *((unsigned char *)p_cache + 3665))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v214 = gconnectionLogObj;
                    p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                    {
                      int v216 = *(_DWORD *)(a3 + 176);
                      int v215 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447234;
                      *(void *)((char *)buf + 4) = "nw_http2_submit_headers";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v215;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v216;
                      _os_log_impl(&dword_1830D4000, v214, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> failed to handle new stream id", (uint8_t *)buf, 0x2Cu);
                    }
                  }
                  goto LABEL_149;
                }
                *(_DWORD *)(a3 + 176) = v103;
                if (!nw_http2_add_to_id_table(a1, a3, (uint64_t)a2))
                {
                  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    unsigned int v193 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                    {
                      int v195 = *(_DWORD *)(a3 + 176);
                      int v194 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447234;
                      *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v194;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v195;
                      _os_log_impl(&dword_1830D4000, v193, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> Failed to add new stream to the id based hash table", (uint8_t *)buf, 0x2Cu);
                    }
                  }
                  *(_DWORD *)(a3 + 176) = -1;
                  goto LABEL_331;
                }
                int v125 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
                if (*(int *)(a3 + 176) > 0) {
                  goto LABEL_179;
                }
              }
              else if (v124 > 0)
              {
LABEL_179:
                if ((v125 & 0x80000) == 0 && *((unsigned char *)p_cache + 3665))
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  os_log_type_t v309 = gconnectionLogObj;
                  p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                  {
                    int v311 = *(_DWORD *)(a3 + 176);
                    int v310 = *(_DWORD *)(a3 + 180);
                    if ((*(_WORD *)(a1 + 388) & 0x80) != 0) {
                      os_log_type_t v312 = "response";
                    }
                    else {
                      os_log_type_t v312 = "request";
                    }
                    LODWORD(buf[0]) = 136447746;
                    *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                    WORD2(buf[1]) = 2082;
                    *(void *)((char *)&buf[1] + 6) = a3 + 191;
                    HIWORD(buf[2]) = 2080;
                    *(void *)&long long v369 = " ";
                    WORD4(v369) = 1024;
                    *(_DWORD *)((char *)&v369 + 10) = v310;
                    HIWORD(v369) = 1024;
                    LODWORD(v370[0]) = v311;
                    WORD2(v370[0]) = 2080;
                    *(void **)((char *)v370 + 6) = (void *)v312;
                    HIWORD(v370[1]) = 1024;
                    LODWORD(v370[2]) = v311;
                    _os_log_impl(&dword_1830D4000, v309, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> %s headers submitted on stream %d", (uint8_t *)buf, 0x3Cu);
                  }
                }
                if (a4)
                {
                  int v126 = *(_DWORD *)(a4 + 52);
                  if (v126 && v126 != *(_DWORD *)(a4 + 56) + *(_DWORD *)(a4 + 60))
                  {
                    int v10 = *(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16);
                    goto LABEL_185;
                  }
                  goto LABEL_35;
                }
                __nwlog_obj();
                LODWORD(buf[0]) = 136446210;
                *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                BOOL v305 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v373[0]) = 16;
                LOBYTE(v365[0]) = 0;
                if (__nwlog_fault(v305, v373, v365))
                {
                  if (LOBYTE(v373[0]) == 17)
                  {
                    os_log_type_t v306 = __nwlog_obj();
                    os_log_type_t v307 = v373[0];
                    if (os_log_type_enabled(v306, v373[0]))
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                      v308 = "%{public}s called with null frame";
LABEL_616:
                      _os_log_impl(&dword_1830D4000, v306, v307, v308, (uint8_t *)buf, 0xCu);
                    }
                  }
                  else if (LOBYTE(v365[0]))
                  {
                    v329 = (char *)__nw_create_backtrace_string();
                    os_log_type_t v306 = __nwlog_obj();
                    os_log_type_t v307 = v373[0];
                    BOOL v330 = os_log_type_enabled(v306, v373[0]);
                    if (v329)
                    {
                      if (v330)
                      {
                        LODWORD(buf[0]) = 136446466;
                        *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = v329;
                        _os_log_impl(&dword_1830D4000, v306, v307, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)buf, 0x16u);
                      }
                      free(v329);
                      goto LABEL_617;
                    }
                    if (v330)
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                      v308 = "%{public}s called with null frame, no backtrace";
                      goto LABEL_616;
                    }
                  }
                  else
                  {
                    os_log_type_t v306 = __nwlog_obj();
                    os_log_type_t v307 = v373[0];
                    if (os_log_type_enabled(v306, v373[0]))
                    {
                      LODWORD(buf[0]) = 136446210;
                      *(void *)((char *)buf + 4) = "__nw_frame_unclaimed_length";
                      v308 = "%{public}s called with null frame, backtrace limit exceeded";
                      goto LABEL_616;
                    }
                  }
                }
LABEL_617:
                if (v305) {
                  free(v305);
                }
                p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
                goto LABEL_35;
              }
              if ((v125 & 0x80000) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v149 = *(_DWORD *)(a3 + 176);
                int v148 = *(_DWORD *)(a3 + 180);
                LODWORD(buf[0]) = 136447490;
                *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                WORD2(buf[1]) = 2082;
                *(void *)((char *)&buf[1] + 6) = a3 + 191;
                HIWORD(buf[2]) = 2080;
                *(void *)&long long v369 = " ";
                WORD4(v369) = 1024;
                *(_DWORD *)((char *)&v369 + 10) = v148;
                HIWORD(v369) = 1024;
                LODWORD(v370[0]) = v149;
                WORD2(v370[0]) = 2048;
                *(void **)((char *)v370 + 6) = (void *)a3;
                unsigned int v150 = (char *)_os_log_send_and_compose_impl();
                LOBYTE(v373[0]) = 16;
                LOBYTE(v365[0]) = 0;
                if (__nwlog_fault(v150, v373, v365))
                {
                  if (LOBYTE(v373[0]) == 17)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v151 = gconnectionLogObj;
                    os_log_type_t v152 = v373[0];
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0]))
                    {
                      int v154 = *(_DWORD *)(a3 + 176);
                      int v153 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v153;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v154;
                      WORD2(v370[0]) = 2048;
                      *(void **)((char *)v370 + 6) = (void *)a3;
                      int v155 = "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening";
LABEL_319:
                      BOOL v206 = v151;
                      os_log_type_t v207 = v152;
                      uint32_t v208 = 54;
LABEL_327:
                      _os_log_impl(&dword_1830D4000, v206, v207, v155, (uint8_t *)buf, v208);
                      goto LABEL_328;
                    }
                  }
                  else if (LOBYTE(v365[0]))
                  {
                    int v166 = (char *)__nw_create_backtrace_string();
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v151 = gconnectionLogObj;
                    os_log_type_t v152 = v373[0];
                    BOOL v167 = os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0]);
                    if (v166)
                    {
                      if (v167)
                      {
                        int v169 = *(_DWORD *)(a3 + 176);
                        int v168 = *(_DWORD *)(a3 + 180);
                        LODWORD(buf[0]) = 136447746;
                        *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                        WORD2(buf[1]) = 2082;
                        *(void *)((char *)&buf[1] + 6) = a3 + 191;
                        HIWORD(buf[2]) = 2080;
                        *(void *)&long long v369 = " ";
                        WORD4(v369) = 1024;
                        *(_DWORD *)((char *)&v369 + 10) = v168;
                        HIWORD(v369) = 1024;
                        LODWORD(v370[0]) = v169;
                        WORD2(v370[0]) = 2048;
                        *(void **)((char *)v370 + 6) = (void *)a3;
                        HIWORD(v370[1]) = 2082;
                        v370[2] = v166;
                        _os_log_impl(&dword_1830D4000, v151, v152, "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening, dumping backtrace:%{public}s", (uint8_t *)buf, 0x40u);
                      }
                      free(v166);
                      if (!v150) {
                        goto LABEL_330;
                      }
                      goto LABEL_329;
                    }
                    if (v167)
                    {
                      int v205 = *(_DWORD *)(a3 + 176);
                      int v204 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v204;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v205;
                      WORD2(v370[0]) = 2048;
                      *(void **)((char *)v370 + 6) = (void *)a3;
                      int v155 = "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening, no backtrace";
                      goto LABEL_319;
                    }
                  }
                  else
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    int v151 = gconnectionLogObj;
                    os_log_type_t v152 = v373[0];
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, v373[0]))
                    {
                      int v201 = *(_DWORD *)(a3 + 176);
                      int v200 = *(_DWORD *)(a3 + 180);
                      LODWORD(buf[0]) = 136447490;
                      *(void *)((char *)buf + 4) = "nw_http2_stream_submitted_headers";
                      WORD2(buf[1]) = 2082;
                      *(void *)((char *)&buf[1] + 6) = a3 + 191;
                      HIWORD(buf[2]) = 2080;
                      *(void *)&long long v369 = " ";
                      WORD4(v369) = 1024;
                      *(_DWORD *)((char *)&v369 + 10) = v200;
                      HIWORD(v369) = 1024;
                      LODWORD(v370[0]) = v201;
                      WORD2(v370[0]) = 2048;
                      *(void **)((char *)v370 + 6) = (void *)a3;
                      int v155 = "%{public}s %{public}s%s<i%u:s%d> Stream %p has invalid id after opening, backtrace limit exceeded";
                      goto LABEL_319;
                    }
                  }
                }
                goto LABEL_328;
              }
              goto LABEL_331;
            }
            __nwlog_obj();
            uint64_t v104 = nghttp2_strerror();
            LODWORD(v373[0]) = 136446466;
            *(void *)((char *)v373 + 4) = "nw_http2_stream_make_and_submit_headers";
            WORD2(v373[1]) = 2082;
            *(void *)((char *)&v373[1] + 6) = v104;
            int v105 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t v367 = OS_LOG_TYPE_ERROR;
            char v351 = 0;
            if (__nwlog_fault(v105, &v367, &v351))
            {
              if (v367 == OS_LOG_TYPE_FAULT)
              {
                __int16 v106 = __nwlog_obj();
                os_log_type_t v107 = v367;
                if (os_log_type_enabled(v106, v367))
                {
                  uint64_t v108 = nghttp2_strerror();
                  LODWORD(v373[0]) = 136446466;
                  *(void *)((char *)v373 + 4) = "nw_http2_stream_make_and_submit_headers";
                  WORD2(v373[1]) = 2082;
                  *(void *)((char *)&v373[1] + 6) = v108;
                  uint64_t v109 = "%{public}s nghttp2_submit_headers: %{public}s failed";
LABEL_162:
                  int v123 = v106;
LABEL_163:
                  _os_log_impl(&dword_1830D4000, v123, v107, v109, (uint8_t *)v373, 0x16u);
                }
              }
              else if (v351)
              {
                uint64_t v118 = (char *)__nw_create_backtrace_string();
                __int16 v119 = __nwlog_obj();
                os_log_type_t v107 = v367;
                BOOL v120 = os_log_type_enabled(v119, v367);
                if (v118)
                {
                  if (v120)
                  {
                    uint64_t v121 = nghttp2_strerror();
                    LODWORD(v373[0]) = 136446722;
                    *(void *)((char *)v373 + 4) = "nw_http2_stream_make_and_submit_headers";
                    WORD2(v373[1]) = 2082;
                    *(void *)((char *)&v373[1] + 6) = v121;
                    HIWORD(v373[2]) = 2082;
                    char v374 = v118;
                    _os_log_impl(&dword_1830D4000, v119, v107, "%{public}s nghttp2_submit_headers: %{public}s failed, dumping backtrace:%{public}s", (uint8_t *)v373, 0x20u);
                  }
                  free(v118);
                  goto LABEL_164;
                }
                if (v120)
                {
                  uint64_t v196 = nghttp2_strerror();
                  LODWORD(v373[0]) = 136446466;
                  *(void *)((char *)v373 + 4) = "nw_http2_stream_make_and_submit_headers";
                  WORD2(v373[1]) = 2082;
                  *(void *)((char *)&v373[1] + 6) = v196;
                  uint64_t v109 = "%{public}s nghttp2_submit_headers: %{public}s failed, no backtrace";
                  int v123 = v119;
                  goto LABEL_163;
                }
              }
              else
              {
                __int16 v106 = __nwlog_obj();
                os_log_type_t v107 = v367;
                if (os_log_type_enabled(v106, v367))
                {
                  uint64_t v122 = nghttp2_strerror();
                  LODWORD(v373[0]) = 136446466;
                  *(void *)((char *)v373 + 4) = "nw_http2_stream_make_and_submit_headers";
                  WORD2(v373[1]) = 2082;
                  *(void *)((char *)&v373[1] + 6) = v122;
                  uint64_t v109 = "%{public}s nghttp2_submit_headers: %{public}s failed, backtrace limit exceeded";
                  goto LABEL_162;
                }
              }
            }
LABEL_164:
            if (v105) {
              free(v105);
            }
            p_cache = NWConcrete_nw_resolution_report.cache;
            goto LABEL_167;
          }
          v87 += 40 * (v91 & 0xFFFFFFFFFFFFFFELL);
        }
        do
        {
          uint64_t v97 = *((void *)v87 + 1) + v89;
          *(void *)v87 += v89;
          *((void *)v87 + 1) = v97;
          v87 += 40;
        }
        while (v87 != v88);
        goto LABEL_122;
      }
      if (v353[0] == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v281 = __nwlog_obj();
        os_log_type_t v284 = v353[0];
        if (os_log_type_enabled(v281, v353[0]))
        {
          LODWORD(v373[0]) = 136446210;
          *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_1830D4000, v281, v284, "%{public}s metadata must be http", (uint8_t *)v373, 0xCu);
        }
LABEL_592:

        goto LABEL_593;
      }
      if (v367 == OS_LOG_TYPE_DEFAULT)
      {
        nw_endpoint_t v281 = __nwlog_obj();
        os_log_type_t v328 = v353[0];
        if (os_log_type_enabled(v281, v353[0]))
        {
          LODWORD(v373[0]) = 136446210;
          *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_1830D4000, v281, v328, "%{public}s metadata must be http, backtrace limit exceeded", (uint8_t *)v373, 0xCu);
        }
        goto LABEL_592;
      }
      v296 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v281 = __nwlog_obj();
      os_log_type_t v299 = v353[0];
      BOOL v300 = os_log_type_enabled(v281, v353[0]);
      if (!v296)
      {
        if (v300)
        {
          LODWORD(v373[0]) = 136446210;
          *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_1830D4000, v281, v299, "%{public}s metadata must be http, no backtrace", (uint8_t *)v373, 0xCu);
        }
        goto LABEL_592;
      }
      if (v300)
      {
        LODWORD(v373[0]) = 136446466;
        *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
        WORD2(v373[1]) = 2082;
        *(void *)((char *)&v373[1] + 6) = v296;
        _os_log_impl(&dword_1830D4000, v281, v299, "%{public}s metadata must be http, dumping backtrace:%{public}s", (uint8_t *)v373, 0x16u);
      }
    }
    else
    {
      nw_endpoint_t v280 = __nwlog_obj();
      LODWORD(v373[0]) = 136446210;
      *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
      char v348 = (void *)_os_log_send_and_compose_impl();

      v353[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v367 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault((const char *)v348, v353, &v367)) {
        goto LABEL_593;
      }
      if (v353[0] == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v281 = __nwlog_obj();
        os_log_type_t v282 = v353[0];
        if (os_log_type_enabled(v281, v353[0]))
        {
          LODWORD(v373[0]) = 136446210;
          *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_1830D4000, v281, v282, "%{public}s called with null metadata", (uint8_t *)v373, 0xCu);
        }
        goto LABEL_592;
      }
      if (v367 == OS_LOG_TYPE_DEFAULT)
      {
        nw_endpoint_t v281 = __nwlog_obj();
        os_log_type_t v327 = v353[0];
        if (os_log_type_enabled(v281, v353[0]))
        {
          LODWORD(v373[0]) = 136446210;
          *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_1830D4000, v281, v327, "%{public}s called with null metadata, backtrace limit exceeded", (uint8_t *)v373, 0xCu);
        }
        goto LABEL_592;
      }
      v296 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v281 = __nwlog_obj();
      os_log_type_t v297 = v353[0];
      BOOL v298 = os_log_type_enabled(v281, v353[0]);
      if (!v296)
      {
        if (v298)
        {
          LODWORD(v373[0]) = 136446210;
          *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
          _os_log_impl(&dword_1830D4000, v281, v297, "%{public}s called with null metadata, no backtrace", (uint8_t *)v373, 0xCu);
        }
        goto LABEL_592;
      }
      if (v298)
      {
        LODWORD(v373[0]) = 136446466;
        *(void *)((char *)v373 + 4) = "nw_http_metadata_enumerate_modern_header_fields";
        WORD2(v373[1]) = 2082;
        *(void *)((char *)&v373[1] + 6) = v296;
        _os_log_impl(&dword_1830D4000, v281, v297, "%{public}s called with null metadata, dumping backtrace:%{public}s", (uint8_t *)v373, 0x16u);
      }
    }

    free(v296);
    goto LABEL_593;
  }
  if (((*(unsigned __int16 *)(v46 + 188) | (*(unsigned __int8 *)(v46 + 190) << 16)) & 0x80000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v47 = gconnectionLogObj;
    BOOL v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    uint64_t v46 = v366;
    if (v48)
    {
      int v49 = "";
      int v51 = *(_DWORD *)(v366 + 176);
      int v50 = *(_DWORD *)(v366 + 180);
      int v52 = (const char *)(v366 + 191);
      *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      if (!v366) {
        int v52 = "";
      }
      LODWORD(buf[0]) = 136447234;
      if (v366) {
        int v49 = " ";
      }
      *(void *)((char *)&buf[1] + 6) = v52;
      HIWORD(buf[2]) = 2080;
      *(void *)&long long v369 = v49;
      WORD4(v369) = 1024;
      *(_DWORD *)((char *)&v369 + 10) = v50;
      HIWORD(v369) = 1024;
      LODWORD(v370[0]) = v51;
      _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> Already buffered header bytes", (uint8_t *)buf, 0x2Cu);
      uint64_t v46 = v366;
    }
  }
  int v53 = *(unsigned __int16 *)(v46 + 188);
  int v54 = v53 | (*(unsigned __int8 *)(v46 + 190) << 16);
  if ((v53 & 0x40) != 0) {
    goto LABEL_149;
  }
  *(unsigned char *)(v46 + 190) = BYTE2(v54);
  *(_WORD *)(v46 + 188) = v54 | 0x40;
  uint64_t v55 = a2[3];
  if (!v55 || (uint64_t v56 = *(void (**)(void *, uint64_t, uint64_t))(v55 + 56)) == 0)
  {
    __nwlog_obj();
    v272 = (const char *)a2[2];
    if (!v272) {
      v272 = "invalid";
    }
    LODWORD(buf[0]) = 136446466;
    *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v272;
    os_log_type_t v273 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v373[0]) = 0;
    if (__nwlog_fault(v273, type, v373))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v274 = __nwlog_obj();
        os_log_type_t v275 = type[0];
        if (!os_log_type_enabled(v274, type[0])) {
          goto LABEL_527;
        }
        id v276 = (const char *)a2[2];
        if (!v276) {
          id v276 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v276;
        os_log_type_t v277 = "%{public}s protocol %{public}s has invalid error callback";
LABEL_526:
        _os_log_impl(&dword_1830D4000, v274, v275, v277, (uint8_t *)buf, 0x16u);
        goto LABEL_527;
      }
      if (!LOBYTE(v373[0]))
      {
        BOOL v274 = __nwlog_obj();
        os_log_type_t v275 = type[0];
        if (!os_log_type_enabled(v274, type[0])) {
          goto LABEL_527;
        }
        os_log_type_t v304 = (const char *)a2[2];
        if (!v304) {
          os_log_type_t v304 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v304;
        os_log_type_t v277 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_526;
      }
      id v285 = (char *)__nw_create_backtrace_string();
      BOOL v274 = __nwlog_obj();
      os_log_type_t v275 = type[0];
      BOOL v286 = os_log_type_enabled(v274, type[0]);
      if (!v285)
      {
        if (!v286) {
          goto LABEL_527;
        }
        nw_endpoint_t v317 = (const char *)a2[2];
        if (!v317) {
          nw_endpoint_t v317 = "invalid";
        }
        LODWORD(buf[0]) = 136446466;
        *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v317;
        os_log_type_t v277 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
        goto LABEL_526;
      }
      if (v286)
      {
        os_log_type_t v287 = (const char *)a2[2];
        if (!v287) {
          os_log_type_t v287 = "invalid";
        }
        LODWORD(buf[0]) = 136446722;
        *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
        WORD2(buf[1]) = 2082;
        *(void *)((char *)&buf[1] + 6) = v287;
        HIWORD(buf[2]) = 2082;
        *(void *)&long long v369 = v285;
        _os_log_impl(&dword_1830D4000, v274, v275, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
      }
      free(v285);
    }
LABEL_527:
    if (v273) {
      free(v273);
    }
    uint64_t v57 = a2[3];
    if (!v57) {
      goto LABEL_530;
    }
    goto LABEL_76;
  }
  v56(a2, a1, 22);
  uint64_t v57 = a2[3];
  if (!v57) {
    goto LABEL_530;
  }
LABEL_76:
  os_log_type_t v58 = *(void (**)(void *, uint64_t))(v57 + 48);
  if (v58)
  {
    v58(a2, a1);
    goto LABEL_149;
  }
LABEL_530:
  __nwlog_obj();
  v318 = (const char *)a2[2];
  if (!v318) {
    v318 = "invalid";
  }
  LODWORD(buf[0]) = 136446466;
  *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
  WORD2(buf[1]) = 2082;
  *(void *)((char *)&buf[1] + 6) = v318;
  id v40 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v373[0]) = 0;
  if (!__nwlog_fault(v40, type, v373)) {
    goto LABEL_147;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v319 = __nwlog_obj();
    os_log_type_t v320 = type[0];
    if (os_log_type_enabled(v319, type[0]))
    {
      v321 = (const char *)a2[2];
      if (!v321) {
        v321 = "invalid";
      }
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v321;
      os_log_type_t v45 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_554:
      os_log_type_t v112 = v319;
      os_log_type_t v113 = v320;
      uint32_t v114 = 22;
      goto LABEL_146;
    }
    goto LABEL_147;
  }
  if (!LOBYTE(v373[0]))
  {
    os_log_type_t v319 = __nwlog_obj();
    os_log_type_t v320 = type[0];
    if (os_log_type_enabled(v319, type[0]))
    {
      os_log_type_t v325 = (const char *)a2[2];
      if (!v325) {
        os_log_type_t v325 = "invalid";
      }
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v325;
      os_log_type_t v45 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_554;
    }
    goto LABEL_147;
  }
  id v322 = (char *)__nw_create_backtrace_string();
  os_log_type_t v319 = __nwlog_obj();
  os_log_type_t v320 = type[0];
  BOOL v323 = os_log_type_enabled(v319, type[0]);
  if (!v322)
  {
    if (v323)
    {
      BOOL v326 = (const char *)a2[2];
      if (!v326) {
        BOOL v326 = "invalid";
      }
      LODWORD(buf[0]) = 136446466;
      *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = v326;
      os_log_type_t v45 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
      goto LABEL_554;
    }
    goto LABEL_147;
  }
  if (v323)
  {
    os_log_type_t v324 = (const char *)a2[2];
    if (!v324) {
      os_log_type_t v324 = "invalid";
    }
    LODWORD(buf[0]) = 136446722;
    *(void *)((char *)buf + 4) = "nw_http2_stream_make_and_submit_headers";
    WORD2(buf[1]) = 2082;
    *(void *)((char *)&buf[1] + 6) = v324;
    HIWORD(buf[2]) = 2082;
    *(void *)&long long v369 = v322;
    _os_log_impl(&dword_1830D4000, v319, v320, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", (uint8_t *)buf, 0x20u);
  }
  free(v322);
  if (v40) {
LABEL_148:
  }
    free(v40);
LABEL_149:
  BOOL result = 0;
  if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0
    && *((unsigned char *)p_cache + 3665))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v115 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
    if (result)
    {
      int v117 = *(_DWORD *)(a3 + 176);
      int v116 = *(_DWORD *)(a3 + 180);
      LODWORD(buf[0]) = 136447234;
      *(void *)((char *)buf + 4) = "nw_http2_submit_message";
      WORD2(buf[1]) = 2082;
      *(void *)((char *)&buf[1] + 6) = a3 + 191;
      HIWORD(buf[2]) = 2080;
      *(void *)&long long v369 = " ";
      WORD4(v369) = 1024;
      *(_DWORD *)((char *)&v369 + 10) = v116;
      HIWORD(v369) = 1024;
      LODWORD(v370[0]) = v117;
      __int16 v15 = "%{public}s %{public}s%s<i%u:s%d> failed to send headers";
      os_log_type_t v16 = v115;
      os_log_type_t v17 = OS_LOG_TYPE_DEBUG;
      uint32_t v18 = 44;
      goto LABEL_9;
    }
  }
  return result;
}

uint64_t ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke(uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    BOOL result = strcmp(__s1, "?1");
    int v3 = (result == 0) << 17;
  }
  else
  {
    int v3 = 0;
  }
  uint64_t v4 = *(void *)(v2 + 32);
  int v5 = *(unsigned __int16 *)(v4 + 188);
  v4 += 188;
  unsigned int v6 = (v5 | (*(unsigned __int8 *)(v4 + 2) << 16)) & 0xFFFDFFFF | v3;
  *(_WORD *)uint64_t v4 = v6;
  *(unsigned char *)(v4 + 2) = BYTE2(v6);
  return result;
}

uint64_t ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_2(uint64_t result, char *__s1)
{
  uint64_t v2 = result;
  if (__s1)
  {
    BOOL result = strcmp(__s1, "connect-udp");
    if (result)
    {
      BOOL result = strcmp(__s1, "connect-ip");
      int v4 = (result == 0) << 18;
    }
    else
    {
      int v4 = 0x40000;
    }
  }
  else
  {
    int v4 = 0;
  }
  uint64_t v5 = *(void *)(v2 + 32);
  int v6 = *(unsigned __int16 *)(v5 + 188);
  v5 += 188;
  unsigned int v7 = (v6 | (*(unsigned __int8 *)(v5 + 2) << 16)) & 0xFFFBFFFF | v4;
  *(_WORD *)uint64_t v5 = v7;
  *(unsigned char *)(v5 + 2) = BYTE2(v7);
  return result;
}

__n128 __Block_byref_object_copy__84443(void *a1, uint64_t a2)
{
  a1[5] = 0;
  a1[6] = 0;
  a1[7] = 0;
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 5) = result;
  a1[7] = *(void *)(a2 + 56);
  *(void *)(a2 + 40) = 0;
  *(void *)(a2 + 48) = 0;
  *(void *)(a2 + 56) = 0;
  return result;
}

void __Block_byref_object_dispose__84444(uint64_t a1)
{
  uint64_t v2 = *(void **)(a1 + 40);
  if (v2)
  {
    *(void *)(a1 + 48) = v2;
    operator delete(v2);
  }
}

void ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_85(void *a1, char *__src, int64_t a3, char *a4, int64_t a5, int a6)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v12 = a1[6];
  if (v12)
  {
    if (((*(unsigned __int16 *)(v12 + 188) | (*(unsigned __int8 *)(v12 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v39 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v40 = a1[6];
        int v41 = (const char *)(v40 + 191);
        os_log_type_t v42 = "";
        BOOL v43 = v40 == 0;
        if (!v40) {
          int v41 = "";
        }
        uint64_t v46 = v40 + 176;
        int v44 = *(_DWORD *)(v40 + 176);
        int v45 = *(_DWORD *)(v46 + 4);
        if (!v43) {
          os_log_type_t v42 = " ";
        }
        *(_DWORD *)int buf = 136447746;
        int v50 = "nw_http2_stream_make_and_submit_headers_block_invoke";
        __int16 v51 = 2082;
        int v52 = v41;
        __int16 v53 = 2080;
        int v54 = v42;
        __int16 v55 = 1024;
        int v56 = v45;
        __int16 v57 = 1024;
        *(_DWORD *)os_log_type_t v58 = v44;
        *(_WORD *)&v58[4] = 2082;
        *(void *)&v58[6] = __src;
        *(_WORD *)&v58[14] = 2082;
        *(void *)&v58[16] = a4;
        int v36 = "%{public}s %{public}s%s<i%u:s%d> sending header field %{public}s: %{public}s";
        int v37 = v39;
        uint32_t v38 = 64;
LABEL_44:
        _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, v36, buf, v38);
      }
    }
  }
  else
  {
    uint64_t v29 = a1[7];
    if ((!v29 || (*(__int16 *)(v29 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v30 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v31 = a1[7];
        int v32 = (const char *)(v31 + 390);
        int v33 = *(_DWORD *)(v31 + 368);
        BOOL v34 = v31 == 0;
        *(_DWORD *)int buf = 136447490;
        if (!v31) {
          int v32 = "";
        }
        int v50 = "nw_http2_stream_make_and_submit_headers_block_invoke";
        BOOL v35 = " ";
        if (v34) {
          BOOL v35 = "";
        }
        __int16 v51 = 2082;
        int v52 = v32;
        __int16 v53 = 2080;
        int v54 = v35;
        __int16 v55 = 1024;
        int v56 = v33;
        __int16 v57 = 2082;
        *(void *)os_log_type_t v58 = __src;
        *(_WORD *)&v58[8] = 2082;
        *(void *)&v58[10] = a4;
        int v36 = "%{public}s %{public}s%s<i%u> sending header field %{public}s: %{public}s";
        int v37 = v30;
        uint32_t v38 = 58;
        goto LABEL_44;
      }
    }
  }
  if ((a6 & 0xFFFFFFFE) == 2) {
    char v13 = 7;
  }
  else {
    char v13 = 6;
  }
  int v14 = *(void **)(a1[4] + 8);
  uint64_t v15 = *(void *)(*(void *)(a1[5] + 8) + 24);
  uint64_t v16 = v15 + a3;
  uint32_t v18 = (void *)v14[6];
  unint64_t v17 = v14[7];
  if ((unint64_t)v18 >= v17)
  {
    uint64_t v47 = __src;
    int64_t v48 = a5;
    int v20 = (void *)v14[5];
    unint64_t v21 = 0xCCCCCCCCCCCCCCCDLL * (v18 - v20) + 1;
    if (v21 > 0x666666666666666) {
      abort();
    }
    unint64_t v22 = 0xCCCCCCCCCCCCCCCDLL * ((uint64_t)(v17 - (void)v20) >> 3);
    if (2 * v22 > v21) {
      unint64_t v21 = 2 * v22;
    }
    if (v22 >= 0x333333333333333) {
      unint64_t v23 = 0x666666666666666;
    }
    else {
      unint64_t v23 = v21;
    }
    if (v23)
    {
      if (v23 > 0x666666666666666) {
        std::__throw_bad_array_new_length[abi:nn180100]();
      }
      int v24 = (char *)operator new(40 * v23);
    }
    else
    {
      int v24 = 0;
    }
    int v25 = &v24[8 * (v18 - v20)];
    *(void *)int v25 = v15;
    *((void *)v25 + 1) = v16;
    uint64_t v26 = &v24[40 * v23];
    a5 = v48;
    *((void *)v25 + 2) = a3;
    *((void *)v25 + 3) = v48;
    v25[32] = v13;
    int v19 = v25 + 40;
    if (v18 != v20)
    {
      do
      {
        long long v27 = *(_OWORD *)(v18 - 5);
        long long v28 = *(_OWORD *)(v18 - 3);
        *((void *)v25 - 1) = *(v18 - 1);
        *(_OWORD *)(v25 - 24) = v28;
        *(_OWORD *)(v25 - 40) = v27;
        v25 -= 40;
        v18 -= 5;
      }
      while (v18 != v20);
      uint32_t v18 = (void *)v14[5];
    }
    v14[5] = v25;
    v14[6] = v19;
    v14[7] = v26;
    __src = v47;
    if (v18) {
      operator delete(v18);
    }
  }
  else
  {
    *uint32_t v18 = v15;
    v18[1] = v16;
    v18[2] = a3;
    v18[3] = a5;
    int v19 = v18 + 5;
    *((unsigned char *)v18 + 32) = v13;
  }
  v14[6] = v19;
  std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(a1[6] + 120, *(char **)(a1[6] + 128), __src, &__src[a3], a3);
  std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(a1[6] + 120, *(char **)(a1[6] + 128), a4, &a4[a5], a5);
  *(void *)(*(void *)(a1[5] + 8) + 24) += a5 + a3;
}

size_t ___ZL39nw_http2_stream_make_and_submit_headersP17nw_protocol_http2P12http2_streamP11nw_protocolb_block_invoke_88(size_t result, char *__s)
{
  uint64_t v2 = result;
  if (__s
    && (__n128 result = strlen(__s), result >= 3)
    && *__s == 117
    && __s[1] == 61
    && (char v4 = __s[2], (v4 - 56) >= 0xF8u))
  {
    int v5 = dword_183E23468[(v4 - 48)];
  }
  else
  {
    int v5 = 16;
  }
  *(_DWORD *)(*(void *)(*(void *)(v2 + 32) + 8) + 24) = v5;
  return result;
}

void nw_http2_enqueue_frame_for_stream(uint64_t a1, uint64_t a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  if (((*(unsigned __int16 *)(a1 + 188) | (*(unsigned __int8 *)(a1 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v8 = *(_DWORD *)(a1 + 176);
      int v7 = *(_DWORD *)(a1 + 180);
      int v19 = 136447746;
      int v20 = "nw_http2_enqueue_frame_for_stream";
      __int16 v21 = 2082;
      uint64_t v22 = a1 + 191;
      __int16 v23 = 2080;
      int v24 = " ";
      __int16 v25 = 1024;
      int v26 = v7;
      __int16 v27 = 1024;
      int v28 = v8;
      __int16 v29 = 1024;
      int v30 = v8;
      __int16 v31 = 2048;
      uint64_t v32 = a2;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, frame %p", (uint8_t *)&v19, 0x3Cu);
    }
  }
  if (((*(unsigned __int16 *)(a1 + 188) | (*(unsigned __int8 *)(a1 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v9 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v11 = *(_DWORD *)(a1 + 176);
      int v10 = *(_DWORD *)(a1 + 180);
      int v19 = 136447746;
      int v20 = "nw_http2_set_stream_output_available_pending";
      __int16 v21 = 2082;
      uint64_t v22 = a1 + 191;
      __int16 v23 = 2080;
      int v24 = " ";
      __int16 v25 = 1024;
      int v26 = v10;
      __int16 v27 = 1024;
      int v28 = v11;
      __int16 v29 = 1024;
      int v30 = v11;
      __int16 v31 = 1024;
      LODWORD(v32) = 0;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> called for stream %d, needs output available: %{BOOL}d", (uint8_t *)&v19, 0x38u);
    }
  }
  int v4 = *(_WORD *)(a1 + 188) & 0xFFDF | (*(unsigned __int8 *)(a1 + 190) << 16);
  *(_WORD *)(a1 + 188) &= ~0x20u;
  *(unsigned char *)(a1 + 190) = BYTE2(v4);
  *(void *)(a2 + 16) = 0;
  int v5 = *(void **)(a1 + 24);
  *(void *)(a2 + 24) = v5;
  *int v5 = a2;
  *(void *)(a1 + 24) = a2 + 16;
  if (((*(unsigned __int16 *)(a1 + 188) | (*(unsigned __int8 *)(a1 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v12 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      char v13 = (uint64_t *)(a1 + 16);
      uint64_t v14 = a1 + 191;
      uint64_t v17 = a1 + 176;
      int v15 = *(_DWORD *)(a1 + 176);
      int v16 = *(_DWORD *)(v17 + 4);
      int v19 = 0;
      nw_frame_array_get_frame_count(v13, 0, &v19);
      int v18 = v19;
      int v19 = 136447490;
      int v20 = "nw_http2_enqueue_frame_for_stream";
      __int16 v21 = 2082;
      uint64_t v22 = v14;
      __int16 v23 = 2080;
      int v24 = " ";
      __int16 v25 = 1024;
      int v26 = v16;
      __int16 v27 = 1024;
      int v28 = v15;
      __int16 v29 = 1024;
      int v30 = v18;
      _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream now has %u bytes pending", (uint8_t *)&v19, 0x32u);
    }
  }
}

void std::vector<char>::__insert_with_size[abi:nn180100]<char const*,char const*>(uint64_t a1, char *__dst, char *__src, char *a4, int64_t a5)
{
  if (a5 < 1) {
    return;
  }
  int v10 = *(char **)(a1 + 8);
  uint64_t v9 = *(void *)(a1 + 16);
  if (v9 - (uint64_t)v10 < a5)
  {
    int v11 = *(char **)a1;
    uint64_t v12 = (uint64_t)&v10[a5 - *(void *)a1];
    if (v12 < 0) {
      abort();
    }
    char v13 = (char *)(__dst - v11);
    unint64_t v14 = v9 - (void)v11;
    if (2 * v14 > v12) {
      uint64_t v12 = 2 * v14;
    }
    if (v14 >= 0x3FFFFFFFFFFFFFFFLL) {
      size_t v15 = 0x7FFFFFFFFFFFFFFFLL;
    }
    else {
      size_t v15 = v12;
    }
    if (v15)
    {
      size_t v16 = v15;
      size_t v15 = (size_t)operator new(v15);
    }
    else
    {
      size_t v16 = 0;
    }
    size_t v33 = v15;
    BOOL v34 = &v13[v15];
    memcpy(&v13[v15], __src, a5);
    if (v11 == __dst)
    {
      BOOL v35 = v34;
LABEL_44:
      BOOL v43 = &v34[a5];
      if (v10 != __dst) {
        memmove(v43, __dst, v10 - __dst);
      }
      int v44 = *(char **)a1;
      *(void *)a1 = v35;
      *(void *)(a1 + 8) = &v43[v10 - __dst];
      *(void *)(a1 + 16) = v33 + v16;
      if (v44)
      {
        operator delete(v44);
      }
      return;
    }
    if ((unint64_t)v13 >= 0x20)
    {
      unint64_t v37 = __dst - v11;
      int v36 = __dst;
      BOOL v35 = v34;
      if ((unint64_t)&v11[-v33] >= 0x20)
      {
        int v36 = &__dst[-(v37 & 0xFFFFFFFFFFFFFFE0)];
        uint32_t v38 = __dst - 16;
        uint64_t v39 = (_OWORD *)(v33 + __dst - 16 - v11);
        unint64_t v40 = v37 & 0xFFFFFFFFFFFFFFE0;
        do
        {
          long long v41 = *(_OWORD *)v38;
          *(v39 - 1) = *((_OWORD *)v38 - 1);
          *uint64_t v39 = v41;
          v38 -= 32;
          v39 -= 2;
          v40 -= 32;
        }
        while (v40);
        BOOL v35 = &v34[-(v37 & 0xFFFFFFFFFFFFFFE0)];
        if (v37 == (v37 & 0xFFFFFFFFFFFFFFE0)) {
          goto LABEL_44;
        }
      }
    }
    else
    {
      int v36 = __dst;
      BOOL v35 = v34;
    }
    do
    {
      char v42 = *--v36;
      *--BOOL v35 = v42;
    }
    while (v36 != v11);
    int v10 = *(char **)(a1 + 8);
    goto LABEL_44;
  }
  uint64_t v17 = v10 - __dst;
  if (v10 - __dst >= a5)
  {
    int v18 = &__src[a5];
    int v20 = *(char **)(a1 + 8);
LABEL_17:
    __int16 v21 = &__dst[a5];
    uint64_t v22 = &v20[-a5];
    __int16 v23 = v20;
    if (&v20[-a5] < v10)
    {
      unint64_t v24 = &v10[a5] - v20;
      BOOL v25 = v24 >= 0x20 && (unint64_t)a5 > 0x1F;
      int v26 = &v20[-a5];
      __int16 v23 = v20;
      if (!v25) {
        goto LABEL_54;
      }
      unint64_t v27 = v24 & 0xFFFFFFFFFFFFFFE0;
      int v26 = &v22[v24 & 0xFFFFFFFFFFFFFFE0];
      int v28 = (long long *)(v22 + 16);
      __int16 v29 = v20 + 16;
      unint64_t v30 = v24 & 0xFFFFFFFFFFFFFFE0;
      do
      {
        long long v31 = *v28;
        *(v29 - 1) = *(v28 - 1);
        _OWORD *v29 = v31;
        v28 += 2;
        v29 += 2;
        v30 -= 32;
      }
      while (v30);
      __int16 v23 = &v20[v27];
      if (v24 != v27)
      {
LABEL_54:
        do
        {
          char v32 = *v26++;
          *v23++ = v32;
        }
        while (v26 != v10);
      }
    }
    *(void *)(a1 + 8) = v23;
    if (v20 != v21) {
      memmove(&__dst[a5], __dst, v20 - v21);
    }
    if (v18 != __src)
    {
      memmove(__dst, __src, v18 - __src);
    }
    return;
  }
  int v18 = &__src[v17];
  int64_t v19 = a4 - &__src[v17];
  if (a4 != &__src[v17]) {
    memmove(*(void **)(a1 + 8), &__src[v17], a4 - &__src[v17]);
  }
  int v20 = &v10[v19];
  *(void *)(a1 + 8) = &v10[v19];
  if (v17 >= 1) {
    goto LABEL_17;
  }
}

uint64_t nw_protocol_http2_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  v331[2] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v322 = "nw_protocol_http2_get_input_frames";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v317) = 16;
    LOBYTE(v313) = 0;
    if (!__nwlog_fault(v25, &v317, &v313)) {
      goto LABEL_51;
    }
    if (v317 == 17)
    {
      int v26 = __nwlog_obj();
      os_log_type_t v27 = v317;
      if (!os_log_type_enabled(v26, (os_log_type_t)v317)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null protocol";
      goto LABEL_49;
    }
    if ((_BYTE)v313)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v26 = __nwlog_obj();
      os_log_type_t v27 = v317;
      BOOL v209 = os_log_type_enabled(v26, (os_log_type_t)v317);
      if (backtrace_string)
      {
        if (v209)
        {
          *(_DWORD *)int buf = 136446466;
          id v322 = "nw_protocol_http2_get_input_frames";
          __int16 v323 = 2082;
          os_log_type_t v324 = backtrace_string;
          int v210 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_299:
          _os_log_impl(&dword_1830D4000, v26, v27, v210, buf, 0x16u);
        }
LABEL_300:
        free(backtrace_string);
        goto LABEL_51;
      }
      if (!v209) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v26 = __nwlog_obj();
      os_log_type_t v27 = v317;
      if (!os_log_type_enabled(v26, (os_log_type_t)v317)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_49:
    int v45 = v26;
    os_log_type_t v46 = v27;
LABEL_50:
    _os_log_impl(&dword_1830D4000, v45, v46, v28, buf, 0xCu);
    goto LABEL_51;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    id v322 = "nw_protocol_http2_get_input_frames";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v317) = 16;
    LOBYTE(v313) = 0;
    if (!__nwlog_fault(v25, &v317, &v313)) {
      goto LABEL_51;
    }
    if (v317 == 17)
    {
      int v26 = __nwlog_obj();
      os_log_type_t v27 = v317;
      if (!os_log_type_enabled(v26, (os_log_type_t)v317)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null http2";
      goto LABEL_49;
    }
    if ((_BYTE)v313)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v26 = __nwlog_obj();
      os_log_type_t v27 = v317;
      BOOL v211 = os_log_type_enabled(v26, (os_log_type_t)v317);
      if (backtrace_string)
      {
        if (v211)
        {
          *(_DWORD *)int buf = 136446466;
          id v322 = "nw_protocol_http2_get_input_frames";
          __int16 v323 = 2082;
          os_log_type_t v324 = backtrace_string;
          int v210 = "%{public}s called with null http2, dumping backtrace:%{public}s";
          goto LABEL_299;
        }
        goto LABEL_300;
      }
      if (!v211) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null http2, no backtrace";
    }
    else
    {
      int v26 = __nwlog_obj();
      os_log_type_t v27 = v317;
      if (!os_log_type_enabled(v26, (os_log_type_t)v317)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null http2, backtrace limit exceeded";
    }
    goto LABEL_49;
  }
  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v204 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v205 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447746;
      id v322 = "nw_protocol_http2_get_input_frames";
      __int16 v323 = 2082;
      os_log_type_t v324 = handle + 390;
      __int16 v325 = 2080;
      uint64_t v326 = (uint64_t)" ";
      __int16 v327 = 1024;
      *(_DWORD *)os_log_type_t v328 = v205;
      *(_WORD *)&v328[4] = 1024;
      *(_DWORD *)&v328[6] = a3;
      *(_WORD *)&v328[10] = 1024;
      *(_DWORD *)&v328[12] = a4;
      *(_WORD *)&v328[16] = 1024;
      *(_DWORD *)&v328[18] = a5;
      _os_log_impl(&dword_1830D4000, v204, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called min_bytes: %u, max_bytes: %u, max_frame_count: %u", buf, 0x38u);
    }
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    id v322 = "nw_protocol_http2_get_input_frames";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v317) = 16;
    LOBYTE(v313) = 0;
    if (!__nwlog_fault(v25, &v317, &v313)) {
      goto LABEL_51;
    }
    if (v317 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v26 = gLogObj;
      os_log_type_t v27 = v317;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v317)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null input_protocol";
      goto LABEL_49;
    }
    if (!(_BYTE)v313)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v26 = gLogObj;
      os_log_type_t v27 = v317;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v317)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_49;
    }
    __int16 v29 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    unint64_t v30 = gLogObj;
    os_log_type_t v31 = v317;
    BOOL v32 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v317);
    if (v29)
    {
      if (v32)
      {
        *(_DWORD *)int buf = 136446466;
        id v322 = "nw_protocol_http2_get_input_frames";
        __int16 v323 = 2082;
        os_log_type_t v324 = v29;
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v29);
      goto LABEL_51;
    }
    if (v32)
    {
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v28 = "%{public}s called with null input_protocol, no backtrace";
      int v45 = v30;
      os_log_type_t v46 = v31;
      goto LABEL_50;
    }
LABEL_51:
    if (v25) {
      free(v25);
    }
    return 0;
  }
  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    uint64_t v13 = output_handler_context[4];
    if (v13)
    {
      uint64_t v317 = 0;
      v318 = &v317;
      int v320 = 0;
      uint64_t v319 = 0x2000000000;
      uint64_t v313 = 0;
      v314 = &v313;
      int v316 = 0;
      uint64_t v315 = 0x2000000000;
      if (nw_array_is_empty(*(void *)(v13 + 160)))
      {
        int v237 = a4;
        if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x20000) == 0)
        {
          v241[0] = MEMORY[0x1E4F143A8];
          v241[1] = 0x40000000;
          BOOL v242 = ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_71;
          __int16 v243 = &unk_1E524A7E8;
          os_log_type_t v244 = &v317;
          __int16 v245 = &v313;
          unsigned int v249 = a5;
          int v250 = a4;
          uint64_t v246 = v13;
          int v247 = handle;
          int v248 = a6;
          uint64_t v14 = *(void *)v13;
          do
          {
            if (!v14) {
              break;
            }
            uint64_t v15 = *(void *)(v14 + 32);
            char v16 = ((uint64_t (*)(void *))v242)(v241);
            uint64_t v14 = v15;
          }
          while ((v16 & 1) != 0);
          if (*((_DWORD *)v314 + 6) < a3)
          {
            int v17 = *(unsigned __int16 *)(v13 + 188);
            int v18 = v17 | (*(unsigned __int8 *)(v13 + 190) << 16);
            if ((v17 & 0x1000) == 0)
            {
              if (*((_DWORD *)v318 + 6))
              {
                nw_frame_array_prepend_array((void *)v13, a6, 1);
                a6->tqh_first = 0;
                a6->tqh_last = &a6->tqh_first;
                int v18 = *(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16);
              }
              uint64_t v19 = 0;
              if ((v18 & 0x80000) == 0 && gLogDatapath)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v20 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v22 = *(_DWORD *)(v13 + 176);
                  int v21 = *(_DWORD *)(v13 + 180);
                  *(_DWORD *)int buf = 136447490;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = (const char *)(v13 + 191);
                  __int16 v325 = 2080;
                  uint64_t v326 = (uint64_t)" ";
                  __int16 v327 = 1024;
                  *(_DWORD *)os_log_type_t v328 = v21;
                  *(_WORD *)&v328[4] = 1024;
                  *(_DWORD *)&v328[6] = v22;
                  *(_WORD *)&v328[10] = 1024;
                  *(_DWORD *)&v328[12] = a3;
                  _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> failed to find enough (%u) bytes to return, returning 0 frames", buf, 0x32u);
                }
                uint64_t v19 = 0;
              }
              goto LABEL_289;
            }
          }
LABEL_205:
          if (*((_DWORD *)v318 + 6)) {
            goto LABEL_286;
          }
          BOOL v175 = (*(_WORD *)(v13 + 188) & 0x800) != 0 && v237 == 0;
          BOOL v176 = !v175 && (*(_WORD *)(v13 + 188) & 0x1000) == 0;
          if (v176 || !*(void *)(v13 + 112) || (*(_WORD *)(v13 + 188) & 0x8000) != 0) {
            goto LABEL_286;
          }
          if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v227 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v229 = *(_DWORD *)(v13 + 176);
              int v228 = *(_DWORD *)(v13 + 180);
              *(_DWORD *)int buf = 136447234;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = (const char *)(v13 + 191);
              __int16 v325 = 2080;
              uint64_t v326 = (uint64_t)" ";
              __int16 v327 = 1024;
              *(_DWORD *)os_log_type_t v328 = v228;
              *(_WORD *)&v328[4] = 1024;
              *(_DWORD *)&v328[6] = v229;
              _os_log_impl(&dword_1830D4000, v227, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> no frames to return, adding metadata only frame", buf, 0x2Cu);
            }
          }
          *(_WORD *)(v13 + 188) |= 0x8000u;
          input_uint64_t frame = http2_create_input_frame((uint64_t)handle, v13, 0);
          if (!input_frame)
          {
LABEL_286:
            if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v220 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v222 = *(_DWORD *)(v13 + 176);
                int v221 = *(_DWORD *)(v13 + 180);
                int v223 = *((_DWORD *)v318 + 6);
                int v224 = *((_DWORD *)v314 + 6);
                *(_DWORD *)int buf = 136447746;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = (const char *)(v13 + 191);
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v221;
                *(_WORD *)&v328[4] = 1024;
                *(_DWORD *)&v328[6] = v222;
                *(_WORD *)&v328[10] = 1024;
                *(_DWORD *)&v328[12] = v223;
                *(_WORD *)&v328[16] = 1024;
                *(_DWORD *)&v328[18] = v224;
                _os_log_impl(&dword_1830D4000, v220, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> returning %u frames (%u total bytes)", buf, 0x38u);
              }
            }
            uint64_t v19 = *((unsigned int *)v318 + 6);
            goto LABEL_289;
          }
          uint64_t v178 = input_frame;
          int v179 = *(NSObject **)(v13 + 112);
          int v180 = *(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16);
          if (v179)
          {
            int v181 = (*(_WORD *)(v13 + 188) & 0x1000) != 0 && *(void *)v13 == 0;
            if ((v180 & 0x80000) == 0 && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v233 = gconnectionLogObj;
              BOOL v234 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
              int v179 = *(NSObject **)(v13 + 112);
              if (v234)
              {
                int v236 = *(_DWORD *)(v13 + 176);
                int v235 = *(_DWORD *)(v13 + 180);
                *(_DWORD *)int buf = 136448258;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = (const char *)(v13 + 191);
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v235;
                *(_WORD *)&v328[4] = 1024;
                *(_DWORD *)&v328[6] = v236;
                *(_WORD *)&v328[10] = 2048;
                *(void *)&v328[12] = v179;
                *(_WORD *)&v328[20] = 1024;
                *(_DWORD *)&v328[22] = v236;
                *(_WORD *)&v328[26] = 2048;
                *(void *)&v328[28] = v178;
                __int16 v329 = 1024;
                int v330 = v181;
                _os_log_impl(&dword_1830D4000, v233, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting metadata %p from stream %d on frame %p, complete %u", buf, 0x4Cu);
                int v179 = *(NSObject **)(v13 + 112);
              }
            }
            nw_frame_set_metadata(v178, v179, 1, v181);
            if (v181) {
              char v190 = 0x80;
            }
            else {
              char v190 = 0;
            }
            *(unsigned char *)(v178 + 186) = v190 & 0x80 | *(unsigned char *)(v178 + 186) & 0x7F;
          }
          else if ((v180 & 0x80000) == 0 && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v187 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v189 = *(_DWORD *)(v13 + 176);
              int v188 = *(_DWORD *)(v13 + 180);
              *(_DWORD *)int buf = 136447746;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = (const char *)(v13 + 191);
              __int16 v325 = 2080;
              uint64_t v326 = (uint64_t)" ";
              __int16 v327 = 1024;
              *(_DWORD *)os_log_type_t v328 = v188;
              *(_WORD *)&v328[4] = 1024;
              *(_DWORD *)&v328[6] = v189;
              *(_WORD *)&v328[10] = 1024;
              *(_DWORD *)&v328[12] = v189;
              *(_WORD *)&v328[16] = 2048;
              *(void *)&v328[18] = v178;
              _os_log_impl(&dword_1830D4000, v187, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> stream %d has no metadata to set on frame %p", buf, 0x3Cu);
            }
          }
          *(void *)(v178 + 32) = 0;
          tqh_last = a6->tqh_last;
          *(void *)(v178 + 40) = tqh_last;
          *tqh_last = (nw_frame *)v178;
          a6->tqh_last = (nw_frame **)(v178 + 32);
          uint64_t v192 = *((unsigned int *)v318 + 6) + 1;
          uint64_t v193 = v192 << 31 >> 31;
          *((_DWORD *)v318 + 6) = v192;
          if (v193 == v192 && (v193 & 0x8000000000000000) == 0)
          {
LABEL_284:
            if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              os_log_type_t v230 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v232 = *(_DWORD *)(v13 + 176);
                int v231 = *(_DWORD *)(v13 + 180);
                *(_DWORD *)int buf = 136447234;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = (const char *)(v13 + 191);
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v231;
                *(_WORD *)&v328[4] = 1024;
                *(_DWORD *)&v328[6] = v232;
                _os_log_impl(&dword_1830D4000, v230, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> delivering empty incoming frame", buf, 0x2Cu);
              }
            }
            goto LABEL_286;
          }
          __nwlog_obj();
          uint64_t v194 = *((unsigned int *)v318 + 6);
          *(_DWORD *)int buf = 136446978;
          id v322 = "nw_protocol_http2_get_input_frames";
          __int16 v323 = 2082;
          os_log_type_t v324 = "return_frame_count";
          __int16 v325 = 2048;
          uint64_t v326 = 1;
          __int16 v327 = 2048;
          *(void *)os_log_type_t v328 = v194;
          int v195 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(v305) = 0;
          if (__nwlog_fault(v195, type, &v305))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              uint64_t v196 = __nwlog_obj();
              os_log_type_t v197 = type[0];
              if (os_log_type_enabled(v196, type[0]))
              {
                uint64_t v198 = *((unsigned int *)v318 + 6);
                *(_DWORD *)int buf = 136446978;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "return_frame_count";
                __int16 v325 = 2048;
                uint64_t v326 = 1;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v198;
                uint64_t v199 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_280:
                _os_log_impl(&dword_1830D4000, v196, v197, v199, buf, 0x2Au);
              }
            }
            else if ((_BYTE)v305)
            {
              int v200 = (char *)__nw_create_backtrace_string();
              uint64_t v196 = __nwlog_obj();
              os_log_type_t v197 = type[0];
              BOOL v201 = os_log_type_enabled(v196, type[0]);
              if (v200)
              {
                if (v201)
                {
                  uint64_t v202 = *((unsigned int *)v318 + 6);
                  *(_DWORD *)int buf = 136447234;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = "return_frame_count";
                  __int16 v325 = 2048;
                  uint64_t v326 = 1;
                  __int16 v327 = 2048;
                  *(void *)os_log_type_t v328 = v202;
                  *(_WORD *)&v328[8] = 2082;
                  *(void *)&v328[10] = v200;
                  _os_log_impl(&dword_1830D4000, v196, v197, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v200);
                goto LABEL_281;
              }
              if (v201)
              {
                uint64_t v206 = *((unsigned int *)v318 + 6);
                *(_DWORD *)int buf = 136446978;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "return_frame_count";
                __int16 v325 = 2048;
                uint64_t v326 = 1;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v206;
                uint64_t v199 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                goto LABEL_280;
              }
            }
            else
            {
              uint64_t v196 = __nwlog_obj();
              os_log_type_t v197 = type[0];
              if (os_log_type_enabled(v196, type[0]))
              {
                uint64_t v203 = *((unsigned int *)v318 + 6);
                *(_DWORD *)int buf = 136446978;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "return_frame_count";
                __int16 v325 = 2048;
                uint64_t v326 = 1;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v203;
                uint64_t v199 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                goto LABEL_280;
              }
            }
          }
LABEL_281:
          if (v195) {
            free(v195);
          }
          *((_DWORD *)v318 + 6) = -1;
          goto LABEL_284;
        }
        int v238 = a1;
        uint64_t v239 = MEMORY[0x1E4F143A8];
        unsigned int v47 = a5;
        while (1)
        {
          *(void *)long long type = 0;
          int v310 = type;
          uint64_t v311 = 0x2000000000;
          uint64_t v312 = 0;
          uint64_t v305 = 0;
          os_log_type_t v306 = &v305;
          uint64_t v307 = 0x2000000000;
          char v308 = 0;
          v331[0] = 0;
          v331[1] = 0;
          v304[0] = 0;
          v304[1] = v304;
          v304[2] = 0x2000000000;
          v304[3] = v331;
          v302[0] = 0;
          v302[1] = v302;
          v302[2] = 0x2000000000;
          __int16 v303 = 0;
          uint64_t v298 = 0;
          os_log_type_t v299 = &v298;
          uint64_t v300 = 0x2000000000;
          __int16 v301 = 0;
          uint64_t v294 = 0;
          int v295 = &v294;
          uint64_t v296 = 0x2000000000;
          uint64_t v297 = -1;
          uint64_t v290 = 0;
          os_log_type_t v291 = &v290;
          uint64_t v292 = 0x2000000000;
          uint64_t v293 = 0;
          uint64_t v286 = 0;
          os_log_type_t v287 = &v286;
          uint64_t v288 = 0x2000000000;
          uint64_t v289 = 0;
          v274[0] = v239;
          v274[1] = 0x40000000;
          os_log_type_t v275 = (uint64_t (*)(void *))___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
          id v276 = &unk_1E524A798;
          os_log_type_t v277 = &v305;
          os_log_type_t v278 = v302;
          BOOL v279 = v304;
          nw_endpoint_t v280 = &v294;
          nw_endpoint_t v281 = &v298;
          os_log_type_t v282 = &v290;
          v283 = &v286;
          os_log_type_t v284 = handle;
          uint64_t v285 = v13;
          uint64_t v48 = *(void *)v13;
          do
          {
            if (!v48) {
              break;
            }
            uint64_t v49 = *(void *)(v48 + 32);
            char v50 = v275(v274);
            uint64_t v48 = v49;
          }
          while ((v50 & 1) != 0);
          if (!*((unsigned char *)v306 + 24)) {
            goto LABEL_118;
          }
          unsigned int v51 = 0;
          unsigned int v52 = *((_DWORD *)v291 + 6) + *((unsigned __int16 *)v299 + 12);
          uint64_t v53 = *(void *)v13;
          while (v53)
          {
            int v57 = *(_DWORD *)(v53 + 52);
            if (v57) {
              v57 -= *(_DWORD *)(v53 + 56) + *(_DWORD *)(v53 + 60);
            }
            uint64_t v53 = *(void *)(v53 + 32);
            BOOL v54 = __CFADD__(v51, v57);
            unsigned int v55 = v51 + v57;
            v51 += v57;
            if (v54) {
              unsigned int v56 = -1;
            }
            else {
              unsigned int v56 = v55;
            }
            if (v56 >= v52) {
              goto LABEL_68;
            }
          }
          if (v51 < v52) {
            goto LABEL_118;
          }
LABEL_68:
          *(void *)uint64_t v270 = 0;
          nw_endpoint_t v271 = v270;
          uint64_t v272 = 0x2000000000;
          __int16 v273 = 0;
          __int16 v273 = *((_WORD *)v299 + 12);
          uint64_t v266 = 0;
          BOOL v267 = &v266;
          uint64_t v268 = 0x2000000000;
          uint64_t v269 = 0;
          uint64_t v269 = v291[3];
          if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x80000) == 0
            && gLogDatapath)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v160 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v162 = *(_DWORD *)(v13 + 176);
              int v161 = *(_DWORD *)(v13 + 180);
              uint64_t v163 = v295[3];
              uint64_t v164 = v291[3];
              *(_DWORD *)int buf = 136447746;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = (const char *)(v13 + 191);
              __int16 v325 = 2080;
              uint64_t v326 = (uint64_t)" ";
              __int16 v327 = 1024;
              *(_DWORD *)os_log_type_t v328 = v161;
              *(_WORD *)&v328[4] = 1024;
              *(_DWORD *)&v328[6] = v162;
              *(_WORD *)&v328[10] = 2048;
              *(void *)&v328[12] = v163;
              *(_WORD *)&v328[20] = 2048;
              *(void *)&v328[22] = v164;
              _os_log_impl(&dword_1830D4000, v160, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule type 0x%llx length %llu", buf, 0x40u);
            }
          }
          uint64_t v58 = 0;
          v264[0] = 0;
          v264[1] = v264;
          int v265 = 0;
          v264[2] = 0x2000000000;
          uint64_t v59 = v238;
          if (!v295[3])
          {
            int v60 = (*(unsigned __int8 *)(v13 + 190) >> 3) & 1;
            if (!gLogDatapath) {
              LOBYTE(v60) = 1;
            }
            if (!v287[3])
            {
              if ((v60 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v172 = gconnectionLogObj;
                unsigned int v47 = a5;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v174 = *(_DWORD *)(v13 + 176);
                  int v173 = *(_DWORD *)(v13 + 180);
                  *(_DWORD *)int buf = 136447234;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = (const char *)(v13 + 191);
                  __int16 v325 = 2080;
                  uint64_t v326 = (uint64_t)" ";
                  __int16 v327 = 1024;
                  *(_DWORD *)os_log_type_t v328 = v173;
                  *(_WORD *)&v328[4] = 1024;
                  *(_DWORD *)&v328[6] = v174;
                  _os_log_impl(&dword_1830D4000, v172, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule datagram with zero context ID", buf, 0x2Cu);
                }
              }
              uint64_t v58 = http2_create_input_frame((uint64_t)handle, v13, *((unsigned int *)v291 + 6));
              goto LABEL_78;
            }
            if ((v60 & 1) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v168 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v170 = *(_DWORD *)(v13 + 176);
                int v169 = *(_DWORD *)(v13 + 180);
                uint64_t v171 = v287[3];
                *(_DWORD *)int buf = 136447490;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = (const char *)(v13 + 191);
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v169;
                *(_WORD *)&v328[4] = 1024;
                *(_DWORD *)&v328[6] = v170;
                *(_WORD *)&v328[10] = 2048;
                *(void *)&v328[12] = v171;
                _os_log_impl(&dword_1830D4000, v168, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule datagram non-zero context ID %llu", buf, 0x36u);
              }
              uint64_t v58 = 0;
              unsigned int v47 = a5;
LABEL_78:
              uint64_t v59 = v238;
              goto LABEL_79;
            }
            uint64_t v58 = 0;
          }
LABEL_79:
          v253[0] = MEMORY[0x1E4F143A8];
          v253[1] = 0x40000000;
          int v254 = (uint64_t (*)(void *))___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_68;
          int v255 = &unk_1E524A7C0;
          uint64_t v260 = v13;
          BOOL v261 = v59;
          v256 = v270;
          __int16 v257 = &v266;
          os_log_type_t v258 = v264;
          __int16 v259 = type;
          uint64_t v262 = v58;
          int v263 = handle;
          uint64_t v61 = *(void *)v13;
          do
          {
            if (!v61) {
              break;
            }
            uint64_t v62 = *(void *)(v61 + 32);
            char v63 = v254(v253);
            uint64_t v61 = v62;
          }
          while ((v63 & 1) != 0);
          int v64 = *((void *)v310 + 3);
          if (!v64 || !v267[3]) {
            goto LABEL_111;
          }
          if (*((__int16 *)handle + 194) < 0) {
            goto LABEL_110;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v65 = *((_DWORD *)handle + 92);
          uint64_t v66 = v267[3];
          *(_DWORD *)int buf = 136447234;
          id v322 = "nw_protocol_http2_get_input_frames";
          __int16 v323 = 2082;
          os_log_type_t v324 = handle + 390;
          __int16 v325 = 2080;
          uint64_t v326 = (uint64_t)" ";
          __int16 v327 = 1024;
          *(_DWORD *)os_log_type_t v328 = v65;
          *(_WORD *)&v328[4] = 2048;
          *(void *)&v328[6] = v66;
          int v67 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t v252 = OS_LOG_TYPE_ERROR;
          char v251 = 0;
          if (__nwlog_fault(v67, &v252, &v251))
          {
            if (v252 == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v68 = gconnectionLogObj;
              os_log_type_t v69 = v252;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, v252))
              {
                int v70 = *((_DWORD *)handle + 92);
                uint64_t v71 = v267[3];
                *(_DWORD *)int buf = 136447234;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = handle + 390;
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v70;
                *(_WORD *)&v328[4] = 2048;
                *(void *)&v328[6] = v71;
                int v72 = v68;
                os_log_type_t v73 = v69;
                id v74 = "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu";
LABEL_106:
                _os_log_impl(&dword_1830D4000, v72, v73, v74, buf, 0x30u);
              }
            }
            else if (v251)
            {
              __int16 v75 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v76 = gconnectionLogObj;
              os_log_type_t v77 = v252;
              BOOL v78 = os_log_type_enabled((os_log_t)gconnectionLogObj, v252);
              if (!v75)
              {
                unsigned int v47 = a5;
                if (!v78) {
                  goto LABEL_107;
                }
                int v85 = *((_DWORD *)handle + 92);
                uint64_t v86 = v267[3];
                *(_DWORD *)int buf = 136447234;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = handle + 390;
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v85;
                *(_WORD *)&v328[4] = 2048;
                *(void *)&v328[6] = v86;
                int v72 = v76;
                os_log_type_t v73 = v77;
                id v74 = "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu, no backtrace";
                goto LABEL_106;
              }
              if (v78)
              {
                int v79 = *((_DWORD *)handle + 92);
                uint64_t v80 = v267[3];
                *(_DWORD *)int buf = 136447490;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = handle + 390;
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v79;
                *(_WORD *)&v328[4] = 2048;
                *(void *)&v328[6] = v80;
                *(_WORD *)&v328[14] = 2082;
                *(void *)&v328[16] = v75;
                _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu, dumping backtrace:%{public}s", buf, 0x3Au);
              }
              free(v75);
              unsigned int v47 = a5;
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v81 = gconnectionLogObj;
              os_log_type_t v82 = v252;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, v252))
              {
                int v83 = *((_DWORD *)handle + 92);
                uint64_t v84 = v267[3];
                *(_DWORD *)int buf = 136447234;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = handle + 390;
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v83;
                *(_WORD *)&v328[4] = 2048;
                *(void *)&v328[6] = v84;
                int v72 = v81;
                os_log_type_t v73 = v82;
                id v74 = "%{public}s %{public}s%s<i%u> Read capsule data, but still have remaining length %llu, backtrace limit exceeded";
                goto LABEL_106;
              }
            }
          }
LABEL_107:
          if (v67) {
            free(v67);
          }
          int v64 = *((void *)v310 + 3);
          if (v64)
          {
LABEL_110:
            dispatch_release(v64);
            *((void *)v310 + 3) = 0;
          }
LABEL_111:
          _Block_object_dispose(v264, 8);
          _Block_object_dispose(&v266, 8);
          _Block_object_dispose(v270, 8);
          if (v58)
          {
            nw_frame_set_metadata(v58, 0, 1, 1);
            *(void *)(v58 + 32) = 0;
            BOOL v87 = a6->tqh_last;
            *(void *)(v58 + 40) = v87;
            char *v87 = (nw_frame *)v58;
            a6->tqh_last = (nw_frame **)(v58 + 32);
            uint64_t v88 = *((unsigned int *)v318 + 6) + 1;
            uint64_t v89 = v88 << 31 >> 31;
            *((_DWORD *)v318 + 6) = v88;
            if (v89 != v88 || v89 < 0)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v90 = *((unsigned int *)v318 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "return_frame_count";
              __int16 v325 = 2048;
              uint64_t v326 = 1;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v90;
              unint64_t v91 = (char *)_os_log_send_and_compose_impl();
              v270[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v266) = 0;
              if (!__nwlog_fault(v91, v270, &v266)) {
                goto LABEL_157;
              }
              if (v270[0] != OS_LOG_TYPE_FAULT)
              {
                if ((_BYTE)v266)
                {
                  int v116 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v117 = gLogObj;
                  os_log_type_t v118 = v270[0];
                  BOOL v119 = os_log_type_enabled((os_log_t)gLogObj, v270[0]);
                  if (v116)
                  {
                    if (v119)
                    {
                      uint64_t v120 = *((unsigned int *)v318 + 6);
                      *(_DWORD *)int buf = 136447234;
                      id v322 = "nw_protocol_http2_get_input_frames";
                      __int16 v323 = 2082;
                      os_log_type_t v324 = "return_frame_count";
                      __int16 v325 = 2048;
                      uint64_t v326 = 1;
                      __int16 v327 = 2048;
                      *(void *)os_log_type_t v328 = v120;
                      *(_WORD *)&v328[8] = 2082;
                      *(void *)&v328[10] = v116;
                      _os_log_impl(&dword_1830D4000, v117, v118, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                    }
                    free(v116);
                    unsigned int v47 = a5;
                    goto LABEL_157;
                  }
                  unsigned int v47 = a5;
                  if (!v119) {
                    goto LABEL_157;
                  }
                  uint64_t v133 = *((unsigned int *)v318 + 6);
                  *(_DWORD *)int buf = 136446978;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = "return_frame_count";
                  __int16 v325 = 2048;
                  uint64_t v326 = 1;
                  __int16 v327 = 2048;
                  *(void *)os_log_type_t v328 = v133;
                  uint64_t v95 = v117;
                  os_log_type_t v96 = v118;
                  uint64_t v97 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                }
                else
                {
                  int v124 = __nwlog_obj();
                  os_log_type_t v125 = v270[0];
                  if (!os_log_type_enabled(v124, v270[0])) {
                    goto LABEL_157;
                  }
                  uint64_t v126 = *((unsigned int *)v318 + 6);
                  *(_DWORD *)int buf = 136446978;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = "return_frame_count";
                  __int16 v325 = 2048;
                  uint64_t v326 = 1;
                  __int16 v327 = 2048;
                  *(void *)os_log_type_t v328 = v126;
                  uint64_t v95 = v124;
                  os_log_type_t v96 = v125;
                  uint64_t v97 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                }
LABEL_156:
                _os_log_impl(&dword_1830D4000, v95, v96, v97, buf, 0x2Au);
                goto LABEL_157;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v92 = gLogObj;
              os_log_type_t v93 = v270[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v270[0]))
              {
                uint64_t v94 = *((unsigned int *)v318 + 6);
                *(_DWORD *)int buf = 136446978;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "return_frame_count";
                __int16 v325 = 2048;
                uint64_t v326 = 1;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v94;
                uint64_t v95 = v92;
                os_log_type_t v96 = v93;
                uint64_t v97 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_156;
              }
LABEL_157:
              if (v91) {
                free(v91);
              }
              *((_DWORD *)v318 + 6) = -1;
            }
            uint64_t v134 = *((unsigned int *)v314 + 6);
            uint64_t v135 = v291[3];
            BOOL v54 = __CFADD__(v134, v135);
            unint64_t v136 = v134 + v135;
            *((_DWORD *)v314 + 6) = v136;
            if (v54 || HIDWORD(v136))
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v137 = v291[3];
              uint64_t v138 = *((unsigned int *)v314 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "total_bytes";
              __int16 v325 = 2048;
              uint64_t v326 = v137;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v138;
              uint64_t v139 = (char *)_os_log_send_and_compose_impl();
              v270[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v266) = 0;
              if (!__nwlog_fault(v139, v270, &v266)) {
                goto LABEL_176;
              }
              if (v270[0] != OS_LOG_TYPE_FAULT)
              {
                if ((_BYTE)v266)
                {
                  int v147 = (char *)__nw_create_backtrace_string();
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  int v148 = gLogObj;
                  os_log_type_t v149 = v270[0];
                  BOOL v150 = os_log_type_enabled((os_log_t)gLogObj, v270[0]);
                  if (v147)
                  {
                    if (v150)
                    {
                      uint64_t v151 = v291[3];
                      uint64_t v152 = *((unsigned int *)v314 + 6);
                      *(_DWORD *)int buf = 136447234;
                      id v322 = "nw_protocol_http2_get_input_frames";
                      __int16 v323 = 2082;
                      os_log_type_t v324 = "total_bytes";
                      __int16 v325 = 2048;
                      uint64_t v326 = v151;
                      __int16 v327 = 2048;
                      *(void *)os_log_type_t v328 = v152;
                      *(_WORD *)&v328[8] = 2082;
                      *(void *)&v328[10] = v147;
                      _os_log_impl(&dword_1830D4000, v148, v149, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                    }
                    free(v147);
                    goto LABEL_176;
                  }
                  if (!v150) {
                    goto LABEL_176;
                  }
                  uint64_t v157 = v291[3];
                  uint64_t v158 = *((unsigned int *)v314 + 6);
                  *(_DWORD *)int buf = 136446978;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = "total_bytes";
                  __int16 v325 = 2048;
                  uint64_t v326 = v157;
                  __int16 v327 = 2048;
                  *(void *)os_log_type_t v328 = v158;
                  char v144 = v148;
                  os_log_type_t v145 = v149;
                  unsigned int v146 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
                }
                else
                {
                  int v153 = __nwlog_obj();
                  os_log_type_t v154 = v270[0];
                  if (!os_log_type_enabled(v153, v270[0])) {
                    goto LABEL_176;
                  }
                  uint64_t v155 = v291[3];
                  uint64_t v156 = *((unsigned int *)v314 + 6);
                  *(_DWORD *)int buf = 136446978;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = "total_bytes";
                  __int16 v325 = 2048;
                  uint64_t v326 = v155;
                  __int16 v327 = 2048;
                  *(void *)os_log_type_t v328 = v156;
                  char v144 = v153;
                  os_log_type_t v145 = v154;
                  unsigned int v146 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
                }
LABEL_175:
                _os_log_impl(&dword_1830D4000, v144, v145, v146, buf, 0x2Au);
                goto LABEL_176;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v140 = gLogObj;
              os_log_type_t v141 = v270[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v270[0]))
              {
                uint64_t v142 = v291[3];
                uint64_t v143 = *((unsigned int *)v314 + 6);
                *(_DWORD *)int buf = 136446978;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "total_bytes";
                __int16 v325 = 2048;
                uint64_t v326 = v142;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v143;
                char v144 = v140;
                os_log_type_t v145 = v141;
                unsigned int v146 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_175;
              }
LABEL_176:
              if (v139) {
                free(v139);
              }
              *((_DWORD *)v314 + 6) = -1;
            }
            char v128 = 0;
            if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x80000) == 0
              && gLogDatapath)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              BOOL v165 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v167 = *(_DWORD *)(v13 + 176);
                int v166 = *(_DWORD *)(v13 + 180);
                *(_DWORD *)int buf = 136447234;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = (const char *)(v13 + 191);
                __int16 v325 = 2080;
                uint64_t v326 = (uint64_t)" ";
                __int16 v327 = 1024;
                *(_DWORD *)os_log_type_t v328 = v166;
                *(_WORD *)&v328[4] = 1024;
                *(_DWORD *)&v328[6] = v167;
                _os_log_impl(&dword_1830D4000, v165, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving datagram capsule", buf, 0x2Cu);
              }
              char v128 = 0;
            }
            goto LABEL_181;
          }
LABEL_118:
          if (!*((void *)v310 + 3)) {
            goto LABEL_153;
          }
          uint64_t v98 = http2_create_input_frame((uint64_t)handle, v13, 0);
          metadata_for_capsule = nw_http_create_metadata_for_capsule(v295[3], *((void **)v310 + 3));
          nw_frame_set_metadata(v98, metadata_for_capsule, 1, 1);
          if (metadata_for_capsule) {
            os_release(metadata_for_capsule);
          }
          *(void *)(v98 + 32) = 0;
          BOOL v100 = a6->tqh_last;
          *(void *)(v98 + 40) = v100;
          const char *v100 = (nw_frame *)v98;
          a6->tqh_last = (nw_frame **)(v98 + 32);
          uint64_t v101 = *((unsigned int *)v318 + 6) + 1;
          uint64_t v102 = v101 << 31 >> 31;
          *((_DWORD *)v318 + 6) = v101;
          if (v102 != v101 || v102 < 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v103 = *((unsigned int *)v318 + 6);
            *(_DWORD *)int buf = 136446978;
            id v322 = "nw_protocol_http2_get_input_frames";
            __int16 v323 = 2082;
            os_log_type_t v324 = "return_frame_count";
            __int16 v325 = 2048;
            uint64_t v326 = 1;
            __int16 v327 = 2048;
            *(void *)os_log_type_t v328 = v103;
            uint64_t v104 = (char *)_os_log_send_and_compose_impl();
            v270[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v266) = 0;
            if (!__nwlog_fault(v104, v270, &v266)) {
              goto LABEL_144;
            }
            if (v270[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v105 = gLogObj;
              os_log_type_t v106 = v270[0];
              if (os_log_type_enabled((os_log_t)gLogObj, v270[0]))
              {
                uint64_t v107 = *((unsigned int *)v318 + 6);
                *(_DWORD *)int buf = 136446978;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "return_frame_count";
                __int16 v325 = 2048;
                uint64_t v326 = 1;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v107;
                uint64_t v108 = v105;
                os_log_type_t v109 = v106;
                int v110 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
                goto LABEL_143;
              }
              goto LABEL_144;
            }
            if ((_BYTE)v266)
            {
              int v111 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v112 = gLogObj;
              os_log_type_t v113 = v270[0];
              BOOL v114 = os_log_type_enabled((os_log_t)gLogObj, v270[0]);
              if (v111)
              {
                if (v114)
                {
                  uint64_t v115 = *((unsigned int *)v318 + 6);
                  *(_DWORD *)int buf = 136447234;
                  id v322 = "nw_protocol_http2_get_input_frames";
                  __int16 v323 = 2082;
                  os_log_type_t v324 = "return_frame_count";
                  __int16 v325 = 2048;
                  uint64_t v326 = 1;
                  __int16 v327 = 2048;
                  *(void *)os_log_type_t v328 = v115;
                  *(_WORD *)&v328[8] = 2082;
                  *(void *)&v328[10] = v111;
                  _os_log_impl(&dword_1830D4000, v112, v113, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
                }
                free(v111);
                unsigned int v47 = a5;
                goto LABEL_144;
              }
              unsigned int v47 = a5;
              if (!v114)
              {
LABEL_144:
                if (v104) {
                  free(v104);
                }
                *((_DWORD *)v318 + 6) = -1;
                goto LABEL_147;
              }
              uint64_t v127 = *((unsigned int *)v318 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "return_frame_count";
              __int16 v325 = 2048;
              uint64_t v326 = 1;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v127;
              uint64_t v108 = v112;
              os_log_type_t v109 = v113;
              int v110 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v121 = gLogObj;
              os_log_type_t v122 = v270[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, v270[0])) {
                goto LABEL_144;
              }
              uint64_t v123 = *((unsigned int *)v318 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "return_frame_count";
              __int16 v325 = 2048;
              uint64_t v326 = 1;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v123;
              uint64_t v108 = v121;
              os_log_type_t v109 = v122;
              int v110 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            }
LABEL_143:
            _os_log_impl(&dword_1830D4000, v108, v109, v110, buf, 0x2Au);
            goto LABEL_144;
          }
LABEL_147:
          char v128 = 1;
          if (((*(unsigned __int16 *)(v13 + 188) | (*(unsigned __int8 *)(v13 + 190) << 16)) & 0x80000) != 0
            || !gLogDatapath)
          {
            goto LABEL_181;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v129 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v131 = *(_DWORD *)(v13 + 176);
            int v130 = *(_DWORD *)(v13 + 180);
            uint64_t v132 = v295[3];
            *(_DWORD *)int buf = 136447490;
            id v322 = "nw_protocol_http2_get_input_frames";
            __int16 v323 = 2082;
            os_log_type_t v324 = (const char *)(v13 + 191);
            __int16 v325 = 2080;
            uint64_t v326 = (uint64_t)" ";
            __int16 v327 = 1024;
            *(_DWORD *)os_log_type_t v328 = v130;
            *(_WORD *)&v328[4] = 1024;
            *(_DWORD *)&v328[6] = v131;
            *(_WORD *)&v328[10] = 2048;
            *(void *)&v328[12] = v132;
            _os_log_impl(&dword_1830D4000, v129, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> Receiving capsule type 0x%llx", buf, 0x36u);
          }
LABEL_153:
          char v128 = 1;
LABEL_181:
          os_log_type_t v159 = *((void *)v310 + 3);
          if (v159)
          {
            dispatch_release(v159);
            *((void *)v310 + 3) = 0;
          }
          _Block_object_dispose(&v286, 8);
          _Block_object_dispose(&v290, 8);
          _Block_object_dispose(&v294, 8);
          _Block_object_dispose(&v298, 8);
          _Block_object_dispose(v302, 8);
          _Block_object_dispose(v304, 8);
          _Block_object_dispose(&v305, 8);
          _Block_object_dispose(type, 8);
          if ((v128 & 1) != 0 || *((_DWORD *)v318 + 6) >= v47) {
            goto LABEL_205;
          }
        }
      }
      if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v216 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v217 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          id v322 = "nw_protocol_http2_get_input_frames";
          __int16 v323 = 2082;
          os_log_type_t v324 = handle + 390;
          __int16 v325 = 2080;
          uint64_t v326 = (uint64_t)" ";
          __int16 v327 = 1024;
          *(_DWORD *)os_log_type_t v328 = v217;
          _os_log_impl(&dword_1830D4000, v216, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> adding informational response", buf, 0x26u);
        }
      }
      size_t v33 = nw_array_remove_object_at_index(*(void *)(v13 + 160), 0);
      uint64_t v34 = http2_create_input_frame((uint64_t)handle, v13, 0);
      if (v34)
      {
        uint64_t v35 = v34;
        nw_frame_set_metadata(v34, v33, 1, 1);
        *(void *)(v35 + 32) = 0;
        int v36 = a6->tqh_last;
        *(void *)(v35 + 40) = v36;
        *int v36 = (nw_frame *)v35;
        a6->tqh_last = (nw_frame **)(v35 + 32);
        uint64_t v37 = *((unsigned int *)v318 + 6) + 1;
        uint64_t v38 = v37 << 31 >> 31;
        *((_DWORD *)v318 + 6) = v37;
        if (v38 == v37 && (v38 & 0x8000000000000000) == 0) {
          goto LABEL_236;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v39 = *((unsigned int *)v318 + 6);
        *(_DWORD *)int buf = 136446978;
        id v322 = "nw_protocol_http2_get_input_frames";
        __int16 v323 = 2082;
        os_log_type_t v324 = "return_frame_count";
        __int16 v325 = 2048;
        uint64_t v326 = 1;
        __int16 v327 = 2048;
        *(void *)os_log_type_t v328 = v39;
        unint64_t v40 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v305) = 0;
        if (__nwlog_fault(v40, type, &v305))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            long long v41 = gLogObj;
            os_log_type_t v42 = type[0];
            if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
            {
              uint64_t v43 = *((unsigned int *)v318 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "return_frame_count";
              __int16 v325 = 2048;
              uint64_t v326 = 1;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v43;
              int v44 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_232:
              _os_log_impl(&dword_1830D4000, v41, v42, v44, buf, 0x2Au);
            }
          }
          else if ((_BYTE)v305)
          {
            int v182 = (char *)__nw_create_backtrace_string();
            long long v41 = __nwlog_obj();
            os_log_type_t v42 = type[0];
            BOOL v183 = os_log_type_enabled(v41, type[0]);
            if (v182)
            {
              if (v183)
              {
                uint64_t v184 = *((unsigned int *)v318 + 6);
                *(_DWORD *)int buf = 136447234;
                id v322 = "nw_protocol_http2_get_input_frames";
                __int16 v323 = 2082;
                os_log_type_t v324 = "return_frame_count";
                __int16 v325 = 2048;
                uint64_t v326 = 1;
                __int16 v327 = 2048;
                *(void *)os_log_type_t v328 = v184;
                *(_WORD *)&v328[8] = 2082;
                *(void *)&v328[10] = v182;
                _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
              }
              free(v182);
              goto LABEL_233;
            }
            if (v183)
            {
              uint64_t v186 = *((unsigned int *)v318 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "return_frame_count";
              __int16 v325 = 2048;
              uint64_t v326 = 1;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v186;
              int v44 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
              goto LABEL_232;
            }
          }
          else
          {
            long long v41 = __nwlog_obj();
            os_log_type_t v42 = type[0];
            if (os_log_type_enabled(v41, type[0]))
            {
              uint64_t v185 = *((unsigned int *)v318 + 6);
              *(_DWORD *)int buf = 136446978;
              id v322 = "nw_protocol_http2_get_input_frames";
              __int16 v323 = 2082;
              os_log_type_t v324 = "return_frame_count";
              __int16 v325 = 2048;
              uint64_t v326 = 1;
              __int16 v327 = 2048;
              *(void *)os_log_type_t v328 = v185;
              int v44 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
              goto LABEL_232;
            }
          }
        }
LABEL_233:
        if (v40) {
          free(v40);
        }
        *((_DWORD *)v318 + 6) = -1;
LABEL_236:
        if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v218 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v219 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            id v322 = "nw_protocol_http2_get_input_frames";
            __int16 v323 = 2082;
            os_log_type_t v324 = handle + 390;
            __int16 v325 = 2080;
            uint64_t v326 = (uint64_t)" ";
            __int16 v327 = 1024;
            *(_DWORD *)os_log_type_t v328 = v219;
            _os_log_impl(&dword_1830D4000, v218, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> delivering empty incoming frame", buf, 0x26u);
          }
        }
        uint64_t v19 = *((unsigned int *)v318 + 6);
        if (!v33) {
          goto LABEL_289;
        }
        goto LABEL_239;
      }
      __nwlog_obj();
      *(_DWORD *)int buf = 136446210;
      id v322 = "nw_protocol_http2_get_input_frames";
      int v212 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v305) = 0;
      if (__nwlog_fault(v212, type, &v305))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          int v213 = __nwlog_obj();
          os_log_type_t v214 = type[0];
          if (!os_log_type_enabled(v213, type[0])) {
            goto LABEL_335;
          }
          *(_DWORD *)int buf = 136446210;
          id v322 = "nw_protocol_http2_get_input_frames";
          int v215 = "%{public}s called with null empty_frame";
LABEL_334:
          _os_log_impl(&dword_1830D4000, v213, v214, v215, buf, 0xCu);
          goto LABEL_335;
        }
        if (!(_BYTE)v305)
        {
          int v213 = __nwlog_obj();
          os_log_type_t v214 = type[0];
          if (!os_log_type_enabled(v213, type[0])) {
            goto LABEL_335;
          }
          *(_DWORD *)int buf = 136446210;
          id v322 = "nw_protocol_http2_get_input_frames";
          int v215 = "%{public}s called with null empty_frame, backtrace limit exceeded";
          goto LABEL_334;
        }
        int v225 = (char *)__nw_create_backtrace_string();
        int v213 = __nwlog_obj();
        os_log_type_t v214 = type[0];
        BOOL v226 = os_log_type_enabled(v213, type[0]);
        if (!v225)
        {
          if (!v226) {
            goto LABEL_335;
          }
          *(_DWORD *)int buf = 136446210;
          id v322 = "nw_protocol_http2_get_input_frames";
          int v215 = "%{public}s called with null empty_frame, no backtrace";
          goto LABEL_334;
        }
        if (v226)
        {
          *(_DWORD *)int buf = 136446466;
          id v322 = "nw_protocol_http2_get_input_frames";
          __int16 v323 = 2082;
          os_log_type_t v324 = v225;
          _os_log_impl(&dword_1830D4000, v213, v214, "%{public}s called with null empty_frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v225);
      }
LABEL_335:
      if (v212) {
        free(v212);
      }
      uint64_t v19 = 0;
      if (!v33) {
        goto LABEL_289;
      }
LABEL_239:
      os_release(v33);
LABEL_289:
      _Block_object_dispose(&v313, 8);
      _Block_object_dispose(&v317, 8);
      return v19;
    }
  }
  if (*((__int16 *)handle + 194) < 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  __int16 v23 = gconnectionLogObj;
  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
    return 0;
  }
  int v24 = *((_DWORD *)handle + 92);
  *(_DWORD *)int buf = 136447490;
  id v322 = "nw_protocol_http2_get_input_frames";
  __int16 v323 = 2082;
  os_log_type_t v324 = handle + 390;
  __int16 v325 = 2080;
  uint64_t v326 = (uint64_t)" ";
  __int16 v327 = 1024;
  *(_DWORD *)os_log_type_t v328 = v24;
  *(_WORD *)&v328[4] = 1042;
  *(_DWORD *)&v328[6] = 16;
  *(_WORD *)&v328[10] = 2098;
  *(void *)&v328[12] = a2;
  _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> can't find hash table entry for %{public,uuid_t}.16P", buf, 0x36u);
  return 0;
}

BOOL ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v65 = *MEMORY[0x1E4F143B8];
  unsigned int v54 = 0;
  int v4 = (const void *)nw_frame_unclaimed_bytes(a2, &v54);
  if (v4)
  {
    if (*(unsigned char *)(*(void *)(a1[4] + 8) + 24)) {
      return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
    }
    uint64_t v8 = *(unsigned __int16 *)(*(void *)(a1[5] + 8) + 24);
    if (16 - v8 >= (unint64_t)v54) {
      size_t v9 = v54;
    }
    else {
      size_t v9 = 16 - v8;
    }
    memcpy((void *)(*(void *)(*(void *)(a1[6] + 8) + 24) + v8), v4, v9);
    *(_WORD *)(*(void *)(a1[5] + 8) + 24) += v9;
    int v10 = *(_DWORD **)(*(void *)(a1[6] + 8) + 24);
    if (v10)
    {
      uint64_t v11 = *(unsigned __int16 *)(*(void *)(a1[5] + 8) + 24);
      if (!*(_WORD *)(*(void *)(a1[5] + 8) + 24)) {
        return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
      }
      unint64_t v12 = *(unsigned __int8 *)v10;
      if (v12 > 0x3F)
      {
        unsigned int v19 = v12 >> 6;
        if (v19 == 2)
        {
          if (v11 < 4) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v12 = bswap32(*v10 & 0xFFFFFF7F);
          unsigned int v13 = 4;
        }
        else if (v19 == 1)
        {
          if (v11 < 2) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v12 = bswap32(*(_WORD *)v10 & 0xFFBF) >> 16;
          unsigned int v13 = 2;
        }
        else
        {
          if (v11 < 8) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v12 = bswap64(*(void *)v10 & 0xFFFFFFFFFFFFFF3FLL);
          unsigned int v13 = 8;
        }
      }
      else
      {
        unsigned int v13 = 1;
      }
      *(void *)(*(void *)(a1[7] + 8) + 24) = v12;
      *(_WORD *)(*(void *)(a1[8] + 8) + 24) = v13;
      unint64_t v14 = v11 - v13;
      if (!v14) {
        return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
      }
      uint64_t v15 = (_DWORD *)((char *)v10 + v13);
      unint64_t v16 = *(unsigned __int8 *)v15;
      if (v16 > 0x3F)
      {
        unsigned int v20 = v16 >> 6;
        if (v20 == 2)
        {
          if (v14 < 4) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v16 = bswap32(*v15 & 0xFFFFFF7F);
          unsigned int v17 = 4;
        }
        else if (v20 == 1)
        {
          if (v14 < 2) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v16 = bswap32(*(_WORD *)v15 & 0xFFBF) >> 16;
          unsigned int v17 = 2;
        }
        else
        {
          if (v14 < 8) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v16 = bswap64(*(void *)v15 & 0xFFFFFFFFFFFFFF3FLL);
          unsigned int v17 = 8;
        }
      }
      else
      {
        unsigned int v17 = 1;
      }
      *(void *)(*(void *)(a1[9] + 8) + 24) = v16;
      *(_WORD *)(*(void *)(a1[8] + 8) + 24) += v17;
      if (*(void *)(*(void *)(a1[7] + 8) + 24)) {
        goto LABEL_17;
      }
      uint64_t v21 = v17;
      if (v14 == v17) {
        return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
      }
      unint64_t v22 = *((unsigned __int8 *)v15 + v17);
      if (v22 > 0x3F)
      {
        unint64_t v34 = v14 - v21;
        unsigned int v35 = v22 >> 6;
        if (v35 == 2)
        {
          if (v34 < 4) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v22 = bswap32(*(_DWORD *)((char *)v15 + v21) & 0xFFFFFF7F);
          unsigned int v23 = 4;
        }
        else if (v35 == 1)
        {
          if (v34 < 2) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v22 = bswap32(*(_WORD *)((unsigned char *)v15 + v21) & 0xFFBF) >> 16;
          unsigned int v23 = 2;
        }
        else
        {
          if (v34 < 8) {
            return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
          }
          unint64_t v22 = bswap64(*(void *)((unsigned char *)v15 + v21) & 0xFFFFFFFFFFFFFF3FLL);
          unsigned int v23 = 8;
        }
      }
      else
      {
        unsigned int v23 = 1;
      }
      *(void *)(*(void *)(a1[10] + 8) + 24) = v22;
      *(_WORD *)(*(void *)(a1[8] + 8) + 24) += v23;
      uint64_t v24 = a1[11];
      if ((!v24 || (*(__int16 *)(v24 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        unsigned int v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v48 = a1[11];
          uint64_t v49 = "";
          char v50 = (const char *)(v48 + 390);
          BOOL v51 = v48 == 0;
          if (!v48) {
            char v50 = "";
          }
          int v52 = *(_DWORD *)(v48 + 368);
          if (!v51) {
            uint64_t v49 = " ";
          }
          uint64_t v53 = *(void *)(*(void *)(a1[9] + 8) + 24);
          *(_DWORD *)int buf = 136447490;
          uint64_t v58 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v59 = 2082;
          int v60 = v50;
          __int16 v61 = 2080;
          uint64_t v62 = v49;
          __int16 v63 = 1024;
          *(_DWORD *)int v64 = v52;
          *(_WORD *)&v64[4] = 2048;
          *(void *)&v64[6] = v53;
          *(_WORD *)&v64[14] = 1024;
          *(_DWORD *)&v64[16] = v23;
          _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> Receiving capsule length %llu, adjusting by %u", buf, 0x36u);
        }
      }
      uint64_t v25 = *(void *)(a1[9] + 8);
      unint64_t v26 = *(void *)(v25 + 24);
      os_log_type_t v27 = (const char *)v23;
      *(void *)(v25 + 24) = v26 - v23;
      if (v26 >= v23)
      {
LABEL_17:
        uint64_t v5 = 0;
        *(_WORD *)(*(void *)(a1[5] + 8) + 24) = 0;
        *(unsigned char *)(*(void *)(a1[4] + 8) + 24) = 1;
        return v5;
      }
      __nwlog_obj();
      uint64_t v28 = *(void *)(*(void *)(a1[9] + 8) + 24);
      *(_DWORD *)int buf = 136446978;
      uint64_t v58 = "nw_protocol_http2_get_input_frames_block_invoke";
      __int16 v59 = 2082;
      int v60 = "capsule_length";
      __int16 v61 = 2048;
      uint64_t v62 = (const char *)v23;
      __int16 v63 = 2048;
      *(void *)int v64 = v28;
      __int16 v29 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v55 = 0;
      if (__nwlog_fault(v29, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          unint64_t v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          if (os_log_type_enabled(v30, type))
          {
            uint64_t v32 = *(void *)(*(void *)(a1[9] + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            uint64_t v58 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v59 = 2082;
            int v60 = "capsule_length";
            __int16 v61 = 2048;
            uint64_t v62 = v27;
            __int16 v63 = 2048;
            *(void *)int v64 = v32;
            size_t v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_65:
            _os_log_impl(&dword_1830D4000, v30, v31, v33, buf, 0x2Au);
          }
        }
        else if (v55)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          unint64_t v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          BOOL v37 = os_log_type_enabled(v30, type);
          if (backtrace_string)
          {
            if (v37)
            {
              uint64_t v38 = *(void *)(*(void *)(a1[9] + 8) + 24);
              *(_DWORD *)int buf = 136447234;
              uint64_t v58 = "nw_protocol_http2_get_input_frames_block_invoke";
              __int16 v59 = 2082;
              int v60 = "capsule_length";
              __int16 v61 = 2048;
              uint64_t v62 = v27;
              __int16 v63 = 2048;
              *(void *)int v64 = v38;
              *(_WORD *)&v64[8] = 2082;
              *(void *)&v64[10] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(backtrace_string);
            goto LABEL_66;
          }
          if (v37)
          {
            uint64_t v40 = *(void *)(*(void *)(a1[9] + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            uint64_t v58 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v59 = 2082;
            int v60 = "capsule_length";
            __int16 v61 = 2048;
            uint64_t v62 = v27;
            __int16 v63 = 2048;
            *(void *)int v64 = v40;
            size_t v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
            goto LABEL_65;
          }
        }
        else
        {
          unint64_t v30 = __nwlog_obj();
          os_log_type_t v31 = type;
          if (os_log_type_enabled(v30, type))
          {
            uint64_t v39 = *(void *)(*(void *)(a1[9] + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            uint64_t v58 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v59 = 2082;
            int v60 = "capsule_length";
            __int16 v61 = 2048;
            uint64_t v62 = v27;
            __int16 v63 = 2048;
            *(void *)int v64 = v39;
            size_t v33 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
            goto LABEL_65;
          }
        }
      }
LABEL_66:
      if (v29) {
        free(v29);
      }
      *(void *)(*(void *)(a1[9] + 8) + 24) = 0;
      goto LABEL_17;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v58 = "_http_vle_decode";
    long long v41 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v55 = 0;
    if (__nwlog_fault(v41, &type, &v55))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_83;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v58 = "_http_vle_decode";
        int v44 = "%{public}s called with null *buffer";
        goto LABEL_82;
      }
      if (!v55)
      {
        os_log_type_t v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (!os_log_type_enabled(v42, type)) {
          goto LABEL_83;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v58 = "_http_vle_decode";
        int v44 = "%{public}s called with null *buffer, backtrace limit exceeded";
        goto LABEL_82;
      }
      int v45 = (char *)__nw_create_backtrace_string();
      os_log_type_t v42 = __nwlog_obj();
      os_log_type_t v43 = type;
      BOOL v46 = os_log_type_enabled(v42, type);
      if (v45)
      {
        if (v46)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v58 = "_http_vle_decode";
          __int16 v59 = 2082;
          int v60 = v45;
          _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s called with null *buffer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v45);
        goto LABEL_83;
      }
      if (v46)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v58 = "_http_vle_decode";
        int v44 = "%{public}s called with null *buffer, no backtrace";
LABEL_82:
        _os_log_impl(&dword_1830D4000, v42, v43, v44, buf, 0xCu);
      }
    }
LABEL_83:
    if (v41) {
      free(v41);
    }
    return *(unsigned char *)(*(void *)(a1[4] + 8) + 24) == 0;
  }
  uint64_t v6 = *(void *)(a2 + 32);
  int v7 = *(void **)(a2 + 40);
  if (v6)
  {
    *(void *)(v6 + 40) = v7;
    int v7 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(a1[12] + 8) = v7;
  }
  *int v7 = v6;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v5 = 1;
  nw_frame_finalize(a2);
  return v5;
}

BOOL ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_68(void *a1, uint64_t a2)
{
  uint64_t v97 = *MEMORY[0x1E4F143B8];
  unsigned int size = 0;
  uint64_t v4 = nw_frame_unclaimed_bytes(a2, &size);
  uint64_t v6 = *(void *)(a1[4] + 8);
  unsigned int v7 = *(unsigned __int16 *)(v6 + 24);
  if (*(_WORD *)(v6 + 24))
  {
    if (size < v7)
    {
      *(_WORD *)(v6 + 24) = v7 - size;
      uint64_t v8 = *(void *)(a2 + 32);
      size_t v9 = *(void **)(a2 + 40);
      if (v8)
      {
        *(void *)(v8 + 40) = v9;
        size_t v9 = *(void **)(a2 + 40);
      }
      else
      {
        *(void *)(a1[8] + 8) = v9;
      }
      *size_t v9 = v8;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      uint64_t v22 = 1;
      nw_frame_finalize(a2);
      return v22;
    }
    nw_frame_claim(a2, v5, v7, 0);
    int v10 = (const void *)nw_frame_unclaimed_bytes(a2, &size);
    *(_WORD *)(*(void *)(a1[4] + 8) + 24) = 0;
  }
  else
  {
    int v10 = (const void *)v4;
  }
  uint64_t v11 = *(void *)(a1[5] + 8);
  size_t v12 = *(void *)(v11 + 24);
  if (!v12) {
    return 0;
  }
  size_t v13 = size;
  if (v12 <= size)
  {
    uint64_t v18 = a1[10];
    if (!v18)
    {
      dispatch_data_t v29 = dispatch_data_create(v10, v12, 0, 0);
      if (v29)
      {
        os_log_type_t v31 = v29;
        uint64_t v32 = *(void *)(a1[7] + 8);
        size_t v33 = *(NSObject **)(v32 + 24);
        if (v33)
        {
          dispatch_data_t concat = dispatch_data_create_concat(v33, v31);
          unsigned int v35 = *(NSObject **)(*(void *)(a1[7] + 8) + 24);
          if (v35)
          {
            dispatch_release(v35);
            *(void *)(*(void *)(a1[7] + 8) + 24) = 0;
          }
          dispatch_release(v31);
          *(void *)(*(void *)(a1[7] + 8) + 24) = concat;
        }
        else
        {
          *(void *)(v32 + 24) = v31;
        }
      }
      goto LABEL_88;
    }
    uint64_t v19 = *(void *)(v18 + 112);
    if (v19)
    {
      if ((*(_WORD *)(v18 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(a1[10], *(void *)(v18 + 88)))
      {
        LODWORD(v19) = *(_DWORD *)(v18 + 52);
        uint64_t v20 = *(unsigned int *)(v18 + 56);
        if (v19) {
          LODWORD(v19) = v19 - (v20 + *(_DWORD *)(v18 + 60));
        }
        uint64_t v21 = *(void *)(v18 + 112) + v20;
        goto LABEL_66;
      }
      LODWORD(v19) = 0;
    }
    uint64_t v21 = 0;
LABEL_66:
    uint64_t v50 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
    size_t v51 = *(void *)(*(void *)(a1[5] + 8) + 24);
    if (v51 + v50 > v19)
    {
      uint64_t v52 = a1[11];
      if (v52 && *(__int16 *)(v52 + 388) < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v53 = a1[11];
      unsigned int v54 = (const char *)(v53 + 390);
      BOOL v55 = v53 == 0;
      int v56 = *(_DWORD *)(v53 + 368);
      int size_4 = 136446978;
      if (v55) {
        unsigned int v54 = "";
      }
      uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
      if (v55) {
        int v57 = "";
      }
      else {
        int v57 = " ";
      }
      __int16 v89 = 2082;
      uint64_t v90 = (void *)v54;
      __int16 v91 = 2080;
      uint64_t v92 = v57;
      __int16 v93 = 1024;
      int v94 = v56;
      uint64_t v58 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v84 = 0;
      if (__nwlog_fault(v58, &type, &v84))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v59 = gconnectionLogObj;
          os_log_type_t v60 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            uint64_t v61 = a1[11];
            uint64_t v62 = (const char *)(v61 + 390);
            BOOL v63 = v61 == 0;
            if (!v61) {
              uint64_t v62 = "";
            }
            int v64 = *(_DWORD *)(v61 + 368);
            if (v63) {
              uint64_t v65 = "";
            }
            else {
              uint64_t v65 = " ";
            }
            int size_4 = 136446978;
            uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v89 = 2082;
            uint64_t v90 = (void *)v62;
            __int16 v91 = 2080;
            uint64_t v92 = v65;
            __int16 v93 = 1024;
            int v94 = v64;
            uint64_t v66 = "%{public}s %{public}s%s<i%u> Datagram frame is too short";
LABEL_115:
            _os_log_impl(&dword_1830D4000, v59, v60, v66, (uint8_t *)&size_4, 0x26u);
          }
        }
        else if (v84)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v59 = gconnectionLogObj;
          os_log_type_t v60 = type;
          BOOL v68 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (!backtrace_string)
          {
            if (!v68) {
              goto LABEL_116;
            }
            uint64_t v78 = a1[11];
            int v79 = (const char *)(v78 + 390);
            BOOL v80 = v78 == 0;
            if (!v78) {
              int v79 = "";
            }
            int v81 = *(_DWORD *)(v78 + 368);
            if (v80) {
              os_log_type_t v82 = "";
            }
            else {
              os_log_type_t v82 = " ";
            }
            int size_4 = 136446978;
            uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v89 = 2082;
            uint64_t v90 = (void *)v79;
            __int16 v91 = 2080;
            uint64_t v92 = v82;
            __int16 v93 = 1024;
            int v94 = v81;
            uint64_t v66 = "%{public}s %{public}s%s<i%u> Datagram frame is too short, no backtrace";
            goto LABEL_115;
          }
          if (v68)
          {
            uint64_t v69 = a1[11];
            int v70 = (const char *)(v69 + 390);
            if (v69)
            {
              uint64_t v71 = " ";
            }
            else
            {
              int v70 = "";
              uint64_t v71 = "";
            }
            int v72 = *(_DWORD *)(v69 + 368);
            int size_4 = 136447234;
            uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v89 = 2082;
            uint64_t v90 = (void *)v70;
            __int16 v91 = 2080;
            uint64_t v92 = v71;
            __int16 v93 = 1024;
            int v94 = v72;
            __int16 v95 = 2082;
            os_log_type_t v96 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s %{public}s%s<i%u> Datagram frame is too short, dumping backtrace:%{public}s", (uint8_t *)&size_4, 0x30u);
          }
          free(backtrace_string);
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v59 = gconnectionLogObj;
          os_log_type_t v60 = type;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
          {
            uint64_t v73 = a1[11];
            id v74 = (const char *)(v73 + 390);
            BOOL v75 = v73 == 0;
            if (!v73) {
              id v74 = "";
            }
            int v76 = *(_DWORD *)(v73 + 368);
            if (v75) {
              os_log_type_t v77 = "";
            }
            else {
              os_log_type_t v77 = " ";
            }
            int size_4 = 136446978;
            uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v89 = 2082;
            uint64_t v90 = (void *)v74;
            __int16 v91 = 2080;
            uint64_t v92 = v77;
            __int16 v93 = 1024;
            int v94 = v76;
            uint64_t v66 = "%{public}s %{public}s%s<i%u> Datagram frame is too short, backtrace limit exceeded";
            goto LABEL_115;
          }
        }
      }
LABEL_116:
      if (v58)
      {
        uint64_t v49 = (char *)v58;
        goto LABEL_118;
      }
      return 0;
    }
    memcpy((void *)(v21 + v50), v10, v51);
    *(_DWORD *)(*(void *)(a1[6] + 8) + 24) += *(_DWORD *)(*(void *)(a1[5] + 8) + 24);
LABEL_88:
    nw_frame_claim(a2, v30, *(_DWORD *)(*(void *)(a1[5] + 8) + 24), 0);
    uint64_t v22 = 0;
    *(void *)(*(void *)(a1[5] + 8) + 24) = 0;
    return v22;
  }
  *(void *)(v11 + 24) = v12 - size;
  uint64_t v14 = a1[10];
  if (!v14)
  {
    dispatch_data_t v23 = dispatch_data_create(v10, v13, 0, 0);
    if (v23)
    {
      uint64_t v24 = v23;
      uint64_t v25 = *(void *)(a1[7] + 8);
      unint64_t v26 = *(NSObject **)(v25 + 24);
      if (v26)
      {
        dispatch_data_t v27 = dispatch_data_create_concat(v26, v24);
        uint64_t v28 = *(NSObject **)(*(void *)(a1[7] + 8) + 24);
        if (v28)
        {
          dispatch_release(v28);
          *(void *)(*(void *)(a1[7] + 8) + 24) = 0;
        }
        dispatch_release(v24);
        *(void *)(*(void *)(a1[7] + 8) + 24) = v27;
      }
      else
      {
        *(void *)(v25 + 24) = v24;
      }
    }
    goto LABEL_47;
  }
  uint64_t v15 = *(void *)(v14 + 112);
  if (v15)
  {
    if ((*(_WORD *)(v14 + 204) & 0x100) == 0
      || !g_channel_check_validity
      || g_channel_check_validity(a1[10], *(void *)(v14 + 88)))
    {
      LODWORD(v15) = *(_DWORD *)(v14 + 52);
      uint64_t v16 = *(unsigned int *)(v14 + 56);
      if (v15) {
        LODWORD(v15) = v15 - (v16 + *(_DWORD *)(v14 + 60));
      }
      uint64_t v17 = *(void *)(v14 + 112) + v16;
      goto LABEL_41;
    }
    LODWORD(v15) = 0;
  }
  uint64_t v17 = 0;
LABEL_41:
  uint64_t v36 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
  if (v15 < size + v36)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int size_4 = 136446210;
    uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
    BOOL v37 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v84 = 0;
    if (!__nwlog_fault(v37, &type, &v84)) {
      goto LABEL_60;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v38 = gLogObj;
      os_log_type_t v39 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_60;
      }
      int size_4 = 136446210;
      uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v40 = "%{public}s Datagram frame is too short";
    }
    else
    {
      if (v84)
      {
        os_log_type_t v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v44 = gLogObj;
        os_log_type_t v45 = type;
        BOOL v46 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v43)
        {
          if (v46)
          {
            int size_4 = 136446466;
            uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v89 = 2082;
            uint64_t v90 = v43;
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s Datagram frame is too short, dumping backtrace:%{public}s", (uint8_t *)&size_4, 0x16u);
          }
          free(v43);
        }
        else if (v46)
        {
          int size_4 = 136446210;
          uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
          uint64_t v40 = "%{public}s Datagram frame is too short, no backtrace";
          unsigned int v47 = v44;
          os_log_type_t v48 = v45;
          goto LABEL_59;
        }
LABEL_60:
        if (v37)
        {
          uint64_t v49 = (char *)v37;
LABEL_118:
          free(v49);
          return 0;
        }
        return 0;
      }
      uint64_t v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_60;
      }
      int size_4 = 136446210;
      uint64_t v88 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v40 = "%{public}s Datagram frame is too short, backtrace limit exceeded";
    }
    unsigned int v47 = v38;
    os_log_type_t v48 = v39;
LABEL_59:
    _os_log_impl(&dword_1830D4000, v47, v48, v40, (uint8_t *)&size_4, 0xCu);
    goto LABEL_60;
  }
  memcpy((void *)(v17 + v36), v10, size);
  *(_DWORD *)(*(void *)(a1[6] + 8) + 24) += size;
LABEL_47:
  uint64_t v41 = *(void *)(a2 + 32);
  os_log_type_t v42 = *(void **)(a2 + 40);
  if (v41)
  {
    *(void *)(v41 + 40) = v42;
    os_log_type_t v42 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(a1[8] + 8) = v42;
  }
  *os_log_type_t v42 = v41;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return *(void *)(*(void *)(a1[5] + 8) + 24) != 0;
}

uint64_t ___ZL34nw_protocol_http2_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_71(uint64_t a1, uint64_t a2)
{
  uint64_t v222 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 1) > *(_DWORD *)(a1 + 72)) {
    return 0;
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  unsigned int v6 = *(_DWORD *)(v5 + 24);
  unsigned int v7 = *(_DWORD *)(a1 + 76);
  size_t v8 = v7 - v6;
  if (v7 <= v6) {
    return 0;
  }
  unsigned int v9 = v4;
  int v10 = v4 - v8;
  if (v4 <= v8)
  {
    *(_DWORD *)(v5 + 24) = v6 + v4;
    uint64_t v17 = *(void *)(a2 + 32);
    uint64_t v18 = *(void **)(a2 + 40);
    if (v17)
    {
      *(void *)(v17 + 40) = v18;
      uint64_t v18 = *(void **)(a2 + 40);
    }
    else
    {
      *(void *)(*(void *)(a1 + 48) + 8) = v18;
    }
    *uint64_t v18 = v17;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    uint64_t v23 = *(void *)(a1 + 48);
    if (v23)
    {
      uint64_t v13 = a2;
      if (((*(unsigned __int16 *)(v23 + 188) | (*(unsigned __int8 *)(v23 + 190) << 16)) & 0x80000) == 0)
      {
        uint64_t v13 = a2;
        if (gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v24 = gconnectionLogObj;
          uint64_t v13 = a2;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v25 = *(void *)(a1 + 48);
            unint64_t v26 = (const char *)(v25 + 191);
            dispatch_data_t v27 = "";
            BOOL v28 = v25 == 0;
            if (!v25) {
              unint64_t v26 = "";
            }
            uint64_t v31 = v25 + 176;
            int v29 = *(_DWORD *)(v25 + 176);
            int v30 = *(_DWORD *)(v31 + 4);
            if (!v28) {
              dispatch_data_t v27 = " ";
            }
            *(_DWORD *)int buf = 136447490;
            int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v214 = 2082;
            int v215 = v26;
            __int16 v216 = 2080;
            uint64_t v217 = (uint64_t)v27;
            __int16 v218 = 1024;
            *(_DWORD *)int v219 = v30;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v29;
            *(_WORD *)&v219[10] = 1024;
            *(_DWORD *)&v219[12] = v9;
            uint64_t v32 = "%{public}s %{public}s%s<i%u:s%d> delivering entire incoming frame (%u bytes)";
            size_t v33 = v24;
            uint32_t v34 = 50;
LABEL_32:
            _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, v32, buf, v34);
            uint64_t v13 = a2;
          }
        }
      }
    }
    else
    {
      uint64_t v125 = *(void *)(a1 + 56);
      if (!v125 || (uint64_t v13 = a2, (*(__int16 *)(v125 + 388) & 0x80000000) == 0))
      {
        uint64_t v13 = a2;
        if (gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v126 = gconnectionLogObj;
          uint64_t v13 = a2;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v127 = *(void *)(a1 + 56);
            char v128 = "";
            BOOL v129 = v127 == 0;
            int v130 = *(_DWORD *)(v127 + 368);
            int v131 = (const char *)(v127 + 390);
            int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v214 = 2082;
            if (v129) {
              int v131 = "";
            }
            *(_DWORD *)int buf = 136447234;
            if (!v129) {
              char v128 = " ";
            }
            int v215 = v131;
            __int16 v216 = 2080;
            uint64_t v217 = (uint64_t)v128;
            __int16 v218 = 1024;
            *(_DWORD *)int v219 = v130;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v9;
            uint64_t v32 = "%{public}s %{public}s%s<i%u> delivering entire incoming frame (%u bytes)";
            size_t v33 = v126;
            uint32_t v34 = 44;
            goto LABEL_32;
          }
        }
      }
    }
LABEL_47:
    uint64_t v43 = *(void *)(a1 + 48);
    int v44 = *(unsigned __int16 *)(v43 + 188) | (*(unsigned __int8 *)(v43 + 190) << 16);
    if (!*(void *)(v43 + 112))
    {
      if ((v44 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v48 = *(void *)(a1 + 48);
          uint64_t v49 = "";
          uint64_t v50 = (const char *)(v48 + 191);
          BOOL v51 = v48 == 0;
          if (!v48) {
            uint64_t v50 = "";
          }
          uint64_t v54 = v48 + 176;
          int v52 = *(_DWORD *)(v48 + 176);
          int v53 = *(_DWORD *)(v54 + 4);
          if (!v51) {
            uint64_t v49 = " ";
          }
          *(_DWORD *)int buf = 136447746;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v50;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v49;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v53;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v52;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v52;
          *(_WORD *)&v219[16] = 2048;
          *(void *)&v219[18] = a2;
          BOOL v55 = "%{public}s %{public}s%s<i%u:s%d> stream %d has no metadata to set on frame %p";
          goto LABEL_203;
        }
      }
LABEL_71:
      uint64_t v58 = *(void *)(a1 + 64);
      *(void *)(v13 + 32) = 0;
      __int16 v59 = *(uint64_t **)(v58 + 8);
      *(void *)(v13 + 40) = v59;
      *__int16 v59 = v13;
      *(void *)(v58 + 8) = v13 + 32;
      uint64_t v60 = *(void *)(*(void *)(a1 + 32) + 8);
      uint64_t v61 = *(unsigned int *)(v60 + 24) + 1;
      uint64_t v62 = v61 << 31 >> 31;
      *(_DWORD *)(v60 + 24) = v61;
      if (v62 == v61 && (v62 & 0x8000000000000000) == 0) {
        return 1;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v63 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
      *(_DWORD *)int buf = 136446978;
      int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      __int16 v214 = 2082;
      int v215 = "return_frame_count";
      __int16 v216 = 2048;
      uint64_t v217 = 1;
      __int16 v218 = 2048;
      *(void *)int v219 = v63;
      int v64 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v210 = 0;
      if (__nwlog_fault(v64, &type, &v210))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v65 = gLogObj;
          os_log_type_t v66 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            uint64_t v67 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v214 = 2082;
            int v215 = "return_frame_count";
            __int16 v216 = 2048;
            uint64_t v217 = 1;
            __int16 v218 = 2048;
            *(void *)int v219 = v67;
            BOOL v68 = "%{public}s Overflow: %{public}s, increment %llu, result %llu";
LABEL_115:
            _os_log_impl(&dword_1830D4000, v65, v66, v68, buf, 0x2Au);
          }
        }
        else if (v210)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v65 = gLogObj;
          os_log_type_t v66 = type;
          BOOL v70 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v70)
            {
              uint64_t v71 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
              *(_DWORD *)int buf = 136447234;
              int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
              __int16 v214 = 2082;
              int v215 = "return_frame_count";
              __int16 v216 = 2048;
              uint64_t v217 = 1;
              __int16 v218 = 2048;
              *(void *)int v219 = v71;
              *(_WORD *)&v219[8] = 2082;
              *(void *)&v219[10] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s Overflow: %{public}s, increment %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
            }
            free(backtrace_string);
            goto LABEL_116;
          }
          if (v70)
          {
            uint64_t v98 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v214 = 2082;
            int v215 = "return_frame_count";
            __int16 v216 = 2048;
            uint64_t v217 = 1;
            __int16 v218 = 2048;
            *(void *)int v219 = v98;
            BOOL v68 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, no backtrace";
            goto LABEL_115;
          }
        }
        else
        {
          uint64_t v65 = __nwlog_obj();
          os_log_type_t v66 = type;
          if (os_log_type_enabled(v65, type))
          {
            uint64_t v97 = *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            *(_DWORD *)int buf = 136446978;
            int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v214 = 2082;
            int v215 = "return_frame_count";
            __int16 v216 = 2048;
            uint64_t v217 = 1;
            __int16 v218 = 2048;
            *(void *)int v219 = v97;
            BOOL v68 = "%{public}s Overflow: %{public}s, increment %llu, result %llu, backtrace limit exceeded";
            goto LABEL_115;
          }
        }
      }
LABEL_116:
      if (v64) {
        free(v64);
      }
      *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = -1;
      return 1;
    }
    if ((*(_WORD *)(v43 + 188) & 0x1000) != 0)
    {
      BOOL v45 = *(void *)v43 == 0;
      p_cache = NWConcrete_nw_resolution_report.cache;
      if ((v44 & 0x80000) != 0) {
        goto LABEL_63;
      }
    }
    else
    {
      BOOL v45 = 0;
      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
      if ((v44 & 0x80000) != 0) {
        goto LABEL_63;
      }
    }
    if (*((unsigned char *)p_cache + 3665))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v151 = gconnectionLogObj;
      BOOL v152 = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG);
      uint64_t v43 = *(void *)(a1 + 48);
      if (v152)
      {
        int v153 = (const char *)(v43 + 191);
        os_log_type_t v154 = "";
        int v156 = *(_DWORD *)(v43 + 176);
        int v155 = *(_DWORD *)(v43 + 180);
        BOOL v157 = v43 == 0;
        if (!v43) {
          int v153 = "";
        }
        uint64_t v158 = *(void *)(v43 + 112);
        if (!v157) {
          os_log_type_t v154 = " ";
        }
        *(_DWORD *)int buf = 136448258;
        int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        __int16 v214 = 2082;
        int v215 = v153;
        __int16 v216 = 2080;
        uint64_t v217 = (uint64_t)v154;
        __int16 v218 = 1024;
        *(_DWORD *)int v219 = v155;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v156;
        *(_WORD *)&v219[10] = 2048;
        *(void *)&v219[12] = v158;
        *(_WORD *)&v219[20] = 1024;
        *(_DWORD *)&v219[22] = v156;
        *(_WORD *)&v219[26] = 2048;
        *(void *)&v219[28] = a2;
        __int16 v220 = 1024;
        BOOL v221 = v45;
        _os_log_impl(&dword_1830D4000, v151, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting metadata %p from stream %d on frame %p, complete %u", buf, 0x4Cu);
        uint64_t v43 = *(void *)(a1 + 48);
      }
    }
LABEL_63:
    nw_frame_set_metadata(a2, *(NSObject **)(v43 + 112), 1, v45);
    if (v45) {
      char v56 = 0x80;
    }
    else {
      char v56 = 0;
    }
    *(unsigned char *)(a2 + 186) = v56 & 0x80 | *(unsigned char *)(a2 + 186) & 0x7F;
    if (v45) {
      *(_WORD *)(*(void *)(a1 + 48) + 188) |= 0x8000u;
    }
    uint64_t v57 = *(void *)(a1 + 48);
    if (v57)
    {
      if (((*(unsigned __int16 *)(v57 + 188) | (*(unsigned __int8 *)(v57 + 190) << 16)) & 0x80000) == 0
        && *((unsigned char *)p_cache + 3665))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v47 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v159 = *(void *)(a1 + 48);
          int v160 = (const char *)(v159 + 191);
          int v161 = "";
          if (!v159) {
            int v160 = "";
          }
          int v163 = *(_DWORD *)(v159 + 176);
          int v162 = *(_DWORD *)(v159 + 180);
          if (v159) {
            int v161 = " ";
          }
          uint64_t v164 = **(void **)(*(void *)(v159 + 8) + 8);
          int v165 = (*(unsigned __int16 *)(v159 + 188) >> 12) & 1;
          *(_DWORD *)int buf = 136447746;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v160;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v161;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v162;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v163;
          *(_WORD *)&v219[10] = 2048;
          *(void *)&v219[12] = v164;
          *(_WORD *)&v219[20] = 1024;
          *(_DWORD *)&v219[22] = v165;
          BOOL v55 = "%{public}s %{public}s%s<i%u:s%d> last frame in input_frames is %p, inbound_message_complete: %u";
LABEL_203:
          os_log_type_t v149 = v47;
          uint32_t v150 = 60;
LABEL_204:
          _os_log_impl(&dword_1830D4000, v149, OS_LOG_TYPE_DEBUG, v55, buf, v150);
          goto LABEL_71;
        }
      }
    }
    else
    {
      uint64_t v140 = *(void *)(a1 + 56);
      if ((!v140 || (*(__int16 *)(v140 + 388) & 0x80000000) == 0) && *((unsigned char *)p_cache + 3665))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v141 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v143 = *(void *)(a1 + 48);
          uint64_t v142 = *(void *)(a1 + 56);
          char v144 = (const char *)(v142 + 390);
          os_log_type_t v145 = "";
          if (v142) {
            os_log_type_t v145 = " ";
          }
          else {
            char v144 = "";
          }
          int v146 = *(_DWORD *)(v142 + 368);
          uint64_t v147 = **(void **)(*(void *)(v143 + 8) + 8);
          int v148 = (*(unsigned __int16 *)(v143 + 188) >> 12) & 1;
          *(_DWORD *)int buf = 136447490;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v144;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v145;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v146;
          *(_WORD *)&v219[4] = 2048;
          *(void *)&v219[6] = v147;
          *(_WORD *)&v219[14] = 1024;
          *(_DWORD *)&v219[16] = v148;
          BOOL v55 = "%{public}s %{public}s%s<i%u> last frame in input_frames is %p, inbound_message_complete: %u";
          os_log_type_t v149 = v141;
          uint32_t v150 = 54;
          goto LABEL_204;
        }
      }
    }
    goto LABEL_71;
  }
  uint64_t v11 = *(void *)(a1 + 48);
  if (v11)
  {
    if (((*(unsigned __int16 *)(v11 + 188) | (*(unsigned __int8 *)(v11 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v132 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v133 = *(void *)(a1 + 48);
        uint64_t v134 = (const char *)(v133 + 191);
        uint64_t v135 = "";
        BOOL v136 = v133 == 0;
        if (!v133) {
          uint64_t v134 = "";
        }
        uint64_t v139 = v133 + 176;
        int v137 = *(_DWORD *)(v133 + 176);
        int v138 = *(_DWORD *)(v139 + 4);
        if (!v136) {
          uint64_t v135 = " ";
        }
        *(_DWORD *)int buf = 136447746;
        int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        __int16 v214 = 2082;
        int v215 = v134;
        __int16 v216 = 2080;
        uint64_t v217 = (uint64_t)v135;
        __int16 v218 = 1024;
        *(_DWORD *)int v219 = v138;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v137;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        *(_WORD *)&v219[16] = 1024;
        *(_DWORD *)&v219[18] = v9;
        os_log_type_t v122 = "%{public}s %{public}s%s<i%u:s%d> remaining space %u less than frame length %u";
        uint64_t v123 = v132;
        uint32_t v124 = 56;
LABEL_176:
        _os_log_impl(&dword_1830D4000, v123, OS_LOG_TYPE_DEBUG, v122, buf, v124);
      }
    }
  }
  else
  {
    uint64_t v115 = *(void *)(a1 + 56);
    if ((!v115 || (*(__int16 *)(v115 + 388) & 0x80000000) == 0) && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v116 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v117 = *(void *)(a1 + 56);
        int v118 = *(_DWORD *)(v117 + 368);
        BOOL v119 = v117 == 0;
        int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        if (v117) {
          uint64_t v120 = (const char *)(v117 + 390);
        }
        else {
          uint64_t v120 = "";
        }
        __int16 v214 = 2082;
        uint64_t v121 = " ";
        *(_DWORD *)int buf = 136447490;
        if (v119) {
          uint64_t v121 = "";
        }
        int v215 = v120;
        __int16 v216 = 2080;
        uint64_t v217 = (uint64_t)v121;
        __int16 v218 = 1024;
        *(_DWORD *)int v219 = v118;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v8;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v9;
        os_log_type_t v122 = "%{public}s %{public}s%s<i%u> remaining space %u less than frame length %u";
        uint64_t v123 = v116;
        uint32_t v124 = 50;
        goto LABEL_176;
      }
    }
  }
  input_uint64_t frame = http2_create_input_frame(*(void *)(a1 + 56), *(void *)(a1 + 48), v8);
  if (!input_frame)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v210 = 0;
    if (!__nwlog_fault(v19, &type, &v210)) {
      goto LABEL_132;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = gLogObj;
      os_log_type_t v21 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)int buf = 136446210;
      int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v22 = "%{public}s http2_create_input_frame failed";
    }
    else if (v210)
    {
      uint64_t v36 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v37 = os_log_type_enabled(v20, type);
      if (v36)
      {
        if (v37)
        {
          *(_DWORD *)int buf = 136446466;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v36;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s http2_create_input_frame failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v36);
        goto LABEL_132;
      }
      if (!v37)
      {
LABEL_132:
        if (v19) {
          free(v19);
        }
        return 0;
      }
      *(_DWORD *)int buf = 136446210;
      int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v22 = "%{public}s http2_create_input_frame failed, no backtrace";
    }
    else
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_132;
      }
      *(_DWORD *)int buf = 136446210;
      int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
      uint64_t v22 = "%{public}s http2_create_input_frame failed, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_132;
  }
  uint64_t v13 = input_frame;
  if (!*(void *)(input_frame + 112)
    || (*(_WORD *)(input_frame + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(input_frame, *(void *)(input_frame + 88)))
  {
    int v16 = 0;
    unsigned int v35 = 0;
  }
  else
  {
    int v15 = *(_DWORD *)(v13 + 52);
    uint64_t v14 = *(unsigned int *)(v13 + 56);
    if (v15) {
      int v16 = v15 - (v14 + *(_DWORD *)(v13 + 60));
    }
    else {
      int v16 = 0;
    }
    unsigned int v35 = (void *)(*(void *)(v13 + 112) + v14);
  }
  uint64_t v38 = *(void *)(a1 + 48);
  if (v16 == v8)
  {
    os_log_type_t v39 = *(NSObject **)(v38 + 112);
    if (v39) {
      nw_frame_set_metadata(v13, v39, 1, 0);
    }
    uint64_t v40 = (const void *)nw_frame_unclaimed_bytes(a2, 0);
    memcpy(v35, v40, v8);
    nw_frame_claim(a2, v41, v8, 0);
    http2_input_frame_metadata_reset(a2, *(void *)(a1 + 56), *(void *)(a1 + 48), v10);
    *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v8;
    uint64_t v42 = *(void *)(a1 + 48);
    if (v42)
    {
      if (((*(unsigned __int16 *)(v42 + 188) | (*(unsigned __int8 *)(v42 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v186 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v187 = *(void *)(a1 + 48);
          if (v187) {
            int v188 = (const char *)(v187 + 191);
          }
          else {
            int v188 = "";
          }
          if (v187) {
            int v189 = " ";
          }
          else {
            int v189 = "";
          }
          int v191 = *(_DWORD *)(v187 + 176);
          int v190 = *(_DWORD *)(v187 + 180);
          int v192 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)int buf = 136448002;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v188;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v189;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v190;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v191;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v8;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v9;
          *(_WORD *)&v219[22] = 1024;
          *(_DWORD *)&v219[24] = v192;
          _os_log_impl(&dword_1830D4000, v186, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> delivering partial frame (%u bytes of %u, %u bytes remaining)", buf, 0x3Eu);
        }
      }
    }
    else
    {
      uint64_t v166 = *(void *)(a1 + 56);
      if ((!v166 || (*(__int16 *)(v166 + 388) & 0x80000000) == 0) && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v167 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v168 = *(void *)(a1 + 56);
          if (v168) {
            int v169 = (const char *)(v168 + 390);
          }
          else {
            int v169 = "";
          }
          if (v168) {
            int v170 = " ";
          }
          else {
            int v170 = "";
          }
          int v171 = *(_DWORD *)(v168 + 368);
          int v172 = nw_frame_unclaimed_length((_DWORD *)a2);
          *(_DWORD *)int buf = 136447746;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v169;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v170;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v171;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v8;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v9;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v172;
          _os_log_impl(&dword_1830D4000, v167, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> delivering partial frame (%u bytes of %u, %u bytes remaining)", buf, 0x38u);
        }
      }
    }
    goto LABEL_47;
  }
  if (v38)
  {
    if (((*(unsigned __int16 *)(v38 + 188) | (*(unsigned __int8 *)(v38 + 190) << 16)) & 0x80000) != 0) {
      goto LABEL_143;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v72 = *(void *)(a1 + 48);
    uint64_t v73 = (const char *)(v72 + 191);
    BOOL v74 = v72 == 0;
    if (!v72) {
      uint64_t v73 = "";
    }
    uint64_t v77 = v72 + 176;
    int v75 = *(_DWORD *)(v72 + 176);
    int v76 = *(_DWORD *)(v77 + 4);
    if (v74) {
      uint64_t v78 = "";
    }
    else {
      uint64_t v78 = " ";
    }
    *(_DWORD *)int buf = 136447746;
    int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    __int16 v214 = 2082;
    int v215 = v73;
    __int16 v216 = 2080;
    uint64_t v217 = (uint64_t)v78;
    __int16 v218 = 1024;
    *(_DWORD *)int v219 = v76;
    *(_WORD *)&v219[4] = 1024;
    *(_DWORD *)&v219[6] = v75;
    *(_WORD *)&v219[10] = 1024;
    *(_DWORD *)&v219[12] = v16;
    *(_WORD *)&v219[16] = 1024;
    *(_DWORD *)&v219[18] = v8;
    int v79 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v210 = 0;
    if (__nwlog_fault(v79, &type, &v210))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v80 = gconnectionLogObj;
        os_log_type_t v81 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          uint64_t v82 = *(void *)(a1 + 48);
          int v83 = (const char *)(v82 + 191);
          if (v82)
          {
            char v84 = " ";
          }
          else
          {
            int v83 = "";
            char v84 = "";
          }
          uint64_t v87 = v82 + 176;
          int v85 = *(_DWORD *)(v82 + 176);
          int v86 = *(_DWORD *)(v87 + 4);
          *(_DWORD *)int buf = 136447746;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v83;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v84;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v86;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v85;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          uint64_t v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame";
LABEL_139:
          os_log_type_t v112 = v80;
          os_log_type_t v113 = v81;
          uint32_t v114 = 56;
LABEL_140:
          _os_log_impl(&dword_1830D4000, v112, v113, v88, buf, v114);
        }
      }
      else
      {
        if (v210)
        {
          __int16 v89 = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v80 = gconnectionLogObj;
          os_log_type_t v81 = type;
          BOOL v90 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (v89)
          {
            if (v90)
            {
              uint64_t v91 = *(void *)(a1 + 48);
              uint64_t v92 = (const char *)(v91 + 191);
              if (v91)
              {
                __int16 v93 = " ";
              }
              else
              {
                uint64_t v92 = "";
                __int16 v93 = "";
              }
              uint64_t v96 = v91 + 176;
              int v94 = *(_DWORD *)(v91 + 176);
              int v95 = *(_DWORD *)(v96 + 4);
              *(_DWORD *)int buf = 136448002;
              int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
              __int16 v214 = 2082;
              int v215 = v92;
              __int16 v216 = 2080;
              uint64_t v217 = (uint64_t)v93;
              __int16 v218 = 1024;
              *(_DWORD *)int v219 = v95;
              *(_WORD *)&v219[4] = 1024;
              *(_DWORD *)&v219[6] = v94;
              *(_WORD *)&v219[10] = 1024;
              *(_DWORD *)&v219[12] = v16;
              *(_WORD *)&v219[16] = 1024;
              *(_DWORD *)&v219[18] = v8;
              *(_WORD *)&v219[22] = 2082;
              *(void *)&v219[24] = v89;
              _os_log_impl(&dword_1830D4000, v80, v81, "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame, dumping backtrace:%{public}s", buf, 0x42u);
            }
            free(v89);
            if (!v79) {
              goto LABEL_143;
            }
            goto LABEL_142;
          }
          if (!v90) {
            goto LABEL_141;
          }
          uint64_t v106 = *(void *)(a1 + 48);
          uint64_t v107 = (const char *)(v106 + 191);
          if (v106)
          {
            uint64_t v108 = " ";
          }
          else
          {
            uint64_t v107 = "";
            uint64_t v108 = "";
          }
          uint64_t v111 = v106 + 176;
          int v109 = *(_DWORD *)(v106 + 176);
          int v110 = *(_DWORD *)(v111 + 4);
          *(_DWORD *)int buf = 136447746;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v107;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v108;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v110;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v109;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          uint64_t v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame, no backtrace";
          goto LABEL_139;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v80 = gconnectionLogObj;
        os_log_type_t v81 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          uint64_t v100 = *(void *)(a1 + 48);
          uint64_t v101 = (const char *)(v100 + 191);
          if (v100)
          {
            uint64_t v102 = " ";
          }
          else
          {
            uint64_t v101 = "";
            uint64_t v102 = "";
          }
          uint64_t v105 = v100 + 176;
          int v103 = *(_DWORD *)(v100 + 176);
          int v104 = *(_DWORD *)(v105 + 4);
          *(_DWORD *)int buf = 136447746;
          int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
          __int16 v214 = 2082;
          int v215 = v101;
          __int16 v216 = 2080;
          uint64_t v217 = (uint64_t)v102;
          __int16 v218 = 1024;
          *(_DWORD *)int v219 = v104;
          *(_WORD *)&v219[4] = 1024;
          *(_DWORD *)&v219[6] = v103;
          *(_WORD *)&v219[10] = 1024;
          *(_DWORD *)&v219[12] = v16;
          *(_WORD *)&v219[16] = 1024;
          *(_DWORD *)&v219[18] = v8;
          uint64_t v88 = "%{public}s %{public}s%s<i%u:s%d> got frame with wrong number of bytes (got %u != wanted %u) from http2_c"
                "reate_input_frame, backtrace limit exceeded";
          goto LABEL_139;
        }
      }
    }
  }
  else
  {
    uint64_t v173 = *(void *)(a1 + 56);
    if (v173 && *(__int16 *)(v173 + 388) < 0) {
      goto LABEL_143;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v174 = *(void *)(a1 + 56);
    BOOL v175 = (const char *)(v174 + 390);
    BOOL v176 = v174 == 0;
    int v177 = *(_DWORD *)(v174 + 368);
    if (v176) {
      BOOL v175 = "";
    }
    *(_DWORD *)int buf = 136447490;
    int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
    if (v176) {
      uint64_t v178 = "";
    }
    else {
      uint64_t v178 = " ";
    }
    __int16 v214 = 2082;
    int v215 = v175;
    __int16 v216 = 2080;
    uint64_t v217 = (uint64_t)v178;
    __int16 v218 = 1024;
    *(_DWORD *)int v219 = v177;
    *(_WORD *)&v219[4] = 1024;
    *(_DWORD *)&v219[6] = v16;
    *(_WORD *)&v219[10] = 1024;
    *(_DWORD *)&v219[12] = v8;
    int v79 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v210 = 0;
    if (__nwlog_fault(v79, &type, &v210))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v179 = gconnectionLogObj;
        os_log_type_t v180 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_141;
        }
        uint64_t v181 = *(void *)(a1 + 56);
        int v182 = (const char *)(v181 + 390);
        BOOL v183 = v181 == 0;
        if (!v181) {
          int v182 = "";
        }
        int v184 = *(_DWORD *)(v181 + 368);
        if (v183) {
          uint64_t v185 = "";
        }
        else {
          uint64_t v185 = " ";
        }
        *(_DWORD *)int buf = 136447490;
        int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        __int16 v214 = 2082;
        int v215 = v182;
        __int16 v216 = 2080;
        uint64_t v217 = (uint64_t)v185;
        __int16 v218 = 1024;
        *(_DWORD *)int v219 = v184;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        uint64_t v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame";
      }
      else if (v210)
      {
        uint64_t v193 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v179 = gconnectionLogObj;
        os_log_type_t v180 = type;
        BOOL v194 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v193)
        {
          if (v194)
          {
            uint64_t v195 = *(void *)(a1 + 56);
            uint64_t v196 = (const char *)(v195 + 390);
            BOOL v197 = v195 == 0;
            if (!v195) {
              uint64_t v196 = "";
            }
            int v198 = *(_DWORD *)(v195 + 368);
            if (v197) {
              uint64_t v199 = "";
            }
            else {
              uint64_t v199 = " ";
            }
            *(_DWORD *)int buf = 136447746;
            int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
            __int16 v214 = 2082;
            int v215 = v196;
            __int16 v216 = 2080;
            uint64_t v217 = (uint64_t)v199;
            __int16 v218 = 1024;
            *(_DWORD *)int v219 = v198;
            *(_WORD *)&v219[4] = 1024;
            *(_DWORD *)&v219[6] = v16;
            *(_WORD *)&v219[10] = 1024;
            *(_DWORD *)&v219[12] = v8;
            *(_WORD *)&v219[16] = 2082;
            *(void *)&v219[18] = v193;
            _os_log_impl(&dword_1830D4000, v179, v180, "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_input_frame, dumping backtrace:%{public}s", buf, 0x3Cu);
          }
          free(v193);
          goto LABEL_141;
        }
        if (!v194) {
          goto LABEL_141;
        }
        uint64_t v205 = *(void *)(a1 + 56);
        uint64_t v206 = (const char *)(v205 + 390);
        BOOL v207 = v205 == 0;
        if (!v205) {
          uint64_t v206 = "";
        }
        int v208 = *(_DWORD *)(v205 + 368);
        if (v207) {
          BOOL v209 = "";
        }
        else {
          BOOL v209 = " ";
        }
        *(_DWORD *)int buf = 136447490;
        int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        __int16 v214 = 2082;
        int v215 = v206;
        __int16 v216 = 2080;
        uint64_t v217 = (uint64_t)v209;
        __int16 v218 = 1024;
        *(_DWORD *)int v219 = v208;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        uint64_t v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_"
              "input_frame, no backtrace";
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v179 = gconnectionLogObj;
        os_log_type_t v180 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_141;
        }
        uint64_t v200 = *(void *)(a1 + 56);
        BOOL v201 = (const char *)(v200 + 390);
        BOOL v202 = v200 == 0;
        if (!v200) {
          BOOL v201 = "";
        }
        int v203 = *(_DWORD *)(v200 + 368);
        if (v202) {
          int v204 = "";
        }
        else {
          int v204 = " ";
        }
        *(_DWORD *)int buf = 136447490;
        int v213 = "nw_protocol_http2_get_input_frames_block_invoke";
        __int16 v214 = 2082;
        int v215 = v201;
        __int16 v216 = 2080;
        uint64_t v217 = (uint64_t)v204;
        __int16 v218 = 1024;
        *(_DWORD *)int v219 = v203;
        *(_WORD *)&v219[4] = 1024;
        *(_DWORD *)&v219[6] = v16;
        *(_WORD *)&v219[10] = 1024;
        *(_DWORD *)&v219[12] = v8;
        uint64_t v88 = "%{public}s %{public}s%s<i%u> got frame with wrong number of bytes (got %u != wanted %u) from http2_create_"
              "input_frame, backtrace limit exceeded";
      }
      os_log_type_t v112 = v179;
      os_log_type_t v113 = v180;
      uint32_t v114 = 50;
      goto LABEL_140;
    }
  }
LABEL_141:
  if (v79) {
LABEL_142:
  }
    free(v79);
LABEL_143:
  nw_frame_finalize(v13);
  return 0;
}

void nw_protocol_http2_output_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_protocol_http2_output_available";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17)) {
      goto LABEL_51;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_protocol_http2_output_available";
      size_t v8 = "%{public}s called with null protocol";
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v14 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v20 = "nw_protocol_http2_output_available";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_51:
        if (!v5) {
          return;
        }
LABEL_52:
        free(v5);
        return;
      }
      if (!v14) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_protocol_http2_output_available";
      size_t v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      unsigned int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v20 = "nw_protocol_http2_output_available";
      size_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_50:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_51;
  }
  handle = a1->handle;
  if (handle)
  {
    if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unsigned int v9 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v10 = handle[92];
        *(_DWORD *)int buf = 136446978;
        uint64_t v20 = "nw_protocol_http2_output_available";
        __int16 v21 = 2082;
        uint64_t v22 = (char *)handle + 390;
        __int16 v23 = 2080;
        uint64_t v24 = " ";
        __int16 v25 = 1024;
        int v26 = v10;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    if (nghttp2_session_want_write())
    {
      if (((__int16)handle[97] & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v3 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          int v4 = handle[92];
          *(_DWORD *)int buf = 136446978;
          uint64_t v20 = "nw_protocol_http2_output_available";
          __int16 v21 = 2082;
          uint64_t v22 = (char *)handle + 390;
          __int16 v23 = 2080;
          uint64_t v24 = " ";
          __int16 v25 = 1024;
          int v26 = v4;
          _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> session send wanted by nghttp2 library", buf, 0x26u);
        }
      }
      nw_http2_session_send((uint64_t)handle);
      if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v11 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v12 = handle[92];
          *(_DWORD *)int buf = 136446978;
          uint64_t v20 = "nw_protocol_http2_output_available";
          __int16 v21 = 2082;
          uint64_t v22 = (char *)handle + 390;
          __int16 v23 = 2080;
          uint64_t v24 = " ";
          __int16 v25 = 1024;
          int v26 = v12;
          _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called session send for nghttp2 session", buf, 0x26u);
        }
      }
    }
    nw_http2_drain_output_frames((uint64_t)handle);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  uint64_t v20 = "nw_protocol_http2_output_available";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (!__nwlog_fault(v5, &type, &v17)) {
    goto LABEL_51;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_51;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_protocol_http2_output_available";
    size_t v8 = "%{public}s called with null http2";
    goto LABEL_50;
  }
  if (!v17)
  {
    unsigned int v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_51;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_protocol_http2_output_available";
    size_t v8 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_50;
  }
  int v15 = (char *)__nw_create_backtrace_string();
  unsigned int v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v16 = os_log_type_enabled(v6, type);
  if (!v15)
  {
    if (!v16) {
      goto LABEL_51;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v20 = "nw_protocol_http2_output_available";
    size_t v8 = "%{public}s called with null http2, no backtrace";
    goto LABEL_50;
  }
  if (v16)
  {
    *(_DWORD *)int buf = 136446466;
    uint64_t v20 = "nw_protocol_http2_output_available";
    __int16 v21 = 2082;
    uint64_t v22 = v15;
    _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v15);
  if (v5) {
    goto LABEL_52;
  }
}

void nw_protocol_http2_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v16 = "nw_protocol_http2_input_available";
    int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (!__nwlog_fault(v3, &type, &v13)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v16 = "nw_protocol_http2_input_available";
      unsigned int v6 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v10 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)int buf = 136446466;
          BOOL v16 = "nw_protocol_http2_input_available";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_40:
        if (!v3) {
          return;
        }
LABEL_41:
        free(v3);
        return;
      }
      if (!v10) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v16 = "nw_protocol_http2_input_available";
      unsigned int v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v16 = "nw_protocol_http2_input_available";
      unsigned int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_39:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_40;
  }
  handle = a1->handle;
  if (handle)
  {
    if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v7 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v8 = handle[92];
        *(_DWORD *)int buf = 136446978;
        BOOL v16 = "nw_protocol_http2_input_available";
        __int16 v17 = 2082;
        uint64_t v18 = (char *)handle + 390;
        __int16 v19 = 2080;
        uint64_t v20 = " ";
        __int16 v21 = 1024;
        int v22 = v8;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    if ((handle[97] & 0x1000) == 0) {
      nw_protocol_http2_process_input((uint64_t)handle);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  BOOL v16 = "nw_protocol_http2_input_available";
  int v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (!__nwlog_fault(v3, &type, &v13)) {
    goto LABEL_40;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_40;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v16 = "nw_protocol_http2_input_available";
    unsigned int v6 = "%{public}s called with null http2";
    goto LABEL_39;
  }
  if (!v13)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_40;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v16 = "nw_protocol_http2_input_available";
    unsigned int v6 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_39;
  }
  uint64_t v11 = (char *)__nw_create_backtrace_string();
  int v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v12 = os_log_type_enabled(v4, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_40;
    }
    *(_DWORD *)int buf = 136446210;
    BOOL v16 = "nw_protocol_http2_input_available";
    unsigned int v6 = "%{public}s called with null http2, no backtrace";
    goto LABEL_39;
  }
  if (v12)
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v16 = "nw_protocol_http2_input_available";
    __int16 v17 = 2082;
    uint64_t v18 = v11;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v3) {
    goto LABEL_41;
  }
}

BOOL nw_protocol_http2_replace_input_handler(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v61 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    int v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v30, &type, &v47)) {
      goto LABEL_99;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null protocol";
      goto LABEL_98;
    }
    if (!v47)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v37 = os_log_type_enabled(v31, type);
    if (!backtrace_string)
    {
      if (!v37) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_98;
    }
    if (!v37) {
      goto LABEL_76;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    __int16 v51 = 2082;
    int v52 = backtrace_string;
    uint64_t v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_75:
    _os_log_impl(&dword_1830D4000, v31, v32, v38, buf, 0x16u);
    goto LABEL_76;
  }
  uint64_t v4 = *(void *)(a1 + 40);
  if (!v4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    int v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v30, &type, &v47)) {
      goto LABEL_99;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null http2";
      goto LABEL_98;
    }
    if (!v47)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v39 = os_log_type_enabled(v31, type);
    if (!backtrace_string)
    {
      if (!v39) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null http2, no backtrace";
      goto LABEL_98;
    }
    if (!v39) {
      goto LABEL_76;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    __int16 v51 = 2082;
    int v52 = backtrace_string;
    uint64_t v38 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_75;
  }
  if ((*(__int16 *)(v4 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint32_t v34 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v35 = *(_DWORD *)(v4 + 368);
      *(_DWORD *)int buf = 136446978;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      __int16 v51 = 2082;
      int v52 = (char *)(v4 + 390);
      __int16 v53 = 2080;
      uint64_t v54 = " ";
      __int16 v55 = 1024;
      int v56 = v35;
      _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    int v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v30, &type, &v47)) {
      goto LABEL_99;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null old_input_protocol";
      goto LABEL_98;
    }
    if (!v47)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null old_input_protocol, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v40 = os_log_type_enabled(v31, type);
    if (!backtrace_string)
    {
      if (!v40) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null old_input_protocol, no backtrace";
      goto LABEL_98;
    }
    if (!v40) {
      goto LABEL_76;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    __int16 v51 = 2082;
    int v52 = backtrace_string;
    uint64_t v38 = "%{public}s called with null old_input_protocol, dumping backtrace:%{public}s";
    goto LABEL_75;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    int v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v30, &type, &v47)) {
      goto LABEL_99;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null new_input_protocol";
      goto LABEL_98;
    }
    if (!v47)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (!os_log_type_enabled(v31, type)) {
        goto LABEL_99;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v50 = "nw_protocol_http2_replace_input_handler";
      size_t v33 = "%{public}s called with null new_input_protocol, backtrace limit exceeded";
      goto LABEL_98;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v41 = os_log_type_enabled(v31, type);
    if (backtrace_string)
    {
      if (v41)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v50 = "nw_protocol_http2_replace_input_handler";
        __int16 v51 = 2082;
        int v52 = backtrace_string;
        uint64_t v38 = "%{public}s called with null new_input_protocol, dumping backtrace:%{public}s";
        goto LABEL_75;
      }
LABEL_76:
      free(backtrace_string);
      goto LABEL_99;
    }
    if (!v41) {
      goto LABEL_99;
    }
    *(_DWORD *)int buf = 136446210;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    size_t v33 = "%{public}s called with null new_input_protocol, no backtrace";
LABEL_98:
    _os_log_impl(&dword_1830D4000, v31, v32, v33, buf, 0xCu);
LABEL_99:
    if (v30) {
      free(v30);
    }
    return 0;
  }
  uint64_t v7 = *(void *)(a2 + 56);
  if (!v7)
  {
    if (*(__int16 *)(v4 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v22 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v23 = *(_DWORD *)(v4 + 368);
    *(_DWORD *)int buf = 136446978;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    __int16 v51 = 2082;
    int v52 = (char *)(v4 + 390);
    __int16 v53 = 2080;
    uint64_t v54 = " ";
    __int16 v55 = 1024;
    int v56 = v23;
    uint64_t v24 = "%{public}s %{public}s%s<i%u> Failed to find old node";
LABEL_29:
    __int16 v25 = v22;
    uint32_t v26 = 38;
LABEL_36:
    _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, v24, buf, v26);
    return 0;
  }
  uint64_t v8 = *(void *)(v7 + 32);
  v43[0] = MEMORY[0x1E4F143A8];
  v43[1] = 0x40000000;
  int v44 = ___ZL39nw_protocol_http2_replace_input_handlerP11nw_protocolS0_S0__block_invoke;
  BOOL v45 = &__block_descriptor_tmp_64_84666;
  uint64_t v46 = a3;
  uint64_t v9 = *(void *)(v8 + 16);
  do
  {
    if (!v9) {
      break;
    }
    uint64_t v10 = *(void *)(v9 + 16);
    char v11 = ((uint64_t (*)(void *))v44)(v43);
    uint64_t v9 = v10;
  }
  while ((v11 & 1) != 0);
  nw_http2_remove_from_protocol_table(v4, a2);
  uint64_t v12 = nw_http2_add_to_protocol_table(v4, a3, v8);
  if (v12)
  {
    *(void *)(a3 + 56) = v12;
    nw_protocol_set_output_handler(a3, a1);
    if (*(void *)(a1 + 48) == a2)
    {
      nw_protocol_set_input_handler(a1, a3);
      *(_OWORD *)uint64_t v4 = *(_OWORD *)a3;
    }
    int v13 = *(_DWORD *)(v8 + 176);
    if (v13 != -1)
    {
      uint64_t stream_node_from_id = nw_http2_get_stream_node_from_id(v4, v13);
      if (stream_node_from_id) {
        *(void *)(stream_node_from_id + 32) = a3;
      }
    }
    BOOL result = 1;
    if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v16 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v17 = v8 + 191;
        uint64_t v20 = v8 + 176;
        int v18 = *(_DWORD *)(v8 + 176);
        int v19 = *(_DWORD *)(v20 + 4);
        int v21 = nw_hash_table_count(*(void *)(v4 + 152));
        *(_DWORD *)int buf = 136447490;
        uint64_t v50 = "nw_protocol_http2_replace_input_handler";
        __int16 v51 = 2082;
        int v52 = (char *)v17;
        __int16 v53 = 2080;
        uint64_t v54 = " ";
        __int16 v55 = 1024;
        int v56 = v19;
        __int16 v57 = 1024;
        int v58 = v18;
        __int16 v59 = 1024;
        int v60 = v21;
        _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> replaced input handler, have %u input handlers", buf, 0x32u);
      }
      return 1;
    }
    return result;
  }
  if (!v8)
  {
    if (*(__int16 *)(v4 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v22 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    int v42 = *(_DWORD *)(v4 + 368);
    *(_DWORD *)int buf = 136446978;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    __int16 v51 = 2082;
    int v52 = (char *)(v4 + 390);
    __int16 v53 = 2080;
    uint64_t v54 = " ";
    __int16 v55 = 1024;
    int v56 = v42;
    uint64_t v24 = "%{public}s %{public}s%s<i%u> could not add protocol to protocol based hash table, cannot replace input handler";
    goto LABEL_29;
  }
  if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) != 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  uint64_t v27 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v29 = *(_DWORD *)(v8 + 176);
    int v28 = *(_DWORD *)(v8 + 180);
    *(_DWORD *)int buf = 136447234;
    uint64_t v50 = "nw_protocol_http2_replace_input_handler";
    __int16 v51 = 2082;
    int v52 = (char *)(v8 + 191);
    __int16 v53 = 2080;
    uint64_t v54 = " ";
    __int16 v55 = 1024;
    int v56 = v28;
    __int16 v57 = 1024;
    int v58 = v29;
    uint64_t v24 = "%{public}s %{public}s%s<i%u:s%d> could not add protocol to protocol based hash table, cannot replace input handler";
    __int16 v25 = v27;
    uint32_t v26 = 44;
    goto LABEL_36;
  }
  return result;
}

uint64_t ___ZL39nw_protocol_http2_replace_input_handlerP11nw_protocolS0_S0__block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(nw_frame_get_metadata(a2) + 8) = *(void *)(a1 + 32);
  return 1;
}

BOOL nw_http2_remove_from_protocol_table(uint64_t a1, uint64_t a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v24 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v25 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447234;
      int v29 = "nw_http2_remove_from_protocol_table";
      __int16 v30 = 2082;
      uint64_t v31 = a1 + 390;
      __int16 v32 = 2080;
      size_t v33 = " ";
      __int16 v34 = 1024;
      int v35 = v25;
      __int16 v36 = 2048;
      uint64_t v37 = a2;
      _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called for input handler %p", buf, 0x30u);
    }
  }
  uint64_t v4 = *(void *)(a1 + 152);
  if (v4)
  {
    BOOL node = nw_hash_table_get_node(v4, a2, 8);
    if (node)
    {
      if (nw_hash_table_remove_node(*(void *)(a1 + 152), node))
      {
        *(void *)(a2 + 56) = 0;
        BOOL result = 1;
        if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v7 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v8 = *(_DWORD *)(a1 + 368);
            *(_DWORD *)int buf = 136447234;
            int v29 = "nw_http2_remove_from_protocol_table";
            __int16 v30 = 2082;
            uint64_t v31 = a1 + 390;
            __int16 v32 = 2080;
            size_t v33 = " ";
            __int16 v34 = 1024;
            int v35 = v8;
            __int16 v36 = 2048;
            uint64_t v37 = a2;
            _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removed protocol %p from protocol based table", buf, 0x30u);
          }
          return 1;
        }
        return result;
      }
      if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v13 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)int buf = 136447234;
        int v29 = "nw_http2_remove_from_protocol_table";
        __int16 v30 = 2082;
        uint64_t v31 = a1 + 390;
        __int16 v32 = 2080;
        size_t v33 = " ";
        __int16 v34 = 1024;
        int v35 = v13;
        __int16 v36 = 2048;
        uint64_t v37 = a2;
        BOOL v14 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v26 = 0;
        if (!__nwlog_fault(v14, &type, &v26)) {
          goto LABEL_47;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v15 = gconnectionLogObj;
          os_log_type_t v16 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_47;
          }
          int v17 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)int buf = 136447234;
          int v29 = "nw_http2_remove_from_protocol_table";
          __int16 v30 = 2082;
          uint64_t v31 = a1 + 390;
          __int16 v32 = 2080;
          size_t v33 = " ";
          __int16 v34 = 1024;
          int v35 = v17;
          __int16 v36 = 2048;
          uint64_t v37 = a2;
          int v18 = "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table";
        }
        else if (v26)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v15 = gconnectionLogObj;
          os_log_type_t v16 = type;
          BOOL v20 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
          if (backtrace_string)
          {
            if (v20)
            {
              int v21 = *(_DWORD *)(a1 + 368);
              *(_DWORD *)int buf = 136447490;
              int v29 = "nw_http2_remove_from_protocol_table";
              __int16 v30 = 2082;
              uint64_t v31 = a1 + 390;
              __int16 v32 = 2080;
              size_t v33 = " ";
              __int16 v34 = 1024;
              int v35 = v21;
              __int16 v36 = 2048;
              uint64_t v37 = a2;
              __int16 v38 = 2082;
              BOOL v39 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table, dumping backtrace:%{public}s", buf, 0x3Au);
            }
            free(backtrace_string);
            goto LABEL_47;
          }
          if (!v20)
          {
LABEL_47:
            if (v14) {
              free(v14);
            }
            return 0;
          }
          int v23 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)int buf = 136447234;
          int v29 = "nw_http2_remove_from_protocol_table";
          __int16 v30 = 2082;
          uint64_t v31 = a1 + 390;
          __int16 v32 = 2080;
          size_t v33 = " ";
          __int16 v34 = 1024;
          int v35 = v23;
          __int16 v36 = 2048;
          uint64_t v37 = a2;
          int v18 = "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table, no backtrace";
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v15 = gconnectionLogObj;
          os_log_type_t v16 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_47;
          }
          int v22 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)int buf = 136447234;
          int v29 = "nw_http2_remove_from_protocol_table";
          __int16 v30 = 2082;
          uint64_t v31 = a1 + 390;
          __int16 v32 = 2080;
          size_t v33 = " ";
          __int16 v34 = 1024;
          int v35 = v22;
          __int16 v36 = 2048;
          uint64_t v37 = a2;
          int v18 = "%{public}s %{public}s%s<i%u> failed to remove protocol node for protocol %p from table, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v15, v16, v18, buf, 0x30u);
        goto LABEL_47;
      }
      return 0;
    }
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v9 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v12 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447234;
      int v29 = "nw_http2_remove_from_protocol_table";
      __int16 v30 = 2082;
      uint64_t v31 = a1 + 390;
      __int16 v32 = 2080;
      size_t v33 = " ";
      __int16 v34 = 1024;
      int v35 = v12;
      __int16 v36 = 2048;
      uint64_t v37 = a2;
      char v11 = "%{public}s %{public}s%s<i%u> protocol %p is not present in id based table, cannot remove";
      goto LABEL_23;
    }
  }
  else
  {
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v9 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v10 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447234;
      int v29 = "nw_http2_remove_from_protocol_table";
      __int16 v30 = 2082;
      uint64_t v31 = a1 + 390;
      __int16 v32 = 2080;
      size_t v33 = " ";
      __int16 v34 = 1024;
      int v35 = v10;
      __int16 v36 = 2048;
      uint64_t v37 = a2;
      char v11 = "%{public}s %{public}s%s<i%u> protocol based table is NULL, cannot remove protocol %p";
LABEL_23:
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, v11, buf, 0x30u);
      return 0;
    }
  }
  return result;
}

uint64_t nw_http2_add_to_protocol_table(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v42 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v44 = *(_DWORD *)(a3 + 176);
        int v43 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)int buf = 136447746;
        BOOL v68 = "nw_http2_add_to_protocol_table";
        __int16 v69 = 2082;
        BOOL v70 = (char *)(a3 + 191);
        __int16 v71 = 2080;
        uint64_t v72 = " ";
        __int16 v73 = 1024;
        int v74 = v43;
        __int16 v75 = 1024;
        *(_DWORD *)int v76 = v44;
        *(_WORD *)&v76[4] = 2048;
        *(void *)&v76[6] = a2;
        *(_WORD *)&unsigned char v76[14] = 1024;
        *(_DWORD *)&v76[16] = v44;
        BOOL v39 = "%{public}s %{public}s%s<i%u:s%d> called for protocol %p, stream %d";
        uint64_t v40 = v42;
        uint32_t v41 = 60;
        goto LABEL_70;
      }
    }
  }
  else if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v37 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v38 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447490;
      BOOL v68 = "nw_http2_add_to_protocol_table";
      __int16 v69 = 2082;
      BOOL v70 = (char *)(a1 + 390);
      __int16 v71 = 2080;
      uint64_t v72 = " ";
      __int16 v73 = 1024;
      int v74 = v38;
      __int16 v75 = 2048;
      *(void *)int v76 = a2;
      *(_WORD *)&v76[8] = 1024;
      *(_DWORD *)&v76[10] = -999;
      BOOL v39 = "%{public}s %{public}s%s<i%u> called for protocol %p, stream %d";
      uint64_t v40 = v37;
      uint32_t v41 = 54;
LABEL_70:
      _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEBUG, v39, buf, v41);
    }
  }
  char v66 = 0;
  uint64_t internal = *(void *)(a1 + 152);
  if (internal) {
    goto LABEL_7;
  }
  uint64_t internal = nw_hash_table_create_internal(0x11u, 8, (const void *(*)(const void *, unsigned int *))nw_http2_get_key, (unsigned int (*)(const void *, unsigned int))nw_http2_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_http2_matches_key, 0);
  if (!internal)
  {
    *(void *)(a1 + 152) = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    BOOL v68 = "nw_http2_add_to_protocol_table";
    int v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (!__nwlog_fault(v21, &type, &v64)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = gLogObj;
      os_log_type_t v23 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v68 = "nw_http2_add_to_protocol_table";
      uint64_t v24 = "%{public}s nw_hash_table_create_no_lock failed";
    }
    else
    {
      if (v64)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v26 = gLogObj;
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)int buf = 136446466;
            BOOL v68 = "nw_http2_add_to_protocol_table";
            __int16 v69 = 2082;
            BOOL v70 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s nw_hash_table_create_no_lock failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v28)
        {
          *(_DWORD *)int buf = 136446210;
          BOOL v68 = "nw_http2_add_to_protocol_table";
          uint64_t v24 = "%{public}s nw_hash_table_create_no_lock failed, no backtrace";
          __int16 v34 = v26;
          os_log_type_t v35 = v27;
          goto LABEL_52;
        }
LABEL_53:
        if (v21)
        {
          size_t v33 = (char *)v21;
          goto LABEL_55;
        }
        return 0;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = gLogObj;
      os_log_type_t v23 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_53;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v68 = "nw_http2_add_to_protocol_table";
      uint64_t v24 = "%{public}s nw_hash_table_create_no_lock failed, backtrace limit exceeded";
    }
    __int16 v34 = v22;
    os_log_type_t v35 = v23;
LABEL_52:
    _os_log_impl(&dword_1830D4000, v34, v35, v24, buf, 0xCu);
    goto LABEL_53;
  }
  *(_DWORD *)(internal + 48) &= ~2u;
  *(void *)(a1 + 152) = internal;
LABEL_7:
  BOOL v7 = nw_hash_table_add_object(internal, a2, &v66);
  if (!v66)
  {
    if (a3)
    {
      if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) != 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v10 = *(_DWORD *)(a3 + 176);
      int v9 = *(_DWORD *)(a3 + 180);
      *(_DWORD *)int buf = 136447746;
      BOOL v68 = "nw_http2_add_to_protocol_table";
      __int16 v69 = 2082;
      BOOL v70 = (char *)(a3 + 191);
      __int16 v71 = 2080;
      uint64_t v72 = " ";
      __int16 v73 = 1024;
      int v74 = v9;
      __int16 v75 = 1024;
      *(_DWORD *)int v76 = v10;
      *(_WORD *)&v76[4] = 1042;
      *(_DWORD *)&v76[6] = 16;
      *(_WORD *)&v76[10] = 2098;
      *(void *)&v76[12] = a2;
      char v11 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v64 = 0;
      if (!__nwlog_fault(v11, &type, &v64)) {
        goto LABEL_47;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v12 = gconnectionLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          int v15 = *(_DWORD *)(a3 + 176);
          int v14 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)int buf = 136447746;
          BOOL v68 = "nw_http2_add_to_protocol_table";
          __int16 v69 = 2082;
          BOOL v70 = (char *)(a3 + 191);
          __int16 v71 = 2080;
          uint64_t v72 = " ";
          __int16 v73 = 1024;
          int v74 = v14;
          __int16 v75 = 1024;
          *(_DWORD *)int v76 = v15;
          *(_WORD *)&v76[4] = 1042;
          *(_DWORD *)&v76[6] = 16;
          *(_WORD *)&v76[10] = 2098;
          *(void *)&v76[12] = a2;
          os_log_type_t v16 = "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P";
LABEL_46:
          _os_log_impl(&dword_1830D4000, v12, v13, v16, buf, 0x3Cu);
        }
      }
      else if (v64)
      {
        int v17 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v12 = gconnectionLogObj;
        os_log_type_t v13 = type;
        BOOL v18 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (!v17)
        {
          if (!v18) {
            goto LABEL_47;
          }
          int v32 = *(_DWORD *)(a3 + 176);
          int v31 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)int buf = 136447746;
          BOOL v68 = "nw_http2_add_to_protocol_table";
          __int16 v69 = 2082;
          BOOL v70 = (char *)(a3 + 191);
          __int16 v71 = 2080;
          uint64_t v72 = " ";
          __int16 v73 = 1024;
          int v74 = v31;
          __int16 v75 = 1024;
          *(_DWORD *)int v76 = v32;
          *(_WORD *)&v76[4] = 1042;
          *(_DWORD *)&v76[6] = 16;
          *(_WORD *)&v76[10] = 2098;
          *(void *)&v76[12] = a2;
          os_log_type_t v16 = "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P, no backtrace";
          goto LABEL_46;
        }
        if (v18)
        {
          int v20 = *(_DWORD *)(a3 + 176);
          int v19 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)int buf = 136448002;
          BOOL v68 = "nw_http2_add_to_protocol_table";
          __int16 v69 = 2082;
          BOOL v70 = (char *)(a3 + 191);
          __int16 v71 = 2080;
          uint64_t v72 = " ";
          __int16 v73 = 1024;
          int v74 = v19;
          __int16 v75 = 1024;
          *(_DWORD *)int v76 = v20;
          *(_WORD *)&v76[4] = 1042;
          *(_DWORD *)&v76[6] = 16;
          *(_WORD *)&v76[10] = 2098;
          *(void *)&v76[12] = a2;
          *(_WORD *)&v76[20] = 2082;
          *(void *)&v76[22] = v17;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x46u);
        }
        free(v17);
      }
      else
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v12 = gconnectionLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
        {
          int v30 = *(_DWORD *)(a3 + 176);
          int v29 = *(_DWORD *)(a3 + 180);
          *(_DWORD *)int buf = 136447746;
          BOOL v68 = "nw_http2_add_to_protocol_table";
          __int16 v69 = 2082;
          BOOL v70 = (char *)(a3 + 191);
          __int16 v71 = 2080;
          uint64_t v72 = " ";
          __int16 v73 = 1024;
          int v74 = v29;
          __int16 v75 = 1024;
          *(_DWORD *)int v76 = v30;
          *(_WORD *)&v76[4] = 1042;
          *(_DWORD *)&v76[6] = 16;
          *(_WORD *)&v76[10] = 2098;
          *(void *)&v76[12] = a2;
          os_log_type_t v16 = "%{public}s %{public}s%s<i%u:s%d> http2 already has input handler registered for %{public,uuid_t}.16P, ba"
                "cktrace limit exceeded";
          goto LABEL_46;
        }
      }
LABEL_47:
      if (v11)
      {
        size_t v33 = (char *)v11;
LABEL_55:
        free(v33);
        return 0;
      }
      return 0;
    }
    if (*(__int16 *)(a1 + 388) < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v53 = *(_DWORD *)(a1 + 368);
    *(_DWORD *)int buf = 136447490;
    BOOL v68 = "nw_http2_add_to_protocol_table";
    __int16 v69 = 2082;
    BOOL v70 = (char *)(a1 + 390);
    __int16 v71 = 2080;
    uint64_t v72 = " ";
    __int16 v73 = 1024;
    int v74 = v53;
    __int16 v75 = 1042;
    *(_DWORD *)int v76 = 16;
    *(_WORD *)&v76[4] = 2098;
    *(void *)&v76[6] = a2;
    uint64_t v54 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v64 = 0;
    if (__nwlog_fault(v54, &type, &v64))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v55 = gconnectionLogObj;
        os_log_type_t v56 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_108;
        }
        int v57 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)int buf = 136447490;
        BOOL v68 = "nw_http2_add_to_protocol_table";
        __int16 v69 = 2082;
        BOOL v70 = (char *)(a1 + 390);
        __int16 v71 = 2080;
        uint64_t v72 = " ";
        __int16 v73 = 1024;
        int v74 = v57;
        __int16 v75 = 1042;
        *(_DWORD *)int v76 = 16;
        *(_WORD *)&v76[4] = 2098;
        *(void *)&v76[6] = a2;
        int v58 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P";
        goto LABEL_107;
      }
      if (!v64)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v55 = gconnectionLogObj;
        os_log_type_t v56 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_108;
        }
        int v62 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)int buf = 136447490;
        BOOL v68 = "nw_http2_add_to_protocol_table";
        __int16 v69 = 2082;
        BOOL v70 = (char *)(a1 + 390);
        __int16 v71 = 2080;
        uint64_t v72 = " ";
        __int16 v73 = 1024;
        int v74 = v62;
        __int16 v75 = 1042;
        *(_DWORD *)int v76 = 16;
        *(_WORD *)&v76[4] = 2098;
        *(void *)&v76[6] = a2;
        int v58 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, backtrac"
              "e limit exceeded";
        goto LABEL_107;
      }
      __int16 v59 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v55 = gconnectionLogObj;
      os_log_type_t v56 = type;
      BOOL v60 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v59)
      {
        if (v60)
        {
          int v61 = *(_DWORD *)(a1 + 368);
          *(_DWORD *)int buf = 136447746;
          BOOL v68 = "nw_http2_add_to_protocol_table";
          __int16 v69 = 2082;
          BOOL v70 = (char *)(a1 + 390);
          __int16 v71 = 2080;
          uint64_t v72 = " ";
          __int16 v73 = 1024;
          int v74 = v61;
          __int16 v75 = 1042;
          *(_DWORD *)int v76 = 16;
          *(_WORD *)&v76[4] = 2098;
          *(void *)&v76[6] = a2;
          *(_WORD *)&unsigned char v76[14] = 2082;
          *(void *)&v76[16] = v59;
          _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v59);
        goto LABEL_108;
      }
      if (v60)
      {
        int v63 = *(_DWORD *)(a1 + 368);
        *(_DWORD *)int buf = 136447490;
        BOOL v68 = "nw_http2_add_to_protocol_table";
        __int16 v69 = 2082;
        BOOL v70 = (char *)(a1 + 390);
        __int16 v71 = 2080;
        uint64_t v72 = " ";
        __int16 v73 = 1024;
        int v74 = v63;
        __int16 v75 = 1042;
        *(_DWORD *)int v76 = 16;
        *(_WORD *)&v76[4] = 2098;
        *(void *)&v76[6] = a2;
        int v58 = "%{public}s %{public}s%s<i%u> http2 already has input handler registered for %{public,uuid_t}.16P, no backtrace";
LABEL_107:
        _os_log_impl(&dword_1830D4000, v55, v56, v58, buf, 0x36u);
      }
    }
LABEL_108:
    if (!v54) {
      return 0;
    }
    size_t v33 = (char *)v54;
    goto LABEL_55;
  }
  uint64_t v8 = v7;
  if (a3)
  {
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v47 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v49 = *(_DWORD *)(a3 + 176);
        int v48 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)int buf = 136447490;
        BOOL v68 = "nw_http2_add_to_protocol_table";
        __int16 v69 = 2082;
        BOOL v70 = (char *)(a3 + 191);
        __int16 v71 = 2080;
        uint64_t v72 = " ";
        __int16 v73 = 1024;
        int v74 = v48;
        __int16 v75 = 1024;
        *(_DWORD *)int v76 = v49;
        *(_WORD *)&v76[4] = 2048;
        *(void *)&v76[6] = a2;
        _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> added protocol %p to protocol hash table", buf, 0x36u);
      }
    }
    if (((*(unsigned __int16 *)(a3 + 188) | (*(unsigned __int8 *)(a3 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v50 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v52 = *(_DWORD *)(a3 + 176);
        int v51 = *(_DWORD *)(a3 + 180);
        *(_DWORD *)int buf = 136448002;
        BOOL v68 = "nw_http2_add_to_protocol_table";
        __int16 v69 = 2082;
        BOOL v70 = (char *)(a3 + 191);
        __int16 v71 = 2080;
        uint64_t v72 = " ";
        __int16 v73 = 1024;
        int v74 = v51;
        __int16 v75 = 1024;
        *(_DWORD *)int v76 = v52;
        *(_WORD *)&v76[4] = 2048;
        *(void *)&v76[6] = a2;
        *(_WORD *)&unsigned char v76[14] = 2048;
        *(void *)&v76[16] = v8;
        *(_WORD *)&v76[24] = 2048;
        *(void *)&v76[26] = a3;
        _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> connecting protocol %p node %p with stream %p", buf, 0x4Au);
      }
    }
    *(void *)nw_hash_node_get_extra(v8) = a3;
  }
  else if ((*(__int16 *)(a1 + 388) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v45 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v46 = *(_DWORD *)(a1 + 368);
      *(_DWORD *)int buf = 136447234;
      BOOL v68 = "nw_http2_add_to_protocol_table";
      __int16 v69 = 2082;
      BOOL v70 = (char *)(a1 + 390);
      __int16 v71 = 2080;
      uint64_t v72 = " ";
      __int16 v73 = 1024;
      int v74 = v46;
      __int16 v75 = 2048;
      *(void *)int v76 = a2;
      _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> added protocol %p to protocol hash table", buf, 0x30u);
    }
  }
  return v8;
}

BOOL nw_http2_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

void nw_http2_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
}

BOOL nw_protocol_http2_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v112 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
    BOOL v68 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v68, &type, &v98)) {
      goto LABEL_207;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (!os_log_type_enabled(v69, type)) {
        goto LABEL_207;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_protocol_http2_remove_input_handler";
      __int16 v71 = "%{public}s called with null protocol";
LABEL_206:
      _os_log_impl(&dword_1830D4000, v69, v70, v71, buf, 0xCu);
      goto LABEL_207;
    }
    if (!v98)
    {
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v69 = __nwlog_obj();
    os_log_type_t v70 = type;
    BOOL v81 = os_log_type_enabled(v69, type);
    if (!backtrace_string)
    {
      if (v81)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    if (!v81) {
      goto LABEL_163;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
    __int16 v102 = 2082;
    int v103 = backtrace_string;
    uint64_t v82 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_162:
    _os_log_impl(&dword_1830D4000, v69, v70, v82, buf, 0x16u);
    goto LABEL_163;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
    BOOL v68 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v68, &type, &v98)) {
      goto LABEL_207;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (!os_log_type_enabled(v69, type)) {
        goto LABEL_207;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_protocol_http2_remove_input_handler";
      __int16 v71 = "%{public}s called with null http2";
      goto LABEL_206;
    }
    if (!v98)
    {
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v69 = __nwlog_obj();
    os_log_type_t v70 = type;
    BOOL v83 = os_log_type_enabled(v69, type);
    if (!backtrace_string)
    {
      if (v83)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null http2, no backtrace";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    if (!v83) {
      goto LABEL_163;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
    __int16 v102 = 2082;
    int v103 = backtrace_string;
    uint64_t v82 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_162;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
    BOOL v68 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v68, &type, &v98)) {
      goto LABEL_207;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null input_protocol";
        goto LABEL_206;
      }
LABEL_207:
      if (!v68) {
        return 0;
      }
      uint64_t v67 = (char *)v68;
      goto LABEL_119;
    }
    if (!v98)
    {
      __int16 v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null input_protocol, backtrace limit exceeded";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v69 = __nwlog_obj();
    os_log_type_t v70 = type;
    BOOL v84 = os_log_type_enabled(v69, type);
    if (!backtrace_string)
    {
      if (v84)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v101 = "nw_protocol_http2_remove_input_handler";
        __int16 v71 = "%{public}s called with null input_protocol, no backtrace";
        goto LABEL_206;
      }
      goto LABEL_207;
    }
    if (v84)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v101 = "nw_protocol_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = backtrace_string;
      uint64_t v82 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
      goto LABEL_162;
    }
LABEL_163:
    free(backtrace_string);
    goto LABEL_207;
  }
  p_cache = NWConcrete_nw_resolution_report.cache;
  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v76 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v77 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447234;
      uint64_t v101 = "nw_protocol_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = handle + 390;
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v77;
      __int16 v108 = 2048;
      *(void *)int v109 = a2;
      _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called with input_protocol %p", buf, 0x30u);
    }
  }
  unsigned int v6 = (char *)a1->handle;
  if (!v6)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v101 = "nw_http2_remove_input_handler";
    uint64_t v72 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v72, &type, &v98)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_214;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v75 = "%{public}s called with null http2";
      goto LABEL_213;
    }
    if (!v98)
    {
      __int16 v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_214;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v75 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_213;
    }
    int v85 = (char *)__nw_create_backtrace_string();
    __int16 v73 = __nwlog_obj();
    os_log_type_t v74 = type;
    BOOL v86 = os_log_type_enabled(v73, type);
    if (!v85)
    {
      if (!v86) {
        goto LABEL_214;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v75 = "%{public}s called with null http2, no backtrace";
      goto LABEL_213;
    }
    if (v86)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = v85;
      _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v85);
LABEL_214:
    if (!v72) {
      goto LABEL_20;
    }
    goto LABEL_215;
  }
  if (!*((void *)handle + 19))
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v101 = "nw_http2_remove_input_handler";
    uint64_t v72 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v72, &type, &v98)) {
      goto LABEL_214;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_214;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v75 = "%{public}s called with null table";
      goto LABEL_213;
    }
    if (!v98)
    {
      __int16 v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_214;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v75 = "%{public}s called with null table, backtrace limit exceeded";
      goto LABEL_213;
    }
    uint64_t v87 = (char *)__nw_create_backtrace_string();
    __int16 v73 = __nwlog_obj();
    os_log_type_t v74 = type;
    BOOL v88 = os_log_type_enabled(v73, type);
    if (v87)
    {
      if (v88)
      {
        *(_DWORD *)int buf = 136446466;
        uint64_t v101 = "nw_http2_remove_input_handler";
        __int16 v102 = 2082;
        int v103 = v87;
        _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v87);
      if (!v72) {
        goto LABEL_20;
      }
LABEL_215:
      free(v72);
      goto LABEL_20;
    }
    if (v88)
    {
      *(_DWORD *)int buf = 136446210;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v75 = "%{public}s called with null table, no backtrace";
LABEL_213:
      _os_log_impl(&dword_1830D4000, v73, v74, v75, buf, 0xCu);
      goto LABEL_214;
    }
    goto LABEL_214;
  }
  if ((*((__int16 *)v6 + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v78 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v79 = *((_DWORD *)v6 + 92);
      *(_DWORD *)int buf = 136446978;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = v6 + 390;
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v79;
      _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    uint64_t v8 = output_handler_context[4];
    if (v8)
    {
      nw_http_transaction_metadata_mark_end(*(void **)(v8 + 96));
      int v9 = *(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16);
      int v10 = *(_WORD *)(v8 + 188) & 0xFFFB | (*(unsigned __int8 *)(v8 + 190) << 16);
      *(_WORD *)(v8 + 188) &= ~4u;
      *(unsigned char *)(v8 + 190) = BYTE2(v10);
      if ((v9 & 1) != 0 || *(_DWORD *)(v8 + 176) != -1)
      {
        nw_http2_stream_close((uint64_t)v6, v8);
        goto LABEL_36;
      }
      if ((v9 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v22 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v24 = *(_DWORD *)(v8 + 176);
          int v23 = *(_DWORD *)(v8 + 180);
          *(_DWORD *)int buf = 136447234;
          uint64_t v101 = "nw_http2_remove_input_handler";
          __int16 v102 = 2082;
          int v103 = (char *)(v8 + 191);
          __int16 v104 = 2080;
          uint64_t v105 = " ";
          __int16 v106 = 1024;
          int v107 = v23;
          __int16 v108 = 1024;
          *(_DWORD *)int v109 = v24;
          BOOL v18 = "%{public}s %{public}s%s<i%u:s%d> not closing already closed stream";
          int v19 = v22;
          os_log_type_t v20 = OS_LOG_TYPE_DEBUG;
          uint32_t v21 = 44;
          goto LABEL_35;
        }
      }
    }
    else if ((*((__int16 *)v6 + 194) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v16 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v17 = *((_DWORD *)v6 + 92);
        *(_DWORD *)int buf = 136446978;
        uint64_t v101 = "nw_http2_remove_input_handler";
        __int16 v102 = 2082;
        int v103 = v6 + 390;
        __int16 v104 = 2080;
        uint64_t v105 = " ";
        __int16 v106 = 1024;
        int v107 = v17;
        BOOL v18 = "%{public}s %{public}s%s<i%u> stream not found as extra";
        int v19 = v16;
        os_log_type_t v20 = OS_LOG_TYPE_ERROR;
        uint32_t v21 = 38;
LABEL_35:
        _os_log_impl(&dword_1830D4000, v19, v20, v18, buf, v21);
      }
    }
LABEL_36:
    if (nw_http2_remove_from_protocol_table((uint64_t)v6, (uint64_t)a2))
    {
      nw_protocol_set_output_handler((uint64_t)a2, 0);
      if (!v8)
      {
        if (*((__int16 *)v6 + 194) < 0) {
          goto LABEL_63;
        }
        goto LABEL_39;
      }
    }
    else
    {
      if (!v8)
      {
        if ((*((__int16 *)v6 + 194) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v89 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            int v90 = *((_DWORD *)v6 + 92);
            *(_DWORD *)int buf = 136447234;
            uint64_t v101 = "nw_http2_remove_input_handler";
            __int16 v102 = 2082;
            int v103 = v6 + 390;
            __int16 v104 = 2080;
            uint64_t v105 = " ";
            __int16 v106 = 1024;
            int v107 = v90;
            __int16 v108 = 2048;
            *(void *)int v109 = a2;
            _os_log_impl(&dword_1830D4000, v89, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> unable to remove protocol %p from protocol table", buf, 0x30u);
          }
        }
        nw_protocol_set_output_handler((uint64_t)a2, 0);
        if (*((__int16 *)v6 + 194) < 0)
        {
LABEL_63:
          uint64_t v43 = *((void *)handle + 19);
          if (v43)
          {
            if ((*((_WORD *)handle + 194) & 0xC) == 0 && a1->default_input_handler == a2)
            {
              if ((*((_WORD *)handle + 194) & 0x8000) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v44 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  int v45 = *((_DWORD *)handle + 92);
                  *(_DWORD *)int buf = 136446978;
                  uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                  __int16 v102 = 2082;
                  int v103 = handle + 390;
                  __int16 v104 = 2080;
                  uint64_t v105 = " ";
                  __int16 v106 = 1024;
                  int v107 = v45;
                  _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> first input handler bailed, closing", buf, 0x26u);
                }
              }
              *((_WORD *)handle + 194) |= 8u;
              nw_protocol_remove_instance((uint64_t)a1);
              nw_protocol_http2_notify((uint64_t)a1, (uint64_t)a1, 0x16u, 0, 0);
              uint64_t v43 = *((void *)handle + 19);
            }
            int v46 = nw_hash_table_count(v43);
            BOOL v48 = *((__int16 *)handle + 194) < 0 || *((unsigned char *)p_cache + 3665) == 0;
            if (v46)
            {
              if (!v48)
              {
                int v91 = v46;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v92 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v93 = *((_DWORD *)handle + 92);
                  *(_DWORD *)int buf = 136447234;
                  uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                  __int16 v102 = 2082;
                  int v103 = handle + 390;
                  __int16 v104 = 2080;
                  uint64_t v105 = " ";
                  __int16 v106 = 1024;
                  int v107 = v93;
                  __int16 v108 = 1024;
                  *(_DWORD *)int v109 = v91;
                  _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> not destroying, still have %u input handlers", buf, 0x2Cu);
                }
              }
              if (a1->default_input_handler == a2)
              {
                nw_protocol_set_input_handler((uint64_t)a1, 0);
                int v49 = (char *)*((void *)handle + 19);
                v96[0] = MEMORY[0x1E4F143A8];
                v96[1] = 0x40000000;
                v96[2] = ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke_61;
                v96[3] = &__block_descriptor_tmp_62_84765;
                v96[4] = a1;
                v96[5] = handle;
                nw_hash_table_apply(v49, (uint64_t)v96);
              }
            }
            else
            {
              if (!v48)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v94 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
                {
                  int v95 = *((_DWORD *)handle + 92);
                  *(_DWORD *)int buf = 136446978;
                  uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                  __int16 v102 = 2082;
                  int v103 = handle + 390;
                  __int16 v104 = 2080;
                  uint64_t v105 = " ";
                  __int16 v106 = 1024;
                  int v107 = v95;
                  _os_log_impl(&dword_1830D4000, v94, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> no more input handlers, scheduling destroy", buf, 0x26u);
                }
              }
              nw_protocol_set_input_handler((uint64_t)a1, 0);
              nw_frame_cache_remove_all((uint64_t *)handle + 25);
              uint64_t v56 = *((void *)handle + 11);
              if (v56) {
                nw_queue_cancel_source(v56);
              }
              v97[0] = MEMORY[0x1E4F143A8];
              v97[1] = 0x40000000;
              v97[2] = ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke;
              v97[3] = &__block_descriptor_tmp_60_84762;
              v97[4] = a1;
              *((void *)handle + 11) = nw_queue_context_create_source(0, 2, 3, 0, v97, 0);
              uint64_t v57 = *((void *)handle + 10);
              if (!nw_protocol_http2_accept((uint64_t)a1))
              {
                if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  int v58 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
                  {
                    int v59 = *((_DWORD *)handle + 92);
                    *(_DWORD *)int buf = 136446978;
                    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                    __int16 v102 = 2082;
                    int v103 = handle + 390;
                    __int16 v104 = 2080;
                    uint64_t v105 = " ";
                    __int16 v106 = 1024;
                    int v107 = v59;
                    _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> cannot accept input handlers, destroying immediately", buf, 0x26u);
                  }
                }
                uint64_t v57 = 0;
              }
              uint64_t v60 = *((void *)handle + 11);
              dispatch_time_t v61 = dispatch_time(0x8000000000000000, 1000000 * v57);
              nw_queue_set_timer_values(v60, v61, 0xFFFFFFFFFFFFFFFFLL, 1000 * v57);
              nw_queue_activate_source(*((void *)handle + 11));
            }
            return 1;
          }
          if ((*((_WORD *)handle + 194) & 0x8000) != 0) {
            return 0;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v50 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136447234;
          uint64_t v101 = "nw_protocol_http2_remove_input_handler";
          __int16 v102 = 2082;
          int v103 = handle + 390;
          __int16 v104 = 2080;
          uint64_t v105 = " ";
          __int16 v106 = 1024;
          int v107 = v50;
          __int16 v108 = 2048;
          *(void *)int v109 = a2;
          int v51 = (const char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v98 = 0;
          if (__nwlog_fault(v51, &type, &v98))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v52 = gconnectionLogObj;
              os_log_type_t v53 = type;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
              {
                int v54 = *((_DWORD *)handle + 92);
                *(_DWORD *)int buf = 136447234;
                uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                __int16 v102 = 2082;
                int v103 = handle + 390;
                __int16 v104 = 2080;
                uint64_t v105 = " ";
                __int16 v106 = 1024;
                int v107 = v54;
                __int16 v108 = 2048;
                *(void *)int v109 = a2;
                __int16 v55 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p";
LABEL_116:
                _os_log_impl(&dword_1830D4000, v52, v53, v55, buf, 0x30u);
              }
            }
            else if (v98)
            {
              int v62 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v52 = gconnectionLogObj;
              os_log_type_t v53 = type;
              BOOL v63 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
              if (!v62)
              {
                if (!v63) {
                  goto LABEL_117;
                }
                int v66 = *((_DWORD *)handle + 92);
                *(_DWORD *)int buf = 136447234;
                uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                __int16 v102 = 2082;
                int v103 = handle + 390;
                __int16 v104 = 2080;
                uint64_t v105 = " ";
                __int16 v106 = 1024;
                int v107 = v66;
                __int16 v108 = 2048;
                *(void *)int v109 = a2;
                __int16 v55 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p, no backtrace";
                goto LABEL_116;
              }
              if (v63)
              {
                int v64 = *((_DWORD *)handle + 92);
                *(_DWORD *)int buf = 136447490;
                uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                __int16 v102 = 2082;
                int v103 = handle + 390;
                __int16 v104 = 2080;
                uint64_t v105 = " ";
                __int16 v106 = 1024;
                int v107 = v64;
                __int16 v108 = 2048;
                *(void *)int v109 = a2;
                *(_WORD *)&v109[8] = 2082;
                *(void *)&v109[10] = v62;
                _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p, dumping backtrace:%{public}s", buf, 0x3Au);
              }
              free(v62);
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v52 = gconnectionLogObj;
              os_log_type_t v53 = type;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
              {
                int v65 = *((_DWORD *)handle + 92);
                *(_DWORD *)int buf = 136447234;
                uint64_t v101 = "nw_protocol_http2_remove_input_handler";
                __int16 v102 = 2082;
                int v103 = handle + 390;
                __int16 v104 = 2080;
                uint64_t v105 = " ";
                __int16 v106 = 1024;
                int v107 = v65;
                __int16 v108 = 2048;
                *(void *)int v109 = a2;
                __int16 v55 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when removing input handler %p, backtrace limit exceeded";
                goto LABEL_116;
              }
            }
          }
LABEL_117:
          if (v51)
          {
            uint64_t v67 = (char *)v51;
LABEL_119:
            free(v67);
          }
          return 0;
        }
LABEL_39:
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v25 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v26 = *((_DWORD *)v6 + 92);
          int v27 = nw_hash_table_count(*((void *)v6 + 19));
          *(_DWORD *)int buf = 136447490;
          uint64_t v101 = "nw_http2_remove_input_handler";
          __int16 v102 = 2082;
          int v103 = v6 + 390;
          __int16 v104 = 2080;
          uint64_t v105 = " ";
          __int16 v106 = 1024;
          int v107 = v26;
          __int16 v108 = 2048;
          *(void *)int v109 = a2;
          *(_WORD *)&v109[8] = 1024;
          *(_DWORD *)&v109[10] = v27;
          _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> removed input handler %p, now have %u input handlers", buf, 0x36u);
        }
        goto LABEL_63;
      }
      if (((*(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16)) & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v28 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v30 = *(_DWORD *)(v8 + 176);
          int v29 = *(_DWORD *)(v8 + 180);
          *(_DWORD *)int buf = 136447490;
          uint64_t v101 = "nw_http2_remove_input_handler";
          __int16 v102 = 2082;
          int v103 = (char *)(v8 + 191);
          __int16 v104 = 2080;
          uint64_t v105 = " ";
          __int16 v106 = 1024;
          int v107 = v29;
          __int16 v108 = 1024;
          *(_DWORD *)int v109 = v30;
          *(_WORD *)&v109[4] = 2048;
          *(void *)&v109[6] = a2;
          _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> unable to remove protocol %p from protocol table", buf, 0x36u);
        }
      }
      nw_protocol_set_output_handler((uint64_t)a2, 0);
    }
    int v31 = *(unsigned __int16 *)(v8 + 188) | (*(unsigned __int8 *)(v8 + 190) << 16);
    if (*(unsigned char *)(v8 + 191))
    {
      if ((v31 & 0x80000) != 0) {
        goto LABEL_62;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v32 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_62;
      }
      int v33 = *(_DWORD *)(v8 + 176);
      int v34 = *(_DWORD *)(v8 + 180);
      int v35 = nw_hash_table_count(*((void *)v6 + 19));
      *(_DWORD *)int buf = 136448002;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = (char *)(v8 + 191);
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v34;
      p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
      __int16 v108 = 1024;
      *(_DWORD *)int v109 = v33;
      *(_WORD *)&v109[4] = 2048;
      *(void *)&v109[6] = a2;
      *(_WORD *)&v109[14] = 2080;
      *(void *)&v109[16] = v8 + 191;
      __int16 v110 = 1024;
      int v111 = v35;
      __int16 v36 = "%{public}s %{public}s%s<i%u:s%d> removed input handler %p, originally from %s, now have %u input handlers";
      uint64_t v37 = v32;
      uint32_t v38 = 70;
    }
    else
    {
      if ((v31 & 0x80000) != 0) {
        goto LABEL_62;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v39 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_62;
      }
      int v41 = *(_DWORD *)(v8 + 176);
      int v40 = *(_DWORD *)(v8 + 180);
      int v42 = nw_hash_table_count(*((void *)v6 + 19));
      *(_DWORD *)int buf = 136447746;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = (char *)(v8 + 191);
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v40;
      __int16 v108 = 1024;
      *(_DWORD *)int v109 = v41;
      p_cache = NWConcrete_nw_resolution_report.cache;
      *(_WORD *)&v109[4] = 2048;
      *(void *)&v109[6] = a2;
      *(_WORD *)&v109[14] = 1024;
      *(_DWORD *)&v109[16] = v42;
      __int16 v36 = "%{public}s %{public}s%s<i%u:s%d> removed input handler %p, now have %u input handlers";
      uint64_t v37 = v39;
      uint32_t v38 = 60;
    }
    _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, v36, buf, v38);
LABEL_62:
    nw_http2_stream_destroy((void **)v8);
    goto LABEL_63;
  }
  if ((*((__int16 *)v6 + 194) & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    char v11 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      int v12 = *((_DWORD *)v6 + 92);
      *(_DWORD *)int buf = 136447234;
      uint64_t v101 = "nw_http2_remove_input_handler";
      __int16 v102 = 2082;
      int v103 = v6 + 390;
      __int16 v104 = 2080;
      uint64_t v105 = " ";
      __int16 v106 = 1024;
      int v107 = v12;
      __int16 v108 = 2048;
      *(void *)int v109 = a2;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> output handler context doesn't exist on protocol %p", buf, 0x30u);
    }
  }
LABEL_20:
  if (*((__int16 *)handle + 194) < 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v13 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    int v15 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136447490;
    uint64_t v101 = "nw_protocol_http2_remove_input_handler";
    __int16 v102 = 2082;
    int v103 = handle + 390;
    __int16 v104 = 2080;
    uint64_t v105 = " ";
    __int16 v106 = 1024;
    int v107 = v15;
    __int16 v108 = 1042;
    *(_DWORD *)int v109 = 16;
    *(_WORD *)&v109[4] = 2098;
    *(void *)&v109[6] = a2;
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> http2 does not have input handler registered for %{public,uuid_t}.16P", buf, 0x36u);
    return 0;
  }
  return result;
}

void ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke(uint64_t a1)
{
  uint64_t v142 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
    uint64_t v2 = _os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v136 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault((const char *)v2, type, &v136)) {
      goto LABEL_220;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v82 = __nwlog_obj();
      os_log_type_t v83 = type[0];
      if (!os_log_type_enabled(v82, type[0])) {
        goto LABEL_220;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
      BOOL v84 = "%{public}s called with null protocol";
LABEL_219:
      _os_log_impl(&dword_1830D4000, v82, v83, v84, buf, 0xCu);
      goto LABEL_220;
    }
    if (v136 == OS_LOG_TYPE_DEFAULT)
    {
      uint64_t v82 = __nwlog_obj();
      os_log_type_t v83 = type[0];
      if (!os_log_type_enabled(v82, type[0])) {
        goto LABEL_220;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
      BOOL v84 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_219;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v82 = __nwlog_obj();
    os_log_type_t v83 = type[0];
    BOOL v98 = os_log_type_enabled(v82, type[0]);
    if (!backtrace_string)
    {
      if (!v98) {
        goto LABEL_220;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
      BOOL v84 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_219;
    }
    if (v98)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_220:
    if (!v2) {
      return;
    }
    goto LABEL_139;
  }
  uint64_t v2 = *(void *)(v1 + 40);
  if (v2)
  {
    p_cache = NWConcrete_nw_resolution_report.cache;
    if ((*(__int16 *)(v2 + 388) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v85 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v86 = *(_DWORD *)(v2 + 368);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v2 + 390;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v138) = 1024;
        *(_DWORD *)((char *)&v138 + 2) = v86;
        _os_log_impl(&dword_1830D4000, v85, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    uint64_t v4 = *(void *)(v2 + 88);
    if (v4)
    {
      nw_queue_cancel_source(v4);
      *(void *)(v2 + 88) = 0;
    }
    uint64_t v5 = *(void *)(v2 + 152);
    if (v5)
    {
      int v6 = *(_DWORD *)(v5 + 40);
      if (v6)
      {
        if ((*(__int16 *)(v2 + 388) & 0x80000000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v7 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v8 = *(_DWORD *)(v2 + 368);
            *(_DWORD *)int buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v2 + 390;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            LOWORD(v138) = 1024;
            *(_DWORD *)((char *)&v138 + 2) = v8;
            HIWORD(v138) = 2048;
            uint64_t v139 = v2;
            __int16 v140 = 1024;
            int v141 = v6;
            _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> not destroying http2 %p, still have %u input handlers", buf, 0x36u);
          }
        }
        return;
      }
      nw_protocol_set_input_handler(v1, 0);
      if ((*(__int16 *)(v2 + 388) & 0x80000000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v15 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          int v16 = *(_DWORD *)(v2 + 368);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v2 + 390;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          LOWORD(v138) = 1024;
          *(_DWORD *)((char *)&v138 + 2) = v16;
          _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> no more input handlers, destroying", buf, 0x26u);
        }
      }
      uint64_t v17 = *(void *)(v2 + 144);
      if (v17) {
        (*(void (**)(uint64_t, uint64_t, void))(*(void *)v17 + 8))(v17, v2, 0);
      }
      BOOL v18 = *(char **)(v2 + 160);
      if (v18)
      {
        *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
        uint64_t v132 = 0x40000000;
        uint64_t v133 = ___ZL25nw_protocol_http2_destroyP11nw_protocol_block_invoke;
        uint64_t v134 = &__block_descriptor_tmp_63_84784;
        uint64_t v135 = v2;
        nw_hash_table_apply(v18, (uint64_t)type);
        int v19 = *(os_unfair_lock_s **)(v2 + 160);
        if (v19)
        {
          _nw_hash_table_release(v19);
          *(void *)(v2 + 160) = 0;
        }
      }
      os_log_type_t v20 = *(os_unfair_lock_s **)(v2 + 152);
      if (v20)
      {
        _nw_hash_table_release(v20);
        *(void *)(v2 + 152) = 0;
      }
      if (gLogDatapath)
      {
        uint64_t v112 = __nwlog_obj();
        if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
          _os_log_impl(&dword_1830D4000, v112, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
        }
      }
      *(void *)int buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_83451;
      *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_33_83452;
      uint64_t v138 = v2 + 240;
      LOBYTE(v139) = 0;
      uint64_t v21 = *(void *)(v2 + 240);
      do
      {
        if (!v21) {
          break;
        }
        uint64_t v22 = *(void *)(v21 + 32);
        char v23 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
        uint64_t v21 = v22;
      }
      while ((v23 & 1) != 0);
      int v24 = &unk_183D5C000;
      if (!*(void *)(v2 + 168))
      {
LABEL_73:
        if (*((unsigned char *)p_cache + 3665))
        {
          os_log_type_t v113 = __nwlog_obj();
          if (os_log_type_enabled(v113, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_release_master_frame_array";
            _os_log_impl(&dword_1830D4000, v113, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
          }
        }
        *(void *)int buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke;
        *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_34_83454;
        uint64_t v138 = v2 + 168;
        uint64_t v42 = *(void *)(v2 + 168);
        do
        {
          if (!v42) {
            break;
          }
          uint64_t v43 = *(void *)(v42 + 16);
          char v44 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
          uint64_t v42 = v43;
        }
        while ((v44 & 1) != 0);
        if (!*(void *)(v2 + 184))
        {
LABEL_94:
          if (*((unsigned char *)p_cache + 3665))
          {
            uint32_t v114 = __nwlog_obj();
            if (os_log_type_enabled(v114, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)int buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_release_master_frame_array";
              _os_log_impl(&dword_1830D4000, v114, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
            }
          }
          *(void *)int buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 0x40000000;
          *(void *)&buf[16] = ___ZL38nw_protocol_release_master_frame_arrayP16nw_frame_array_s_block_invoke;
          *(void *)&unsigned char buf[24] = &__block_descriptor_tmp_34_83454;
          uint64_t v138 = v2 + 184;
          uint64_t v57 = *(void *)(v2 + 184);
          do
          {
            if (!v57) {
              break;
            }
            uint64_t v58 = *(void *)(v57 + 16);
            char v59 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
            uint64_t v57 = v58;
          }
          while ((v59 & 1) != 0);
          nw_frame_cache_destroy((uint64_t *)(v2 + 200));
          uint64_t v60 = *(void **)(v2 + 288);
          if (v60)
          {
            dispatch_time_t v61 = *(void **)(v2 + 296);
            if (v61) {
              nw_association_unregister(v60, v61);
            }
          }
          uint64_t v62 = *(void *)(v1 + 32);
          if (v62)
          {
            uint64_t v63 = *(void *)(v62 + 24);
            if (v63)
            {
              int v64 = *(void (**)(uint64_t, uint64_t))(v63 + 8);
              if (v64)
              {
                v64(v62, v1);
                goto LABEL_105;
              }
            }
          }
          __nwlog_obj();
          uint64_t v87 = *(void *)(v1 + 32);
          BOOL v88 = "invalid";
          if (v87)
          {
            __int16 v89 = *(const char **)(v87 + 16);
            if (v89) {
              BOOL v88 = v89;
            }
          }
          int v128 = v24[308];
          *(_DWORD *)int buf = v128;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v88;
          int v90 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t v136 = OS_LOG_TYPE_ERROR;
          char v130 = 0;
          if (__nwlog_fault(v90, &v136, &v130))
          {
            if (v136 == OS_LOG_TYPE_FAULT)
            {
              int v91 = __nwlog_obj();
              os_log_type_t v92 = v136;
              if (!os_log_type_enabled(v91, v136)) {
                goto LABEL_228;
              }
              uint64_t v93 = *(void *)(v1 + 32);
              int v94 = "invalid";
              if (v93)
              {
                int v95 = *(const char **)(v93 + 16);
                if (v95) {
                  int v94 = v95;
                }
              }
              *(_DWORD *)int buf = v128;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v94;
              uint64_t v96 = "%{public}s protocol %{public}s has invalid remove_input_handler callback";
              goto LABEL_227;
            }
            if (!v130)
            {
              int v91 = __nwlog_obj();
              os_log_type_t v92 = v136;
              if (!os_log_type_enabled(v91, v136)) {
                goto LABEL_228;
              }
              uint64_t v120 = *(void *)(v1 + 32);
              uint64_t v121 = "invalid";
              if (v120)
              {
                os_log_type_t v122 = *(const char **)(v120 + 16);
                if (v122) {
                  uint64_t v121 = v122;
                }
              }
              *(_DWORD *)int buf = v128;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v121;
              uint64_t v96 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, backtrace limit exceeded";
              goto LABEL_227;
            }
            uint64_t v101 = (char *)__nw_create_backtrace_string();
            int v91 = __nwlog_obj();
            os_log_type_t v92 = v136;
            BOOL v102 = os_log_type_enabled(v91, v136);
            if (v101)
            {
              if (v102)
              {
                uint64_t v103 = *(void *)(v1 + 32);
                __int16 v104 = "invalid";
                if (v103)
                {
                  uint64_t v105 = *(const char **)(v103 + 16);
                  if (v105) {
                    __int16 v104 = v105;
                  }
                }
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v104;
                *(_WORD *)&buf[22] = 2082;
                *(void *)&unsigned char buf[24] = v101;
                _os_log_impl(&dword_1830D4000, v91, v92, "%{public}s protocol %{public}s has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v101);
              goto LABEL_228;
            }
            if (v102)
            {
              uint64_t v123 = *(void *)(v1 + 32);
              uint32_t v124 = "invalid";
              if (v123)
              {
                uint64_t v125 = *(const char **)(v123 + 16);
                if (v125) {
                  uint32_t v124 = v125;
                }
              }
              *(_DWORD *)int buf = v128;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v124;
              uint64_t v96 = "%{public}s protocol %{public}s has invalid remove_input_handler callback, no backtrace";
LABEL_227:
              _os_log_impl(&dword_1830D4000, v91, v92, v96, buf, 0x16u);
            }
          }
LABEL_228:
          if (v90) {
            free(v90);
          }
LABEL_105:
          nw_protocol_remove_instance(v1);
          uint64_t v65 = *(void *)(v2 + 144);
          if (!v65)
          {
LABEL_110:
            nw_http_connection_metadata_closed(*(void **)(v2 + 256));
            for (i = *(void **)(v2 + 328); i; i = (void *)*i)
              (*(void (**)(void, void))(i[4] + 16))(i[4], 0);
            if (*(void *)(v2 + 336))
            {
              BOOL v68 = *(void **)(v2 + 328);
              while (v68)
              {
                BOOL v80 = v68;
                BOOL v68 = (void *)*v68;
                if (v80[5])
                {
                  BOOL v81 = (const void *)v80[4];
                  if (v81) {
                    _Block_release(v81);
                  }
                }
                operator delete(v80);
              }
              *(void *)(v2 + 328) = 0;
              uint64_t v69 = *(void *)(v2 + 320);
              if (v69)
              {
                for (uint64_t j = 0; j != v69; ++j)
                  *(void *)(*(void *)(v2 + 312) + 8 * j) = 0;
              }
              *(void *)(v2 + 336) = 0;
            }
            __int16 v71 = *(void **)(v2 + 104);
            if (v71)
            {
              os_release(v71);
              *(void *)(v2 + 104) = 0;
            }
            uint64_t v72 = *(void **)(v2 + 112);
            if (v72)
            {
              os_release(v72);
              *(void *)(v2 + 112) = 0;
            }
            __int16 v73 = *(void **)(v2 + 120);
            if (v73)
            {
              os_release(v73);
              *(void *)(v2 + 120) = 0;
            }
            os_log_type_t v74 = *(void **)(v2 + 256);
            if (v74)
            {
              os_release(v74);
              *(void *)(v2 + 256) = 0;
            }
            __int16 v75 = *(void **)(v2 + 280);
            if (v75)
            {
              os_release(v75);
              *(void *)(v2 + 280) = 0;
            }
            int v76 = *(void **)(v2 + 288);
            if (v76)
            {
              os_release(v76);
              *(void *)(v2 + 288) = 0;
            }
            int v77 = *(void **)(v2 + 296);
            if (v77)
            {
              os_release(v77);
              *(void *)(v2 + 296) = 0;
            }
            uint64_t v78 = *(void **)(v2 + 304);
            if (v78)
            {
              os_release(v78);
              *(void *)(v2 + 304) = 0;
            }
            nghttp2_session_del();
            (*(void (**)(void, void))(*(void *)(v2 + 352) + 16))(*(void *)(v2 + 352), 0);
            int v79 = *(const void **)(v2 + 352);
            if (v79)
            {
              _Block_release(v79);
              *(void *)(v2 + 352) = 0;
            }
            if ((*(__int16 *)(v2 + 388) & 0x80000000) == 0 && *((unsigned char *)p_cache + 3665))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v115 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
              {
                int v116 = *(_DWORD *)(v2 + 368);
                *(_DWORD *)int buf = 136447234;
                *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v2 + 390;
                *(_WORD *)&buf[22] = 2080;
                *(void *)&unsigned char buf[24] = " ";
                LOWORD(v138) = 1024;
                *(_DWORD *)((char *)&v138 + 2) = v116;
                HIWORD(v138) = 2048;
                uint64_t v139 = v2;
                _os_log_impl(&dword_1830D4000, v115, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> freeing http2 %p", buf, 0x30u);
              }
            }
            std::__destroy_at[abi:nn180100]<nw_protocol_http2,0>(v2);
LABEL_139:
            uint64_t v39 = (void *)v2;
LABEL_140:
            free(v39);
            return;
          }
          if (*(void *)v65)
          {
            int v66 = *(void (**)(uint64_t, uint64_t))(*(void *)v65 + 8);
            if (v66)
            {
              v66(v65, v1);
LABEL_109:
              *(void *)(v2 + 144) = 0;
              goto LABEL_110;
            }
          }
          __nwlog_obj();
          uint64_t v106 = *(void *)(v2 + 144);
          int v129 = v24[308];
          *(_DWORD *)int buf = v129;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v106;
          int v107 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t v136 = OS_LOG_TYPE_ERROR;
          char v130 = 0;
          if (__nwlog_fault(v107, &v136, &v130))
          {
            if (v136 == OS_LOG_TYPE_FAULT)
            {
              __int16 v108 = __nwlog_obj();
              os_log_type_t v109 = v136;
              if (!os_log_type_enabled(v108, v136)) {
                goto LABEL_235;
              }
              uint64_t v110 = *(void *)(v2 + 144);
              *(_DWORD *)int buf = v129;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v110;
              int v111 = "%{public}s listen protocol (%p) has invalid disconnected callback";
              goto LABEL_234;
            }
            if (!v130)
            {
              __int16 v108 = __nwlog_obj();
              os_log_type_t v109 = v136;
              if (!os_log_type_enabled(v108, v136)) {
                goto LABEL_235;
              }
              uint64_t v126 = *(void *)(v2 + 144);
              *(_DWORD *)int buf = v129;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v126;
              int v111 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
              goto LABEL_234;
            }
            uint64_t v117 = (char *)__nw_create_backtrace_string();
            __int16 v108 = __nwlog_obj();
            os_log_type_t v109 = v136;
            BOOL v118 = os_log_type_enabled(v108, v136);
            if (v117)
            {
              if (v118)
              {
                uint64_t v119 = *(void *)(v2 + 144);
                *(_DWORD *)int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v119;
                *(_WORD *)&buf[22] = 2082;
                *(void *)&unsigned char buf[24] = v117;
                _os_log_impl(&dword_1830D4000, v108, v109, "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
              }
              free(v117);
              goto LABEL_235;
            }
            if (v118)
            {
              uint64_t v127 = *(void *)(v2 + 144);
              *(_DWORD *)int buf = v129;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v127;
              int v111 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_234:
              _os_log_impl(&dword_1830D4000, v108, v109, v111, buf, 0x16u);
            }
          }
LABEL_235:
          if (v107) {
            free(v107);
          }
          goto LABEL_109;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        frame_size_t count = nw_frame_array_get_frame_count((uint64_t *)(v2 + 184), 0, 0);
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = frame_count;
        int v46 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v136 = OS_LOG_TYPE_ERROR;
        char v130 = 0;
        if (__nwlog_fault(v46, &v136, &v130))
        {
          if (v136 == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v47 = gLogObj;
            os_log_type_t v48 = v136;
            if (!os_log_type_enabled((os_log_t)gLogObj, v136)) {
              goto LABEL_92;
            }
            int v49 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 184), 0, 0);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v49;
            int v50 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames";
            goto LABEL_91;
          }
          if (!v130)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            char v47 = gLogObj;
            os_log_type_t v48 = v136;
            if (!os_log_type_enabled((os_log_t)gLogObj, v136)) {
              goto LABEL_92;
            }
            int v55 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 184), 0, 0);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v55;
            int v50 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, backtrace limit exceeded";
            goto LABEL_91;
          }
          int v51 = p_cache;
          int v52 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v47 = gLogObj;
          os_log_type_t v48 = v136;
          BOOL v53 = os_log_type_enabled((os_log_t)gLogObj, v136);
          if (v52)
          {
            if (v53)
            {
              int v54 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 184), 0, 0);
              *(_DWORD *)int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v54;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = v52;
              _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v52);
            p_cache = v51;
            int v24 = (void *)&unk_183D5C000;
            goto LABEL_92;
          }
          p_cache = v51;
          int v24 = &unk_183D5C000;
          if (v53)
          {
            int v56 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 184), 0, 0);
            *(_DWORD *)int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v56;
            int v50 = "%{public}s allocated_output_frames should be empty on destroy, but has %u frames, no backtrace";
LABEL_91:
            _os_log_impl(&dword_1830D4000, v47, v48, v50, buf, 0x12u);
          }
        }
LABEL_92:
        if (v46) {
          free(v46);
        }
        goto LABEL_94;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v25 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 168), 0, 0);
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v25;
      int v26 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v136 = OS_LOG_TYPE_ERROR;
      char v130 = 0;
      if (__nwlog_fault(v26, &v136, &v130))
      {
        if (v136 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v27 = gLogObj;
          os_log_type_t v28 = v136;
          if (!os_log_type_enabled((os_log_t)gLogObj, v136)) {
            goto LABEL_71;
          }
          int v29 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 168), 0, 0);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v29;
          int v30 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames";
          goto LABEL_70;
        }
        if (!v130)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v27 = gLogObj;
          os_log_type_t v28 = v136;
          if (!os_log_type_enabled((os_log_t)gLogObj, v136)) {
            goto LABEL_71;
          }
          int v40 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 168), 0, 0);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v40;
          int v30 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, backtrace limit exceeded";
          goto LABEL_70;
        }
        int v34 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v27 = gLogObj;
        os_log_type_t v28 = v136;
        BOOL v35 = os_log_type_enabled((os_log_t)gLogObj, v136);
        if (v34)
        {
          if (v35)
          {
            int v36 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 168), 0, 0);
            *(_DWORD *)int buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v36;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v34;
            _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v34);
          p_cache = (void **)(NWConcrete_nw_resolution_report + 16);
          goto LABEL_71;
        }
        p_cache = NWConcrete_nw_resolution_report.cache;
        if (v35)
        {
          int v41 = nw_frame_array_get_frame_count((uint64_t *)(v2 + 168), 0, 0);
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v41;
          int v30 = "%{public}s allocated_input_frames should be empty on destroy, but has %u frames, no backtrace";
LABEL_70:
          _os_log_impl(&dword_1830D4000, v27, v28, v30, buf, 0x12u);
        }
      }
LABEL_71:
      if (v26) {
        free(v26);
      }
      goto LABEL_73;
    }
    if (*(__int16 *)(v2 + 388) < 0) {
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v9 = *(_DWORD *)(v2 + 368);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v2 + 390;
    *(_WORD *)&buf[22] = 2080;
    *(void *)&unsigned char buf[24] = " ";
    LOWORD(v138) = 1024;
    *(_DWORD *)((char *)&v138 + 2) = v9;
    int v10 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v136 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v10, type, &v136))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v11 = gconnectionLogObj;
        os_log_type_t v12 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
          goto LABEL_64;
        }
        int v13 = *(_DWORD *)(v2 + 368);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v2 + 390;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v138) = 1024;
        *(_DWORD *)((char *)&v138 + 2) = v13;
        int v14 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying";
        goto LABEL_63;
      }
      if (v136 == OS_LOG_TYPE_DEFAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v11 = gconnectionLogObj;
        os_log_type_t v12 = type[0];
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type[0])) {
          goto LABEL_64;
        }
        int v37 = *(_DWORD *)(v2 + 368);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v2 + 390;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v138) = 1024;
        *(_DWORD *)((char *)&v138 + 2) = v37;
        int v14 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying, backtrace limit exceeded";
        goto LABEL_63;
      }
      int v31 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v11 = gconnectionLogObj;
      os_log_type_t v12 = type[0];
      BOOL v32 = os_log_type_enabled((os_log_t)gconnectionLogObj, type[0]);
      if (v31)
      {
        if (v32)
        {
          int v33 = *(_DWORD *)(v2 + 368);
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v2 + 390;
          *(_WORD *)&buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          LOWORD(v138) = 1024;
          *(_DWORD *)((char *)&v138 + 2) = v33;
          HIWORD(v138) = 2082;
          uint64_t v139 = (uint64_t)v31;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v31);
        goto LABEL_64;
      }
      if (v32)
      {
        int v38 = *(_DWORD *)(v2 + 368);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v2 + 390;
        *(_WORD *)&buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v138) = 1024;
        *(_DWORD *)((char *)&v138 + 2) = v38;
        int v14 = "%{public}s %{public}s%s<i%u> http2_streams_protocol NULL when destroying, no backtrace";
LABEL_63:
        _os_log_impl(&dword_1830D4000, v11, v12, v14, buf, 0x26u);
      }
    }
LABEL_64:
    if (!v10) {
      return;
    }
    uint64_t v39 = (void *)v10;
    goto LABEL_140;
  }
  __nwlog_obj();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
  uint64_t v2 = _os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v136 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault((const char *)v2, type, &v136)) {
    goto LABEL_220;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    uint64_t v82 = __nwlog_obj();
    os_log_type_t v83 = type[0];
    if (!os_log_type_enabled(v82, type[0])) {
      goto LABEL_220;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
    BOOL v84 = "%{public}s called with null http2";
    goto LABEL_219;
  }
  if (v136 == OS_LOG_TYPE_DEFAULT)
  {
    uint64_t v82 = __nwlog_obj();
    os_log_type_t v83 = type[0];
    if (!os_log_type_enabled(v82, type[0])) {
      goto LABEL_220;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
    BOOL v84 = "%{public}s called with null http2, backtrace limit exceeded";
    goto LABEL_219;
  }
  int v99 = (char *)__nw_create_backtrace_string();
  uint64_t v82 = __nwlog_obj();
  os_log_type_t v83 = type[0];
  BOOL v100 = os_log_type_enabled(v82, type[0]);
  if (!v99)
  {
    if (!v100) {
      goto LABEL_220;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
    BOOL v84 = "%{public}s called with null http2, no backtrace";
    goto LABEL_219;
  }
  if (v100)
  {
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_destroy";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v99;
    _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v99);
  if (v2) {
    goto LABEL_139;
  }
}

uint64_t ___ZL38nw_protocol_http2_remove_input_handlerP11nw_protocolS0_b_block_invoke_61(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t object = nw_hash_node_get_object(a2);
  nw_protocol_set_input_handler(v3, object);
  *(_OWORD *)*(void *)(a1 + 40) = *(_OWORD *)*(void *)(*(void *)(a1 + 32) + 48);
  uint64_t v5 = *(void *)(a1 + 40);
  if ((!v5 || (*(__int16 *)(v5 + 388) & 0x80000000) == 0) && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v7 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v8 = *(void *)(a1 + 40);
      int v9 = (const char *)(v8 + 390);
      int v10 = "";
      BOOL v11 = v8 == 0;
      if (!v8) {
        int v9 = "";
      }
      int v12 = *(_DWORD *)(v8 + 368);
      if (!v11) {
        int v10 = " ";
      }
      uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 48);
      int v14 = 136447234;
      int v15 = "nw_protocol_http2_remove_input_handler_block_invoke";
      __int16 v16 = 2082;
      uint64_t v17 = v9;
      __int16 v18 = 2080;
      int v19 = v10;
      __int16 v20 = 1024;
      int v21 = v12;
      __int16 v22 = 2048;
      uint64_t v23 = v13;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> reset default input handler to %p", (uint8_t *)&v14, 0x30u);
    }
  }
  return 0;
}

uint64_t ___ZL25nw_protocol_http2_destroyP11nw_protocol_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v5 = object;
    int v6 = *(unsigned __int16 *)(object + 188);
    int v7 = v6 | (*(unsigned __int8 *)(object + 190) << 16);
    if ((v6 & 1) == 0 || *(_DWORD *)(object + 176) == -1)
    {
      if ((v7 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v44 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v46 = *(_DWORD *)(v5 + 176);
          int v45 = *(_DWORD *)(v5 + 180);
          *(_DWORD *)int buf = 136447234;
          int v50 = "nw_protocol_http2_destroy_block_invoke";
          __int16 v51 = 2082;
          int v52 = (const char *)(v5 + 191);
          __int16 v53 = 2080;
          int v54 = " ";
          __int16 v55 = 1024;
          int v56 = v45;
          __int16 v57 = 1024;
          *(_DWORD *)uint64_t v58 = v46;
          _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> not closing already closed or invalid stream when destroying", buf, 0x2Cu);
        }
      }
      *(_WORD *)(v5 + 188) &= ~1u;
      *(_DWORD *)(v5 + 176) = -1;
      nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 32) + 160), a2);
    }
    else
    {
      if ((v7 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v8 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
        {
          int v10 = *(_DWORD *)(v5 + 176);
          int v9 = *(_DWORD *)(v5 + 180);
          *(_DWORD *)int buf = 136447490;
          int v50 = "nw_protocol_http2_destroy_block_invoke";
          __int16 v51 = 2082;
          int v52 = (const char *)(v5 + 191);
          __int16 v53 = 2080;
          int v54 = " ";
          __int16 v55 = 1024;
          int v56 = v9;
          __int16 v57 = 1024;
          *(_DWORD *)uint64_t v58 = v10;
          *(_WORD *)&v58[4] = 1024;
          *(_DWORD *)&v58[6] = v10;
          _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> closing stream %d during destroy, did not have an active input_handler", buf, 0x32u);
        }
      }
      nw_http2_stream_close(*(void *)(a1 + 32), v5);
    }
    nw_http2_stream_destroy((void **)v5);
    return 1;
  }
  uint64_t v11 = *(void *)(a1 + 32);
  if (v11 && *(__int16 *)(v11 + 388) < 0) {
    return 1;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  uint64_t v12 = *(void *)(a1 + 32);
  uint64_t v13 = (const char *)(v12 + 390);
  BOOL v14 = v12 == 0;
  int v15 = *(_DWORD *)(v12 + 368);
  if (v14) {
    uint64_t v13 = "";
  }
  *(_DWORD *)int buf = 136447234;
  int v50 = "nw_protocol_http2_destroy_block_invoke";
  if (v14) {
    __int16 v16 = "";
  }
  else {
    __int16 v16 = " ";
  }
  __int16 v51 = 2082;
  int v52 = v13;
  __int16 v53 = 2080;
  int v54 = v16;
  __int16 v55 = 1024;
  int v56 = v15;
  __int16 v57 = 2048;
  *(void *)uint64_t v58 = a2;
  uint64_t v17 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v47 = 0;
  if (__nwlog_fault(v17, &type, &v47))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v18 = gconnectionLogObj;
      os_log_type_t v19 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_63;
      }
      uint64_t v20 = *(void *)(a1 + 32);
      int v21 = (const char *)(v20 + 390);
      BOOL v22 = v20 == 0;
      if (!v20) {
        int v21 = "";
      }
      int v23 = *(_DWORD *)(v20 + 368);
      if (v22) {
        uint64_t v24 = "";
      }
      else {
        uint64_t v24 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      int v50 = "nw_protocol_http2_destroy_block_invoke";
      __int16 v51 = 2082;
      int v52 = v21;
      __int16 v53 = 2080;
      int v54 = v24;
      __int16 v55 = 1024;
      int v56 = v23;
      __int16 v57 = 2048;
      *(void *)uint64_t v58 = a2;
      int v25 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra";
      goto LABEL_62;
    }
    if (!v47)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v18 = gconnectionLogObj;
      os_log_type_t v19 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_63;
      }
      uint64_t v33 = *(void *)(a1 + 32);
      int v34 = (const char *)(v33 + 390);
      BOOL v35 = v33 == 0;
      if (!v33) {
        int v34 = "";
      }
      int v36 = *(_DWORD *)(v33 + 368);
      if (v35) {
        int v37 = "";
      }
      else {
        int v37 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      int v50 = "nw_protocol_http2_destroy_block_invoke";
      __int16 v51 = 2082;
      int v52 = v34;
      __int16 v53 = 2080;
      int v54 = v37;
      __int16 v55 = 1024;
      int v56 = v36;
      __int16 v57 = 2048;
      *(void *)uint64_t v58 = a2;
      int v25 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, backtrace limit exceeded";
      goto LABEL_62;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    __int16 v18 = gconnectionLogObj;
    os_log_type_t v19 = type;
    BOOL v27 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
    if (backtrace_string)
    {
      if (v27)
      {
        uint64_t v28 = *(void *)(a1 + 32);
        int v29 = (const char *)(v28 + 390);
        BOOL v30 = v28 == 0;
        if (!v28) {
          int v29 = "";
        }
        int v31 = *(_DWORD *)(v28 + 368);
        if (v30) {
          BOOL v32 = "";
        }
        else {
          BOOL v32 = " ";
        }
        *(_DWORD *)int buf = 136447490;
        int v50 = "nw_protocol_http2_destroy_block_invoke";
        __int16 v51 = 2082;
        int v52 = v29;
        __int16 v53 = 2080;
        int v54 = v32;
        __int16 v55 = 1024;
        int v56 = v31;
        __int16 v57 = 2048;
        *(void *)uint64_t v58 = a2;
        *(_WORD *)&v58[8] = 2082;
        char v59 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, dumping backtrace:%{public}s", buf, 0x3Au);
      }
      free(backtrace_string);
      goto LABEL_63;
    }
    if (v27)
    {
      uint64_t v38 = *(void *)(a1 + 32);
      uint64_t v39 = (const char *)(v38 + 390);
      BOOL v40 = v38 == 0;
      if (!v38) {
        uint64_t v39 = "";
      }
      int v41 = *(_DWORD *)(v38 + 368);
      if (v40) {
        uint64_t v42 = "";
      }
      else {
        uint64_t v42 = " ";
      }
      *(_DWORD *)int buf = 136447234;
      int v50 = "nw_protocol_http2_destroy_block_invoke";
      __int16 v51 = 2082;
      int v52 = v39;
      __int16 v53 = 2080;
      int v54 = v42;
      __int16 v55 = 1024;
      int v56 = v41;
      __int16 v57 = 2048;
      *(void *)uint64_t v58 = a2;
      int v25 = "%{public}s %{public}s%s<i%u> hash node %p didn't have a stream as extra, no backtrace";
LABEL_62:
      _os_log_impl(&dword_1830D4000, v18, v19, v25, buf, 0x30u);
    }
  }
LABEL_63:
  if (v17) {
    free(v17);
  }
  return 1;
}

BOOL nw_protocol_http2_add_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v207 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v188 = "nw_protocol_http2_add_input_handler";
    os_log_type_t v154 = (char *)_os_log_send_and_compose_impl();
    v201[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v154, v201, &type)) {
      goto LABEL_281;
    }
    if (v201[0] == OS_LOG_TYPE_FAULT)
    {
      int v155 = __nwlog_obj();
      os_log_type_t v156 = v201[0];
      if (!os_log_type_enabled(v155, v201[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null protocol";
      goto LABEL_280;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      int v155 = __nwlog_obj();
      os_log_type_t v156 = v201[0];
      if (!os_log_type_enabled(v155, v201[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_280;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v155 = __nwlog_obj();
    os_log_type_t v156 = v201[0];
    BOOL v164 = os_log_type_enabled(v155, v201[0]);
    if (!backtrace_string)
    {
      if (!v164) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_280;
    }
    if (!v164) {
      goto LABEL_261;
    }
    *(_DWORD *)int buf = 136446466;
    int v188 = "nw_protocol_http2_add_input_handler";
    __int16 v189 = 2082;
    uint64_t v190 = (uint64_t)backtrace_string;
    int v165 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_260:
    _os_log_impl(&dword_1830D4000, v155, v156, v165, buf, 0x16u);
    goto LABEL_261;
  }
  handle = (__int16 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v188 = "nw_protocol_http2_add_input_handler";
    os_log_type_t v154 = (char *)_os_log_send_and_compose_impl();
    v201[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v154, v201, &type)) {
      goto LABEL_281;
    }
    if (v201[0] == OS_LOG_TYPE_FAULT)
    {
      int v155 = __nwlog_obj();
      os_log_type_t v156 = v201[0];
      if (!os_log_type_enabled(v155, v201[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null http2";
      goto LABEL_280;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      int v155 = __nwlog_obj();
      os_log_type_t v156 = v201[0];
      if (!os_log_type_enabled(v155, v201[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_280;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v155 = __nwlog_obj();
    os_log_type_t v156 = v201[0];
    BOOL v166 = os_log_type_enabled(v155, v201[0]);
    if (!backtrace_string)
    {
      if (!v166) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null http2, no backtrace";
      goto LABEL_280;
    }
    if (!v166) {
      goto LABEL_261;
    }
    *(_DWORD *)int buf = 136446466;
    int v188 = "nw_protocol_http2_add_input_handler";
    __int16 v189 = 2082;
    uint64_t v190 = (uint64_t)backtrace_string;
    int v165 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_260;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v188 = "nw_protocol_http2_add_input_handler";
    os_log_type_t v154 = (char *)_os_log_send_and_compose_impl();
    v201[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v154, v201, &type)) {
      goto LABEL_281;
    }
    if (v201[0] == OS_LOG_TYPE_FAULT)
    {
      int v155 = __nwlog_obj();
      os_log_type_t v156 = v201[0];
      if (!os_log_type_enabled(v155, v201[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null input_protocol";
      goto LABEL_280;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      int v155 = __nwlog_obj();
      os_log_type_t v156 = v201[0];
      if (!os_log_type_enabled(v155, v201[0])) {
        goto LABEL_281;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v157 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_280;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v155 = __nwlog_obj();
    os_log_type_t v156 = v201[0];
    BOOL v167 = os_log_type_enabled(v155, v201[0]);
    if (backtrace_string)
    {
      if (v167)
      {
        *(_DWORD *)int buf = 136446466;
        int v188 = "nw_protocol_http2_add_input_handler";
        __int16 v189 = 2082;
        uint64_t v190 = (uint64_t)backtrace_string;
        int v165 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_260;
      }
LABEL_261:
      free(backtrace_string);
      goto LABEL_281;
    }
    if (!v167) {
      goto LABEL_281;
    }
    *(_DWORD *)int buf = 136446210;
    int v188 = "nw_protocol_http2_add_input_handler";
    BOOL v157 = "%{public}s called with null input_protocol, no backtrace";
LABEL_280:
    _os_log_impl(&dword_1830D4000, v155, v156, v157, buf, 0xCu);
LABEL_281:
    if (v154) {
      free(v154);
    }
    return 0;
  }
  if ((handle[194] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v158 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v159 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      int v188 = "nw_protocol_http2_add_input_handler";
      __int16 v189 = 2082;
      uint64_t v190 = (uint64_t)(handle + 195);
      __int16 v191 = 2080;
      uint64_t v192 = (uint64_t)" ";
      __int16 v193 = 1024;
      int v194 = v159;
      _os_log_impl(&dword_1830D4000, v158, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
    int v160 = handle[194];
    int v5 = *((_DWORD *)handle + 90);
    *((_DWORD *)handle + 90) = -1;
    if ((v160 & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v161 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v162 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447746;
        int v188 = "nw_protocol_http2_add_input_handler";
        __int16 v189 = 2082;
        uint64_t v190 = (uint64_t)(handle + 195);
        __int16 v191 = 2080;
        uint64_t v192 = (uint64_t)" ";
        __int16 v193 = 1024;
        int v194 = v162;
        __int16 v195 = 2048;
        *(void *)uint64_t v196 = a2;
        *(_WORD *)&v196[8] = 1042;
        *(_DWORD *)&v196[10] = 16;
        *(_WORD *)&v196[14] = 2098;
        *(void *)&v196[16] = a2;
        _os_log_impl(&dword_1830D4000, v161, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> incoming protocol %p has flow id %{public,uuid_t}.16P", buf, 0x40u);
      }
    }
  }
  else
  {
    int v5 = *((_DWORD *)handle + 90);
    *((_DWORD *)handle + 90) = -1;
  }
  if (!*((void *)handle + 14))
  {
    callbacks = a2->callbacks;
    if (!callbacks
      || (get_remote_endpoint = (uint64_t (*)(nw_protocol *))callbacks->get_remote_endpoint) == 0
      || (uint64_t v8 = (void *)get_remote_endpoint(a2)) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v26 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        return 0;
      }
      *(_DWORD *)int buf = 136446210;
      int v188 = "nw_protocol_http2_add_input_handler";
      BOOL v27 = "%{public}s failed to get remote endpoint from input_handler";
LABEL_32:
      BOOL v30 = v26;
      uint32_t v31 = 12;
LABEL_87:
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, v27, buf, v31);
      return 0;
    }
    *((void *)handle + 14) = os_retain(v8);
  }
  int v9 = a2->callbacks;
  if (!v9
    || (get_parameters = (uint64_t (*)(nw_protocol *))v9->get_parameters) == 0
    || (uint64_t v11 = (void *)get_parameters(a2)) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v26 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    *(_DWORD *)int buf = 136446210;
    int v188 = "nw_protocol_http2_add_input_handler";
    BOOL v27 = "%{public}s couldn't get parameters from input_protocol";
    goto LABEL_32;
  }
  int v206 = 0;
  long long v204 = 0u;
  long long v205 = 0u;
  long long v203 = 0u;
  *(_OWORD *)BOOL v201 = 0u;
  long long v202 = 0u;
  uint64_t object = v11;
  uint64_t v12 = nw_parameters_copy_protocol_options_legacy(v11, a1);
  if (!v12)
  {
    BOOL v28 = 0;
    BOOL v183 = 0;
    int capsule_handling_disabled = 0;
    int idle_timeout = 240;
    goto LABEL_68;
  }
  uint64_t v13 = v12;
  BOOL v14 = v13;
  uint64_t v15 = 0;
  v201[0] = OS_LOG_TYPE_DEFAULT;
  __int16 v16 = (unsigned __int8 *)(v13 + 48);
  while (1)
  {
    int v17 = v13[v15 + 48];
    v201[v15] = v17;
    if (!v17) {
      break;
    }
    if (++v15 == 83)
    {
      HIBYTE(v206) = 0;
      break;
    }
  }

  __int16 v18 = handle + 195;
  int v19 = *((unsigned __int8 *)handle + 390);
  BOOL v184 = *((unsigned char *)handle + 390) == 0;
  if (*((unsigned char *)handle + 390))
  {
    if (handle[194] < 0 || !gLogDatapath) {
      goto LABEL_43;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v20 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_43;
    }
    int v21 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136447234;
    int v188 = "nw_protocol_http2_add_input_handler";
    __int16 v189 = 2082;
    uint64_t v190 = (uint64_t)(handle + 195);
    __int16 v191 = 2080;
    uint64_t v192 = (uint64_t)" ";
    __int16 v193 = 1024;
    int v194 = v21;
    __int16 v195 = 2080;
    *(void *)uint64_t v196 = v201;
    BOOL v22 = "%{public}s %{public}s%s<i%u> new stream %s joined http2";
    int v23 = v20;
    os_log_type_t v24 = OS_LOG_TYPE_DEBUG;
    uint32_t v25 = 48;
  }
  else
  {
    BOOL v32 = v14;
    uint64_t v33 = v32;
    *__int16 v18 = 0;
    uint64_t v34 = 84;
    while (1)
    {
      int v35 = *v16;
      *__int16 v18 = v35;
      if (!v35) {
        break;
      }
      ++v18;
      ++v16;
      if ((unint64_t)--v34 <= 1)
      {
        *__int16 v18 = 0;
        break;
      }
    }

    *((_DWORD *)handle + 92) = nw_protocol_get_next_instance_id();
    int v36 = v33;
    int v37 = *((_DWORD *)v36 + 33);

    if (handle[194] < 0) {
      goto LABEL_43;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v38 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_43;
    }
    int v39 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136447490;
    int v188 = "nw_protocol_http2_add_input_handler";
    __int16 v189 = 2082;
    uint64_t v190 = (uint64_t)(handle + 195);
    __int16 v191 = 2080;
    uint64_t v192 = (uint64_t)" ";
    __int16 v193 = 1024;
    int v194 = v39;
    __int16 v195 = 1024;
    *(_DWORD *)uint64_t v196 = v39;
    *(_WORD *)&v196[4] = 1024;
    *(_DWORD *)&v196[6] = v37;
    BOOL v22 = "%{public}s %{public}s%s<i%u> created HTTP/2 and assigned instance ID: %u from C%u";
    int v23 = v38;
    os_log_type_t v24 = OS_LOG_TYPE_INFO;
    uint32_t v25 = 50;
  }
  _os_log_impl(&dword_1830D4000, v23, v24, v22, buf, v25);
LABEL_43:
  int idle_timeout = nw_http2_get_idle_timeout(v14);
  BOOL v40 = nw_http2_copy_reset_stream_error_callback(v14);
  char v41 = *((unsigned char *)handle + 272);
  if (v41)
  {
    uint64_t v42 = (const void *)*((void *)handle + 33);
    if (v42)
    {
      _Block_release(v42);
      char v41 = *((unsigned char *)handle + 272);
    }
  }
  *((void *)handle + 33) = v40;
  *((unsigned char *)handle + 272) = v41 | 1;
  BOOL v183 = (id *)nw_http_messaging_options_copy_transaction_metadata(v14);
  int capsule_handling_disabled = nw_http2_get_capsule_handling_disabled(v14);
  if (!v19)
  {
    stream_receive_window_unsigned int size = nw_http2_get_stream_receive_window_size(v14);
    if (stream_receive_window_size)
    {
      int v44 = stream_receive_window_size;
      if ((handle[194] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v45 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v46 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136447234;
          int v188 = "nw_protocol_http2_add_input_handler";
          __int16 v189 = 2082;
          uint64_t v190 = (uint64_t)(handle + 195);
          __int16 v191 = 2080;
          uint64_t v192 = (uint64_t)" ";
          __int16 v193 = 1024;
          int v194 = v46;
          __int16 v195 = 1024;
          *(_DWORD *)uint64_t v196 = v44;
          _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> overriding stream receive window size to %u", buf, 0x2Cu);
        }
      }
    }
    else
    {
      int v44 = 0x200000;
    }
    connection_receive_window_unsigned int size = nw_http2_get_connection_receive_window_size(v14);
    if (connection_receive_window_size)
    {
      int v48 = connection_receive_window_size;
      if ((handle[194] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v49 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v50 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136447234;
          int v188 = "nw_protocol_http2_add_input_handler";
          __int16 v189 = 2082;
          uint64_t v190 = (uint64_t)(handle + 195);
          __int16 v191 = 2080;
          uint64_t v192 = (uint64_t)" ";
          __int16 v193 = 1024;
          int v194 = v50;
          __int16 v195 = 1024;
          *(_DWORD *)uint64_t v196 = v48;
          _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> overriding connection receive window size to %u", buf, 0x2Cu);
        }
      }
    }
    else
    {
      int v48 = 10485760;
    }
    int local_max_webtransport_sessions = nw_http2_get_local_max_webtransport_sessions(v14);
    if (local_max_webtransport_sessions && (handle[194] & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v176 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v177 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447234;
        int v188 = "nw_protocol_http2_add_input_handler";
        __int16 v189 = 2082;
        uint64_t v190 = (uint64_t)(handle + 195);
        __int16 v191 = 2080;
        uint64_t v192 = (uint64_t)" ";
        __int16 v193 = 1024;
        int v194 = v177;
        __int16 v195 = 1024;
        *(_DWORD *)uint64_t v196 = local_max_webtransport_sessions;
        _os_log_impl(&dword_1830D4000, v176, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> setting max webtransport sessions to %u", buf, 0x2Cu);
      }
    }
    *((_DWORD *)handle + 94) = v44;
    *((_DWORD *)handle + 95) = v48;
    *((_DWORD *)handle + 96) = local_max_webtransport_sessions;
  }
  os_release(v14);
  BOOL v28 = v184;
LABEL_68:
  *((void *)handle + 10) = (1000 * idle_timeout);
  uint64_t v52 = nw_http2_add_to_protocol_table((uint64_t)handle, (uint64_t)a2, 0);
  if (!v52)
  {
    if (handle[194] < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v68 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return 0;
    }
    int v69 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136446978;
    int v188 = "nw_protocol_http2_add_input_handler";
    __int16 v189 = 2082;
    uint64_t v190 = (uint64_t)(handle + 195);
    __int16 v191 = 2080;
    uint64_t v192 = (uint64_t)" ";
    __int16 v193 = 1024;
    int v194 = v69;
    BOOL v27 = "%{public}s %{public}s%s<i%u> could not add protocol to protocol based hash table, cannot add input handler";
    BOOL v30 = v68;
    uint32_t v31 = 38;
    goto LABEL_87;
  }
  __int16 v53 = (void *)v52;
  if (v5 != -1)
  {
    uint64_t stream_node_from_id = nw_http2_get_stream_node_from_id((uint64_t)handle, v5);
    if (stream_node_from_id)
    {
      uint64_t v55 = stream_node_from_id;
      uint64_t v56 = *(void *)(stream_node_from_id + 16);
      if (v56)
      {
        uint64_t v57 = *(void *)(stream_node_from_id + 32);
        if (v57)
        {
          if (((*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v59 = *(_DWORD *)(v56 + 176);
            int v58 = *(_DWORD *)(v56 + 180);
            uint64_t v60 = *(void *)(v55 + 32);
            *(_DWORD *)int buf = 136448258;
            int v188 = "nw_protocol_http2_add_input_handler";
            __int16 v189 = 2082;
            uint64_t v190 = v56 + 191;
            __int16 v191 = 2080;
            uint64_t v192 = (uint64_t)" ";
            __int16 v193 = 1024;
            int v194 = v58;
            __int16 v195 = 1024;
            *(_DWORD *)uint64_t v196 = v59;
            *(_WORD *)&v196[4] = 2048;
            *(void *)&v196[6] = a2;
            *(_WORD *)&v196[14] = 2048;
            *(void *)&v196[16] = v60;
            *(_WORD *)&v196[24] = 2048;
            *(void *)BOOL v197 = v56;
            *(_WORD *)&v197[8] = 1024;
            int v198 = v59;
            dispatch_time_t v61 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v185 = 0;
            if (!__nwlog_fault(v61, &type, &v185)) {
              goto LABEL_215;
            }
            if (type == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v62 = gconnectionLogObj;
              os_log_type_t v63 = type;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                goto LABEL_215;
              }
              int v65 = *(_DWORD *)(v56 + 176);
              int v64 = *(_DWORD *)(v56 + 180);
              uint64_t v66 = *(void *)(v55 + 32);
              *(_DWORD *)int buf = 136448258;
              int v188 = "nw_protocol_http2_add_input_handler";
              __int16 v189 = 2082;
              uint64_t v190 = v56 + 191;
              __int16 v191 = 2080;
              uint64_t v192 = (uint64_t)" ";
              __int16 v193 = 1024;
              int v194 = v64;
              __int16 v195 = 1024;
              *(_DWORD *)uint64_t v196 = v65;
              *(_WORD *)&v196[4] = 2048;
              *(void *)&v196[6] = a2;
              *(_WORD *)&v196[14] = 2048;
              *(void *)&v196[16] = v66;
              *(_WORD *)&v196[24] = 2048;
              *(void *)BOOL v197 = v56;
              *(_WORD *)&v197[8] = 1024;
              int v198 = v65;
              uint64_t v67 = "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer"
                    " %p for stream (%p, id %d)";
            }
            else if (v185)
            {
              int v116 = (char *)__nw_create_backtrace_string();
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v62 = gconnectionLogObj;
              os_log_type_t v63 = type;
              BOOL v117 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
              if (v116)
              {
                if (v117)
                {
                  int v119 = *(_DWORD *)(v56 + 176);
                  int v118 = *(_DWORD *)(v56 + 180);
                  uint64_t v120 = *(void *)(v55 + 32);
                  *(_DWORD *)int buf = 136448514;
                  int v188 = "nw_protocol_http2_add_input_handler";
                  __int16 v189 = 2082;
                  uint64_t v190 = v56 + 191;
                  __int16 v191 = 2080;
                  uint64_t v192 = (uint64_t)" ";
                  __int16 v193 = 1024;
                  int v194 = v118;
                  __int16 v195 = 1024;
                  *(_DWORD *)uint64_t v196 = v119;
                  *(_WORD *)&v196[4] = 2048;
                  *(void *)&v196[6] = a2;
                  *(_WORD *)&v196[14] = 2048;
                  *(void *)&v196[16] = v120;
                  *(_WORD *)&v196[24] = 2048;
                  *(void *)BOOL v197 = v56;
                  *(_WORD *)&v197[8] = 1024;
                  int v198 = v119;
                  __int16 v199 = 2082;
                  uint64_t v200 = v116;
                  _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer %p for stream (%p, id %d), dumping backtrace:%{public}s", buf, 0x5Au);
                }
                free(v116);
                goto LABEL_215;
              }
              if (!v117)
              {
LABEL_215:
                if (v61) {
                  free(v61);
                }
                goto LABEL_217;
              }
              int v151 = *(_DWORD *)(v56 + 176);
              int v150 = *(_DWORD *)(v56 + 180);
              uint64_t v152 = *(void *)(v55 + 32);
              *(_DWORD *)int buf = 136448258;
              int v188 = "nw_protocol_http2_add_input_handler";
              __int16 v189 = 2082;
              uint64_t v190 = v56 + 191;
              __int16 v191 = 2080;
              uint64_t v192 = (uint64_t)" ";
              __int16 v193 = 1024;
              int v194 = v150;
              __int16 v195 = 1024;
              *(_DWORD *)uint64_t v196 = v151;
              *(_WORD *)&v196[4] = 2048;
              *(void *)&v196[6] = a2;
              *(_WORD *)&v196[14] = 2048;
              *(void *)&v196[16] = v152;
              *(_WORD *)&v196[24] = 2048;
              *(void *)BOOL v197 = v56;
              *(_WORD *)&v197[8] = 1024;
              int v198 = v151;
              uint64_t v67 = "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer"
                    " %p for stream (%p, id %d), no backtrace";
            }
            else
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v62 = gconnectionLogObj;
              os_log_type_t v63 = type;
              if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
                goto LABEL_215;
              }
              int v145 = *(_DWORD *)(v56 + 176);
              int v144 = *(_DWORD *)(v56 + 180);
              uint64_t v146 = *(void *)(v55 + 32);
              *(_DWORD *)int buf = 136448258;
              int v188 = "nw_protocol_http2_add_input_handler";
              __int16 v189 = 2082;
              uint64_t v190 = v56 + 191;
              __int16 v191 = 2080;
              uint64_t v192 = (uint64_t)" ";
              __int16 v193 = 1024;
              int v194 = v144;
              __int16 v195 = 1024;
              *(_DWORD *)uint64_t v196 = v145;
              *(_WORD *)&v196[4] = 2048;
              *(void *)&v196[6] = a2;
              *(_WORD *)&v196[14] = 2048;
              *(void *)&v196[16] = v146;
              *(_WORD *)&v196[24] = 2048;
              *(void *)BOOL v197 = v56;
              *(_WORD *)&v197[8] = 1024;
              int v198 = v145;
              uint64_t v67 = "%{public}s %{public}s%s<i%u:s%d> adding new input handler %p, already have existing protocol pointer"
                    " %p for stream (%p, id %d), backtrace limit exceeded";
            }
            _os_log_impl(&dword_1830D4000, v62, v63, v67, buf, 0x50u);
            goto LABEL_215;
          }
LABEL_217:
          nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
          return 0;
        }
        *(void *)(stream_node_from_id + 32) = a2;
        v53[4] = v56;
        while (1)
        {
          int v91 = v201[v57];
          *(unsigned char *)(v56 + 191 + v57) = v91;
          if (!v91) {
            break;
          }
          if (++v57 == 83)
          {
            *(unsigned char *)(v56 + 274) = 0;
            break;
          }
        }
        if (((*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v92 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            int v94 = *(_DWORD *)(v56 + 176);
            int v93 = *(_DWORD *)(v56 + 180);
            *(_DWORD *)int buf = 136448258;
            int v188 = "nw_protocol_http2_add_input_handler";
            __int16 v189 = 2082;
            uint64_t v190 = v56 + 191;
            __int16 v191 = 2080;
            uint64_t v192 = (uint64_t)" ";
            __int16 v193 = 1024;
            int v194 = v93;
            __int16 v195 = 1024;
            *(_DWORD *)uint64_t v196 = v94;
            *(_WORD *)&v196[4] = 1024;
            *(_DWORD *)&v196[6] = v5;
            *(_WORD *)&v196[10] = 2080;
            *(void *)&v196[12] = v201;
            *(_WORD *)&v196[20] = 1024;
            *(_DWORD *)&v196[22] = v94;
            *(_WORD *)BOOL v197 = 2048;
            *(void *)&v197[2] = v56;
            _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> connected incoming stream id %d for %s to existing stream %d (%p)", buf, 0x4Cu);
          }
        }
LABEL_131:
        if (capsule_handling_disabled) {
          int v95 = 0x10000;
        }
        else {
          int v95 = 0;
        }
        unsigned int v96 = (*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0xFFFEFFFF;
        *(_WORD *)(v56 + 188) = *(_WORD *)(v56 + 188);
        *(unsigned char *)(v56 + 190) = (v96 | v95) >> 16;
        singleton = v183;
        if (!v183)
        {
          if (nw_protocol_copy_http_transaction_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http_transaction_definition_onceToken, &__block_literal_global_84_75899);
          }
          singleton = nw_protocol_metadata_create_singleton((void *)nw_protocol_copy_http_transaction_definition_definition);
        }
        *(void *)(v56 + 96) = singleton;
        if (v28)
        {
          nw_http_transaction_metadata_set_first_on_connection(singleton);
          singleton = *(id **)(v56 + 96);
        }
        nw_http_transaction_metadata_set_connection_metadata(singleton, *((void **)handle + 32));
        if (((*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0x80000) == 0
          && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v172 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v174 = *(_DWORD *)(v56 + 176);
            int v173 = *(_DWORD *)(v56 + 180);
            identifier = a2->identifier;
            *(_DWORD *)int buf = 136448002;
            int v188 = "nw_protocol_http2_add_input_handler";
            __int16 v189 = 2082;
            uint64_t v190 = v56 + 191;
            __int16 v191 = 2080;
            uint64_t v192 = (uint64_t)" ";
            __int16 v193 = 1024;
            int v194 = v173;
            __int16 v195 = 1024;
            *(_DWORD *)uint64_t v196 = v174;
            *(_WORD *)&v196[4] = 2048;
            *(void *)&v196[6] = a2;
            *(_WORD *)&v196[14] = 2080;
            *(void *)&v196[16] = identifier;
            *(_WORD *)&v196[24] = 2048;
            *(void *)BOOL v197 = v53;
            _os_log_impl(&dword_1830D4000, v172, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> setting input protocol %p (%s) output_handler_context to %p", buf, 0x4Au);
          }
        }
        a2->output_handler_context = v53;
        nw_protocol_set_output_handler((uint64_t)a2, (uint64_t)a1);
        if (a1->default_input_handler)
        {
          if (!v28) {
            goto LABEL_147;
          }
        }
        else
        {
          nw_protocol_set_input_handler((uint64_t)a1, (uint64_t)a2);
          *(_OWORD *)handle = *(_OWORD *)a2->flow_id;
          if (!v28) {
            goto LABEL_147;
          }
        }
        if (!*((void *)handle + 36))
        {
          uint64_t v127 = object;
          id v128 = *(id *)(v127[13] + 136);

          int v129 = (void *)*((void *)handle + 35);
          if (v129)
          {
            os_release(v129);
            *((void *)handle + 35) = 0;
          }
          id v130 = nw_path_copy_flow_registration(v128, (uint64_t)handle);
          *((void *)handle + 35) = v130;
          if (v128)
          {
            os_release(v128);
            id v130 = (id)*((void *)handle + 35);
          }
          if (v130)
          {
            id v131 = nw_path_flow_registration_copy_endpoint(v130);
            id v132 = nw_path_flow_registration_copy_parameters(*((void **)handle + 35));
            uint64_t v133 = nw_endpoint_copy_association_with_evaluator(v131, v132, 0);
            *((void *)handle + 36) = v133;
            if (v131)
            {
              os_release(v131);
              uint64_t v133 = (id *)*((void *)handle + 36);
            }
            if (v133)
            {
              uint64_t v134 = nw_protocol_instance_stub_create((nw_protocol *)handle);
              *((void *)handle + 37) = v134;
              nw_association_register_internal(*((void **)handle + 36), v127, v134, 0, 0, &__block_literal_global_58_84853);
              id v135 = nw_association_copy_current_path(*((void **)handle + 36), v132);
              if (v135)
              {
                os_log_type_t v136 = v135;
                BOOL v137 = nw_path_copy_for_flow_registration(v135, *((void **)handle + 35));
                if (v137)
                {
                  uint64_t v138 = (void *)v137;
                  uint64_t v139 = (void *)*((void *)handle + 15);
                  if (v139 != v138)
                  {
                    if (v139)
                    {
                      os_release(v139);
                      *((void *)handle + 15) = 0;
                    }
                    *((void *)handle + 15) = os_retain(v138);
                  }
                  if (nw_path_has_flows(v138)) {
                    __int16 v140 = 32;
                  }
                  else {
                    __int16 v140 = 0;
                  }
                  handle[194] = handle[194] & 0xFFDF | v140;
                  id v141 = nw_parameters_copy_effective_proxy_config(v127);
                  if (v141)
                  {
                    uint64_t v142 = v141;
                    if (nw_path_has_proxy_config(v136, v141))
                    {
                      uint64_t v143 = (void *)*((void *)handle + 38);
                      if (v143) {
                        os_release(v143);
                      }
                      *((void *)handle + 38) = v142;
                    }
                    else
                    {
                      os_release(v142);
                    }
                  }
                  os_release(v136);
                }
                else
                {
                  uint64_t v138 = v136;
                }
                os_release(v138);
              }
            }
            if (v132) {
              os_release(v132);
            }
          }
        }
LABEL_147:
        uint64_t v98 = *((void *)handle + 11);
        if (v98)
        {
          nw_queue_cancel_source(v98);
          *((void *)handle + 11) = 0;
        }
        if (!*((void *)handle + 13)) {
          *((void *)handle + 13) = os_retain(object);
        }
        int v99 = *(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16);
        if (v201[0])
        {
          if ((v99 & 0x80000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v100 = gconnectionLogObj;
            uint64_t v101 = 1;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
              return v101;
            }
            uint64_t v102 = v56 + 191;
            uint64_t v105 = v56 + 176;
            int v103 = *(_DWORD *)(v56 + 176);
            int v104 = *(_DWORD *)(v105 + 4);
            int v106 = nw_hash_table_count(*((void *)handle + 19));
            *(_DWORD *)int buf = 136448002;
            int v188 = "nw_protocol_http2_add_input_handler";
            __int16 v189 = 2082;
            uint64_t v190 = v102;
            __int16 v191 = 2080;
            uint64_t v192 = (uint64_t)" ";
            __int16 v193 = 1024;
            int v194 = v104;
            __int16 v195 = 1024;
            *(_DWORD *)uint64_t v196 = v103;
            *(_WORD *)&v196[4] = 2048;
            *(void *)&v196[6] = a2;
            *(_WORD *)&v196[14] = 2082;
            *(void *)&v196[16] = v201;
            *(_WORD *)&v196[24] = 1024;
            *(_DWORD *)BOOL v197 = v106;
            int v107 = "%{public}s %{public}s%s<i%u:s%d> added input handler %p from %{public}s, now have %u input handlers";
            uint64_t v101 = 1;
            __int16 v108 = v100;
            uint32_t v109 = 70;
            goto LABEL_162;
          }
        }
        else if ((v99 & 0x80000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v110 = gconnectionLogObj;
          uint64_t v101 = 1;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
            return v101;
          }
          uint64_t v111 = v56 + 191;
          uint64_t v114 = v56 + 176;
          int v112 = *(_DWORD *)(v56 + 176);
          int v113 = *(_DWORD *)(v114 + 4);
          int v115 = nw_hash_table_count(*((void *)handle + 19));
          *(_DWORD *)int buf = 136447746;
          int v188 = "nw_protocol_http2_add_input_handler";
          __int16 v189 = 2082;
          uint64_t v190 = v111;
          __int16 v191 = 2080;
          uint64_t v192 = (uint64_t)" ";
          __int16 v193 = 1024;
          int v194 = v113;
          __int16 v195 = 1024;
          *(_DWORD *)uint64_t v196 = v112;
          *(_WORD *)&v196[4] = 2048;
          *(void *)&v196[6] = a2;
          *(_WORD *)&v196[14] = 1024;
          *(_DWORD *)&v196[16] = v115;
          int v107 = "%{public}s %{public}s%s<i%u:s%d> added input handler %p, now have %u input handlers";
          uint64_t v101 = 1;
          __int16 v108 = v110;
          uint32_t v109 = 60;
LABEL_162:
          _os_log_impl(&dword_1830D4000, v108, OS_LOG_TYPE_INFO, v107, buf, v109);
          return v101;
        }
        return 1;
      }
      if (handle[194] < 0) {
        goto LABEL_217;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v89 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_217;
      }
      int v90 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447234;
      int v188 = "nw_protocol_http2_add_input_handler";
      __int16 v189 = 2082;
      uint64_t v190 = (uint64_t)(handle + 195);
      __int16 v191 = 2080;
      uint64_t v192 = (uint64_t)" ";
      __int16 v193 = 1024;
      int v194 = v90;
      __int16 v195 = 1024;
      *(_DWORD *)uint64_t v196 = v5;
      int v86 = "%{public}s %{public}s%s<i%u> stream (id %d) not found in hash node";
      uint64_t v87 = v89;
      uint32_t v88 = 44;
    }
    else
    {
      if (handle[194] < 0) {
        goto LABEL_217;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v84 = gconnectionLogObj;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_217;
      }
      int v85 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447490;
      int v188 = "nw_protocol_http2_add_input_handler";
      __int16 v189 = 2082;
      uint64_t v190 = (uint64_t)(handle + 195);
      __int16 v191 = 2080;
      uint64_t v192 = (uint64_t)" ";
      __int16 v193 = 1024;
      int v194 = v85;
      __int16 v195 = 1024;
      *(_DWORD *)uint64_t v196 = v5;
      *(_WORD *)&v196[4] = 2048;
      *(void *)&v196[6] = a2;
      int v86 = "%{public}s %{public}s%s<i%u> could not find existing stream %d to connect protocol %p with";
      uint64_t v87 = v84;
      uint32_t v88 = 54;
    }
    _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_ERROR, v86, buf, v88);
    goto LABEL_217;
  }
  if ((handle[194] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v170 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v171 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      int v188 = "nw_protocol_http2_add_input_handler";
      __int16 v189 = 2082;
      uint64_t v190 = (uint64_t)(handle + 195);
      __int16 v191 = 2080;
      uint64_t v192 = (uint64_t)" ";
      __int16 v193 = 1024;
      int v194 = v171;
      _os_log_impl(&dword_1830D4000, v170, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> detected new stream initiated from this side of the connection, allocating new stream", buf, 0x26u);
    }
  }
  os_log_type_t v70 = malloc_type_calloc(1uLL, 0x118uLL, 0xEAFB8F1AuLL);
  uint64_t v56 = (uint64_t)v70;
  if (v70)
  {
    uint64_t v71 = (uint64_t)(v70 + 11);
    v70[34] = 0;
    *((_OWORD *)v70 + 15) = 0u;
    *((_OWORD *)v70 + 16) = 0u;
    *((_OWORD *)v70 + 13) = 0u;
    *((_OWORD *)v70 + 14) = 0u;
    *((_OWORD *)v70 + 11) = 0u;
    *((_OWORD *)v70 + 12) = 0u;
    *((_OWORD *)v70 + 9) = 0u;
    *((_OWORD *)v70 + 10) = 0u;
    *((_OWORD *)v70 + 7) = 0u;
    *((_OWORD *)v70 + 8) = 0u;
    *((_OWORD *)v70 + 5) = 0u;
    *((_OWORD *)v70 + 6) = 0u;
    *((_OWORD *)v70 + 3) = 0u;
    *((_OWORD *)v70 + 4) = 0u;
    *((_OWORD *)v70 + 1) = 0u;
    *((_OWORD *)v70 + 2) = 0u;
    *(_OWORD *)os_log_type_t v70 = 0u;
    nw_http2_stream_init((uint64_t)v70);
    goto LABEL_92;
  }
  uint64_t v168 = __nwlog_obj();
  os_log_type_enabled(v168, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  int v188 = "strict_calloc";
  __int16 v189 = 2048;
  uint64_t v190 = 1;
  __int16 v191 = 2048;
  uint64_t v192 = 280;
  int v169 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v169);
  if (!result)
  {
    free(v169);
    MEMORY[0x110] = 0;
    MEMORY[0x100] = 0u;
    MEMORY[0xF0] = 0u;
    MEMORY[0xE0] = 0u;
    MEMORY[0xD0] = 0u;
    MEMORY[0xC0] = 0u;
    MEMORY[0xB0] = 0u;
    MEMORY[0xA0] = 0u;
    MEMORY[0x90] = 0u;
    MEMORY[0x80] = 0u;
    MEMORY[0x70] = 0u;
    MEMORY[0x60] = 0u;
    MEMORY[0x50] = 0u;
    MEMORY[0x40] = 0u;
    MEMORY[0x30] = 0u;
    MEMORY[0x20] = 0u;
    MEMORY[0x10] = 0u;
    MEMORY[0] = 0u;
    nw_http2_stream_init(0);
    uint64_t v71 = 88;
LABEL_92:
    uint64_t v72 = 0;
    *(unsigned char *)uint64_t v71 = (handle[194] & 0x80) != 0;
    int v73 = *(_WORD *)(v56 + 188) & 0xFF7F | (*(unsigned __int8 *)(v56 + 190) << 16);
    *(_WORD *)(v56 + 188) = *(_WORD *)(v56 + 188) & 0xFF7F | handle[194] & 0x80;
    *(unsigned char *)(v56 + 190) = BYTE2(v73);
    while (1)
    {
      int v74 = v201[v72];
      *(unsigned char *)(v56 + 191 + v72) = v74;
      if (!v74) {
        break;
      }
      if (++v72 == 83)
      {
        *(unsigned char *)(v56 + 274) = 0;
        break;
      }
    }
    unsigned int v75 = (16 * (unsigned __int16)handle[194]) & 0x80000 | (*(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16)) & 0xFFF7FFFF;
    *(_WORD *)(v56 + 188) = *(_WORD *)(v56 + 188);
    *(unsigned char *)(v56 + 190) = BYTE2(v75);
    *(_DWORD *)(v56 + 180) = *((_DWORD *)handle + 92);
    v53[4] = v56;
    int v76 = *(unsigned __int16 *)(v56 + 188);
    int v77 = v76 | (*(unsigned __int8 *)(v56 + 190) << 16);
    if ((v76 & 0x80) == 0) {
      goto LABEL_131;
    }
    if (a1->default_input_handler)
    {
      if ((v77 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v78 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v80 = *(_DWORD *)(v56 + 176);
          int v79 = *(_DWORD *)(v56 + 180);
          *(_DWORD *)int buf = 136447234;
          int v188 = "nw_protocol_http2_add_input_handler";
          __int16 v189 = 2082;
          uint64_t v190 = v56 + 191;
          __int16 v191 = 2080;
          uint64_t v192 = (uint64_t)" ";
          __int16 v193 = 1024;
          int v194 = v79;
          __int16 v195 = 1024;
          *(_DWORD *)uint64_t v196 = v80;
          _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> http2 has default_input_handler on the first stream in a listening connection. Is a connection trying to join while having server set on the parameters?", buf, 0x2Cu);
        }
      }
      nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      if (*(unsigned char *)(v56 + 168))
      {
        BOOL v81 = *(void **)(v56 + 160);
        if (v81) {
          os_release(v81);
        }
      }
      *(void *)(v56 + 160) = 0;
      if (*(unsigned char *)(v56 + 152))
      {
        uint64_t v82 = *(void **)(v56 + 144);
        if (v82) {
          os_release(v82);
        }
      }
      *(void *)(v56 + 144) = 0;
      os_log_type_t v83 = *(void **)(v56 + 120);
      if (v83)
      {
        *(void *)(v56 + 128) = v83;
        operator delete(v83);
      }
    }
    else
    {
      if ((v77 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v178 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v180 = *(_DWORD *)(v56 + 176);
          int v179 = *(_DWORD *)(v56 + 180);
          *(_DWORD *)int buf = 136447234;
          int v188 = "nw_protocol_http2_add_input_handler";
          __int16 v189 = 2082;
          uint64_t v190 = v56 + 191;
          __int16 v191 = 2080;
          uint64_t v192 = (uint64_t)" ";
          __int16 v193 = 1024;
          int v194 = v179;
          __int16 v195 = 1024;
          *(_DWORD *)uint64_t v196 = v180;
          _os_log_impl(&dword_1830D4000, v178, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> responder's first stream detected, overriding stream id to 1", buf, 0x2Cu);
        }
      }
      *(_DWORD *)(v56 + 176) = 1;
      uint64_t v121 = nw_http2_add_to_id_table((uint64_t)handle, v56, (uint64_t)a2);
      int v122 = *(unsigned __int16 *)(v56 + 188) | (*(unsigned __int8 *)(v56 + 190) << 16);
      if (v121)
      {
        if ((v122 & 0x80000) == 0 && gLogDatapath)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v123 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v125 = *(_DWORD *)(v56 + 176);
            int v124 = *(_DWORD *)(v56 + 180);
            uint64_t v126 = v53[4];
            *(_DWORD *)int buf = 136447746;
            int v188 = "nw_protocol_http2_add_input_handler";
            __int16 v189 = 2082;
            uint64_t v190 = v56 + 191;
            __int16 v191 = 2080;
            uint64_t v192 = (uint64_t)" ";
            __int16 v193 = 1024;
            int v194 = v124;
            __int16 v195 = 1024;
            *(_DWORD *)uint64_t v196 = v125;
            *(_WORD *)&v196[4] = 2048;
            *(void *)&v196[6] = v56;
            *(_WORD *)&v196[14] = 2048;
            *(void *)&v196[16] = v126;
            _os_log_impl(&dword_1830D4000, v123, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> new stream is %p, stream pointer is %p", buf, 0x40u);
          }
        }
        goto LABEL_131;
      }
      if ((v122 & 0x80000) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v147 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
        {
          int v149 = *(_DWORD *)(v56 + 176);
          int v148 = *(_DWORD *)(v56 + 180);
          *(_DWORD *)int buf = 136447234;
          int v188 = "nw_protocol_http2_add_input_handler";
          __int16 v189 = 2082;
          uint64_t v190 = v56 + 191;
          __int16 v191 = 2080;
          uint64_t v192 = (uint64_t)" ";
          __int16 v193 = 1024;
          int v194 = v148;
          __int16 v195 = 1024;
          *(_DWORD *)uint64_t v196 = v149;
          _os_log_impl(&dword_1830D4000, v147, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> Failed to add new stream to the id based hash table", buf, 0x2Cu);
        }
      }
      nw_http2_remove_from_protocol_table((uint64_t)handle, (uint64_t)a2);
      std::destroy_at[abi:nn180100]<http2_stream,0>(v56);
    }
    free((void *)v56);
    return 0;
  }
  __break(1u);
  return result;
}

void ___ZL36nw_protocol_http2_set_up_associationP17nw_protocol_http2P13nw_parameters_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  uint64_t handle = nw_protocol_instance_stub_get_handle(a2);
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
    int v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v21, &type, &v29)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      os_log_type_t v24 = "%{public}s called with null protocol_handle";
      goto LABEL_66;
    }
    if (!v29)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      os_log_type_t v24 = "%{public}s called with null protocol_handle, backtrace limit exceeded";
      goto LABEL_66;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v26 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      os_log_type_t v24 = "%{public}s called with null protocol_handle, no backtrace";
      goto LABEL_66;
    }
    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      __int16 v33 = 2082;
      uint64_t v34 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null protocol_handle, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_67:
    if (!v21) {
      return;
    }
    goto LABEL_68;
  }
  uint64_t v5 = *(void *)(handle + 40);
  if (!v5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
    int v21 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (!__nwlog_fault(v21, &type, &v29)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      os_log_type_t v24 = "%{public}s called with null http2";
      goto LABEL_66;
    }
    if (!v29)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_67;
      }
      *(_DWORD *)int buf = 136446210;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      os_log_type_t v24 = "%{public}s called with null http2, backtrace limit exceeded";
      goto LABEL_66;
    }
    BOOL v27 = (char *)__nw_create_backtrace_string();
    BOOL v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v28 = os_log_type_enabled(v22, type);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)int buf = 136446466;
        BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
        __int16 v33 = 2082;
        uint64_t v34 = v27;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v27);
      if (!v21) {
        return;
      }
LABEL_68:
      free(v21);
      return;
    }
    if (v28)
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
      os_log_type_t v24 = "%{public}s called with null http2, no backtrace";
LABEL_66:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
      goto LABEL_67;
    }
    goto LABEL_67;
  }
  if ((*(_WORD *)(v5 + 388) & 8) == 0)
  {
    BOOL v6 = nw_path_copy_for_flow_registration(a3, *(void **)(v5 + 280));
    if (v6)
    {
      int v7 = (void *)v6;
      uint64_t v8 = *(void **)(v5 + 120);
      if (v8 != v7)
      {
        if (v8)
        {
          os_release(v8);
          *(void *)(v5 + 120) = 0;
        }
        *(void *)(v5 + 120) = os_retain(v7);
      }
      int v9 = *(void **)(v5 + 304);
      if (v9 && (nw_path_has_proxy_config(v7, v9) & 1) == 0)
      {
        if ((*(__int16 *)(v5 + 388) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v17 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
          {
            int v18 = *(_DWORD *)(v5 + 368);
            *(_DWORD *)int buf = 136446978;
            BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
            __int16 v33 = 2082;
            uint64_t v34 = (char *)(v5 + 390);
            __int16 v35 = 2080;
            int v36 = " ";
            __int16 v37 = 1024;
            int v38 = v18;
            _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Effective proxy configuration lost, treating as a GOAWAY", buf, 0x26u);
          }
        }
        nw_http2_connection_receive_goaway(v5, 0x7FFFFFFF);
        goto LABEL_37;
      }
      if ((*(_WORD *)(v5 + 388) & 0x20) != 0)
      {
        BOOL is_viable = nw_path_is_viable(v7);
        alternate_path_uint64_t state = nw_path_get_alternate_path_state(v7, a3);
        __int16 v12 = *(_WORD *)(v5 + 388);
        if (is_viable && alternate_path_state == 0)
        {
          if ((v12 & 0x40) != 0)
          {
            if ((*(_WORD *)(v5 + 388) & 0x8000) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v19 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
              {
                int v20 = *(_DWORD *)(v5 + 368);
                *(_DWORD *)int buf = 136446978;
                BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
                __int16 v33 = 2082;
                uint64_t v34 = (char *)(v5 + 390);
                __int16 v35 = 2080;
                int v36 = " ";
                __int16 v37 = 1024;
                int v38 = v20;
                _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Path recovered, recommending that new flows join", buf, 0x26u);
              }
            }
            __int16 v16 = *(_WORD *)(v5 + 388) & 0xFFBF;
            goto LABEL_36;
          }
        }
        else if ((v12 & 0x40) == 0)
        {
          if ((*(_WORD *)(v5 + 388) & 0x8000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v14 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
            {
              int v15 = *(_DWORD *)(v5 + 368);
              *(_DWORD *)int buf = 136446978;
              BOOL v32 = "nw_protocol_http2_set_up_association_block_invoke";
              __int16 v33 = 2082;
              uint64_t v34 = (char *)(v5 + 390);
              __int16 v35 = 2080;
              int v36 = " ";
              __int16 v37 = 1024;
              int v38 = v15;
              _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> Bad path, recommending that new flows not join", buf, 0x26u);
            }
          }
          __int16 v16 = *(_WORD *)(v5 + 388) | 0x40;
LABEL_36:
          *(_WORD *)(v5 + 388) = v16;
        }
      }
LABEL_37:
      os_release(v7);
    }
  }
}

void nw_protocol_http2_input_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_http2_input_finished";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_63;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      int v10 = "%{public}s called with null protocol";
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)int buf = 136446466;
          os_log_type_t v23 = "nw_protocol_http2_input_finished";
          __int16 v24 = 2082;
          uint32_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_63:
        if (!v7) {
          return;
        }
        goto LABEL_64;
      }
      if (!v14) {
        goto LABEL_63;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      int v10 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      int v10 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_62;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_http2_input_finished";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_63;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v20)
      {
        uint64_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (!os_log_type_enabled(v8, type)) {
          goto LABEL_63;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_protocol_http2_input_finished";
        int v10 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_62;
      }
      int v15 = (char *)__nw_create_backtrace_string();
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (!v15)
      {
        if (!v16) {
          goto LABEL_63;
        }
        *(_DWORD *)int buf = 136446210;
        os_log_type_t v23 = "nw_protocol_http2_input_finished";
        int v10 = "%{public}s called with null http2, no backtrace";
        goto LABEL_62;
      }
      if (v16)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v23 = "nw_protocol_http2_input_finished";
        __int16 v24 = 2082;
        uint32_t v25 = v15;
        int v17 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_47:
        _os_log_impl(&dword_1830D4000, v8, v9, v17, buf, 0x16u);
      }
LABEL_48:
      free(v15);
      if (!v7) {
        return;
      }
LABEL_64:
      free(v7);
      return;
    }
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (!os_log_type_enabled(v8, type)) {
      goto LABEL_63;
    }
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_http2_input_finished";
    int v10 = "%{public}s called with null http2";
LABEL_62:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
    goto LABEL_63;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v23 = "nw_protocol_http2_input_finished";
    int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_63;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      int v10 = "%{public}s called with null other_protocol";
      goto LABEL_62;
    }
    if (!v20)
    {
      uint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_63;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      int v10 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_62;
    }
    int v15 = (char *)__nw_create_backtrace_string();
    uint64_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v18 = os_log_type_enabled(v8, type);
    if (!v15)
    {
      if (!v18) {
        goto LABEL_63;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      int v10 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_62;
    }
    if (v18)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      __int16 v24 = 2082;
      uint32_t v25 = v15;
      int v17 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_47;
    }
    goto LABEL_48;
  }
  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v11 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v12 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      __int16 v24 = 2082;
      uint32_t v25 = handle + 390;
      __int16 v26 = 2080;
      BOOL v27 = " ";
      __int16 v28 = 1024;
      int v29 = v12;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  if ((*((_WORD *)handle + 194) & 0x9000) == 0x1000)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v3 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      int v4 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      os_log_type_t v23 = "nw_protocol_http2_input_finished";
      __int16 v24 = 2082;
      uint32_t v25 = handle + 390;
      __int16 v26 = 2080;
      BOOL v27 = " ";
      __int16 v28 = 1024;
      int v29 = v4;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u> still waiting for listen handler, but input finished. Processing input anyway.", buf, 0x26u);
    }
  }
  nw_protocol_http2_process_input((uint64_t)handle);
  *((_WORD *)handle + 194) |= 2u;
  uint64_t v5 = (char *)*((void *)handle + 19);
  v19[0] = MEMORY[0x1E4F143A8];
  v19[1] = 0x40000000;
  v19[2] = ___ZL32nw_protocol_http2_input_finishedP11nw_protocolS0__block_invoke;
  v19[3] = &__block_descriptor_tmp_54_84889;
  v19[4] = handle;
  nw_hash_table_apply(v5, (uint64_t)v19);
  uint64_t v6 = *((void *)handle + 11);
  if (v6)
  {
    if (*(void *)v6)
    {
      dispatch_source_set_timer(*(dispatch_source_t *)v6, 0x8000000000000000, 0xFFFFFFFFFFFFFFFFLL, 0x3B9ACA00uLL);
    }
    else
    {
      *(_OWORD *)(v6 + 32) = xmmword_183D5CD50;
      if (*(unsigned char *)(v6 + 48))
      {
        if (*(unsigned char *)(v6 + 49)) {
          nw_queue_source_run_timer(v6);
        }
      }
    }
  }
}

uint64_t ___ZL32nw_protocol_http2_input_finishedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  uint64_t object = nw_hash_node_get_object(a2);
  if (!object)
  {
    uint64_t v14 = *(void *)(a1 + 32);
    if (v14 && *(__int16 *)(v14 + 388) < 0) {
      return 1;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v15 = *(void *)(a1 + 32);
    BOOL v16 = (const char *)(v15 + 390);
    BOOL v17 = v15 == 0;
    int v18 = *(_DWORD *)(v15 + 368);
    if (v17) {
      BOOL v16 = "";
    }
    *(_DWORD *)int buf = 136447234;
    uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
    if (v17) {
      int v19 = "";
    }
    else {
      int v19 = " ";
    }
    __int16 v101 = 2082;
    uint64_t v102 = v16;
    __int16 v103 = 2080;
    int v104 = v19;
    __int16 v105 = 1024;
    int v106 = v18;
    __int16 v107 = 2048;
    *(void *)__int16 v108 = a2;
    char v20 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v97 = 0;
    if (!__nwlog_fault(v20, &type, &v97)) {
      goto LABEL_103;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v21 = gconnectionLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        uint64_t v23 = *(void *)(a1 + 32);
        __int16 v24 = (const char *)(v23 + 390);
        BOOL v25 = v23 == 0;
        if (!v23) {
          __int16 v24 = "";
        }
        int v26 = *(_DWORD *)(v23 + 368);
        if (v25) {
          BOOL v27 = "";
        }
        else {
          BOOL v27 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v24;
        __int16 v103 = 2080;
        int v104 = v27;
        __int16 v105 = 1024;
        int v106 = v26;
        __int16 v107 = 2048;
        *(void *)__int16 v108 = a2;
        __int16 v28 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished";
LABEL_102:
        _os_log_impl(&dword_1830D4000, v21, v22, v28, buf, 0x30u);
      }
    }
    else if (v97)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v21 = gconnectionLogObj;
      os_log_type_t v22 = type;
      BOOL v54 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (!backtrace_string)
      {
        if (!v54) {
          goto LABEL_103;
        }
        uint64_t v66 = *(void *)(a1 + 32);
        uint64_t v67 = (const char *)(v66 + 390);
        BOOL v68 = v66 == 0;
        if (!v66) {
          uint64_t v67 = "";
        }
        int v69 = *(_DWORD *)(v66 + 368);
        if (v68) {
          os_log_type_t v70 = "";
        }
        else {
          os_log_type_t v70 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v67;
        __int16 v103 = 2080;
        int v104 = v70;
        __int16 v105 = 1024;
        int v106 = v69;
        __int16 v107 = 2048;
        *(void *)__int16 v108 = a2;
        __int16 v28 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished, no backtrace";
        goto LABEL_102;
      }
      if (v54)
      {
        uint64_t v55 = *(void *)(a1 + 32);
        uint64_t v56 = (const char *)(v55 + 390);
        BOOL v57 = v55 == 0;
        if (!v55) {
          uint64_t v56 = "";
        }
        int v58 = *(_DWORD *)(v55 + 368);
        if (v57) {
          int v59 = "";
        }
        else {
          int v59 = " ";
        }
        *(_DWORD *)int buf = 136447490;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v56;
        __int16 v103 = 2080;
        int v104 = v59;
        __int16 v105 = 1024;
        int v106 = v58;
        __int16 v107 = 2048;
        *(void *)__int16 v108 = a2;
        *(_WORD *)&v108[8] = 2082;
        uint32_t v109 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished, dumping backtrace:%{public}s", buf, 0x3Au);
      }
      free(backtrace_string);
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v21 = gconnectionLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
        uint64_t v61 = *(void *)(a1 + 32);
        uint64_t v62 = (const char *)(v61 + 390);
        BOOL v63 = v61 == 0;
        if (!v61) {
          uint64_t v62 = "";
        }
        int v64 = *(_DWORD *)(v61 + 368);
        if (v63) {
          int v65 = "";
        }
        else {
          int v65 = " ";
        }
        *(_DWORD *)int buf = 136447234;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v62;
        __int16 v103 = 2080;
        int v104 = v65;
        __int16 v105 = 1024;
        int v106 = v64;
        __int16 v107 = 2048;
        *(void *)__int16 v108 = a2;
        __int16 v28 = "%{public}s %{public}s%s<i%u> no object for hash node %p, skipping input_finished, backtrace limit exceeded";
        goto LABEL_102;
      }
    }
LABEL_103:
    if (v20)
    {
      uint64_t v71 = (char *)v20;
LABEL_105:
      free(v71);
      return 1;
    }
    return 1;
  }
  uint64_t v5 = object;
  uint64_t v6 = *(void *)nw_hash_node_get_extra(a2);
  if (!v6)
  {
    uint64_t v29 = *(void *)(a1 + 32);
    if (!v29 || (*(__int16 *)(v29 + 388) & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v30 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        uint64_t v31 = *(void *)(a1 + 32);
        BOOL v32 = (const char *)(v31 + 390);
        __int16 v33 = "";
        BOOL v34 = v31 == 0;
        int v35 = *(_DWORD *)(v31 + 368);
        if (v34) {
          BOOL v32 = "";
        }
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        *(_DWORD *)int buf = 136446978;
        if (!v34) {
          __int16 v33 = " ";
        }
        uint64_t v102 = v32;
        __int16 v103 = 2080;
        int v104 = v33;
        __int16 v105 = 1024;
        int v106 = v35;
        _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> input protocol has no stream, masking input_finished with disconnected", buf, 0x26u);
      }
    }
LABEL_41:
    uint64_t v36 = *(void *)(v5 + 24);
    if (!v36 || (__int16 v37 = *(void (**)(uint64_t, void))(v36 + 48)) == 0)
    {
      __nwlog_obj();
      int v38 = *(const char **)(v5 + 16);
      if (!v38) {
        int v38 = "invalid";
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
      __int16 v101 = 2082;
      uint64_t v102 = v38;
      uint64_t v39 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v97 = 0;
      if (__nwlog_fault(v39, &type, &v97))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          if (!os_log_type_enabled(v40, type)) {
            goto LABEL_180;
          }
          uint64_t v42 = *(const char **)(v5 + 16);
          if (!v42) {
            uint64_t v42 = "invalid";
          }
LABEL_50:
          *(_DWORD *)int buf = 136446466;
          uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
          __int16 v101 = 2082;
          uint64_t v102 = v42;
          uint64_t v43 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_179:
          _os_log_impl(&dword_1830D4000, v40, v41, v43, buf, 0x16u);
          goto LABEL_180;
        }
        if (v97)
        {
          int v73 = (char *)__nw_create_backtrace_string();
          BOOL v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          BOOL v74 = os_log_type_enabled(v40, type);
          if (v73)
          {
            if (!v74) {
              goto LABEL_113;
            }
            unsigned int v75 = *(const char **)(v5 + 16);
            if (!v75) {
              unsigned int v75 = "invalid";
            }
            goto LABEL_112;
          }
          if (!v74) {
            goto LABEL_180;
          }
          uint32_t v88 = *(const char **)(v5 + 16);
          if (!v88) {
            uint32_t v88 = "invalid";
          }
          goto LABEL_178;
        }
        BOOL v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (!os_log_type_enabled(v40, type)) {
          goto LABEL_180;
        }
        uint64_t v78 = *(const char **)(v5 + 16);
        if (!v78) {
          uint64_t v78 = "invalid";
        }
        goto LABEL_126;
      }
      goto LABEL_180;
    }
    goto LABEL_85;
  }
  int v7 = *(unsigned __int16 *)(v6 + 188);
  int v8 = v7 | (*(unsigned __int8 *)(v6 + 190) << 16);
  if (v7)
  {
    if ((v7 & 0x1000) != 0)
    {
      uint64_t v60 = *(void *)(v5 + 24);
      if (!v60 || (__int16 v37 = *(void (**)(uint64_t, void))(v60 + 184)) == 0)
      {
        __nwlog_obj();
        int v76 = *(const char **)(v5 + 16);
        if (!v76) {
          int v76 = "invalid";
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v76;
        uint64_t v39 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v97 = 0;
        if (__nwlog_fault(v39, &type, &v97))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            BOOL v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (!os_log_type_enabled(v40, type)) {
              goto LABEL_180;
            }
            int v77 = *(const char **)(v5 + 16);
            if (!v77) {
              int v77 = "invalid";
            }
            *(_DWORD *)int buf = 136446466;
            uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
            __int16 v101 = 2082;
            uint64_t v102 = v77;
            uint64_t v43 = "%{public}s protocol %{public}s has invalid input_finished callback";
            goto LABEL_179;
          }
          if (!v97)
          {
            BOOL v40 = __nwlog_obj();
            os_log_type_t v41 = type;
            if (!os_log_type_enabled(v40, type)) {
              goto LABEL_180;
            }
            int v93 = *(const char **)(v5 + 16);
            if (!v93) {
              int v93 = "invalid";
            }
            *(_DWORD *)int buf = 136446466;
            uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
            __int16 v101 = 2082;
            uint64_t v102 = v93;
            uint64_t v43 = "%{public}s protocol %{public}s has invalid input_finished callback, backtrace limit exceeded";
            goto LABEL_179;
          }
          int v85 = (char *)__nw_create_backtrace_string();
          BOOL v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          BOOL v86 = os_log_type_enabled(v40, type);
          if (!v85)
          {
            if (!v86) {
              goto LABEL_180;
            }
            int v94 = *(const char **)(v5 + 16);
            if (!v94) {
              int v94 = "invalid";
            }
            *(_DWORD *)int buf = 136446466;
            uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
            __int16 v101 = 2082;
            uint64_t v102 = v94;
            uint64_t v43 = "%{public}s protocol %{public}s has invalid input_finished callback, no backtrace";
            goto LABEL_179;
          }
          if (v86)
          {
            uint64_t v87 = *(const char **)(v5 + 16);
            if (!v87) {
              uint64_t v87 = "invalid";
            }
            *(_DWORD *)int buf = 136446722;
            uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
            __int16 v101 = 2082;
            uint64_t v102 = v87;
            __int16 v103 = 2082;
            int v104 = v85;
            _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s protocol %{public}s has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v85);
        }
        goto LABEL_180;
      }
LABEL_85:
      v37(v5, *(void *)(a1 + 32));
      return 1;
    }
    if ((v8 & 0x80000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v44 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v46 = *(_DWORD *)(v6 + 176);
        int v45 = *(_DWORD *)(v6 + 180);
        *(_DWORD *)int buf = 136447234;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = (const char *)(v6 + 191);
        __int16 v103 = 2080;
        int v104 = " ";
        __int16 v105 = 1024;
        int v106 = v45;
        __int16 v107 = 1024;
        *(_DWORD *)__int16 v108 = v46;
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s<i%u:s%d> input finished before a complete message", buf, 0x2Cu);
      }
    }
    int v47 = *(unsigned __int16 *)(v6 + 188);
    int v48 = v47 | (*(unsigned __int8 *)(v6 + 190) << 16);
    if ((v47 & 0x40) != 0) {
      return 1;
    }
    *(unsigned char *)(v6 + 190) = BYTE2(v48);
    *(_WORD *)(v6 + 188) = v48 | 0x40;
    uint64_t v49 = *(void *)(v5 + 24);
    if (v49)
    {
      int v50 = *(void (**)(uint64_t, void, uint64_t))(v49 + 56);
      if (v50)
      {
        v50(v5, *(void *)(a1 + 32), 57);
        goto LABEL_61;
      }
    }
    __nwlog_obj();
    int v79 = *(const char **)(v5 + 16);
    if (!v79) {
      int v79 = "invalid";
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
    __int16 v101 = 2082;
    uint64_t v102 = v79;
    int v80 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v97 = 0;
    if (__nwlog_fault(v80, &type, &v97))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v81 = __nwlog_obj();
        os_log_type_t v82 = type;
        if (!os_log_type_enabled(v81, type)) {
          goto LABEL_187;
        }
        os_log_type_t v83 = *(const char **)(v5 + 16);
        if (!v83) {
          os_log_type_t v83 = "invalid";
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v83;
        uint64_t v84 = "%{public}s protocol %{public}s has invalid error callback";
        goto LABEL_186;
      }
      if (!v97)
      {
        BOOL v81 = __nwlog_obj();
        os_log_type_t v82 = type;
        if (!os_log_type_enabled(v81, type)) {
          goto LABEL_187;
        }
        int v95 = *(const char **)(v5 + 16);
        if (!v95) {
          int v95 = "invalid";
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v95;
        uint64_t v84 = "%{public}s protocol %{public}s has invalid error callback, backtrace limit exceeded";
        goto LABEL_186;
      }
      int v90 = (char *)__nw_create_backtrace_string();
      BOOL v81 = __nwlog_obj();
      os_log_type_t v82 = type;
      BOOL v91 = os_log_type_enabled(v81, type);
      if (v90)
      {
        if (v91)
        {
          os_log_type_t v92 = *(const char **)(v5 + 16);
          if (!v92) {
            os_log_type_t v92 = "invalid";
          }
          *(_DWORD *)int buf = 136446722;
          uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
          __int16 v101 = 2082;
          uint64_t v102 = v92;
          __int16 v103 = 2082;
          int v104 = v90;
          _os_log_impl(&dword_1830D4000, v81, v82, "%{public}s protocol %{public}s has invalid error callback, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(v90);
        goto LABEL_187;
      }
      if (v91)
      {
        unsigned int v96 = *(const char **)(v5 + 16);
        if (!v96) {
          unsigned int v96 = "invalid";
        }
        *(_DWORD *)int buf = 136446466;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v96;
        uint64_t v84 = "%{public}s protocol %{public}s has invalid error callback, no backtrace";
LABEL_186:
        _os_log_impl(&dword_1830D4000, v81, v82, v84, buf, 0x16u);
      }
    }
LABEL_187:
    if (v80) {
      free(v80);
    }
LABEL_61:
    uint64_t v51 = *(void *)(v5 + 24);
    if (!v51 || (__int16 v37 = *(void (**)(uint64_t, void))(v51 + 48)) == 0)
    {
      __nwlog_obj();
      uint64_t v52 = *(const char **)(v5 + 16);
      if (!v52) {
        uint64_t v52 = "invalid";
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
      __int16 v101 = 2082;
      uint64_t v102 = v52;
      uint64_t v39 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v97 = 0;
      if (__nwlog_fault(v39, &type, &v97))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          if (!os_log_type_enabled(v40, type)) {
            goto LABEL_180;
          }
          uint64_t v42 = *(const char **)(v5 + 16);
          if (!v42) {
            uint64_t v42 = "invalid";
          }
          goto LABEL_50;
        }
        if (v97)
        {
          int v73 = (char *)__nw_create_backtrace_string();
          BOOL v40 = __nwlog_obj();
          os_log_type_t v41 = type;
          BOOL v89 = os_log_type_enabled(v40, type);
          if (v73)
          {
            if (!v89)
            {
LABEL_113:
              free(v73);
              if (!v39) {
                return 1;
              }
LABEL_181:
              uint64_t v71 = (char *)v39;
              goto LABEL_105;
            }
            unsigned int v75 = *(const char **)(v5 + 16);
            if (!v75) {
              unsigned int v75 = "invalid";
            }
LABEL_112:
            *(_DWORD *)int buf = 136446722;
            uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
            __int16 v101 = 2082;
            uint64_t v102 = v75;
            __int16 v103 = 2082;
            int v104 = v73;
            _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
            goto LABEL_113;
          }
          if (!v89) {
            goto LABEL_180;
          }
          uint32_t v88 = *(const char **)(v5 + 16);
          if (!v88) {
            uint32_t v88 = "invalid";
          }
LABEL_178:
          *(_DWORD *)int buf = 136446466;
          uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
          __int16 v101 = 2082;
          uint64_t v102 = v88;
          uint64_t v43 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
          goto LABEL_179;
        }
        BOOL v40 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (!os_log_type_enabled(v40, type)) {
          goto LABEL_180;
        }
        uint64_t v78 = *(const char **)(v5 + 16);
        if (!v78) {
          uint64_t v78 = "invalid";
        }
LABEL_126:
        *(_DWORD *)int buf = 136446466;
        uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
        __int16 v101 = 2082;
        uint64_t v102 = v78;
        uint64_t v43 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
        goto LABEL_179;
      }
LABEL_180:
      if (!v39) {
        return 1;
      }
      goto LABEL_181;
    }
    goto LABEL_85;
  }
  if ((v8 & 0x80000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v9 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
    {
      int v11 = *(_DWORD *)(v6 + 176);
      int v10 = *(_DWORD *)(v6 + 180);
      *(_DWORD *)int buf = 136447490;
      uint64_t v100 = "nw_protocol_http2_input_finished_block_invoke";
      __int16 v101 = 2082;
      uint64_t v102 = (const char *)(v6 + 191);
      __int16 v103 = 2080;
      int v104 = " ";
      __int16 v105 = 1024;
      int v106 = v10;
      __int16 v107 = 1024;
      *(_DWORD *)__int16 v108 = v11;
      *(_WORD *)&v108[4] = 1024;
      *(_DWORD *)&v108[6] = v11;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u:s%d> stream %d not open, masking input_finished with disconnected", buf, 0x32u);
    }
  }
  int v12 = *(unsigned __int16 *)(v6 + 188);
  int v13 = v12 | (*(unsigned __int8 *)(v6 + 190) << 16);
  if ((v12 & 0x40) == 0)
  {
    *(unsigned char *)(v6 + 190) = BYTE2(v13);
    *(_WORD *)(v6 + 188) = v13 | 0x40;
    goto LABEL_41;
  }
  return 1;
}

void nw_protocol_http2_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v28 = "nw_protocol_http2_output_finished";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v28 = "nw_protocol_http2_output_finished";
      int v13 = "%{public}s called with null protocol";
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          __int16 v28 = "nw_protocol_http2_output_finished";
          __int16 v29 = 2082;
          uint64_t v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_72:
        if (!v10) {
          return;
        }
        goto LABEL_73;
      }
      if (!v17) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v28 = "nw_protocol_http2_output_finished";
      int v13 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v28 = "nw_protocol_http2_output_finished";
      int v13 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_71;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v28 = "nw_protocol_http2_output_finished";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25)) {
      goto LABEL_72;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v25)
      {
        int v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_72;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v28 = "nw_protocol_http2_output_finished";
        int v13 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_71;
      }
      int v18 = (char *)__nw_create_backtrace_string();
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!v18)
      {
        if (!v19) {
          goto LABEL_72;
        }
        *(_DWORD *)int buf = 136446210;
        __int16 v28 = "nw_protocol_http2_output_finished";
        int v13 = "%{public}s called with null http2, no backtrace";
        goto LABEL_71;
      }
      if (v19)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v28 = "nw_protocol_http2_output_finished";
        __int16 v29 = 2082;
        uint64_t v30 = v18;
        char v20 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_52:
        _os_log_impl(&dword_1830D4000, v11, v12, v20, buf, 0x16u);
      }
LABEL_53:
      free(v18);
      if (!v10) {
        return;
      }
LABEL_73:
      free(v10);
      return;
    }
    int v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_72;
    }
    *(_DWORD *)int buf = 136446210;
    __int16 v28 = "nw_protocol_http2_output_finished";
    int v13 = "%{public}s called with null http2";
LABEL_71:
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
    goto LABEL_72;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v28 = "nw_protocol_http2_output_finished";
    int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v10, &type, &v25)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v28 = "nw_protocol_http2_output_finished";
      int v13 = "%{public}s called with null other_protocol";
      goto LABEL_71;
    }
    if (!v25)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v28 = "nw_protocol_http2_output_finished";
      int v13 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_71;
    }
    int v18 = (char *)__nw_create_backtrace_string();
    int v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (!v18)
    {
      if (!v21) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v28 = "nw_protocol_http2_output_finished";
      int v13 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_71;
    }
    if (v21)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v28 = "nw_protocol_http2_output_finished";
      __int16 v29 = 2082;
      uint64_t v30 = v18;
      char v20 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_52;
    }
    goto LABEL_53;
  }
  if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v15 = handle[92];
      *(_DWORD *)int buf = 136446978;
      __int16 v28 = "nw_protocol_http2_output_finished";
      __int16 v29 = 2082;
      uint64_t v30 = (char *)handle + 390;
      __int16 v31 = 2080;
      BOOL v32 = " ";
      __int16 v33 = 1024;
      int v34 = v15;
      _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (output_handler_context)
  {
    uint64_t v5 = output_handler_context[4];
    if (v5)
    {
      if (((*(unsigned __int16 *)(v5 + 188) | (*(unsigned __int8 *)(v5 + 190) << 16)) & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v22 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v24 = *(_DWORD *)(v5 + 176);
          int v23 = *(_DWORD *)(v5 + 180);
          *(_DWORD *)int buf = 136447234;
          __int16 v28 = "nw_protocol_http2_output_finished";
          __int16 v29 = 2082;
          uint64_t v30 = (char *)(v5 + 191);
          __int16 v31 = 2080;
          BOOL v32 = " ";
          __int16 v33 = 1024;
          int v34 = v23;
          __int16 v35 = 1024;
          int v36 = v24;
          _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> sending non-deferred end stream", buf, 0x2Cu);
        }
      }
      nw_http2_send_end_stream((uint64_t)handle, v5);
      return;
    }
    if (((__int16)handle[97] & 0x80000000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v6 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        int v9 = handle[92];
        *(_DWORD *)int buf = 136446978;
        __int16 v28 = "nw_protocol_http2_output_finished";
        __int16 v29 = 2082;
        uint64_t v30 = (char *)handle + 390;
        __int16 v31 = 2080;
        BOOL v32 = " ";
        __int16 v33 = 1024;
        int v34 = v9;
        int v8 = "%{public}s %{public}s%s<i%u> couldn't get stream during output_finished";
        goto LABEL_21;
      }
    }
  }
  else if (((__int16)handle[97] & 0x80000000) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v6 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      int v7 = handle[92];
      *(_DWORD *)int buf = 136446978;
      __int16 v28 = "nw_protocol_http2_output_finished";
      __int16 v29 = 2082;
      uint64_t v30 = (char *)handle + 390;
      __int16 v31 = 2080;
      BOOL v32 = " ";
      __int16 v33 = 1024;
      int v34 = v7;
      int v8 = "%{public}s %{public}s%s<i%u> couldn't get output handler context during output_finished";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, v8, buf, 0x26u);
    }
  }
}

void nw_protocol_http2_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t handle = a1->handle;
    if (handle)
    {
      if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v16 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v17 = handle[92];
          *(_DWORD *)int buf = 136446978;
          uint64_t v30 = "nw_protocol_http2_disconnected";
          __int16 v31 = 2082;
          BOOL v32 = (char *)handle + 390;
          __int16 v33 = 2080;
          int v34 = " ";
          __int16 v35 = 1024;
          int v36 = v17;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
        }
      }
      nw_protocol_remove_instance((uint64_t)a1);
      uint64_t v4 = *((void *)handle + 18);
      if (!v4) {
        goto LABEL_9;
      }
      if (*(void *)v4)
      {
        uint64_t v5 = *(void (**)(void))(*(void *)v4 + 8);
        if (v5)
        {
          v5();
LABEL_9:
          nw_http2_connection_close((uint64_t)handle);
          return;
        }
      }
      __nwlog_obj();
      uint64_t v6 = (char *)*((void *)handle + 18);
      *(_DWORD *)int buf = 136446466;
      uint64_t v30 = "nw_protocol_http2_disconnected";
      __int16 v31 = 2048;
      BOOL v32 = v6;
      int v7 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v27 = 0;
      if (__nwlog_fault(v7, &type, &v27))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v8 = __nwlog_obj();
          os_log_type_t v9 = type;
          if (!os_log_type_enabled(v8, type)) {
            goto LABEL_52;
          }
          int v10 = (char *)*((void *)handle + 18);
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_protocol_http2_disconnected";
          __int16 v31 = 2048;
          BOOL v32 = v10;
          int v11 = "%{public}s listen protocol (%p) has invalid disconnected callback";
          goto LABEL_51;
        }
        if (!v27)
        {
          int v8 = __nwlog_obj();
          os_log_type_t v9 = type;
          if (!os_log_type_enabled(v8, type)) {
            goto LABEL_52;
          }
          char v25 = (char *)*((void *)handle + 18);
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_protocol_http2_disconnected";
          __int16 v31 = 2048;
          BOOL v32 = v25;
          int v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, backtrace limit exceeded";
          goto LABEL_51;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v19 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v19)
          {
            char v20 = (char *)*((void *)handle + 18);
            *(_DWORD *)int buf = 136446722;
            uint64_t v30 = "nw_protocol_http2_disconnected";
            __int16 v31 = 2048;
            BOOL v32 = v20;
            __int16 v33 = 2082;
            int v34 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s listen protocol (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_52;
        }
        if (v19)
        {
          int v26 = (char *)*((void *)handle + 18);
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_protocol_http2_disconnected";
          __int16 v31 = 2048;
          BOOL v32 = v26;
          int v11 = "%{public}s listen protocol (%p) has invalid disconnected callback, no backtrace";
LABEL_51:
          _os_log_impl(&dword_1830D4000, v8, v9, v11, buf, 0x16u);
        }
      }
LABEL_52:
      if (v7) {
        free(v7);
      }
      goto LABEL_9;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_protocol_http2_disconnected";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_protocol_http2_disconnected";
        int v15 = "%{public}s called with null http2";
        goto LABEL_58;
      }
      if (!v27)
      {
        int v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (!os_log_type_enabled(v13, type)) {
          goto LABEL_59;
        }
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_protocol_http2_disconnected";
        int v15 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_58;
      }
      int v23 = (char *)__nw_create_backtrace_string();
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v24 = os_log_type_enabled(v13, type);
      if (v23)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          uint64_t v30 = "nw_protocol_http2_disconnected";
          __int16 v31 = 2082;
          BOOL v32 = v23;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null http2, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v23);
        if (v12) {
          goto LABEL_60;
        }
        return;
      }
      if (v24)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v30 = "nw_protocol_http2_disconnected";
        int v15 = "%{public}s called with null http2, no backtrace";
LABEL_58:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v30 = "nw_protocol_http2_disconnected";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault(v12, &type, &v27)) {
      goto LABEL_59;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v30 = "nw_protocol_http2_disconnected";
      int v15 = "%{public}s called with null protocol";
      goto LABEL_58;
    }
    if (!v27)
    {
      int v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (!os_log_type_enabled(v13, type)) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v30 = "nw_protocol_http2_disconnected";
      int v15 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_58;
    }
    BOOL v21 = (char *)__nw_create_backtrace_string();
    int v13 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v22 = os_log_type_enabled(v13, type);
    if (!v21)
    {
      if (!v22) {
        goto LABEL_59;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v30 = "nw_protocol_http2_disconnected";
      int v15 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_58;
    }
    if (v22)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v30 = "nw_protocol_http2_disconnected";
      __int16 v31 = 2082;
      BOOL v32 = v21;
      _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v21);
  }
LABEL_59:
  if (v12) {
LABEL_60:
  }
    free(v12);
}

void nw_protocol_http2_disconnect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v56 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v45 = "nw_protocol_http2_disconnect";
    int v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v17, &type, &v42)) {
      goto LABEL_84;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_84;
      }
      *(_DWORD *)int buf = 136446210;
      int v45 = "nw_protocol_http2_disconnect";
      char v20 = "%{public}s called with null protocol";
    }
    else if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v24 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)int buf = 136446466;
          int v45 = "nw_protocol_http2_disconnect";
          __int16 v46 = 2082;
          int v47 = (nw_protocol_identifier *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_84:
        if (!v17) {
          return;
        }
        goto LABEL_85;
      }
      if (!v24) {
        goto LABEL_84;
      }
      *(_DWORD *)int buf = 136446210;
      int v45 = "nw_protocol_http2_disconnect";
      char v20 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_84;
      }
      *(_DWORD *)int buf = 136446210;
      int v45 = "nw_protocol_http2_disconnect";
      char v20 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_83;
  }
  uint64_t handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v45 = "nw_protocol_http2_disconnect";
    int v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v17, &type, &v42)) {
      goto LABEL_84;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v42)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (!os_log_type_enabled(v18, type)) {
          goto LABEL_84;
        }
        *(_DWORD *)int buf = 136446210;
        int v45 = "nw_protocol_http2_disconnect";
        char v20 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_83;
      }
      char v25 = (char *)__nw_create_backtrace_string();
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (!v25)
      {
        if (!v26) {
          goto LABEL_84;
        }
        *(_DWORD *)int buf = 136446210;
        int v45 = "nw_protocol_http2_disconnect";
        char v20 = "%{public}s called with null http2, no backtrace";
        goto LABEL_83;
      }
      if (v26)
      {
        *(_DWORD *)int buf = 136446466;
        int v45 = "nw_protocol_http2_disconnect";
        __int16 v46 = 2082;
        int v47 = (nw_protocol_identifier *)v25;
        char v27 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_53:
        _os_log_impl(&dword_1830D4000, v18, v19, v27, buf, 0x16u);
      }
LABEL_54:
      free(v25);
      if (!v17) {
        return;
      }
LABEL_85:
      int v38 = (char *)v17;
LABEL_86:
      free(v38);
      return;
    }
    int v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (!os_log_type_enabled(v18, type)) {
      goto LABEL_84;
    }
    *(_DWORD *)int buf = 136446210;
    int v45 = "nw_protocol_http2_disconnect";
    char v20 = "%{public}s called with null http2";
LABEL_83:
    _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0xCu);
    goto LABEL_84;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    int v45 = "nw_protocol_http2_disconnect";
    int v17 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v42 = 0;
    if (!__nwlog_fault(v17, &type, &v42)) {
      goto LABEL_84;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_84;
      }
      *(_DWORD *)int buf = 136446210;
      int v45 = "nw_protocol_http2_disconnect";
      char v20 = "%{public}s called with null other_protocol";
      goto LABEL_83;
    }
    if (!v42)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_84;
      }
      *(_DWORD *)int buf = 136446210;
      int v45 = "nw_protocol_http2_disconnect";
      char v20 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_83;
    }
    char v25 = (char *)__nw_create_backtrace_string();
    int v18 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v28 = os_log_type_enabled(v18, type);
    if (!v25)
    {
      if (!v28) {
        goto LABEL_84;
      }
      *(_DWORD *)int buf = 136446210;
      int v45 = "nw_protocol_http2_disconnect";
      char v20 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_83;
    }
    if (v28)
    {
      *(_DWORD *)int buf = 136446466;
      int v45 = "nw_protocol_http2_disconnect";
      __int16 v46 = 2082;
      int v47 = (nw_protocol_identifier *)v25;
      char v27 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  if (((__int16)handle[97] & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v21 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v22 = handle[92];
      *(_DWORD *)int buf = 136446978;
      int v45 = "nw_protocol_http2_disconnect";
      __int16 v46 = 2082;
      int v47 = (nw_protocol_identifier *)((char *)handle + 390);
      __int16 v48 = 2080;
      uint64_t v49 = " ";
      __int16 v50 = 1024;
      int v51 = v22;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    if ((__int16)handle[97] < 0) {
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v10 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v11 = handle[92];
    *(_DWORD *)int buf = 136446978;
    int v45 = "nw_protocol_http2_disconnect";
    __int16 v46 = 2082;
    int v47 = (nw_protocol_identifier *)((char *)handle + 390);
    __int16 v48 = 2080;
    uint64_t v49 = " ";
    __int16 v50 = 1024;
    int v51 = v11;
    os_log_type_t v12 = "%{public}s %{public}s%s<i%u> attempting to disconnect on protocol that doesn't have entry in table, ignoring";
    int v13 = v10;
    uint32_t v14 = 38;
LABEL_22:
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, v12, buf, v14);
    return;
  }
  uint64_t v5 = output_handler_context[4];
  if (!v5)
  {
    if ((__int16)handle[97] < 0) {
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v15 = gconnectionLogObj;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
      return;
    }
    int v16 = handle[92];
    *(_DWORD *)int buf = 136447490;
    int v45 = "nw_protocol_http2_disconnect";
    __int16 v46 = 2082;
    int v47 = (nw_protocol_identifier *)((char *)handle + 390);
    __int16 v48 = 2080;
    uint64_t v49 = " ";
    __int16 v50 = 1024;
    int v51 = v16;
    __int16 v52 = 2048;
    __int16 v53 = a2;
    __int16 v54 = 2048;
    uint64_t v55 = output_handler_context;
    os_log_type_t v12 = "%{public}s %{public}s%s<i%u> protocol (%p) node (%p) has no stream pointer as extra";
    int v13 = v15;
    uint32_t v14 = 58;
    goto LABEL_22;
  }
  nw_http2_stream_close((uint64_t)handle, output_handler_context[4]);
  int v6 = *(unsigned __int16 *)(v5 + 188);
  int v7 = v6 | (*(unsigned __int8 *)(v5 + 190) << 16);
  if ((v6 & 0x40) != 0) {
    return;
  }
  *(unsigned char *)(v5 + 190) = BYTE2(v7);
  *(_WORD *)(v5 + 188) = v7 | 0x40;
  callbacks = a2->callbacks;
  if (callbacks)
  {
    disconnected = (void (*)(nw_protocol *, _DWORD *))callbacks->disconnected;
    if (disconnected)
    {
      disconnected(a2, handle);
      return;
    }
  }
  __nwlog_obj();
  identifier = a2->identifier;
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  *(_DWORD *)int buf = 136446466;
  int v45 = "nw_protocol_http2_disconnect";
  __int16 v46 = 2082;
  int v47 = identifier;
  uint64_t v30 = (const char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (!__nwlog_fault(v30, &type, &v42)) {
    goto LABEL_96;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    __int16 v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    if (!os_log_type_enabled(v31, type)) {
      goto LABEL_96;
    }
    __int16 v33 = a2->identifier;
    if (!v33) {
      __int16 v33 = (nw_protocol_identifier *)"invalid";
    }
    *(_DWORD *)int buf = 136446466;
    int v45 = "nw_protocol_http2_disconnect";
    __int16 v46 = 2082;
    int v47 = v33;
    int v34 = "%{public}s protocol %{public}s has invalid disconnected callback";
LABEL_95:
    _os_log_impl(&dword_1830D4000, v31, v32, v34, buf, 0x16u);
    goto LABEL_96;
  }
  if (!v42)
  {
    __int16 v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v39 = os_log_type_enabled(v31, type);
    BOOL v40 = (nw_protocol_identifier *)"invalid";
    if (!v39) {
      goto LABEL_96;
    }
    if (a2->identifier) {
      BOOL v40 = a2->identifier;
    }
    *(_DWORD *)int buf = 136446466;
    int v45 = "nw_protocol_http2_disconnect";
    __int16 v46 = 2082;
    int v47 = v40;
    int v34 = "%{public}s protocol %{public}s has invalid disconnected callback, backtrace limit exceeded";
    goto LABEL_95;
  }
  __int16 v35 = (char *)__nw_create_backtrace_string();
  __int16 v31 = __nwlog_obj();
  os_log_type_t v32 = type;
  BOOL v36 = os_log_type_enabled(v31, type);
  if (!v35)
  {
    os_log_type_t v41 = (nw_protocol_identifier *)"invalid";
    if (!v36) {
      goto LABEL_96;
    }
    if (a2->identifier) {
      os_log_type_t v41 = a2->identifier;
    }
    *(_DWORD *)int buf = 136446466;
    int v45 = "nw_protocol_http2_disconnect";
    __int16 v46 = 2082;
    int v47 = v41;
    int v34 = "%{public}s protocol %{public}s has invalid disconnected callback, no backtrace";
    goto LABEL_95;
  }
  if (v36)
  {
    uint64_t v37 = (nw_protocol_identifier *)"invalid";
    if (a2->identifier) {
      uint64_t v37 = a2->identifier;
    }
    *(_DWORD *)int buf = 136446722;
    int v45 = "nw_protocol_http2_disconnect";
    __int16 v46 = 2082;
    int v47 = v37;
    __int16 v48 = 2082;
    uint64_t v49 = v35;
    _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s protocol %{public}s has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x20u);
  }
  free(v35);
LABEL_96:
  if (v30)
  {
    int v38 = (char *)v30;
    goto LABEL_86;
  }
}

void nw_protocol_http2_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v15, &type, &v54)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      int v18 = "%{public}s called with null protocol";
    }
    else if (v54)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v22 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_130:
        if (!v15) {
          return;
        }
LABEL_131:
        free(v15);
        return;
      }
      if (!v22) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      int v18 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      int v18 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_129;
  }
  uint64_t handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v15, &type, &v54)) {
      goto LABEL_130;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v54)
      {
        int v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_130;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
        int v18 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_129;
      }
      int v23 = (char *)__nw_create_backtrace_string();
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v24 = os_log_type_enabled(v16, type);
      if (!v23)
      {
        if (!v24) {
          goto LABEL_130;
        }
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
        int v18 = "%{public}s called with null http2, no backtrace";
        goto LABEL_129;
      }
      if (v24)
      {
        *(_DWORD *)int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v23;
        char v25 = "%{public}s called with null http2, dumping backtrace:%{public}s";
LABEL_55:
        _os_log_impl(&dword_1830D4000, v16, v17, v25, buf, 0x16u);
      }
LABEL_56:
      free(v23);
      if (!v15) {
        return;
      }
      goto LABEL_131;
    }
    int v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (!os_log_type_enabled(v16, type)) {
      goto LABEL_130;
    }
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
    int v18 = "%{public}s called with null http2";
LABEL_129:
    _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0xCu);
    goto LABEL_130;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
    uint64_t v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (!__nwlog_fault(v15, &type, &v54)) {
      goto LABEL_130;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      int v18 = "%{public}s called with null other_protocol";
      goto LABEL_129;
    }
    if (!v54)
    {
      int v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      int v18 = "%{public}s called with null other_protocol, backtrace limit exceeded";
      goto LABEL_129;
    }
    int v23 = (char *)__nw_create_backtrace_string();
    int v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v26 = os_log_type_enabled(v16, type);
    if (!v23)
    {
      if (!v26) {
        goto LABEL_130;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      int v18 = "%{public}s called with null other_protocol, no backtrace";
      goto LABEL_129;
    }
    if (v26)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v23;
      char v25 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_55;
    }
    goto LABEL_56;
  }
  if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v19 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v20 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = handle + 390;
      *(_WORD *)&buf[22] = 2080;
      BOOL v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v20;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      connected = (void (*)(void))callbacks->connected;
      if (connected) {
        connected();
      }
    }
  }
  if (a1->output_handler != a2)
  {
    if ((*((__int16 *)handle + 194) & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v8 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v9 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v9;
        uint64_t v10 = "%{public}s %{public}s%s<i%u> connected protocol is not our output_handler, ignoring";
LABEL_69:
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, v10, buf, 0x26u);
        return;
      }
    }
    return;
  }
  int v11 = *((__int16 *)handle + 194);
  if (v11 < 0)
  {
    if ((v11 & 0x80) == 0) {
      goto LABEL_20;
    }
  }
  else
  {
    if (gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v49 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v50 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v50;
        _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
      }
    }
    LOWORD(v11) = *((_WORD *)handle + 194);
    if ((v11 & 0x80) == 0)
    {
LABEL_20:
      if ((v11 & 0x8000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v12 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v13 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = handle + 390;
          *(_WORD *)&buf[22] = 2080;
          BOOL v57 = " ";
          LOWORD(v58) = 1024;
          *(_DWORD *)((char *)&v58 + 2) = v13;
          uint32_t v14 = "%{public}s %{public}s%s<i%u> not server, processing input without waiting";
LABEL_136:
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, v14, buf, 0x26u);
          goto LABEL_62;
        }
      }
      goto LABEL_62;
    }
  }
  if (!*((void *)handle + 18))
  {
    if ((v11 & 0x8000) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v35 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        int v36 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v36;
        _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s<i%u> no listen handler on server, deferring processing of input and connected state until listen handler is present", buf, 0x26u);
      }
    }
    *((_WORD *)handle + 194) |= 0x1000u;
    return;
  }
  if ((v11 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v12 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v51 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = handle + 390;
      *(_WORD *)&buf[22] = 2080;
      BOOL v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v51;
      uint32_t v14 = "%{public}s %{public}s%s<i%u> listen handler present, processing input without waiting";
      goto LABEL_136;
    }
  }
LABEL_62:
  __int16 v27 = *((_WORD *)handle + 194);
  *((_WORD *)handle + 194) = v27 & 0xEFFF;
  if ((v27 & 0xC) == 0)
  {
    nw_http2_send_settings((uint64_t)handle);
    int v29 = *((__int16 *)handle + 194);
    *((_WORD *)handle + 194) |= 4u;
    if ((v29 & 0x80000000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v52 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v53 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v53;
        _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2 tunnel is now connected", buf, 0x26u);
      }
    }
    uint64_t v30 = (void *)*((void *)handle + 14);
    if (v30)
    {
      __int16 v31 = v30;
      BOOL v32 = (v31[231] & 4) == 0;

      if (v32)
      {
        if ((*((__int16 *)handle + 194) & 0x80000000) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v33 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            int v34 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = handle + 390;
            *(_WORD *)&buf[22] = 2080;
            BOOL v57 = " ";
            LOWORD(v58) = 1024;
            *(_DWORD *)((char *)&v58 + 2) = v34;
            _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered", buf, 0x26u);
          }
        }
      }
      else
      {
        nw_endpoint_add_edges_for_instance(v31, handle, 1);
      }
      goto LABEL_111;
    }
    if (*((__int16 *)handle + 194) < 0)
    {
LABEL_111:
      nw_protocol_http2_process_input((uint64_t)handle);
      __int16 v48 = (char *)*((void *)handle + 19);
      *(void *)int buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 0x40000000;
      *(void *)&buf[16] = ___ZL35nw_protocol_http2_process_connectedP17nw_protocol_http2_block_invoke;
      BOOL v57 = (const char *)&__block_descriptor_tmp_50_84149;
      int v58 = handle;
      nw_hash_table_apply(v48, (uint64_t)buf);
      return;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v37 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = handle + 390;
    *(_WORD *)&buf[22] = 2080;
    BOOL v57 = " ";
    LOWORD(v58) = 1024;
    *(_DWORD *)((char *)&v58 + 2) = v37;
    int v38 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (__nwlog_fault(v38, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v39 = gconnectionLogObj;
        os_log_type_t v40 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_109;
        }
        int v41 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v41;
        char v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
        goto LABEL_108;
      }
      if (!v54)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v39 = gconnectionLogObj;
        os_log_type_t v40 = type;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_109;
        }
        int v46 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v46;
        char v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
        goto LABEL_108;
      }
      uint64_t v43 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v39 = gconnectionLogObj;
      os_log_type_t v40 = type;
      BOOL v44 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v43)
      {
        if (v44)
        {
          int v45 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = handle + 390;
          *(_WORD *)&buf[22] = 2080;
          BOOL v57 = " ";
          LOWORD(v58) = 1024;
          *(_DWORD *)((char *)&v58 + 2) = v45;
          HIWORD(v58) = 2082;
          int v59 = v43;
          _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s", buf, 0x30u);
        }
        free(v43);
        goto LABEL_109;
      }
      if (v44)
      {
        int v47 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = handle + 390;
        *(_WORD *)&buf[22] = 2080;
        BOOL v57 = " ";
        LOWORD(v58) = 1024;
        *(_DWORD *)((char *)&v58 + 2) = v47;
        char v42 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_108:
        _os_log_impl(&dword_1830D4000, v39, v40, v42, buf, 0x26u);
      }
    }
LABEL_109:
    if (v38) {
      free(v38);
    }
    goto LABEL_111;
  }
  if ((v27 & 0x8000) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v8 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v28 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_protocol_http2_process_connected";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = handle + 390;
      *(_WORD *)&buf[22] = 2080;
      BOOL v57 = " ";
      LOWORD(v58) = 1024;
      *(_DWORD *)((char *)&v58 + 2) = v28;
      uint64_t v10 = "%{public}s %{public}s%s<i%u> tunnel already connected or closed, ignoring connected event";
      goto LABEL_69;
    }
  }
}

BOOL nw_protocol_http2_connect(nw_protocol *a1, nw_protocol *a2)
{
  *(void *)&v111[11] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v102 = "nw_protocol_http2_connect";
    uint64_t v62 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (!__nwlog_fault(v62, &type, &v99)) {
      goto LABEL_193;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v63 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (!os_log_type_enabled(v63, type)) {
        goto LABEL_193;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v102 = "nw_protocol_http2_connect";
      int v65 = "%{public}s called with null protocol";
LABEL_192:
      _os_log_impl(&dword_1830D4000, v63, v64, v65, buf, 0xCu);
      goto LABEL_193;
    }
    if (!v99)
    {
      BOOL v63 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v63 = __nwlog_obj();
    os_log_type_t v64 = type;
    BOOL v79 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v79)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    if (!v79) {
      goto LABEL_167;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v102 = "nw_protocol_http2_connect";
    __int16 v103 = 2082;
    int v104 = backtrace_string;
    int v80 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_166:
    _os_log_impl(&dword_1830D4000, v63, v64, v80, buf, 0x16u);
    goto LABEL_167;
  }
  uint64_t handle = (__int16 *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v102 = "nw_protocol_http2_connect";
    uint64_t v62 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (!__nwlog_fault(v62, &type, &v99)) {
      goto LABEL_193;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v63 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (!os_log_type_enabled(v63, type)) {
        goto LABEL_193;
      }
      *(_DWORD *)int buf = 136446210;
      uint64_t v102 = "nw_protocol_http2_connect";
      int v65 = "%{public}s called with null http2";
      goto LABEL_192;
    }
    if (!v99)
    {
      BOOL v63 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null http2, backtrace limit exceeded";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v63 = __nwlog_obj();
    os_log_type_t v64 = type;
    BOOL v81 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v81)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null http2, no backtrace";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    if (!v81) {
      goto LABEL_167;
    }
    *(_DWORD *)int buf = 136446466;
    uint64_t v102 = "nw_protocol_http2_connect";
    __int16 v103 = 2082;
    int v104 = backtrace_string;
    int v80 = "%{public}s called with null http2, dumping backtrace:%{public}s";
    goto LABEL_166;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    uint64_t v102 = "nw_protocol_http2_connect";
    uint64_t v62 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (!__nwlog_fault(v62, &type, &v99)) {
      goto LABEL_193;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v63 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null other_protocol";
        goto LABEL_192;
      }
LABEL_193:
      if (!v62) {
        return 0;
      }
      uint64_t v61 = (char *)v62;
      goto LABEL_122;
    }
    if (!v99)
    {
      BOOL v63 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v63, type))
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v63 = __nwlog_obj();
    os_log_type_t v64 = type;
    BOOL v82 = os_log_type_enabled(v63, type);
    if (!backtrace_string)
    {
      if (v82)
      {
        *(_DWORD *)int buf = 136446210;
        uint64_t v102 = "nw_protocol_http2_connect";
        int v65 = "%{public}s called with null other_protocol, no backtrace";
        goto LABEL_192;
      }
      goto LABEL_193;
    }
    if (v82)
    {
      *(_DWORD *)int buf = 136446466;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = backtrace_string;
      int v80 = "%{public}s called with null other_protocol, dumping backtrace:%{public}s";
      goto LABEL_166;
    }
LABEL_167:
    free(backtrace_string);
    goto LABEL_193;
  }
  int v5 = handle[194];
  if (v5 < 0)
  {
    if ((v5 & 8) == 0) {
      goto LABEL_7;
    }
LABEL_137:
    BOOL result = 1;
    if ((v5 & 0x8000) == 0 && gLogDatapath)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v83 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
      {
        int v84 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136446978;
        uint64_t v102 = "nw_protocol_http2_connect";
        __int16 v103 = 2082;
        int v104 = (char *)(handle + 195);
        __int16 v105 = 2080;
        int v106 = " ";
        __int16 v107 = 1024;
        int v108 = v84;
        _os_log_impl(&dword_1830D4000, v83, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> tunnel already closed, ignoring connect with success", buf, 0x26u);
      }
      return 1;
    }
    return result;
  }
  if (gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v66 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v67 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)(handle + 195);
      __int16 v105 = 2080;
      int v106 = " ";
      __int16 v107 = 1024;
      int v108 = v67;
      _os_log_impl(&dword_1830D4000, v66, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> called", buf, 0x26u);
    }
  }
  LOWORD(v5) = handle[194];
  if ((v5 & 8) != 0) {
    goto LABEL_137;
  }
LABEL_7:
  if (!*((void *)handle + 8))
  {
    uint64_t v6 = mach_continuous_time();
    uint64_t v7 = v6 <= 1 ? 1 : v6;
    *((void *)handle + 8) = v7;
    uint64_t v8 = nw_protocol_copy_info(*((void *)handle + 4), 255);
    if (v8)
    {
      int v9 = (void *)v8;
      uint64_t v10 = *(void *)(v8 + 24);
      if (*(void *)(v8 + 16) != v10)
      {
        int v11 = *(void **)(v10 - 8);
        if (v11)
        {
          os_log_type_t v12 = os_retain(v11);
          if (v12)
          {
            int v13 = v12;
            if (nw_protocol_metadata_is_tls(v12))
            {
              uint32_t v14 = v13;
              nw_http_connection_metadata_set_sec_metadata(*((void **)handle + 32), v14);
              os_release(v14);
            }
            os_release(v13);
          }
        }
      }
      os_release(v9);
    }
  }
  output_handler_context = a2->output_handler_context;
  if ((handle[194] & 4) == 0)
  {
    if (!output_handler_context) {
      goto LABEL_24;
    }
    uint64_t v16 = output_handler_context[4];
    if (v16)
    {
      int v17 = *(unsigned __int16 *)(v16 + 188);
      int v18 = v17 | (*(unsigned __int8 *)(v16 + 190) << 16);
      *(_WORD *)(v16 + 188) = v17 | 8;
      if ((v18 & 0x80000) == 0 && gLogDatapath)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v93 = gconnectionLogObj;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v95 = *(_DWORD *)(v16 + 176);
          int v94 = *(_DWORD *)(v16 + 180);
          *(_DWORD *)int buf = 136447746;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)(v16 + 191);
          __int16 v105 = 2080;
          int v106 = " ";
          __int16 v107 = 1024;
          int v108 = v94;
          __int16 v109 = 1024;
          *(_DWORD *)uint64_t v110 = v95;
          *(_WORD *)&v110[4] = 1024;
          *(_DWORD *)&v110[6] = v95;
          v111[0] = 2048;
          *(void *)&v111[1] = v16;
          _os_log_impl(&dword_1830D4000, v93, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u:s%d> marked stream id %d (%p) as waiting for connect", buf, 0x3Cu);
        }
      }
LABEL_24:
      os_log_type_t v19 = (void *)*((void *)handle + 14);
      if (v19)
      {
        int v20 = v19;
        BOOL v21 = (v20[231] & 4) == 0;

        if (v21)
        {
          if ((handle[194] & 0x80000000) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v22 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v23 = *((_DWORD *)handle + 92);
              *(_DWORD *)int buf = 136446978;
              uint64_t v102 = "nw_protocol_http2_connect";
              __int16 v103 = 2082;
              int v104 = (char *)(handle + 195);
              __int16 v105 = 2080;
              int v106 = " ";
              __int16 v107 = 1024;
              int v108 = v23;
              _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s<i%u> http2's remote endpoint is not registered", buf, 0x26u);
            }
          }
        }
        else
        {
          nw_endpoint_add_edges_for_instance(v20, (atomic_uchar *)handle, 0);
        }
        goto LABEL_110;
      }
      if (handle[194] < 0) {
        goto LABEL_110;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v34 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136446978;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)(handle + 195);
      __int16 v105 = 2080;
      int v106 = " ";
      __int16 v107 = 1024;
      int v108 = v34;
      __int16 v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v99 = 0;
      if (__nwlog_fault(v35, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v36 = gconnectionLogObj;
          os_log_type_t v37 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_108;
          }
          int v38 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)(handle + 195);
          __int16 v105 = 2080;
          int v106 = " ";
          __int16 v107 = 1024;
          int v108 = v38;
          BOOL v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint";
          goto LABEL_107;
        }
        if (!v99)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v36 = gconnectionLogObj;
          os_log_type_t v37 = type;
          if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
            goto LABEL_108;
          }
          int v54 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)(handle + 195);
          __int16 v105 = 2080;
          int v106 = " ";
          __int16 v107 = 1024;
          int v108 = v54;
          BOOL v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, backtrace limit exceeded";
          goto LABEL_107;
        }
        int v47 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v36 = gconnectionLogObj;
        os_log_type_t v37 = type;
        BOOL v48 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v47)
        {
          if (v48)
          {
            int v49 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136447234;
            uint64_t v102 = "nw_protocol_http2_connect";
            __int16 v103 = 2082;
            int v104 = (char *)(handle + 195);
            __int16 v105 = 2080;
            int v106 = " ";
            __int16 v107 = 1024;
            int v108 = v49;
            __int16 v109 = 2082;
            *(void *)uint64_t v110 = v47;
            _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, dumping backtrace:%{public}s", buf, 0x30u);
          }
          free(v47);
          goto LABEL_108;
        }
        if (v48)
        {
          int v56 = *((_DWORD *)handle + 92);
          *(_DWORD *)int buf = 136446978;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)(handle + 195);
          __int16 v105 = 2080;
          int v106 = " ";
          __int16 v107 = 1024;
          int v108 = v56;
          BOOL v39 = "%{public}s %{public}s%s<i%u> http2 does not have remote endpoint, no backtrace";
LABEL_107:
          _os_log_impl(&dword_1830D4000, v36, v37, v39, buf, 0x26u);
        }
      }
LABEL_108:
      if (v35) {
        free(v35);
      }
LABEL_110:
      output_handler = a1->output_handler;
      if (output_handler)
      {
        callbacks = output_handler->callbacks;
        if (callbacks)
        {
          connect = (void (*)(nw_protocol *, nw_protocol *))callbacks->connect;
          if (connect)
          {
            connect(output_handler, a1);
            return 1;
          }
        }
      }
      __nwlog_obj();
      BOOL v68 = a1->output_handler;
      int v69 = "invalid";
      if (v68)
      {
        identifier = v68->identifier;
        if (identifier) {
          int v69 = (const char *)identifier;
        }
      }
      *(_DWORD *)int buf = 136446466;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)v69;
      uint64_t v71 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v99 = 0;
      if (__nwlog_fault(v71, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v72 = __nwlog_obj();
          os_log_type_t v73 = type;
          if (!os_log_type_enabled(v72, type)) {
            goto LABEL_210;
          }
          BOOL v74 = a1->output_handler;
          unsigned int v75 = "invalid";
          if (v74)
          {
            int v76 = v74->identifier;
            if (v76) {
              unsigned int v75 = (const char *)v76;
            }
          }
          *(_DWORD *)int buf = 136446466;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)v75;
          int v77 = "%{public}s protocol %{public}s has invalid connect callback";
          goto LABEL_209;
        }
        if (!v99)
        {
          uint64_t v72 = __nwlog_obj();
          os_log_type_t v73 = type;
          if (!os_log_type_enabled(v72, type)) {
            goto LABEL_210;
          }
          int v90 = a1->output_handler;
          BOOL v91 = "invalid";
          if (v90)
          {
            os_log_type_t v92 = v90->identifier;
            if (v92) {
              BOOL v91 = (const char *)v92;
            }
          }
          *(_DWORD *)int buf = 136446466;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)v91;
          int v77 = "%{public}s protocol %{public}s has invalid connect callback, backtrace limit exceeded";
          goto LABEL_209;
        }
        int v85 = (char *)__nw_create_backtrace_string();
        uint64_t v72 = __nwlog_obj();
        os_log_type_t v73 = type;
        BOOL v86 = os_log_type_enabled(v72, type);
        if (v85)
        {
          if (v86)
          {
            uint64_t v87 = a1->output_handler;
            uint32_t v88 = "invalid";
            if (v87)
            {
              BOOL v89 = v87->identifier;
              if (v89) {
                uint32_t v88 = (const char *)v89;
              }
            }
            *(_DWORD *)int buf = 136446722;
            uint64_t v102 = "nw_protocol_http2_connect";
            __int16 v103 = 2082;
            int v104 = (char *)v88;
            __int16 v105 = 2082;
            int v106 = v85;
            _os_log_impl(&dword_1830D4000, v72, v73, "%{public}s protocol %{public}s has invalid connect callback, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(v85);
          goto LABEL_210;
        }
        if (v86)
        {
          unsigned int v96 = a1->output_handler;
          char v97 = "invalid";
          if (v96)
          {
            uint64_t v98 = v96->identifier;
            if (v98) {
              char v97 = (const char *)v98;
            }
          }
          *(_DWORD *)int buf = 136446466;
          uint64_t v102 = "nw_protocol_http2_connect";
          __int16 v103 = 2082;
          int v104 = (char *)v97;
          int v77 = "%{public}s protocol %{public}s has invalid connect callback, no backtrace";
LABEL_209:
          _os_log_impl(&dword_1830D4000, v72, v73, v77, buf, 0x16u);
        }
      }
LABEL_210:
      if (v71) {
        free(v71);
      }
      return 1;
    }
    if (handle[194] < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v40 = *((_DWORD *)handle + 92);
    *(_DWORD *)int buf = 136447234;
    uint64_t v102 = "nw_protocol_http2_connect";
    __int16 v103 = 2082;
    int v104 = (char *)(handle + 195);
    __int16 v105 = 2080;
    int v106 = " ";
    __int16 v107 = 1024;
    int v108 = v40;
    __int16 v109 = 2048;
    *(void *)uint64_t v110 = a2;
    int v41 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v99 = 0;
    if (!__nwlog_fault(v41, &type, &v99)) {
      goto LABEL_120;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v42 = gconnectionLogObj;
      os_log_type_t v43 = type;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, type))
      {
LABEL_63:
        int v44 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447234;
        uint64_t v102 = "nw_protocol_http2_connect";
        __int16 v103 = 2082;
        int v104 = (char *)(handle + 195);
        __int16 v105 = 2080;
        int v106 = " ";
        __int16 v107 = 1024;
        int v108 = v44;
        __int16 v109 = 2048;
        *(void *)uint64_t v110 = a2;
        int v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra";
LABEL_119:
        _os_log_impl(&dword_1830D4000, v42, v43, v45, buf, 0x30u);
      }
LABEL_120:
      if (v41)
      {
        uint64_t v61 = (char *)v41;
LABEL_122:
        free(v61);
      }
      return 0;
    }
    if (v99)
    {
      int v50 = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v42 = gconnectionLogObj;
      os_log_type_t v43 = type;
      BOOL v51 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
      if (v50)
      {
        if (v51) {
          goto LABEL_91;
        }
        goto LABEL_92;
      }
      if (!v51) {
        goto LABEL_120;
      }
      goto LABEL_118;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    char v42 = gconnectionLogObj;
    os_log_type_t v43 = type;
    if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
      goto LABEL_120;
    }
    goto LABEL_100;
  }
  if (output_handler_context)
  {
    uint64_t v24 = output_handler_context[4];
    if (!v24)
    {
      if (handle[194] < 0) {
        return 0;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v46 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447234;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)(handle + 195);
      __int16 v105 = 2080;
      int v106 = " ";
      __int16 v107 = 1024;
      int v108 = v46;
      __int16 v109 = 2048;
      *(void *)uint64_t v110 = a2;
      int v41 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v99 = 0;
      if (!__nwlog_fault(v41, &type, &v99)) {
        goto LABEL_120;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v42 = gconnectionLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
          goto LABEL_63;
        }
        goto LABEL_120;
      }
      if (v99)
      {
        int v50 = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        char v42 = gconnectionLogObj;
        os_log_type_t v43 = type;
        BOOL v52 = os_log_type_enabled((os_log_t)gconnectionLogObj, type);
        if (v50)
        {
          if (v52)
          {
LABEL_91:
            int v53 = *((_DWORD *)handle + 92);
            *(_DWORD *)int buf = 136447490;
            uint64_t v102 = "nw_protocol_http2_connect";
            __int16 v103 = 2082;
            int v104 = (char *)(handle + 195);
            __int16 v105 = 2080;
            int v106 = " ";
            __int16 v107 = 1024;
            int v108 = v53;
            __int16 v109 = 2048;
            *(void *)uint64_t v110 = a2;
            *(_WORD *)&v110[8] = 2082;
            *(void *)uint64_t v111 = v50;
            _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, dumping backtrace:%{public}s", buf, 0x3Au);
          }
LABEL_92:
          free(v50);
          goto LABEL_120;
        }
        if (!v52) {
          goto LABEL_120;
        }
LABEL_118:
        int v60 = *((_DWORD *)handle + 92);
        *(_DWORD *)int buf = 136447234;
        uint64_t v102 = "nw_protocol_http2_connect";
        __int16 v103 = 2082;
        int v104 = (char *)(handle + 195);
        __int16 v105 = 2080;
        int v106 = " ";
        __int16 v107 = 1024;
        int v108 = v60;
        __int16 v109 = 2048;
        *(void *)uint64_t v110 = a2;
        int v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, no backtrace";
        goto LABEL_119;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v42 = gconnectionLogObj;
      os_log_type_t v43 = type;
      if (!os_log_type_enabled((os_log_t)gconnectionLogObj, type)) {
        goto LABEL_120;
      }
LABEL_100:
      int v55 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447234;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)(handle + 195);
      __int16 v105 = 2080;
      int v106 = " ";
      __int16 v107 = 1024;
      int v108 = v55;
      __int16 v109 = 2048;
      *(void *)uint64_t v110 = a2;
      int v45 = "%{public}s %{public}s%s<i%u> hash node for protocol %p did not have stream as extra, backtrace limit exceeded";
      goto LABEL_119;
    }
    if (nw_http2_stream_connect((uint64_t)handle, output_handler_context[4], (uint64_t)a2)) {
      return 1;
    }
    if (((*(unsigned __int16 *)(v24 + 188) | (*(unsigned __int8 *)(v24 + 190) << 16)) & 0x80000) != 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v25 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v28 = *(_DWORD *)(v24 + 176);
      int v27 = *(_DWORD *)(v24 + 180);
      *(_DWORD *)int buf = 136447746;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)(v24 + 191);
      __int16 v105 = 2080;
      int v106 = " ";
      __int16 v107 = 1024;
      int v108 = v27;
      __int16 v109 = 1024;
      *(_DWORD *)uint64_t v110 = v28;
      *(_WORD *)&v110[4] = 1024;
      *(_DWORD *)&v110[6] = v28;
      v111[0] = 2048;
      *(void *)&v111[1] = v24;
      int v29 = "%{public}s %{public}s%s<i%u:s%d> nw_http2_stream_connect failed for stream id %d (%p)";
      uint64_t v30 = v25;
      uint32_t v31 = 60;
LABEL_44:
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, v29, buf, v31);
      return 0;
    }
  }
  else
  {
    if (handle[194] < 0) {
      return 0;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v32 = gconnectionLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v33 = *((_DWORD *)handle + 92);
      *(_DWORD *)int buf = 136447234;
      uint64_t v102 = "nw_protocol_http2_connect";
      __int16 v103 = 2082;
      int v104 = (char *)(handle + 195);
      __int16 v105 = 2080;
      int v106 = " ";
      __int16 v107 = 1024;
      int v108 = v33;
      __int16 v109 = 2048;
      *(void *)uint64_t v110 = a2;
      int v29 = "%{public}s %{public}s%s<i%u> connect called on protocol %p which is not in protocol hash table";
      uint64_t v30 = v32;
      uint32_t v31 = 48;
      goto LABEL_44;
    }
  }
  return result;
}

double __nw_protocol_http2_identifier_block_invoke()
{
  strcpy((char *)&nw_protocol_http2_identifier::http2_protocol_identifier, "http2");
  *(void *)&double result = 0x200000004;
  qword_1E8F6B6DC = 0x200000004;
  return result;
}

uint64_t nw_network_agent_ctl_setsockopt(int a1, int a2, unsigned __int8 *uu, unsigned char *a4, unsigned char *a5, uint64_t a6, int a7, int a8, char a9, char a10, char a11, char a12, char a13, char a14, char a15, char a16, unsigned __int8 a17, unsigned __int8 a18, char a19, const unsigned __int8 *a20,unsigned int a21)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (a2 == 2)
  {
    return nw_network_agent_ctl_setsockopt_inner(a1, 2, 0, 0, 0, 0);
  }
  if (!uu)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
    int v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (!__nwlog_fault(v27, &type, &v49)) {
      goto LABEL_122;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null netagent_uuid";
      goto LABEL_120;
    }
    if (!v49)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
      goto LABEL_120;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v28 = __nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v42 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v42) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null netagent_uuid, no backtrace";
      goto LABEL_120;
    }
    if (!v42) {
      goto LABEL_152;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    os_log_type_t v43 = "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s";
    goto LABEL_151;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
    int v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (!__nwlog_fault(v27, &type, &v49)) {
      goto LABEL_122;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null domain";
      goto LABEL_120;
    }
    if (!v49)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null domain, backtrace limit exceeded";
      goto LABEL_120;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v28 = __nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v44 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v44) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null domain, no backtrace";
      goto LABEL_120;
    }
    if (!v44) {
      goto LABEL_152;
    }
    *(_DWORD *)int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    os_log_type_t v43 = "%{public}s called with null domain, dumping backtrace:%{public}s";
LABEL_151:
    _os_log_impl(&dword_1830D4000, v28, v29, v43, buf, 0x16u);
    goto LABEL_152;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
    int v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (!__nwlog_fault(v27, &type, &v49)) {
      goto LABEL_122;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null type";
      goto LABEL_120;
    }
    if (!v49)
    {
      int v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null type, backtrace limit exceeded";
      goto LABEL_120;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v28 = __nwlog_obj();
    os_log_type_t v29 = type;
    BOOL v45 = os_log_type_enabled(v28, type);
    if (!backtrace_string)
    {
      if (!v45) {
        goto LABEL_122;
      }
      *(_DWORD *)int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      uint64_t v30 = "%{public}s called with null type, no backtrace";
      goto LABEL_120;
    }
    if (v45)
    {
      *(_DWORD *)int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      os_log_type_t v43 = "%{public}s called with null type, dumping backtrace:%{public}s";
      goto LABEL_151;
    }
LABEL_152:
    free(backtrace_string);
    goto LABEL_122;
  }
  if (!uuid_is_null(uu))
  {
    uint64_t v57 = 0;
    long long v56 = 0u;
    long long v54 = 0u;
    memset(v55, 0, sizeof(v55));
    long long v52 = 0u;
    long long v53 = 0u;
    *(_OWORD *)int buf = *(_OWORD *)uu;
    *(_OWORD *)&buf[16] = 0u;
    buf[16] = *a4;
    if (buf[16])
    {
      buf[17] = a4[1];
      if (buf[17])
      {
        buf[18] = a4[2];
        if (buf[18])
        {
          buf[19] = a4[3];
          if (buf[19])
          {
            buf[20] = a4[4];
            if (buf[20])
            {
              buf[21] = a4[5];
              if (buf[21])
              {
                buf[22] = a4[6];
                if (buf[22])
                {
                  buf[23] = a4[7];
                  if (buf[23])
                  {
                    unsigned char buf[24] = a4[8];
                    if (buf[24])
                    {
                      buf[25] = a4[9];
                      if (buf[25])
                      {
                        buf[26] = a4[10];
                        if (buf[26])
                        {
                          buf[27] = a4[11];
                          if (buf[27])
                          {
                            buf[28] = a4[12];
                            if (buf[28])
                            {
                              buf[29] = a4[13];
                              if (buf[29])
                              {
                                buf[30] = a4[14];
                                if (buf[30])
                                {
                                  buf[31] = a4[15];
                                  if (buf[31])
                                  {
                                    LOBYTE(v52) = a4[16];
                                    if ((_BYTE)v52)
                                    {
                                      BYTE1(v52) = a4[17];
                                      if (BYTE1(v52))
                                      {
                                        BYTE2(v52) = a4[18];
                                        if (BYTE2(v52))
                                        {
                                          BYTE3(v52) = a4[19];
                                          if (BYTE3(v52))
                                          {
                                            BYTE4(v52) = a4[20];
                                            if (BYTE4(v52))
                                            {
                                              BYTE5(v52) = a4[21];
                                              if (BYTE5(v52))
                                              {
                                                BYTE6(v52) = a4[22];
                                                if (BYTE6(v52))
                                                {
                                                  BYTE7(v52) = a4[23];
                                                  if (BYTE7(v52))
                                                  {
                                                    BYTE8(v52) = a4[24];
                                                    if (BYTE8(v52))
                                                    {
                                                      BYTE9(v52) = a4[25];
                                                      if (BYTE9(v52))
                                                      {
                                                        BYTE10(v52) = a4[26];
                                                        if (BYTE10(v52))
                                                        {
                                                          BYTE11(v52) = a4[27];
                                                          if (BYTE11(v52))
                                                          {
                                                            BYTE12(v52) = a4[28];
                                                            if (BYTE12(v52))
                                                            {
                                                              BYTE13(v52) = a4[29];
                                                              if (BYTE13(v52))
                                                              {
                                                                BYTE14(v52) = a4[30];
                                                                if (BYTE14(v52)) {
                                                                  HIBYTE(v52) = 0;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    LOBYTE(v53) = *a5;
    if ((_BYTE)v53)
    {
      BYTE1(v53) = a5[1];
      if (BYTE1(v53))
      {
        BYTE2(v53) = a5[2];
        if (BYTE2(v53))
        {
          BYTE3(v53) = a5[3];
          if (BYTE3(v53))
          {
            BYTE4(v53) = a5[4];
            if (BYTE4(v53))
            {
              BYTE5(v53) = a5[5];
              if (BYTE5(v53))
              {
                BYTE6(v53) = a5[6];
                if (BYTE6(v53))
                {
                  BYTE7(v53) = a5[7];
                  if (BYTE7(v53))
                  {
                    BYTE8(v53) = a5[8];
                    if (BYTE8(v53))
                    {
                      BYTE9(v53) = a5[9];
                      if (BYTE9(v53))
                      {
                        BYTE10(v53) = a5[10];
                        if (BYTE10(v53))
                        {
                          BYTE11(v53) = a5[11];
                          if (BYTE11(v53))
                          {
                            BYTE12(v53) = a5[12];
                            if (BYTE12(v53))
                            {
                              BYTE13(v53) = a5[13];
                              if (BYTE13(v53))
                              {
                                BYTE14(v53) = a5[14];
                                if (BYTE14(v53))
                                {
                                  HIBYTE(v53) = a5[15];
                                  if (HIBYTE(v53))
                                  {
                                    LOBYTE(v54) = a5[16];
                                    if ((_BYTE)v54)
                                    {
                                      BYTE1(v54) = a5[17];
                                      if (BYTE1(v54))
                                      {
                                        BYTE2(v54) = a5[18];
                                        if (BYTE2(v54))
                                        {
                                          BYTE3(v54) = a5[19];
                                          if (BYTE3(v54))
                                          {
                                            BYTE4(v54) = a5[20];
                                            if (BYTE4(v54))
                                            {
                                              BYTE5(v54) = a5[21];
                                              if (BYTE5(v54))
                                              {
                                                BYTE6(v54) = a5[22];
                                                if (BYTE6(v54))
                                                {
                                                  BYTE7(v54) = a5[23];
                                                  if (BYTE7(v54))
                                                  {
                                                    BYTE8(v54) = a5[24];
                                                    if (BYTE8(v54))
                                                    {
                                                      BYTE9(v54) = a5[25];
                                                      if (BYTE9(v54))
                                                      {
                                                        BYTE10(v54) = a5[26];
                                                        if (BYTE10(v54))
                                                        {
                                                          BYTE11(v54) = a5[27];
                                                          if (BYTE11(v54))
                                                          {
                                                            BYTE12(v54) = a5[28];
                                                            if (BYTE12(v54))
                                                            {
                                                              BYTE13(v54) = a5[29];
                                                              if (BYTE13(v54))
                                                              {
                                                                BYTE14(v54) = a5[30];
                                                                if (BYTE14(v54)) {
                                                                  HIBYTE(v54) = 0;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    if (a6)
    {
      uint64_t v31 = 0;
      while (1)
      {
        int v32 = *(unsigned __int8 *)(a6 + v31);
        *((unsigned char *)v55 + v31) = v32;
        if (!v32) {
          break;
        }
        if (++v31 == 127)
        {
          HIBYTE(v56) = 0;
          break;
        }
      }
    }
    if (a7)
    {
      LODWORD(v57) = v57 | 2;
      int v34 = a17;
      int v33 = a18;
      if (!a8) {
        goto LABEL_84;
      }
    }
    else
    {
      int v34 = a17;
      int v33 = a18;
      if (!a8)
      {
LABEL_84:
        if (a9) {
          goto LABEL_85;
        }
        goto LABEL_99;
      }
    }
    LODWORD(v57) = v57 | 4;
    if (a9)
    {
LABEL_85:
      LODWORD(v57) = v57 | 8;
      if (!a10) {
        goto LABEL_86;
      }
      goto LABEL_100;
    }
LABEL_99:
    if (!a10)
    {
LABEL_86:
      if (a11) {
        goto LABEL_87;
      }
      goto LABEL_101;
    }
LABEL_100:
    LODWORD(v57) = v57 | 0x10;
    if (a11)
    {
LABEL_87:
      LODWORD(v57) = v57 | 0x20;
      if (!a12) {
        goto LABEL_88;
      }
      goto LABEL_102;
    }
LABEL_101:
    if (!a12)
    {
LABEL_88:
      if (a13) {
        goto LABEL_89;
      }
      goto LABEL_103;
    }
LABEL_102:
    LODWORD(v57) = v57 | 0x40;
    if (a13)
    {
LABEL_89:
      LODWORD(v57) = v57 | 0x80;
      if (!a14) {
        goto LABEL_90;
      }
      goto LABEL_104;
    }
LABEL_103:
    if (!a14)
    {
LABEL_90:
      if (a15) {
        goto LABEL_91;
      }
      goto LABEL_105;
    }
LABEL_104:
    LODWORD(v57) = v57 | 0x400;
    if (a15)
    {
LABEL_91:
      LODWORD(v57) = v57 | 0x100;
      if (!a16) {
        goto LABEL_92;
      }
      goto LABEL_106;
    }
LABEL_105:
    if (!a16)
    {
LABEL_92:
      if (v34) {
        goto LABEL_93;
      }
      goto LABEL_107;
    }
LABEL_106:
    LODWORD(v57) = v57 | 0x10000;
    if (v34)
    {
LABEL_93:
      LODWORD(v57) = v57 | 0x20000;
      if (!v33) {
        goto LABEL_94;
      }
      goto LABEL_108;
    }
LABEL_107:
    if (!v33)
    {
LABEL_94:
      if (a19) {
        goto LABEL_95;
      }
      goto LABEL_109;
    }
LABEL_108:
    LODWORD(v57) = v57 | 0x200;
    if (a19)
    {
LABEL_95:
      LODWORD(v57) = v57 | 0x800;
      if (!a20) {
        return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
      }
      goto LABEL_110;
    }
LABEL_109:
    if (!a20) {
      return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
    }
LABEL_110:
    if (a21) {
      HIDWORD(v57) = a21;
    }
    return nw_network_agent_ctl_setsockopt_inner(a1, a2, buf, 0xD8u, a20, a21);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
  int v27 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v49 = 0;
  if (__nwlog_fault(v27, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v28 = gLogObj;
      os_log_type_t v29 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
        uint64_t v30 = "%{public}s called with null netagent_uuid";
LABEL_120:
        BOOL v39 = v28;
        os_log_type_t v40 = v29;
LABEL_121:
        _os_log_impl(&dword_1830D4000, v39, v40, v30, buf, 0xCu);
      }
    }
    else if (v49)
    {
      __int16 v35 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v36 = gLogObj;
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v35)
      {
        if (v38)
        {
          *(_DWORD *)int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v35;
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v35);
        goto LABEL_122;
      }
      if (v38)
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
        uint64_t v30 = "%{public}s called with null netagent_uuid, no backtrace";
        BOOL v39 = v36;
        os_log_type_t v40 = v37;
        goto LABEL_121;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v28 = gLogObj;
      os_log_type_t v29 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_network_agent_ctl_setsockopt";
        uint64_t v30 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
        goto LABEL_120;
      }
    }
  }
LABEL_122:
  if (v27) {
    free(v27);
  }
  return 0xFFFFFFFFLL;
}

uint64_t nw_network_agent_ctl_setsockopt_inner(int a1, int a2, const unsigned __int8 *a3, unsigned int a4, const unsigned __int8 *a5, unsigned int a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = a6 + a4;
  if (__CFADD__(a6, a4))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446722;
    int v36 = "nw_network_agent_ctl_setsockopt_inner";
    __int16 v37 = 1024;
    *(_DWORD *)BOOL v38 = a4;
    *(_WORD *)&void v38[4] = 1024;
    *(_DWORD *)&v38[6] = a6;
    int v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v9, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)int buf = 136446722;
          int v36 = "nw_network_agent_ctl_setsockopt_inner";
          __int16 v37 = 1024;
          *(_DWORD *)BOOL v38 = a4;
          *(_WORD *)&void v38[4] = 1024;
          *(_DWORD *)&v38[6] = a6;
          os_log_type_t v12 = "%{public}s Invalid payload values (%u, %u)";
LABEL_35:
          _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0x18u);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = gLogObj;
        os_log_type_t v11 = type;
        BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)int buf = 136446978;
            int v36 = "nw_network_agent_ctl_setsockopt_inner";
            __int16 v37 = 1024;
            *(_DWORD *)BOOL v38 = a4;
            *(_WORD *)&void v38[4] = 1024;
            *(_DWORD *)&v38[6] = a6;
            __int16 v39 = 2082;
            os_log_type_t v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s Invalid payload values (%u, %u), dumping backtrace:%{public}s", buf, 0x22u);
          }
          free(backtrace_string);
          goto LABEL_36;
        }
        if (v20)
        {
          *(_DWORD *)int buf = 136446722;
          int v36 = "nw_network_agent_ctl_setsockopt_inner";
          __int16 v37 = 1024;
          *(_DWORD *)BOOL v38 = a4;
          *(_WORD *)&void v38[4] = 1024;
          *(_DWORD *)&v38[6] = a6;
          os_log_type_t v12 = "%{public}s Invalid payload values (%u, %u), no backtrace";
          goto LABEL_35;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v10 = gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)int buf = 136446722;
          int v36 = "nw_network_agent_ctl_setsockopt_inner";
          __int16 v37 = 1024;
          *(_DWORD *)BOOL v38 = a4;
          *(_WORD *)&void v38[4] = 1024;
          *(_DWORD *)&v38[6] = a6;
          os_log_type_t v12 = "%{public}s Invalid payload values (%u, %u), backtrace limit exceeded";
          goto LABEL_35;
        }
      }
    }
LABEL_36:
    if (v9) {
      free(v9);
    }
    return 0xFFFFFFFFLL;
  }
  if (!(a6 + a4))
  {
    int v18 = 0;
    goto LABEL_21;
  }
  int v17 = (char *)malloc_type_malloc(a6 + a4, 0xF2B69DE5uLL);
  int v18 = v17;
  if (v17)
  {
    if (a3) {
      goto LABEL_10;
    }
    goto LABEL_12;
  }
  uint64_t v31 = __nwlog_obj();
  os_log_type_enabled(v31, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446466;
  int v36 = "strict_malloc";
  __int16 v37 = 2048;
  *(void *)BOOL v38 = v8;
  int v32 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v32);
  if (!result)
  {
    free(v32);
    int v17 = 0;
    if (a3)
    {
LABEL_10:
      int v17 = v18;
      if (a4)
      {
        memcpy(v18, a3, a4);
        int v17 = &v18[a4];
      }
    }
LABEL_12:
    if (a5 && a6) {
      memcpy(v17, a5, a6);
    }
LABEL_21:
    uint64_t v21 = setsockopt(a1, 2, a2, v18, v8);
    if ((v21 & 0x80000000) == 0)
    {
LABEL_22:
      if (v18) {
        free(v18);
      }
      return v21;
    }
    int v22 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v23 = gLogObj;
    if (v22 == 2)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446722;
        int v36 = "nw_network_agent_ctl_setsockopt_inner";
        __int16 v37 = 1024;
        *(_DWORD *)BOOL v38 = a2;
        *(_WORD *)&void v38[4] = 1024;
        *(_DWORD *)&v38[6] = 2;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s setsockopt for message type %u failed %{darwin.errno}d", buf, 0x18u);
      }
      goto LABEL_22;
    }
    *(_DWORD *)int buf = 136446722;
    int v36 = "nw_network_agent_ctl_setsockopt_inner";
    __int16 v37 = 1024;
    *(_DWORD *)BOOL v38 = a2;
    *(_WORD *)&void v38[4] = 1024;
    *(_DWORD *)&v38[6] = v22;
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v24, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = gLogObj;
        os_log_type_t v26 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446722;
        int v36 = "nw_network_agent_ctl_setsockopt_inner";
        __int16 v37 = 1024;
        *(_DWORD *)BOOL v38 = a2;
        *(_WORD *)&void v38[4] = 1024;
        *(_DWORD *)&v38[6] = v22;
        int v27 = "%{public}s setsockopt for message type %u failed %{darwin.errno}d";
        goto LABEL_49;
      }
      if (!v33)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (!os_log_type_enabled(v25, type)) {
          goto LABEL_50;
        }
        *(_DWORD *)int buf = 136446722;
        int v36 = "nw_network_agent_ctl_setsockopt_inner";
        __int16 v37 = 1024;
        *(_DWORD *)BOOL v38 = a2;
        *(_WORD *)&void v38[4] = 1024;
        *(_DWORD *)&v38[6] = v22;
        int v27 = "%{public}s setsockopt for message type %u failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_49;
      }
      os_log_type_t v29 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v25 = gLogObj;
      os_log_type_t v26 = type;
      BOOL v30 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v29)
      {
        if (v30)
        {
          *(_DWORD *)int buf = 136446978;
          int v36 = "nw_network_agent_ctl_setsockopt_inner";
          __int16 v37 = 1024;
          *(_DWORD *)BOOL v38 = a2;
          *(_WORD *)&void v38[4] = 1024;
          *(_DWORD *)&v38[6] = v22;
          __int16 v39 = 2082;
          os_log_type_t v40 = v29;
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s setsockopt for message type %u failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v29);
        goto LABEL_50;
      }
      if (v30)
      {
        *(_DWORD *)int buf = 136446722;
        int v36 = "nw_network_agent_ctl_setsockopt_inner";
        __int16 v37 = 1024;
        *(_DWORD *)BOOL v38 = a2;
        *(_WORD *)&void v38[4] = 1024;
        *(_DWORD *)&v38[6] = v22;
        int v27 = "%{public}s setsockopt for message type %u failed %{darwin.errno}d, no backtrace";
LABEL_49:
        _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0x18u);
      }
    }
LABEL_50:
    if (v24) {
      free(v24);
    }
    goto LABEL_22;
  }
  __break(1u);
  return result;
}

uint64_t nw_network_agent_ctl_simple_setsockopt(int a1, int a2, const unsigned __int8 *a3, unsigned int a4)
{
  return nw_network_agent_ctl_setsockopt_inner(a1, a2, a3, a4, 0, 0);
}

uint64_t nw_network_agent_ctl_send_assign_message(int a1, unsigned __int8 *a2, unsigned int a3)
{
  return nw_network_agent_ctl_setsockopt_inner(a1, 11, a2, a3, 0, 0);
}

uint64_t nw_network_agent_ctl_send_assign_group_message(int a1, unsigned __int8 *a2, unsigned int a3)
{
  return nw_network_agent_ctl_setsockopt_inner(a1, 20, a2, a3, 0, 0);
}

uint64_t nw_network_agent_open_control_socket()
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  int v48 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  memset(v43, 0, sizeof(v43));
  memset(v36, 0, sizeof(v36));
  if (getuid())
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    v0 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446210;
      BOOL v38 = "nw_network_agent_open_control_socket";
      _os_log_impl(&dword_1830D4000, v0, OS_LOG_TYPE_DEFAULT, "%{public}s Requesting netagent socket from helper", buf, 0xCu);
    }
    kernel_socket_uint64_t internal = networkd_privileged_get_kernel_socket_internal(0xCuLL);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
    {
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEFAULT, "%{public}s Received netagent socket %d from helper", buf, 0x12u);
    }
    return kernel_socket_internal;
  }
  uint64_t v3 = socket(32, 2, 2);
  if ((v3 & 0x80000000) != 0)
  {
    int v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = v9;
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v10, &type, &v34)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = v9;
      int v13 = "%{public}s cannot create netagent kernel control socket %{darwin.errno}d";
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = gLogObj;
      os_log_type_t v12 = type;
      BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)int buf = 136446722;
          BOOL v38 = "nw_network_agent_open_control_socket";
          __int16 v39 = 1024;
          int v40 = v9;
          __int16 v41 = 2082;
          v42[0] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s cannot create netagent kernel control socket %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_54;
      }
      if (!v18)
      {
LABEL_54:
        if (v10) {
          free(v10);
        }
        return 0xFFFFFFFFLL;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = v9;
      int v13 = "%{public}s cannot create netagent kernel control socket %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v11 = gLogObj;
      os_log_type_t v12 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_54;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = v9;
      int v13 = "%{public}s cannot create netagent kernel control socket %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0x12u);
    goto LABEL_54;
  }
  kernel_socket_uint64_t internal = v3;
  LODWORD(v43[0]) = 0;
  *((void *)&v43[1] + 1) = 0;
  int v48 = 0;
  long long v46 = 0u;
  long long v47 = 0u;
  long long v45 = 0u;
  long long v44 = 0u;
  strcpy((char *)v43 + 4, "com.apple.net.netagent");
  if (ioctl(v3, 0xC0644E03uLL, v43))
  {
    int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446722;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = kernel_socket_internal;
    __int16 v41 = 1024;
    LODWORD(v42[0]) = v4;
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v5, &type, &v34)) {
      goto LABEL_65;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v4;
      uint64_t v8 = "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d";
      goto LABEL_64;
    }
    if (!v34)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v4;
      uint64_t v8 = "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_64;
    }
    uint64_t v15 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = gLogObj;
    os_log_type_t v7 = type;
    BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (!v15)
    {
      if (!v16) {
        goto LABEL_65;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v4;
      uint64_t v8 = "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d, no backtrace";
      goto LABEL_64;
    }
    if (v16)
    {
      *(_DWORD *)int buf = 136446978;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v4;
      WORD2(v42[0]) = 2082;
      *(void *)((char *)v42 + 6) = v15;
      _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s ioctl CTLIOCGINFO failed on netagent kernel control socket %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
    }
    free(v15);
    goto LABEL_65;
  }
  *(_DWORD *)&v36[0].sa_len = 139296;
  *(_DWORD *)&v36[0].sa_data[2] = v43[0];
  memset(&v36[0].sa_data[6], 0, 24);
  if (connect(kernel_socket_internal, v36, 0x20u))
  {
    int v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446722;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = kernel_socket_internal;
    __int16 v41 = 1024;
    LODWORD(v42[0]) = v14;
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v5, &type, &v34)) {
      goto LABEL_65;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v14;
      uint64_t v8 = "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d";
      goto LABEL_64;
    }
    if (!v34)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)int buf = 136446722;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v14;
      uint64_t v8 = "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_64;
    }
    os_log_type_t v26 = (char *)__nw_create_backtrace_string();
    uint64_t v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v27 = os_log_type_enabled(v6, type);
    if (v26)
    {
      if (v27)
      {
        *(_DWORD *)int buf = 136446978;
        BOOL v38 = "nw_network_agent_open_control_socket";
        __int16 v39 = 1024;
        int v40 = kernel_socket_internal;
        __int16 v41 = 1024;
        LODWORD(v42[0]) = v14;
        WORD2(v42[0]) = 2082;
        *(void *)((char *)v42 + 6) = v26;
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
      }
      free(v26);
      if (!v5) {
        goto LABEL_67;
      }
      goto LABEL_66;
    }
    if (v27)
    {
      *(_DWORD *)int buf = 136446722;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = kernel_socket_internal;
      __int16 v41 = 1024;
      LODWORD(v42[0]) = v14;
      uint64_t v8 = "%{public}s connect failed on netagent kernel control socket %d %{darwin.errno}d, no backtrace";
LABEL_64:
      _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x18u);
    }
LABEL_65:
    if (!v5)
    {
LABEL_67:
      close(kernel_socket_internal);
      return 0xFFFFFFFFLL;
    }
LABEL_66:
    free(v5);
    goto LABEL_67;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v19 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = kernel_socket_internal;
    _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully connected netagent socket %d", buf, 0x12u);
  }
  int v20 = fcntl(kernel_socket_internal, 3, 0);
  if ((v20 & 0x80000000) == 0)
  {
    if ((fcntl(kernel_socket_internal, 4, v20 | 4u) & 0x80000000) == 0) {
      return kernel_socket_internal;
    }
    int v21 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    __nwlog_obj();
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = v21;
    int v22 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v22, &type, &v34)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = v21;
      uint64_t v25 = "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d";
    }
    else if (v34)
    {
      int v32 = (char *)__nw_create_backtrace_string();
      int v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v33 = os_log_type_enabled(v23, type);
      if (v32)
      {
        if (v33)
        {
          *(_DWORD *)int buf = 136446722;
          BOOL v38 = "nw_network_agent_open_control_socket";
          __int16 v39 = 1024;
          int v40 = v21;
          __int16 v41 = 2082;
          v42[0] = v32;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v32);
LABEL_90:
        if (!v22) {
          return kernel_socket_internal;
        }
LABEL_91:
        free(v22);
        return kernel_socket_internal;
      }
      if (!v33) {
        goto LABEL_90;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = v21;
      uint64_t v25 = "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d, no backtrace";
    }
    else
    {
      int v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)int buf = 136446466;
      BOOL v38 = "nw_network_agent_open_control_socket";
      __int16 v39 = 1024;
      int v40 = v21;
      uint64_t v25 = "%{public}s fcntl(F_SETFL) failed on the network agent control socket %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_89:
    _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0x12u);
    goto LABEL_90;
  }
  int v28 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  __nwlog_obj();
  *(_DWORD *)int buf = 136446466;
  BOOL v38 = "nw_network_agent_open_control_socket";
  __int16 v39 = 1024;
  int v40 = v28;
  int v22 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (!__nwlog_fault(v22, &type, &v34)) {
    goto LABEL_90;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v23 = __nwlog_obj();
    os_log_type_t v24 = type;
    if (!os_log_type_enabled(v23, type)) {
      goto LABEL_90;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = v28;
    uint64_t v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d";
    goto LABEL_89;
  }
  if (!v34)
  {
    int v23 = __nwlog_obj();
    os_log_type_t v24 = type;
    if (!os_log_type_enabled(v23, type)) {
      goto LABEL_90;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = v28;
    uint64_t v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, backtrace limit exceeded";
    goto LABEL_89;
  }
  BOOL v30 = (char *)__nw_create_backtrace_string();
  int v23 = __nwlog_obj();
  os_log_type_t v24 = type;
  BOOL v31 = os_log_type_enabled(v23, type);
  if (!v30)
  {
    if (!v31) {
      goto LABEL_90;
    }
    *(_DWORD *)int buf = 136446466;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = v28;
    uint64_t v25 = "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, no backtrace";
    goto LABEL_89;
  }
  if (v31)
  {
    *(_DWORD *)int buf = 136446722;
    BOOL v38 = "nw_network_agent_open_control_socket";
    __int16 v39 = 1024;
    int v40 = v28;
    __int16 v41 = 2082;
    v42[0] = v30;
    _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s fcntl(F_GETFL) failed on the network agent control socket %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
  }
  free(v30);
  if (v22) {
    goto LABEL_91;
  }
  return kernel_socket_internal;
}

uint64_t nw_network_agent_add_to_interface(uint64_t a1, unsigned __int8 *uu)
{
  uint64_t v46 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    __int16 v39 = "nw_network_agent_add_to_interface_internal";
    int v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v4, type, &v37)) {
      goto LABEL_41;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled(v5, type[0])) {
        goto LABEL_41;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_network_agent_add_to_interface_internal";
      os_log_type_t v7 = "%{public}s called with null if_name";
      goto LABEL_39;
    }
    if (v37 == OS_LOG_TYPE_DEFAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled(v5, type[0])) {
        goto LABEL_41;
      }
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_network_agent_add_to_interface_internal";
      os_log_type_t v7 = "%{public}s called with null if_name, backtrace limit exceeded";
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v5 = __nwlog_obj();
    os_log_type_t v6 = type[0];
    BOOL v35 = os_log_type_enabled(v5, type[0]);
    if (backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 2082;
        *(void *)__int16 v41 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null if_name, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_41;
    }
    if (v35)
    {
      *(_DWORD *)int buf = 136446210;
      __int16 v39 = "nw_network_agent_add_to_interface_internal";
      os_log_type_t v7 = "%{public}s called with null if_name, no backtrace";
      goto LABEL_39;
    }
    goto LABEL_41;
  }
  if (uuid_is_null(uu))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    __int16 v39 = "nw_network_agent_add_to_interface_internal";
    int v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v4, type, &v37))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v39 = "nw_network_agent_add_to_interface_internal";
          os_log_type_t v7 = "%{public}s called with null netagent_uuid";
LABEL_39:
          BOOL v18 = v5;
          os_log_type_t v19 = v6;
LABEL_40:
          _os_log_impl(&dword_1830D4000, v18, v19, v7, buf, 0xCu);
        }
      }
      else if (v37)
      {
        os_log_type_t v11 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v12 = gLogObj;
        os_log_type_t v13 = type[0];
        BOOL v14 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v11)
        {
          if (v14)
          {
            *(_DWORD *)int buf = 136446466;
            __int16 v39 = "nw_network_agent_add_to_interface_internal";
            __int16 v40 = 2082;
            *(void *)__int16 v41 = v11;
            _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v11);
          goto LABEL_41;
        }
        if (v14)
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v39 = "nw_network_agent_add_to_interface_internal";
          os_log_type_t v7 = "%{public}s called with null netagent_uuid, no backtrace";
          BOOL v18 = v12;
          os_log_type_t v19 = v13;
          goto LABEL_40;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          __int16 v39 = "nw_network_agent_add_to_interface_internal";
          os_log_type_t v7 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
          goto LABEL_39;
        }
      }
    }
LABEL_41:
    if (v4) {
      free(v4);
    }
    return 22;
  }
  if (getuid())
  {
    BOOL v8 = networkd_privileged_set_agent_on_interface_internal((const char *)a1, uu, 0, 0);
    uint64_t v9 = 0;
    if (!v8)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446722;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 2082;
        *(void *)__int16 v41 = a1;
        *(_WORD *)&v41[8] = 2082;
        *(void *)&v41[10] = "";
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s networkd_privileged_set_agent_on_interface_internal(%{public}s add%{public}s) failed", buf, 0x20u);
      }
      return 0xFFFFFFFFLL;
    }
    return v9;
  }
  int v15 = socket(2, 2, 0);
  if ((v15 & 0x80000000) == 0)
  {
    int v16 = v15;
    memset(&type[1], 0, 15);
    type[0] = *(os_log_type_t *)a1;
    if (type[0])
    {
      type[1] = *(os_log_type_t *)(a1 + 1);
      if (type[1])
      {
        type[2] = *(os_log_type_t *)(a1 + 2);
        if (type[2])
        {
          type[3] = *(os_log_type_t *)(a1 + 3);
          if (type[3])
          {
            os_log_type_t type[4] = *(os_log_type_t *)(a1 + 4);
            if (type[4])
            {
              type[5] = *(os_log_type_t *)(a1 + 5);
              if (type[5])
              {
                type[6] = *(os_log_type_t *)(a1 + 6);
                if (type[6])
                {
                  type[7] = *(os_log_type_t *)(a1 + 7);
                  if (type[7])
                  {
                    os_log_type_t type[8] = *(os_log_type_t *)(a1 + 8);
                    if (type[8])
                    {
                      type[9] = *(os_log_type_t *)(a1 + 9);
                      if (type[9])
                      {
                        type[10] = *(os_log_type_t *)(a1 + 10);
                        if (type[10])
                        {
                          type[11] = *(os_log_type_t *)(a1 + 11);
                          if (type[11])
                          {
                            type[12] = *(os_log_type_t *)(a1 + 12);
                            if (type[12])
                            {
                              type[13] = *(os_log_type_t *)(a1 + 13);
                              if (type[13]) {
                                type[14] = *(os_log_type_t *)(a1 + 14);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    long long v45 = *(_OWORD *)uu;
    if (!ioctl(v15, 0xC02069A5uLL, type))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v25 = gLogObj;
      uint64_t v9 = 0;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 2082;
        *(void *)__int16 v41 = a1;
        _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_DEFAULT, "%{public}s Successfully added agent to \"%{public}s\"", buf, 0x16u);
        uint64_t v9 = 0;
      }
      goto LABEL_81;
    }
    uint64_t v9 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v17 = gLogObj;
    if (v9 == 6)
    {
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446978;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 1024;
        *(_DWORD *)__int16 v41 = v16;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = a1;
        *(_WORD *)&v41[14] = 1024;
        *(_DWORD *)&v41[16] = 6;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d", buf, 0x22u);
      }
LABEL_81:
      close(v16);
      return v9;
    }
    *(_DWORD *)int buf = 136446978;
    __int16 v39 = "nw_network_agent_add_to_interface_internal";
    __int16 v40 = 1024;
    *(_DWORD *)__int16 v41 = v16;
    *(_WORD *)&v41[4] = 2082;
    *(void *)&v41[6] = a1;
    *(_WORD *)&v41[14] = 1024;
    *(_DWORD *)&v41[16] = v9;
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v26, &v37, &v36))
    {
      if (v37 == OS_LOG_TYPE_FAULT)
      {
        BOOL v27 = __nwlog_obj();
        os_log_type_t v28 = v37;
        if (!os_log_type_enabled(v27, v37)) {
          goto LABEL_79;
        }
        *(_DWORD *)int buf = 136446978;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 1024;
        *(_DWORD *)__int16 v41 = v16;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = a1;
        *(_WORD *)&v41[14] = 1024;
        *(_DWORD *)&v41[16] = v9;
        os_log_type_t v29 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d";
        goto LABEL_78;
      }
      if (!v36)
      {
        BOOL v27 = __nwlog_obj();
        os_log_type_t v28 = v37;
        if (!os_log_type_enabled(v27, v37)) {
          goto LABEL_79;
        }
        *(_DWORD *)int buf = 136446978;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 1024;
        *(_DWORD *)__int16 v41 = v16;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = a1;
        *(_WORD *)&v41[14] = 1024;
        *(_DWORD *)&v41[16] = v9;
        os_log_type_t v29 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_78;
      }
      int v32 = (char *)__nw_create_backtrace_string();
      BOOL v27 = __nwlog_obj();
      os_log_type_t v28 = v37;
      BOOL v33 = os_log_type_enabled(v27, v37);
      if (v32)
      {
        if (v33)
        {
          *(_DWORD *)int buf = 136447234;
          __int16 v39 = "nw_network_agent_add_to_interface_internal";
          __int16 v40 = 1024;
          *(_DWORD *)__int16 v41 = v16;
          *(_WORD *)&v41[4] = 2082;
          *(void *)&v41[6] = a1;
          *(_WORD *)&v41[14] = 1024;
          *(_DWORD *)&v41[16] = v9;
          __int16 v42 = 2082;
          os_log_type_t v43 = v32;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }
        free(v32);
        goto LABEL_79;
      }
      if (v33)
      {
        *(_DWORD *)int buf = 136446978;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 1024;
        *(_DWORD *)__int16 v41 = v16;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = a1;
        *(_WORD *)&v41[14] = 1024;
        *(_DWORD *)&v41[16] = v9;
        os_log_type_t v29 = "%{public}s ioctl(%d, SIOCAIFAGENTID) if_name=\"%{public}s\" failed %{darwin.errno}d, no backtrace";
LABEL_78:
        _os_log_impl(&dword_1830D4000, v27, v28, v29, buf, 0x22u);
      }
    }
LABEL_79:
    if (v26) {
      free(v26);
    }
    goto LABEL_81;
  }
  uint64_t v9 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446466;
  __int16 v39 = "nw_network_agent_add_to_interface_internal";
  __int16 v40 = 1024;
  *(_DWORD *)__int16 v41 = v9;
  int v21 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v37 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v21, type, &v37))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v22 = gLogObj;
      os_log_type_t v23 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446466;
      __int16 v39 = "nw_network_agent_add_to_interface_internal";
      __int16 v40 = 1024;
      *(_DWORD *)__int16 v41 = v9;
      os_log_type_t v24 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
      goto LABEL_71;
    }
    if (v37 == OS_LOG_TYPE_DEFAULT)
    {
      int v22 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (!os_log_type_enabled(v22, type[0])) {
        goto LABEL_72;
      }
      *(_DWORD *)int buf = 136446466;
      __int16 v39 = "nw_network_agent_add_to_interface_internal";
      __int16 v40 = 1024;
      *(_DWORD *)__int16 v41 = v9;
      os_log_type_t v24 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_71;
    }
    BOOL v30 = (char *)__nw_create_backtrace_string();
    int v22 = __nwlog_obj();
    os_log_type_t v23 = type[0];
    BOOL v31 = os_log_type_enabled(v22, type[0]);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)int buf = 136446722;
        __int16 v39 = "nw_network_agent_add_to_interface_internal";
        __int16 v40 = 1024;
        *(_DWORD *)__int16 v41 = v9;
        *(_WORD *)&v41[4] = 2082;
        *(void *)&v41[6] = v30;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v30);
      goto LABEL_72;
    }
    if (v31)
    {
      *(_DWORD *)int buf = 136446466;
      __int16 v39 = "nw_network_agent_add_to_interface_internal";
      __int16 v40 = 1024;
      *(_DWORD *)__int16 v41 = v9;
      os_log_type_t v24 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
LABEL_71:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0x12u);
    }
  }
LABEL_72:
  if (v21) {
    free(v21);
  }
  return v9;
}

uint64_t nw_network_agent_remove_from_interface(uint64_t a1, unsigned __int8 *uu)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v43 = "nw_network_agent_remove_from_interface";
    int v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v41 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v4, type, &v41)) {
      goto LABEL_42;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled(v5, type[0])) {
        goto LABEL_42;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v43 = "nw_network_agent_remove_from_interface";
      os_log_type_t v7 = "%{public}s called with null if_name";
      goto LABEL_40;
    }
    if (v41 == OS_LOG_TYPE_DEFAULT)
    {
      int v5 = __nwlog_obj();
      os_log_type_t v6 = type[0];
      if (!os_log_type_enabled(v5, type[0])) {
        goto LABEL_42;
      }
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v43 = "nw_network_agent_remove_from_interface";
      os_log_type_t v7 = "%{public}s called with null if_name, backtrace limit exceeded";
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v5 = __nwlog_obj();
    os_log_type_t v6 = type[0];
    BOOL v39 = os_log_type_enabled(v5, type[0]);
    if (backtrace_string)
    {
      if (v39)
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 2082;
        *(void *)long long v45 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null if_name, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_42;
    }
    if (v39)
    {
      *(_DWORD *)int buf = 136446210;
      os_log_type_t v43 = "nw_network_agent_remove_from_interface";
      os_log_type_t v7 = "%{public}s called with null if_name, no backtrace";
      goto LABEL_40;
    }
    goto LABEL_42;
  }
  if (uuid_is_null(uu))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446210;
    os_log_type_t v43 = "nw_network_agent_remove_from_interface";
    int v4 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v41 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v4, type, &v41))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v43 = "nw_network_agent_remove_from_interface";
          os_log_type_t v7 = "%{public}s called with null netagent_uuid";
LABEL_40:
          int v22 = v5;
          os_log_type_t v23 = v6;
LABEL_41:
          _os_log_impl(&dword_1830D4000, v22, v23, v7, buf, 0xCu);
        }
      }
      else if (v41)
      {
        uint64_t v10 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v11 = gLogObj;
        os_log_type_t v12 = type[0];
        BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v10)
        {
          if (v13)
          {
            *(_DWORD *)int buf = 136446466;
            os_log_type_t v43 = "nw_network_agent_remove_from_interface";
            __int16 v44 = 2082;
            *(void *)long long v45 = v10;
            _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null netagent_uuid, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v10);
          goto LABEL_42;
        }
        if (v13)
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v43 = "nw_network_agent_remove_from_interface";
          os_log_type_t v7 = "%{public}s called with null netagent_uuid, no backtrace";
          int v22 = v11;
          os_log_type_t v23 = v12;
          goto LABEL_41;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v5 = gLogObj;
        os_log_type_t v6 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)int buf = 136446210;
          os_log_type_t v43 = "nw_network_agent_remove_from_interface";
          os_log_type_t v7 = "%{public}s called with null netagent_uuid, backtrace limit exceeded";
          goto LABEL_40;
        }
      }
    }
LABEL_42:
    if (v4) {
      free(v4);
    }
    return 22;
  }
  if (getuid())
  {
    uint64_t v8 = 0;
    if (!networkd_privileged_set_agent_on_interface_internal((const char *)a1, uu, 1, 0))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 2082;
        *(void *)long long v45 = a1;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s networkd_privileged_set_agent_on_interface(%{public}s, remove) failed", buf, 0x16u);
      }
      return 0xFFFFFFFFLL;
    }
    return v8;
  }
  int v14 = socket(2, 2, 0);
  if ((v14 & 0x80000000) == 0)
  {
    int v15 = v14;
    memset(&type[1], 0, 15);
    type[0] = *(os_log_type_t *)a1;
    if (type[0])
    {
      type[1] = *(os_log_type_t *)(a1 + 1);
      if (type[1])
      {
        type[2] = *(os_log_type_t *)(a1 + 2);
        if (type[2])
        {
          type[3] = *(os_log_type_t *)(a1 + 3);
          if (type[3])
          {
            os_log_type_t type[4] = *(os_log_type_t *)(a1 + 4);
            if (type[4])
            {
              type[5] = *(os_log_type_t *)(a1 + 5);
              if (type[5])
              {
                type[6] = *(os_log_type_t *)(a1 + 6);
                if (type[6])
                {
                  type[7] = *(os_log_type_t *)(a1 + 7);
                  if (type[7])
                  {
                    os_log_type_t type[8] = *(os_log_type_t *)(a1 + 8);
                    if (type[8])
                    {
                      type[9] = *(os_log_type_t *)(a1 + 9);
                      if (type[9])
                      {
                        type[10] = *(os_log_type_t *)(a1 + 10);
                        if (type[10])
                        {
                          type[11] = *(os_log_type_t *)(a1 + 11);
                          if (type[11])
                          {
                            type[12] = *(os_log_type_t *)(a1 + 12);
                            if (type[12])
                            {
                              type[13] = *(os_log_type_t *)(a1 + 13);
                              if (type[13]) {
                                type[14] = *(os_log_type_t *)(a1 + 14);
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    long long v51 = *(_OWORD *)uu;
    if (!ioctl(v14, 0xC02069A6uLL, type))
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v29 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)int buf = 136446466;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 2082;
        *(void *)long long v45 = a1;
        BOOL v18 = "%{public}s Successfully removed agent from \"%{public}s\"";
        os_log_type_t v19 = v29;
        os_log_type_t v20 = OS_LOG_TYPE_DEFAULT;
        uint32_t v21 = 22;
        goto LABEL_54;
      }
LABEL_83:
      close(v15);
      return 0;
    }
    int v16 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (v16 == 6 || v16 == 102)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 1024;
        *(_DWORD *)long long v45 = v15;
        *(_WORD *)&v45[4] = 2082;
        *(void *)&v45[6] = a1;
        __int16 v46 = 1024;
        int v47 = v16;
        BOOL v18 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d";
        os_log_type_t v19 = v17;
        os_log_type_t v20 = OS_LOG_TYPE_ERROR;
        uint32_t v21 = 34;
LABEL_54:
        _os_log_impl(&dword_1830D4000, v19, v20, v18, buf, v21);
        goto LABEL_83;
      }
      goto LABEL_83;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446978;
    os_log_type_t v43 = "nw_network_agent_remove_from_interface";
    __int16 v44 = 1024;
    *(_DWORD *)long long v45 = v15;
    *(_WORD *)&v45[4] = 2082;
    *(void *)&v45[6] = a1;
    __int16 v46 = 1024;
    int v47 = v16;
    int v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v41 = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (__nwlog_fault(v32, &v41, &v40))
    {
      if (v41 == OS_LOG_TYPE_FAULT)
      {
        BOOL v33 = __nwlog_obj();
        os_log_type_t v34 = v41;
        if (!os_log_type_enabled(v33, v41)) {
          goto LABEL_81;
        }
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 1024;
        *(_DWORD *)long long v45 = v15;
        *(_WORD *)&v45[4] = 2082;
        *(void *)&v45[6] = a1;
        __int16 v46 = 1024;
        int v47 = v16;
        BOOL v35 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d";
        goto LABEL_80;
      }
      if (!v40)
      {
        BOOL v33 = __nwlog_obj();
        os_log_type_t v34 = v41;
        if (!os_log_type_enabled(v33, v41)) {
          goto LABEL_81;
        }
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 1024;
        *(_DWORD *)long long v45 = v15;
        *(_WORD *)&v45[4] = 2082;
        *(void *)&v45[6] = a1;
        __int16 v46 = 1024;
        int v47 = v16;
        BOOL v35 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_80;
      }
      char v36 = (char *)__nw_create_backtrace_string();
      BOOL v33 = __nwlog_obj();
      os_log_type_t v34 = v41;
      BOOL v37 = os_log_type_enabled(v33, v41);
      if (v36)
      {
        if (v37)
        {
          *(_DWORD *)int buf = 136447234;
          os_log_type_t v43 = "nw_network_agent_remove_from_interface";
          __int16 v44 = 1024;
          *(_DWORD *)long long v45 = v15;
          *(_WORD *)&v45[4] = 2082;
          *(void *)&v45[6] = a1;
          __int16 v46 = 1024;
          int v47 = v16;
          __int16 v48 = 2082;
          uint64_t v49 = v36;
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }
        free(v36);
        goto LABEL_81;
      }
      if (v37)
      {
        *(_DWORD *)int buf = 136446978;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 1024;
        *(_DWORD *)long long v45 = v15;
        *(_WORD *)&v45[4] = 2082;
        *(void *)&v45[6] = a1;
        __int16 v46 = 1024;
        int v47 = v16;
        BOOL v35 = "%{public}s ioctl(%d, SIOCDIFAGENTID, %{public}s) failed %{darwin.errno}d, no backtrace";
LABEL_80:
        _os_log_impl(&dword_1830D4000, v33, v34, v35, buf, 0x22u);
      }
    }
LABEL_81:
    if (v32) {
      free(v32);
    }
    goto LABEL_83;
  }
  uint64_t v8 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446466;
  os_log_type_t v43 = "nw_network_agent_remove_from_interface";
  __int16 v44 = 1024;
  *(_DWORD *)long long v45 = v8;
  uint64_t v25 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v41 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v25, type, &v41))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v26 = gLogObj;
      os_log_type_t v27 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_74;
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v43 = "nw_network_agent_remove_from_interface";
      __int16 v44 = 1024;
      *(_DWORD *)long long v45 = v8;
      os_log_type_t v28 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
      goto LABEL_73;
    }
    if (v41 == OS_LOG_TYPE_DEFAULT)
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type[0];
      if (!os_log_type_enabled(v26, type[0])) {
        goto LABEL_74;
      }
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v43 = "nw_network_agent_remove_from_interface";
      __int16 v44 = 1024;
      *(_DWORD *)long long v45 = v8;
      os_log_type_t v28 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_73;
    }
    BOOL v30 = (char *)__nw_create_backtrace_string();
    os_log_type_t v26 = __nwlog_obj();
    os_log_type_t v27 = type[0];
    BOOL v31 = os_log_type_enabled(v26, type[0]);
    if (v30)
    {
      if (v31)
      {
        *(_DWORD *)int buf = 136446722;
        os_log_type_t v43 = "nw_network_agent_remove_from_interface";
        __int16 v44 = 1024;
        *(_DWORD *)long long v45 = v8;
        *(_WORD *)&v45[4] = 2082;
        *(void *)&v45[6] = v30;
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v30);
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)int buf = 136446466;
      os_log_type_t v43 = "nw_network_agent_remove_from_interface";
      __int16 v44 = 1024;
      *(_DWORD *)long long v45 = v8;
      os_log_type_t v28 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
LABEL_73:
      _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0x12u);
    }
  }
LABEL_74:
  if (v25) {
    free(v25);
  }
  return v8;
}

unsigned int *nw_network_agent_get_agent_from_dictionary(unsigned int *result)
{
  size_t length = 0;
  if (result)
  {
    data = (unsigned int *)xpc_dictionary_get_data(result, "data", &length);
    uint64_t result = 0;
    if (data)
    {
      if (length >= 0xD8)
      {
        if (length == data[53] + 216) {
          return data;
        }
        else {
          return 0;
        }
      }
    }
  }
  return result;
}

unsigned int *nw_network_agent_truncate_agent_data_in_dictionary(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  size_t v16 = 0;
  data = (unsigned int *)xpc_dictionary_get_data(a1, "data", &v16);
  if (data && v16 >= 0xD8 && v16 == data[53] + 216)
  {
    long long v3 = *((_OWORD *)data + 1);
    bytes[0] = *(_OWORD *)data;
    bytes[1] = v3;
    long long v4 = *((_OWORD *)data + 2);
    long long v5 = *((_OWORD *)data + 3);
    long long v6 = *((_OWORD *)data + 5);
    bytes[4] = *((_OWORD *)data + 4);
    bytes[5] = v6;
    bytes[2] = v4;
    bytes[3] = v5;
    long long v7 = *((_OWORD *)data + 6);
    long long v8 = *((_OWORD *)data + 7);
    long long v9 = *((_OWORD *)data + 9);
    bytes[8] = *((_OWORD *)data + 8);
    bytes[9] = v9;
    bytes[6] = v7;
    bytes[7] = v8;
    long long v10 = *((_OWORD *)data + 10);
    long long v11 = *((_OWORD *)data + 12);
    unsigned int v12 = data[52];
    bytes[11] = *((_OWORD *)data + 11);
    bytes[12] = v11;
    bytes[10] = v10;
    unsigned int v19 = v12;
    int v20 = 0;
    xpc_dictionary_set_data(a1, "data", bytes, 0xD8uLL);
    size_t length = 0;
    BOOL v13 = (unsigned int *)xpc_dictionary_get_data(a1, "data", &length);
    uint64_t result = 0;
    if (!v13) {
      return result;
    }
    size_t v15 = length;
    if (length < 0xD8) {
      return result;
    }
LABEL_9:
    if (v15 == v13[53] + 216) {
      return v13;
    }
    else {
      return 0;
    }
  }
  *(void *)&bytes[0] = 0;
  BOOL v13 = (unsigned int *)xpc_dictionary_get_data(a1, "data", (size_t *)bytes);
  uint64_t result = 0;
  if (v13)
  {
    size_t v15 = *(void *)&bytes[0];
    if (*(void *)&bytes[0] >= 0xD8uLL) {
      goto LABEL_9;
    }
  }
  return result;
}

BOOL nw_network_agent_copy_dictionary_for_uuid(const unsigned __int8 *a1)
{
  uint64_t v57 = *MEMORY[0x1E4F143B8];
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = 0u;
  long long v40 = 0u;
  if (!a1 || uuid_is_null(a1)) {
    return 0;
  }
  int v2 = socket(2, 2, 0);
  if (v2 < 0)
  {
    int v6 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int buf = 136446466;
    long long v54 = "nw_network_agent_copy_struct";
    __int16 v55 = 1024;
    *(_DWORD *)long long v56 = v6;
    long long v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v7, &type, &v37)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_33;
      }
      int buf = 136446466;
      long long v54 = "nw_network_agent_copy_struct";
      __int16 v55 = 1024;
      *(_DWORD *)long long v56 = v6;
      long long v10 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d";
    }
    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v8 = gLogObj;
      os_log_type_t v9 = type;
      BOOL v20 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v20)
        {
          int buf = 136446722;
          long long v54 = "nw_network_agent_copy_struct";
          __int16 v55 = 1024;
          *(_DWORD *)long long v56 = v6;
          *(_WORD *)&v56[4] = 2082;
          *(void *)&v56[6] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_33;
      }
      if (!v20)
      {
LABEL_33:
        if (v7) {
          free(v7);
        }
        return 0;
      }
      int buf = 136446466;
      long long v54 = "nw_network_agent_copy_struct";
      __int16 v55 = 1024;
      *(_DWORD *)long long v56 = v6;
      long long v10 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      long long v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (!os_log_type_enabled(v8, type)) {
        goto LABEL_33;
      }
      int buf = 136446466;
      long long v54 = "nw_network_agent_copy_struct";
      __int16 v55 = 1024;
      *(_DWORD *)long long v56 = v6;
      long long v10 = "%{public}s socket(AF_INET, SOCK_DGRAM, 0) failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v8, v9, v10, (uint8_t *)&buf, 0x12u);
    goto LABEL_33;
  }
  int v3 = v2;
  long long v51 = 0u;
  long long v52 = 0u;
  long long v49 = 0u;
  long long v50 = 0u;
  long long v47 = 0u;
  long long v48 = 0u;
  long long v45 = 0u;
  long long v46 = 0u;
  long long v43 = 0u;
  long long v44 = 0u;
  long long v41 = 0u;
  long long v42 = 0u;
  long long v39 = *(_OWORD *)a1;
  long long v40 = 0u;
  if (ioctl(v2, 0xC0E069A8uLL, &v39))
  {
    int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v5 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int buf = 136446466;
      long long v54 = "nw_network_agent_copy_struct";
      __int16 v55 = 1024;
      *(_DWORD *)long long v56 = v4;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s SIOCGIFAGENTDATA failed %{darwin.errno}d", (uint8_t *)&buf, 0x12u);
    }
LABEL_46:
    close(v3);
    return 0;
  }
  size_t v11 = DWORD1(v52) + 216;
  unsigned int v12 = malloc_type_calloc(1uLL, v11, 0xEAFB8F1AuLL);
  if (v12)
  {
    size_t v13 = DWORD1(v52);
    if (!DWORD1(v52)) {
      goto LABEL_51;
    }
LABEL_13:
    *((void *)&v52 + 1) = nw_calloc_type<unsigned char>(v13);
    if (ioctl(v3, 0xC0E069A8uLL, &v39))
    {
      int v14 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int buf = 136446466;
      long long v54 = "nw_network_agent_copy_struct";
      __int16 v55 = 1024;
      *(_DWORD *)long long v56 = v14;
      size_t v15 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (__nwlog_fault(v15, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          size_t v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            int buf = 136446466;
            long long v54 = "nw_network_agent_copy_struct";
            __int16 v55 = 1024;
            *(_DWORD *)long long v56 = v14;
            BOOL v18 = "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d";
LABEL_39:
            _os_log_impl(&dword_1830D4000, v16, v17, v18, (uint8_t *)&buf, 0x12u);
          }
        }
        else if (v37)
        {
          uint64_t v21 = (char *)__nw_create_backtrace_string();
          size_t v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          BOOL v22 = os_log_type_enabled(v16, type);
          if (v21)
          {
            if (v22)
            {
              int buf = 136446722;
              long long v54 = "nw_network_agent_copy_struct";
              __int16 v55 = 1024;
              *(_DWORD *)long long v56 = v14;
              *(_WORD *)&v56[4] = 2082;
              *(void *)&v56[6] = v21;
              _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x1Cu);
            }
            free(v21);
            goto LABEL_40;
          }
          if (v22)
          {
            int buf = 136446466;
            long long v54 = "nw_network_agent_copy_struct";
            __int16 v55 = 1024;
            *(_DWORD *)long long v56 = v14;
            BOOL v18 = "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d, no backtrace";
            goto LABEL_39;
          }
        }
        else
        {
          size_t v16 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            int buf = 136446466;
            long long v54 = "nw_network_agent_copy_struct";
            __int16 v55 = 1024;
            *(_DWORD *)long long v56 = v14;
            BOOL v18 = "%{public}s SIOCGIFAGENTDATA retry failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_39;
          }
        }
      }
LABEL_40:
      if (v15) {
        free(v15);
      }
      if (v12) {
        free(v12);
      }
      if (*((void *)&v52 + 1))
      {
        free(*((void **)&v52 + 1));
        *((void *)&v52 + 1) = 0;
      }
      goto LABEL_46;
    }
LABEL_51:
    long long v27 = v40;
    _OWORD *v12 = v39;
    v12[1] = v27;
    long long v28 = v41;
    long long v29 = v42;
    long long v30 = v44;
    void v12[4] = v43;
    v12[5] = v30;
    v12[2] = v28;
    v12[3] = v29;
    long long v31 = v45;
    long long v32 = v46;
    long long v33 = v48;
    v12[8] = v47;
    v12[9] = v33;
    v12[6] = v31;
    v12[7] = v32;
    long long v34 = v49;
    long long v35 = v50;
    long long v36 = v51;
    *((void *)v12 + 26) = v52;
    v12[11] = v35;
    v12[12] = v36;
    v12[10] = v34;
    if (*((void *)&v52 + 1))
    {
      memcpy((char *)v12 + 216, *((const void **)&v52 + 1), DWORD1(v52));
      if (*((void *)&v52 + 1))
      {
        free(*((void **)&v52 + 1));
        *((void *)&v52 + 1) = 0;
      }
    }
    close(v3);
    xpc_object_t v23 = xpc_dictionary_create(0, 0, 0);
    xpc_dictionary_set_data(v23, "data", v12, *((unsigned int *)v12 + 53) + 216);
    free(v12);
    return (BOOL)v23;
  }
  uint64_t v25 = __nwlog_obj();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  int buf = 136446722;
  long long v54 = "strict_calloc";
  __int16 v55 = 2048;
  *(void *)long long v56 = 1;
  *(_WORD *)&v56[8] = 2048;
  *(void *)&v56[10] = v11;
  os_log_type_t v26 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    size_t v13 = DWORD1(v52);
    if (!DWORD1(v52)) {
      goto LABEL_51;
    }
    goto LABEL_13;
  }
  __break(1u);
  return result;
}

uint64_t nw_network_agent_set_use_count(int a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v14 = a2;
  uint64_t v3 = setsockopt(a1, 2, 16, &v14, 8u);
  if ((v3 & 0x80000000) == 0) {
    return v3;
  }
  int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446978;
  size_t v16 = "nw_network_agent_set_use_count";
  __int16 v17 = 1024;
  int v18 = a1;
  __int16 v19 = 2048;
  uint64_t v20 = v14;
  __int16 v21 = 1024;
  int v22 = v4;
  long long v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)int buf = 136446978;
      size_t v16 = "nw_network_agent_set_use_count";
      __int16 v17 = 1024;
      int v18 = a1;
      __int16 v19 = 2048;
      uint64_t v20 = v14;
      __int16 v21 = 1024;
      int v22 = v4;
      long long v8 = "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d";
      goto LABEL_15;
    }
    if (!v12)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v6 = gLogObj;
      os_log_type_t v7 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_16;
      }
      *(_DWORD *)int buf = 136446978;
      size_t v16 = "nw_network_agent_set_use_count";
      __int16 v17 = 1024;
      int v18 = a1;
      __int16 v19 = 2048;
      uint64_t v20 = v14;
      __int16 v21 = 1024;
      int v22 = v4;
      long long v8 = "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, backtrace limit exceeded";
      goto LABEL_15;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v6 = gLogObj;
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)int buf = 136447234;
        size_t v16 = "nw_network_agent_set_use_count";
        __int16 v17 = 1024;
        int v18 = a1;
        __int16 v19 = 2048;
        uint64_t v20 = v14;
        __int16 v21 = 1024;
        int v22 = v4;
        __int16 v23 = 2082;
        os_log_type_t v24 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s setsockopt for use count failed, handle = %d, use_size_t count = %llu %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
      }
      free(backtrace_string);
      goto LABEL_16;
    }
    if (v10)
    {
      *(_DWORD *)int buf = 136446978;
      size_t v16 = "nw_network_agent_set_use_count";
      __int16 v17 = 1024;
      int v18 = a1;
      __int16 v19 = 2048;
      uint64_t v20 = v14;
      __int16 v21 = 1024;
      int v22 = v4;
      long long v8 = "%{public}s setsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, no backtrace";
LABEL_15:
      _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x22u);
    }
  }
LABEL_16:
  if (v5) {
    free(v5);
  }
  return v3;
}

uint64_t nw_network_agent_get_use_count(int a1, void *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *a2 = 0;
    *(void *)os_log_type_t type = 0;
    socklen_t v25 = 8;
    uint64_t v4 = getsockopt(a1, 2, 16, type, &v25);
    if ((v4 & 0x80000000) == 0)
    {
      *a2 = *(void *)type;
      return v4;
    }
    int v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446978;
    long long v28 = "nw_network_agent_get_use_count";
    __int16 v29 = 1024;
    *(_DWORD *)long long v30 = a1;
    *(_WORD *)&v30[4] = 2048;
    *(void *)&v30[6] = *(void *)type;
    __int16 v31 = 1024;
    int v32 = v9;
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &v24, &v23)) {
      goto LABEL_36;
    }
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v11 = gLogObj;
      os_log_type_t v12 = v24;
      if (!os_log_type_enabled((os_log_t)gLogObj, v24)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446978;
      long long v28 = "nw_network_agent_get_use_count";
      __int16 v29 = 1024;
      *(_DWORD *)long long v30 = a1;
      *(_WORD *)&v30[4] = 2048;
      *(void *)&v30[6] = *(void *)type;
      __int16 v31 = 1024;
      int v32 = v9;
      size_t v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v11 = gLogObj;
      os_log_type_t v12 = v24;
      BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, v24);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136447234;
          long long v28 = "nw_network_agent_get_use_count";
          __int16 v29 = 1024;
          *(_DWORD *)long long v30 = a1;
          *(_WORD *)&v30[4] = 2048;
          *(void *)&v30[6] = *(void *)type;
          __int16 v31 = 1024;
          int v32 = v9;
          __int16 v33 = 2082;
          long long v34 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s getsockopt for use count failed, handle = %d, use_size_t count = %llu %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x2Cu);
        }
        free(backtrace_string);
        goto LABEL_36;
      }
      if (!v19)
      {
LABEL_36:
        if (v10) {
          free(v10);
        }
        return v4;
      }
      *(_DWORD *)int buf = 136446978;
      long long v28 = "nw_network_agent_get_use_count";
      __int16 v29 = 1024;
      *(_DWORD *)long long v30 = a1;
      *(_WORD *)&v30[4] = 2048;
      *(void *)&v30[6] = *(void *)type;
      __int16 v31 = 1024;
      int v32 = v9;
      size_t v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v11 = gLogObj;
      os_log_type_t v12 = v24;
      if (!os_log_type_enabled((os_log_t)gLogObj, v24)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446978;
      long long v28 = "nw_network_agent_get_use_count";
      __int16 v29 = 1024;
      *(_DWORD *)long long v30 = a1;
      *(_WORD *)&v30[4] = 2048;
      *(void *)&v30[6] = *(void *)type;
      __int16 v31 = 1024;
      int v32 = v9;
      size_t v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %llu %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0x22u);
    goto LABEL_36;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446210;
  long long v28 = "nw_network_agent_get_use_count";
  long long v5 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v25) = 0;
  if (__nwlog_fault(v5, type, &v25))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        long long v28 = "nw_network_agent_get_use_count";
        long long v8 = "%{public}s called with null out_use_count";
LABEL_24:
        uint64_t v20 = v6;
        os_log_type_t v21 = v7;
LABEL_25:
        _os_log_impl(&dword_1830D4000, v20, v21, v8, buf, 0xCu);
      }
    }
    else if ((_BYTE)v25)
    {
      uint64_t v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v15 = gLogObj;
      os_log_type_t v16 = type[0];
      BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v14)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          long long v28 = "nw_network_agent_get_use_count";
          __int16 v29 = 2082;
          *(void *)long long v30 = v14;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null out_use_count, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v14);
        goto LABEL_26;
      }
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        long long v28 = "nw_network_agent_get_use_count";
        long long v8 = "%{public}s called with null out_use_count, no backtrace";
        uint64_t v20 = v15;
        os_log_type_t v21 = v16;
        goto LABEL_25;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        long long v28 = "nw_network_agent_get_use_count";
        long long v8 = "%{public}s called with null out_use_count, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
LABEL_26:
  if (v5) {
    free(v5);
  }
  return 0xFFFFFFFFLL;
}

uint64_t nw_network_agent_get_token_count(int a1, _DWORD *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *a2 = 0;
    socklen_t v25 = 4;
    *(_DWORD *)os_log_type_t type = 0;
    uint64_t v4 = getsockopt(a1, 2, 23, type, &v25);
    if ((v4 & 0x80000000) == 0)
    {
      *a2 = *(_DWORD *)type;
      return v4;
    }
    int v9 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)int buf = 136446978;
    long long v28 = "nw_network_agent_get_token_count";
    __int16 v29 = 1024;
    *(_DWORD *)long long v30 = a1;
    *(_WORD *)&v30[4] = 1024;
    *(_DWORD *)&v30[6] = *(_DWORD *)type;
    __int16 v31 = 1024;
    int v32 = v9;
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &v24, &v23)) {
      goto LABEL_36;
    }
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v11 = gLogObj;
      os_log_type_t v12 = v24;
      if (!os_log_type_enabled((os_log_t)gLogObj, v24)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446978;
      long long v28 = "nw_network_agent_get_token_count";
      __int16 v29 = 1024;
      *(_DWORD *)long long v30 = a1;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = *(_DWORD *)type;
      __int16 v31 = 1024;
      int v32 = v9;
      size_t v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d";
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v11 = gLogObj;
      os_log_type_t v12 = v24;
      BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, v24);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)int buf = 136447234;
          long long v28 = "nw_network_agent_get_token_count";
          __int16 v29 = 1024;
          *(_DWORD *)long long v30 = a1;
          *(_WORD *)&v30[4] = 1024;
          *(_DWORD *)&v30[6] = *(_DWORD *)type;
          __int16 v31 = 1024;
          int v32 = v9;
          __int16 v33 = 2082;
          long long v34 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s getsockopt for use count failed, handle = %d, use_size_t count = %u %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x28u);
        }
        free(backtrace_string);
        goto LABEL_36;
      }
      if (!v19)
      {
LABEL_36:
        if (v10) {
          free(v10);
        }
        return v4;
      }
      *(_DWORD *)int buf = 136446978;
      long long v28 = "nw_network_agent_get_token_count";
      __int16 v29 = 1024;
      *(_DWORD *)long long v30 = a1;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = *(_DWORD *)type;
      __int16 v31 = 1024;
      int v32 = v9;
      size_t v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v11 = gLogObj;
      os_log_type_t v12 = v24;
      if (!os_log_type_enabled((os_log_t)gLogObj, v24)) {
        goto LABEL_36;
      }
      *(_DWORD *)int buf = 136446978;
      long long v28 = "nw_network_agent_get_token_count";
      __int16 v29 = 1024;
      *(_DWORD *)long long v30 = a1;
      *(_WORD *)&v30[4] = 1024;
      *(_DWORD *)&v30[6] = *(_DWORD *)type;
      __int16 v31 = 1024;
      int v32 = v9;
      size_t v13 = "%{public}s getsockopt for use count failed, handle = %d, use_count = %u %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0x1Eu);
    goto LABEL_36;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)int buf = 136446210;
  long long v28 = "nw_network_agent_get_token_count";
  long long v5 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v25) = 0;
  if (__nwlog_fault(v5, type, &v25))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        long long v28 = "nw_network_agent_get_token_count";
        long long v8 = "%{public}s called with null out_use_count";
LABEL_24:
        uint64_t v20 = v6;
        os_log_type_t v21 = v7;
LABEL_25:
        _os_log_impl(&dword_1830D4000, v20, v21, v8, buf, 0xCu);
      }
    }
    else if ((_BYTE)v25)
    {
      uint64_t v14 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      size_t v15 = gLogObj;
      os_log_type_t v16 = type[0];
      BOOL v17 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
      if (v14)
      {
        if (v17)
        {
          *(_DWORD *)int buf = 136446466;
          long long v28 = "nw_network_agent_get_token_count";
          __int16 v29 = 2082;
          *(void *)long long v30 = v14;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null out_use_count, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v14);
        goto LABEL_26;
      }
      if (v17)
      {
        *(_DWORD *)int buf = 136446210;
        long long v28 = "nw_network_agent_get_token_count";
        long long v8 = "%{public}s called with null out_use_count, no backtrace";
        uint64_t v20 = v15;
        os_log_type_t v21 = v16;
        goto LABEL_25;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v6 = gLogObj;
      os_log_type_t v7 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)int buf = 136446210;
        long long v28 = "nw_network_agent_get_token_count";
        long long v8 = "%{public}s called with null out_use_count, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
LABEL_26:
  if (v5) {
    free(v5);
  }
  return 0xFFFFFFFFLL;
}

void *nw_protocol_socksv5_copy_definition()
{
  if (nw_protocol_socksv5_copy_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_socksv5_copy_definition::onceToken, &__block_literal_global_85297);
  }
  BOOL result = (void *)nw_protocol_socksv5_copy_definition::definition;
  if (nw_protocol_socksv5_copy_definition::definition)
  {
    return os_retain(result);
  }
  return result;
}

BOOL __nw_protocol_socksv5_copy_definition_block_invoke()
{
  nw_protocol_definition_t definition = nw_framer_create_definition("socksv5", 0, &__block_literal_global_9_85302);
  nw_protocol_socksv5_copy_definition::nw_protocol_definition_t definition = (uint64_t)definition;

  return nw_protocol_definition_register(definition);
}

uint64_t __nw_protocol_socksv5_copy_definition_block_invoke_2(uint64_t a1, NSObject *a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v3)
  {
LABEL_2:
    void v3[4] = 0;
    nw_parameters_t v4 = nw_framer_copy_parameters(a2);
    if (v4)
    {
      long long v5 = v4;
      id v6 = v5[23];

      if (v6)
      {
        os_log_type_t v7 = (id *)v6;
        id v8 = v7[13];

        if (v8)
        {
          int v9 = v8;
          BOOL v10 = (const char *)v9[2];

          if (v10) {
            *(void *)uint64_t v3 = xpc_string_create(v10);
          }
          size_t v11 = v9;
          os_log_type_t v12 = (const char *)v11[3];

          if (v12) {
            *((void *)v3 + 1) = xpc_string_create(v12);
          }
        }
        os_release(v7);
      }
      os_release(v5);
    }
    input_handler[0] = MEMORY[0x1E4F143A8];
    input_handler[1] = 0x40000000;
    input_handler[2] = __nw_protocol_socksv5_copy_definition_block_invoke_3;
    input_handler[3] = &__block_descriptor_tmp_14_85308;
    input_void handler[4] = v3;
    input_handler[5] = a2;
    nw_framer_set_input_handler(a2, input_handler);
    output_handler[0] = MEMORY[0x1E4F143A8];
    output_handler[1] = 0x40000000;
    output_handler[2] = __nw_protocol_socksv5_copy_definition_block_invoke_2_15;
    output_handler[3] = &__block_descriptor_tmp_17_85309;
    output_void handler[4] = v3;
    nw_framer_set_output_handler(a2, output_handler);
    cleanup_handler[0] = MEMORY[0x1E4F143A8];
    cleanup_handler[1] = 0x40000000;
    cleanup_handler[2] = __nw_protocol_socksv5_copy_definition_block_invoke_3_18;
    cleanup_handler[3] = &__block_descriptor_tmp_20_85310;
    cleanup_void handler[4] = v3;
    nw_framer_set_cleanup_handler(a2, cleanup_handler);
    if (a2)
    {
      *(_DWORD *)output_buffer = 261;
      if (*(void *)v3 && *((void *)v3 + 1))
      {
        output_buffer[1] = OS_LOG_TYPE_DEBUG;
        output_buffer[3] = OS_LOG_TYPE_DEBUG;
        size_t v13 = 4;
      }
      else
      {
        size_t v13 = 3;
      }
      nw_framer_write_output(a2, (const uint8_t *)output_buffer, v13);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v14 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)int buf = 136446210;
        long long v30 = "nw_socksv5_send_hello";
        _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s Sent client hello", buf, 0xCu);
      }
      void v3[4] = 1;
      return 2;
    }
    __nwlog_obj();
    *(_DWORD *)int buf = 136446210;
    long long v30 = "nw_socksv5_send_hello";
    int v18 = (char *)_os_log_send_and_compose_impl();
    output_buffer[0] = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v18, output_buffer, &v28))
    {
      if (output_buffer[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v19 = __nwlog_obj();
        os_log_type_t v20 = output_buffer[0];
        if (!os_log_type_enabled(v19, output_buffer[0])) {
          goto LABEL_36;
        }
        *(_DWORD *)int buf = 136446210;
        long long v30 = "nw_socksv5_send_hello";
        os_log_type_t v21 = "%{public}s called with null framer";
        goto LABEL_35;
      }
      if (!v28)
      {
        BOOL v19 = __nwlog_obj();
        os_log_type_t v20 = output_buffer[0];
        if (!os_log_type_enabled(v19, output_buffer[0])) {
          goto LABEL_36;
        }
        *(_DWORD *)int buf = 136446210;
        long long v30 = "nw_socksv5_send_hello";
        os_log_type_t v21 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = output_buffer[0];
      BOOL v23 = os_log_type_enabled(v19, output_buffer[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)int buf = 136446466;
          long long v30 = "nw_socksv5_send_hello";
          __int16 v31 = 2082;
          uint64_t v32 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null framer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_36;
      }
      if (v23)
      {
        *(_DWORD *)int buf = 136446210;
        long long v30 = "nw_socksv5_send_hello";
        os_log_type_t v21 = "%{public}s called with null framer, no backtrace";
LABEL_35:
        _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
      }
    }
LABEL_36:
    if (v18) {
      free(v18);
    }
    return 2;
  }
  os_log_type_t v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)int buf = 136446722;
  long long v30 = "strict_calloc";
  __int16 v31 = 2048;
  uint64_t v32 = 1;
  __int16 v33 = 2048;
  uint64_t v34 = 24;
  BOOL v17 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_2;
  }
  __break(1u);
  return result;
}

uint64_t __nw_protocol_socksv5_copy_definition_block_invoke_3(uint64_t a1, nw_framer_t framer)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  switch(*(_DWORD *)(v2 + 16))
  {
    case 0:
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_parameters_t v4 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        LODWORD(buf) = 136446210;
        *(void *)((char *)&buf + 4) = "nw_protocol_socksv5_copy_definition_block_invoke_3";
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s Reading packets in initial state", (uint8_t *)&buf, 0xCu);
      }
      return 0;
    case 1:
      long long v5 = *(NSObject **)(a1 + 40);
      *(_WORD *)temp_buffer = 0;
      *(void *)&long long buf = MEMORY[0x1E4F143A8];
      *((void *)&buf + 1) = 0x40000000;
      id v6 = &__block_descriptor_tmp_27_85321;
      os_log_type_t v7 = ___ZL22nw_socksv5_parse_helloP9nw_framerP10nw_socksv5_block_invoke;
      goto LABEL_6;
    case 2:
      long long v5 = *(NSObject **)(a1 + 40);
      *(_WORD *)temp_buffer = 0;
      *(void *)&long long buf = MEMORY[0x1E4F143A8];
      *((void *)&buf + 1) = 0x40000000;
      id v6 = &__block_descriptor_tmp_28_85322;
      os_log_type_t v7 = ___ZL21nw_socksv5_parse_authP9nw_framerP10nw_socksv5_block_invoke;
LABEL_6:
      uint64_t v40 = (uint64_t)v7;
      long long v41 = v6;
      long long v42 = v5;
      uint64_t v43 = v2;
      nw_framer_parse_input(v5, 2uLL, 2uLL, temp_buffer, &buf);
      return 0;
    case 3:
      id v8 = *(NSObject **)(a1 + 40);
      *(_DWORD *)__int16 v33 = 0;
      uint64_t v29 = 0;
      long long v30 = &v29;
      int v32 = 0;
      uint64_t v31 = 0x2000000000;
      uint64_t v25 = 0;
      os_log_type_t v26 = &v25;
      uint64_t v27 = 0x2000000000;
      char v28 = 0;
      *(void *)temp_buffer = MEMORY[0x1E4F143A8];
      uint64_t v19 = 0x40000000;
      uint64_t v20 = (uint64_t)___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke;
      os_log_type_t v21 = &unk_1E524AA80;
      BOOL v23 = &v29;
      os_log_type_t v24 = v8;
      int v22 = &v25;
      if (nw_framer_parse_input(v8, 4uLL, 4uLL, v33, temp_buffer))
      {
        if (*((unsigned char *)v26 + 24) != 3) {
          goto LABEL_10;
        }
        *(_DWORD *)((char *)&buf + 3) = 0;
        LODWORD(buf) = 0;
        size_t v9 = *((unsigned int *)v30 + 6);
        parse[0] = MEMORY[0x1E4F143A8];
        parse[1] = 0x40000000;
        parse[2] = ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_30;
        parse[3] = &unk_1E524AAA8;
        parse[4] = &v29;
        if (nw_framer_parse_input(v8, v9, v9, (uint8_t *)&buf, parse))
        {
LABEL_10:
          bzero(&buf, 0x201uLL);
          size_t v10 = *((unsigned int *)v30 + 6);
          if (v10 < 0x202)
          {
            *(void *)&long long v34 = MEMORY[0x1E4F143A8];
            *((void *)&v34 + 1) = 0x40000000;
            uint64_t v35 = ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_32;
            long long v36 = &unk_1E524AAD0;
            char v37 = &v29;
            uint64_t v38 = v2;
            if (nw_framer_parse_input(v8, v10, v10, (uint8_t *)&buf, &v34))
            {
              nw_framer_pass_through_input(v8);
              nw_framer_pass_through_output(v8);
              nw_framer_mark_ready(v8);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            size_t v11 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              LODWORD(v34) = 136446210;
              *(void *)((char *)&v34 + 4) = "nw_socksv5_parse_connect";
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s Read length is longer than the destination message, disconnecting", (uint8_t *)&v34, 0xCu);
            }
            nw_framer_mark_failed_with_error(v8, 22);
          }
        }
      }
      _Block_object_dispose(&v25, 8);
      p_long long buf = &v29;
      goto LABEL_20;
    case 4:
      *(void *)&long long buf = 0;
      *((void *)&buf + 1) = &buf;
      uint64_t v40 = 0x2000000000;
      long long v41 = 0;
      *(void *)temp_buffer = 0;
      uint64_t v19 = (uint64_t)temp_buffer;
      uint64_t v20 = 0x2000000000;
      LOBYTE(v21) = 0;
      v16[0] = MEMORY[0x1E4F143A8];
      v16[1] = 0x40000000;
      void v16[2] = __nw_protocol_socksv5_copy_definition_block_invoke_10;
      v16[3] = &unk_1E524A9B8;
      v16[4] = &buf;
      v16[5] = temp_buffer;
      nw_framer_parse_input(framer, 1uLL, 0xFFFFFFFFuLL, 0, v16);
      size_t v13 = nw_framer_message_create(*(nw_framer_t *)(a1 + 40));
      nw_framer_deliver_input_no_copy(framer, *(void *)(*((void *)&buf + 1) + 24), v13, *(unsigned char *)(v19 + 24));
      if (v13) {
        os_release(v13);
      }
      _Block_object_dispose(temp_buffer, 8);
      p_long long buf = (uint64_t *)&buf;
LABEL_20:
      _Block_object_dispose(p_buf, 8);
      break;
    default:
      return 0;
  }
  return 0;
}

BOOL __nw_protocol_socksv5_copy_definition_block_invoke_2_15(BOOL result, nw_framer_t framer, int a3, size_t output_length)
{
  if (*(_DWORD *)(*(void *)(result + 32) + 16) == 4) {
    return nw_framer_write_output_no_copy(framer, output_length);
  }
  return result;
}

void __nw_protocol_socksv5_copy_definition_block_invoke_3_18(uint64_t a1)
{
  uint64_t v2 = *(xpc_object_t **)(a1 + 32);
  if (*v2)
  {
    xpc_release(*v2);
    **(void **)(a1 + 32) = 0;
    uint64_t v2 = *(xpc_object_t **)(a1 + 32);
  }
  if (!v2[1]
    || (xpc_release(v2[1]), *(void *)(*(void *)(a1 + 32) + 8) = 0, (uint64_t v2 = *(xpc_object_t **)(a1 + 32)) != 0))
  {
    free(v2);
  }
}

uint64_t ___ZL22nw_socksv5_parse_helloP9nw_framerP10nw_socksv5_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*a2 != 5)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v8 = *a2;
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v8;
        size_t v9 = "%{public}s Received invalid SOCKS version %d";
LABEL_22:
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, v9, buf, 0x12u);
      }
LABEL_23:
      nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 22);
      return 2;
    }
    if (a2[1] != 2)
    {
      if (!a2[1])
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_parameters_t v4 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
          _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s Received hello. Doing SOCKSv5 with no authentication", buf, 0xCu);
        }
        nw_socksv5_send_connect(*(NSObject **)(a1 + 32), *(void *)(a1 + 40));
        return 2;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v7 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v16 = a2[1];
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v16;
        size_t v9 = "%{public}s Received invalid SOCKS method %d";
        goto LABEL_22;
      }
      goto LABEL_23;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    size_t v10 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s Received hello. Doing SOCKSv5 with username/password authentication", buf, 0xCu);
    }
    size_t v11 = *(NSObject **)(a1 + 32);
    if (v11)
    {
      uint64_t v12 = *(void *)(a1 + 40);
      long long v62 = 0u;
      memset(v63, 0, sizeof(v63));
      long long v60 = 0u;
      long long v61 = 0u;
      long long v58 = 0u;
      long long v59 = 0u;
      long long v56 = 0u;
      long long v57 = 0u;
      long long v54 = 0u;
      long long v55 = 0u;
      long long v52 = 0u;
      long long v53 = 0u;
      long long v50 = 0u;
      long long v51 = 0u;
      long long v49 = 0u;
      long long v48 = 0u;
      long long v47 = 0u;
      long long v46 = 0u;
      long long v45 = 0u;
      long long v44 = 0u;
      long long v43 = 0u;
      long long v42 = 0u;
      long long v41 = 0u;
      long long v40 = 0u;
      long long v39 = 0u;
      long long v38 = 0u;
      long long v37 = 0u;
      long long v36 = 0u;
      long long v35 = 0u;
      memset(&buf[2], 0, 32);
      buf[0] = 1;
      if (*(void *)v12)
      {
        size_t length = xpc_string_get_length(*(xpc_object_t *)v12);
        uint64_t v14 = *(void **)(v12 + 8);
        if (v14)
        {
LABEL_19:
          size_t v15 = xpc_string_get_length(v14);
LABEL_28:
          if (length >= 0xFE) {
            size_t v18 = 254;
          }
          else {
            size_t v18 = length;
          }
          if (v15 >= 0xFE) {
            size_t v19 = 254;
          }
          else {
            size_t v19 = v15;
          }
          buf[1] = v18;
          if (v18)
          {
            string_ptr = xpc_string_get_string_ptr(*(xpc_object_t *)v12);
            strncpy(&buf[2], string_ptr, v18);
          }
          buf[v18 + 2] = v19;
          if (v19)
          {
            os_log_type_t v21 = xpc_string_get_string_ptr(*(xpc_object_t *)(v12 + 8));
            strncpy(&buf[v18 + 3], v21, v19);
          }
          uint64_t v22 = length - 255;
          if (length >= 0xFF) {
            uint64_t v22 = -1;
          }
          uint64_t v23 = v15 - 255;
          if (v15 >= 0xFF) {
            uint64_t v23 = -1;
          }
          nw_framer_write_output(v11, buf, v22 + v23 + 513);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v24 = gLogObj;
          uint64_t v6 = 2;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)int v32 = 136446210;
            __int16 v33 = "nw_socksv5_send_auth";
            _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s Sent client auth", v32, 0xCu);
          }
          *(_DWORD *)(v12 + 16) = 2;
          return v6;
        }
      }
      else
      {
        size_t length = 0;
        uint64_t v14 = *(void **)(v12 + 8);
        if (v14) {
          goto LABEL_19;
        }
      }
      size_t v15 = 0;
      goto LABEL_28;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();
    v32[0] = 16;
    char v31 = 0;
    if (__nwlog_fault(v25, v32, &v31))
    {
      if (v32[0] == 17)
      {
        os_log_type_t v26 = __nwlog_obj();
        os_log_type_t v27 = v32[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v32[0])) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
        char v28 = "%{public}s called with null framer";
        goto LABEL_58;
      }
      if (!v31)
      {
        os_log_type_t v26 = __nwlog_obj();
        os_log_type_t v27 = v32[0];
        if (!os_log_type_enabled(v26, (os_log_type_t)v32[0])) {
          goto LABEL_59;
        }
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
        char v28 = "%{public}s called with null framer, backtrace limit exceeded";
        goto LABEL_58;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = v32[0];
      BOOL v30 = os_log_type_enabled(v26, (os_log_type_t)v32[0]);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null framer, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_59;
      }
      if (v30)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socksv5_send_auth";
        char v28 = "%{public}s called with null framer, no backtrace";
LABEL_58:
        _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
      }
    }
LABEL_59:
    if (v25) {
      free(v25);
    }
    return 2;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  long long v5 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socksv5_parse_hello_block_invoke";
    _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s Received NULL server hello", buf, 0xCu);
  }
  return 0;
}

uint64_t ___ZL21nw_socksv5_parse_authP9nw_framerP10nw_socksv5_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    if (*a2 == 1)
    {
      int v4 = a2[1];
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v5 = gLogObj;
      if (!v4)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
        {
          int v11 = 136446210;
          uint64_t v12 = "nw_socksv5_parse_auth_block_invoke";
          _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s Received authentication success from SOCKS server", (uint8_t *)&v11, 0xCu);
        }
        nw_socksv5_send_connect(*(NSObject **)(a1 + 32), *(void *)(a1 + 40));
        return 2;
      }
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v6 = a2[1];
        int v11 = 136446466;
        uint64_t v12 = "nw_socksv5_parse_auth_block_invoke";
        __int16 v13 = 1024;
        int v14 = v6;
        os_log_type_t v7 = "%{public}s Received SOCKS auth status %d, failing";
LABEL_11:
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, v7, (uint8_t *)&v11, 0x12u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v5 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v10 = *a2;
        int v11 = 136446466;
        uint64_t v12 = "nw_socksv5_parse_auth_block_invoke";
        __int16 v13 = 1024;
        int v14 = v10;
        os_log_type_t v7 = "%{public}s Received invalid SOCKS auth version %d";
        goto LABEL_11;
      }
    }
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 32), 80);
    return 2;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v8 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    int v11 = 136446210;
    uint64_t v12 = "nw_socksv5_parse_auth_block_invoke";
    _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s Received NULL server auth", (uint8_t *)&v11, 0xCu);
  }
  return 0;
}

uint64_t ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke(uint64_t a1, unsigned __int8 *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v13 = 136446210;
      int v14 = "nw_socksv5_parse_connect_block_invoke";
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s Received NULL header", (uint8_t *)&v13, 0xCu);
    }
    return 0;
  }
  if (*a2 == 5)
  {
    if (a2[1])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v4 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v5 = a2[1];
        int v13 = 136446466;
        int v14 = "nw_socksv5_parse_connect_block_invoke";
        __int16 v15 = 1024;
        int v16 = v5;
        int v6 = "%{public}s Received SOCKS connect status %d, failing";
LABEL_11:
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, v6, (uint8_t *)&v13, 0x12u);
        goto LABEL_12;
      }
      goto LABEL_12;
    }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a2[3];
    int v10 = a2[3];
    switch(v10)
    {
      case 4:
        uint64_t result = 0;
        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 22;
        return result;
      case 3:
        uint64_t result = 0;
        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 5;
        return result;
      case 1:
        uint64_t result = 0;
        *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 10;
        return result;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v11 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v12 = a2[3];
      int v13 = 136446466;
      int v14 = "nw_socksv5_parse_connect_block_invoke";
      __int16 v15 = 1024;
      int v16 = v12;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s Received SOCKS unknown type %d", (uint8_t *)&v13, 0x12u);
    }
    nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 48), 22);
    return 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v4 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    int v9 = *a2;
    int v13 = 136446466;
    int v14 = "nw_socksv5_parse_connect_block_invoke";
    __int16 v15 = 1024;
    int v16 = v9;
    int v6 = "%{public}s Received invalid SOCKS version %d";
    goto LABEL_11;
  }
LABEL_12:
  nw_framer_mark_failed_with_error(*(nw_framer_t *)(a1 + 48), 22);
  return 4;
}

uint64_t ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_30(uint64_t a1, uint64_t a2)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  if (a2)
  {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned __int8 *)(a2 + 4) + 7;
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v2 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      int v4 = 136446210;
      int v5 = "nw_socksv5_parse_connect_block_invoke";
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s Received NULL fqdn", (uint8_t *)&v4, 0xCu);
    }
  }
  return 0;
}

uint64_t ___ZL24nw_socksv5_parse_connectP9nw_framerP10nw_socksv5_block_invoke_32(uint64_t a1)
{
  uint64_t v6 = *MEMORY[0x1E4F143B8];
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v2 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
  {
    int v4 = 136446210;
    int v5 = "nw_socksv5_parse_connect_block_invoke";
    _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_DEBUG, "%{public}s Received complete connect message from SOCKS server", (uint8_t *)&v4, 0xCu);
  }
  *(_DWORD *)(*(void *)(a1 + 40) + 16) = 4;
  return *(unsigned int *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
}

uint64_t __nw_protocol_socksv5_copy_definition_block_invoke_10(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = a3;
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a4;
  return 0;
}

void nw_socksv5_send_connect(NSObject *a1, uint64_t a2)
{
  uint64_t v52 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    nw_endpoint_t v4 = nw_framer_copy_remote_endpoint(a1);
    BOOL v5 = nw_endpoint_copy_proxy_original_endpoint(v4);
    if (v4) {
      os_release(v4);
    }
    long long v50 = 0u;
    memset(v51, 0, sizeof(v51));
    long long v48 = 0u;
    long long v49 = 0u;
    long long v46 = 0u;
    long long v47 = 0u;
    long long v44 = 0u;
    long long v45 = 0u;
    long long v42 = 0u;
    long long v43 = 0u;
    long long v40 = 0u;
    long long v41 = 0u;
    long long v38 = 0u;
    long long v39 = 0u;
    long long v37 = 0u;
    long long v36 = 0u;
    long long v35 = 0u;
    long long v34 = 0u;
    long long v33 = 0u;
    long long v32 = 0u;
    long long v31 = 0u;
    long long v30 = 0u;
    long long v29 = 0u;
    long long v28 = 0u;
    long long v27 = 0u;
    long long v26 = 0u;
    long long v25 = 0u;
    long long v24 = 0u;
    long long v23 = 0u;
    *(_WORD *)output_buffer = 261;
    memset(&output_buffer[2], 0, 33);
    if (nw_endpoint_get_type((nw_endpoint_t)v5) == nw_endpoint_type_address)
    {
      address = nw_endpoint_get_address((nw_endpoint_t)v5);
      if (address->sa_family == 30)
      {
        output_buffer[3] = 4;
        *(sockaddr *)&output_buffer[4] = *(sockaddr *)&address->sa_data[6];
        *(_WORD *)&output_buffer[20] = *(_WORD *)address->sa_data;
        size_t v7 = 22;
      }
      else
      {
        output_buffer[3] = 1;
        *(_DWORD *)&output_buffer[4] = *(_DWORD *)&address->sa_data[2];
        *(_WORD *)&output_buffer[8] = *(_WORD *)address->sa_data;
        size_t v7 = 10;
      }
    }
    else
    {
      output_buffer[3] = 3;
      hostname = nw_endpoint_get_hostname((nw_endpoint_t)v5);
      if (hostname)
      {
        int v9 = hostname;
        size_t v10 = strlen(hostname);
        if (v10 >= 0xFF) {
          size_t v11 = 255;
        }
        else {
          size_t v11 = v10;
        }
        output_buffer[4] = v11;
        memcpy(&output_buffer[5], v9, v11);
      }
      else
      {
        size_t v11 = 0;
        output_buffer[4] = 0;
      }
      *(_WORD *)&output_buffer[v11 + 5] = __rev16(nw_endpoint_get_port((nw_endpoint_t)v5));
      size_t v7 = v11 + 7;
    }
    nw_framer_write_output(a1, output_buffer, v7);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v12 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v21 = "nw_socksv5_send_connect";
      _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s Sent client request", buf, 0xCu);
    }
    *(_DWORD *)(a2 + 16) = 3;
    if (v5) {
      os_release((void *)v5);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)output_buffer = 136446210;
  *(void *)&output_buffer[4] = "nw_socksv5_send_connect";
  int v13 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  char v19 = 0;
  if (__nwlog_fault(v13, buf, &v19))
  {
    if (buf[0] == 17)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = buf[0];
      if (!os_log_type_enabled(v14, (os_log_type_t)buf[0])) {
        goto LABEL_34;
      }
      *(_DWORD *)output_buffer = 136446210;
      *(void *)&output_buffer[4] = "nw_socksv5_send_connect";
      int v16 = "%{public}s called with null framer";
      goto LABEL_33;
    }
    if (!v19)
    {
      int v14 = __nwlog_obj();
      os_log_type_t v15 = buf[0];
      if (!os_log_type_enabled(v14, (os_log_type_t)buf[0])) {
        goto LABEL_34;
      }
      *(_DWORD *)output_buffer = 136446210;
      *(void *)&output_buffer[4] = "nw_socksv5_send_connect";
      int v16 = "%{public}s called with null framer, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v14 = __nwlog_obj();
    os_log_type_t v15 = buf[0];
    BOOL v18 = os_log_type_enabled(v14, (os_log_type_t)buf[0]);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)output_buffer = 136446466;
        *(void *)&output_buffer[4] = "nw_socksv5_send_connect";
        *(_WORD *)&output_buffer[12] = 2082;
        *(void *)&output_buffer[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null framer, dumping backtrace:%{public}s", output_buffer, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_34;
    }
    if (v18)
    {
      *(_DWORD *)output_buffer = 136446210;
      *(void *)&output_buffer[4] = "nw_socksv5_send_connect";
      int v16 = "%{public}s called with null framer, no backtrace";
LABEL_33:
      _os_log_impl(&dword_1830D4000, v14, v15, v16, output_buffer, 0xCu);
    }
  }
LABEL_34:
  if (v13) {
    free(v13);
  }
}

void *nw_protocol_copy_test_definition()
{
  if (nw_protocol_copy_test_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_85364);
  }
  uint64_t result = (void *)nw_protocol_copy_test_definition::test_definition;
  if (nw_protocol_copy_test_definition::test_definition)
  {
    return os_retain(result);
  }
  return result;
}

void __nw_protocol_copy_test_definition_block_invoke()
{
  if (nw_protocol_test_identifier(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_test_identifier(void)::onceToken, &__block_literal_global_15_85368);
  }
  nw_protocol_copy_test_definition::test_nw_protocol_definition_t definition = (uint64_t)nw_protocol_definition_create_with_identifier((long long *)&g_test_protocol_identifier);
  nw_protocol_definition_set_options_allocator((void *)nw_protocol_copy_test_definition::test_definition, (uint64_t)nw_protocol_test_allocate_options, (uint64_t)nw_protocol_test_copy_options, (uint64_t)nw_protocol_test_deallocate_options);
  nw_protocol_definition_set_options_equality_check((void *)nw_protocol_copy_test_definition::test_definition, (uint64_t)nw_protocol_test_options_are_equal);
  v0 = (void *)nw_protocol_copy_test_definition::test_definition;

  nw_protocol_definition_set_metadata_allocator(v0, (uint64_t)nw_protocol_test_allocate_metadata, (uint64_t)nw_protocol_test_deallocate_metadata);
}

void nw_protocol_test_deallocate_metadata(nw_protocol_definition *a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

BOOL nw_protocol_test_allocate_metadata(nw_protocol_definition *a1)
{
  uint64_t v1 = malloc_type_calloc(1uLL, 4uLL, 0xEAFB8F1AuLL);
  if (v1) {
    return (BOOL)v1;
  }
  uint64_t v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  nw_endpoint_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_test_options_are_equal(nw_protocol_definition *a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] && a2[3] == a3[3] && a2[4] == a3[4] && a2[5] == a3[5];
}

void nw_protocol_test_deallocate_options(nw_protocol_definition *a1, void *a2)
{
  if (a2)
  {
    if (a2[4])
    {
      uint64_t v3 = (const void *)a2[3];
      if (v3) {
        _Block_release(v3);
      }
    }
    a2[3] = 0;
    if (a2[2])
    {
      nw_endpoint_t v4 = (const void *)a2[1];
      if (v4) {
        _Block_release(v4);
      }
    }
    free(a2);
  }
}

BOOL nw_protocol_test_copy_options(nw_protocol_definition *a1, void *a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v27 = "nw_protocol_test_copy_options";
    int v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v16, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          long long v27 = "nw_protocol_test_copy_options";
          char v19 = "%{public}s called with null existing_handle";
LABEL_31:
          _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v23 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)long long buf = 136446466;
            long long v27 = "nw_protocol_test_copy_options";
            __int16 v28 = 2082;
            uint64_t v29 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_32;
        }
        if (v23)
        {
          *(_DWORD *)long long buf = 136446210;
          long long v27 = "nw_protocol_test_copy_options";
          char v19 = "%{public}s called with null existing_handle, no backtrace";
          goto LABEL_31;
        }
      }
      else
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          long long v27 = "nw_protocol_test_copy_options";
          char v19 = "%{public}s called with null existing_handle, backtrace limit exceeded";
          goto LABEL_31;
        }
      }
    }
LABEL_32:
    if (v16) {
      free(v16);
    }
    return 0;
  }
  uint64_t v3 = malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
  if (v3) {
    goto LABEL_3;
  }
  uint64_t v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446722;
  long long v27 = "strict_calloc";
  __int16 v28 = 2048;
  uint64_t v29 = 1;
  __int16 v30 = 2048;
  uint64_t v31 = 48;
  os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
LABEL_3:
    v3[1] = 0u;
    v3[2] = 0u;
    _OWORD *v3 = 0u;
    *(void *)uint64_t v3 = *a2;
    nw_endpoint_t v4 = (const void *)a2[1];
    if (v4)
    {
      BOOL v5 = _Block_copy(v4);
      char v6 = *((unsigned char *)v3 + 16);
      if (v6)
      {
        size_t v7 = (const void *)*((void *)v3 + 1);
        if (v7)
        {
          _Block_release(v7);
          char v6 = *((unsigned char *)v3 + 16);
        }
      }
    }
    else
    {
      BOOL v5 = 0;
      char v6 = 0;
    }
    *((void *)v3 + 1) = v5;
    *((unsigned char *)v3 + 16) = v6 | 1;
    int v8 = (const void *)a2[3];
    if (v8)
    {
      int v9 = _Block_copy(v8);
      char v10 = *((unsigned char *)v3 + 32);
      if ((v10 & 1) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      int v9 = 0;
      char v10 = *((unsigned char *)v3 + 32);
      if ((v10 & 1) == 0)
      {
LABEL_14:
        *((void *)v3 + 3) = v9;
        *((unsigned char *)v3 + 32) = v10 | 1;
        *((_DWORD *)v3 + 10) = *((_DWORD *)a2 + 10);
        int v12 = *((unsigned char *)v3 + 44) & 0xFE | *((unsigned char *)a2 + 44) & 1;
        *((unsigned char *)v3 + 44) = v12;
        unsigned int v13 = v12 & 0xFFFFFFFD | (2 * ((*((unsigned __int8 *)a2 + 44) >> 1) & 1));
        *((unsigned char *)v3 + 44) = v13;
        unsigned int v14 = v13 & 0xFFFFFFFB | (4 * ((*((unsigned __int8 *)a2 + 44) >> 2) & 1));
        *((unsigned char *)v3 + 44) = v14;
        *((unsigned char *)v3 + 44) = v14 & 0xF7 | *((unsigned char *)a2 + 44) & 8;
        return (BOOL)v3;
      }
    }
    size_t v11 = (const void *)*((void *)v3 + 3);
    if (v11)
    {
      _Block_release(v11);
      char v10 = *((unsigned char *)v3 + 32);
    }
    goto LABEL_14;
  }
  __break(1u);
  return result;
}

BOOL nw_protocol_test_allocate_options(nw_protocol_definition *a1)
{
  uint64_t v1 = malloc_type_calloc(1uLL, 0x30uLL, 0xEAFB8F1AuLL);
  if (v1) {
    goto LABEL_2;
  }
  uint64_t v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  nw_endpoint_t v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
LABEL_2:
    v1[1] = 0u;
    v1[2] = 0u;
    _OWORD *v1 = 0u;
    return (BOOL)v1;
  }
  __break(1u);
  return result;
}

BOOL ___Z27nw_protocol_test_identifierv_block_invoke()
{
  qword_1E8F7A520 = 0;
  unk_1E8F7A528 = 0;
  unk_1E8F7A415 = 0;
  unk_1E8F7A425 = 0;
  unk_1E8F7A41D = 0;
  dword_1E8F7A42C = 0;
  strcpy((char *)&g_test_protocol_identifier, "test");
  qword_1E8F7A430 = 0x100000004;
  qword_1E8F7A448 = (uint64_t)nw_protocol_common_replace_input_handler;
  qword_1E8F7A4A8 = (uint64_t)nw_protocol_common_get_parameters;
  qword_1E8F7A4B0 = (uint64_t)nw_protocol_common_get_path;
  qword_1E8F7A4C0 = (uint64_t)nw_protocol_common_get_remote_endpoint;
  qword_1E8F7A4B8 = (uint64_t)nw_protocol_common_get_local_endpoint;
  qword_1E8F7A500 = (uint64_t)nw_protocol_common_get_output_local_endpoint;
  qword_1E8F7A508 = (uint64_t)nw_protocol_common_get_output_interface;
  qword_1E8F7A460 = (uint64_t)nw_protocol_common_connected;
  qword_1E8F7A458 = (uint64_t)nw_protocol_common_disconnect;
  qword_1E8F7A478 = (uint64_t)nw_protocol_common_input_available;
  qword_1E8F7A480 = (uint64_t)nw_protocol_common_output_available;
  qword_1E8F7A4F0 = (uint64_t)nw_protocol_common_input_finished;
  qword_1E8F7A540 = (uint64_t)nw_protocol_common_input_flush;
  qword_1E8F7A470 = (uint64_t)nw_protocol_common_error;
  qword_1E8F7A538 = (uint64_t)nw_protocol_common_reset;
  qword_1E8F7A518 = (uint64_t)nw_protocol_common_copy_info;
  qword_1E8F7A4E8 = (uint64_t)nw_protocol_common_supports_external_data;
  qword_1E8F7A510 = (uint64_t)nw_protocol_common_waiting_for_output;
  qword_1E8F7A4C8 = (uint64_t)nw_protocol_common_register_notification;
  qword_1E8F7A4D0 = (uint64_t)nw_protocol_common_unregister_notification;
  qword_1E8F7A4D8 = (uint64_t)nw_protocol_common_notify;
  qword_1E8F7A4E0 = (uint64_t)nw_protocol_common_updated_path;
  qword_1E8F7A4A0 = (uint64_t)nw_protocol_common_link_state;
  g_test_protocol_callbacks = (uint64_t)nw_protocol_test_add_input_handler;
  qword_1E8F7A440 = (uint64_t)nw_protocol_test_remove_input_handler;
  qword_1E8F7A488 = (uint64_t)nw_protocol_test_get_input_frames;
  qword_1E8F7A490 = (uint64_t)nw_protocol_test_get_output_frames;
  qword_1E8F7A498 = (uint64_t)nw_protocol_test_finalize_output_frames;
  qword_1E8F7A450 = (uint64_t)nw_protocol_test_connect;
  qword_1E8F7A468 = (uint64_t)nw_protocol_test_disconnected;
  qword_1E8F7A4F8 = (uint64_t)nw_protocol_test_output_finished;
  qword_1E8F7A530 = (uint64_t)nw_protocol_test_get_message_properties;
  return nw_protocol_register_extended(&g_test_protocol_identifier, (uint64_t)nw_protocol_test_create);
}

uint64_t nw_protocol_test_create(const nw_protocol_identifier *a1, nw_endpoint *a2, nw_parameters *a3)
{
  uint64_t v3 = nw_protocol_new(120, (uint64_t)a3, (uint64_t)&g_test_protocol_identifier, (uint64_t)&g_test_protocol_callbacks);
  *(void *)uint64_t v3 = 0;
  *(void *)(v3 + 8) = 0;
  *(unsigned char *)(v3 + 117) &= 0xFCu;
  *(void *)(v3 + 16) = v3 + 8;
  *(unsigned char *)(v3 + 116) = 0;
  return v3 - 96;
}

void nw_protocol_test_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_get_message_properties";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v24, &type, &v81)) {
      goto LABEL_89;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v81)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v70 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v70)
          {
            *(_DWORD *)long long buf = 136446466;
            int v84 = "nw_protocol_test_get_message_properties";
            __int16 v85 = 2082;
            BOOL v86 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
        }
        else if (v70)
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_get_message_properties";
          long long v27 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_get_message_properties";
          long long v27 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
      goto LABEL_89;
    }
    long long v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_89;
    }
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_get_message_properties";
    long long v27 = "%{public}s called with null protocol";
LABEL_88:
    _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0xCu);
    goto LABEL_89;
  }
  if (*(_UNKNOWN **)(a1 + 40) != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_get_message_properties";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v24, &type, &v81)) {
      goto LABEL_89;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v81)
      {
        long long v40 = (char *)__nw_create_backtrace_string();
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v71 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v71)
          {
            *(_DWORD *)long long buf = 136446466;
            int v84 = "nw_protocol_test_get_message_properties";
            __int16 v85 = 2082;
            BOOL v86 = v40;
            long long v42 = "%{public}s called with null test, dumping backtrace:%{public}s";
            goto LABEL_63;
          }
LABEL_64:
          free(v40);
          if (!v24) {
            return;
          }
          goto LABEL_90;
        }
        if (v71)
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_get_message_properties";
          long long v27 = "%{public}s called with null test, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_get_message_properties";
          long long v27 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
      goto LABEL_89;
    }
    long long v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_89;
    }
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_get_message_properties";
    long long v27 = "%{public}s called with null test";
    goto LABEL_88;
  }
  if (!a3) {
    return;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if (v5)
  {
    uint64_t v6 = *(void *)(v5 + 24);
    if (v6)
    {
      size_t v7 = *(void (**)(uint64_t, uint64_t, uint64_t))(v6 + 248);
      int v8 = &nw_protocol_ref_counted_handle;
      if (v7)
      {
        int v9 = *(void **)(v5 + 40);
        if (v9 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v10 = *(void *)(v5 + 88);
          if (v10) {
            *(void *)(v5 + 88) = v10 + 1;
          }
        }
        uint64_t v11 = *(void *)(a1 + 88);
        if (v11) {
          *(void *)(a1 + 88) = v11 + 1;
        }
        v7(v5, a1, a3);
        if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v28 = *(void *)(a1 + 88);
          if (v28)
          {
            uint64_t v29 = v28 - 1;
            *(void *)(a1 + 88) = v29;
            if (!v29)
            {
              __int16 v30 = *(void (***)(void))(a1 + 64);
              if (v30)
              {
                *(void *)(a1 + 64) = 0;
                v30[2](v30);
                _Block_release(v30);
              }
              if (*(unsigned char *)(a1 + 72))
              {
                uint64_t v31 = *(const void **)(a1 + 64);
                if (v31) {
                  _Block_release(v31);
                }
              }
              free((void *)a1);
            }
          }
        }
        if (v9 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v51 = *(void *)(v5 + 88);
          if (v51)
          {
            uint64_t v52 = v51 - 1;
            *(void *)(v5 + 88) = v52;
            if (!v52)
            {
              long long v53 = *(void (***)(void))(v5 + 64);
              if (v53)
              {
                *(void *)(v5 + 64) = 0;
                v53[2](v53);
                _Block_release(v53);
              }
              if (*(unsigned char *)(v5 + 72))
              {
                long long v54 = *(const void **)(v5 + 64);
                if (v54) {
                  _Block_release(v54);
                }
              }
              free((void *)v5);
            }
          }
        }
        int v8 = *(void **)(a1 + 40);
      }
    }
    else
    {
      int v8 = &nw_protocol_ref_counted_handle;
    }
  }
  else
  {
    int v8 = &nw_protocol_ref_counted_handle;
  }
  v76[0] = MEMORY[0x1E4F143A8];
  v76[1] = 0x40000000;
  int v77 = ___ZL39nw_protocol_test_get_message_propertiesP11nw_protocolS0_P30nw_protocol_message_properties_block_invoke;
  uint64_t v78 = &__block_descriptor_tmp_45_85400;
  uint64_t v79 = a1 + 96;
  uint64_t v80 = a3;
  if (v8 != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_access_options";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v24, &type, &v81)) {
      goto LABEL_89;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (v81)
      {
        long long v40 = (char *)__nw_create_backtrace_string();
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v72 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v72)
          {
            *(_DWORD *)long long buf = 136446466;
            int v84 = "nw_protocol_test_access_options";
            __int16 v85 = 2082;
            BOOL v86 = v40;
            long long v42 = "%{public}s called with null test, dumping backtrace:%{public}s";
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        if (v72)
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v27 = "%{public}s called with null test, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v27 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
      goto LABEL_89;
    }
    long long v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    if (!os_log_type_enabled(v25, type)) {
      goto LABEL_89;
    }
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_access_options";
    long long v27 = "%{public}s called with null test";
    goto LABEL_88;
  }
  uint64_t v12 = *(void *)(a1 + 88);
  if (v12) {
    *(void *)(a1 + 88) = v12 + 1;
  }
  uint64_t v13 = *(void *)(a1 + 24);
  if (v13)
  {
    unsigned int v14 = *(uint64_t (**)(uint64_t))(v13 + 112);
    if (v14)
    {
      os_log_type_t v15 = (void *)v14(a1);
      goto LABEL_22;
    }
  }
  __nwlog_obj();
  long long v60 = *(const char **)(a1 + 16);
  *(_DWORD *)long long buf = 136446722;
  int v84 = "__nw_protocol_get_parameters";
  if (!v60) {
    long long v60 = "invalid";
  }
  __int16 v85 = 2082;
  BOOL v86 = (void *)v60;
  __int16 v87 = 2048;
  uint64_t v88 = a1;
  long long v61 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v81 = 0;
  if (__nwlog_fault(v61, &type, &v81))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v62, type))
      {
        uint64_t v64 = *(const char **)(a1 + 16);
        if (!v64) {
          uint64_t v64 = "invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        int v84 = "__nw_protocol_get_parameters";
        __int16 v85 = 2082;
        BOOL v86 = (void *)v64;
        __int16 v87 = 2048;
        uint64_t v88 = a1;
        int v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_173:
        _os_log_impl(&dword_1830D4000, v62, v63, v65, buf, 0x20u);
      }
    }
    else if (v81)
    {
      uint64_t v66 = (char *)__nw_create_backtrace_string();
      long long v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      BOOL v67 = os_log_type_enabled(v62, type);
      if (v66)
      {
        if (v67)
        {
          BOOL v68 = *(const char **)(a1 + 16);
          if (!v68) {
            BOOL v68 = "invalid";
          }
          *(_DWORD *)long long buf = 136446978;
          int v84 = "__nw_protocol_get_parameters";
          __int16 v85 = 2082;
          BOOL v86 = (void *)v68;
          __int16 v87 = 2048;
          uint64_t v88 = a1;
          __int16 v89 = 2082;
          int v90 = v66;
          _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v66);
        goto LABEL_174;
      }
      if (v67)
      {
        unsigned int v75 = *(const char **)(a1 + 16);
        if (!v75) {
          unsigned int v75 = "invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        int v84 = "__nw_protocol_get_parameters";
        __int16 v85 = 2082;
        BOOL v86 = (void *)v75;
        __int16 v87 = 2048;
        uint64_t v88 = a1;
        int v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
        goto LABEL_173;
      }
    }
    else
    {
      long long v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v62, type))
      {
        BOOL v74 = *(const char **)(a1 + 16);
        if (!v74) {
          BOOL v74 = "invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        int v84 = "__nw_protocol_get_parameters";
        __int16 v85 = 2082;
        BOOL v86 = (void *)v74;
        __int16 v87 = 2048;
        uint64_t v88 = a1;
        int v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
        goto LABEL_173;
      }
    }
  }
LABEL_174:
  if (v61) {
    free(v61);
  }
  os_log_type_t v15 = 0;
LABEL_22:
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    uint64_t v20 = *(void *)(a1 + 88);
    if (v20)
    {
      uint64_t v21 = v20 - 1;
      *(void *)(a1 + 88) = v21;
      if (!v21)
      {
        uint64_t v22 = *(void (***)(void))(a1 + 64);
        if (v22)
        {
          *(void *)(a1 + 64) = 0;
          v22[2](v22);
          _Block_release(v22);
        }
        if (*(unsigned char *)(a1 + 72))
        {
          BOOL v23 = *(const void **)(a1 + 64);
          if (v23) {
            _Block_release(v23);
          }
        }
        free((void *)a1);
      }
    }
  }
  if (!v15)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_access_options";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (__nwlog_fault(v24, &type, &v81))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v27 = "%{public}s called with null parameters";
          goto LABEL_88;
        }
      }
      else if (v81)
      {
        long long v40 = (char *)__nw_create_backtrace_string();
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        BOOL v73 = os_log_type_enabled(v25, type);
        if (v40)
        {
          if (v73)
          {
            *(_DWORD *)long long buf = 136446466;
            int v84 = "nw_protocol_test_access_options";
            __int16 v85 = 2082;
            BOOL v86 = v40;
            long long v42 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
            goto LABEL_63;
          }
          goto LABEL_64;
        }
        if (v73)
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v27 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_88;
        }
      }
      else
      {
        long long v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v27 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_88;
        }
      }
    }
LABEL_89:
    if (!v24) {
      return;
    }
LABEL_90:
    free(v24);
    return;
  }
  if (nw_protocol_copy_test_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_85364);
  }
  if (!nw_protocol_copy_test_definition::test_definition
    || (int v16 = (atomic_uchar *)os_retain((void *)nw_protocol_copy_test_definition::test_definition)) == 0)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_access_options";
    char v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v24, &type, &v81)) {
      goto LABEL_89;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)long long buf = 136446210;
      int v84 = "nw_protocol_test_access_options";
      long long v27 = "%{public}s called with null definition";
      goto LABEL_88;
    }
    if (!v81)
    {
      long long v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_89;
      }
      *(_DWORD *)long long buf = 136446210;
      int v84 = "nw_protocol_test_access_options";
      long long v27 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_88;
    }
    long long v40 = (char *)__nw_create_backtrace_string();
    long long v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v41 = os_log_type_enabled(v25, type);
    if (!v40)
    {
      if (!v41) {
        goto LABEL_89;
      }
      *(_DWORD *)long long buf = 136446210;
      int v84 = "nw_protocol_test_access_options";
      long long v27 = "%{public}s called with null definition, no backtrace";
      goto LABEL_88;
    }
    if (v41)
    {
      *(_DWORD *)long long buf = 136446466;
      int v84 = "nw_protocol_test_access_options";
      __int16 v85 = 2082;
      BOOL v86 = v40;
      long long v42 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_63:
      _os_log_impl(&dword_1830D4000, v25, v26, v42, buf, 0x16u);
      goto LABEL_64;
    }
    goto LABEL_64;
  }
  uint64_t v17 = v16;
  os_log_type_t v18 = nw_parameters_copy_protocol_options_for_definition(v15, v16);
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_access_options";
    uint64_t v32 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (__nwlog_fault(v32, &type, &v81))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v35 = "%{public}s Failed to copy protocol options";
LABEL_93:
          long long v55 = v33;
          os_log_type_t v56 = v34;
LABEL_94:
          _os_log_impl(&dword_1830D4000, v55, v56, v35, buf, 0xCu);
        }
      }
      else if (v81)
      {
        long long v43 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v44 = gLogObj;
        os_log_type_t v45 = type;
        BOOL v46 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v43)
        {
          if (v46)
          {
            *(_DWORD *)long long buf = 136446466;
            int v84 = "nw_protocol_test_access_options";
            __int16 v85 = 2082;
            BOOL v86 = v43;
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v43);
          goto LABEL_95;
        }
        if (v46)
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v35 = "%{public}s Failed to copy protocol options, no backtrace";
          long long v55 = v44;
          os_log_type_t v56 = v45;
          goto LABEL_94;
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v33 = gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v84 = "nw_protocol_test_access_options";
          long long v35 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
          goto LABEL_93;
        }
      }
    }
LABEL_95:
    if (v32) {
      free(v32);
    }
    long long v57 = v17;
    goto LABEL_105;
  }
  char v19 = v18;
  if (!nw_protocol_options_is_test_protocol(v18))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446210;
    int v84 = "nw_protocol_test_access_options";
    long long v36 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v81 = 0;
    if (!__nwlog_fault(v36, &type, &v81)) {
      goto LABEL_102;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v37 = gLogObj;
      os_log_type_t v38 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_102;
      }
      *(_DWORD *)long long buf = 136446210;
      int v84 = "nw_protocol_test_access_options";
      long long v39 = "%{public}s Failed to copy test protocol options";
    }
    else
    {
      if (v81)
      {
        long long v47 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        long long v48 = gLogObj;
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (v47)
        {
          if (v50)
          {
            *(_DWORD *)long long buf = 136446466;
            int v84 = "nw_protocol_test_access_options";
            __int16 v85 = 2082;
            BOOL v86 = v47;
            _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v47);
          goto LABEL_102;
        }
        if (!v50)
        {
LABEL_102:
          if (v36) {
            free(v36);
          }
          goto LABEL_104;
        }
        *(_DWORD *)long long buf = 136446210;
        int v84 = "nw_protocol_test_access_options";
        long long v39 = "%{public}s Failed to copy test protocol options, no backtrace";
        long long v58 = v48;
        os_log_type_t v59 = v49;
LABEL_101:
        _os_log_impl(&dword_1830D4000, v58, v59, v39, buf, 0xCu);
        goto LABEL_102;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v37 = gLogObj;
      os_log_type_t v38 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_102;
      }
      *(_DWORD *)long long buf = 136446210;
      int v84 = "nw_protocol_test_access_options";
      long long v39 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
    }
    long long v58 = v37;
    os_log_type_t v59 = v38;
    goto LABEL_101;
  }
  v77((uint64_t)v76, v19);
LABEL_104:
  os_release(v17);
  long long v57 = v19;
LABEL_105:
  os_release(v57);
}

uint64_t ___ZL39nw_protocol_test_get_message_propertiesP11nw_protocolS0_P30nw_protocol_message_properties_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int v19 = 0;
  __int16 v18 = 0;
  unsigned __int8 v17 = 0;
  if (nw_protocol_options_is_test_protocol(a2))
  {
    *(void *)uint64_t v28 = 0;
    *(void *)&v28[8] = v28;
    *(void *)&v28[16] = 0x2000000000;
    char v29 = 0;
    *(void *)long long buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 0x40000000;
    *(void *)&buf[16] = ___ZL47nw_protocol_test_options_get_message_propertiesP19nw_protocol_optionsPjPbS2_S2__block_invoke;
    *(void *)&long long v23 = &unk_1E524ADF0;
    *((void *)&v23 + 1) = v28;
    char v24 = &v19;
    long long v25 = (char *)&v18 + 1;
    os_log_type_t v26 = &v18;
    long long v27 = &v17;
    nw_protocol_options_access_handle(a2, buf);
    int v4 = *(unsigned __int8 *)(*(void *)&v28[8] + 24);
    _Block_object_dispose(v28, 8);
    if (v4)
    {
      if (gLogDatapath)
      {
        uint64_t v12 = __nwlog_obj();
        if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v13 = *(void *)(a1 + 32);
          if (v13) {
            unsigned int v14 = (const char *)(v13 + 32);
          }
          else {
            unsigned int v14 = "";
          }
          *(_DWORD *)long long buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_message_properties_block_invoke";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v14;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v23) = v19;
          WORD2(v23) = 1024;
          *(_DWORD *)((char *)&v23 + 6) = HIBYTE(v18);
          WORD5(v23) = 1024;
          HIDWORD(v23) = v18;
          LOWORD(v24) = 1024;
          *(_DWORD *)((char *)&v24 + 2) = v17;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s setting maximum_message_size %u, frame_as_message %{BOOL}d, allow_discontiguous_messages %{BOOL}d, receive_single_message %{BOOL}d", buf, 0x2Eu);
        }
      }
      uint64_t v5 = *(_DWORD **)(a1 + 40);
      unsigned int v6 = v5[1] & 0xFFFFFFFE | HIBYTE(v18);
      *uint64_t v5 = v19;
      v5[1] = v6;
      *(_DWORD *)(*(void *)(a1 + 40) + 4) = *(_DWORD *)(*(void *)(a1 + 40) + 4) & 0xFFFFFFFD | (2 * v18);
      *(_DWORD *)(*(void *)(a1 + 40) + 4) = *(_DWORD *)(*(void *)(a1 + 40) + 4) & 0xFFFFFFFB | (4 * v17);
    }
    return 1;
  }
  __nwlog_obj();
  *(_DWORD *)uint64_t v28 = 136446210;
  *(void *)&v28[4] = "nw_protocol_test_options_get_message_properties";
  int v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v8, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)uint64_t v28 = 136446210;
      *(void *)&v28[4] = "nw_protocol_test_options_get_message_properties";
      uint64_t v11 = "%{public}s protocol options are not test protocol";
      goto LABEL_24;
    }
    if (!v20)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_25;
      }
      *(_DWORD *)uint64_t v28 = 136446210;
      *(void *)&v28[4] = "nw_protocol_test_options_get_message_properties";
      uint64_t v11 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
      goto LABEL_24;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v16 = os_log_type_enabled(v9, type);
    if (backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)uint64_t v28 = 136446466;
        *(void *)&v28[4] = "nw_protocol_test_options_get_message_properties";
        *(_WORD *)&v28[12] = 2082;
        *(void *)&v28[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", v28, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_25;
    }
    if (v16)
    {
      *(_DWORD *)uint64_t v28 = 136446210;
      *(void *)&v28[4] = "nw_protocol_test_options_get_message_properties";
      uint64_t v11 = "%{public}s protocol options are not test protocol, no backtrace";
LABEL_24:
      _os_log_impl(&dword_1830D4000, v9, v10, v11, v28, 0xCu);
    }
  }
LABEL_25:
  if (v8) {
    free(v8);
  }
  return 1;
}

BOOL nw_protocol_options_is_test_protocol(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = a1;
    id v2 = v1[1];

    if (nw_protocol_copy_test_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_85364);
    }
    if (nw_protocol_copy_test_definition::test_definition) {
      uint64_t v3 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
    }
    else {
      uint64_t v3 = 0;
    }
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v2, (uint64_t)v3);
    if (v2) {
      os_release(v2);
    }
    if (v3) {
      os_release(v3);
    }
    return is_equal_unsafe;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  os_log_type_t v15 = "nw_protocol_options_is_test_protocol";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_test_protocol";
        int v9 = "%{public}s called with null options";
LABEL_25:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v15 = "nw_protocol_options_is_test_protocol";
          __int16 v16 = 2082;
          unsigned __int8 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (v11)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_test_protocol";
        int v9 = "%{public}s called with null options, no backtrace";
        goto LABEL_25;
      }
    }
    else
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_test_protocol";
        int v9 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
  }
LABEL_26:
  if (v6) {
    free(v6);
  }
  return 0;
}

uint64_t ___ZL47nw_protocol_test_options_get_message_propertiesP19nw_protocol_optionsPjPbS2_S2__block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 44) & 1;
  if (*(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24))
  {
    id v2 = *(BOOL **)(a1 + 48);
    **(_DWORD **)(a1 + 40) = *(_DWORD *)(a2 + 40);
    BOOL *v2 = (*(unsigned char *)(a2 + 44) & 2) != 0;
    uint64_t v3 = *(BOOL **)(a1 + 64);
    **(unsigned char **)(a1 + 56) = (*(unsigned char *)(a2 + 44) & 4) != 0;
    BOOL *v3 = (*(unsigned char *)(a2 + 44) & 8) != 0;
  }
  return 1;
}

void nw_protocol_test_output_finished(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v104 = "nw_protocol_test_output_finished";
    BOOL v72 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v101 = 0;
    if (!__nwlog_fault(v72, &type, &v101)) {
      goto LABEL_233;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_233;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_output_finished";
      unsigned int v75 = "%{public}s called with null protocol";
    }
    else if (v101)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      BOOL v84 = os_log_type_enabled(v73, type);
      if (backtrace_string)
      {
        if (v84)
        {
          *(_DWORD *)long long buf = 136446466;
          int v104 = "nw_protocol_test_output_finished";
          __int16 v105 = 2082;
          int v106 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_233:
        if (!v72) {
          return;
        }
        goto LABEL_234;
      }
      if (!v84) {
        goto LABEL_233;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_output_finished";
      unsigned int v75 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_233;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_output_finished";
      unsigned int v75 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_232;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v104 = "nw_protocol_test_output_finished";
    BOOL v72 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v101 = 0;
    if (!__nwlog_fault(v72, &type, &v101)) {
      goto LABEL_233;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v101)
      {
        BOOL v73 = __nwlog_obj();
        os_log_type_t v74 = type;
        if (!os_log_type_enabled(v73, type)) {
          goto LABEL_233;
        }
        *(_DWORD *)long long buf = 136446210;
        int v104 = "nw_protocol_test_output_finished";
        unsigned int v75 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_232;
      }
      __int16 v85 = (char *)__nw_create_backtrace_string();
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      BOOL v86 = os_log_type_enabled(v73, type);
      if (!v85)
      {
        if (!v86) {
          goto LABEL_233;
        }
        *(_DWORD *)long long buf = 136446210;
        int v104 = "nw_protocol_test_output_finished";
        unsigned int v75 = "%{public}s called with null test, no backtrace";
        goto LABEL_232;
      }
      if (v86)
      {
        *(_DWORD *)long long buf = 136446466;
        int v104 = "nw_protocol_test_output_finished";
        __int16 v105 = 2082;
        int v106 = (nw_protocol *)v85;
        __int16 v87 = "%{public}s called with null test, dumping backtrace:%{public}s";
LABEL_184:
        _os_log_impl(&dword_1830D4000, v73, v74, v87, buf, 0x16u);
      }
LABEL_185:
      free(v85);
      if (!v72) {
        return;
      }
LABEL_234:
      os_log_type_t v59 = (nw_protocol *)v72;
LABEL_109:
      free(v59);
      return;
    }
    BOOL v73 = __nwlog_obj();
    os_log_type_t v74 = type;
    if (!os_log_type_enabled(v73, type)) {
      goto LABEL_233;
    }
    *(_DWORD *)long long buf = 136446210;
    int v104 = "nw_protocol_test_output_finished";
    unsigned int v75 = "%{public}s called with null test";
LABEL_232:
    _os_log_impl(&dword_1830D4000, v73, v74, v75, buf, 0xCu);
    goto LABEL_233;
  }
  if (gLogDatapath)
  {
    int v76 = __nwlog_obj();
    if (os_log_type_enabled(v76, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      int v104 = "nw_protocol_test_output_finished";
      __int16 v105 = 2082;
      int v106 = a1 + 2;
      _os_log_impl(&dword_1830D4000, v76, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s output_finished", buf, 0x16u);
    }
  }
  v96[0] = MEMORY[0x1E4F143A8];
  v96[1] = 0x40000000;
  char v97 = ___ZL32nw_protocol_test_output_finishedP11nw_protocolS0__block_invoke;
  uint64_t v98 = &__block_descriptor_tmp_44_85458;
  char v99 = a1;
  uint64_t v100 = a2;
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v104 = "nw_protocol_test_access_options";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v101 = 0;
    if (__nwlog_fault(v16, &type, &v101))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned __int8 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v104 = "nw_protocol_test_access_options";
          int v19 = "%{public}s called with null test";
LABEL_60:
          _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
        }
      }
      else if (v101)
      {
        uint64_t v88 = (char *)__nw_create_backtrace_string();
        unsigned __int8 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v89 = os_log_type_enabled(v17, type);
        if (v88)
        {
          if (v89)
          {
            *(_DWORD *)long long buf = 136446466;
            int v104 = "nw_protocol_test_access_options";
            __int16 v105 = 2082;
            int v106 = (nw_protocol *)v88;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null test, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v88);
        }
        else if (v89)
        {
          *(_DWORD *)long long buf = 136446210;
          int v104 = "nw_protocol_test_access_options";
          int v19 = "%{public}s called with null test, no backtrace";
          goto LABEL_60;
        }
      }
      else
      {
        unsigned __int8 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          int v104 = "nw_protocol_test_access_options";
          int v19 = "%{public}s called with null test, backtrace limit exceeded";
          goto LABEL_60;
        }
      }
    }
LABEL_61:
    if (!v16) {
      goto LABEL_78;
    }
    goto LABEL_62;
  }
  callbacks = a1[1].callbacks;
  if (callbacks) {
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  uint64_t v5 = a1->callbacks;
  if (v5)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v5->get_parameters;
    if (get_parameters)
    {
      size_t v7 = (void *)get_parameters(a1);
      goto LABEL_10;
    }
  }
  __nwlog_obj();
  identifier = a1->identifier;
  *(_DWORD *)long long buf = 136446722;
  int v104 = "__nw_protocol_get_parameters";
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  __int16 v105 = 2082;
  int v106 = (nw_protocol *)identifier;
  __int16 v107 = 2048;
  int v108 = a1;
  long long v61 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v101 = 0;
  if (__nwlog_fault(v61, &type, &v101))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v62, type))
      {
        uint64_t v64 = a1->identifier;
        if (!v64) {
          uint64_t v64 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        int v104 = "__nw_protocol_get_parameters";
        __int16 v105 = 2082;
        int v106 = (nw_protocol *)v64;
        __int16 v107 = 2048;
        int v108 = a1;
        int v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_203:
        _os_log_impl(&dword_1830D4000, v62, v63, v65, buf, 0x20u);
      }
    }
    else if (v101)
    {
      int v77 = (char *)__nw_create_backtrace_string();
      long long v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      BOOL v78 = os_log_type_enabled(v62, type);
      if (v77)
      {
        if (v78)
        {
          uint64_t v79 = a1->identifier;
          if (!v79) {
            uint64_t v79 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)long long buf = 136446978;
          int v104 = "__nw_protocol_get_parameters";
          __int16 v105 = 2082;
          int v106 = (nw_protocol *)v79;
          __int16 v107 = 2048;
          int v108 = a1;
          __int16 v109 = 2082;
          uint64_t v110 = v77;
          _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v77);
        goto LABEL_204;
      }
      if (v78)
      {
        int v94 = a1->identifier;
        if (!v94) {
          int v94 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        int v104 = "__nw_protocol_get_parameters";
        __int16 v105 = 2082;
        int v106 = (nw_protocol *)v94;
        __int16 v107 = 2048;
        int v108 = a1;
        int v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
        goto LABEL_203;
      }
    }
    else
    {
      long long v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v62, type))
      {
        os_log_type_t v92 = a1->identifier;
        if (!v92) {
          os_log_type_t v92 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        int v104 = "__nw_protocol_get_parameters";
        __int16 v105 = 2082;
        int v106 = (nw_protocol *)v92;
        __int16 v107 = 2048;
        int v108 = a1;
        int v65 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
        goto LABEL_203;
      }
    }
  }
LABEL_204:
  if (v61) {
    free(v61);
  }
  size_t v7 = 0;
LABEL_10:
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    char v12 = a1[1].callbacks;
    if (v12)
    {
      uint64_t v13 = (nw_protocol_callbacks *)((char *)v12 - 1);
      a1[1].callbacks = v13;
      if (!v13)
      {
        unsigned int v14 = *(void (***)(void))a1[1].flow_id;
        if (v14)
        {
          *(void *)a1[1].flow_id = 0;
          v14[2](v14);
          _Block_release(v14);
        }
        if (a1[1].flow_id[8])
        {
          os_log_type_t v15 = *(const void **)a1[1].flow_id;
          if (v15) {
            _Block_release(v15);
          }
        }
        free(a1);
      }
    }
  }
  if (v7)
  {
    if (nw_protocol_copy_test_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_85364);
    }
    if (nw_protocol_copy_test_definition::test_definition)
    {
      os_log_type_t v8 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
      if (v8)
      {
        int v9 = v8;
        os_log_type_t v10 = nw_parameters_copy_protocol_options_for_definition(v7, v8);
        if (v10)
        {
          BOOL v11 = v10;
          if (nw_protocol_options_is_test_protocol(v10))
          {
            v97((uint64_t)v96, v11);
LABEL_76:
            os_release(v9);
            BOOL v41 = v11;
LABEL_77:
            os_release(v41);
            goto LABEL_78;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)long long buf = 136446210;
          int v104 = "nw_protocol_test_access_options";
          char v24 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v101 = 0;
          if (__nwlog_fault(v24, &type, &v101))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v25 = gLogObj;
              os_log_type_t v26 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_74;
              }
              *(_DWORD *)long long buf = 136446210;
              int v104 = "nw_protocol_test_access_options";
              long long v27 = "%{public}s Failed to copy test protocol options";
LABEL_72:
              long long v42 = v25;
              os_log_type_t v43 = v26;
LABEL_73:
              _os_log_impl(&dword_1830D4000, v42, v43, v27, buf, 0xCu);
              goto LABEL_74;
            }
            if (!v101)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              uint64_t v25 = gLogObj;
              os_log_type_t v26 = type;
              if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
                goto LABEL_74;
              }
              *(_DWORD *)long long buf = 136446210;
              int v104 = "nw_protocol_test_access_options";
              long long v27 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
              goto LABEL_72;
            }
            long long v35 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            long long v36 = gLogObj;
            os_log_type_t v37 = type;
            BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v35)
            {
              if (v38)
              {
                *(_DWORD *)long long buf = 136446466;
                int v104 = "nw_protocol_test_access_options";
                __int16 v105 = 2082;
                int v106 = (nw_protocol *)v35;
                _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v35);
              goto LABEL_74;
            }
            if (v38)
            {
              *(_DWORD *)long long buf = 136446210;
              int v104 = "nw_protocol_test_access_options";
              long long v27 = "%{public}s Failed to copy test protocol options, no backtrace";
              long long v42 = v36;
              os_log_type_t v43 = v37;
              goto LABEL_73;
            }
          }
LABEL_74:
          if (v24) {
            free(v24);
          }
          goto LABEL_76;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)long long buf = 136446210;
        int v104 = "nw_protocol_test_access_options";
        char v20 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v101 = 0;
        if (__nwlog_fault(v20, &type, &v101))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v21 = gLogObj;
            os_log_type_t v22 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)long long buf = 136446210;
              int v104 = "nw_protocol_test_access_options";
              long long v23 = "%{public}s Failed to copy protocol options";
LABEL_65:
              long long v39 = v21;
              os_log_type_t v40 = v22;
LABEL_66:
              _os_log_impl(&dword_1830D4000, v39, v40, v23, buf, 0xCu);
            }
          }
          else if (v101)
          {
            uint64_t v31 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v32 = gLogObj;
            os_log_type_t v33 = type;
            BOOL v34 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (v31)
            {
              if (v34)
              {
                *(_DWORD *)long long buf = 136446466;
                int v104 = "nw_protocol_test_access_options";
                __int16 v105 = 2082;
                int v106 = (nw_protocol *)v31;
                _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
              }
              free(v31);
              goto LABEL_67;
            }
            if (v34)
            {
              *(_DWORD *)long long buf = 136446210;
              int v104 = "nw_protocol_test_access_options";
              long long v23 = "%{public}s Failed to copy protocol options, no backtrace";
              long long v39 = v32;
              os_log_type_t v40 = v33;
              goto LABEL_66;
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v21 = gLogObj;
            os_log_type_t v22 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)long long buf = 136446210;
              int v104 = "nw_protocol_test_access_options";
              long long v23 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
              goto LABEL_65;
            }
          }
        }
LABEL_67:
        if (v20) {
          free(v20);
        }
        BOOL v41 = (atomic_uchar *)v9;
        goto LABEL_77;
      }
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v104 = "nw_protocol_test_access_options";
    __int16 v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v101 = 0;
    if (!__nwlog_fault(v16, &type, &v101)) {
      goto LABEL_61;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned __int8 v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_access_options";
      int v19 = "%{public}s called with null definition";
      goto LABEL_60;
    }
    if (!v101)
    {
      unsigned __int8 v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_61;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_access_options";
      int v19 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_60;
    }
    uint64_t v28 = (char *)__nw_create_backtrace_string();
    unsigned __int8 v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v29 = os_log_type_enabled(v17, type);
    if (!v28)
    {
      if (!v29) {
        goto LABEL_61;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_access_options";
      int v19 = "%{public}s called with null definition, no backtrace";
      goto LABEL_60;
    }
    if (v29)
    {
      *(_DWORD *)long long buf = 136446466;
      int v104 = "nw_protocol_test_access_options";
      __int16 v105 = 2082;
      int v106 = (nw_protocol *)v28;
      uint64_t v30 = "%{public}s called with null definition, dumping backtrace:%{public}s";
LABEL_43:
      _os_log_impl(&dword_1830D4000, v17, v18, v30, buf, 0x16u);
      goto LABEL_44;
    }
    goto LABEL_44;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  int v104 = "nw_protocol_test_access_options";
  __int16 v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v101 = 0;
  if (!__nwlog_fault(v16, &type, &v101)) {
    goto LABEL_61;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned __int8 v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_access_options";
      int v19 = "%{public}s called with null parameters";
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  if (!v101)
  {
    unsigned __int8 v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v17, type))
    {
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_access_options";
      int v19 = "%{public}s called with null parameters, backtrace limit exceeded";
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  uint64_t v28 = (char *)__nw_create_backtrace_string();
  unsigned __int8 v17 = __nwlog_obj();
  os_log_type_t v18 = type;
  BOOL v91 = os_log_type_enabled(v17, type);
  if (!v28)
  {
    if (v91)
    {
      *(_DWORD *)long long buf = 136446210;
      int v104 = "nw_protocol_test_access_options";
      int v19 = "%{public}s called with null parameters, no backtrace";
      goto LABEL_60;
    }
    goto LABEL_61;
  }
  if (v91)
  {
    *(_DWORD *)long long buf = 136446466;
    int v104 = "nw_protocol_test_access_options";
    __int16 v105 = 2082;
    int v106 = (nw_protocol *)v28;
    uint64_t v30 = "%{public}s called with null parameters, dumping backtrace:%{public}s";
    goto LABEL_43;
  }
LABEL_44:
  free(v28);
  if (v16) {
LABEL_62:
  }
    free(v16);
LABEL_78:
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    int v104 = "__nw_protocol_output_finished";
    BOOL v72 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v101 = 0;
    if (!__nwlog_fault(v72, &type, &v101)) {
      goto LABEL_233;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_233;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "__nw_protocol_output_finished";
      unsigned int v75 = "%{public}s called with null protocol";
      goto LABEL_232;
    }
    if (!v101)
    {
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (!os_log_type_enabled(v73, type)) {
        goto LABEL_233;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "__nw_protocol_output_finished";
      unsigned int v75 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_232;
    }
    __int16 v85 = (char *)__nw_create_backtrace_string();
    BOOL v73 = __nwlog_obj();
    os_log_type_t v74 = type;
    BOOL v90 = os_log_type_enabled(v73, type);
    if (!v85)
    {
      if (!v90) {
        goto LABEL_233;
      }
      *(_DWORD *)long long buf = 136446210;
      int v104 = "__nw_protocol_output_finished";
      unsigned int v75 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_232;
    }
    if (v90)
    {
      *(_DWORD *)long long buf = 136446466;
      int v104 = "__nw_protocol_output_finished";
      __int16 v105 = 2082;
      int v106 = (nw_protocol *)v85;
      __int16 v87 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_184;
    }
    goto LABEL_185;
  }
  uint64_t handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v46 = output_handler[1].callbacks;
    if (v46) {
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v46->add_input_handler + 1);
    }
  }
  long long v47 = a1->handle;
  if (v47 == &nw_protocol_ref_counted_handle)
  {
    long long v48 = a1[1].callbacks;
    if (v48) {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v48->add_input_handler + 1);
    }
  }
  os_log_type_t v49 = output_handler->callbacks;
  if (v49)
  {
    output_finished = (void (*)(nw_protocol *, nw_protocol *))v49->output_finished;
    if (output_finished)
    {
      output_finished(output_handler, a1);
      goto LABEL_88;
    }
  }
  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)long long buf = 136446722;
  int v104 = "__nw_protocol_output_finished";
  if (!name) {
    name = "invalid";
  }
  __int16 v105 = 2082;
  int v106 = (nw_protocol *)name;
  __int16 v107 = 2048;
  int v108 = output_handler;
  BOOL v67 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v101 = 0;
  if (__nwlog_fault(v67, &type, &v101))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v68 = __nwlog_obj();
      os_log_type_t v69 = type;
      if (!os_log_type_enabled(v68, type)) {
        goto LABEL_212;
      }
      BOOL v70 = output_handler->identifier->name;
      if (!v70) {
        BOOL v70 = "invalid";
      }
      *(_DWORD *)long long buf = 136446722;
      int v104 = "__nw_protocol_output_finished";
      __int16 v105 = 2082;
      int v106 = (nw_protocol *)v70;
      __int16 v107 = 2048;
      int v108 = output_handler;
      BOOL v71 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback";
      goto LABEL_211;
    }
    if (!v101)
    {
      BOOL v68 = __nwlog_obj();
      os_log_type_t v69 = type;
      if (!os_log_type_enabled(v68, type)) {
        goto LABEL_212;
      }
      int v93 = output_handler->identifier->name;
      if (!v93) {
        int v93 = "invalid";
      }
      *(_DWORD *)long long buf = 136446722;
      int v104 = "__nw_protocol_output_finished";
      __int16 v105 = 2082;
      int v106 = (nw_protocol *)v93;
      __int16 v107 = 2048;
      int v108 = output_handler;
      BOOL v71 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, backtrace limit exceeded";
      goto LABEL_211;
    }
    uint64_t v80 = (char *)__nw_create_backtrace_string();
    BOOL v68 = __nwlog_obj();
    os_log_type_t v69 = type;
    BOOL v81 = os_log_type_enabled(v68, type);
    if (v80)
    {
      if (v81)
      {
        BOOL v82 = output_handler->identifier->name;
        if (!v82) {
          BOOL v82 = "invalid";
        }
        *(_DWORD *)long long buf = 136446978;
        int v104 = "__nw_protocol_output_finished";
        __int16 v105 = 2082;
        int v106 = (nw_protocol *)v82;
        __int16 v107 = 2048;
        int v108 = output_handler;
        __int16 v109 = 2082;
        uint64_t v110 = v80;
        _os_log_impl(&dword_1830D4000, v68, v69, "%{public}s protocol %{public}s (%p) has invalid output_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v80);
      goto LABEL_212;
    }
    if (v81)
    {
      int v95 = output_handler->identifier->name;
      if (!v95) {
        int v95 = "invalid";
      }
      *(_DWORD *)long long buf = 136446722;
      int v104 = "__nw_protocol_output_finished";
      __int16 v105 = 2082;
      int v106 = (nw_protocol *)v95;
      __int16 v107 = 2048;
      int v108 = output_handler;
      BOOL v71 = "%{public}s protocol %{public}s (%p) has invalid output_finished callback, no backtrace";
LABEL_211:
      _os_log_impl(&dword_1830D4000, v68, v69, v71, buf, 0x20u);
    }
  }
LABEL_212:
  if (v67) {
    free(v67);
  }
LABEL_88:
  if (v47 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v51 = a1[1].callbacks;
    if (v51)
    {
      uint64_t v52 = (nw_protocol_callbacks *)((char *)v51 - 1);
      a1[1].callbacks = v52;
      if (!v52)
      {
        long long v53 = *(void (***)(void))a1[1].flow_id;
        if (v53)
        {
          *(void *)a1[1].flow_id = 0;
          v53[2](v53);
          _Block_release(v53);
        }
        if (a1[1].flow_id[8])
        {
          long long v54 = *(const void **)a1[1].flow_id;
          if (v54) {
            _Block_release(v54);
          }
        }
        free(a1);
      }
    }
  }
  if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
  {
    long long v55 = output_handler[1].callbacks;
    if (v55)
    {
      os_log_type_t v56 = (nw_protocol_callbacks *)((char *)v55 - 1);
      output_handler[1].callbacks = v56;
      if (!v56)
      {
        long long v57 = *(void (***)(void))output_handler[1].flow_id;
        if (v57)
        {
          *(void *)output_handler[1].flow_id = 0;
          v57[2](v57);
          _Block_release(v57);
        }
        if (output_handler[1].flow_id[8])
        {
          long long v58 = *(const void **)output_handler[1].flow_id;
          if (v58) {
            _Block_release(v58);
          }
        }
        os_log_type_t v59 = output_handler;
        goto LABEL_109;
      }
    }
  }
}

uint64_t ___ZL32nw_protocol_test_output_finishedP11nw_protocolS0__block_invoke(uint64_t a1, void *a2)
{
  uint64_t event_handler = nw_protocol_test_options_get_event_handler(a2, 1);
  if (event_handler) {
    (*(void (**)(uint64_t, void, void))(event_handler + 16))(event_handler, *(void *)(a1 + 32), *(void *)(a1 + 40));
  }
  return 1;
}

uint64_t nw_protocol_test_options_get_event_handler(void *a1, int a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
      int v9 = "%{public}s called with null options";
LABEL_44:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      goto LABEL_45;
    }
    if (!v17)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
        int v9 = "%{public}s called with null options, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
        int v9 = "%{public}s called with null options, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v11) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    char v12 = "%{public}s called with null options, dumping backtrace:%{public}s";
LABEL_30:
    _os_log_impl(&dword_1830D4000, v7, v8, v12, buf, 0x16u);
    goto LABEL_31;
  }
  char v2 = a2;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
    unsigned int v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v6, &type, &v17)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)long long buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
      int v9 = "%{public}s called with null event";
      goto LABEL_44;
    }
    if (!v17)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
        int v9 = "%{public}s called with null event, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v13 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
        int v9 = "%{public}s called with null event, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (!v13) {
      goto LABEL_31;
    }
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    char v12 = "%{public}s called with null event, dumping backtrace:%{public}s";
    goto LABEL_30;
  }
  if (nw_protocol_options_is_test_protocol(a1))
  {
    *(void *)long long buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3002000000;
    char v20 = __Block_byref_object_copy__85490;
    uint64_t v21 = __Block_byref_object_dispose__85491;
    uint64_t v22 = 0;
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 0x40000000;
    v15[2] = __nw_protocol_test_options_get_event_handler_block_invoke;
    v15[3] = &unk_1E524ABD8;
    char v16 = v2;
    v15[4] = buf;
    nw_protocol_options_access_handle(a1, v15);
    uint64_t v4 = *(void *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);
    return v4;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (!__nwlog_fault(v6, &type, &v17)) {
    goto LABEL_45;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v17)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
        int v9 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    size_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v14 = os_log_type_enabled(v7, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
        int v9 = "%{public}s protocol options are not test protocol, no backtrace";
        goto LABEL_44;
      }
      goto LABEL_45;
    }
    if (v14)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      char v12 = "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s";
      goto LABEL_30;
    }
LABEL_31:
    free(backtrace_string);
    goto LABEL_45;
  }
  size_t v7 = __nwlog_obj();
  os_log_type_t v8 = type;
  if (os_log_type_enabled(v7, type))
  {
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_event_handler";
    int v9 = "%{public}s protocol options are not test protocol";
    goto LABEL_44;
  }
LABEL_45:
  if (v6) {
    free(v6);
  }
  return 0;
}

void __Block_byref_object_copy__85490(uint64_t a1, uint64_t a2)
{
}

void __Block_byref_object_dispose__85491(uint64_t a1)
{
}

uint64_t __nw_protocol_test_options_get_event_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (*(unsigned char *)(a1 + 40) == 1)
  {
    *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = *(void *)(a2 + 24);
    return 1;
  }
  if (!*(unsigned char *)(a1 + 40))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)long long buf = 136446210;
    char v16 = "nw_protocol_test_options_get_event_handler_block_invoke";
    char v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (!__nwlog_fault(v2, &type, &v13)) {
      goto LABEL_17;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)long long buf = 136446210;
      char v16 = "nw_protocol_test_options_get_event_handler_block_invoke";
      uint64_t v5 = "%{public}s Invalid event supplied";
    }
    else
    {
      if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v7 = gLogObj;
        os_log_type_t v8 = type;
        BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)long long buf = 136446466;
            char v16 = "nw_protocol_test_options_get_event_handler_block_invoke";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s Invalid event supplied, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_17;
        }
        if (!v9)
        {
LABEL_17:
          if (v2) {
            free(v2);
          }
          return 1;
        }
        *(_DWORD *)long long buf = 136446210;
        char v16 = "nw_protocol_test_options_get_event_handler_block_invoke";
        uint64_t v5 = "%{public}s Invalid event supplied, no backtrace";
        os_log_type_t v10 = v7;
        os_log_type_t v11 = v8;
LABEL_16:
        _os_log_impl(&dword_1830D4000, v10, v11, v5, buf, 0xCu);
        goto LABEL_17;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = gLogObj;
      os_log_type_t v4 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_17;
      }
      *(_DWORD *)long long buf = 136446210;
      char v16 = "nw_protocol_test_options_get_event_handler_block_invoke";
      uint64_t v5 = "%{public}s Invalid event supplied, backtrace limit exceeded";
    }
    os_log_type_t v10 = v3;
    os_log_type_t v11 = v4;
    goto LABEL_16;
  }
  return 1;
}

void nw_protocol_test_disconnected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v44 = "nw_protocol_test_disconnected";
    uint64_t v25 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v25, &type, &v41)) {
      goto LABEL_105;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v44 = "nw_protocol_test_disconnected";
      uint64_t v28 = "%{public}s called with null protocol";
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v34 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v34)
        {
          *(_DWORD *)long long buf = 136446466;
          long long v44 = "nw_protocol_test_disconnected";
          __int16 v45 = 2082;
          BOOL v46 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_105:
        if (!v25) {
          return;
        }
        goto LABEL_106;
      }
      if (!v34) {
        goto LABEL_105;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v44 = "nw_protocol_test_disconnected";
      uint64_t v28 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v44 = "nw_protocol_test_disconnected";
      uint64_t v28 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_104;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v44 = "nw_protocol_test_disconnected";
    uint64_t v25 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v25, &type, &v41)) {
      goto LABEL_105;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v41)
      {
        os_log_type_t v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (!os_log_type_enabled(v26, type)) {
          goto LABEL_105;
        }
        *(_DWORD *)long long buf = 136446210;
        long long v44 = "nw_protocol_test_disconnected";
        uint64_t v28 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_104;
      }
      long long v35 = (char *)__nw_create_backtrace_string();
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v36 = os_log_type_enabled(v26, type);
      if (!v35)
      {
        if (!v36) {
          goto LABEL_105;
        }
        *(_DWORD *)long long buf = 136446210;
        long long v44 = "nw_protocol_test_disconnected";
        uint64_t v28 = "%{public}s called with null test, no backtrace";
        goto LABEL_104;
      }
      if (v36)
      {
        *(_DWORD *)long long buf = 136446466;
        long long v44 = "nw_protocol_test_disconnected";
        __int16 v45 = 2082;
        BOOL v46 = (nw_protocol *)v35;
        os_log_type_t v37 = "%{public}s called with null test, dumping backtrace:%{public}s";
LABEL_78:
        _os_log_impl(&dword_1830D4000, v26, v27, v37, buf, 0x16u);
      }
LABEL_79:
      free(v35);
      if (!v25) {
        return;
      }
LABEL_106:
      os_log_type_t v18 = (nw_protocol *)v25;
LABEL_35:
      free(v18);
      return;
    }
    os_log_type_t v26 = __nwlog_obj();
    os_log_type_t v27 = type;
    if (!os_log_type_enabled(v26, type)) {
      goto LABEL_105;
    }
    *(_DWORD *)long long buf = 136446210;
    long long v44 = "nw_protocol_test_disconnected";
    uint64_t v28 = "%{public}s called with null test";
LABEL_104:
    _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
    goto LABEL_105;
  }
  if (gLogDatapath)
  {
    BOOL v29 = __nwlog_obj();
    if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)long long buf = 136446466;
      long long v44 = "nw_protocol_test_disconnected";
      __int16 v45 = 2082;
      BOOL v46 = a1 + 2;
      _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s disconnected", buf, 0x16u);
    }
  }
  BYTE5(a1[3].identifier) |= 2u;
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    long long v44 = "__nw_protocol_disconnected";
    uint64_t v25 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v25, &type, &v41)) {
      goto LABEL_105;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v44 = "__nw_protocol_disconnected";
      uint64_t v28 = "%{public}s called with null protocol";
      goto LABEL_104;
    }
    if (!v41)
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_105;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v44 = "__nw_protocol_disconnected";
      uint64_t v28 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_104;
    }
    long long v35 = (char *)__nw_create_backtrace_string();
    os_log_type_t v26 = __nwlog_obj();
    os_log_type_t v27 = type;
    BOOL v38 = os_log_type_enabled(v26, type);
    if (!v35)
    {
      if (!v38) {
        goto LABEL_105;
      }
      *(_DWORD *)long long buf = 136446210;
      long long v44 = "__nw_protocol_disconnected";
      uint64_t v28 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_104;
    }
    if (v38)
    {
      *(_DWORD *)long long buf = 136446466;
      long long v44 = "__nw_protocol_disconnected";
      __int16 v45 = 2082;
      BOOL v46 = (nw_protocol *)v35;
      os_log_type_t v37 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_78;
    }
    goto LABEL_79;
  }
  uint64_t handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = default_input_handler[1].callbacks;
    if (callbacks) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }
  unsigned int v6 = a1->handle;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    size_t v7 = a1[1].callbacks;
    if (v7) {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
    }
  }
  os_log_type_t v8 = default_input_handler->callbacks;
  if (v8)
  {
    disconnected = (void (*)(nw_protocol *, nw_protocol *))v8->disconnected;
    if (disconnected)
    {
      disconnected(default_input_handler, a1);
      goto LABEL_14;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)long long buf = 136446722;
  long long v44 = "__nw_protocol_disconnected";
  if (!name) {
    name = "invalid";
  }
  __int16 v45 = 2082;
  BOOL v46 = (nw_protocol *)name;
  __int16 v47 = 2048;
  long long v48 = default_input_handler;
  char v20 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v41 = 0;
  if (__nwlog_fault(v20, &type, &v41))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_90;
      }
      uint64_t v23 = default_input_handler->identifier->name;
      if (!v23) {
        uint64_t v23 = "invalid";
      }
      *(_DWORD *)long long buf = 136446722;
      long long v44 = "__nw_protocol_disconnected";
      __int16 v45 = 2082;
      BOOL v46 = (nw_protocol *)v23;
      __int16 v47 = 2048;
      long long v48 = default_input_handler;
      char v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
      goto LABEL_89;
    }
    if (!v41)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (!os_log_type_enabled(v21, type)) {
        goto LABEL_90;
      }
      long long v39 = default_input_handler->identifier->name;
      if (!v39) {
        long long v39 = "invalid";
      }
      *(_DWORD *)long long buf = 136446722;
      long long v44 = "__nw_protocol_disconnected";
      __int16 v45 = 2082;
      BOOL v46 = (nw_protocol *)v39;
      __int16 v47 = 2048;
      long long v48 = default_input_handler;
      char v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
      goto LABEL_89;
    }
    uint64_t v30 = (char *)__nw_create_backtrace_string();
    uint64_t v21 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v31 = os_log_type_enabled(v21, type);
    if (v30)
    {
      if (v31)
      {
        uint64_t v32 = default_input_handler->identifier->name;
        if (!v32) {
          uint64_t v32 = "invalid";
        }
        *(_DWORD *)long long buf = 136446978;
        long long v44 = "__nw_protocol_disconnected";
        __int16 v45 = 2082;
        BOOL v46 = (nw_protocol *)v32;
        __int16 v47 = 2048;
        long long v48 = default_input_handler;
        __int16 v49 = 2082;
        BOOL v50 = v30;
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v30);
      goto LABEL_90;
    }
    if (v31)
    {
      os_log_type_t v40 = default_input_handler->identifier->name;
      if (!v40) {
        os_log_type_t v40 = "invalid";
      }
      *(_DWORD *)long long buf = 136446722;
      long long v44 = "__nw_protocol_disconnected";
      __int16 v45 = 2082;
      BOOL v46 = (nw_protocol *)v40;
      __int16 v47 = 2048;
      long long v48 = default_input_handler;
      char v24 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
LABEL_89:
      _os_log_impl(&dword_1830D4000, v21, v22, v24, buf, 0x20u);
    }
  }
LABEL_90:
  if (v20) {
    free(v20);
  }
LABEL_14:
  if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v10 = a1[1].callbacks;
    if (v10)
    {
      os_log_type_t v11 = (nw_protocol_callbacks *)((char *)v10 - 1);
      a1[1].callbacks = v11;
      if (!v11)
      {
        char v12 = *(void (***)(void))a1[1].flow_id;
        if (v12)
        {
          *(void *)a1[1].flow_id = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if (a1[1].flow_id[8])
        {
          char v13 = *(const void **)a1[1].flow_id;
          if (v13) {
            _Block_release(v13);
          }
        }
        free(a1);
      }
    }
  }
  if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
  {
    BOOL v14 = default_input_handler[1].callbacks;
    if (v14)
    {
      os_log_type_t v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
      default_input_handler[1].callbacks = v15;
      if (!v15)
      {
        char v16 = *(void (***)(void))default_input_handler[1].flow_id;
        if (v16)
        {
          *(void *)default_input_handler[1].flow_id = 0;
          v16[2](v16);
          _Block_release(v16);
        }
        if (default_input_handler[1].flow_id[8])
        {
          __int16 v17 = *(const void **)default_input_handler[1].flow_id;
          if (v17) {
            _Block_release(v17);
          }
        }
        os_log_type_t v18 = default_input_handler;
        goto LABEL_35;
      }
    }
  }
}

uint64_t nw_protocol_test_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v63 = "nw_protocol_test_connect";
    os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (!__nwlog_fault(v40, &type, &v60)) {
      goto LABEL_128;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v60)
      {
        char v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_128;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v63 = "nw_protocol_test_connect";
        os_log_type_t v43 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_127;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v53 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v53) {
          goto LABEL_128;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v63 = "nw_protocol_test_connect";
        os_log_type_t v43 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_127;
      }
      if (v53)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v63 = "nw_protocol_test_connect";
        __int16 v64 = 2082;
        int v65 = (nw_protocol *)backtrace_string;
        long long v54 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_101:
        _os_log_impl(&dword_1830D4000, v41, v42, v54, buf, 0x16u);
      }
LABEL_102:
      free(backtrace_string);
      goto LABEL_128;
    }
    char v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    if (!os_log_type_enabled(v41, type)) {
      goto LABEL_128;
    }
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v63 = "nw_protocol_test_connect";
    os_log_type_t v43 = "%{public}s called with null protocol";
LABEL_127:
    _os_log_impl(&dword_1830D4000, v41, v42, v43, buf, 0xCu);
LABEL_128:
    if (v40) {
      free(v40);
    }
    return 0;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v63 = "nw_protocol_test_connect";
    os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (!__nwlog_fault(v40, &type, &v60)) {
      goto LABEL_128;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_128;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v63 = "nw_protocol_test_connect";
      os_log_type_t v43 = "%{public}s called with null test";
      goto LABEL_127;
    }
    if (!v60)
    {
      char v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (!os_log_type_enabled(v41, type)) {
        goto LABEL_128;
      }
      *(_DWORD *)long long buf = 136446210;
      os_log_type_t v63 = "nw_protocol_test_connect";
      os_log_type_t v43 = "%{public}s called with null test, backtrace limit exceeded";
      goto LABEL_127;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v41 = __nwlog_obj();
    os_log_type_t v42 = type;
    BOOL v55 = os_log_type_enabled(v41, type);
    if (backtrace_string)
    {
      if (v55)
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v63 = "nw_protocol_test_connect";
        __int16 v64 = 2082;
        int v65 = (nw_protocol *)backtrace_string;
        long long v54 = "%{public}s called with null test, dumping backtrace:%{public}s";
        goto LABEL_101;
      }
      goto LABEL_102;
    }
    if (!v55) {
      goto LABEL_128;
    }
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v63 = "nw_protocol_test_connect";
    os_log_type_t v43 = "%{public}s called with null test, no backtrace";
    goto LABEL_127;
  }
  if ((BYTE1(a1[1].output_handler) & 0xC) != 0)
  {
    if (gLogDatapath)
    {
      long long v44 = __nwlog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        os_log_type_t v63 = "nw_protocol_test_connect";
        __int16 v64 = 2082;
        int v65 = a1 + 2;
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Returning connected immediately for test protocol", buf, 0x16u);
      }
    }
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      uint64_t handle = default_input_handler->handle;
      if (handle == &nw_protocol_ref_counted_handle)
      {
        callbacks = default_input_handler[1].callbacks;
        if (callbacks) {
          default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
      }
      unsigned int v6 = a1->handle;
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        size_t v7 = a1[1].callbacks;
        if (v7) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
        }
      }
      os_log_type_t v8 = default_input_handler->callbacks;
      if (v8)
      {
        connected = (void (*)(nw_protocol *, nw_protocol *))v8->connected;
        if (connected)
        {
          connected(default_input_handler, a1);
          goto LABEL_15;
        }
      }
      __nwlog_obj();
      name = default_input_handler->identifier->name;
      *(_DWORD *)long long buf = 136446722;
      os_log_type_t v63 = "__nw_protocol_connected";
      if (!name) {
        name = "invalid";
      }
      __int16 v64 = 2082;
      int v65 = (nw_protocol *)name;
      __int16 v66 = 2048;
      BOOL v67 = default_input_handler;
      long long v35 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v60 = 0;
      if (__nwlog_fault(v35, &type, &v60))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v36 = __nwlog_obj();
          os_log_type_t v37 = type;
          if (!os_log_type_enabled(v36, type)) {
            goto LABEL_121;
          }
          BOOL v38 = default_input_handler->identifier->name;
          if (!v38) {
            BOOL v38 = "invalid";
          }
          *(_DWORD *)long long buf = 136446722;
          os_log_type_t v63 = "__nw_protocol_connected";
          __int16 v64 = 2082;
          int v65 = (nw_protocol *)v38;
          __int16 v66 = 2048;
          BOOL v67 = default_input_handler;
          long long v39 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
          goto LABEL_120;
        }
        if (!v60)
        {
          BOOL v36 = __nwlog_obj();
          os_log_type_t v37 = type;
          if (!os_log_type_enabled(v36, type)) {
            goto LABEL_121;
          }
          long long v58 = default_input_handler->identifier->name;
          if (!v58) {
            long long v58 = "invalid";
          }
          *(_DWORD *)long long buf = 136446722;
          os_log_type_t v63 = "__nw_protocol_connected";
          __int16 v64 = 2082;
          int v65 = (nw_protocol *)v58;
          __int16 v66 = 2048;
          BOOL v67 = default_input_handler;
          long long v39 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_120;
        }
        __int16 v49 = (char *)__nw_create_backtrace_string();
        BOOL v36 = __nwlog_obj();
        os_log_type_t v37 = type;
        BOOL v50 = os_log_type_enabled(v36, type);
        if (v49)
        {
          if (v50)
          {
            uint64_t v51 = default_input_handler->identifier->name;
            if (!v51) {
              uint64_t v51 = "invalid";
            }
            *(_DWORD *)long long buf = 136446978;
            os_log_type_t v63 = "__nw_protocol_connected";
            __int16 v64 = 2082;
            int v65 = (nw_protocol *)v51;
            __int16 v66 = 2048;
            BOOL v67 = default_input_handler;
            __int16 v68 = 2082;
            os_log_type_t v69 = v49;
            _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v49);
          goto LABEL_121;
        }
        if (v50)
        {
          os_log_type_t v59 = default_input_handler->identifier->name;
          if (!v59) {
            os_log_type_t v59 = "invalid";
          }
          *(_DWORD *)long long buf = 136446722;
          os_log_type_t v63 = "__nw_protocol_connected";
          __int16 v64 = 2082;
          int v65 = (nw_protocol *)v59;
          __int16 v66 = 2048;
          BOOL v67 = default_input_handler;
          long long v39 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_120:
          _os_log_impl(&dword_1830D4000, v36, v37, v39, buf, 0x20u);
        }
      }
LABEL_121:
      if (v35) {
        free(v35);
      }
LABEL_15:
      if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v22 = a1[1].callbacks;
        if (v22)
        {
          uint64_t v23 = (nw_protocol_callbacks *)((char *)v22 - 1);
          a1[1].callbacks = v23;
          if (!v23)
          {
            char v24 = *(void (***)(void))a1[1].flow_id;
            if (v24)
            {
              *(void *)a1[1].flow_id = 0;
              v24[2](v24);
              _Block_release(v24);
            }
            if (a1[1].flow_id[8])
            {
              uint64_t v25 = *(const void **)a1[1].flow_id;
              if (v25) {
                _Block_release(v25);
              }
            }
            free(a1);
          }
        }
      }
      if (handle == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v26 = default_input_handler[1].callbacks;
        if (v26)
        {
          os_log_type_t v27 = (nw_protocol_callbacks *)((char *)v26 - 1);
          default_input_handler[1].callbacks = v27;
          if (!v27)
          {
            uint64_t v28 = *(void (***)(void))default_input_handler[1].flow_id;
            if (v28)
            {
              *(void *)default_input_handler[1].flow_id = 0;
              v28[2](v28);
              _Block_release(v28);
            }
            if (default_input_handler[1].flow_id[8])
            {
              BOOL v29 = *(const void **)default_input_handler[1].flow_id;
              if (v29) {
                _Block_release(v29);
              }
            }
            free(default_input_handler);
            return 1;
          }
        }
      }
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    os_log_type_t v63 = "__nw_protocol_connected";
    __int16 v45 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (__nwlog_fault(v45, &type, &v60))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v46 = __nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_136;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v63 = "__nw_protocol_connected";
        long long v48 = "%{public}s called with null protocol";
        goto LABEL_135;
      }
      if (!v60)
      {
        BOOL v46 = __nwlog_obj();
        os_log_type_t v47 = type;
        if (!os_log_type_enabled(v46, type)) {
          goto LABEL_136;
        }
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v63 = "__nw_protocol_connected";
        long long v48 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_135;
      }
      os_log_type_t v56 = (char *)__nw_create_backtrace_string();
      BOOL v46 = __nwlog_obj();
      os_log_type_t v47 = type;
      BOOL v57 = os_log_type_enabled(v46, type);
      if (v56)
      {
        if (v57)
        {
          *(_DWORD *)long long buf = 136446466;
          os_log_type_t v63 = "__nw_protocol_connected";
          __int16 v64 = 2082;
          int v65 = (nw_protocol *)v56;
          _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v56);
        goto LABEL_136;
      }
      if (v57)
      {
        *(_DWORD *)long long buf = 136446210;
        os_log_type_t v63 = "__nw_protocol_connected";
        long long v48 = "%{public}s called with null protocol, no backtrace";
LABEL_135:
        _os_log_impl(&dword_1830D4000, v46, v47, v48, buf, 0xCu);
      }
    }
LABEL_136:
    if (v45) {
      free(v45);
    }
    return 1;
  }
  output_handler = a1->output_handler;
  if (!output_handler) {
    return 0;
  }
  char v13 = output_handler->callbacks;
  if (!v13) {
    return 0;
  }
  connect = (uint64_t (*)(nw_protocol *, nw_protocol *))v13->connect;
  if (!connect) {
    return 0;
  }
  os_log_type_t v15 = output_handler->handle;
  if (v15 == &nw_protocol_ref_counted_handle)
  {
    char v16 = output_handler[1].callbacks;
    if (v16) {
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v16->add_input_handler + 1);
    }
  }
  __int16 v17 = a1[1].callbacks;
  if (v17) {
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
  }
  uint64_t v10 = connect(output_handler, a1);
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    uint64_t v30 = a1[1].callbacks;
    if (v30)
    {
      BOOL v31 = (nw_protocol_callbacks *)((char *)v30 - 1);
      a1[1].callbacks = v31;
      if (!v31)
      {
        uint64_t v32 = *(void (***)(void))a1[1].flow_id;
        if (v32)
        {
          *(void *)a1[1].flow_id = 0;
          v32[2](v32);
          _Block_release(v32);
        }
        if (a1[1].flow_id[8])
        {
          os_log_type_t v33 = *(const void **)a1[1].flow_id;
          if (v33) {
            _Block_release(v33);
          }
        }
        free(a1);
      }
    }
  }
  if (v15 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
  {
    os_log_type_t v18 = output_handler[1].callbacks;
    if (v18)
    {
      uint64_t v19 = (nw_protocol_callbacks *)((char *)v18 - 1);
      output_handler[1].callbacks = v19;
      if (!v19)
      {
        char v20 = *(void (***)(void))output_handler[1].flow_id;
        if (v20)
        {
          *(void *)output_handler[1].flow_id = 0;
          v20[2](v20);
          _Block_release(v20);
        }
        if (output_handler[1].flow_id[8])
        {
          uint64_t v21 = *(const void **)output_handler[1].flow_id;
          if (v21) {
            _Block_release(v21);
          }
        }
        free(output_handler);
      }
    }
  }
  return v10;
}

uint64_t nw_protocol_test_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v108 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v101 = "nw_protocol_test_finalize_output_frames";
    __int16 v66 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v66, &type, &v98)) {
      goto LABEL_212;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (!os_log_type_enabled(v67, type)) {
        goto LABEL_212;
      }
      *(_DWORD *)long long buf = 136446210;
      char v101 = "nw_protocol_test_finalize_output_frames";
      os_log_type_t v69 = "%{public}s called with null protocol";
LABEL_211:
      _os_log_impl(&dword_1830D4000, v67, v68, v69, buf, 0xCu);
      goto LABEL_212;
    }
    if (!v98)
    {
      BOOL v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (os_log_type_enabled(v67, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v101 = "nw_protocol_test_finalize_output_frames";
        os_log_type_t v69 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_211;
      }
      goto LABEL_212;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v67 = __nwlog_obj();
    os_log_type_t v68 = type;
    BOOL v79 = os_log_type_enabled(v67, type);
    if (!backtrace_string)
    {
      if (v79)
      {
        *(_DWORD *)long long buf = 136446210;
        char v101 = "nw_protocol_test_finalize_output_frames";
        os_log_type_t v69 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_211;
      }
      goto LABEL_212;
    }
    if (!v79) {
      goto LABEL_165;
    }
    *(_DWORD *)long long buf = 136446466;
    char v101 = "nw_protocol_test_finalize_output_frames";
    __int16 v102 = 2082;
    __int16 v103 = (nw_protocol_identifier *)backtrace_string;
    uint64_t v80 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_164:
    _os_log_impl(&dword_1830D4000, v67, v68, v80, buf, 0x16u);
    goto LABEL_165;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v101 = "nw_protocol_test_finalize_output_frames";
    __int16 v66 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v66, &type, &v98)) {
      goto LABEL_212;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (!os_log_type_enabled(v67, type)) {
        goto LABEL_212;
      }
      *(_DWORD *)long long buf = 136446210;
      char v101 = "nw_protocol_test_finalize_output_frames";
      os_log_type_t v69 = "%{public}s called with null test";
      goto LABEL_211;
    }
    if (!v98)
    {
      BOOL v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (os_log_type_enabled(v67, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v101 = "nw_protocol_test_finalize_output_frames";
        os_log_type_t v69 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_211;
      }
      goto LABEL_212;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v67 = __nwlog_obj();
    os_log_type_t v68 = type;
    BOOL v81 = os_log_type_enabled(v67, type);
    if (!backtrace_string)
    {
      if (v81)
      {
        *(_DWORD *)long long buf = 136446210;
        char v101 = "nw_protocol_test_finalize_output_frames";
        os_log_type_t v69 = "%{public}s called with null test, no backtrace";
        goto LABEL_211;
      }
      goto LABEL_212;
    }
    if (!v81) {
      goto LABEL_165;
    }
    *(_DWORD *)long long buf = 136446466;
    char v101 = "nw_protocol_test_finalize_output_frames";
    __int16 v102 = 2082;
    __int16 v103 = (nw_protocol_identifier *)backtrace_string;
    uint64_t v80 = "%{public}s called with null test, dumping backtrace:%{public}s";
    goto LABEL_164;
  }
  v94[0] = MEMORY[0x1E4F143A8];
  v94[1] = 0x40000000;
  int v95 = ___ZL39nw_protocol_test_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  unsigned int v96 = &__block_descriptor_tmp_43_85573;
  char v97 = a2;
  callbacks = a1[1].callbacks;
  if (callbacks) {
    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
  }
  uint64_t v5 = a1->callbacks;
  if (v5)
  {
    get_parameters = (uint64_t (*)(nw_protocol *))v5->get_parameters;
    if (get_parameters)
    {
      size_t v7 = (void *)get_parameters(a1);
      goto LABEL_8;
    }
  }
  __nwlog_obj();
  identifier = a1->identifier;
  *(_DWORD *)long long buf = 136446722;
  char v101 = "__nw_protocol_get_parameters";
  if (!identifier) {
    identifier = (nw_protocol_identifier *)"invalid";
  }
  __int16 v102 = 2082;
  __int16 v103 = identifier;
  __int16 v104 = 2048;
  __int16 v105 = a1;
  BOOL v55 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v98 = 0;
  if (__nwlog_fault(v55, &type, &v98))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v56, type))
      {
        long long v58 = a1->identifier;
        if (!v58) {
          long long v58 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        char v101 = "__nw_protocol_get_parameters";
        __int16 v102 = 2082;
        __int16 v103 = v58;
        __int16 v104 = 2048;
        __int16 v105 = a1;
        os_log_type_t v59 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_184:
        _os_log_impl(&dword_1830D4000, v56, v57, v59, buf, 0x20u);
      }
    }
    else if (v98)
    {
      BOOL v72 = (char *)__nw_create_backtrace_string();
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      BOOL v73 = os_log_type_enabled(v56, type);
      if (v72)
      {
        if (v73)
        {
          os_log_type_t v74 = a1->identifier;
          if (!v74) {
            os_log_type_t v74 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)long long buf = 136446978;
          char v101 = "__nw_protocol_get_parameters";
          __int16 v102 = 2082;
          __int16 v103 = v74;
          __int16 v104 = 2048;
          __int16 v105 = a1;
          __int16 v106 = 2082;
          __int16 v107 = v72;
          _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v72);
        goto LABEL_185;
      }
      if (v73)
      {
        BOOL v89 = a1->identifier;
        if (!v89) {
          BOOL v89 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        char v101 = "__nw_protocol_get_parameters";
        __int16 v102 = 2082;
        __int16 v103 = v89;
        __int16 v104 = 2048;
        __int16 v105 = a1;
        os_log_type_t v59 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
        goto LABEL_184;
      }
    }
    else
    {
      os_log_type_t v56 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v56, type))
      {
        __int16 v87 = a1->identifier;
        if (!v87) {
          __int16 v87 = (nw_protocol_identifier *)"invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        char v101 = "__nw_protocol_get_parameters";
        __int16 v102 = 2082;
        __int16 v103 = v87;
        __int16 v104 = 2048;
        __int16 v105 = a1;
        os_log_type_t v59 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
        goto LABEL_184;
      }
    }
  }
LABEL_185:
  if (v55) {
    free(v55);
  }
  size_t v7 = 0;
LABEL_8:
  if (a1->handle == &nw_protocol_ref_counted_handle)
  {
    char v12 = a1[1].callbacks;
    if (v12)
    {
      char v13 = (nw_protocol_callbacks *)((char *)v12 - 1);
      a1[1].callbacks = v13;
      if (!v13)
      {
        BOOL v14 = *(void (***)(void))a1[1].flow_id;
        if (v14)
        {
          *(void *)a1[1].flow_id = 0;
          v14[2](v14);
          _Block_release(v14);
        }
        if (a1[1].flow_id[8])
        {
          os_log_type_t v15 = *(const void **)a1[1].flow_id;
          if (v15) {
            _Block_release(v15);
          }
        }
        free(a1);
      }
    }
  }
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v101 = "nw_protocol_test_access_options";
    char v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (__nwlog_fault(v16, &type, &v98))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v101 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null parameters";
LABEL_57:
          _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
        }
      }
      else if (v98)
      {
        BOOL v82 = (char *)__nw_create_backtrace_string();
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v83 = os_log_type_enabled(v17, type);
        if (v82)
        {
          if (v83)
          {
            *(_DWORD *)long long buf = 136446466;
            char v101 = "nw_protocol_test_access_options";
            __int16 v102 = 2082;
            __int16 v103 = (nw_protocol_identifier *)v82;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v82);
        }
        else if (v83)
        {
          *(_DWORD *)long long buf = 136446210;
          char v101 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null parameters, no backtrace";
          goto LABEL_57;
        }
      }
      else
      {
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)long long buf = 136446210;
          char v101 = "nw_protocol_test_access_options";
          uint64_t v19 = "%{public}s called with null parameters, backtrace limit exceeded";
          goto LABEL_57;
        }
      }
    }
LABEL_58:
    if (!v16) {
      goto LABEL_75;
    }
    goto LABEL_59;
  }
  if (nw_protocol_copy_test_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_test_definition::onceToken, &__block_literal_global_85364);
  }
  if (nw_protocol_copy_test_definition::test_definition)
  {
    os_log_type_t v8 = os_retain((void *)nw_protocol_copy_test_definition::test_definition);
    if (v8)
    {
      BOOL v9 = v8;
      uint64_t v10 = nw_parameters_copy_protocol_options_for_definition(v7, v8);
      if (v10)
      {
        os_log_type_t v11 = v10;
        if (nw_protocol_options_is_test_protocol(v10))
        {
          v95((uint64_t)v94, v11);
LABEL_73:
          os_release(v9);
          os_log_type_t v40 = v11;
LABEL_74:
          os_release(v40);
          goto LABEL_75;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)long long buf = 136446210;
        char v101 = "nw_protocol_test_access_options";
        char v24 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v98 = 0;
        if (__nwlog_fault(v24, &type, &v98))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v25 = gLogObj;
            os_log_type_t v26 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_71;
            }
            *(_DWORD *)long long buf = 136446210;
            char v101 = "nw_protocol_test_access_options";
            os_log_type_t v27 = "%{public}s Failed to copy test protocol options";
LABEL_69:
            char v41 = v25;
            os_log_type_t v42 = v26;
LABEL_70:
            _os_log_impl(&dword_1830D4000, v41, v42, v27, buf, 0xCu);
            goto LABEL_71;
          }
          if (!v98)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v25 = gLogObj;
            os_log_type_t v26 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_71;
            }
            *(_DWORD *)long long buf = 136446210;
            char v101 = "nw_protocol_test_access_options";
            os_log_type_t v27 = "%{public}s Failed to copy test protocol options, backtrace limit exceeded";
            goto LABEL_69;
          }
          BOOL v34 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          long long v35 = gLogObj;
          os_log_type_t v36 = type;
          BOOL v37 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v34)
          {
            if (v37)
            {
              *(_DWORD *)long long buf = 136446466;
              char v101 = "nw_protocol_test_access_options";
              __int16 v102 = 2082;
              __int16 v103 = (nw_protocol_identifier *)v34;
              _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s Failed to copy test protocol options, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v34);
            goto LABEL_71;
          }
          if (v37)
          {
            *(_DWORD *)long long buf = 136446210;
            char v101 = "nw_protocol_test_access_options";
            os_log_type_t v27 = "%{public}s Failed to copy test protocol options, no backtrace";
            char v41 = v35;
            os_log_type_t v42 = v36;
            goto LABEL_70;
          }
        }
LABEL_71:
        if (v24) {
          free(v24);
        }
        goto LABEL_73;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)long long buf = 136446210;
      char v101 = "nw_protocol_test_access_options";
      char v20 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v98 = 0;
      if (__nwlog_fault(v20, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v21 = gLogObj;
          os_log_type_t v22 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)long long buf = 136446210;
            char v101 = "nw_protocol_test_access_options";
            uint64_t v23 = "%{public}s Failed to copy protocol options";
LABEL_62:
            BOOL v38 = v21;
            os_log_type_t v39 = v22;
LABEL_63:
            _os_log_impl(&dword_1830D4000, v38, v39, v23, buf, 0xCu);
          }
        }
        else if (v98)
        {
          uint64_t v30 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v31 = gLogObj;
          os_log_type_t v32 = type;
          BOOL v33 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v30)
          {
            if (v33)
            {
              *(_DWORD *)long long buf = 136446466;
              char v101 = "nw_protocol_test_access_options";
              __int16 v102 = 2082;
              __int16 v103 = (nw_protocol_identifier *)v30;
              _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s Failed to copy protocol options, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v30);
            goto LABEL_64;
          }
          if (v33)
          {
            *(_DWORD *)long long buf = 136446210;
            char v101 = "nw_protocol_test_access_options";
            uint64_t v23 = "%{public}s Failed to copy protocol options, no backtrace";
            BOOL v38 = v31;
            os_log_type_t v39 = v32;
            goto LABEL_63;
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v21 = gLogObj;
          os_log_type_t v22 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)long long buf = 136446210;
            char v101 = "nw_protocol_test_access_options";
            uint64_t v23 = "%{public}s Failed to copy protocol options, backtrace limit exceeded";
            goto LABEL_62;
          }
        }
      }
LABEL_64:
      if (v20) {
        free(v20);
      }
      os_log_type_t v40 = (atomic_uchar *)v9;
      goto LABEL_74;
    }
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v101 = "nw_protocol_test_access_options";
  char v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v98 = 0;
  if (!__nwlog_fault(v16, &type, &v98)) {
    goto LABEL_58;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_58;
    }
    *(_DWORD *)long long buf = 136446210;
    char v101 = "nw_protocol_test_access_options";
    uint64_t v19 = "%{public}s called with null definition";
    goto LABEL_57;
  }
  if (!v98)
  {
    __int16 v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_58;
    }
    *(_DWORD *)long long buf = 136446210;
    char v101 = "nw_protocol_test_access_options";
    uint64_t v19 = "%{public}s called with null definition, backtrace limit exceeded";
    goto LABEL_57;
  }
  uint64_t v28 = (char *)__nw_create_backtrace_string();
  __int16 v17 = __nwlog_obj();
  os_log_type_t v18 = type;
  BOOL v29 = os_log_type_enabled(v17, type);
  if (!v28)
  {
    if (!v29) {
      goto LABEL_58;
    }
    *(_DWORD *)long long buf = 136446210;
    char v101 = "nw_protocol_test_access_options";
    uint64_t v19 = "%{public}s called with null definition, no backtrace";
    goto LABEL_57;
  }
  if (v29)
  {
    *(_DWORD *)long long buf = 136446466;
    char v101 = "nw_protocol_test_access_options";
    __int16 v102 = 2082;
    __int16 v103 = (nw_protocol_identifier *)v28;
    _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v28);
  if (v16) {
LABEL_59:
  }
    free(v16);
LABEL_75:
  output_handler = a1->output_handler;
  if (output_handler)
  {
    uint64_t handle = output_handler->handle;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      __int16 v45 = output_handler[1].callbacks;
      if (v45) {
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v45->add_input_handler + 1);
      }
    }
    if (a2)
    {
      BOOL v46 = output_handler->callbacks;
      if (v46)
      {
        finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v46->finalize_output_frames;
        if (finalize_output_frames)
        {
          uint64_t v48 = finalize_output_frames(output_handler, a2);
          if (handle != &nw_protocol_ref_counted_handle) {
            return v48;
          }
          goto LABEL_83;
        }
      }
      __nwlog_obj();
      name = output_handler->identifier->name;
      *(_DWORD *)long long buf = 136446722;
      char v101 = "__nw_protocol_finalize_output_frames";
      if (!name) {
        name = "invalid";
      }
      __int16 v102 = 2082;
      __int16 v103 = (nw_protocol_identifier *)name;
      __int16 v104 = 2048;
      __int16 v105 = output_handler;
      long long v61 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v98 = 0;
      if (__nwlog_fault(v61, &type, &v98))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          long long v62 = __nwlog_obj();
          os_log_type_t v63 = type;
          if (!os_log_type_enabled(v62, type)) {
            goto LABEL_219;
          }
          __int16 v64 = output_handler->identifier->name;
          if (!v64) {
            __int16 v64 = "invalid";
          }
          *(_DWORD *)long long buf = 136446722;
          char v101 = "__nw_protocol_finalize_output_frames";
          __int16 v102 = 2082;
          __int16 v103 = (nw_protocol_identifier *)v64;
          __int16 v104 = 2048;
          __int16 v105 = output_handler;
          int v65 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_192:
          BOOL v91 = v62;
          os_log_type_t v92 = v63;
          uint32_t v93 = 32;
LABEL_218:
          _os_log_impl(&dword_1830D4000, v91, v92, v65, buf, v93);
          goto LABEL_219;
        }
        if (!v98)
        {
          long long v62 = __nwlog_obj();
          os_log_type_t v63 = type;
          if (!os_log_type_enabled(v62, type)) {
            goto LABEL_219;
          }
          uint64_t v88 = output_handler->identifier->name;
          if (!v88) {
            uint64_t v88 = "invalid";
          }
          *(_DWORD *)long long buf = 136446722;
          char v101 = "__nw_protocol_finalize_output_frames";
          __int16 v102 = 2082;
          __int16 v103 = (nw_protocol_identifier *)v88;
          __int16 v104 = 2048;
          __int16 v105 = output_handler;
          int v65 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
          goto LABEL_192;
        }
        unsigned int v75 = (char *)__nw_create_backtrace_string();
        long long v62 = __nwlog_obj();
        os_log_type_t v63 = type;
        BOOL v76 = os_log_type_enabled(v62, type);
        if (!v75)
        {
          if (!v76) {
            goto LABEL_219;
          }
          BOOL v90 = output_handler->identifier->name;
          if (!v90) {
            BOOL v90 = "invalid";
          }
          *(_DWORD *)long long buf = 136446722;
          char v101 = "__nw_protocol_finalize_output_frames";
          __int16 v102 = 2082;
          __int16 v103 = (nw_protocol_identifier *)v90;
          __int16 v104 = 2048;
          __int16 v105 = output_handler;
          int v65 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
          goto LABEL_192;
        }
        if (v76)
        {
          int v77 = output_handler->identifier->name;
          if (!v77) {
            int v77 = "invalid";
          }
          *(_DWORD *)long long buf = 136446978;
          char v101 = "__nw_protocol_finalize_output_frames";
          __int16 v102 = 2082;
          __int16 v103 = (nw_protocol_identifier *)v77;
          __int16 v104 = 2048;
          __int16 v105 = output_handler;
          __int16 v106 = 2082;
          __int16 v107 = v75;
          _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v75);
      }
LABEL_219:
      if (!v61) {
        goto LABEL_221;
      }
      goto LABEL_220;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    char v101 = "__nw_protocol_finalize_output_frames";
    long long v61 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v98 = 0;
    if (!__nwlog_fault(v61, &type, &v98)) {
      goto LABEL_219;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_219;
      }
      *(_DWORD *)long long buf = 136446210;
      char v101 = "__nw_protocol_finalize_output_frames";
      int v65 = "%{public}s called with null frames";
    }
    else if (v98)
    {
      __int16 v85 = (char *)__nw_create_backtrace_string();
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      BOOL v86 = os_log_type_enabled(v70, type);
      if (v85)
      {
        if (v86)
        {
          *(_DWORD *)long long buf = 136446466;
          char v101 = "__nw_protocol_finalize_output_frames";
          __int16 v102 = 2082;
          __int16 v103 = (nw_protocol_identifier *)v85;
          _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s called with null frames, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v85);
        if (!v61)
        {
LABEL_221:
          uint64_t v48 = 0;
          if (handle != &nw_protocol_ref_counted_handle) {
            return v48;
          }
LABEL_83:
          if (output_handler->handle == &nw_protocol_ref_counted_handle)
          {
            BOOL v50 = output_handler[1].callbacks;
            if (v50)
            {
              uint64_t v51 = (nw_protocol_callbacks *)((char *)v50 - 1);
              output_handler[1].callbacks = v51;
              if (!v51)
              {
                uint64_t v52 = *(void (***)(void))output_handler[1].flow_id;
                if (v52)
                {
                  *(void *)output_handler[1].flow_id = 0;
                  v52[2](v52);
                  _Block_release(v52);
                }
                if (output_handler[1].flow_id[8])
                {
                  BOOL v53 = *(const void **)output_handler[1].flow_id;
                  if (v53) {
                    _Block_release(v53);
                  }
                }
                free(output_handler);
              }
            }
          }
          return v48;
        }
LABEL_220:
        free(v61);
        goto LABEL_221;
      }
      if (!v86) {
        goto LABEL_219;
      }
      *(_DWORD *)long long buf = 136446210;
      char v101 = "__nw_protocol_finalize_output_frames";
      int v65 = "%{public}s called with null frames, no backtrace";
    }
    else
    {
      uint64_t v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_219;
      }
      *(_DWORD *)long long buf = 136446210;
      char v101 = "__nw_protocol_finalize_output_frames";
      int v65 = "%{public}s called with null frames, backtrace limit exceeded";
    }
    BOOL v91 = v70;
    os_log_type_t v92 = v71;
    uint32_t v93 = 12;
    goto LABEL_218;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  char v101 = "__nw_protocol_finalize_output_frames";
  __int16 v66 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v98 = 0;
  if (!__nwlog_fault(v66, &type, &v98)) {
    goto LABEL_212;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v98)
    {
      BOOL v67 = __nwlog_obj();
      os_log_type_t v68 = type;
      if (os_log_type_enabled(v67, type))
      {
        *(_DWORD *)long long buf = 136446210;
        char v101 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v69 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_211;
      }
      goto LABEL_212;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v67 = __nwlog_obj();
    os_log_type_t v68 = type;
    BOOL v84 = os_log_type_enabled(v67, type);
    if (!backtrace_string)
    {
      if (v84)
      {
        *(_DWORD *)long long buf = 136446210;
        char v101 = "__nw_protocol_finalize_output_frames";
        os_log_type_t v69 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_211;
      }
      goto LABEL_212;
    }
    if (v84)
    {
      *(_DWORD *)long long buf = 136446466;
      char v101 = "__nw_protocol_finalize_output_frames";
      __int16 v102 = 2082;
      __int16 v103 = (nw_protocol_identifier *)backtrace_string;
      uint64_t v80 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_164;
    }
LABEL_165:
    free(backtrace_string);
    goto LABEL_212;
  }
  BOOL v67 = __nwlog_obj();
  os_log_type_t v68 = type;
  if (os_log_type_enabled(v67, type))
  {
    *(_DWORD *)long long buf = 136446210;
    char v101 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v69 = "%{public}s called with null protocol";
    goto LABEL_211;
  }
LABEL_212:
  if (v66) {
    free(v66);
  }
  return 0;
}

uint64_t ___ZL39nw_protocol_test_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, void *a2)
{
  uint64_t finalize_output_frames_handler = nw_protocol_test_options_get_finalize_output_frames_handler(a2);
  if (finalize_output_frames_handler) {
    (*(void (**)(uint64_t, void))(finalize_output_frames_handler + 16))(finalize_output_frames_handler, *(void *)(a1 + 32));
  }
  return 1;
}

uint64_t nw_protocol_test_options_get_finalize_output_frames_handler(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (nw_protocol_options_is_test_protocol(a1))
  {
    *(void *)long long buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3002000000;
    BOOL v14 = __Block_byref_object_copy__85490;
    os_log_type_t v15 = __Block_byref_object_dispose__85491;
    uint64_t v16 = 0;
    v10[0] = MEMORY[0x1E4F143A8];
    v10[1] = 0x40000000;
    v10[2] = __nw_protocol_test_options_get_finalize_output_frames_handler_block_invoke;
    v10[3] = &unk_1E524AB88;
    v10[4] = buf;
    nw_protocol_options_access_handle(a1, v10);
    uint64_t v2 = *(void *)(*(void *)&buf[8] + 40);
    _Block_object_dispose(buf, 8);
    return v2;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
  os_log_type_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
        size_t v7 = "%{public}s protocol options are not test protocol";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s protocol options are not test protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v9)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
        size_t v7 = "%{public}s protocol options are not test protocol, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_options_get_finalize_output_frames_handler";
        size_t v7 = "%{public}s protocol options are not test protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t __nw_protocol_test_options_get_finalize_output_frames_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) = *(void *)(a2 + 8);
  return 1;
}

uint64_t nw_protocol_test_get_output_frames(nw_protocol *a1, nw_protocol *a2, uint64_t a3, uint64_t a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      p_output_handler = &a1[1].output_handler;
      output_handler = a1[1].output_handler;
      if ((output_handler & 0x80) != 0)
      {
        int v13 = (BYTE4(a1[3].identifier) + 1) & 3;
        BYTE4(a1[3].identifier) = v13;
        if (v13 == 2)
        {
          if (!gLogDatapath) {
            goto LABEL_77;
          }
          BOOL v14 = __nwlog_obj();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_77;
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 2;
          os_log_type_t v15 = "%{public}s %{public}s Failing every 2nd request for get_output_frames";
          goto LABEL_148;
        }
        if (!v13)
        {
          if (!gLogDatapath) {
            goto LABEL_77;
          }
          BOOL v14 = __nwlog_obj();
          if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_77;
          }
          *(_DWORD *)long long buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 2;
          os_log_type_t v15 = "%{public}s %{public}s Failing every 4th request for get_output_frames";
LABEL_148:
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, v15, buf, 0x16u);
LABEL_77:
          if (a1[1].output_handler_context)
          {
            if (gLogDatapath)
            {
              os_log_type_t v63 = __nwlog_obj();
              if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)long long buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 2;
                _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Cancelling existing output frame failure timer", buf, 0x16u);
              }
            }
            nw_queue_cancel_source((uint64_t)a1[1].output_handler_context);
            a1[1].output_handler_context = 0;
          }
          v75[0] = MEMORY[0x1E4F143A8];
          v75[1] = 0x40000000;
          v75[2] = ___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
          v75[3] = &__block_descriptor_tmp_40_85611;
          v75[4] = (char *)a1 + 96;
          v75[5] = a1;
          uint64_t v34 = 0;
          a1[1].output_handler_context = (void *)nw_queue_context_create_source(0, 2, 3, 0, v75, 0);
          return v34;
        }
      }
      else
      {
        if (((unsigned __int16)output_handler & 0x100) == 0) {
          goto LABEL_15;
        }
        BYTE4(a1[3].identifier) = (BYTE4(a1[3].identifier) + 1) & 3;
      }
      if (((unsigned __int16)output_handler & 0x200) == 0 || (arc4random() & 0x80000000) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v16 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
        {
          *(_DWORD *)long long buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_INFO, "%{public}s Allowing request for get_output_frames to succeed", buf, 0xCu);
        }
LABEL_15:
        *(void *)long long buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3802000000;
        BOOL v81 = __Block_byref_object_copy__27;
        BOOL v82 = __Block_byref_object_dispose__28;
        v83[0] = 0;
        v83[1] = v83;
        uint64_t v17 = *p_output_handler;
        os_log_type_t v18 = a6;
        if ((*p_output_handler & 8) != 0)
        {
          if (gLogDatapath)
          {
            char v60 = __nwlog_obj();
            if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              *(void *)&os_log_type_t type[4] = "nw_protocol_test_get_output_frames";
              *(_WORD *)&type[12] = 2082;
              *(void *)&type[14] = a1 + 2;
              _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Splitting outgoing frames", type, 0x16u);
            }
          }
          os_log_type_t v18 = (nw_frame_array_s *)(*(void *)&buf[8] + 40);
          uint64_t v17 = *p_output_handler;
          if ((*p_output_handler & 0x2000) == 0)
          {
LABEL_17:
            BOOL v67 = a6;
            if ((v17 & 0x10000) == 0) {
              goto LABEL_31;
            }
            goto LABEL_29;
          }
        }
        else if ((v17 & 0x2000) == 0)
        {
          goto LABEL_17;
        }
        if (gLogDatapath)
        {
          long long v61 = __nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            *(void *)&os_log_type_t type[4] = "nw_protocol_test_get_output_frames";
            *(_WORD *)&type[12] = 2082;
            *(void *)&type[14] = a1 + 2;
            _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Capping send size at 1300", type, 0x16u);
          }
        }
        if (a4 >= 0x514) {
          a4 = 1300;
        }
        else {
          a4 = a4;
        }
        if (a3 >= 0x514) {
          a3 = 1300;
        }
        else {
          a3 = a3;
        }
        BOOL v67 = a6;
        if ((*p_output_handler & 0x10000) == 0)
        {
LABEL_31:
          uint64_t v19 = type;
          *(void *)os_log_type_t type = 0;
          *(void *)&os_log_type_t type[8] = type;
          int v79 = 0;
          *(void *)&os_log_type_t type[16] = 0x2000000000;
          char v20 = a1->output_handler;
          if (!v20)
          {
            char v22 = 0;
            goto LABEL_36;
          }
          uint64_t handle = v20->handle;
          if (handle == &nw_protocol_ref_counted_handle)
          {
            callbacks = v20[1].callbacks;
            if (callbacks) {
              v20[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
            }
            char v22 = -1;
            uint64_t v23 = v20->callbacks;
            if (!v23) {
              goto LABEL_106;
            }
          }
          else
          {
            char v22 = 0;
            uint64_t v23 = v20->callbacks;
            if (!v23) {
              goto LABEL_106;
            }
          }
          get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))v23->get_output_frames;
          if (!get_output_frames)
          {
LABEL_106:
            uint64_t v19 = type;
LABEL_36:
            char v24 = v67;
            if ((*(unsigned char *)p_output_handler & 8) == 0)
            {
LABEL_64:
              uint64_t v34 = *((unsigned int *)v19 + 6);
              if (v22)
              {
                if (v20)
                {
                  if (v20->handle == &nw_protocol_ref_counted_handle)
                  {
                    long long v35 = v20[1].callbacks;
                    if (v35)
                    {
                      os_log_type_t v36 = (nw_protocol_callbacks *)((char *)v35 - 1);
                      v20[1].callbacks = v36;
                      if (!v36)
                      {
                        BOOL v37 = *(void (***)(void, void))v20[1].flow_id;
                        if (v37)
                        {
                          *(void *)v20[1].flow_id = 0;
                          ((void (**)(void, nw_protocol *))v37)[2](v37, a2);
                          _Block_release(v37);
                        }
                        if (v20[1].flow_id[8])
                        {
                          BOOL v38 = *(const void **)v20[1].flow_id;
                          if (v38) {
                            _Block_release(v38);
                          }
                        }
                        free(v20);
                      }
                    }
                  }
                }
              }
              _Block_object_dispose(type, 8);
              _Block_object_dispose(buf, 8);
              return v34;
            }
LABEL_60:
            *((_DWORD *)v19 + 6) = 0;
            v68[0] = MEMORY[0x1E4F143A8];
            v68[1] = 0x40000000;
            os_log_type_t v69 = (uint64_t (*)(void *))___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_41;
            uint64_t v70 = &unk_1E524AD68;
            BOOL v73 = p_output_handler;
            os_log_type_t v74 = v24;
            os_log_type_t v71 = buf;
            BOOL v72 = type;
            a2 = *(nw_protocol **)(*(void *)&buf[8] + 40);
            do
            {
              if (!a2) {
                break;
              }
              os_log_type_t v32 = a2->output_handler;
              char v33 = v69(v68);
              a2 = v32;
            }
            while ((v33 & 1) != 0);
            uint64_t v19 = *(unsigned char **)&type[8];
            goto LABEL_64;
          }
          char v66 = v22;
          if (handle == &nw_protocol_ref_counted_handle)
          {
            os_log_type_t v27 = v20[1].callbacks;
            if (v27) {
              v20[1].callbacks = (nw_protocol_callbacks *)((char *)&v27->add_input_handler + 1);
            }
          }
          uint64_t v28 = a1->handle;
          if (v28 == &nw_protocol_ref_counted_handle)
          {
            BOOL v29 = a1[1].callbacks;
            if (v29) {
              a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
            }
          }
          if (v18)
          {
            int v30 = get_output_frames(v20, a1, a3, a4, a5, v18);
            goto LABEL_53;
          }
          __nwlog_obj();
          *(_DWORD *)BOOL v84 = 136446210;
          __int16 v85 = "__nw_protocol_get_output_frames";
          os_log_type_t v56 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t v77 = OS_LOG_TYPE_ERROR;
          char v76 = 0;
          if (__nwlog_fault(v56, &v77, &v76))
          {
            if (v77 == OS_LOG_TYPE_FAULT)
            {
              os_log_type_t v57 = __nwlog_obj();
              os_log_type_t v58 = v77;
              if (os_log_type_enabled(v57, v77))
              {
                *(_DWORD *)BOOL v84 = 136446210;
                __int16 v85 = "__nw_protocol_get_output_frames";
                os_log_type_t v59 = "%{public}s called with null return_array";
LABEL_153:
                _os_log_impl(&dword_1830D4000, v57, v58, v59, v84, 0xCu);
              }
            }
            else if (v76)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              os_log_type_t v57 = __nwlog_obj();
              os_log_type_t v58 = v77;
              BOOL v65 = os_log_type_enabled(v57, v77);
              if (backtrace_string)
              {
                if (v65)
                {
                  *(_DWORD *)BOOL v84 = 136446466;
                  __int16 v85 = "__nw_protocol_get_output_frames";
                  __int16 v86 = 2082;
                  __int16 v87 = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v57, v58, "%{public}s called with null return_array, dumping backtrace:%{public}s", v84, 0x16u);
                }
                free(backtrace_string);
                goto LABEL_154;
              }
              if (v65)
              {
                *(_DWORD *)BOOL v84 = 136446210;
                __int16 v85 = "__nw_protocol_get_output_frames";
                os_log_type_t v59 = "%{public}s called with null return_array, no backtrace";
                goto LABEL_153;
              }
            }
            else
            {
              os_log_type_t v57 = __nwlog_obj();
              os_log_type_t v58 = v77;
              if (os_log_type_enabled(v57, v77))
              {
                *(_DWORD *)BOOL v84 = 136446210;
                __int16 v85 = "__nw_protocol_get_output_frames";
                os_log_type_t v59 = "%{public}s called with null return_array, backtrace limit exceeded";
                goto LABEL_153;
              }
            }
          }
LABEL_154:
          if (v56) {
            free(v56);
          }
          int v30 = 0;
LABEL_53:
          BOOL v31 = v28 == &nw_protocol_ref_counted_handle;
          char v22 = v66;
          if (v31 && a1->handle == &nw_protocol_ref_counted_handle)
          {
            os_log_type_t v40 = a1[1].callbacks;
            if (v40)
            {
              char v41 = (nw_protocol_callbacks *)((char *)v40 - 1);
              a1[1].callbacks = v41;
              if (!v41)
              {
                os_log_type_t v42 = *(void (***)(void))a1[1].flow_id;
                if (v42)
                {
                  *(void *)a1[1].flow_id = 0;
                  v42[2](v42);
                  _Block_release(v42);
                }
                if (a1[1].flow_id[8])
                {
                  os_log_type_t v43 = *(const void **)a1[1].flow_id;
                  if (v43) {
                    _Block_release(v43);
                  }
                }
                free(a1);
              }
            }
          }
          BOOL v31 = handle == &nw_protocol_ref_counted_handle;
          char v24 = v67;
          if (v31 && v20->handle == &nw_protocol_ref_counted_handle)
          {
            long long v44 = v20[1].callbacks;
            if (v44)
            {
              __int16 v45 = (nw_protocol_callbacks *)((char *)v44 - 1);
              v20[1].callbacks = v45;
              if (!v45)
              {
                BOOL v46 = *(void (***)(void))v20[1].flow_id;
                if (v46)
                {
                  *(void *)v20[1].flow_id = 0;
                  v46[2](v46);
                  _Block_release(v46);
                }
                if (v20[1].flow_id[8])
                {
                  os_log_type_t v47 = *(const void **)v20[1].flow_id;
                  if (v47) {
                    _Block_release(v47);
                  }
                }
                free(v20);
              }
            }
          }
          uint64_t v19 = *(unsigned char **)&type[8];
          *(_DWORD *)(*(void *)&type[8] + 24) = v30;
          if ((*(unsigned char *)p_output_handler & 8) == 0) {
            goto LABEL_64;
          }
          goto LABEL_60;
        }
LABEL_29:
        if (gLogDatapath)
        {
          long long v62 = __nwlog_obj();
          if (os_log_type_enabled(v62, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            *(void *)&os_log_type_t type[4] = "nw_protocol_test_get_output_frames";
            *(_WORD *)&type[12] = 2082;
            *(void *)&type[14] = a1 + 2;
            _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Requesting UINT32_MAX output frame", type, 0x16u);
          }
        }
        a4 = 0xFFFFFFFFLL;
        goto LABEL_31;
      }
      if (!gLogDatapath) {
        goto LABEL_77;
      }
      BOOL v14 = __nwlog_obj();
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_77;
      }
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 2;
      os_log_type_t v15 = "%{public}s %{public}s Failing random request for get_output_frames";
      goto LABEL_148;
    }
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
    uint64_t v48 = (char *)_os_log_send_and_compose_impl();
    type[0] = 16;
    v84[0] = 0;
    if (!__nwlog_fault(v48, type, v84)) {
      goto LABEL_143;
    }
    if (type[0] == 17)
    {
      __int16 v49 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
        uint64_t v51 = "%{public}s called with null test";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    if (!v84[0])
    {
      __int16 v49 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
        uint64_t v51 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    uint64_t v52 = (char *)__nw_create_backtrace_string();
    __int16 v49 = __nwlog_obj();
    os_log_type_t v50 = type[0];
    BOOL v55 = os_log_type_enabled(v49, (os_log_type_t)type[0]);
    if (!v52)
    {
      if (v55)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
        uint64_t v51 = "%{public}s called with null test, no backtrace";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    if (v55)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v52;
      long long v54 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_115;
    }
    goto LABEL_116;
  }
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
  uint64_t v48 = (char *)_os_log_send_and_compose_impl();
  type[0] = 16;
  v84[0] = 0;
  if (!__nwlog_fault(v48, type, v84)) {
    goto LABEL_143;
  }
  if (type[0] != 17)
  {
    if (!v84[0])
    {
      __int16 v49 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
        uint64_t v51 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    uint64_t v52 = (char *)__nw_create_backtrace_string();
    __int16 v49 = __nwlog_obj();
    os_log_type_t v50 = type[0];
    BOOL v53 = os_log_type_enabled(v49, (os_log_type_t)type[0]);
    if (!v52)
    {
      if (v53)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
        uint64_t v51 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_142;
      }
      goto LABEL_143;
    }
    if (v53)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v52;
      long long v54 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_115:
      _os_log_impl(&dword_1830D4000, v49, v50, v54, buf, 0x16u);
    }
LABEL_116:
    free(v52);
    goto LABEL_143;
  }
  __int16 v49 = __nwlog_obj();
  os_log_type_t v50 = type[0];
  if (os_log_type_enabled(v49, (os_log_type_t)type[0]))
  {
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_get_output_frames";
    uint64_t v51 = "%{public}s called with null protocol";
LABEL_142:
    _os_log_impl(&dword_1830D4000, v49, v50, v51, buf, 0xCu);
  }
LABEL_143:
  if (v48) {
    free(v48);
  }
  return 0;
}

void ___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    char v24 = __nwlog_obj();
    if (os_log_type_enabled(v24, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v25 = *(void *)(a1 + 32);
      if (v25) {
        os_log_type_t v26 = (const char *)(v25 + 32);
      }
      else {
        os_log_type_t v26 = "";
      }
      *(_DWORD *)long long buf = 136446466;
      BOOL v46 = "nw_protocol_test_get_output_frames_block_invoke";
      __int16 v47 = 2082;
      uint64_t v48 = (void *)v26;
      _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Calling output_available", buf, 0x16u);
    }
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "__nw_protocol_get_input_handler";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (!__nwlog_fault(v27, &type, &v43)) {
      goto LABEL_79;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v46 = "__nw_protocol_get_input_handler";
      int v30 = "%{public}s called with null protocol";
    }
    else if (v43)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v35 = os_log_type_enabled(v28, type);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)long long buf = 136446466;
          BOOL v46 = "__nw_protocol_get_input_handler";
          __int16 v47 = 2082;
          uint64_t v48 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_79;
      }
      if (!v35)
      {
LABEL_79:
        if (v27) {
          free(v27);
        }
        goto LABEL_81;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v46 = "__nw_protocol_get_input_handler";
      int v30 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (!os_log_type_enabled(v28, type)) {
        goto LABEL_79;
      }
      *(_DWORD *)long long buf = 136446210;
      BOOL v46 = "__nw_protocol_get_input_handler";
      int v30 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
    goto LABEL_79;
  }
  uint64_t v3 = *(void *)(v2 + 48);
  if (v3)
  {
    os_log_type_t v4 = *(void **)(v3 + 40);
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = *(void *)(v3 + 88);
      if (v5) {
        *(void *)(v3 + 88) = v5 + 1;
      }
    }
    os_log_type_t v6 = *(void **)(v2 + 40);
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *(void *)(v2 + 88);
      if (v7) {
        *(void *)(v2 + 88) = v7 + 1;
      }
    }
    uint64_t v8 = *(void *)(v3 + 24);
    if (v8)
    {
      BOOL v9 = *(void (**)(uint64_t, uint64_t))(v8 + 72);
      if (v9)
      {
        v9(v3, v2);
        goto LABEL_13;
      }
    }
    __nwlog_obj();
    os_log_type_t v18 = *(const char **)(v3 + 16);
    *(_DWORD *)long long buf = 136446722;
    BOOL v46 = "__nw_protocol_output_available";
    if (!v18) {
      os_log_type_t v18 = "invalid";
    }
    __int16 v47 = 2082;
    uint64_t v48 = (void *)v18;
    __int16 v49 = 2048;
    uint64_t v50 = v3;
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v43 = 0;
    if (__nwlog_fault(v19, &type, &v43))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_72;
        }
        char v22 = *(const char **)(v3 + 16);
        if (!v22) {
          char v22 = "invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        BOOL v46 = "__nw_protocol_output_available";
        __int16 v47 = 2082;
        uint64_t v48 = (void *)v22;
        __int16 v49 = 2048;
        uint64_t v50 = v3;
        uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback";
        goto LABEL_71;
      }
      if (!v43)
      {
        char v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_72;
        }
        os_log_type_t v36 = *(const char **)(v3 + 16);
        if (!v36) {
          os_log_type_t v36 = "invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        BOOL v46 = "__nw_protocol_output_available";
        __int16 v47 = 2082;
        uint64_t v48 = (void *)v36;
        __int16 v49 = 2048;
        uint64_t v50 = v3;
        uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded";
        goto LABEL_71;
      }
      BOOL v31 = (char *)__nw_create_backtrace_string();
      char v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          char v33 = *(const char **)(v3 + 16);
          if (!v33) {
            char v33 = "invalid";
          }
          *(_DWORD *)long long buf = 136446978;
          BOOL v46 = "__nw_protocol_output_available";
          __int16 v47 = 2082;
          uint64_t v48 = (void *)v33;
          __int16 v49 = 2048;
          uint64_t v50 = v3;
          __int16 v51 = 2082;
          uint64_t v52 = v31;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v31);
        goto LABEL_72;
      }
      if (v32)
      {
        BOOL v37 = *(const char **)(v3 + 16);
        if (!v37) {
          BOOL v37 = "invalid";
        }
        *(_DWORD *)long long buf = 136446722;
        BOOL v46 = "__nw_protocol_output_available";
        __int16 v47 = 2082;
        uint64_t v48 = (void *)v37;
        __int16 v49 = 2048;
        uint64_t v50 = v3;
        uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace";
LABEL_71:
        _os_log_impl(&dword_1830D4000, v20, v21, v23, buf, 0x20u);
      }
    }
LABEL_72:
    if (v19) {
      free(v19);
    }
LABEL_13:
    if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v10 = *(void *)(v2 + 88);
      if (v10)
      {
        uint64_t v11 = v10 - 1;
        *(void *)(v2 + 88) = v11;
        if (!v11)
        {
          char v12 = *(void (***)(void))(v2 + 64);
          if (v12)
          {
            *(void *)(v2 + 64) = 0;
            v12[2](v12);
            _Block_release(v12);
          }
          if (*(unsigned char *)(v2 + 72))
          {
            int v13 = *(const void **)(v2 + 64);
            if (v13) {
              _Block_release(v13);
            }
          }
          free((void *)v2);
        }
      }
    }
    if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v14 = *(void *)(v3 + 88);
      if (v14)
      {
        uint64_t v15 = v14 - 1;
        *(void *)(v3 + 88) = v15;
        if (!v15)
        {
          uint64_t v16 = *(void (***)(void))(v3 + 64);
          if (v16)
          {
            *(void *)(v3 + 64) = 0;
            v16[2](v16);
            _Block_release(v16);
          }
          if (*(unsigned char *)(v3 + 72))
          {
            uint64_t v17 = *(const void **)(v3 + 64);
            if (v17) {
              _Block_release(v17);
            }
          }
          goto LABEL_33;
        }
      }
    }
    return;
  }
LABEL_81:
  __nwlog_obj();
  *(_DWORD *)long long buf = 136446210;
  BOOL v46 = "__nw_protocol_output_available";
  uint64_t v3 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v43 = 0;
  if (!__nwlog_fault((const char *)v3, &type, &v43)) {
    goto LABEL_96;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "__nw_protocol_output_available";
    os_log_type_t v40 = "%{public}s called with null protocol";
  }
  else if (v43)
  {
    char v41 = (char *)__nw_create_backtrace_string();
    BOOL v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    BOOL v42 = os_log_type_enabled(v38, type);
    if (v41)
    {
      if (v42)
      {
        *(_DWORD *)long long buf = 136446466;
        BOOL v46 = "__nw_protocol_output_available";
        __int16 v47 = 2082;
        uint64_t v48 = v41;
        _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v41);
      if (v3) {
        goto LABEL_33;
      }
      return;
    }
    if (!v42) {
      goto LABEL_96;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "__nw_protocol_output_available";
    os_log_type_t v40 = "%{public}s called with null protocol, no backtrace";
  }
  else
  {
    BOOL v38 = __nwlog_obj();
    os_log_type_t v39 = type;
    if (!os_log_type_enabled(v38, type)) {
      goto LABEL_96;
    }
    *(_DWORD *)long long buf = 136446210;
    BOOL v46 = "__nw_protocol_output_available";
    os_log_type_t v40 = "%{public}s called with null protocol, backtrace limit exceeded";
  }
  _os_log_impl(&dword_1830D4000, v38, v39, v40, buf, 0xCu);
LABEL_96:
  if (v3) {
LABEL_33:
  }
    free((void *)v3);
}

__n128 __Block_byref_object_copy__27(uint64_t a1, uint64_t a2)
{
  __n128 result = *(__n128 *)(a2 + 40);
  *(__n128 *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZL34nw_protocol_test_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_41(void *a1, uint64_t a2)
{
  uint64_t v2 = (_DWORD *)a2;
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a2 + 32);
  uint64_t v5 = *(void **)(a2 + 40);
  if (v4)
  {
    *(void *)(v4 + 40) = v5;
    uint64_t v5 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1[4] + 8) + 48) = v5;
  }
  *uint64_t v5 = v4;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  unsigned int v6 = nw_frame_unclaimed_length((_DWORD *)a2);
  char v24 = v2;
  if (gLogDatapath)
  {
    uint64_t v17 = __nwlog_obj();
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v18 = a1[6];
      BOOL v19 = v18 == 0;
      *(_DWORD *)long long buf = 136446978;
      char v20 = (const char *)(v18 + 32);
      os_log_type_t v26 = "nw_protocol_test_get_output_frames_block_invoke";
      if (v19) {
        char v20 = "";
      }
      __int16 v27 = 2082;
      uint64_t v28 = v20;
      __int16 v29 = 1024;
      unsigned int v30 = v6;
      __int16 v31 = 1024;
      int v32 = 11;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Splitting frame of size %u into chunks of size %u", buf, 0x22u);
    }
  }
  if (v6 >= 0xC)
  {
    do
    {
      uint64_t v7 = nw_frame_split((uint64_t *)&v24, 0xBu);
      unsigned int v8 = nw_frame_unclaimed_length(v24);
      uint64_t v9 = a1[7];
      *(void *)(v7 + 32) = 0;
      uint64_t v10 = *(uint64_t **)(v9 + 8);
      *(void *)(v7 + 40) = v10;
      *uint64_t v10 = v7;
      *(void *)(v9 + 8) = v7 + 32;
      ++*(_DWORD *)(*(void *)(a1[5] + 8) + 24);
      if (gLogDatapath)
      {
        os_log_t log = __nwlog_obj();
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v11 = a1[6];
          if (v11) {
            char v12 = (const char *)(v11 + 32);
          }
          else {
            char v12 = "";
          }
          os_log_type_t v21 = v12;
          unsigned int v22 = *(_DWORD *)(*(void *)(a1[5] + 8) + 24);
          int v13 = nw_frame_unclaimed_length((_DWORD *)v7);
          *(_DWORD *)long long buf = 136447234;
          os_log_type_t v26 = "nw_protocol_test_get_output_frames_block_invoke";
          __int16 v27 = 2082;
          uint64_t v28 = v21;
          __int16 v29 = 1024;
          unsigned int v30 = v22;
          __int16 v31 = 1024;
          int v32 = v13;
          __int16 v33 = 1024;
          unsigned int v34 = v8;
          _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Split frame into small frame %u of size %u, remaining frame of size %u", buf, 0x28u);
        }
      }
    }
    while (v8 > 0xB);
    uint64_t v2 = v24;
  }
  uint64_t v14 = a1[7];
  *((void *)v2 + 4) = 0;
  uint64_t v15 = *(void **)(v14 + 8);
  *((void *)v2 + 5) = v15;
  void *v15 = v2;
  *(void *)(v14 + 8) = v2 + 8;
  ++*(_DWORD *)(*(void *)(a1[5] + 8) + 24);
  return 1;
}

uint64_t nw_protocol_test_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v327 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
    uint64_t v138 = (char *)_os_log_send_and_compose_impl();
    v313[0] = 16;
    v320[0] = 0;
    if (!__nwlog_fault(v138, v313, v320)) {
      goto LABEL_272;
    }
    if (v313[0] == 17)
    {
      id v135 = __nwlog_obj();
      os_log_type_t v136 = v313[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v313[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        BOOL v137 = "%{public}s called with null protocol";
LABEL_271:
        _os_log_impl(&dword_1830D4000, v135, v136, v137, buf, 0xCu);
      }
LABEL_272:
      if (v138) {
        free(v138);
      }
      return 0;
    }
    if (!v320[0])
    {
      id v135 = __nwlog_obj();
      os_log_type_t v136 = v313[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v313[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        BOOL v137 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v135 = __nwlog_obj();
    os_log_type_t v136 = v313[0];
    BOOL v141 = os_log_type_enabled(v135, (os_log_type_t)v313[0]);
    if (!backtrace_string)
    {
      if (v141)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        BOOL v137 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    if (v141)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v142 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_235:
      _os_log_impl(&dword_1830D4000, v135, v136, v142, buf, 0x16u);
    }
LABEL_236:
    free(backtrace_string);
    goto LABEL_272;
  }
  uint64_t handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    uint64_t v9 = &a1[1].output_handler;
  }
  else {
    uint64_t v9 = 0;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)long long buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
    uint64_t v138 = (char *)_os_log_send_and_compose_impl();
    v313[0] = 16;
    v320[0] = 0;
    if (!__nwlog_fault(v138, v313, v320)) {
      goto LABEL_272;
    }
    if (v313[0] == 17)
    {
      id v135 = __nwlog_obj();
      os_log_type_t v136 = v313[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v313[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        BOOL v137 = "%{public}s called with null test";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    if (!v320[0])
    {
      id v135 = __nwlog_obj();
      os_log_type_t v136 = v313[0];
      if (os_log_type_enabled(v135, (os_log_type_t)v313[0]))
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        BOOL v137 = "%{public}s called with null test, backtrace limit exceeded";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v135 = __nwlog_obj();
    os_log_type_t v136 = v313[0];
    BOOL v145 = os_log_type_enabled(v135, (os_log_type_t)v313[0]);
    if (!backtrace_string)
    {
      if (v145)
      {
        *(_DWORD *)long long buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        BOOL v137 = "%{public}s called with null test, no backtrace";
        goto LABEL_271;
      }
      goto LABEL_272;
    }
    if (v145)
    {
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v142 = "%{public}s called with null test, dumping backtrace:%{public}s";
      goto LABEL_235;
    }
    goto LABEL_236;
  }
  uint64_t v11 = *p_output_handler;
  if ((*p_output_handler & 0x400) != 0)
  {
    if (a3 <= 0xA) {
      size_t v14 = 10;
    }
    else {
      size_t v14 = a3;
    }
    uint64_t v15 = malloc_type_malloc(v14, 0xF2B69DE5uLL);
    if (v15)
    {
      uint64_t v16 = (uint64_t)v15;
    }
    else
    {
      uint64_t v143 = __nwlog_obj();
      os_log_type_enabled(v143, OS_LOG_TYPE_ERROR);
      *(_DWORD *)long long buf = 136446466;
      *(void *)&uint8_t buf[4] = "strict_malloc";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v14;
      int v144 = (void *)_os_log_send_and_compose_impl();
      uint64_t result = __nwlog_abort((uint64_t)v144);
      if (result) {
        goto LABEL_479;
      }
      free(v144);
      uint64_t v16 = 0;
    }
    uint64_t v17 = nw_frame_create(0, v16, v14, (uint64_t)__nw_frame_malloc_finalizer, 0);
    uint64_t v18 = 1;
    nw_frame_set_buffer_used_malloc(v17, 1);
    *(void *)(v17 + 32) = 0;
    tqh_last = a6->tqh_last;
    *(void *)(v17 + 40) = tqh_last;
    *tqh_last = (nw_frame *)v17;
    a6->tqh_last = (nw_frame **)(v17 + 32);
    if (gLogDatapath)
    {
      char v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)long long buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 2;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Returning input frame of length 10 with empty metadata", buf, 0x16u);
      }
    }
    return v18;
  }
  if ((v11 & 0x800) == 0)
  {
    if ((v11 & 2) != 0)
    {
      if (gLogDatapath)
      {
        int v163 = __nwlog_obj();
        if (os_log_type_enabled(v163, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 2;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v317) = a4;
          _os_log_impl(&dword_1830D4000, v163, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Overriding max bytes of %u to UINT32_MAX", buf, 0x1Cu);
        }
      }
    }
    else if ((v11 & 0x40) != 0)
    {
      if (gLogDatapath)
      {
        BOOL v176 = __nwlog_obj();
        if (os_log_type_enabled(v176, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)long long buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_test_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 2;
          *(_WORD *)&buf[22] = 1024;
          LODWORD(v317) = a4;
          _os_log_impl(&dword_1830D4000, v176, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Overriding max bytes of %u to 1", buf, 0x1Cu);
        }
      }
    }
    *(void *)long long buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3802000000;
    uint64_t v317 = __Block_byref_object_copy__27;
    v318 = __Block_byref_object_dispose__28;
    v319[0] = 0;
    v319[1] = v319;
    uint64_t v31 = *p_output_handler;
    int v268 = a4;
    if ((*p_output_handler & 4) != 0)
    {
      if (!gLogDatapath) {
        goto LABEL_37;
      }
      __int16 v33 = __nwlog_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_37;
      }
      *(_DWORD *)uint64_t v313 = 136446466;
      *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v313[12] = 2082;
      *(void *)&v313[14] = a1 + 2;
      unsigned int v34 = "%{public}s %{public}s Splitting incoming frames";
    }
    else if ((v31 & 0x10) != 0)
    {
      if (!gLogDatapath) {
        goto LABEL_37;
      }
      __int16 v33 = __nwlog_obj();
      if (!os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_37;
      }
      *(_DWORD *)uint64_t v313 = 136446466;
      *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v313[12] = 2082;
      *(void *)&v313[14] = a1 + 2;
      unsigned int v34 = "%{public}s %{public}s Using custom frame allocator on incoming frames";
    }
    else
    {
      int v32 = a6;
      if ((v31 & 0x20) == 0) {
        goto LABEL_38;
      }
      if (!gLogDatapath || (__int16 v33 = __nwlog_obj(), !os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG)))
      {
LABEL_37:
        int v32 = (nw_frame_array_s *)(*(void *)&buf[8] + 40);
LABEL_38:
        output_handler = a1->output_handler;
        nw_endpoint_t v271 = output_handler;
        if (!output_handler)
        {
          char v270 = 0;
          os_log_type_t v36 = &v305;
          uint64_t v305 = 0;
          os_log_type_t v306 = &v305;
          int v308 = 0;
          uint64_t v307 = 0x2000000000;
          goto LABEL_62;
        }
        if (output_handler->handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          uint64_t v305 = 0;
          char v270 = -1;
        }
        else
        {
          char v270 = 0;
          uint64_t v305 = 0;
        }
        os_log_type_t v36 = &v305;
        int v308 = 0;
        os_log_type_t v306 = &v305;
        uint64_t v307 = 0x2000000000;
        BOOL v38 = output_handler->callbacks;
        if (!v38)
        {
LABEL_62:
          uint64_t v46 = *p_output_handler;
          __int16 v47 = &unk_183D5C000;
          if ((*p_output_handler & 4) != 0)
          {
            *((_DWORD *)v36 + 6) = 0;
            v298[0] = MEMORY[0x1E4F143A8];
            v298[1] = 0x40000000;
            os_log_type_t v299 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            uint64_t v300 = &unk_1E524AC88;
            __int16 v303 = p_output_handler;
            os_log_type_t v304 = a6;
            __int16 v301 = buf;
            int v302 = &v305;
            uint64_t v49 = *(void *)(*(void *)&buf[8] + 40);
            do
            {
              if (!v49) {
                break;
              }
              uint64_t v50 = *(void *)(v49 + 32);
              char v51 = v299(v298);
              uint64_t v49 = v50;
            }
            while ((v51 & 1) != 0);
          }
          else if ((v46 & 0x10) != 0)
          {
            *((_DWORD *)v36 + 6) = 0;
            v291[0] = MEMORY[0x1E4F143A8];
            v291[1] = 0x40000000;
            uint64_t v292 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_31;
            uint64_t v293 = &unk_1E524ACB0;
            uint64_t v296 = p_output_handler;
            uint64_t v297 = a6;
            uint64_t v294 = buf;
            int v295 = &v305;
            uint64_t v52 = *(void *)(*(void *)&buf[8] + 40);
            do
            {
              if (!v52) {
                break;
              }
              uint64_t v53 = *(void *)(v52 + 32);
              char v54 = v292(v291);
              uint64_t v52 = v53;
            }
            while ((v54 & 1) != 0);
          }
          else
          {
            if ((v46 & 0x20) == 0)
            {
              if ((v46 & 0x1000) == 0) {
                goto LABEL_137;
              }
              if (a2)
              {
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  char v66 = a2[1].callbacks;
                  if (v66) {
                    a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v66->add_input_handler + 1);
                  }
                  *(void *)int v320 = a2;
                  char v48 = v320[8] | 1;
                }
                else
                {
                  *(void *)int v320 = a2;
                  char v48 = v320[8] & 0xFE;
                }
                v320[8] = v48;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  os_log_type_t v68 = a1[1].callbacks;
                  if (v68) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v68->add_input_handler + 1);
                  }
                  *(void *)uint64_t v311 = a1;
                  char v67 = v312 | 1;
                }
                else
                {
                  *(void *)uint64_t v311 = a1;
                  char v67 = v312 & 0xFE;
                }
                char v312 = v67;
                os_log_type_t v69 = a2->callbacks;
                if (v69)
                {
                  error = (void (*)(nw_protocol *, nw_protocol *, uint64_t))v69->error;
                  if (error)
                  {
                    error(a2, a1, 14);
                    goto LABEL_108;
                  }
                }
                __nwlog_obj();
                identifier = a2->identifier;
                *(_DWORD *)uint64_t v313 = 136446722;
                *(void *)&v313[4] = "__nw_protocol_error";
                if (!identifier) {
                  identifier = (nw_protocol_identifier *)"invalid";
                }
                *(_WORD *)&v313[12] = 2082;
                *(void *)&v313[14] = identifier;
                *(_WORD *)&v313[22] = 2048;
                *(void *)v314 = a2;
                uint64_t v186 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t v310 = OS_LOG_TYPE_ERROR;
                char v309 = 0;
                if (__nwlog_fault(v186, &v310, &v309))
                {
                  if (v310 == OS_LOG_TYPE_FAULT)
                  {
                    uint64_t v187 = __nwlog_obj();
                    os_log_type_t v188 = v310;
                    if (os_log_type_enabled(v187, v310))
                    {
                      __int16 v189 = a2->identifier;
                      if (!v189) {
                        __int16 v189 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_error";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v189;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = a2;
                      uint64_t v190 = "%{public}s protocol %{public}s (%p) has invalid error callback";
LABEL_411:
                      __int16 v243 = v187;
LABEL_412:
                      _os_log_impl(&dword_1830D4000, v243, v188, v190, v313, 0x20u);
                    }
                  }
                  else if (v309)
                  {
                    uint64_t v222 = (char *)__nw_create_backtrace_string();
                    int v223 = __nwlog_obj();
                    os_log_type_t v188 = v310;
                    int v264 = v223;
                    BOOL v224 = os_log_type_enabled(v223, v310);
                    if (v222)
                    {
                      if (v224)
                      {
                        int v225 = a2->identifier;
                        if (!v225) {
                          int v225 = (nw_protocol_identifier *)"invalid";
                        }
                        *(_DWORD *)uint64_t v313 = 136446978;
                        *(void *)&v313[4] = "__nw_protocol_error";
                        *(_WORD *)&v313[12] = 2082;
                        *(void *)&v313[14] = v225;
                        *(_WORD *)&v313[22] = 2048;
                        *(void *)v314 = a2;
                        *(_WORD *)&v314[8] = 2082;
                        *(void *)&v314[10] = v222;
                        _os_log_impl(&dword_1830D4000, v264, v188, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", v313, 0x2Au);
                      }
                      free(v222);
                      goto LABEL_413;
                    }
                    if (v224)
                    {
                      int v248 = a2->identifier;
                      if (!v248) {
                        int v248 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_error";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v248;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = a2;
                      uint64_t v190 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
                      __int16 v243 = v264;
                      goto LABEL_412;
                    }
                  }
                  else
                  {
                    uint64_t v187 = __nwlog_obj();
                    os_log_type_t v188 = v310;
                    if (os_log_type_enabled(v187, v310))
                    {
                      BOOL v242 = a2->identifier;
                      if (!v242) {
                        BOOL v242 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_error";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v242;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = a2;
                      uint64_t v190 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
                      goto LABEL_411;
                    }
                  }
                }
LABEL_413:
                if (v186) {
                  free(v186);
                }
                __int16 v47 = (void *)&unk_183D5C000;
LABEL_108:
                nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v311);
                nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v320);
                if (a2->handle == &nw_protocol_ref_counted_handle)
                {
                  BOOL v72 = a2[1].callbacks;
                  if (v72) {
                    a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v72->add_input_handler + 1);
                  }
                  *(void *)int v320 = a2;
                  char v71 = v320[8] | 1;
                }
                else
                {
                  *(void *)int v320 = a2;
                  char v71 = v320[8] & 0xFE;
                }
                v320[8] = v71;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  os_log_type_t v74 = a1[1].callbacks;
                  if (v74) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v74->add_input_handler + 1);
                  }
                  *(void *)uint64_t v311 = a1;
                  char v73 = v312 | 1;
                }
                else
                {
                  *(void *)uint64_t v311 = a1;
                  char v73 = v312 & 0xFE;
                }
                char v312 = v73;
                unsigned int v75 = a2->callbacks;
                if (v75)
                {
                  disconnected = (void (*)(nw_protocol *, nw_protocol *))v75->disconnected;
                  if (disconnected)
                  {
                    disconnected(a2, a1);
LABEL_121:
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v311);
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v320);
                    goto LABEL_122;
                  }
                }
                __nwlog_obj();
                __int16 v191 = a2->identifier;
                *(_DWORD *)uint64_t v313 = 136446722;
                *(void *)&v313[4] = "__nw_protocol_disconnected";
                if (!v191) {
                  __int16 v191 = (nw_protocol_identifier *)"invalid";
                }
                *(_WORD *)&v313[12] = 2082;
                *(void *)&v313[14] = v191;
                *(_WORD *)&v313[22] = 2048;
                *(void *)v314 = a2;
                uint64_t v192 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t v310 = OS_LOG_TYPE_ERROR;
                char v309 = 0;
                if (__nwlog_fault(v192, &v310, &v309))
                {
                  if (v310 == OS_LOG_TYPE_FAULT)
                  {
                    __int16 v193 = __nwlog_obj();
                    os_log_type_t v194 = v310;
                    if (os_log_type_enabled(v193, v310))
                    {
                      __int16 v195 = a2->identifier;
                      if (!v195) {
                        __int16 v195 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_disconnected";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v195;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = a2;
                      uint64_t v196 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback";
LABEL_420:
                      __int16 v245 = v193;
LABEL_421:
                      _os_log_impl(&dword_1830D4000, v245, v194, v196, v313, 0x20u);
                    }
                  }
                  else if (v309)
                  {
                    BOOL v226 = (char *)__nw_create_backtrace_string();
                    int v227 = __nwlog_obj();
                    os_log_type_t v194 = v310;
                    int v265 = v227;
                    BOOL v228 = os_log_type_enabled(v227, v310);
                    if (v226)
                    {
                      if (v228)
                      {
                        int v229 = a2->identifier;
                        if (!v229) {
                          int v229 = (nw_protocol_identifier *)"invalid";
                        }
                        *(_DWORD *)uint64_t v313 = 136446978;
                        *(void *)&v313[4] = "__nw_protocol_disconnected";
                        *(_WORD *)&v313[12] = 2082;
                        *(void *)&v313[14] = v229;
                        *(_WORD *)&v313[22] = 2048;
                        *(void *)v314 = a2;
                        *(_WORD *)&v314[8] = 2082;
                        *(void *)&v314[10] = v226;
                        _os_log_impl(&dword_1830D4000, v265, v194, "%{public}s protocol %{public}s (%p) has invalid disconnected callback, dumping backtrace:%{public}s", v313, 0x2Au);
                      }
                      free(v226);
                      goto LABEL_422;
                    }
                    if (v228)
                    {
                      unsigned int v249 = a2->identifier;
                      if (!v249) {
                        unsigned int v249 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_disconnected";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v249;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = a2;
                      uint64_t v196 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, no backtrace";
                      __int16 v245 = v265;
                      goto LABEL_421;
                    }
                  }
                  else
                  {
                    __int16 v193 = __nwlog_obj();
                    os_log_type_t v194 = v310;
                    if (os_log_type_enabled(v193, v310))
                    {
                      os_log_type_t v244 = a2->identifier;
                      if (!v244) {
                        os_log_type_t v244 = (nw_protocol_identifier *)"invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_disconnected";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v244;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = a2;
                      uint64_t v196 = "%{public}s protocol %{public}s (%p) has invalid disconnected callback, backtrace limit exceeded";
                      goto LABEL_420;
                    }
                  }
                }
LABEL_422:
                if (v192) {
                  free(v192);
                }
                __int16 v47 = (void *)&unk_183D5C000;
                goto LABEL_121;
              }
              __nwlog_obj();
              *(_DWORD *)uint64_t v313 = 136446210;
              *(void *)&v313[4] = "__nw_protocol_error";
              __int16 v214 = (char *)_os_log_send_and_compose_impl();
              v320[0] = 16;
              v311[0] = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v214, v320, v311))
              {
                if (v320[0] == 17)
                {
                  int v215 = __nwlog_obj();
                  os_log_type_t v216 = v320[0];
                  if (!os_log_type_enabled(v215, (os_log_type_t)v320[0])) {
                    goto LABEL_453;
                  }
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_error";
                  uint64_t v217 = "%{public}s called with null protocol";
LABEL_452:
                  _os_log_impl(&dword_1830D4000, v215, v216, v217, v313, 0xCu);
                  goto LABEL_453;
                }
                if (v311[0] == OS_LOG_TYPE_DEFAULT)
                {
                  int v215 = __nwlog_obj();
                  os_log_type_t v216 = v320[0];
                  if (!os_log_type_enabled(v215, (os_log_type_t)v320[0])) {
                    goto LABEL_453;
                  }
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_error";
                  uint64_t v217 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_452;
                }
                int v237 = (char *)__nw_create_backtrace_string();
                int v215 = __nwlog_obj();
                os_log_type_t v216 = v320[0];
                BOOL v238 = os_log_type_enabled(v215, (os_log_type_t)v320[0]);
                if (!v237)
                {
                  if (!v238) {
                    goto LABEL_453;
                  }
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_error";
                  uint64_t v217 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_452;
                }
                if (v238)
                {
                  *(_DWORD *)uint64_t v313 = 136446466;
                  *(void *)&v313[4] = "__nw_protocol_error";
                  *(_WORD *)&v313[12] = 2082;
                  *(void *)&v313[14] = v237;
                  _os_log_impl(&dword_1830D4000, v215, v216, "%{public}s called with null protocol, dumping backtrace:%{public}s", v313, 0x16u);
                }
                free(v237);
              }
LABEL_453:
              if (v214) {
                free(v214);
              }
              __nwlog_obj();
              *(_DWORD *)uint64_t v313 = 136446210;
              *(void *)&v313[4] = "__nw_protocol_disconnected";
              char v251 = (char *)_os_log_send_and_compose_impl();
              v320[0] = 16;
              v311[0] = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v251, v320, v311)) {
                goto LABEL_476;
              }
              if (v320[0] == 17)
              {
                os_log_type_t v252 = __nwlog_obj();
                os_log_type_t v253 = v320[0];
                if (os_log_type_enabled(v252, (os_log_type_t)v320[0]))
                {
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_disconnected";
                  int v254 = "%{public}s called with null protocol";
LABEL_475:
                  _os_log_impl(&dword_1830D4000, v252, v253, v254, v313, 0xCu);
                }
              }
              else if (v311[0])
              {
                int v255 = (char *)__nw_create_backtrace_string();
                os_log_type_t v252 = __nwlog_obj();
                os_log_type_t v253 = v320[0];
                BOOL v256 = os_log_type_enabled(v252, (os_log_type_t)v320[0]);
                if (v255)
                {
                  if (v256)
                  {
                    *(_DWORD *)uint64_t v313 = 136446466;
                    *(void *)&v313[4] = "__nw_protocol_disconnected";
                    *(_WORD *)&v313[12] = 2082;
                    *(void *)&v313[14] = v255;
                    _os_log_impl(&dword_1830D4000, v252, v253, "%{public}s called with null protocol, dumping backtrace:%{public}s", v313, 0x16u);
                  }
                  free(v255);
                  goto LABEL_476;
                }
                if (v256)
                {
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_disconnected";
                  int v254 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_475;
                }
              }
              else
              {
                os_log_type_t v252 = __nwlog_obj();
                os_log_type_t v253 = v320[0];
                if (os_log_type_enabled(v252, (os_log_type_t)v320[0]))
                {
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_disconnected";
                  int v254 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_475;
                }
              }
LABEL_476:
              if (v251) {
                free(v251);
              }
              __int16 v47 = (void *)&unk_183D5C000;
LABEL_122:
              os_log_type_t v77 = a1->output_handler;
              if (v77)
              {
                if (v77->handle == &nw_protocol_ref_counted_handle)
                {
                  int v79 = v77[1].callbacks;
                  if (v79) {
                    v77[1].callbacks = (nw_protocol_callbacks *)((char *)&v79->add_input_handler + 1);
                  }
                  *(void *)int v320 = v77;
                  char v78 = v320[8] | 1;
                }
                else
                {
                  *(void *)int v320 = a1->output_handler;
                  char v78 = v320[8] & 0xFE;
                }
                v320[8] = v78;
                if (a1->handle == &nw_protocol_ref_counted_handle)
                {
                  BOOL v81 = a1[1].callbacks;
                  if (v81) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v81->add_input_handler + 1);
                  }
                  *(void *)uint64_t v311 = a1;
                  char v80 = v312 | 1;
                }
                else
                {
                  *(void *)uint64_t v311 = a1;
                  char v80 = v312 & 0xFE;
                }
                char v312 = v80;
                BOOL v82 = v77->callbacks;
                if (v82)
                {
                  disconnect = (void (*)(nw_protocol *, nw_protocol *))v82->disconnect;
                  if (disconnect)
                  {
                    disconnect(v77, a1);
LABEL_136:
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v311);
                    nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)v320);
                    goto LABEL_137;
                  }
                }
                __nwlog_obj();
                name = v77->identifier->name;
                *(_DWORD *)uint64_t v313 = 136446722;
                *(void *)&v313[4] = "__nw_protocol_disconnect";
                if (!name) {
                  name = "invalid";
                }
                *(_WORD *)&v313[12] = 2082;
                *(void *)&v313[14] = name;
                *(_WORD *)&v313[22] = 2048;
                *(void *)v314 = v77;
                int v198 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t v310 = OS_LOG_TYPE_ERROR;
                char v309 = 0;
                if (__nwlog_fault(v198, &v310, &v309))
                {
                  if (v310 == OS_LOG_TYPE_FAULT)
                  {
                    __int16 v199 = __nwlog_obj();
                    os_log_type_t v200 = v310;
                    if (os_log_type_enabled(v199, v310))
                    {
                      BOOL v201 = v77->identifier->name;
                      if (!v201) {
                        BOOL v201 = "invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_disconnect";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v201;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = v77;
                      long long v202 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback";
LABEL_429:
                      int v247 = v199;
LABEL_430:
                      _os_log_impl(&dword_1830D4000, v247, v200, v202, v313, 0x20u);
                    }
                  }
                  else if (v309)
                  {
                    os_log_type_t v230 = (char *)__nw_create_backtrace_string();
                    int v231 = __nwlog_obj();
                    os_log_type_t v200 = v310;
                    uint64_t v266 = v231;
                    BOOL v232 = os_log_type_enabled(v231, v310);
                    if (v230)
                    {
                      if (v232)
                      {
                        uint64_t v233 = v77->identifier->name;
                        if (!v233) {
                          uint64_t v233 = "invalid";
                        }
                        *(_DWORD *)uint64_t v313 = 136446978;
                        *(void *)&v313[4] = "__nw_protocol_disconnect";
                        *(_WORD *)&v313[12] = 2082;
                        *(void *)&v313[14] = v233;
                        *(_WORD *)&v313[22] = 2048;
                        *(void *)v314 = v77;
                        *(_WORD *)&v314[8] = 2082;
                        *(void *)&v314[10] = v230;
                        _os_log_impl(&dword_1830D4000, v266, v200, "%{public}s protocol %{public}s (%p) has invalid disconnect callback, dumping backtrace:%{public}s", v313, 0x2Au);
                      }
                      free(v230);
                      goto LABEL_431;
                    }
                    if (v232)
                    {
                      int v250 = v77->identifier->name;
                      if (!v250) {
                        int v250 = "invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_disconnect";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v250;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = v77;
                      long long v202 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, no backtrace";
                      int v247 = v266;
                      goto LABEL_430;
                    }
                  }
                  else
                  {
                    __int16 v199 = __nwlog_obj();
                    os_log_type_t v200 = v310;
                    if (os_log_type_enabled(v199, v310))
                    {
                      uint64_t v246 = v77->identifier->name;
                      if (!v246) {
                        uint64_t v246 = "invalid";
                      }
                      *(_DWORD *)uint64_t v313 = 136446722;
                      *(void *)&v313[4] = "__nw_protocol_disconnect";
                      *(_WORD *)&v313[12] = 2082;
                      *(void *)&v313[14] = v246;
                      *(_WORD *)&v313[22] = 2048;
                      *(void *)v314 = v77;
                      long long v202 = "%{public}s protocol %{public}s (%p) has invalid disconnect callback, backtrace limit exceeded";
                      goto LABEL_429;
                    }
                  }
                }
LABEL_431:
                if (v198) {
                  free(v198);
                }
                __int16 v47 = (void *)&unk_183D5C000;
                goto LABEL_136;
              }
              __nwlog_obj();
              *(_DWORD *)uint64_t v313 = 136446210;
              *(void *)&v313[4] = "__nw_protocol_disconnect";
              __int16 v218 = (char *)_os_log_send_and_compose_impl();
              v320[0] = 16;
              v311[0] = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v218, v320, v311))
              {
                if (v320[0] == 17)
                {
                  int v219 = __nwlog_obj();
                  os_log_type_t v220 = v320[0];
                  if (!os_log_type_enabled(v219, (os_log_type_t)v320[0])) {
                    goto LABEL_469;
                  }
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_disconnect";
                  BOOL v221 = "%{public}s called with null protocol";
LABEL_468:
                  _os_log_impl(&dword_1830D4000, v219, v220, v221, v313, 0xCu);
                  goto LABEL_469;
                }
                if (v311[0] == OS_LOG_TYPE_DEFAULT)
                {
                  int v219 = __nwlog_obj();
                  os_log_type_t v220 = v320[0];
                  if (!os_log_type_enabled(v219, (os_log_type_t)v320[0])) {
                    goto LABEL_469;
                  }
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_disconnect";
                  BOOL v221 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_468;
                }
                uint64_t v239 = (char *)__nw_create_backtrace_string();
                int v219 = __nwlog_obj();
                os_log_type_t v220 = v320[0];
                BOOL v240 = os_log_type_enabled(v219, (os_log_type_t)v320[0]);
                if (!v239)
                {
                  if (!v240) {
                    goto LABEL_469;
                  }
                  *(_DWORD *)uint64_t v313 = 136446210;
                  *(void *)&v313[4] = "__nw_protocol_disconnect";
                  BOOL v221 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_468;
                }
                if (v240)
                {
                  *(_DWORD *)uint64_t v313 = 136446466;
                  *(void *)&v313[4] = "__nw_protocol_disconnect";
                  *(_WORD *)&v313[12] = 2082;
                  *(void *)&v313[14] = v239;
                  _os_log_impl(&dword_1830D4000, v219, v220, "%{public}s called with null protocol, dumping backtrace:%{public}s", v313, 0x16u);
                }
                free(v239);
              }
LABEL_469:
              if (v218) {
                free(v218);
              }
              __int16 v47 = (void *)&unk_183D5C000;
              BOOL v84 = (nw_protocol *)*p_output_handler;
              if ((*p_output_handler & 0x40) == 0) {
                goto LABEL_162;
              }
LABEL_138:
              if ((BYTE5(a1[3].identifier) & 2) != 0)
              {
                if (gLogDatapath)
                {
                  int v177 = __nwlog_obj();
                  if (os_log_type_enabled(v177, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)uint64_t v313 = 136446722;
                    *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v313[12] = 2082;
                    *(void *)&v313[14] = a1 + 2;
                    *(_WORD *)&v313[22] = 1024;
                    *(_DWORD *)v314 = v268;
                    _os_log_impl(&dword_1830D4000, v177, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Seen disconnected, performing a final read with the original maximum bytes %u", v313, 0x1Cu);
                  }
                }
                *(void *)uint64_t v313 = 0;
                *(void *)&v313[8] = v313;
                *(void *)&v313[16] = 0x3802000000;
                *(void *)v314 = __Block_byref_object_copy__27;
                *(void *)&v314[8] = __Block_byref_object_dispose__28;
                *(void *)&v314[16] = 0;
                uint64_t v315 = &v314[16];
                if (!v271) {
                  goto LABEL_161;
                }
                __int16 v85 = v271->callbacks;
                if (!v85 || !v85->get_output_frames) {
                  goto LABEL_161;
                }
                __int16 v86 = v47;
                __int16 v87 = v271->handle;
                if (v87 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v88 = v271[1].callbacks;
                  if (v88) {
                    v271[1].callbacks = (nw_protocol_callbacks *)((char *)&v88->add_input_handler + 1);
                  }
                }
                BOOL v89 = a1->handle;
                if (v89 == &nw_protocol_ref_counted_handle)
                {
                  BOOL v90 = a1[1].callbacks;
                  if (v90) {
                    a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v90->add_input_handler + 1);
                  }
                }
                get_input_frames = (uint64_t (*)(nw_protocol *, nw_protocol *))v85->get_input_frames;
                if (get_input_frames)
                {
                  int v92 = get_input_frames(v271, a1);
LABEL_151:
                  if (v89 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v127 = a1[1].callbacks;
                    if (v127)
                    {
                      id v128 = (nw_protocol_callbacks *)((char *)v127 - 1);
                      a1[1].callbacks = v128;
                      if (!v128)
                      {
                        int v129 = *(void (***)(void))a1[1].flow_id;
                        if (v129)
                        {
                          *(void *)a1[1].flow_id = 0;
                          v129[2](v129);
                          _Block_release(v129);
                        }
                        if (a1[1].flow_id[8])
                        {
                          id v130 = *(const void **)a1[1].flow_id;
                          if (v130) {
                            _Block_release(v130);
                          }
                        }
                        free(a1);
                      }
                    }
                  }
                  BOOL v93 = v87 == &nw_protocol_ref_counted_handle;
                  int v94 = v271;
                  __int16 v47 = v86;
                  if (v93 && v271->handle == &nw_protocol_ref_counted_handle)
                  {
                    id v131 = v271[1].callbacks;
                    if (v131)
                    {
                      id v132 = (nw_protocol_callbacks *)((char *)v131 - 1);
                      v271[1].callbacks = v132;
                      if (!v132)
                      {
                        uint64_t v133 = *(void (***)(void))v271[1].flow_id;
                        if (v133)
                        {
                          *(void *)v271[1].flow_id = 0;
                          v133[2](v133);
                          _Block_release(v133);
                          int v94 = v271;
                        }
                        if (v94[1].flow_id[8])
                        {
                          uint64_t v134 = *(const void **)v94[1].flow_id;
                          if (v134)
                          {
                            _Block_release(v134);
                            int v94 = v271;
                          }
                        }
                        free(v94);
                      }
                    }
                  }
                  if (v92)
                  {
                    if (gLogDatapath)
                    {
                      BOOL v184 = __nwlog_obj();
                      if (os_log_type_enabled(v184, OS_LOG_TYPE_DEBUG))
                      {
                        *(_DWORD *)int v320 = 136446722;
                        *(void *)&v320[4] = "nw_protocol_test_get_input_frames";
                        __int16 v321 = 2082;
                        id v322 = a1 + 2;
                        __int16 v323 = 1024;
                        LODWORD(v324) = v92;
                        _os_log_impl(&dword_1830D4000, v184, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got back %u final frames", v320, 0x1Cu);
                      }
                    }
                    v279[0] = MEMORY[0x1E4F143A8];
                    v279[1] = v86[315];
                    nw_endpoint_t v280 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_35;
                    nw_endpoint_t v281 = &unk_1E524ACF8;
                    os_log_type_t v282 = v313;
                    v283 = &v305;
                    os_log_type_t v284 = a6;
                    uint64_t v95 = *(void *)(*(void *)&v313[8] + 40);
                    do
                    {
                      if (!v95) {
                        break;
                      }
                      uint64_t v96 = *(void *)(v95 + 32);
                      char v97 = v280(v279);
                      uint64_t v95 = v96;
                    }
                    while ((v97 & 1) != 0);
                  }
LABEL_161:
                  _Block_object_dispose(v313, 8);
                  BOOL v84 = (nw_protocol *)*p_output_handler;
                  goto LABEL_162;
                }
                __nwlog_obj();
                uint64_t v178 = v271->identifier->name;
                *(_DWORD *)int v320 = 136446722;
                *(void *)&v320[4] = "__nw_protocol_get_input_frames";
                if (!v178) {
                  uint64_t v178 = "invalid";
                }
                __int16 v321 = 2082;
                id v322 = (nw_protocol *)v178;
                __int16 v323 = 2048;
                os_log_type_t v324 = v271;
                int v179 = (const char *)_os_log_send_and_compose_impl();
                v311[0] = OS_LOG_TYPE_ERROR;
                os_log_type_t v310 = OS_LOG_TYPE_DEFAULT;
                uint64_t v269 = (char *)v179;
                if (__nwlog_fault(v179, v311, &v310))
                {
                  if (v311[0] == OS_LOG_TYPE_FAULT)
                  {
                    int v180 = __nwlog_obj();
                    os_log_type_t v181 = v311[0];
                    if (os_log_type_enabled(v180, v311[0]))
                    {
                      int v182 = v271->identifier->name;
                      if (!v182) {
                        int v182 = "invalid";
                      }
                      *(_DWORD *)int v320 = 136446722;
                      *(void *)&v320[4] = "__nw_protocol_get_input_frames";
                      __int16 v321 = 2082;
                      id v322 = (nw_protocol *)v182;
                      __int16 v323 = 2048;
                      os_log_type_t v324 = v271;
                      BOOL v183 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_388:
                      int v235 = v180;
                      os_log_type_t v236 = v181;
LABEL_389:
                      _os_log_impl(&dword_1830D4000, v235, v236, v183, v320, 0x20u);
                    }
                  }
                  else if (v310)
                  {
                    long long v203 = (char *)__nw_create_backtrace_string();
                    long long v204 = __nwlog_obj();
                    os_log_type_t v263 = v311[0];
                    BOOL v205 = os_log_type_enabled(v204, v311[0]);
                    if (v203)
                    {
                      if (v205)
                      {
                        int v206 = v271->identifier->name;
                        if (!v206) {
                          int v206 = "invalid";
                        }
                        *(_DWORD *)int v320 = 136446978;
                        *(void *)&v320[4] = "__nw_protocol_get_input_frames";
                        __int16 v321 = 2082;
                        id v322 = (nw_protocol *)v206;
                        __int16 v323 = 2048;
                        os_log_type_t v324 = v271;
                        __int16 v325 = 2082;
                        uint64_t v326 = v203;
                        _os_log_impl(&dword_1830D4000, v204, v263, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", v320, 0x2Au);
                      }
                      free(v203);
                      goto LABEL_390;
                    }
                    if (v205)
                    {
                      __int16 v241 = v271->identifier->name;
                      if (!v241) {
                        __int16 v241 = "invalid";
                      }
                      *(_DWORD *)int v320 = 136446722;
                      *(void *)&v320[4] = "__nw_protocol_get_input_frames";
                      __int16 v321 = 2082;
                      id v322 = (nw_protocol *)v241;
                      __int16 v323 = 2048;
                      os_log_type_t v324 = v271;
                      BOOL v183 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
                      int v235 = v204;
                      os_log_type_t v236 = v263;
                      goto LABEL_389;
                    }
                  }
                  else
                  {
                    int v180 = __nwlog_obj();
                    os_log_type_t v181 = v311[0];
                    if (os_log_type_enabled(v180, v311[0]))
                    {
                      BOOL v234 = v271->identifier->name;
                      if (!v234) {
                        BOOL v234 = "invalid";
                      }
                      *(_DWORD *)int v320 = 136446722;
                      *(void *)&v320[4] = "__nw_protocol_get_input_frames";
                      __int16 v321 = 2082;
                      id v322 = (nw_protocol *)v234;
                      __int16 v323 = 2048;
                      os_log_type_t v324 = v271;
                      BOOL v183 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
                      goto LABEL_388;
                    }
                  }
                }
LABEL_390:
                if (v269) {
                  free(v269);
                }
                int v92 = 0;
                goto LABEL_151;
              }
LABEL_162:
              if (((unsigned __int16)v84 & 0x4000) != 0)
              {
                if (gLogDatapath)
                {
                  BOOL v164 = __nwlog_obj();
                  if (os_log_type_enabled(v164, OS_LOG_TYPE_DEBUG))
                  {
                    int v165 = *((_DWORD *)v306 + 6);
                    *(_DWORD *)uint64_t v313 = 136446722;
                    *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v313[12] = 2082;
                    *(void *)&v313[14] = a1 + 2;
                    *(_WORD *)&v313[22] = 1024;
                    *(_DWORD *)v314 = v165;
                    _os_log_impl(&dword_1830D4000, v164, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s before interleaving empty frames, had %u frames", v313, 0x1Cu);
                  }
                }
                *(void *)uint64_t v313 = 0;
                *(void *)&v313[8] = v313;
                *(void *)&v313[16] = 0x2000000000;
                *(void *)v314 = 0;
                v272[0] = MEMORY[0x1E4F143A8];
                v272[1] = v47[315];
                __int16 v273 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_37;
                BOOL v274 = &unk_1E524AD20;
                os_log_type_t v277 = v9;
                os_log_type_t v278 = a6;
                os_log_type_t v275 = v313;
                id v276 = &v305;
                tqh_first = a6->tqh_first;
                do
                {
                  if (!tqh_first) {
                    break;
                  }
                  char v99 = (nw_frame *)*((void *)tqh_first + 4);
                  char v100 = v273(v272);
                  tqh_first = v99;
                }
                while ((v100 & 1) != 0);
                _Block_object_dispose(v313, 8);
                BOOL v84 = *v9;
              }
              if (((unsigned __int16)v84 & 0x8000) != 0)
              {
                if (gLogDatapath)
                {
                  BOOL v166 = __nwlog_obj();
                  if (os_log_type_enabled(v166, OS_LOG_TYPE_DEBUG))
                  {
                    int v167 = *((_DWORD *)v306 + 6);
                    *(_DWORD *)uint64_t v313 = 136446722;
                    *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
                    *(_WORD *)&v313[12] = 2082;
                    *(void *)&v313[14] = v9 + 4;
                    *(_WORD *)&v313[22] = 1024;
                    *(_DWORD *)v314 = v167;
                    _os_log_impl(&dword_1830D4000, v166, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s before making one byte frames, had %u frames", v313, 0x1Cu);
                  }
                }
                char v101 = &unk_1EB267000;
                __int16 v102 = "nw_protocol_test_get_input_frames";
                while (1)
                {
                  __int16 v106 = a6->tqh_first;
                  if (!a6->tqh_first) {
                    break;
                  }
                  *(void *)int v320 = a6->tqh_first;
                  uint64_t v107 = *((void *)v106 + 4);
                  uint64_t v108 = (nw_frame **)*((void *)v106 + 5);
                  if (v107)
                  {
                    *(void *)(v107 + 40) = v108;
                    uint64_t v108 = (nw_frame **)*((void *)v106 + 5);
                  }
                  else
                  {
                    a6->tqh_last = v108;
                  }
                  *uint64_t v108 = (nw_frame *)v107;
                  *((void *)v106 + 4) = 0;
                  *((void *)v106 + 5) = 0;
                  while (nw_frame_unclaimed_length(*(_DWORD **)v320) >= 2)
                  {
                    uint64_t v109 = nw_frame_split((uint64_t *)v320, 1u);
                    if (gLogDatapath)
                    {
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      uint64_t v111 = *((void *)v101 + 237);
                      if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
                      {
                        int v112 = v101;
                        int v113 = v102;
                        uint64_t v114 = *(void *)v320;
                        int v115 = nw_frame_unclaimed_length(*(_DWORD **)v320);
                        *(_DWORD *)uint64_t v313 = 136447234;
                        *(void *)&v313[4] = v113;
                        *(_WORD *)&v313[12] = 2082;
                        *(void *)&v313[14] = v9 + 4;
                        *(_WORD *)&v313[22] = 2048;
                        *(void *)v314 = v109;
                        *(_WORD *)&v314[8] = 2048;
                        *(void *)&v314[10] = v114;
                        __int16 v102 = v113;
                        char v101 = v112;
                        *(_WORD *)&v314[18] = 1024;
                        *(_DWORD *)&v314[20] = v115;
                        _os_log_impl(&dword_1830D4000, v111, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s appending one byte frame %p made from existing frame %p (%u bytes)", v313, 0x30u);
                      }
                    }
                    *(void *)(v109 + 32) = 0;
                    uint64_t v110 = (uint64_t *)v9[2];
                    *(void *)(v109 + 40) = v110;
                    *uint64_t v110 = v109;
                    v9[2] = (nw_protocol *)(v109 + 32);
                  }
                  uint64_t v103 = *(void *)v320;
                  uint64_t v104 = *(void *)v320;
                  *(void *)(*(void *)v320 + 32) = 0;
                  __int16 v105 = v9[2];
                  *(void *)(v103 + 40) = v105;
                  *(void *)v105->flow_id = v103;
                  v9[2] = (nw_protocol *)(v104 + 32);
                }
                *((_DWORD *)v306 + 6) = 0;
                int v116 = v9[1];
                if (v116)
                {
                  int v118 = v116->output_handler;
                  int v119 = (nw_protocol *)v116->handle;
                  BOOL v117 = (nw_frame **)&v116->output_handler;
                  if (v118)
                  {
                    v118->uint64_t handle = v119;
                    int v119 = (nw_protocol *)v116->handle;
                  }
                  else
                  {
                    v9[2] = v119;
                  }
                  *(void *)v119->flow_id = v118;
                  char *v117 = 0;
                  v116->uint64_t handle = 0;
                  uint64_t v120 = a6->tqh_last;
                  v116->uint64_t handle = v120;
                  *uint64_t v120 = (nw_frame *)v116;
                  a6->tqh_last = v117;
                  *((_DWORD *)v306 + 6) = 1;
                }
              }
              *(_DWORD *)uint64_t v313 = 0;
              nw_frame_array_get_frame_count((uint64_t *)a6, 1, v313);
              if (gLogDatapath)
              {
                int v150 = *(_DWORD *)v313;
                int v151 = __nwlog_obj();
                if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
                {
                  int v152 = *((_DWORD *)v306 + 6);
                  *(_DWORD *)uint64_t v313 = 136446978;
                  *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
                  *(_WORD *)&v313[12] = 2082;
                  *(void *)&v313[14] = v9 + 4;
                  *(_WORD *)&v313[22] = 1024;
                  *(_DWORD *)v314 = v152;
                  *(_WORD *)&v314[4] = 1024;
                  *(_DWORD *)&v314[6] = v150;
                  _os_log_impl(&dword_1830D4000, v151, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s returning %u frames (total %u bytes)", v313, 0x22u);
                }
              }
              uint64_t v18 = *((unsigned int *)v306 + 6);
              _Block_object_dispose(&v305, 8);
              uint64_t v121 = v271;
              if (v270)
              {
                if (v271)
                {
                  if (v271->handle == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v123 = v271[1].callbacks;
                    if (v123)
                    {
                      int v124 = (nw_protocol_callbacks *)((char *)v123 - 1);
                      v271[1].callbacks = v124;
                      if (!v124)
                      {
                        int v125 = *(void (***)(void))v271[1].flow_id;
                        if (v125)
                        {
                          *(void *)v271[1].flow_id = 0;
                          v125[2](v125);
                          _Block_release(v125);
                          uint64_t v121 = v271;
                        }
                        if (v121[1].flow_id[8])
                        {
                          uint64_t v126 = *(const void **)v121[1].flow_id;
                          if (v126)
                          {
                            _Block_release(v126);
                            uint64_t v121 = v271;
                          }
                        }
                        free(v121);
                      }
                    }
                  }
                }
              }
              _Block_object_dispose(buf, 8);
              return v18;
            }
            v285[0] = MEMORY[0x1E4F143A8];
            v285[1] = 0x40000000;
            uint64_t v286 = (uint64_t (*)(void *))___ZL33nw_protocol_test_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_33;
            os_log_type_t v287 = &__block_descriptor_tmp_34_85694;
            uint64_t v288 = p_output_handler;
            uint64_t v289 = a2;
            uint64_t v290 = a1;
            uint64_t v55 = *(void *)(*(void *)&buf[8] + 40);
            do
            {
              if (!v55) {
                break;
              }
              uint64_t v56 = *(void *)(v55 + 32);
              char v57 = v286(v285);
              uint64_t v55 = v56;
            }
            while ((v57 & 1) != 0);
          }
LABEL_137:
          BOOL v84 = (nw_protocol *)*p_output_handler;
          if ((*p_output_handler & 0x40) == 0) {
            goto LABEL_162;
          }
          goto LABEL_138;
        }
        if (!v38->get_output_frames)
        {
          os_log_type_t v36 = &v305;
          goto LABEL_62;
        }
        os_log_type_t v39 = output_handler->handle;
        if (v39 == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v40 = output_handler[1].callbacks;
          if (v40) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v40->add_input_handler + 1);
          }
        }
        char v41 = a1->handle;
        if (v41 == &nw_protocol_ref_counted_handle)
        {
          BOOL v42 = a1[1].callbacks;
          if (v42) {
            a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v42->add_input_handler + 1);
          }
        }
        if (v32)
        {
          char v43 = (uint64_t (*)(void))v38->get_input_frames;
          if (v43)
          {
            int v44 = v43();
LABEL_56:
            if (v41 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
            {
              long long v62 = a1[1].callbacks;
              if (v62)
              {
                os_log_type_t v63 = (nw_protocol_callbacks *)((char *)v62 - 1);
                a1[1].callbacks = v63;
                if (!v63)
                {
                  __int16 v64 = *(void (***)(void))a1[1].flow_id;
                  if (v64)
                  {
                    *(void *)a1[1].flow_id = 0;
                    v64[2](v64);
                    _Block_release(v64);
                  }
                  if (a1[1].flow_id[8])
                  {
                    BOOL v65 = *(const void **)a1[1].flow_id;
                    if (v65) {
                      _Block_release(v65);
                    }
                  }
                  free(a1);
                }
              }
            }
            __int16 v45 = v271;
            if (v39 == &nw_protocol_ref_counted_handle)
            {
              if (v271)
              {
                if (v271->handle == &nw_protocol_ref_counted_handle)
                {
                  os_log_type_t v58 = v271[1].callbacks;
                  if (v58)
                  {
                    os_log_type_t v59 = (nw_protocol_callbacks *)((char *)v58 - 1);
                    v271[1].callbacks = v59;
                    if (!v59)
                    {
                      char v60 = *(void (***)(void))v271[1].flow_id;
                      if (v60)
                      {
                        *(void *)v271[1].flow_id = 0;
                        v60[2](v60);
                        _Block_release(v60);
                        __int16 v45 = v271;
                      }
                      if (v45[1].flow_id[8])
                      {
                        long long v61 = *(const void **)v45[1].flow_id;
                        if (v61)
                        {
                          _Block_release(v61);
                          __int16 v45 = v271;
                        }
                      }
                      free(v45);
                    }
                  }
                }
              }
            }
            os_log_type_t v36 = v306;
            *((_DWORD *)v306 + 6) = v44;
            goto LABEL_62;
          }
          BOOL v157 = output_handler;
          __nwlog_obj();
          uint64_t v158 = v157->identifier->name;
          *(_DWORD *)uint64_t v313 = 136446722;
          *(void *)&v313[4] = "__nw_protocol_get_input_frames";
          if (!v158) {
            uint64_t v158 = "invalid";
          }
          *(_WORD *)&v313[12] = 2082;
          *(void *)&v313[14] = v158;
          *(_WORD *)&v313[22] = 2048;
          *(void *)v314 = v157;
          int v159 = (const char *)_os_log_send_and_compose_impl();
          v320[0] = 16;
          v311[0] = OS_LOG_TYPE_DEFAULT;
          BOOL v267 = (char *)v159;
          if (!__nwlog_fault(v159, v320, v311)) {
            goto LABEL_346;
          }
          if (v320[0] == 17)
          {
            int v160 = __nwlog_obj();
            os_log_type_t v161 = v320[0];
            os_log_t loga = v160;
            if (os_log_type_enabled(v160, (os_log_type_t)v320[0]))
            {
              int v162 = v271->identifier->name;
              if (!v162) {
                int v162 = "invalid";
              }
              *(_DWORD *)uint64_t v313 = 136446722;
              *(void *)&v313[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&v313[12] = 2082;
              *(void *)&v313[14] = v162;
              *(_WORD *)&v313[22] = 2048;
              *(void *)v314 = v271;
              os_log_type_t v156 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_343:
              int v208 = loga;
              os_log_type_t v209 = v161;
LABEL_344:
              uint32_t v210 = 32;
              goto LABEL_345;
            }
            goto LABEL_346;
          }
          if (v311[0] == OS_LOG_TYPE_DEFAULT)
          {
            BOOL v211 = __nwlog_obj();
            os_log_type_t v161 = v320[0];
            os_log_t loga = v211;
            if (os_log_type_enabled(v211, (os_log_type_t)v320[0]))
            {
              int v212 = v271->identifier->name;
              if (!v212) {
                int v212 = "invalid";
              }
              *(_DWORD *)uint64_t v313 = 136446722;
              *(void *)&v313[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&v313[12] = 2082;
              *(void *)&v313[14] = v212;
              *(_WORD *)&v313[22] = 2048;
              *(void *)v314 = v271;
              os_log_type_t v156 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
              goto LABEL_343;
            }
LABEL_346:
            if (v267) {
              free(v267);
            }
            int v44 = 0;
            goto LABEL_56;
          }
          uint64_t v168 = (char *)__nw_create_backtrace_string();
          id logc = __nwlog_obj();
          os_log_type_t typea = v320[0];
          BOOL v174 = os_log_type_enabled(logc, (os_log_type_t)v320[0]);
          if (!v168)
          {
            if (!v174) {
              goto LABEL_346;
            }
            int v213 = v271->identifier->name;
            if (!v213) {
              int v213 = "invalid";
            }
            *(_DWORD *)uint64_t v313 = 136446722;
            *(void *)&v313[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&v313[12] = 2082;
            *(void *)&v313[14] = v213;
            *(_WORD *)&v313[22] = 2048;
            *(void *)v314 = v271;
            os_log_type_t v156 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            int v208 = logc;
            os_log_type_t v209 = typea;
            goto LABEL_344;
          }
          if (!v174)
          {
LABEL_286:
            free(v168);
            goto LABEL_346;
          }
          BOOL v175 = v271->identifier->name;
          if (!v175) {
            BOOL v175 = "invalid";
          }
          *(_DWORD *)uint64_t v313 = 136446978;
          *(void *)&v313[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&v313[12] = 2082;
          *(void *)&v313[14] = v175;
          *(_WORD *)&v313[22] = 2048;
          *(void *)v314 = v271;
          *(_WORD *)&v314[8] = 2082;
          *(void *)&v314[10] = v168;
          int v170 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s";
          int v171 = logc;
          os_log_type_t v172 = typea;
          uint32_t v173 = 42;
LABEL_285:
          _os_log_impl(&dword_1830D4000, v171, v172, v170, v313, v173);
          goto LABEL_286;
        }
        __nwlog_obj();
        *(_DWORD *)uint64_t v313 = 136446210;
        *(void *)&v313[4] = "__nw_protocol_get_input_frames";
        int v153 = (const char *)_os_log_send_and_compose_impl();
        v320[0] = 16;
        v311[0] = OS_LOG_TYPE_DEFAULT;
        BOOL v267 = (char *)v153;
        if (!__nwlog_fault(v153, v320, v311)) {
          goto LABEL_346;
        }
        if (v320[0] == 17)
        {
          os_log_type_t v154 = __nwlog_obj();
          os_log_type_t v155 = v320[0];
          os_log_t log = v154;
          if (!os_log_type_enabled(v154, (os_log_type_t)v320[0])) {
            goto LABEL_346;
          }
          *(_DWORD *)uint64_t v313 = 136446210;
          *(void *)&v313[4] = "__nw_protocol_get_input_frames";
          os_log_type_t v156 = "%{public}s called with null return_array";
        }
        else
        {
          if (v311[0])
          {
            uint64_t v168 = (char *)__nw_create_backtrace_string();
            nw_endpoint_t logb = __nwlog_obj();
            os_log_type_t type = v320[0];
            BOOL v169 = os_log_type_enabled(logb, (os_log_type_t)v320[0]);
            if (!v168)
            {
              if (!v169) {
                goto LABEL_346;
              }
              *(_DWORD *)uint64_t v313 = 136446210;
              *(void *)&v313[4] = "__nw_protocol_get_input_frames";
              os_log_type_t v156 = "%{public}s called with null return_array, no backtrace";
              int v208 = logb;
              os_log_type_t v209 = type;
              uint32_t v210 = 12;
              goto LABEL_345;
            }
            if (!v169) {
              goto LABEL_286;
            }
            *(_DWORD *)uint64_t v313 = 136446466;
            *(void *)&v313[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&v313[12] = 2082;
            *(void *)&v313[14] = v168;
            int v170 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            int v171 = logb;
            os_log_type_t v172 = type;
            uint32_t v173 = 22;
            goto LABEL_285;
          }
          uint64_t v207 = __nwlog_obj();
          os_log_type_t v155 = v320[0];
          os_log_t log = v207;
          if (!os_log_type_enabled(v207, (os_log_type_t)v320[0])) {
            goto LABEL_346;
          }
          *(_DWORD *)uint64_t v313 = 136446210;
          *(void *)&v313[4] = "__nw_protocol_get_input_frames";
          os_log_type_t v156 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        int v208 = log;
        os_log_type_t v209 = v155;
        uint32_t v210 = 12;
LABEL_345:
        _os_log_impl(&dword_1830D4000, v208, v209, v156, v313, v210);
        goto LABEL_346;
      }
      *(_DWORD *)uint64_t v313 = 136446466;
      *(void *)&v313[4] = "nw_protocol_test_get_input_frames";
      *(_WORD *)&v313[12] = 2082;
      *(void *)&v313[14] = a1 + 2;
      unsigned int v34 = "%{public}s %{public}s Disconnect on input enabled";
    }
    _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, v34, v313, 0x16u);
    goto LABEL_37;
  }
  os_log_type_t v21 = malloc_type_malloc(0xAuLL, 0xF2B69DE5uLL);
  if (v21)
  {
    uint64_t v22 = (uint64_t)v21;
  }
  else
  {
    uint64_t v146 = __nwlog_obj();
    os_log_type_enabled(v146, OS_LOG_TYPE_ERROR);
    *(_DWORD *)long long buf = 136446466;
    *(void *)&uint8_t buf[4] = "strict_malloc";
    *(_WORD *)&unsigned char buf[12] = 2048;
    *(void *)&buf[14] = 10;
    uint64_t v147 = (void *)_os_log_send_and_compose_impl();
    uint64_t result = __nwlog_abort((uint64_t)v147);
    if (result) {
      goto LABEL_479;
    }
    free(v147);
    uint64_t v22 = 0;
  }
  uint64_t v23 = nw_frame_create(0, v22, 10, (uint64_t)__nw_frame_malloc_finalizer, 0);
  nw_frame_set_buffer_used_malloc(v23, 1);
  *(void *)(v23 + 32) = 0;
  char v24 = a6->tqh_last;
  *(void *)(v23 + 40) = v24;
  *char v24 = (nw_frame *)v23;
  a6->tqh_last = (nw_frame **)(v23 + 32);
  uint64_t v25 = malloc_type_malloc(0xAuLL, 0xF2B69DE5uLL);
  if (v25)
  {
    uint64_t v26 = (uint64_t)v25;
LABEL_25:
    uint64_t v27 = nw_frame_create(0, v26, 10, (uint64_t)__nw_frame_malloc_finalizer, 0);
    nw_frame_set_buffer_used_malloc(v27, 1);
    *(void *)(v27 + 32) = 0;
    uint64_t v28 = a6->tqh_last;
    *(void *)(v27 + 40) = v28;
    *uint64_t v28 = (nw_frame *)v27;
    a6->tqh_last = (nw_frame **)(v27 + 32);
    uint64_t v29 = nw_frame_create(0, 0, 0, (uint64_t)__nw_frame_malloc_finalizer, 0);
    *(void *)(v29 + 32) = 0;
    unsigned int v30 = a6->tqh_last;
    *(void *)(v29 + 40) = v30;
    *unsigned int v30 = (nw_frame *)v29;
    a6->tqh_last = (nw_frame **)(v29 + 32);
    return 3;
  }
  int v148 = __nwlog_obj();
  os_log_type_enabled(v148, OS_LOG_TYPE_ERROR);
  *(_DWORD *)long long buf = 136446466;
  *(void *)&uint8_t buf[4] = "strict_malloc";
  *(_WORD *)&unsigned char buf[12] = 2048;
  *(void *)&buf[14] = 10;
  int v149 = (void *)_os_log_send_and_compose_impl();
  uint64_t result = __nwlog_abort((uint64_t)v149);
  if (!result)
  {
    free(v149);
    uint64_t v26 = 0;
    goto LABEL_25;
  }
LABEL_479:
  __break(1u);
  return result;
}