uint64_t __nwlog_is_datapath_logging_enabled()
{
  return gLogDatapath;
}

uint64_t nw_frame_array_first(uint64_t a1)
{
  return *(void *)a1;
}

uint64_t nw_protocol_downcast(uint64_t result)
{
  if (result)
  {
    if (*(_UNKNOWN **)(result + 40) == &nw_protocol_ref_counted_handle) {
      result += 96;
    }
    else {
      return 0;
    }
  }
  return result;
}

void *nw_frame_array_init(void *result)
{
  *result = 0;
  result[1] = result;
  return result;
}

BOOL nw_frame_array_is_empty(void *a1)
{
  return *a1 == 0;
}

void *__cdecl nw_retain(void *obj)
{
  if (obj) {
    return os_retain(obj);
  }
  return obj;
}

uint64_t nw_context_2k_buffer_length()
{
  return dword_1E8F65118;
}

ValueMetadata *type metadata accessor for NWError()
{
  return &type metadata for NWError;
}

uint64_t nw_settings_get_signposts_enabled()
{
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_18_90123);
  }
  return _nw_signposts_enabled;
}

uint64_t nw_frame_array_append(uint64_t result, int a2, uint64_t a3)
{
  if (a2)
  {
    *(void *)(a3 + 32) = 0;
    uint64_t v3 = a3 + 32;
  }
  else
  {
    *(void *)(a3 + 16) = 0;
    uint64_t v3 = a3 + 16;
  }
  v4 = *(void **)(result + 8);
  *(void *)(v3 + 8) = v4;
  void *v4 = a3;
  *(void *)(result + 8) = v3;
  return result;
}

uint64_t nw_frame_array_next(int a1, void *a2)
{
  if (a1)
  {
    uint64_t result = a2[4];
    if (!result && !a2[5]) {
      return 0;
    }
  }
  else
  {
    uint64_t result = a2[2];
    if (!result && !a2[3]) {
      return 0;
    }
  }
  return result;
}

uint64_t nw_frame_array_remove(uint64_t result, int a2, void *a3)
{
  if (!a2)
  {
    uint64_t v4 = a3[2];
    v5 = (void *)a3[3];
    uint64_t v3 = a3 + 2;
    if (v4)
    {
      *(void *)(v4 + 24) = v5;
      v5 = (void *)a3[3];
      goto LABEL_7;
    }
LABEL_6:
    *(void *)(result + 8) = v5;
    goto LABEL_7;
  }
  uint64_t v4 = a3[4];
  v5 = (void *)a3[5];
  uint64_t v3 = a3 + 4;
  if (!v4) {
    goto LABEL_6;
  }
  *(void *)(v4 + 40) = v5;
  v5 = (void *)a3[5];
LABEL_7:
  void *v5 = v4;
  *uint64_t v3 = 0;
  v3[1] = 0;
  return result;
}

uint64_t getEnumTagSinglePayload for NWError(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE && *(unsigned char *)(a1 + 5)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 4);
  if (v3 <= 2) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

uint64_t nw_protocol_upcast(uint64_t a1)
{
  if (a1) {
    return a1 - 96;
  }
  else {
    return 0;
  }
}

void ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_84(uint64_t a1)
{
}

uint64_t sub_1830D6A4C(uint64_t a1)
{
  unsigned int v1 = *(unsigned __int8 *)(a1 + 4) >> 6;
  if (v1 <= 1) {
    return v1;
  }
  else {
    return (*(_DWORD *)a1 + 2);
  }
}

ValueMetadata *type metadata accessor for NWConnection.State()
{
  return &type metadata for NWConnection.State;
}

ValueMetadata *type metadata accessor for NWActivity.CompletionReason()
{
  return &type metadata for NWActivity.CompletionReason;
}

void nw_endpoint_handler_start(void *a1)
{
  uint64_t v93 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v80 = "nw_endpoint_handler_start";
    v59 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (__nwlog_fault(v59, &type, &v77))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v60 = __nwlog_obj();
        os_log_type_t v61 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "nw_endpoint_handler_start";
          _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v77)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v60 = __nwlog_obj();
        os_log_type_t v71 = type;
        BOOL v72 = os_log_type_enabled(v60, type);
        if (backtrace_string)
        {
          if (v72)
          {
            *(_DWORD *)buf = 136446466;
            v80 = "nw_endpoint_handler_start";
            __int16 v81 = 2082;
            v82 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v60, v71, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_86;
        }
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          v80 = "nw_endpoint_handler_start";
          _os_log_impl(&dword_1830D4000, v60, v71, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v60 = __nwlog_obj();
        os_log_type_t v73 = type;
        if (os_log_type_enabled(v60, type))
        {
          *(_DWORD *)buf = 136446210;
          v80 = "nw_endpoint_handler_start";
          _os_log_impl(&dword_1830D4000, v60, v73, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_86:
    if (v59) {
      free(v59);
    }
    goto LABEL_64;
  }
  id v3 = nw_parameters_copy_context(v1[4]);
  nw_context_assert_queue(v3);

  int v4 = v2;
  v5 = v4;
  v6 = v2[4];
  if (!v6)
  {

    if ((*((unsigned char *)v5 + 268) & 0x20) != 0) {
      goto LABEL_25;
    }
    goto LABEL_7;
  }
  v7 = v6;
  uint64_t v8 = v7[12];

  if ((v8 & 0x4000000000) != 0)
  {
    if (nw_endpoint_handler_get_logging_disabled(v5)) {
      goto LABEL_25;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    v9 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(v5);
      v63 = nw_endpoint_handler_dry_run_string(v5);
      nw_endpoint_t v64 = nw_endpoint_handler_copy_endpoint(v5);
      v65 = v2;
      logging_description = nw_endpoint_get_logging_description(v64);
      v67 = nw_endpoint_handler_state_string(v5);
      v68 = nw_endpoint_handler_mode_string(v5);
      id v69 = nw_endpoint_handler_copy_current_path(v5);
      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      __int16 v81 = 2082;
      v82 = id_string;
      __int16 v83 = 2082;
      v84 = v63;
      __int16 v85 = 2082;
      v86 = logging_description;
      __int16 v87 = 2082;
      v88 = v67;
      __int16 v89 = 2082;
      v90 = v68;
      __int16 v91 = 2114;
      id v92 = v69;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);

      v2 = v65;
    }
LABEL_24:

    goto LABEL_25;
  }
  if ((*((unsigned char *)v5 + 268) & 0x20) == 0)
  {
LABEL_7:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    v9 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
    {
      if (*((unsigned char *)v5 + 268)) {
        v10 = "dry-run ";
      }
      else {
        v10 = "";
      }
      nw_endpoint_t v11 = nw_endpoint_handler_copy_endpoint(v5);
      v12 = nw_endpoint_get_logging_description(v11);
      uint64_t v13 = *((unsigned int *)v5 + 30);
      v14 = v12;
      if (v13 > 5) {
        v15 = "unknown-state";
      }
      else {
        v15 = off_1E523FB38[v13];
      }
      v74 = v15;
      v16 = v5;
      v17 = (os_unfair_lock_s *)v16;
      v76 = v2;
      v18 = "path";
      switch(*((_DWORD *)v16 + 29))
      {
        case 0:
          break;
        case 1:
          v18 = "resolver";
          break;
        case 2:
          v18 = nw_endpoint_flow_mode_string(v16[31]);
          break;
        case 3:
          v18 = "proxy";
          break;
        case 4:
          v18 = "fallback";
          break;
        case 5:
          v18 = "transform";
          break;
        default:
          v18 = "unknown-mode";
          break;
      }

      v19 = v17 + 28;
      v20 = v17;
      os_unfair_lock_lock(v17 + 28);
      id v21 = v20[8];
      os_unfair_lock_unlock(v19);

      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      __int16 v81 = 2082;
      v82 = v5 + 21;
      __int16 v83 = 2082;
      v84 = v10;
      __int16 v85 = 2082;
      v86 = v14;
      __int16 v87 = 2082;
      v88 = v74;
      __int16 v89 = 2082;
      v90 = v18;
      __int16 v91 = 2114;
      id v92 = v21;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);

      v2 = v76;
    }
    goto LABEL_24;
  }
LABEL_25:
  if (*((_DWORD *)v5 + 29) == 2 && nw_endpoint_flow_should_not_use_path(v5[31]))
  {
    *((_DWORD *)v5 + 30) = 1;
    uint64_t v22 = mach_continuous_time();
    if (v22 <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v22;
    }
    v5[16] = (void *)v23;
    id v24 = v5[31];
    [v24 startWithHandler:v5];

    goto LABEL_64;
  }
  *((_DWORD *)v5 + 20) = 65537;
  nw_endpoint_handler_report(v5, 0, (_WORD *)v5 + 40, 0);
  if (*((_DWORD *)v5 + 30))
  {
    v25 = v5;
    v26 = v25;
    v27 = v2[4];
    if (v27)
    {
      v28 = v27;
      BOOL v29 = (v28[12] & 0x4000000000) == 0;

      if (!v29)
      {
        if (nw_endpoint_handler_get_logging_disabled(v26)) {
          goto LABEL_64;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v30 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
        {
          v31 = v2;
          v32 = nw_endpoint_handler_get_id_string(v26);
          v33 = nw_endpoint_handler_dry_run_string(v26);
          nw_endpoint_t v34 = nw_endpoint_handler_copy_endpoint(v26);
          v35 = nw_endpoint_get_logging_description(v34);
          v36 = nw_endpoint_handler_state_string(v26);
          v37 = nw_endpoint_handler_mode_string(v26);
          id v38 = nw_endpoint_handler_copy_current_path(v26);
          *(_DWORD *)buf = 136447746;
          v80 = "nw_endpoint_handler_start";
          __int16 v81 = 2082;
          v82 = v32;
          __int16 v83 = 2082;
          v84 = v33;
          __int16 v85 = 2082;
          v86 = v35;
          __int16 v87 = 2082;
          v88 = v36;
          __int16 v89 = 2082;
          v90 = v37;
          __int16 v91 = 2114;
          id v92 = v38;
          _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] state changed during initial report, not starting", buf, 0x48u);

          v2 = v31;
        }
LABEL_63:

        goto LABEL_64;
      }
    }
    else
    {
    }
    if ((*((unsigned char *)v26 + 268) & 0x20) != 0) {
      goto LABEL_64;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    v30 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
    {
      if (*((unsigned char *)v26 + 268)) {
        v44 = "dry-run ";
      }
      else {
        v44 = "";
      }
      nw_endpoint_t v45 = nw_endpoint_handler_copy_endpoint(v26);
      v46 = nw_endpoint_get_logging_description(v45);
      uint64_t v47 = *((unsigned int *)v5 + 30);
      v48 = v46;
      if (v47 > 5) {
        v49 = "unknown-state";
      }
      else {
        v49 = off_1E523FB38[v47];
      }
      v75 = v49;
      v50 = v26;
      v51 = (os_unfair_lock_s *)v50;
      int v52 = *((_DWORD *)v5 + 29);
      v53 = "path";
      switch(v52)
      {
        case 0:
          break;
        case 1:
          v53 = "resolver";
          break;
        case 2:
          v53 = nw_endpoint_flow_mode_string(v50[31]);
          break;
        case 3:
          v53 = "proxy";
          break;
        case 4:
          v53 = "fallback";
          break;
        case 5:
          v53 = "transform";
          break;
        default:
          v53 = "unknown-mode";
          break;
      }

      v54 = v51 + 28;
      v55 = v2;
      v56 = v51;
      os_unfair_lock_lock(v51 + 28);
      id v57 = v56[8];
      os_unfair_lock_unlock(v54);

      v2 = v55;
      *(_DWORD *)buf = 136447746;
      v80 = "nw_endpoint_handler_start";
      __int16 v81 = 2082;
      v82 = v26 + 21;
      __int16 v83 = 2082;
      v84 = v44;
      __int16 v85 = 2082;
      v86 = v48;
      __int16 v87 = 2082;
      v88 = v75;
      __int16 v89 = 2082;
      v90 = v53;
      __int16 v91 = 2114;
      id v92 = v57;
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] state changed during initial report, not starting", buf, 0x48u);
    }
    goto LABEL_63;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 28);
  v39 = v5[8];
  v5[8] = 0;

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 28);
  v40 = v5[7];
  if (v40 && (*((unsigned char *)v5 + 268) & 4) == 0)
  {
    nw_association_unregister(v40, v5);
    v41 = v5[7];
    v5[7] = 0;
  }
  *((_DWORD *)v5 + 30) = 1;
  nw_endpoint_handler_initialize_association(v5);
  id v42 = nw_association_copy_current_path(v5[7], v2[4]);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 28);
  v43 = v5[8];
  v5[8] = v42;

  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 28);
  *((unsigned char *)v5 + 268) &= ~4u;
  nw_endpoint_handler_path_change((NWConcrete_nw_endpoint_handler *)v5);
LABEL_64:
}

void sub_1830D7510(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_handler_copy_endpoint(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v18 = "nw_endpoint_handler_copy_endpoint";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_endpoint_handler_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            v18 = "nw_endpoint_handler_copy_endpoint";
            __int16 v19 = 2082;
            v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_endpoint_handler_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          v18 = "nw_endpoint_handler_copy_endpoint";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v8) {
      free(v8);
    }
    nw_endpoint_t v5 = 0;
    goto LABEL_9;
  }
  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque != 2)
  {
    os_unfair_lock_unlock(v2 + 28);
LABEL_8:
    nw_endpoint_t v5 = (nw_endpoint_t)*(id *)&v2[6]._os_unfair_lock_opaque;
    goto LABEL_9;
  }
  id v3 = nw_endpoint_flow_copy_connected_path(*(void **)&v2[62]._os_unfair_lock_opaque);
  int v4 = v3;
  if (v3) {
    nw_endpoint_t v5 = nw_path_copy_effective_remote_endpoint(v3);
  }
  else {
    nw_endpoint_t v5 = 0;
  }

  os_unfair_lock_unlock(v2 + 28);
  if (!v5) {
    goto LABEL_8;
  }
LABEL_9:

  return v5;
}

void sub_1830D7898(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_connected_path(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = a1;
  v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0 || (v2[8]._os_unfair_lock_opaque & 0x100) != 0)
    {
      id v5 = *(id *)&v2[2]._os_unfair_lock_opaque;
    }
    else
    {
      id v3 = *(void **)&v2[234]._os_unfair_lock_opaque;
      if (v3)
      {
        int v4 = (void *)nw_endpoint_handler_copy_connected_path(v3);
        id v5 = v4;
        if (v4)
        {
          v6 = *(void **)&v2[2]._os_unfair_lock_opaque;
          if (v6) {
            nw_path_apply_override_interface_types_from_path(v4, v6);
          }
        }
      }
      else
      {
        id v5 = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_10;
  }
  uint64_t v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v19 = "nw_endpoint_flow_copy_connected_path";
  v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_endpoint_flow_copy_connected_path";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v19 = "nw_endpoint_flow_copy_connected_path";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_endpoint_flow_copy_connected_path";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v19 = "nw_endpoint_flow_copy_connected_path";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_28:
  if (v9) {
    free(v9);
  }
  id v5 = 0;
LABEL_10:

  return v5;
}

void sub_1830D7BA4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *nw_endpoint_get_logging_description(void *a1)
{
  id v1 = a1;
  v2 = v1;
  if (v1)
  {
    id v3 = v1;
    int v4 = (os_unfair_lock_s *)v3;
    if ((*((unsigned char *)v3 + 231) & 0x20) == 0)
    {
      id v5 = *((id *)v3 + 1);
      if (!v5 || (int v6 = v5[31], (v6 - 2) < 2))
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1)
        {
          os_log_type_t v13 = v5;
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
          id v5 = v13;
        }
        int v7 = nwlog_get_sensitive_redacted::sensitiveRedacted;

        if (!v7) {
          goto LABEL_13;
        }
LABEL_15:
        uint64_t v17 = 0;
        uint64_t v18 = (uint64_t)&v17;
        uint64_t v19 = 0x2020000000;
        __int16 v20 = 0;
        v14[0] = MEMORY[0x1E4F143A8];
        v14[1] = 3221225472;
        v14[2] = __nw_endpoint_get_logging_description_block_invoke;
        v14[3] = &unk_1E524B978;
        os_log_type_t v15 = v4;
        char v16 = &v17;
        os_unfair_lock_lock(v4 + 45);
        __nw_endpoint_get_logging_description_block_invoke((uint64_t)v14);
        os_unfair_lock_unlock(v4 + 45);
        uint64_t v8 = *(const char **)(v18 + 24);

        _Block_object_dispose(&v17, 8);
        goto LABEL_16;
      }
      if (v6 != 1)
      {

        goto LABEL_15;
      }
    }
LABEL_13:
    v9 = v4;
    uint64_t v23 = 0;
    id v24 = &v23;
    uint64_t v25 = 0x2020000000;
    uint64_t v26 = 0;
    os_log_type_t v10 = v9 + 45;
    uint64_t v17 = MEMORY[0x1E4F143A8];
    uint64_t v18 = 3221225472;
    uint64_t v19 = (uint64_t)__nw_endpoint_get_description_block_invoke;
    __int16 v20 = &unk_1E524B978;
    os_log_type_t v11 = v9;
    uint64_t v21 = v11;
    uint64_t v22 = &v23;
    os_unfair_lock_lock(v10);
    __nw_endpoint_get_description_block_invoke((uint64_t)&v17);
    os_unfair_lock_unlock(v10);
    uint64_t v8 = (const char *)v24[3];

    _Block_object_dispose(&v23, 8);
    goto LABEL_16;
  }
  uint64_t v8 = "<NULL>";
LABEL_16:

  return v8;
}

void *__nw_endpoint_get_logging_description_block_invoke(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 32);
  uint64_t v3 = result[10];
  if (!v3)
  {
    uint64_t result = (void *)[result createDescription:1];
    *(void *)(*(void *)(a1 + 32) + 80) = result;
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 80);
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v3;
  *(unsigned char *)(*(void *)(a1 + 32) + 231) |= 0x10u;
  return result;
}

nw_endpoint_t nw_path_copy_effective_remote_endpoint(nw_path_t path)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  p_uint64_t isa = (id *)&v1->isa;
  if (v1)
  {
    uint64_t isa = (uint64_t)v1[9].isa;
    if (isa && *(void *)(isa + 24) != *(void *)(isa + 16))
    {
      int v4 = nw_array_get_object_at_index(isa, 0);
      id v5 = v4;
      if (v4)
      {
        int v6 = (void *)v4[5];
        if (v6)
        {
          int v7 = v6;

          goto LABEL_9;
        }
      }
    }
    int v7 = p_isa[3];
    goto LABEL_9;
  }
  v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "nw_path_copy_effective_remote_endpoint";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v20 = "nw_path_copy_effective_remote_endpoint";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "nw_path_copy_effective_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_26:
  if (v10) {
    free(v10);
  }
  int v7 = 0;
LABEL_9:

  return v7;
}

uint64_t nw_array_get_object_at_index(uint64_t result, unint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!result) {
    return result;
  }
  uint64_t v3 = *(void *)(result + 16);
  if (a2 < (*(void *)(result + 24) - v3) >> 3) {
    return *(void *)(v3 + 8 * a2);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  os_log_type_t v13 = "nw_array_get_object_at_index";
  __int16 v14 = 2048;
  unint64_t v15 = a2;
  int v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v13 = "nw_array_get_object_at_index";
        __int16 v14 = 2048;
        unint64_t v15 = a2;
        int v7 = "%{public}s array index out of range: %lu";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0x16u);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v13 = "nw_array_get_object_at_index";
          __int16 v14 = 2048;
          unint64_t v15 = a2;
          __int16 v16 = 2082;
          char v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s array index out of range: %lu, dumping backtrace:%{public}s", buf, 0x20u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v13 = "nw_array_get_object_at_index";
        __int16 v14 = 2048;
        unint64_t v15 = a2;
        int v7 = "%{public}s array index out of range: %lu, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v13 = "nw_array_get_object_at_index";
        __int16 v14 = 2048;
        unint64_t v15 = a2;
        int v7 = "%{public}s array index out of range: %lu, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t nw_endpoint_handler_copy_connected_path(void *a1)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  v2 = v1;
  if (!v1)
  {
    char v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v29 = "nw_endpoint_handler_copy_connected_path";
    uint64_t v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v18, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v19 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v23)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v29 = "nw_endpoint_handler_copy_connected_path";
            __int16 v30 = 2082;
            v31 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_41;
        }
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v19 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "nw_endpoint_handler_copy_connected_path";
          _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_41:
    if (v18) {
      free(v18);
    }
    goto LABEL_23;
  }
  os_unfair_lock_lock(v1 + 28);
  if (v2[29]._os_unfair_lock_opaque != 2)
  {
    os_unfair_lock_unlock(v2 + 28);
    if ((v2[67]._os_unfair_lock_opaque & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if (v2[67]._os_unfair_lock_opaque) {
          id v5 = "dry-run ";
        }
        else {
          id v5 = "";
        }
        os_log_type_t v6 = (void *)nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        uint64_t os_unfair_lock_opaque = v2[30]._os_unfair_lock_opaque;
        BOOL v9 = logging_description;
        if (os_unfair_lock_opaque > 5) {
          char v10 = "unknown-state";
        }
        else {
          char v10 = off_1E523FB38[os_unfair_lock_opaque];
        }
        uint64_t v25 = v10;
        os_log_type_t v11 = v2;
        os_log_type_t v12 = v11;
        os_log_type_t v13 = "path";
        switch(v2[29]._os_unfair_lock_opaque)
        {
          case 0u:
            break;
          case 1u:
            os_log_type_t v13 = "resolver";
            break;
          case 2u:
            os_log_type_t v13 = nw_endpoint_flow_mode_string(v11[31]);
            break;
          case 3u:
            os_log_type_t v13 = "proxy";
            break;
          case 4u:
            os_log_type_t v13 = "fallback";
            break;
          case 5u:
            os_log_type_t v13 = "transform";
            break;
          default:
            os_log_type_t v13 = "unknown-mode";
            break;
        }

        __int16 v14 = v12;
        os_unfair_lock_lock(v2 + 28);
        id v15 = v14[8];
        os_unfair_lock_unlock(v2 + 28);

        *(_DWORD *)buf = 136447746;
        BOOL v29 = "nw_endpoint_handler_copy_connected_path";
        __int16 v30 = 2082;
        v31 = (char *)&v2[42];
        __int16 v32 = 2082;
        v33 = v5;
        __int16 v34 = 2082;
        v35 = v9;
        __int16 v36 = 2082;
        v37 = v25;
        __int16 v38 = 2082;
        v39 = v13;
        __int16 v40 = 2114;
        id v41 = v15;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is not flow", buf, 0x48u);
      }
    }
LABEL_23:
    uint64_t v3 = 0;
    goto LABEL_24;
  }
  uint64_t v3 = nw_endpoint_flow_copy_connected_path(*(void *)&v2[62]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v2 + 28);
LABEL_24:

  return v3;
}

void sub_1830D88C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_apply_override_interface_types_from_path(void *a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  char v10 = v4;
  if (!v3)
  {
    os_log_type_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v38 = "nw_path_apply_override_interface_types_from_path";
    __int16 v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v21, &type, &v35)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v38 = "nw_path_apply_override_interface_types_from_path";
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null path_to_modify", buf, 0xCu);
      }
    }
    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v22, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v38 = "nw_path_apply_override_interface_types_from_path";
          __int16 v39 = 2082;
          __int16 v40 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null path_to_modify, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v21) {
          goto LABEL_11;
        }
        goto LABEL_46;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v38 = "nw_path_apply_override_interface_types_from_path";
        _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null path_to_modify, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v38 = "nw_path_apply_override_interface_types_from_path";
        _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s called with null path_to_modify, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_44:

    goto LABEL_45;
  }
  if (!v4)
  {
    os_log_type_t v24 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v38 = "nw_path_apply_override_interface_types_from_path";
    __int16 v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v21, &type, &v35)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v38 = "nw_path_apply_override_interface_types_from_path";
        _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null other_path", buf, 0xCu);
      }
    }
    else if (v35)
    {
      BOOL v29 = (char *)__nw_create_backtrace_string();
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v30 = type;
      BOOL v31 = os_log_type_enabled(v22, type);
      if (v29)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v38 = "nw_path_apply_override_interface_types_from_path";
          __int16 v39 = 2082;
          __int16 v40 = v29;
          _os_log_impl(&dword_1830D4000, v22, v30, "%{public}s called with null other_path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v29);
        if (!v21) {
          goto LABEL_11;
        }
LABEL_46:
        free(v21);
        goto LABEL_11;
      }
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v38 = "nw_path_apply_override_interface_types_from_path";
        _os_log_impl(&dword_1830D4000, v22, v30, "%{public}s called with null other_path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v38 = "nw_path_apply_override_interface_types_from_path";
        _os_log_impl(&dword_1830D4000, v22, v33, "%{public}s called with null other_path, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_44;
  }
  unsigned __int8 v11 = v3[475];
  char v12 = *((unsigned char *)v4 + 475) & 8 | v11;
  v3[475] = v12;
  int v13 = (*((unsigned char *)v4 + 475) | v11) & 0x40;
  v3[475] = v13 | v12 & 0xBF;
  char v14 = (*((unsigned char *)v4 + 475) | v11) & 0x80 | v13 & 0x7F | v12 & 0x3F;
  v3[475] = v14;
  int v15 = (*((unsigned char *)v4 + 475) | v11) & 0x10;
  char v16 = v14 & 0xEF | v15;
  v3[475] = v16;
  char v17 = *((unsigned char *)v4 + 476) & 2 | v3[476];
  v3[476] = v17;
  if ((v17 & 2) != 0)
  {
    uint64_t v18 = "Proxy used prohibited interface type";
    int v19 = 6;
    if (v13 || v16 < 0) {
      goto LABEL_10;
    }
    if ((v12 & 8) != 0)
    {
      uint64_t v18 = "Proxy used prohibited expensive path";
      int v19 = 5;
      goto LABEL_10;
    }
    if (v15)
    {
      uint64_t v18 = "Proxy used prohibited constrained path";
      int v19 = 26;
LABEL_10:
      nw_path_set_reason(v3, v19, v18, v5, v6, v7, v8, v9, v34);
    }
  }
LABEL_11:
}

void sub_1830D8E54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_array_apply(atomic_uchar *object, uint64_t a2)
{
  uint64_t v2 = 1;
  if (!object) {
    return v2;
  }
  if (atomic_fetch_add_explicit(object + 40, 1u, memory_order_relaxed) == 255)
  {
    uint64_t v9 = __nwlog_obj();
    os_log_type_enabled(v9, OS_LOG_TYPE_ERROR);
    char v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (!result)
    {
      uint64_t v2 = 0;
LABEL_12:
      free(v10);
      return v2;
    }
  }
  else
  {
    os_retain(object);
    uint64_t v5 = *((void *)object + 2);
    if (*((void *)object + 3) != v5)
    {
      unint64_t v6 = 0;
      do
      {
        uint64_t v2 = (*(uint64_t (**)(uint64_t, unint64_t, void))(a2 + 16))(a2, v6, *(void *)(v5 + 8 * v6));
        if ((v2 & 1) == 0) {
          break;
        }
        ++v6;
        uint64_t v5 = *((void *)object + 2);
      }
      while (v6 < (*((void *)object + 3) - v5) >> 3);
    }
    int add_explicit = atomic_fetch_add_explicit(object + 40, 0xFFu, memory_order_release);
    os_release(object);
    if (add_explicit) {
      return v2;
    }
    unsigned __int8 v11 = __nwlog_obj();
    os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
    char v10 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v10);
    if (!result) {
      goto LABEL_12;
    }
  }
  __break(1u);
  return result;
}

void nw_context_assert_queue(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (((_BYTE)v1[17] & 8) == 0) {
      dispatch_assert_queue_V2(v1[1]);
    }
    goto LABEL_4;
  }
  uint64_t v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_context_assert_queue";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_context_assert_queue";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_context_assert_queue";
          __int16 v15 = 2082;
          char v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_context_assert_queue";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_context_assert_queue";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v4) {
    free(v4);
  }
LABEL_4:
}

void sub_1830D9444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_copy_connected_interface_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = v4;
  os_log_type_t v6 = (void *)*((void *)v4 + 2);
  if (v6 && (*((unsigned char *)v4 + 185) & 1) != 0)
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), v6);
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

uint64_t __nw_path_copy_for_flow_registration_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = v4;
  uint64_t v6 = *(void *)(a1 + 32);
  if (v4[18] == *(void *)(v6 + 32) && v4[19] == *(void *)(v6 + 40) && (*(unsigned char *)(v6 + 149) & 1) == 0)
  {
    nw_array_append(*(void *)(*(void *)(a1 + 40) + 72), v4);
  }
  else
  {
    uint64_t v7 = *(atomic_uchar **)(v6 + 16);
    if (v7)
    {
      v9[0] = MEMORY[0x1E4F143A8];
      v9[1] = 3221225472;
      v9[2] = __nw_path_copy_for_flow_registration_block_invoke_3;
      v9[3] = &unk_1E52497B8;
      os_log_type_t v10 = v4;
      id v11 = *(id *)(a1 + 40);
      char v12 = v10;
      nw_array_apply(v7, (uint64_t)v9);
    }
  }

  return 1;
}

void sub_1830D982C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_protocol_options;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void nw_ip_deallocate_options(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void nw_tcp_deallocate_options(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

uint64_t __nw_protocol_stack_copy_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 16);
  id v4 = nw_protocol_options_copy(a3);
  nw_array_append(v3, v4);

  return 1;
}

void nw_array_append(uint64_t a1, void *object)
{
  if (a1 && object)
  {
    int v3 = a1 + 40;
    LOBYTE(v3) = atomic_load_explicit((atomic_uchar *volatile)(a1 + 40), memory_order_acquire);
    if (v3)
    {
      uint64_t v4 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v4);
      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      uint64_t v5 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v5)) {
        __break(1u);
      }
      else {
        free(v5);
      }
    }
    else
    {
      uint64_t v6 = *(void ***)(a1 + 24);
      if ((unint64_t)v6 >= *(void *)(a1 + 32))
      {
        uint64_t v7 = std::vector<nw_object_wrapper_t>::__emplace_back_slow_path<nw_object *&>(a1 + 16, object);
      }
      else
      {
        void *v6 = os_retain(object);
        uint64_t v7 = v6 + 1;
      }
      *(void *)(a1 + 24) = v7;
    }
  }
}

void *std::vector<nw_object_wrapper_t>::__emplace_back_slow_path<nw_object *&>(uint64_t a1, void *a2)
{
  uint64_t v2 = *(void **)a1;
  unint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = v3 - *(void *)a1;
  uint64_t v5 = v4 >> 3;
  unint64_t v6 = (v4 >> 3) + 1;
  if (v6 >> 61) {
    abort();
  }
  uint64_t v9 = *(void *)(a1 + 16) - (void)v2;
  if (v9 >> 2 > v6) {
    unint64_t v6 = v9 >> 2;
  }
  if ((unint64_t)v9 >= 0x7FFFFFFFFFFFFFF8) {
    unint64_t v10 = 0x1FFFFFFFFFFFFFFFLL;
  }
  else {
    unint64_t v10 = v6;
  }
  if (v10)
  {
    if (v10 >> 61) {
      std::__throw_bad_array_new_length[abi:nn180100]();
    }
    id v11 = (char *)operator new(8 * v10);
    char v12 = &v11[8 * v5];
    if (a2) {
      goto LABEL_10;
    }
  }
  else
  {
    id v11 = 0;
    char v12 = (char *)(8 * v5);
    if (a2)
    {
LABEL_10:
      int v13 = os_retain(a2);
      uint64_t v2 = *(void **)a1;
      unint64_t v3 = *(void *)(a1 + 8);
      goto LABEL_13;
    }
  }
  int v13 = 0;
LABEL_13:
  char v14 = &v11[8 * v10];
  *(void *)char v12 = v13;
  __int16 v15 = v12 + 8;
  if ((void *)v3 == v2)
  {
    *(void *)a1 = v12;
    *(void *)(a1 + 8) = v15;
    *(void *)(a1 + 16) = v14;
    goto LABEL_25;
  }
  unint64_t v16 = v3 - (void)v2 - 8;
  if (v16 <= 0x77
    || (unint64_t)&v11[v4 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8] < v3
    && v3 - (v16 & 0xFFFFFFFFFFFFFFF8) - 8 < (unint64_t)v12)
  {
    uint64_t v17 = (void *)v3;
    do
    {
LABEL_18:
      uint64_t v18 = *--v17;
      *((void *)v12 - 1) = v18;
      v12 -= 8;
      void *v17 = 0;
    }
    while (v17 != v2);
    goto LABEL_19;
  }
  uint64_t v24 = (v16 >> 3) + 1;
  uint64_t v17 = (void *)(v3 - 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL));
  os_log_type_t v25 = &v11[8 * v5 - 16];
  char v26 = (_OWORD *)(v3 - 32);
  uint64_t v27 = v24 & 0x3FFFFFFFFFFFFFFCLL;
  do
  {
    long long v28 = v26[1];
    *((_OWORD *)v25 - 1) = *v26;
    *(_OWORD *)os_log_type_t v25 = v28;
    *char v26 = 0uLL;
    v26[1] = 0uLL;
    v26 -= 2;
    v25 -= 32;
    v27 -= 4;
  }
  while (v27);
  v12 -= 8 * (v24 & 0x3FFFFFFFFFFFFFFCLL);
  if (v24 != (v24 & 0x3FFFFFFFFFFFFFFCLL)) {
    goto LABEL_18;
  }
LABEL_19:
  uint64_t v2 = *(void **)a1;
  int v19 = *(void **)(a1 + 8);
  *(void *)a1 = v12;
  *(void *)(a1 + 8) = v15;
  *(void *)(a1 + 16) = v14;
  if (v19 != v2)
  {
    os_log_type_t v20 = v19;
    do
    {
      os_log_type_t v22 = (void *)*--v20;
      __int16 v21 = v22;
      if (v22) {
        os_release(v21);
      }
      *(v19 - 1) = 0;
      int v19 = v20;
    }
    while (v20 != v2);
  }
LABEL_25:
  if (v2) {
    operator delete(v2);
  }
  return v15;
}

uint64_t __nw_content_context_set_metadata_for_protocol_block_invoke(void *a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a3;
  unint64_t v6 = a1[4];
  if (v6 == v5)
  {
    uint64_t v11 = 0;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
  }
  else
  {
    uint64_t v7 = *(void *)(*(void *)(a1[6] + 8) + 40);
    if (!v7)
    {
      nw_protocol_definition_t v8 = nw_protocol_metadata_copy_definition(v6);
      uint64_t v9 = *(void *)(a1[6] + 8);
      unint64_t v10 = *(void **)(v9 + 40);
      *(void *)(v9 + 40) = v8;

      uint64_t v7 = *(void *)(*(void *)(a1[6] + 8) + 40);
    }
    if (nw_protocol_metadata_matches_definition((uint64_t)v5, v7))
    {
      objc_storeStrong((id *)(*(void *)(a1[7] + 8) + 40), a3);
      uint64_t v11 = 0;
    }
    else
    {
      uint64_t v11 = 1;
    }
  }

  return v11;
}

void sub_1830D9C94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_flow_copy_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v5 = a3;
  nw_protocol_definition_t v6 = nw_protocol_metadata_copy_definition(v5);
  if (nw_protocol_definition_is_equal_unsafe(*(void *)(a1 + 32), (uint64_t)v6)) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return 1;
}

void sub_1830D9D1C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_definition_t nw_protocol_metadata_copy_definition(nw_protocol_metadata_t metadata)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v1 = metadata;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    unint64_t v3 = v1[1].isa;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v16 = "nw_protocol_metadata_copy_definition";
  nw_protocol_definition_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v16 = "nw_protocol_metadata_copy_definition";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v16 = "nw_protocol_metadata_copy_definition";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  unint64_t v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_protocol_transform *nw_protocol_transform_copy(void *a1)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v1 = a1;
  if (v1)
  {
    nw_protocol_metadata_t v2 = objc_alloc_init(NWConcrete_nw_protocol_transform);
    unint64_t v3 = v2;
    if (v2)
    {
      int v4 = *((unsigned char *)v2 + 8) & 0xFE | v1[8] & 1;
      *((unsigned char *)v2 + 8) = v4;
      unsigned int v5 = v4 & 0xFFFFFFFD | (2 * ((v1[8] >> 1) & 1));
      *((unsigned char *)v2 + 8) = v5;
      unsigned int v6 = v5 & 0xFFFFFFFB | (4 * ((v1[8] >> 2) & 1));
      *((unsigned char *)v2 + 8) = v6;
      unsigned int v7 = v6 & 0xFFFFFFF7 | (8 * ((v1[8] >> 3) & 1));
      *((unsigned char *)v2 + 8) = v7;
      unsigned int v8 = v7 & 0xFFFFFFEF | (16 * ((v1[8] >> 4) & 1));
      *((unsigned char *)v2 + 8) = v8;
      unsigned int v9 = v8 & 0xFFFFFFDF | (32 * ((v1[8] >> 5) & 1));
      *((unsigned char *)v2 + 8) = v9;
      LOBYTE(v9) = v9 & 0xBF | (((v1[8] & 0x40) != 0) << 6);
      *((unsigned char *)v2 + 8) = v9;
      *((unsigned char *)v2 + 8) = v1[8] & 0x80 | v9 & 0x7F;
      int v10 = *((unsigned char *)v2 + 9) & 0xFE | v1[9] & 1;
      *((unsigned char *)v2 + 9) = v10;
      unsigned int v11 = v10 & 0xFFFFFFFD | (2 * ((v1[9] >> 1) & 1));
      *((unsigned char *)v2 + 9) = v11;
      *((unsigned char *)v2 + 9) = v11 & 0xFB | v1[9] & 4;
      *(_OWORD *)&v2->traffic_class = *(_OWORD *)(v1 + 12);
      objc_storeStrong((id *)&v2->replace_endpoint, *((id *)v1 + 4));
      os_log_type_t v12 = (void *)*((void *)v1 + 5);
      if (v12)
      {
        char v13 = (OS_xpc_object *)xpc_copy(v12);
        disabled_protocols = v3->disabled_protocols;
        v3->disabled_protocols = v13;
      }
      __int16 v15 = (void *)*((void *)v1 + 6);
      if (v15)
      {
        unint64_t v16 = (OS_xpc_object *)xpc_copy(v15);
        match_url_schemes = v3->match_url_schemes;
        v3->match_url_schemes = v16;
      }
      uint64_t v18 = (void *)*((void *)v1 + 7);
      if (v18)
      {
        uint64_t v19 = nw_protocol_stack_copy(v18);
        transform_stack = v3->transform_stack;
        v3->transform_stack = (OS_nw_protocol_stack *)v19;
      }
      __int16 v21 = v3;
      goto LABEL_29;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "nw_protocol_transform_copy";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault(v23, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v39)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (id)gLogObj;
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "nw_protocol_transform_copy";
            __int16 v43 = 2082;
            v44 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v23) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v24 = (id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "nw_protocol_transform_copy";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v23)
    {
LABEL_29:

      goto LABEL_30;
    }
LABEL_28:
    free(v23);
    goto LABEL_29;
  }
  BOOL v31 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v42 = "nw_protocol_transform_copy";
  os_log_type_t v32 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v39 = 0;
  if (__nwlog_fault(v32, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v33 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v39)
    {
      char v35 = (char *)__nw_create_backtrace_string();
      os_log_type_t v33 = __nwlog_obj();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v33, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v42 = "nw_protocol_transform_copy";
          __int16 v43 = 2082;
          v44 = v35;
          _os_log_impl(&dword_1830D4000, v33, v36, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v35);
        goto LABEL_47;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_1830D4000, v33, v36, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v33 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v33, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "nw_protocol_transform_copy";
        _os_log_impl(&dword_1830D4000, v33, v38, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_47:
  if (v32) {
    free(v32);
  }
  unint64_t v3 = 0;
LABEL_30:

  return v3;
}

void sub_1830DA658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_is_viable_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  int v4 = a3;
  unsigned int v5 = v4;
  if ((v4[185] & 2) != 0)
  {
    if (v4[185]) {
      goto LABEL_15;
    }
    unsigned int v7 = v4;
    unsigned int v8 = (void *)v7[3];
    if (!v8
      || (size_t length = 0, (data = xpc_dictionary_get_data(v8, "data", &length)) == 0)
      || length < 0xD8
      || (int v10 = data, length != data[53] + 216)
      || ((data[52] & 0xE080) != 0 ? (BOOL v11 = (data[52] & 0x13) == 1) : (BOOL v11 = 1), v11))
    {

      uint64_t v6 = 1;
      goto LABEL_16;
    }

    if ((v10[52] & 0x40) != 0)
    {
LABEL_15:
      uint64_t v6 = 0;
      *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
      goto LABEL_16;
    }
  }
  uint64_t v6 = 1;
LABEL_16:

  return v6;
}

uint64_t ___ZL34nw_path_copy_flow_for_registrationP18NWConcrete_nw_pathP36NWConcrete_nw_path_flow_registration_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  uint64_t v6 = v5;
  uint64_t v7 = *(void *)(a1 + 32);
  if (*((void *)v5 + 18) == *(void *)(v7 + 32) && *((void *)v5 + 19) == *(void *)(v7 + 40))
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
    uint64_t v8 = 0;
  }
  else
  {
    uint64_t v8 = 1;
  }

  return v8;
}

uint64_t __nw_protocol_stack_iterate_application_protocols_block_invoke_2(uint64_t a1)
{
  return 1;
}

void nw_quic_connection_deallocate_options(uint64_t a1, uint64_t a2)
{
  unint64_t v3 = *(void **)(a2 + 96);
  *(void *)(a2 + 96) = 0;

  int v4 = *(const void **)(a2 + 104);
  if (v4)
  {
    CFRelease(v4);
    *(void *)(a2 + 104) = 0;
  }
  id v5 = *(const void **)(a2 + 112);
  if (v5)
  {
    CFRelease(v5);
    *(void *)(a2 + 112) = 0;
  }
  uint64_t v6 = *(const void **)(a2 + 120);
  if (v6)
  {
    CFRelease(v6);
    *(void *)(a2 + 120) = 0;
  }
  uint64_t v7 = *(const void **)(a2 + 128);
  if (v7)
  {
    CFRelease(v7);
    *(void *)(a2 + 128) = 0;
  }
  uint64_t v8 = *(void **)(a2 + 136);
  *(void *)(a2 + 136) = 0;

  unsigned int v9 = *(void **)(a2 + 144);
  *(void *)(a2 + 144) = 0;

  int v10 = *(void **)(a2 + 160);
  *(void *)(a2 + 160) = 0;

  BOOL v11 = *(void **)(a2 + 168);
  *(void *)(a2 + 168) = 0;

  os_log_type_t v12 = *(void **)(a2 + 176);
  *(void *)(a2 + 176) = 0;

  char v13 = *(void **)(a2 + 184);
  *(void *)(a2 + 184) = 0;

  char v14 = *(void **)(a2 + 152);
  *(void *)(a2 + 152) = 0;

  free((void *)a2);
}

void nw_proxy_deallocate_options(uint64_t a1, void **a2)
{
  unint64_t v3 = *a2;
  *a2 = 0;

  int v4 = a2[1];
  if (v4) {
    free(v4);
  }

  free(a2);
}

uint64_t ___ZL22nw_path_snapshot_flowsP18NWConcrete_nw_path_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = (void ***)*((void *)v4 + 6);
  if (v5)
  {
    uint64_t v6 = *(void *)(a1 + 32);
    uint64_t v7 = *(void *)(v6 + 56);
    if (v7)
    {
      uint64_t v8 = nw_array_create();
      std::vector<nw_object_wrapper_t>::reserve(v8 + 16, v5[3] - v5[2] + ((uint64_t)(*(void *)(v7 + 24) - *(void *)(v7 + 16)) >> 3));
      std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>((int64_t *)(v8 + 16), *(void *)(v8 + 16), *(void ***)(v7 + 16), *(void ***)(v7 + 24), (uint64_t)(*(void *)(v7 + 24) - *(void *)(v7 + 16)) >> 3);
      std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>((int64_t *)(v8 + 16), *(void *)(v8 + 24), v5[2], v5[3], v5[3] - v5[2]);
      uint64_t v9 = *(void *)(a1 + 32);
      int v10 = *(void **)(v9 + 56);
      *(void *)(v9 + 56) = v8;
    }
    else
    {
      BOOL v11 = v5;
      int v10 = *(void **)(v6 + 56);
      *(void *)(v6 + 56) = v11;
    }
  }
  os_log_type_t v12 = (void ***)*((void *)v4 + 7);
  if (v12)
  {
    uint64_t v13 = *(void *)(a1 + 32);
    uint64_t v14 = *(void *)(v13 + 64);
    if (v14)
    {
      uint64_t v15 = nw_array_create();
      std::vector<nw_object_wrapper_t>::reserve(v15 + 16, v12[3] - v12[2] + ((uint64_t)(*(void *)(v14 + 24) - *(void *)(v14 + 16)) >> 3));
      std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>((int64_t *)(v15 + 16), *(void *)(v15 + 16), *(void ***)(v14 + 16), *(void ***)(v14 + 24), (uint64_t)(*(void *)(v14 + 24) - *(void *)(v14 + 16)) >> 3);
      std::vector<nw_object_wrapper_t>::__insert_with_size[abi:nn180100]<std::__wrap_iter<nw_object_wrapper_t*>,std::__wrap_iter<nw_object_wrapper_t*>>((int64_t *)(v15 + 16), *(void *)(v15 + 24), v12[2], v12[3], v12[3] - v12[2]);
      uint64_t v16 = *(void *)(a1 + 32);
      __int16 v17 = *(void **)(v16 + 64);
      *(void *)(v16 + 64) = v15;
    }
    else
    {
      uint64_t v18 = v12;
      __int16 v17 = *(void **)(v13 + 64);
      *(void *)(v13 + 64) = v18;
    }
  }
  if (!uuid_is_null((const unsigned __int8 *)v4 + 84))
  {
    id v19 = nw_parameters_copy_context(*(void **)(*(void *)(a1 + 32) + 16));
    id v20 = nw_path_copy_dictionary_for_agent_with_generation(v19, (const unsigned __int8 *)v4 + 84, *((_DWORD *)v4 + 20), 0);
    __int16 v21 = (void *)*((void *)v4 + 3);
    *((void *)v4 + 3) = v20;
  }
  if (*(unsigned char *)(*(void *)(a1 + 32) + 386)) {
    *((unsigned char *)v4 + 186) |= 8u;
  }

  return 1;
}

void sub_1830DADE8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_enumerate_protocols_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __nw_endpoint_handler_copy_resolved_endpoints_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  nw_endpoint_t v4 = nw_endpoint_handler_copy_endpoint(a3);
  nw_array_append(*(void *)(a1 + 32), v4);

  return 1;
}

void ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke(uint64_t a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v1 = *(void **)(a1 + 32);
  if (v1)
  {
    unint64_t v3 = v1;
    uint64_t v4 = v3[29];

    if (v4 == 1)
    {
      if (nw_endpoint_handler_trigger_agents(*(void **)(a1 + 32), 1))
      {
        if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v5 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
            uint64_t v7 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
            nw_endpoint_t v8 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
            logging_description = nw_endpoint_get_logging_description(v8);
            int v10 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
            BOOL v11 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
            id v12 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
            *(_DWORD *)buf = 136447746;
            char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
            __int16 v27 = 2082;
            BOOL v28 = (void *)id_string;
            __int16 v29 = 2082;
            os_log_type_t v30 = v7;
            __int16 v31 = 2082;
            os_log_type_t v32 = logging_description;
            __int16 v33 = 2082;
            os_log_type_t v34 = v10;
            __int16 v35 = 2082;
            os_log_type_t v36 = v11;
            __int16 v37 = 2114;
            id v38 = v12;
            _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Child flow failed, trying to trigger matching voluntary agents", buf, 0x48u);
          }
        }
        nw_endpoint_handler_reset_mode(*(void **)(a1 + 32), 0);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = (id)gLogObj;
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
      {
        if (v4 > 5) {
          uint64_t v14 = "unknown-mode";
        }
        else {
          uint64_t v14 = off_1E523FB08[v4];
        }
        *(_DWORD *)buf = 136446722;
        char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        __int16 v27 = 2082;
        BOOL v28 = (void *)v14;
        __int16 v29 = 2082;
        os_log_type_t v30 = "resolver";
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    return;
  }
  uint64_t v15 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
  uint64_t v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v16, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v17 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
          __int16 v27 = 2082;
          BOOL v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_34;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v17 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_resolver_receive_report_block_invoke";
        _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_34:
  if (v16) {
    free(v16);
  }
}

void sub_1830DB2F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_establishment_report_enumerate_resolution_reports_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

BOOL __nw_content_context_copy_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  nw_protocol_definition_t v6 = nw_protocol_metadata_copy_definition(v5);
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v6, *(void *)(a1 + 32));

  if (is_equal_unsafe) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return !is_equal_unsafe;
}

void sub_1830DB3FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_handler_register_context_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  nw_protocol_definition_t v6 = nw_protocol_metadata_copy_definition(v5);
  if (nw_protocol_definition_is_equal_unsafe(*(void *)(*(void *)(a1 + 32) + 768), (uint64_t)v6)) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return 1;
}

void sub_1830DB550(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL45nw_listener_has_flow_for_nexus_agent_on_queueP22NWConcrete_nw_listenerPh_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  if (!nw_path_flow_registration_uses_nexus(v4, *(const unsigned __int8 **)(a1 + 48))
    || (id v5 = nw_path_copy_flow_for_registration(*(NWConcrete_nw_path **)(*(void *)(a1 + 32) + 176), v4)) != 0
    && (char v6 = v5[186], v5, (v6 & 4) != 0))
  {
    uint64_t v7 = 1;
  }
  else
  {
    uint64_t v7 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }

  return v7;
}

void sub_1830DB5F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_enumerate_resolver_configs_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

BOOL ___ZL36nw_endpoint_transform_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_103(uint64_t a1, unint64_t a2, void *a3)
{
  id v5 = a3;
  char v6 = v5;
  uint64_t v7 = *(void *)(a1 + 32);
  unint64_t v8 = *(unsigned int *)(v7 + 40);
  if (v8 > a2)
  {
    if (*(id *)(a1 + 40) == v5)
    {
      *(_DWORD *)(v7 + 88) = a2;
    }
    else
    {
      id v9 = nw_endpoint_handler_copy_parameters(v5);
      if (nw_parameters_get_upper_transport_protocol(v9) == 253)
      {
        id v10 = nw_endpoint_handler_copy_association(*(void **)(a1 + 48), 0);
        nw_quic_report_race_result_on_queue(v10, 0, 1);
      }
      nw_endpoint_handler_cancel(v6, 0, 0);
    }
  }

  return v8 > a2;
}

void sub_1830DB70C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_protocol_transform_modify_parameters_block_invoke_2(uint64_t a1, void *a2)
{
}

void nw_udp_deallocate_options(int a1, void *a2)
{
  if (a2) {
    free(a2);
  }
}

void nw_quic_stream_deallocate_options(uint64_t a1, void *a2)
{
  unint64_t v3 = (void *)a2[2];
  a2[2] = 0;

  free(a2);
}

uint64_t ___ZL41nw_resolver_create_happy_eyeballs_variantP22NWConcrete_nw_resolverPU22objcproto11OS_nw_array8NSObject_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  char v6 = a3;
  if (nw_endpoint_get_type(v6) == nw_endpoint_type_address)
  {
    if (nw_endpoint_get_address_family(v6) == *(unsigned __int8 *)(a1 + 56))
    {
      uint64_t v7 = 1;
    }
    else
    {
      *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 48) + 8) + 40), a3);
      uint64_t v7 = 0;
    }
  }
  else
  {
    uint64_t v7 = 0;
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }

  return v7;
}

void sub_1830DB834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_211(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v12 = 0;
  uint64_t v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  uint64_t v4 = a3;
  id v5 = nw_path_copy_flow_for_registration(*(NWConcrete_nw_path **)(*(void *)(a1 + 32) + 176), v4);
  if (!v5 || (char v6 = v5[186], v5, (v6 & 4) == 0))
  {
    uint64_t v7 = *(void **)(*(void *)(a1 + 32) + 176);
    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_2_212;
    v9[3] = &unk_1E523D020;
    id v10 = v4;
    BOOL v11 = &v12;
    nw_path_enumerate_interface_options(v7, v9);
  }
  if (!*((unsigned char *)v13 + 24)) {
    nw_array_append(*(void *)(a1 + 40), v4);
  }

  _Block_object_dispose(&v12, 8);
  return 1;
}

void sub_1830DB964(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL53nw_establishment_report_get_handshake_ms_for_protocolPU37objcproto26OS_nw_establishment_report8NSObjectPU36objcproto25OS_nw_protocol_definitionS_S3__block_invoke(uint64_t *a1, void *a2, uint64_t a3)
{
  id v5 = a2;
  if (nw_protocol_definition_is_equal_unsafe((uint64_t)v5, a1[4])
    || (uint64_t v6 = a1[5]) != 0 && nw_protocol_definition_is_equal_unsafe((uint64_t)v5, v6))
  {
    uint64_t v7 = 0;
    *(void *)(*(void *)(a1[6] + 8) + 24) = a3;
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

void sub_1830DBA00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_parameters_copy_protocol_options_for_definition_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  nw_protocol_definition_t v6 = nw_protocol_options_copy_definition(v5);
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(*(void *)(a1 + 32), (uint64_t)v6);
  if (is_equal_unsafe) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
  }

  return !is_equal_unsafe;
}

void sub_1830DBA94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_enumerate_gateways_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t __nw_establishment_report_copy_dictionary_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  xpc_object_t v5 = xpc_dictionary_create(0, 0, 0);
  identifier = nw_protocol_definition_get_identifier(*((void **)v4 + 4));
  if (identifier) {
    xpc_dictionary_set_string(v5, "protocol", identifier);
  }
  uint64_t v7 = *((void *)v4 + 1);
  if (v7) {
    xpc_dictionary_set_uint64(v5, "handshake_milliseconds", v7);
  }
  uint64_t v8 = *((void *)v4 + 2);
  if (v8) {
    xpc_dictionary_set_uint64(v5, "handshake_rtt_milliseconds", v8);
  }
  uint64_t v9 = v4[6];
  if (v9) {
    xpc_dictionary_set_uint64(v5, "client_accurate_ecn_state", v9);
  }
  uint64_t v10 = v4[7];
  if (v10) {
    xpc_dictionary_set_uint64(v5, "server_accurate_ecn_state", v10);
  }
  if (v4[10]) {
    xpc_dictionary_set_BOOL(v5, "l4s_enabled", 1);
  }
  xpc_array_append_value(*(xpc_object_t *)(a1 + 32), v5);

  return 1;
}

void sub_1830DBBC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL31nw_resolver_check_svcb_completeP22NWConcrete_nw_resolver_block_invoke(uint64_t a1, uint64_t a2, uint64_t a3)
{
  if (!*(void *)(a3 + 24)) {
    return 1;
  }
  __int16 v3 = *(_WORD *)(a3 + 36);
  int v4 = v3 & 5;
  int v5 = v3 & 0xA;
  uint64_t v6 = 1;
  if (v4) {
    BOOL v7 = v5 == 0;
  }
  else {
    BOOL v7 = 1;
  }
  if (v7)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return v6;
}

uint64_t ___ZL31nw_resolver_cancel_query_lockedP22NWConcrete_nw_resolverb_block_invoke(uint64_t a1, uint64_t a2, NWConcrete_nw_resolver_service *a3)
{
  return 1;
}

void nw_resolver_service_cancel_query(NWConcrete_nw_resolver_service *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  nw_protocol_metadata_t v1 = a1;
  nw_protocol_metadata_t v2 = v1;
  if (v1)
  {
    if (v1->gai)
    {
      dnssd_getaddrinfo_invalidate();
      gai = v2->gai;
      v2->gai = 0;
    }
    goto LABEL_4;
  }
  int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_resolver_service_cancel_query";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_resolver_service_cancel_query";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null service", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          char v15 = "nw_resolver_service_cancel_query";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null service, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_resolver_service_cancel_query";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null service, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_resolver_service_cancel_query";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null service, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v5) {
    free(v5);
  }
LABEL_4:
}

void sub_1830DBEEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL45nw_listener_find_channel_inbox_match_on_queueP22NWConcrete_nw_listenerPU26objcproto15OS_nw_path_flow8NSObjectPU27objcproto16OS_nw_parametersS1__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    id v5 = v4;
    uint64_t v6 = *(void **)(a1 + 40);
    id v7 = *(id *)(a1 + 32);
    id v8 = v6;
    os_log_type_t v9 = v8;
    if (!v5) {
      goto LABEL_49;
    }
    if (v7)
    {
      if (v8)
      {
        if (nw_parameters_is_equal(v8, *((void **)v5 + 6)))
        {
          BOOL v10 = (void *)*((void *)v5 + 9);
          os_log_type_t v11 = v7;
          char v12 = v10;
          BOOL v13 = v11 == v12;
          if (v11 != v12 && v12)
          {
            if (v11[18] != v12[18])
            {

              goto LABEL_50;
            }
            BOOL v13 = v11[19] == v12[19];
          }

          if (v13)
          {
            uint64_t v14 = 0;
            uint64_t v15 = *(void *)(*(void *)(a1 + 48) + 8);
            __int16 v16 = *(void **)(v15 + 40);
            *(void *)(v15 + 40) = v5;
            id v5 = v16;
LABEL_51:

            goto LABEL_52;
          }
LABEL_50:
          uint64_t v14 = 1;
          goto LABEL_51;
        }
LABEL_49:

        goto LABEL_50;
      }
      BOOL v21 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (!__nwlog_fault(v18, &type, &v32)) {
        goto LABEL_47;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v19 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
          _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v19 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v19, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
            __int16 v36 = 2082;
            __int16 v37 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v19, v27, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v18) {
            goto LABEL_49;
          }
          goto LABEL_48;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
          _os_log_impl(&dword_1830D4000, v19, v27, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v19 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
          _os_log_impl(&dword_1830D4000, v19, v30, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    else
    {
      __int16 v17 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v32 = 0;
      if (!__nwlog_fault(v18, &type, &v32)) {
        goto LABEL_47;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null flow", buf, 0xCu);
        }
      }
      else if (v32)
      {
        char v23 = (char *)__nw_create_backtrace_string();
        id v19 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v19, type);
        if (v23)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
            __int16 v36 = 2082;
            __int16 v37 = v23;
            _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s called with null flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v23);
LABEL_47:
          if (!v18) {
            goto LABEL_49;
          }
LABEL_48:
          free(v18);
          goto LABEL_49;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
          _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s called with null flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v19 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v19, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v35 = "-[nw_ip_channel_inbox matchesFlow:parameters:]";
          _os_log_impl(&dword_1830D4000, v19, v29, "%{public}s called with null flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }

    goto LABEL_47;
  }
  uint64_t v14 = 1;
LABEL_52:

  return v14;
}

void sub_1830DC4E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL58nw_protocol_stack_iterate_application_protocols_with_indexP28NWConcrete_nw_protocol_stackU13block_pointerFbmPU33objcproto22OS_nw_protocol_options8NSObjectE_block_invoke_2(uint64_t a1)
{
  uint64_t result = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
  ++*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  return result;
}

BOOL ___ZL55nw_protocol_stack_application_protocols_are_equal_belowP28NWConcrete_nw_protocol_stackmS0_P11nw_protocol28nw_parameters_compare_mode_tPmS4__block_invoke(void *a1, uint64_t a2, void *a3)
{
  uint64_t protocol_handle = nw_protocol_options_get_protocol_handle(a3);
  uint64_t v6 = a1[6];
  if (protocol_handle == v6)
  {
    *(void *)(*(void *)(a1[4] + 8) + 24) = a2;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
  }
  return protocol_handle != v6;
}

uint64_t ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  objc_opt_class();
  if (objc_opt_isKindOfClass())
  {
    uint64_t v5 = *(void *)(a1 + 32);
    if (!v5 || !v4) {
      goto LABEL_9;
    }
    id v7 = *(id **)(v5 + 16);
    uint64_t v6 = *(id **)(v5 + 24);
    if (v7 != v6)
    {
      while (*v7 != v4)
      {
        if (++v7 == v6)
        {
          id v7 = *(id **)(v5 + 24);
          break;
        }
      }
    }
    if (v7 == v6) {
LABEL_9:
    }
      nw_array_append(v5, v4);
  }

  return 1;
}

void sub_1830DC66C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_context_8k_buffer_length()
{
  return dword_1E8F65160;
}

uint64_t ___ZL23nw_path_get_nexus_agentP18NWConcrete_nw_pathb_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = v4;
  size_t length = 0;
  if (v4
    && (data = xpc_dictionary_get_data(v4, "data", &length)) != 0
    && length >= 0xD8
    && length == data[53] + 216
    && (int v7 = data[52], (v7 & 0xE080) != 0))
  {
    BOOL v9 = (v7 & 0x40) == 0 && *(unsigned char *)(a1 + 40) != 0;
    uint64_t v10 = 1;
    if ((data[52] & 0x13) != 1 && !v9)
    {
      uint64_t v10 = 0;
      *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = data;
    }
  }
  else
  {
    uint64_t v10 = 1;
  }

  return v10;
}

uint64_t in_addword(int a1, int a2)
{
  unsigned int v2 = ((a2 + a1) >> 16) + (unsigned __int16)(a2 + a1);
  return (unsigned __int16)(HIWORD(v2) + v2 + ((HIWORD(v2) + (unsigned __int16)v2) >> 16));
}

uint64_t NWConnection.ContentContext.__deallocating_deinit()
{
  NWConnection.ContentContext.deinit();

  return swift_deallocClassInstance();
}

uint64_t NWConnection.ContentContext.deinit()
{
  swift_unknownObjectRelease();
  swift_bridgeObjectRelease();
  uint64_t v1 = *(void *)(v0 + 56);
  *(void *)(v0 + 56) = 0;
  if (v1)
  {
    do
    {
      if (!swift_isUniquelyReferenced_native()) {
        break;
      }
      uint64_t v2 = *(void *)(v1 + 56);
      swift_retain();
      swift_release();
      uint64_t v1 = v2;
    }
    while (v2);
  }
  swift_release();
  return v0;
}

void __Block_byref_object_dispose__11(uint64_t a1)
{
}

ValueMetadata *type metadata accessor for NWApplicationID()
{
  return &type metadata for NWApplicationID;
}

uint64_t block_destroy_helper()
{
  return swift_release();
}

uint64_t block_destroy_helper_0()
{
  return swift_release();
}

uint64_t block_destroy_helper_1()
{
  return swift_release();
}

uint64_t block_destroy_helper_2()
{
  return swift_release();
}

uint64_t block_destroy_helper_3()
{
  return swift_release();
}

uint64_t block_destroy_helper_4()
{
  return swift_release();
}

uint64_t block_destroy_helper_5()
{
  return swift_release();
}

uint64_t block_destroy_helper_6()
{
  return swift_release();
}

uint64_t block_destroy_helper_7()
{
  return swift_release();
}

uint64_t block_destroy_helper_8()
{
  return swift_release();
}

uint64_t block_destroy_helper_9()
{
  return swift_release();
}

uint64_t block_destroy_helper_10()
{
  return swift_release();
}

uint64_t block_destroy_helper_11()
{
  return swift_release();
}

uint64_t block_destroy_helper_12()
{
  return swift_release();
}

uint64_t block_destroy_helper_13()
{
  return swift_release();
}

uint64_t block_destroy_helper_14()
{
  return swift_release();
}

uint64_t block_destroy_helper_15()
{
  return swift_release();
}

uint64_t block_destroy_helper_16()
{
  return swift_release();
}

uint64_t block_destroy_helper_17()
{
  return swift_release();
}

uint64_t block_destroy_helper_18()
{
  return swift_release();
}

uint64_t ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void, void, void))(*(void *)(a1 + 56) + 16))(*(void *)(a1 + 56), *(void *)(a1 + 32), *(void *)(a1 + 40), *(unsigned __int8 *)(a1 + 64), *(void *)(a1 + 48));
}

void ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke(uint64_t a1)
{
}

uint64_t in_pseudo(unsigned int a1, unsigned int a2, unsigned int a3)
{
  unint64_t v3 = a2 + (unint64_t)a1 + a3;
  LODWORD(v3) = ((WORD1(v3) + (unsigned __int16)v3 + HIDWORD(v3)) >> 16)
              + (unsigned __int16)(WORD1(v3) + v3 + WORD2(v3));
  return (unsigned __int16)(((WORD1(v3) + (unsigned __int16)v3) >> 16)
                          + WORD1(v3)
                          + v3
                          + ((((WORD1(v3) + (unsigned __int16)v3) >> 16)
                            + (unsigned __int16)(WORD1(v3) + v3)) >> 16));
}

void *sub_1830DC97C(void *result, int a2)
{
  if (a2 < 0)
  {
    uint64_t v2 = a2 ^ 0x80000000;
    result[1] = 0;
  }
  else
  {
    if (!a2) {
      return result;
    }
    uint64_t v2 = (a2 - 1);
  }
  *uint64_t result = v2;
  return result;
}

uint64_t sub_1830DC99C(void *a1)
{
  if (*a1 != -1) {
    swift_once();
  }

  return swift_retain();
}

void sub_1830DC9E8(uint32_t a1, uint32_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7)
{
  uint64_t v14 = *(NSObject **)(v7 + 16);
  uint64_t v15 = swift_allocObject();
  *(void *)(v15 + 16) = a3;
  *(void *)(v15 + 24) = a4;
  v17[4] = a6;
  v17[5] = v15;
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 1107296256;
  v17[2] = sub_1832E5DC4;
  v17[3] = a7;
  __int16 v16 = _Block_copy(v17);
  swift_unknownObjectRetain();
  swift_retain();
  swift_release();
  nw_connection_receive(v14, a1, a2, v16);
  swift_unknownObjectRelease();
  _Block_release(v16);
}

void NWConnection.receive(minimumIncompleteLength:maximumLength:completion:)(uint32_t a1, uint32_t a2, uint64_t a3, uint64_t a4)
{
}

Swift::Void __swiftcall NWConnection.cancel()()
{
  nw_connection_cancel(*(nw_connection_t *)(v0 + 16));
}

void *destroy for NWConnection.SendCompletion(void *result)
{
  if (*result >= 0xFFFFFFFFuLL) {
    return (void *)swift_release();
  }
  return result;
}

ValueMetadata *type metadata accessor for NWConnection.SendCompletion()
{
  return &type metadata for NWConnection.SendCompletion;
}

uint64_t static NWConnection.ContentContext.defaultMessage.getter()
{
  return sub_1830DC99C(&qword_1E8F61D08);
}

uint64_t nw_protocol_input_available_is_valid(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v2 = *(void *)(a1 + 24);
    if (v2) {
      LODWORD(v2) = *(void *)(v2 + 64) != 0;
    }
  }
  else
  {
    LODWORD(v2) = 0;
  }
  if (a2) {
    return v2;
  }
  else {
    return 0;
  }
}

uint64_t nw_frame_array_foreach(uint64_t result, char a2, uint64_t a3)
{
  uint64_t v5 = *(void *)result;
  if (a2)
  {
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v6 = *(void *)(v5 + 32);
      uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      uint64_t v5 = v6;
    }
    while ((result & 1) != 0);
  }
  else
  {
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v7 = *(void *)(v5 + 16);
      uint64_t result = (*(uint64_t (**)(uint64_t))(a3 + 16))(a3);
      uint64_t v5 = v7;
    }
    while ((result & 1) != 0);
  }
  return result;
}

uint64_t ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

uint64_t ___ZL51nw_connection_report_state_with_handler_on_nw_queueP24NWConcrete_nw_connection21nw_connection_state_tU13block_pointerFvS1_PU22objcproto11OS_nw_error8NSObjectEPU28objcproto17OS_dispatch_queueS2__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void, void, void))(*(void *)(a1 + 48) + 16))(*(void *)(a1 + 48), *(unsigned int *)(a1 + 56), *(void *)(a1 + 32));
}

uint64_t block_copy_helper(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_0(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_1(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_2(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_3(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_4(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_5(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_6(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_7(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_8(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_9(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_10(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_11(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_12(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_13(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_14(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_15(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_16(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_17(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

uint64_t block_copy_helper_18(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 40);
  *(void *)(a1 + 32) = *(void *)(a2 + 32);
  *(void *)(a1 + 40) = v2;
  return swift_retain();
}

void nw_connection_add_client_event(void *a1, int a2, void *a3)
{
}

uint64_t NWActivity.__allocating_init(domain:label:)(unint64_t a1, unint64_t a2)
{
  uint64_t v4 = swift_allocObject();
  NWActivity.init(domain:label:)(a1, a2);
  return v4;
}

uint64_t NWActivity.init(domain:label:)(unint64_t a1, unint64_t a2)
{
  if ((a1 & 0x8000000000000000) != 0 || HIDWORD(a1) || (a2 & 0x8000000000000000) != 0 || HIDWORD(a2))
  {
    uint64_t result = sub_183D456BC();
    __break(1u);
  }
  else
  {
    v2[2] = nw_activity_create(a1, a2);
    v2[3] = a1;
    v2[4] = a2;
    return (uint64_t)v2;
  }
  return result;
}

void __Block_byref_object_dispose__6(uint64_t a1)
{
}

uint64_t nw_context_16k_buffer_length()
{
  return dword_1E8F651A8;
}

uint64_t __swift_memcpy5_4(uint64_t result, int *a2)
{
  int v2 = *a2;
  *(unsigned char *)(result + 4) = *((unsigned char *)a2 + 4);
  *(_DWORD *)uint64_t result = v2;
  return result;
}

BOOL nw_path_network_is_satisfied_update_reason(NWConcrete_nw_path *a1, BOOL a2)
{
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a1;
  BOOL v9 = v3;
  if (!v3)
  {
    v76 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_network_is_satisfied_update_reason";
    char v77 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v90[0]) = 0;
    if (__nwlog_fault(v77, type, v90))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v78 = __nwlog_obj();
        os_log_type_t v79 = type[0];
        if (os_log_type_enabled(v78, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_network_is_satisfied_update_reason";
          _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (LOBYTE(v90[0]))
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v78 = __nwlog_obj();
        os_log_type_t v81 = type[0];
        BOOL v82 = os_log_type_enabled(v78, type[0]);
        if (backtrace_string)
        {
          if (v82)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_network_is_satisfied_update_reason";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v78, v81, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_141;
        }
        if (v82)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_network_is_satisfied_update_reason";
          _os_log_impl(&dword_1830D4000, v78, v81, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v78 = __nwlog_obj();
        os_log_type_t v83 = type[0];
        if (os_log_type_enabled(v78, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_network_is_satisfied_update_reason";
          _os_log_impl(&dword_1830D4000, v78, v83, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_141:
    if (v77) {
      free(v77);
    }
    goto LABEL_7;
  }
  routing_uint64_t result = v3->policy_result.routing_result;
  if (routing_result == 4) {
    goto LABEL_12;
  }
  if (routing_result != 3)
  {
    if (!nw_path_uses_nexus_internal(v3, 1)
      && (*((unsigned char *)v9 + 474) & 4) == 0
      && !v9->policy_result.routed_interface_index
      && (nw_path_may_span_multiple_interfaces(v9) & 1) == 0)
    {
      if (!a2) {
        goto LABEL_124;
      }
      os_log_type_t v11 = "No network route";
      int v12 = 3;
      goto LABEL_6;
    }
LABEL_12:
    BOOL v13 = v9;
    uint64_t v14 = v13;
    uint64_t v15 = v13[12];
    if (v15)
    {
      __int16 v16 = v15;
      int v17 = v16[24];

      uint64_t v18 = v14[13];
      if (v18)
      {
LABEL_14:
        id v19 = v18;
        int v20 = v19[24];

        goto LABEL_17;
      }
    }
    else
    {
      int v17 = 0;
      uint64_t v18 = v13[13];
      if (v18) {
        goto LABEL_14;
      }
    }
    int v20 = 0;
LABEL_17:
    uint64_t v116 = 0;
    v117 = &v116;
    uint64_t v118 = 0x2020000000;
    char v119 = 1;
    if (nw_path_may_span_multiple_interfaces(v14))
    {
LABEL_18:
      id v21 = nw_parameters_copy_prohibited_netagent_uuids(v14[2]);
      if (v21)
      {
        applier[0] = MEMORY[0x1E4F143A8];
        applier[1] = 3221225472;
        applier[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_4;
        applier[3] = &unk_1E5248320;
        v100 = v14;
        v101 = &v116;
        BOOL v102 = a2;
        xpc_array_apply(v21, applier);
      }
      if (*((unsigned char *)v117 + 24))
      {
        id v22 = nw_parameters_copy_required_netagent_uuids(v14[2]);
        if (v22)
        {
          v95[0] = MEMORY[0x1E4F143A8];
          v95[1] = 3221225472;
          v95[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_5;
          v95[3] = &unk_1E5248320;
          v96 = v14;
          v97 = &v116;
          BOOL v98 = a2;
          xpc_array_apply(v22, v95);
        }
        if (*((unsigned char *)v117 + 24))
        {
          id v23 = nw_parameters_copy_prohibited_netagent_domains(v14[2]);
          id v24 = nw_parameters_copy_prohibited_netagent_types(v14[2]);
          BOOL v25 = v24;
          if (v23)
          {
            if (v24)
            {
              size_t count = xpc_array_get_count(v23);
              if (count == xpc_array_get_count(v25))
              {
                v90[0] = MEMORY[0x1E4F143A8];
                v90[1] = 3221225472;
                v90[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_6;
                v90[3] = &unk_1E5248370;
                id v91 = v25;
                BOOL v94 = a2;
                id v92 = v14;
                uint64_t v93 = &v116;
                xpc_array_apply(v23, v90);
              }
            }
          }
          if (*((unsigned char *)v117 + 24))
          {
            id v27 = nw_parameters_copy_required_netagent_domains(v14[2]);
            id v28 = nw_parameters_copy_required_netagent_types(v14[2]);
            os_log_type_t v29 = v28;
            if (v27)
            {
              if (v28)
              {
                size_t v30 = xpc_array_get_count(v27);
                if (v30 == xpc_array_get_count(v29))
                {
                  v85[0] = MEMORY[0x1E4F143A8];
                  v85[1] = 3221225472;
                  v85[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_8;
                  v85[3] = &unk_1E5248370;
                  id v86 = v29;
                  __int16 v87 = v14;
                  v88 = &v116;
                  BOOL v89 = a2;
                  xpc_array_apply(v27, v85);
                }
              }
            }
            a2 = *((unsigned char *)v117 + 24) != 0;
          }
          else
          {
            a2 = 0;
          }
        }
        else
        {
          a2 = 0;
        }
      }
      else
      {
        a2 = 0;
      }

      goto LABEL_123;
    }
    if (nw_parameters_has_prohibited_interface_types(v14[2]))
    {
      id v31 = nw_parameters_copy_prohibited_interface_types(v14[2]);
      if (v31)
      {
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke;
        v121 = &unk_1E52482F8;
        char v32 = v14;
        int v124 = v17;
        int v125 = v20;
        v122 = v32;
        v123 = &v116;
        BOOL v126 = a2;
        xpc_array_apply(v31, buf);
      }
    }
    if (!*((unsigned char *)v117 + 24)) {
      goto LABEL_122;
    }
    if (!nw_parameters_has_prohibited_interface_subtypes(v14[2]))
    {
LABEL_54:
      if (!*((unsigned char *)v117 + 24)) {
        goto LABEL_122;
      }
      if (nw_parameters_has_prohibited_interfaces(v14[2]))
      {
        id v40 = nw_parameters_copy_prohibited_interfaces(v14[2]);
        if (v40)
        {
          v103[0] = MEMORY[0x1E4F143A8];
          v103[1] = 3221225472;
          v103[2] = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_3;
          v103[3] = &unk_1E5248320;
          v104 = v14;
          v105 = &v116;
          BOOL v106 = a2;
          xpc_array_apply(v40, v103);
        }
      }
      if (!*((unsigned char *)v117 + 24)) {
        goto LABEL_122;
      }
      uint64_t v41 = v14;
      if (nw_parameters_get_required_interface_index(v14[2]) && v9->policy_result.routing_result == 6)
      {
        int isa_high = HIDWORD(v41[33].isa);
        LOBYTE(isa_high) = isa_high == nw_parameters_get_required_interface_index(v14[2]);

        if ((isa_high & 1) == 0)
        {
LABEL_95:
          if (nw_parameters_get_prohibit_expensive((nw_parameters_t)v14[2]) && nw_path_is_expensive(v41))
          {
            if (a2)
            {
              os_log_type_t v73 = "Expensive path prohibited";
LABEL_112:
              int v74 = 5;
              goto LABEL_113;
            }
LABEL_122:
            a2 = 0;
            goto LABEL_123;
          }
          if (nw_parameters_get_prohibit_constrained((nw_parameters_t)v14[2]) && nw_path_is_constrained(v41))
          {
            if (a2)
            {
              os_log_type_t v73 = "Constrained path prohibited";
              int v74 = 26;
LABEL_113:
              nw_path_set_reason(v41, v74, v73, v68, v69, v70, v71, v72, v84);
              goto LABEL_122;
            }
            goto LABEL_122;
          }
          if ((nw_parameters_get_allow_ultra_constrained(v14[2]) & 1) == 0
            && nw_path_is_ultra_constrained(v41))
          {
            if (nw_path_is_ultra_constrained_allowed(void)::onceToken != -1) {
              dispatch_once(&nw_path_is_ultra_constrained_allowed(void)::onceToken, &__block_literal_global_491);
            }
            if ((nw_path_is_ultra_constrained_allowed(void)::is_allowed & 1) == 0)
            {
              if (!a2) {
                goto LABEL_122;
              }
              os_log_type_t v73 = "Ultra constrained path not allowed";
              int v74 = 31;
              goto LABEL_113;
            }
          }
          if (!nw_parameters_get_prohibit_roaming(v14[2]) || !nw_path_is_roaming(v41)) {
            goto LABEL_18;
          }
          if (a2)
          {
            os_log_type_t v73 = "Roaming path prohibited";
            goto LABEL_112;
          }
LABEL_123:
          _Block_object_dispose(&v116, 8);

          goto LABEL_124;
        }
      }
      else
      {
      }
      required_interface_os_log_type_t type = nw_parameters_get_required_interface_type((nw_parameters_t)v14[2]);
      if ((required_interface_type & 0xFFFFFFFB) != 0
        && required_interface_type != v17
        && required_interface_type != v20)
      {
        if (a2)
        {
          if (required_interface_type > nw_interface_type_loopback) {
            v49 = "unknown";
          }
          else {
            v49 = off_1E524BC28[required_interface_type];
          }
          nw_path_set_reason(v41, 7, "Interface type %s is required by parameters", v44, v45, v46, v47, v48, (char)v49);
          goto LABEL_122;
        }
        goto LABEL_123;
      }
      required_interface_subos_log_type_t type = nw_parameters_get_required_interface_subtype(v14[2]);
      if (!required_interface_subtype) {
        goto LABEL_89;
      }
      int v56 = required_interface_subtype;
      id v57 = v14[12];
      if (v57) {
        subos_log_type_t type = nw_interface_get_subtype(v57);
      }
      else {
        subos_log_type_t type = 0;
      }
      v59 = v14[13];
      if (v59) {
        LODWORD(v59) = nw_interface_get_subtype(v59);
      }
      if (v56 == subtype || v56 == v59)
      {
LABEL_89:
        nw_interface_t v61 = nw_parameters_copy_required_interface((nw_parameters_t)v14[2]);
        if (v61)
        {
          if (!nw_interface_shallow_compare(v14[12], v61) && !nw_interface_shallow_compare(v14[13], v61))
          {
            *((unsigned char *)v117 + 24) = 0;
            if (a2) {
              nw_path_set_reason(v41, 9, "Interface %s[%u] is required by parameters", v62, v63, v64, v65, v66, (_BYTE)v61 + 104);
            }
          }
        }
        BOOL v67 = *((unsigned char *)v117 + 24) == 0;

        if (v67) {
          goto LABEL_122;
        }
        goto LABEL_95;
      }
      if (!a2) {
        goto LABEL_123;
      }
      if (v56 <= 1001)
      {
        if (v56 == 1001)
        {
          v60 = "wifi_infrastructure";
          goto LABEL_121;
        }
      }
      else
      {
        switch(v56)
        {
          case 1002:
            v60 = "wifi_awdl";
            goto LABEL_121;
          case 4001:
            v60 = "coprocessor";
            goto LABEL_121;
          case 5001:
            v60 = "companion";
LABEL_121:
            nw_path_set_reason(v41, 7, "Interface subtype %s is required by parameters", v51, v52, v53, v54, v55, (char)v60);
            goto LABEL_122;
        }
      }
      v60 = "unknown";
      goto LABEL_121;
    }
    id v33 = nw_parameters_copy_prohibited_interface_subtypes(v14[2]);
    if (!v33)
    {
LABEL_53:

      goto LABEL_54;
    }
    os_log_type_t v34 = v14[12];
    if (v34)
    {
      __int16 v35 = v34;
      int v36 = v35[25];

      __int16 v37 = v14[13];
      if (v37)
      {
LABEL_43:
        uint64_t v38 = v37;
        int v39 = v38[25];

LABEL_52:
        *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
        uint64_t v108 = 3221225472;
        v109 = ___ZL29nw_path_allowed_by_parametersP18NWConcrete_nw_pathb_block_invoke_2;
        v110 = &unk_1E52482F8;
        int v113 = v36;
        int v114 = v39;
        v112 = &v116;
        BOOL v115 = a2;
        v111 = v14;
        xpc_array_apply(v33, type);

        goto LABEL_53;
      }
    }
    else
    {
      int v36 = 0;
      __int16 v37 = v14[13];
      if (v37) {
        goto LABEL_43;
      }
    }
    int v39 = 0;
    goto LABEL_52;
  }
  if (a2)
  {
    os_log_type_t v11 = "Path was denied by NECP policy";
    int v12 = 2;
LABEL_6:
    nw_path_set_reason(v9, v12, v11, v4, v5, v6, v7, v8, v84);
  }
LABEL_7:
  a2 = 0;
LABEL_124:

  return a2;
}

void sub_1830DDB3C(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v4 - 208), 8);
  _Unwind_Resume(a1);
}

uint64_t ___ZL42nw_path_agents_are_satisfied_update_reasonP18NWConcrete_nw_pathbbbPb_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  uint64_t v5 = v4;
  length[0] = 0;
  if (v4)
  {
    data = (const unsigned __int8 *)xpc_dictionary_get_data(v4, "data", length);
    if (data)
    {
      if (length[0] >= 0xD8)
      {
        uint64_t v7 = data;
        if (length[0] == *((unsigned int *)data + 53) + 216)
        {
          BOOL is_required = nw_path_netagent_is_required(*(void **)(a1 + 32), v5);
          unsigned int v9 = *((_DWORD *)v7 + 52);
          BOOL v10 = is_required || *(unsigned char *)(a1 + 56) != 0;
          if ((*((_DWORD *)v7 + 52) & 3) == 1
            && ((v9 & 0x40) != 0 || !*(unsigned char *)(a1 + 57))
            && (!v10 & (v9 >> 4) & 1) == 0)
          {
            *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
            os_log_type_t v11 = *(unsigned char **)(a1 + 48);
            if (v11 && !*v11) {
              *os_log_type_t v11 = v9 & ((v9 & 0xC) != 0);
            }
            if (*(unsigned char *)(a1 + 58))
            {
              int v21 = 0;
              ne_session_get_config_id_from_network_agent();
              int v20 = 0;
              *(_OWORD *)size_t length = 0u;
              memset(v23, 0, sizeof(v23));
              uuid_unparse_upper(v7, (char *)length);
              asprintf(&v20, "Network Agent [domain: %s, type: %s, description: %s, uuid: %s, flags: %x]", (const char *)v7 + 16, (const char *)v7 + 48, (const char *)v7 + 80, (const char *)length, *((_DWORD *)v7 + 52));
              int v17 = *(void **)(a1 + 32);
              if (v20)
              {
                nw_path_set_reason(v17, 4, "%s is unsatisfied", v12, v13, v14, v15, v16, (char)v20);
                if (v20) {
                  free(v20);
                }
              }
              else
              {
                nw_path_set_reason(v17, 4, "Unknown network agent is unsatisfied", v12, v13, v14, v15, v16, v19);
              }
            }
          }
        }
      }
    }
  }

  return 1;
}

void sub_1830DDE3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_netagent_is_required(void *a1, void *a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = (void **)v3;
  id v6 = v4;
  uint64_t v7 = v6;
  if (!v5)
  {
    id v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(applier[0]) = 0;
    if (__nwlog_fault(v9, type, applier))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v32 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          _os_log_impl(&dword_1830D4000, v10, v32, "%{public}s called with null path", buf, 0xCu);
        }
LABEL_31:

        goto LABEL_32;
      }
      if (!LOBYTE(applier[0]))
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v36 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          _os_log_impl(&dword_1830D4000, v10, v36, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_31;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v34 = type[0];
      BOOL v35 = os_log_type_enabled(v10, type[0]);
      if (!backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          _os_log_impl(&dword_1830D4000, v10, v34, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
        goto LABEL_31;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v34, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_32:
    if (v9) {
LABEL_33:
    }
      free(v9);
LABEL_34:
    BOOL v19 = 0;
    goto LABEL_35;
  }
  if (!v6 || object_getClass(v6) != (Class)MEMORY[0x1E4F14590])
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(applier[0]) = 0;
    if (!__nwlog_fault(v9, type, applier)) {
      goto LABEL_32;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (id)gLogObj;
      os_log_type_t v11 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null netagent_dict", buf, 0xCu);
      }
    }
    else if (LOBYTE(applier[0]))
    {
      uint64_t v12 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (id)gLogObj;
      os_log_type_t v13 = type[0];
      BOOL v14 = os_log_type_enabled(v10, type[0]);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v12;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null netagent_dict, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        if (!v9) {
          goto LABEL_34;
        }
        goto LABEL_33;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null netagent_dict, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (id)gLogObj;
      os_log_type_t v21 = type[0];
      if (os_log_type_enabled(v10, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
        _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s called with null netagent_dict, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_31;
  }
  *(void *)buf = 0;
  data = xpc_dictionary_get_data(v7, "data", (size_t *)buf);
  if (!data || *(void *)buf < 0xD8uLL || (uint64_t v16 = data, *(void *)buf != *((unsigned int *)data + 53) + 216))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v20 = (id)gLogObj;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_path_netagent_applies_to_path";
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s Failed to get agent from dictionary", buf, 0xCu);
    }

    goto LABEL_34;
  }
  if ((data[208] & 1) == 0) {
    goto LABEL_34;
  }
  uint64_t v45 = 0;
  uint64_t v46 = &v45;
  uint64_t v47 = 0x2020000000;
  char v48 = 0;
  id v17 = nw_parameters_copy_required_netagent_uuids(v5[2]);
  uint64_t v18 = v17;
  if (v17)
  {
    applier[0] = MEMORY[0x1E4F143A8];
    applier[1] = 3221225472;
    applier[2] = ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke;
    applier[3] = &unk_1E5248460;
    void applier[4] = &v45;
    applier[5] = v16;
    xpc_array_apply(v17, applier);
  }
  if (*((unsigned char *)v46 + 24))
  {
    BOOL v19 = 1;
  }
  else
  {
    id v23 = nw_parameters_copy_required_netagent_domains(v5[2]);
    id v24 = nw_parameters_copy_required_netagent_types(v5[2]);
    BOOL v25 = v24;
    if (v23)
    {
      if (v24)
      {
        size_t count = xpc_array_get_count(v23);
        if (count == xpc_array_get_count(v25))
        {
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 3221225472;
          *(void *)&buf[16] = ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke_2;
          v50 = &unk_1E5248488;
          id v51 = v25;
          uint64_t v52 = &v45;
          uint64_t v53 = v16;
          xpc_array_apply(v23, buf);
        }
      }
    }
    if (*((unsigned char *)v46 + 24))
    {
      BOOL v19 = 1;
    }
    else
    {
      xpc_object_t v27 = nw_parameters_copy_preferred_netagent_domains(v5[2]);
      xpc_object_t v28 = nw_parameters_copy_preferred_netagent_types(v5[2]);
      os_log_type_t v29 = v28;
      if (v27)
      {
        if (v28)
        {
          size_t v30 = xpc_array_get_count(v27);
          if (v30 == xpc_array_get_count(v29))
          {
            *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
            uint64_t v38 = 3221225472;
            int v39 = ___ZL32nw_path_netagent_applies_to_pathP18NWConcrete_nw_pathPU24objcproto13OS_xpc_object8NSObjectb_block_invoke_3;
            id v40 = &unk_1E5248488;
            id v41 = v29;
            uint64_t v42 = &v45;
            __int16 v43 = v16;
            xpc_array_apply(v27, type);
          }
        }
      }
      BOOL v19 = *((unsigned char *)v46 + 24) != 0;
    }
  }

  _Block_object_dispose(&v45, 8);
LABEL_35:

  return v19;
}

void sub_1830DE694(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

id nw_parameters_copy_required_netagent_types(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v17 = "nw_parameters_copy_required_netagent_types";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_types";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            id v17 = "nw_parameters_copy_required_netagent_types";
            __int16 v18 = 2082;
            BOOL v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_types";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_types";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 64);
LABEL_23:

  return v4;
}

id nw_parameters_copy_required_netagent_domains(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v17 = "nw_parameters_copy_required_netagent_domains";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_domains";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            id v17 = "nw_parameters_copy_required_netagent_domains";
            __int16 v18 = 2082;
            BOOL v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_domains";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_domains";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 56);
LABEL_23:

  return v4;
}

id nw_parameters_copy_required_netagent_uuids(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v17 = "nw_parameters_copy_required_netagent_uuids";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            id v17 = "nw_parameters_copy_required_netagent_uuids";
            __int16 v18 = 2082;
            BOOL v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          id v17 = "nw_parameters_copy_required_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 72);
LABEL_23:

  return v4;
}

xpc_object_t nw_parameters_copy_preferred_netagent_domains(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v4 = v1;
  if (v1)
  {
    path_parameters = v1->path_parameters;
    required_interface = path_parameters->required_interface;
    if (required_interface)
    {
      xpc_object_t v7 = *((id *)required_interface + 10);
      path_parameters = v4->path_parameters;
    }
    else
    {
      xpc_object_t v7 = 0;
    }
    if (path_parameters->path_value.companion_preference == 1)
    {
      int agent_preference = nw_parameters_get_agent_preference(v4, v2, v3);
      if (agent_preference)
      {
        if (agent_preference == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned int v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            id v23 = "nw_parameters_copy_preferred_netagent_domains";
            _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s Parameters companion_preferece is prefer but companion is in avoided array", buf, 0xCu);
          }
        }
      }
      else
      {
        if (v7)
        {
          xpc_object_t v10 = xpc_copy(*((xpc_object_t *)v4->path_parameters->required_interface + 10));

          xpc_object_t v7 = v10;
        }
        else
        {
          xpc_object_t v7 = xpc_array_create(0, 0);
        }
        xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "com.apple.networkrelay");
      }
    }
    goto LABEL_15;
  }
  os_log_type_t v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v23 = "nw_parameters_copy_preferred_netagent_domains";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_parameters_copy_preferred_netagent_domains";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          id v23 = "nw_parameters_copy_preferred_netagent_domains";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_parameters_copy_preferred_netagent_domains";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_parameters_copy_preferred_netagent_domains";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_32:
  if (v13) {
    free(v13);
  }
  xpc_object_t v7 = 0;
LABEL_15:

  return v7;
}

void sub_1830DF2BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

xpc_object_t nw_parameters_copy_preferred_netagent_types(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v4 = v1;
  if (v1)
  {
    path_parameters = v1->path_parameters;
    required_interface = path_parameters->required_interface;
    if (required_interface)
    {
      xpc_object_t v7 = *((id *)required_interface + 11);
      path_parameters = v4->path_parameters;
    }
    else
    {
      xpc_object_t v7 = 0;
    }
    if (path_parameters->path_value.companion_preference == 1)
    {
      int agent_preference = nw_parameters_get_agent_preference(v4, v2, v3);
      if (agent_preference)
      {
        if (agent_preference == 2)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned int v9 = (id)gLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            id v23 = "nw_parameters_copy_preferred_netagent_types";
            _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s Parameters companion_preferece is prefer but companion is in avoided array", buf, 0xCu);
          }
        }
      }
      else
      {
        if (v7)
        {
          xpc_object_t v10 = xpc_copy(*((xpc_object_t *)v4->path_parameters->required_interface + 11));

          xpc_object_t v7 = v10;
        }
        else
        {
          xpc_object_t v7 = xpc_array_create(0, 0);
        }
        xpc_array_set_string(v7, 0xFFFFFFFFFFFFFFFFLL, "CompanionProxy");
      }
    }
    goto LABEL_15;
  }
  os_log_type_t v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v23 = "nw_parameters_copy_preferred_netagent_types";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_parameters_copy_preferred_netagent_types";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          id v23 = "nw_parameters_copy_preferred_netagent_types";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_parameters_copy_preferred_netagent_types";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_parameters_copy_preferred_netagent_types";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_32:
  if (v13) {
    free(v13);
  }
  xpc_object_t v7 = 0;
LABEL_15:

  return v7;
}

void sub_1830DF670(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_tcp(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
    }
    BOOL v2 = nw_protocol_options_matches_definition(v1, (void *)g_tcp_definition);
    goto LABEL_5;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_options_is_tcp";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_tcp";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v15 = "nw_protocol_options_is_tcp";
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_tcp";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_options_is_tcp";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_5:

  return v2;
}

void sub_1830DF954(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_uses_nexus_internal(NWConcrete_nw_path *a1, char a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  if (!v3)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "nw_path_uses_nexus_internal";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_uses_nexus_internal";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v19 = "nw_path_uses_nexus_internal";
            __int16 v20 = 2082;
            os_log_type_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_uses_nexus_internal";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_uses_nexus_internal";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_33:
    if (v8) {
      free(v8);
    }
    goto LABEL_35;
  }
  if (nw_path_can_use_channel_syscalls(void)::onceToken != -1) {
    dispatch_once(&nw_path_can_use_channel_syscalls(void)::onceToken, &__block_literal_global_494);
  }
  if ((nw_path_can_use_channel_syscalls(void)::can_use_channel_syscalls & 1) == 0
    || (nw_parameters_get_allow_socket_access(v3->parameters) & 1) != 0
    || nw_parameters_get_ip_protocol(v3->parameters) == 6 && nw_parameters_get_multipath(v3->parameters)
    || v3->policy_result.flow_divert_aggregate_unit
    || v3->policy_result.routing_result == 4
    || (*((unsigned char *)v3 + 473) & 0x10) != 0)
  {
LABEL_35:
    BOOL v6 = 0;
    goto LABEL_36;
  }
  id v4 = v3->endpoint;
  uint64_t v5 = v4;
  BOOL v6 = (!v4 || nw_endpoint_get_type(v4) != nw_endpoint_type_address || (nw_endpoint_is_multicast(v5) & 1) == 0)
    && nw_path_get_nexus_agent(v3, a2) != 0;

LABEL_36:
  return v6;
}

void sub_1830DFCC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_multipath(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    BOOL v3 = *(_DWORD *)(*((void *)v1 + 13) + 103) != 0;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_multipath";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_multipath";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_multipath";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_multipath";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_multipath";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_ip_protocol(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v20 = "nw_parameters_get_ip_protocol";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_parameters_get_ip_protocol";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v20 = "nw_parameters_get_ip_protocol";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_parameters_get_ip_protocol";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v20 = "nw_parameters_get_ip_protocol";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_29:
    if (v9) {
      free(v9);
    }
    goto LABEL_31;
  }
  uint64_t v3 = v1[19];
  if (!v3) {
    goto LABEL_31;
  }
  id v4 = *(void **)(v3 + 24);
  if (!v4) {
    goto LABEL_31;
  }
  id v5 = v4;
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
  }
  BOOL v6 = nw_protocol_options_matches_definition(v5, (void *)g_tcp_definition);

  if (!v6)
  {
    if (nw_protocol_options_is_udp(*(void **)(v2[19] + 24))
      || nw_protocol_options_is_quic(*(nw_protocol_options_t *)(v2[19] + 24)))
    {
      uint64_t protocol = 17;
      goto LABEL_32;
    }
    if (nw_protocol_options_is_custom_ip(*(void **)(v2[19] + 24)))
    {
      uint64_t protocol = nw_custom_ip_options_get_protocol(*(void **)(v2[19] + 24));
      goto LABEL_32;
    }
LABEL_31:
    uint64_t protocol = 0;
    goto LABEL_32;
  }
  uint64_t protocol = 6;
LABEL_32:

  return protocol;
}

void sub_1830E02C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_matches_definition(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3)
  {
    if (v4)
    {
      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(v3[1], (uint64_t)v4);
      goto LABEL_4;
    }
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_protocol_options_matches_definition";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null definition", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v21)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v24 = "nw_protocol_options_matches_definition";
        __int16 v25 = 2082;
        uint64_t v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v24 = "nw_protocol_options_matches_definition";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null options", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v21)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v24 = "nw_protocol_options_matches_definition";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null options, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v24 = "nw_protocol_options_matches_definition";
        __int16 v25 = 2082;
        uint64_t v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v9) {
    free(v9);
  }
  BOOL is_equal_unsafe = 0;
LABEL_4:

  return is_equal_unsafe;
}

void sub_1830E079C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_definition_is_equal_unsafe(uint64_t a1, uint64_t a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v10, &type, &v19)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
        os_log_type_t v13 = "%{public}s called with null definition1";
LABEL_52:
        _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      }
LABEL_53:

LABEL_54:
      if (v10) {
        free(v10);
      }
      return 0;
    }
    if (!v19)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
        os_log_type_t v13 = "%{public}s called with null definition1, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v16 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
        os_log_type_t v13 = "%{public}s called with null definition1, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      os_log_type_t v17 = "%{public}s called with null definition1, dumping backtrace:%{public}s";
LABEL_42:
      _os_log_impl(&dword_1830D4000, v11, v12, v17, buf, 0x16u);
    }
LABEL_43:

    free(backtrace_string);
    goto LABEL_54;
  }
  if (!a2)
  {
    BOOL v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v10, &type, &v19)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
        os_log_type_t v13 = "%{public}s called with null definition2";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (!v19)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
        os_log_type_t v13 = "%{public}s called with null definition2, backtrace limit exceeded";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v18 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
        os_log_type_t v13 = "%{public}s called with null definition2, no backtrace";
        goto LABEL_52;
      }
      goto LABEL_53;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v22 = "nw_protocol_definition_is_equal_unsafe";
      __int16 v23 = 2082;
      __int16 v24 = backtrace_string;
      os_log_type_t v17 = "%{public}s called with null definition2, dumping backtrace:%{public}s";
      goto LABEL_42;
    }
    goto LABEL_43;
  }
  if ((*(unsigned char *)(a1 + 184) & 0x40) != 0 || (*(unsigned char *)(a2 + 184) & 0x40) != 0)
  {
    return a1 == a2;
  }
  else
  {
    if (a1 == a2) {
      return 1;
    }
    if (uuid_compare((const unsigned __int8 *)(a1 + 48), (const unsigned __int8 *)(a2 + 48))) {
      return 0;
    }
    return *(void *)(a1 + 8) == *(void *)(a2 + 8)
        && *(void *)(a1 + 16) == *(void *)(a2 + 16)
        && *(void *)(a1 + 24) == *(void *)(a2 + 24)
        && *(void *)(a1 + 32) == *(void *)(a2 + 32)
        && *(void *)(a1 + 40) == *(void *)(a2 + 40);
  }
}

uint64_t nw_parameters_get_allow_socket_access(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 100) >> 4) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_allow_socket_access";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_allow_socket_access";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_allow_socket_access";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_allow_socket_access";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_allow_socket_access";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_has_prohibited_interfaces(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    BOOL v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v18 = "nw_parameters_has_prohibited_interfaces";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v18 = "nw_parameters_has_prohibited_interfaces";
            __int16 v19 = 2082;
            os_log_type_t v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v18 = "nw_parameters_has_prohibited_interfaces";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3 || (id v4 = *(void **)(v3 + 24)) == 0)
  {
LABEL_23:
    BOOL v5 = 0;
    goto LABEL_24;
  }
  BOOL v5 = xpc_array_get_count(v4) != 0;
LABEL_24:

  return v5;
}

void sub_1830E1168(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint32_t nw_interface_get_index(nw_interface_t interface)
{
  if (interface) {
    LODWORD(interface) = interface[1].isa;
  }
  return interface;
}

uint64_t type metadata accessor for NWActivity()
{
  return self;
}

const char *__cdecl nw_interface_get_name(nw_interface_t interface)
{
  if (interface) {
    return (const char *)&interface[13];
  }
  else {
    return 0;
  }
}

Swift::Void __swiftcall NWActivity.activate()()
{
  nw_activity_activate(*(void **)(v0 + 16));
}

uint64_t dispatch thunk of NWActivity.__allocating_init(domain:label:)()
{
  return (*(uint64_t (**)(void))(v0 + 104))();
}

void *__Block_byref_object_copy__10(uint64_t a1, uint64_t a2)
{
  uint64_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

id nw_protocol_copy_quic_connection_definition()
{
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55981);
  }
  uint64_t v0 = (void *)nw_protocol_copy_quic_connection_definition::quic_definition;

  return v0;
}

uint64_t ___ZL35nw_resolver_remove_sa_family_lockedP22NWConcrete_nw_resolverh_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if (nw_endpoint_get_type(v4) == nw_endpoint_type_address
    && nw_endpoint_get_address_family(v4) == *(unsigned __int8 *)(a1 + 48))
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  else
  {
    nw_array_append(*(void *)(a1 + 32), v4);
  }

  return 1;
}

void sub_1830E17BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1830E2394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_may_span_multiple_interfaces(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v19 = "nw_path_may_span_multiple_interfaces";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v19 = "nw_path_may_span_multiple_interfaces";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v19 = "nw_path_may_span_multiple_interfaces";
            __int16 v20 = 2082;
            uint64_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v19 = "nw_path_may_span_multiple_interfaces";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v19 = "nw_path_may_span_multiple_interfaces";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_24:
    if (v8) {
      free(v8);
    }
    goto LABEL_26;
  }
  if ((*((unsigned char *)v1 + 475) & 1) == 0)
  {
    nw_endpoint_t v3 = v1[3];
    if (!v3
      || (id v4 = v3, isa_high = HIBYTE(v4[28].isa), v4, (isa_high & 1) == 0)
      && nw_endpoint_get_type(v2[3]) != nw_endpoint_type_bonjour_service
      && nw_endpoint_get_type(v2[3]) != (nw_endpoint_type_url|nw_endpoint_type_host))
    {
LABEL_26:
      uint64_t v6 = 0;
      goto LABEL_27;
    }
  }
  uint64_t v6 = 1;
LABEL_27:

  return v6;
}

void sub_1830E26DC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1830E2B2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const sockaddr *__cdecl nw_endpoint_get_address(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1E4F143B8];
  id v1 = endpoint;
  BOOL v2 = v1;
  if (!v1)
  {
    uint64_t v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v38 = "nw_endpoint_get_address";
    uint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        xpc_object_t v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        xpc_object_t v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v38 = "nw_endpoint_get_address";
            __int16 v39 = 2082;
            *(void *)id v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        xpc_object_t v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v38 = "nw_endpoint_get_address";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v27) {
      goto LABEL_24;
    }
    __int16 v24 = (char *)v27;
    goto LABEL_23;
  }
  nw_endpoint_t v3 = v1;
  int v4 = [v3 type];

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    os_log_type_t v7 = v3;
    int v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    uint64_t v38 = "nw_endpoint_get_address";
    __int16 v39 = 1024;
    *(_DWORD *)id v40 = v8;
    LODWORD(v34) = 18;
    os_log_type_t v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          os_log_type_t v12 = v7;
          int v13 = [v12 type];

          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_endpoint_get_address";
          __int16 v39 = 1024;
          *(_DWORD *)id v40 = v13;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        os_log_type_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            __int16 v17 = v7;
            int v18 = [v17 type];

            *(_DWORD *)buf = 136446722;
            uint64_t v38 = "nw_endpoint_get_address";
            __int16 v39 = 1024;
            *(_DWORD *)id v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          __int16 v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          uint64_t v22 = v7;
          int v23 = [v22 type];

          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_endpoint_get_address";
          __int16 v39 = 1024;
          *(_DWORD *)id v40 = v23;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          __int16 v20 = v7;
          int v21 = [v20 type];

          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_endpoint_get_address";
          __int16 v39 = 1024;
          *(_DWORD *)id v40 = v21;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v9)
    {
LABEL_24:
      BOOL v5 = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  BOOL v5 = (const sockaddr *)&v3[29];
LABEL_25:

  return v5;
}

void sub_1830E3144(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_type_t nw_endpoint_get_type(nw_endpoint_t endpoint)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = endpoint;
  BOOL v2 = v1;
  if (v1)
  {
    nw_endpoint_type_t v3 = [v1 type];
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_endpoint_get_type";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_get_type";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_endpoint_get_type";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_get_type";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_get_type";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_endpoint_type_t v3 = nw_endpoint_type_invalid;
LABEL_3:

  return v3;
}

void sub_1830E3440(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_txt_record_is_equal(nw_txt_record_t left, nw_txt_record_t right)
{
  nw_txt_record_t v3 = left;
  int v4 = right;
  BOOL v5 = v4;
  if (v3 == v4) {
    goto LABEL_16;
  }
  BOOL v6 = 0;
  if (v3 && v4)
  {
    if (v3 <= v4) {
      os_log_type_t v7 = (os_unfair_lock_s *)v4;
    }
    else {
      os_log_type_t v7 = (os_unfair_lock_s *)v3;
    }
    if (v3 <= v4) {
      os_log_type_t v8 = (os_unfair_lock_s *)v3;
    }
    else {
      os_log_type_t v8 = (os_unfair_lock_s *)v4;
    }
    os_unfair_lock_lock(v7 + 8);
    os_unfair_lock_lock(v8 + 8);
    size_t isa = (size_t)v3[2].isa;
    if ((Class)isa != v5[2].isa)
    {
LABEL_14:
      os_unfair_lock_unlock((os_unfair_lock_t)&v5[4]);
      os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
      BOOL v6 = 0;
      goto LABEL_17;
    }
    if (memcmp(v3[1].isa, v5[1].isa, isa))
    {
      if (BYTE4(v3[4].isa) & 1) != 0 && (BYTE4(v5[4].isa))
      {
        uint64_t v16 = 0;
        __int16 v17 = &v16;
        uint64_t v18 = 0x2020000000;
        char v19 = 1;
        v13[0] = MEMORY[0x1E4F143A8];
        v13[1] = 3221225472;
        v13[2] = __nw_txt_record_is_equal_block_invoke;
        v13[3] = &unk_1E5244860;
        BOOL v11 = v5;
        os_log_type_t v14 = v11;
        os_log_type_t v15 = &v16;
        os_log_type_t v12 = _Block_copy(v13);
        nw_txt_record_apply_internal_locked(v3, v12, 0);
        os_unfair_lock_unlock(v11 + 8);
        os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
        BOOL v6 = *((unsigned char *)v17 + 24) != 0;

        _Block_object_dispose(&v16, 8);
        goto LABEL_17;
      }
      goto LABEL_14;
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&v5[4]);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[4]);
LABEL_16:
    BOOL v6 = 1;
  }
LABEL_17:

  return v6;
}

void sub_1830E3600(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, void *a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_nsarray_is_equal(NSArray *a1, NSArray *a2)
{
  nw_txt_record_t v3 = a1;
  int v4 = a2;
  BOOL v5 = v4;
  uint64_t v6 = v3 == v4;
  if (v3 != v4 && v3 && v4) {
    uint64_t v6 = [(NSArray *)v3 isEqual:v4];
  }

  return v6;
}

void sub_1830E3694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_copy_scoped_interface(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_path_copy_scoped_interface";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_path_copy_scoped_interface";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "nw_path_copy_scoped_interface";
            __int16 v23 = 2082;
            __int16 v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_path_copy_scoped_interface";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_path_copy_scoped_interface";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_30:
    if (v12) {
      free(v12);
    }
    goto LABEL_12;
  }
  if ((*((unsigned char *)v1 + 476) & 1) == 0 || (nw_txt_record_t v3 = (void *)*((void *)v1 + 11)) == 0)
  {
    int v4 = v1;
    BOOL v5 = v4;
    int v6 = v4[66];
    if (v6 != 6 && v6 != 12)
    {

LABEL_12:
      id v9 = 0;
      goto LABEL_13;
    }
    int v8 = v4[67];

    if (!v8) {
      goto LABEL_12;
    }
    nw_txt_record_t v3 = (void *)*((void *)v5 + 12);
    if (!v3) {
      goto LABEL_12;
    }
  }
  id v9 = v3;
LABEL_13:

  return v9;
}

nw_parameters_expired_dns_behavior_t nw_parameters_get_expired_dns_behavior(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    nw_parameters_expired_dns_behavior_t isa_high = HIBYTE(v1[11].isa);
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_expired_dns_behavior";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_expired_dns_behavior";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_expired_dns_behavior";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_expired_dns_behavior";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_expired_dns_behavior";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_parameters_expired_dns_behavior_t isa_high = nw_parameters_expired_dns_behavior_default;
LABEL_3:

  return isa_high;
}

BOOL nw_path_has_ipv6(nw_path_t path)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (v1)
  {
    BOOL v3 = SBYTE1(v1[59].isa) < 0;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_has_ipv6";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_has_ipv6";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_has_ipv6";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_has_ipv6";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_has_ipv6";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_has_ipv4(nw_path_t path)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (BYTE1(v1[59].isa) >> 6) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_has_ipv4";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_has_ipv4";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_has_ipv4";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_has_ipv4";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_has_ipv4";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_has_unsatisfied_route(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_path_has_unsatisfied_route";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_path_has_unsatisfied_route";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v19 = "nw_path_has_unsatisfied_route";
            __int16 v20 = 2082;
            int v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_path_has_unsatisfied_route";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_path_has_unsatisfied_route";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (v8) {
      free(v8);
    }
    goto LABEL_24;
  }
  if (v1[94] != 2)
  {
LABEL_24:
    uint64_t v6 = 0;
    goto LABEL_25;
  }
  unsigned int v3 = v1[95];
  BOOL v4 = v3 > 0x1F;
  unsigned int v5 = (0xBC000168 >> v3) & 1;
  if (v4) {
    uint64_t v6 = 0;
  }
  else {
    uint64_t v6 = v5;
  }
LABEL_25:

  return v6;
}

uint64_t nw_path_has_nat64_prefixes(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((unsigned char *)v1 + 474) & 1;
    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_path_has_nat64_prefixes";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_path_has_nat64_prefixes";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_path_has_nat64_prefixes";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_path_has_nat64_prefixes";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_path_has_nat64_prefixes";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_get_dns_service_id(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_get_dns_service_id";
    id v9 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, type, &v18))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_get_dns_service_id";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type[0];
        BOOL v14 = os_log_type_enabled(v10, type[0]);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_get_dns_service_id";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_get_dns_service_id";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type[0];
        if (os_log_type_enabled(v10, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_get_dns_service_id";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v9) {
      free(v9);
    }
    goto LABEL_28;
  }
  if (nw_endpoint_get_type(v3[3]) != nw_endpoint_type_host) {
    goto LABEL_28;
  }
  if (*((_DWORD *)v4 + 66) != 4 || (uint64_t hostname = *((unsigned int *)v4 + 67), !hostname) || (a2 & 1) == 0)
  {
    uint64_t hostname = (uint64_t)nw_endpoint_get_hostname(v4[3]);
    if (hostname)
    {
      *(_DWORD *)os_log_type_t type = 0;
      *(void *)buf = 0;
      *(void *)&buf[8] = 0;
      if (nw_path_get_vpn_config_uuid((NWConcrete_nw_path *)v4, (unsigned __int8 (*)[16])buf, (int *)type, 1, 1))
      {
        uint64_t v6 = v4[12];
        if (v6)
        {
          os_log_type_t v7 = v6;
          uint64_t hostname = ne_session_service_get_dns_service_id_for_interface();

          goto LABEL_29;
        }
      }
LABEL_28:
      uint64_t hostname = 0;
    }
  }
LABEL_29:

  return hostname;
}

void sub_1830E49D0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_get_vpn_config_uuid(NWConcrete_nw_path *a1, unsigned __int8 (*a2)[16], int *a3, char a4, char a5)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  os_log_type_t v10 = v9;
  if (!v9)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v14, &type, &v31)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null path", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v31)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
        _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  if (!a2)
  {
    __int16 v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
    BOOL v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v14, &type, &v31)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null out_uuid", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v14) {
        free(v14);
      }
      goto LABEL_39;
    }
    if (!v31)
    {
      os_log_type_t v15 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
        _os_log_impl(&dword_1830D4000, v15, v25, "%{public}s called with null out_uuid, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v15 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
        _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null out_uuid, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_get_vpn_config_uuid";
      *(_WORD *)&buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null out_uuid, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  network_agent_dictionary = v9->network_agent_dictionary;
  if (!network_agent_dictionary)
  {
LABEL_39:
    BOOL v12 = 0;
    goto LABEL_40;
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  char v34 = 0;
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = ___ZL27nw_path_get_vpn_config_uuidP18NWConcrete_nw_pathPA16_hPibbb_block_invoke;
  applier[3] = &unk_1E5248500;
  char v28 = a5;
  char v29 = 1;
  char v30 = a4;
  applier[5] = a2;
  void applier[6] = a3;
  void applier[4] = buf;
  xpc_dictionary_apply(network_agent_dictionary, applier);
  BOOL v12 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
  _Block_object_dispose(buf, 8);
LABEL_40:

  return v12;
}

void sub_1830E4F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL __nw_endpoint_enumerate_cnames_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  BOOL v4 = a3;
  BOOL v5 = nw_endpoint_get_type(v4) != nw_endpoint_type_host
    || !nw_endpoint_get_hostname(v4)
    || ((*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))() & 1) != 0;

  return v5;
}

void sub_1830E4FDC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *__cdecl nw_endpoint_get_hostname(nw_endpoint_t endpoint)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = endpoint;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (const char *)[v1 hostname];
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_endpoint_get_hostname";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_get_hostname";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_endpoint_get_hostname";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_get_hostname";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_endpoint_get_hostname";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void sub_1830E5290(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_enumerate_resolver_configs(void *a1, void *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_path_update_dns(v3);
    resolver_configs = (atomic_uchar *)v3->resolver_configs;
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_path_enumerate_resolver_configs_block_invoke;
    v14[3] = &unk_1E524AE90;
    id v15 = v4;
    nw_array_apply(resolver_configs, (uint64_t)v14);

    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_path_enumerate_resolver_configs";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v7, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_path_enumerate_resolver_configs";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_path_enumerate_resolver_configs";
          __int16 v20 = 2082;
          BOOL v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_path_enumerate_resolver_configs";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_path_enumerate_resolver_configs";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_1830E55B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_get_next_log_id(void)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int add = atomic_fetch_add(nw_resolver_get_next_log_id(void)::s_last_id, 1u);
  uint64_t result = add + 1;
  if (add == -2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_path_t v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      id v4 = "nw_resolver_get_next_log_id";
      __int16 v5 = 1024;
      int v6 = -1;
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached %u resolver logging ids, wrapping", (uint8_t *)&v3, 0x12u);
    }

    return nw_resolver_get_next_log_id();
  }
  return result;
}

void NWPath.status.getter(unsigned char *a1@<X8>)
{
  *a1 = *v1;
}

ValueMetadata *type metadata accessor for NWPath.Status()
{
  return &type metadata for NWPath.Status;
}

unsigned char *sub_1830E5BAC(unsigned char *result, char a2)
{
  *uint64_t result = a2;
  return result;
}

BOOL static NWInterface.InterfaceType.== infix(_:_:)(unsigned __int8 *a1, unsigned __int8 *a2)
{
  return *a1 == *a2;
}

uint64_t nw_interface_functional_type_to_interface_type(int a1)
{
  if ((a1 - 1) > 5) {
    return 0;
  }
  else {
    return dword_183E234A0[a1 - 1];
  }
}

uint64_t nw_protocol_retain(uint64_t result)
{
  if (result)
  {
    if (*(_UNKNOWN **)(result + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v1 = *(void *)(result + 88);
      if (v1) {
        *(void *)(result + 88) = v1 + 1;
      }
    }
    else
    {
      return 0;
    }
  }
  return result;
}

id *nw_endpoint_copy_association(void *a1, void *a2)
{
  return nw_endpoint_copy_association_with_evaluator(a1, a2, 0);
}

uint64_t nw_parameters_get_required_interface_subtype(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned int *)(*((void *)v1 + 13) + 80);
    goto LABEL_3;
  }
  __int16 v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_required_interface_subtype";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_required_interface_subtype";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_required_interface_subtype";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_required_interface_subtype";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_required_interface_subtype";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_allow_ultra_constrained(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 100) >> 2) & 1;
    goto LABEL_3;
  }
  __int16 v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_allow_ultra_constrained";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_allow_ultra_constrained";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_allow_ultra_constrained";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_allow_ultra_constrained";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_allow_ultra_constrained";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

id nw_parameters_copy_prohibited_netagent_uuids(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __int16 v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_copy_prohibited_netagent_uuids";
    int v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_copy_prohibited_netagent_uuids";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 48);
LABEL_23:

  return v4;
}

id nw_parameters_copy_prohibited_netagent_types(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __int16 v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_copy_prohibited_netagent_types";
    int v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_types";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_copy_prohibited_netagent_types";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_types";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_types";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 40);
LABEL_23:

  return v4;
}

id nw_parameters_copy_prohibited_netagent_domains(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    __int16 v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_copy_prohibited_netagent_domains";
    int v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_domains";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_copy_prohibited_netagent_domains";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_domains";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_netagent_domains";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 32);
LABEL_23:

  return v4;
}

uint64_t nw_protocol_get_output_handler(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 32);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "__nw_protocol_get_output_handler";
  nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_protocol_get_output_handler";
        __int16 v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "__nw_protocol_get_output_handler";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_protocol_get_output_handler";
        __int16 v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_protocol_get_output_handler";
        __int16 v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_parameters_set_source_application_by_bundle_id(void *a1, const char *a2)
{
}

uint64_t nw_interface_functional_type_to_interface_subtype(int a1)
{
  if ((a1 - 3) > 4) {
    return 0;
  }
  else {
    return dword_183E234B8[a1 - 3];
  }
}

void ___ZL18nw_context_deallocP21NWConcrete_nw_contextb_block_invoke(uint64_t a1)
{
}

uint64_t nw_protocol_get_input_handler(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 48);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "__nw_protocol_get_input_handler";
  nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_protocol_get_input_handler";
        __int16 v5 = "%{public}s called with null protocol";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "__nw_protocol_get_input_handler";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_protocol_get_input_handler";
        __int16 v5 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_protocol_get_input_handler";
        __int16 v5 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke_3(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 32) + 16))(*(void *)(a1 + 32), *(unsigned __int8 *)(a1 + 40));
}

uint64_t ___ZL28nw_flow_handle_send_completeP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocol_block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

uint64_t nw_parameters_get_prohibit_roaming(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 100) >> 3) & 1;
    goto LABEL_3;
  }
  __int16 v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_prohibit_roaming";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_prohibit_roaming";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_prohibit_roaming";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

NSObject *nw_parameters_create_secure_tcp_or_quic_connection(void *a1, void *a2, void *a3)
{
  return nw_parameters_create_quic_connection_with_tls_fallback(a1, a2, 0, a3);
}

BOOL nw_context_create(const char *a1)
{
  nw_path_t v2 = [NWConcrete_nw_context alloc];

  return -[NWConcrete_nw_context initWithIdentifier:](v2, a1);
}

uint64_t ___ZL27nw_path_get_vpn_config_uuidP18NWConcrete_nw_pathPA16_hPibbb_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  length[0] = 0;
  if (xdict)
  {
    data = xpc_dictionary_get_data(xdict, "data", length);
    if (data)
    {
      if (length[0] >= 0xD8
        && length[0] == *((unsigned int *)data + 53) + 216
        && (!*(unsigned char *)(a1 + 56) || (data[208] & 2) == 0))
      {
        length[0] = 0;
        length[1] = 0;
        ne_session_get_config_id_from_network_agent();
      }
    }
  }
  return 1;
}

uint64_t __nwlog_tcp_log()
{
  if (__nwlog_tcp_log::onceToken[0] != -1) {
    dispatch_once(__nwlog_tcp_log::onceToken, &__block_literal_global_52);
  }
  return gtcpLogObj;
}

void *__Block_byref_object_copy__5(uint64_t a1, uint64_t a2)
{
  uint64_t result = _Block_copy(*(const void **)(a2 + 40));
  *(void *)(a1 + 40) = result;
  return result;
}

uint64_t ___ZL32nw_socket_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t ___ZL33nw_channel_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    ++*(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
  }
  nw_frame_finalize(a2);
  return 1;
}

void nw_frame_finalize(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v13 = "__nw_frame_finalize";
    nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "__nw_frame_finalize";
      __int16 v5 = "%{public}s called with null frame";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          char v13 = "__nw_frame_finalize";
          __int16 v14 = 2082;
          id v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v2) {
          return;
        }
        goto LABEL_35;
      }
      if (!v7) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "__nw_frame_finalize";
      __int16 v5 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v13 = "__nw_frame_finalize";
      __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
    goto LABEL_34;
  }
  id v1 = *(void (**)(void))(a1 + 80);
  if (v1)
  {
    *(void *)(a1 + 80) = 0;
    *(void *)(a1 + 88) = 0;
    v1();
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v13 = "__nw_frame_finalize";
  nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (!__nwlog_fault(v2, &type, &v10)) {
    goto LABEL_34;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v13 = "__nw_frame_finalize";
    __int16 v5 = "%{public}s called with null frame->finalizer";
    goto LABEL_33;
  }
  if (!v10)
  {
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    if (!os_log_type_enabled(v3, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v13 = "__nw_frame_finalize";
    __int16 v5 = "%{public}s called with null frame->finalizer, backtrace limit exceeded";
    goto LABEL_33;
  }
  os_log_type_t v8 = (char *)__nw_create_backtrace_string();
  uint64_t v3 = __nwlog_obj();
  os_log_type_t v4 = type;
  BOOL v9 = os_log_type_enabled(v3, type);
  if (!v8)
  {
    if (!v9) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v13 = "__nw_frame_finalize";
    __int16 v5 = "%{public}s called with null frame->finalizer, no backtrace";
    goto LABEL_33;
  }
  if (v9)
  {
    *(_DWORD *)buf = 136446466;
    char v13 = "__nw_frame_finalize";
    __int16 v14 = 2082;
    id v15 = v8;
    _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame->finalizer, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v8);
  if (v2) {
LABEL_35:
  }
    free(v2);
}

void nw_channel_finalize_output_frame(nw_frame *a1, int a2, unsigned __int16 *a3)
{
  uint64_t v225 = *MEMORY[0x1E4F143B8];
  metadata = (void *)nw_frame_get_metadata((uint64_t)a1);
  BOOL v7 = metadata;
  if (!metadata || !*metadata)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
      goto LABEL_15;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    BOOL v11 = "%{public}s Frame has no packet";
LABEL_13:
    os_log_type_t v12 = v10;
    os_log_type_t v13 = OS_LOG_TYPE_ERROR;
    goto LABEL_14;
  }
  if (!metadata[1])
  {
    if ((a3[222] & 0x1000) == 0) {
      goto LABEL_113;
    }
    if (!*((void *)a3 + 17)) {
      goto LABEL_113;
    }
    int v23 = os_channel_packet_free();
    if (!v23) {
      goto LABEL_113;
    }
    int v24 = v23;
    if (!*((void *)a3 + 17))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
      goto LABEL_113;
    }
    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
    {
LABEL_113:
      void *v7 = 0;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = gLogObj;
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_15;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      BOOL v11 = "%{public}s Frame has no buflet";
      goto LABEL_13;
    }
    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_113;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v24;
    v175 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v175, &v223, type))
    {
      if (v223 == 17)
      {
        v176 = __nwlog_obj();
        os_log_type_t v177 = v223;
        if (!os_log_type_enabled(v176, (os_log_type_t)v223)) {
          goto LABEL_478;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v24;
        v178 = "%{public}s os_channel_packet_free failed %{darwin.errno}d";
        goto LABEL_477;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v176 = __nwlog_obj();
        os_log_type_t v177 = v223;
        if (!os_log_type_enabled(v176, (os_log_type_t)v223)) {
          goto LABEL_478;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v24;
        v178 = "%{public}s os_channel_packet_free failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_477;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      v176 = __nwlog_obj();
      os_log_type_t v177 = v223;
      BOOL v184 = os_log_type_enabled(v176, (os_log_type_t)v223);
      if (backtrace_string)
      {
        if (v184)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v24;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v176, v177, "%{public}s os_channel_packet_free failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_478;
      }
      if (v184)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v24;
        v178 = "%{public}s os_channel_packet_free failed %{darwin.errno}d, no backtrace";
LABEL_477:
        _os_log_impl(&dword_1830D4000, v176, v177, v178, buf, 0x12u);
      }
    }
LABEL_478:
    if (v175) {
      free(v175);
    }
    goto LABEL_113;
  }
  if (!*((void *)a3 + 17))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v25 = gLogObj;
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_15;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    BOOL v11 = "%{public}s Channel is defunct, cannot write frame";
    os_log_type_t v12 = v25;
    os_log_type_t v13 = OS_LOG_TYPE_DEBUG;
LABEL_14:
    _os_log_impl(&dword_1830D4000, v12, v13, v11, buf, 0xCu);
    goto LABEL_15;
  }
  if (!a2)
  {
    int v26 = os_buflet_set_data_length();
    if (!v26) {
      goto LABEL_91;
    }
    int v27 = v26;
    if (!*((void *)a3 + 17))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
LABEL_91:
      LOWORD(v223) = 0;
      *(_WORD *)os_log_type_t type = 0;
      LOWORD(v216) = 0;
      if (a1)
      {
        if ((*((_WORD *)a1 + 102) & 0x100) == 0 || !g_channel_get_internet_checksum_handler) {
          goto LABEL_132;
        }
        int internet_checksum_handler = g_channel_get_internet_checksum_handler(a1, &v223, type, &v216);
        if (!internet_checksum_handler)
        {
          if (!(*(unsigned __int16 *)type | (unsigned __int16)v223 | (unsigned __int16)v216)) {
            goto LABEL_132;
          }
          id v40 = __nwlog_obj();
          if (os_log_type_enabled(v40, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
            __int16 v221 = 1024;
            *(_DWORD *)v222 = (unsigned __int16)v223;
            *(_WORD *)&v222[4] = 1024;
            *(_DWORD *)&v222[6] = *(unsigned __int16 *)type;
            *(_WORD *)&v222[10] = 1024;
            *(_DWORD *)&v222[12] = (unsigned __int16)v216;
            _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_INFO, "%{public}s Bleaching partial checksum bits: is_partial=%d; start=%u; stuff=%u",
              buf,
              0x1Eu);
          }
          int v41 = 45;
          if ((*((_WORD *)a1 + 102) & 0x100) != 0)
          {
            uint64_t v42 = g_channel_set_internet_checksum_handler;
            if (g_channel_set_internet_checksum_handler)
            {
              *((unsigned char *)a1 + 203) |= 4u;
              int v43 = ((uint64_t (*)(nw_frame *, uint64_t, void, void))v42)(a1, 4, 0, 0);
              if (!v43) {
                goto LABEL_132;
              }
              int v41 = v43;
            }
          }
          uint64_t v44 = __nwlog_obj();
          if (!os_log_type_enabled(v44, OS_LOG_TYPE_ERROR)) {
            goto LABEL_132;
          }
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = (unsigned __int16)v223;
          *(_WORD *)&v222[4] = 1024;
          *(_DWORD *)&v222[6] = *(unsigned __int16 *)type;
          *(_WORD *)&v222[10] = 1024;
          *(_DWORD *)&v222[12] = (unsigned __int16)v216;
          *(_WORD *)&v222[16] = 1024;
          *(_DWORD *)&v222[18] = v41;
          os_log_type_t v36 = "%{public}s __nw_frame_set_internet_checksum failed: is_partial=%d; start=%u; stuff=%u %{darwin.errno}d";
          __int16 v37 = v44;
          os_log_type_t v38 = OS_LOG_TYPE_ERROR;
          uint32_t v39 = 36;
          goto LABEL_98;
        }
        int v34 = internet_checksum_handler;
        if (internet_checksum_handler == 45) {
          goto LABEL_132;
        }
        goto LABEL_96;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
      v145 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v219 = OS_LOG_TYPE_ERROR;
      char v218 = 0;
      if (__nwlog_fault(v145, &v219, &v218))
      {
        if (v219 == OS_LOG_TYPE_FAULT)
        {
          v146 = __nwlog_obj();
          os_log_type_t v147 = v219;
          if (os_log_type_enabled(v146, v219))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
            v148 = "%{public}s called with null frame";
LABEL_383:
            _os_log_impl(&dword_1830D4000, v146, v147, v148, buf, 0xCu);
          }
        }
        else if (v218)
        {
          v157 = (char *)__nw_create_backtrace_string();
          v146 = __nwlog_obj();
          os_log_type_t v147 = v219;
          BOOL v158 = os_log_type_enabled(v146, v219);
          if (v157)
          {
            if (v158)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
              __int16 v221 = 2082;
              *(void *)v222 = v157;
              _os_log_impl(&dword_1830D4000, v146, v147, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v157);
            goto LABEL_384;
          }
          if (v158)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
            v148 = "%{public}s called with null frame, no backtrace";
            goto LABEL_383;
          }
        }
        else
        {
          v146 = __nwlog_obj();
          os_log_type_t v147 = v219;
          if (os_log_type_enabled(v146, v219))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_internet_checksum";
            v148 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_383;
          }
        }
      }
LABEL_384:
      if (v145) {
        free(v145);
      }
      int v34 = 22;
LABEL_96:
      uint64_t v35 = __nwlog_obj();
      if (!os_log_type_enabled(v35, OS_LOG_TYPE_ERROR)) {
        goto LABEL_132;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      __int16 v221 = 1024;
      *(_DWORD *)v222 = v34;
      os_log_type_t v36 = "%{public}s __nw_frame_get_internet_checksum failed %{darwin.errno}d";
      __int16 v37 = v35;
      os_log_type_t v38 = OS_LOG_TYPE_ERROR;
      uint32_t v39 = 18;
LABEL_98:
      _os_log_impl(&dword_1830D4000, v37, v38, v36, buf, v39);
      goto LABEL_132;
    }
    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0) {
      goto LABEL_91;
    }
    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_91;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v27;
    v169 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v169, &v223, type))
    {
      if (v223 == 17)
      {
        v170 = __nwlog_obj();
        os_log_type_t v171 = v223;
        if (!os_log_type_enabled(v170, (os_log_type_t)v223)) {
          goto LABEL_471;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v27;
        v172 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d";
        goto LABEL_470;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v170 = __nwlog_obj();
        os_log_type_t v171 = v223;
        if (!os_log_type_enabled(v170, (os_log_type_t)v223)) {
          goto LABEL_471;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v27;
        v172 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_470;
      }
      v181 = (char *)__nw_create_backtrace_string();
      v170 = __nwlog_obj();
      os_log_type_t v171 = v223;
      BOOL v182 = os_log_type_enabled(v170, (os_log_type_t)v223);
      if (v181)
      {
        if (v182)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v27;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = v181;
          _os_log_impl(&dword_1830D4000, v170, v171, "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v181);
        goto LABEL_471;
      }
      if (v182)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v27;
        v172 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, no backtrace";
LABEL_470:
        _os_log_impl(&dword_1830D4000, v170, v171, v172, buf, 0x12u);
      }
    }
LABEL_471:
    if (v169) {
      free(v169);
    }
    goto LABEL_91;
  }
  nw_frame_effective_length((uint64_t)a1);
  int v8 = os_buflet_set_data_length();
  if (!v8) {
    goto LABEL_66;
  }
  int v9 = v8;
  if (*((void *)a3 + 17))
  {
    if (((a3[222] | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0) {
      goto LABEL_66;
    }
    if (os_channel_is_defunct())
    {
      nw_channel_handle_defunct((uint64_t)a3);
      goto LABEL_66;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v9;
    v165 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v165, &v223, type)) {
      goto LABEL_466;
    }
    if (v223 == 17)
    {
      v166 = __nwlog_obj();
      os_log_type_t v167 = v223;
      if (!os_log_type_enabled(v166, (os_log_type_t)v223)) {
        goto LABEL_466;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      __int16 v221 = 1024;
      *(_DWORD *)v222 = v9;
      v168 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d";
    }
    else if (type[0])
    {
      v179 = (char *)__nw_create_backtrace_string();
      v166 = __nwlog_obj();
      os_log_type_t v167 = v223;
      BOOL v180 = os_log_type_enabled(v166, (os_log_type_t)v223);
      if (v179)
      {
        if (v180)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v9;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = v179;
          _os_log_impl(&dword_1830D4000, v166, v167, "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v179);
        goto LABEL_466;
      }
      if (!v180)
      {
LABEL_466:
        if (v165) {
          free(v165);
        }
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      __int16 v221 = 1024;
      *(_DWORD *)v222 = v9;
      v168 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, no backtrace";
    }
    else
    {
      v166 = __nwlog_obj();
      os_log_type_t v167 = v223;
      if (!os_log_type_enabled(v166, (os_log_type_t)v223)) {
        goto LABEL_466;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
      __int16 v221 = 1024;
      *(_DWORD *)v222 = v9;
      v168 = "%{public}s os_buflet_set_data_length failed %{darwin.errno}d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v166, v167, v168, buf, 0x12u);
    goto LABEL_466;
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
LABEL_66:
  if (!*((void *)a3 + 17))
  {
    v144 = __nwlog_obj();
    if (!os_log_type_enabled(v144, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_132;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    os_log_type_t v36 = "%{public}s Channel is newly defunct, cannot write frame";
    __int16 v37 = v144;
    os_log_type_t v38 = OS_LOG_TYPE_DEBUG;
    uint32_t v39 = 12;
    goto LABEL_98;
  }
  if (a1) {
    goto LABEL_68;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "__nw_frame_get_service_class";
  v149 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v223) = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v149, &v223, type))
  {
    if (v223 == 17)
    {
      v150 = __nwlog_obj();
      os_log_type_t v151 = v223;
      if (!os_log_type_enabled(v150, (os_log_type_t)v223)) {
        goto LABEL_390;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_service_class";
      v152 = "%{public}s called with null frame";
      goto LABEL_389;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v150 = __nwlog_obj();
      os_log_type_t v151 = v223;
      if (!os_log_type_enabled(v150, (os_log_type_t)v223)) {
        goto LABEL_390;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_service_class";
      v152 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_389;
    }
    v159 = (char *)__nw_create_backtrace_string();
    v150 = __nwlog_obj();
    os_log_type_t v151 = v223;
    BOOL v160 = os_log_type_enabled(v150, (os_log_type_t)v223);
    if (v159)
    {
      if (v160)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_service_class";
        __int16 v221 = 2082;
        *(void *)v222 = v159;
        _os_log_impl(&dword_1830D4000, v150, v151, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v159);
      goto LABEL_390;
    }
    if (v160)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_service_class";
      v152 = "%{public}s called with null frame, no backtrace";
LABEL_389:
      _os_log_impl(&dword_1830D4000, v150, v151, v152, buf, 0xCu);
    }
  }
LABEL_390:
  if (v149) {
    free(v149);
  }
LABEL_68:
  os_packet_set_service_class();
  if ((a3[222] & 0x400) != 0)
  {
    if (a1)
    {
      if ((*((unsigned char *)a1 + 186) & 3) == 1)
      {
        os_packet_set_l4s_flag();
        if (*((void *)a1 + 20)) {
          os_packet_set_tx_timestamp();
        }
      }
      if ((*((unsigned char *)a1 + 186) & 4) != 0)
      {
        os_packet_set_transport_retransmit();
        if ((*((unsigned char *)a1 + 186) & 8) == 0) {
          goto LABEL_73;
        }
      }
      else if ((*((unsigned char *)a1 + 186) & 8) == 0)
      {
        goto LABEL_73;
      }
      os_packet_set_transport_last_packet();
LABEL_73:
      if ((*((unsigned char *)a1 + 186) & 0x10) != 0)
      {
        os_packet_set_transport_traffic_background();
        if ((*((unsigned char *)a1 + 186) & 0x20) == 0) {
          goto LABEL_75;
        }
      }
      else if ((*((unsigned char *)a1 + 186) & 0x20) == 0)
      {
        goto LABEL_75;
      }
      os_packet_set_transport_traffic_realtime();
LABEL_75:
      LOBYTE(v28) = *((_WORD *)a1 + 102);
      if ((*((_WORD *)a1 + 102) & 0x20) != 0)
      {
        os_packet_set_packetid();
        LOBYTE(v28) = *((_WORD *)a1 + 102);
        if ((*((_WORD *)a1 + 102) & 0x10) == 0) {
          goto LABEL_79;
        }
      }
      else if ((*((_WORD *)a1 + 102) & 0x10) == 0)
      {
        goto LABEL_79;
      }
      if (*((void *)a1 + 19))
      {
        os_packet_set_expire_time();
        __int16 v28 = *((_WORD *)a1 + 102);
      }
LABEL_79:
      if ((v28 & 0x40) == 0)
      {
        if (*((_DWORD *)a1 + 48)) {
          os_packet_set_compression_generation_count();
        }
        goto LABEL_127;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
      char v29 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(v223) = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v29, &v223, type))
      {
        if (v223 == 17)
        {
          char v30 = __nwlog_obj();
          os_log_type_t v31 = v223;
          if (!os_log_type_enabled(v30, (os_log_type_t)v223)) {
            goto LABEL_125;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          BOOL v32 = "%{public}s Attempt to get generation-count on a chain-member";
          goto LABEL_124;
        }
        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          char v30 = __nwlog_obj();
          os_log_type_t v31 = v223;
          if (!os_log_type_enabled(v30, (os_log_type_t)v223)) {
            goto LABEL_125;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          BOOL v32 = "%{public}s Attempt to get generation-count on a chain-member, backtrace limit exceeded";
          goto LABEL_124;
        }
        uint64_t v45 = (char *)__nw_create_backtrace_string();
        char v30 = __nwlog_obj();
        os_log_type_t v31 = v223;
        BOOL v46 = os_log_type_enabled(v30, (os_log_type_t)v223);
        if (v45)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
            __int16 v221 = 2082;
            *(void *)v222 = v45;
            _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s Attempt to get generation-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v45);
          goto LABEL_125;
        }
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_frame_get_compression_generation_count";
          BOOL v32 = "%{public}s Attempt to get generation-count on a chain-member, no backtrace";
LABEL_124:
          _os_log_impl(&dword_1830D4000, v30, v31, v32, buf, 0xCu);
        }
      }
LABEL_125:
      if (v29) {
        free(v29);
      }
LABEL_127:
      int v47 = *((unsigned __int16 *)a1 + 102);
      if ((v47 & 0x8000) != 0)
      {
        os_packet_set_keep_alive();
        if (((*((unsigned __int16 *)a1 + 102) | (*((unsigned __int8 *)a1 + 206) << 16)) & 0x10000) == 0)
        {
LABEL_129:
          if (!*((_WORD *)a1 + 99))
          {
LABEL_131:
            os_packet_add_inet_csum_flags();
            goto LABEL_132;
          }
LABEL_130:
          os_packet_set_tso_flags();
          os_packet_set_protocol_segment_size();
          goto LABEL_131;
        }
      }
      else if (((v47 | (*((unsigned __int8 *)a1 + 206) << 16)) & 0x10000) == 0)
      {
        goto LABEL_129;
      }
      os_packet_set_app_metadata();
      if (!*((_WORD *)a1 + 99)) {
        goto LABEL_131;
      }
      goto LABEL_130;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
    v153 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v153, &v223, type))
    {
      if (v223 == 17)
      {
        v154 = __nwlog_obj();
        os_log_type_t v155 = v223;
        if (!os_log_type_enabled(v154, (os_log_type_t)v223)) {
          goto LABEL_418;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v156 = "%{public}s called with null frame";
LABEL_417:
        _os_log_impl(&dword_1830D4000, v154, v155, v156, buf, 0xCu);
        goto LABEL_418;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v154 = __nwlog_obj();
        os_log_type_t v155 = v223;
        if (!os_log_type_enabled(v154, (os_log_type_t)v223)) {
          goto LABEL_418;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v156 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_417;
      }
      v163 = (char *)__nw_create_backtrace_string();
      v154 = __nwlog_obj();
      os_log_type_t v155 = v223;
      BOOL v164 = os_log_type_enabled(v154, (os_log_type_t)v223);
      if (!v163)
      {
        if (!v164) {
          goto LABEL_418;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        v156 = "%{public}s called with null frame, no backtrace";
        goto LABEL_417;
      }
      if (v164)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_get_ecn_flag";
        __int16 v221 = 2082;
        *(void *)v222 = v163;
        _os_log_impl(&dword_1830D4000, v154, v155, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v163);
    }
LABEL_418:
    if (v153) {
      free(v153);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
    v185 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v185, &v223, type))
    {
      if (v223 == 17)
      {
        v186 = __nwlog_obj();
        os_log_type_t v187 = v223;
        if (!os_log_type_enabled(v186, (os_log_type_t)v223)) {
          goto LABEL_434;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        v188 = "%{public}s called with null frame";
LABEL_433:
        _os_log_impl(&dword_1830D4000, v186, v187, v188, buf, 0xCu);
        goto LABEL_434;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v186 = __nwlog_obj();
        os_log_type_t v187 = v223;
        if (!os_log_type_enabled(v186, (os_log_type_t)v223)) {
          goto LABEL_434;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        v188 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_433;
      }
      v189 = (char *)__nw_create_backtrace_string();
      v186 = __nwlog_obj();
      os_log_type_t v187 = v223;
      BOOL v190 = os_log_type_enabled(v186, (os_log_type_t)v223);
      if (!v189)
      {
        if (!v190) {
          goto LABEL_434;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        v188 = "%{public}s called with null frame, no backtrace";
        goto LABEL_433;
      }
      if (v190)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_is_retransmit";
        __int16 v221 = 2082;
        *(void *)v222 = v189;
        _os_log_impl(&dword_1830D4000, v186, v187, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v189);
    }
LABEL_434:
    if (v185) {
      free(v185);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
    v191 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v191, &v223, type)) {
      goto LABEL_450;
    }
    if (v223 == 17)
    {
      v192 = __nwlog_obj();
      os_log_type_t v193 = v223;
      if (!os_log_type_enabled(v192, (os_log_type_t)v223)) {
        goto LABEL_450;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
      v194 = "%{public}s called with null frame";
    }
    else if (type[0])
    {
      v195 = (char *)__nw_create_backtrace_string();
      v192 = __nwlog_obj();
      os_log_type_t v193 = v223;
      BOOL v196 = os_log_type_enabled(v192, (os_log_type_t)v223);
      if (v195)
      {
        if (v196)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
          __int16 v221 = 2082;
          *(void *)v222 = v195;
          _os_log_impl(&dword_1830D4000, v192, v193, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v195);
        goto LABEL_450;
      }
      if (!v196)
      {
LABEL_450:
        if (v191) {
          free(v191);
        }
        goto LABEL_73;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
      v194 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      v192 = __nwlog_obj();
      os_log_type_t v193 = v223;
      if (!os_log_type_enabled(v192, (os_log_type_t)v223)) {
        goto LABEL_450;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_is_last_frame";
      v194 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v192, v193, v194, buf, 0xCu);
    goto LABEL_450;
  }
LABEL_132:
  if (*((void *)a3 + 17))
  {
    unint64_t v223 = 0;
    uint64_t v224 = 0;
    os_packet_get_flow_uuid();
    uint64_t node = nw_hash_table_get_node(*((void *)a3 + 35), (uint64_t)&v223, 16);
    if (node)
    {
      if ((a3[222] & 0x200) != 0 && (*(unsigned char *)(node + 153) & 3) == 0)
      {
        *(void *)(node + 72) = 0;
        uint64_t v49 = node + 72;
        v50 = (void *)*((void *)a3 + 47);
        *(void *)(v49 + 8) = v50;
        void *v50 = v49 - 40;
        *((void *)a3 + 47) = v49;
        *(unsigned char *)(v49 + 81) |= 1u;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v51 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1042;
        *(_DWORD *)v222 = 16;
        *(_WORD *)&v222[4] = 2098;
        *(void *)&v222[6] = &v223;
        _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_ERROR, "%{public}s Node not found for flow id %{public,uuid_t}.16P", buf, 0x1Cu);
      }
    }
    os_packet_finalize();
    if ((a3[222] & 0x1000) != 0)
    {
      if (*((void *)a3 + 27))
      {
        int v52 = os_channel_slot_attach_packet();
        if (v52)
        {
          int v53 = v52;
          if ((nw_channel_check_defunct((uint64_t)a3) & 1) == 0)
          {
            __nwlog_obj();
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
            __int16 v221 = 1024;
            *(_DWORD *)v222 = v53;
            uint64_t v54 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v216) = 0;
            if (!__nwlog_fault(v54, type, &v216)) {
              goto LABEL_461;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              uint64_t v55 = __nwlog_obj();
              os_log_type_t v56 = type[0];
              if (!os_log_type_enabled(v55, type[0])) {
                goto LABEL_461;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
              __int16 v221 = 1024;
              *(_DWORD *)v222 = v53;
              id v57 = "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d";
            }
            else if ((_BYTE)v216)
            {
              v173 = (char *)__nw_create_backtrace_string();
              uint64_t v55 = __nwlog_obj();
              os_log_type_t v56 = type[0];
              BOOL v174 = os_log_type_enabled(v55, type[0]);
              if (v173)
              {
                if (v174)
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
                  __int16 v221 = 1024;
                  *(_DWORD *)v222 = v53;
                  *(_WORD *)&v222[4] = 2082;
                  *(void *)&v222[6] = v173;
                  _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v173);
                goto LABEL_461;
              }
              if (!v174)
              {
LABEL_461:
                if (v54) {
                  free(v54);
                }
                goto LABEL_15;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
              __int16 v221 = 1024;
              *(_DWORD *)v222 = v53;
              id v57 = "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d, no backtrace";
            }
            else
            {
              uint64_t v55 = __nwlog_obj();
              os_log_type_t v56 = type[0];
              if (!os_log_type_enabled(v55, type[0])) {
                goto LABEL_461;
              }
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
              __int16 v221 = 1024;
              *(_DWORD *)v222 = v53;
              id v57 = "%{public}s os_channel_slot_attach_packet failed %{darwin.errno}d, backtrace limit exceeded";
            }
            _os_log_impl(&dword_1830D4000, v55, v56, v57, buf, 0x12u);
            goto LABEL_461;
          }
        }
      }
    }
  }
LABEL_15:
  uint64_t v15 = *((void *)a1 + 2);
  uint64_t v16 = (void *)*((void *)a1 + 3);
  __int16 v14 = (void *)((char *)a1 + 16);
  if (v15)
  {
    *(void *)(v15 + 24) = v16;
    uint64_t v16 = (void *)*((void *)a1 + 3);
  }
  else
  {
    *((void *)a3 + 39) = v16;
  }
  *uint64_t v16 = v15;
  void *v14 = 0;
  *((void *)a1 + 3) = 0;
  --*((_DWORD *)a3 + 105);
  if (v7 && *v7)
  {
    void *v7 = 0;
    v7[1] = 0;
  }
  *((void *)a1 + 2) = 0;
  __int16 v17 = (void *)*((void *)a3 + 37);
  *((void *)a1 + 3) = v17;
  void *v17 = a1;
  *((void *)a3 + 37) = v14;
  if (*((void *)a3 + 38)) {
    return;
  }
  if (*((void *)a3 + 51) && *((void *)a3 + 27))
  {
    int v18 = os_channel_advance_slot();
    if (!v18 || (int v139 = v18, (nw_channel_check_defunct((uint64_t)a3) & 1) != 0))
    {
LABEL_25:
      *((void *)a3 + 51) = 0;
      goto LABEL_26;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
    __int16 v221 = 1024;
    *(_DWORD *)v222 = v139;
    v140 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v223) = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v140, &v223, type))
    {
      if (v223 == 17)
      {
        v141 = __nwlog_obj();
        os_log_type_t v142 = v223;
        if (!os_log_type_enabled(v141, (os_log_type_t)v223)) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v139;
        v143 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d";
        goto LABEL_395;
      }
      if (type[0] == OS_LOG_TYPE_DEFAULT)
      {
        v141 = __nwlog_obj();
        os_log_type_t v142 = v223;
        if (!os_log_type_enabled(v141, (os_log_type_t)v223)) {
          goto LABEL_396;
        }
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v139;
        v143 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_395;
      }
      v161 = (char *)__nw_create_backtrace_string();
      v141 = __nwlog_obj();
      os_log_type_t v142 = v223;
      BOOL v162 = os_log_type_enabled(v141, (os_log_type_t)v223);
      if (v161)
      {
        if (v162)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
          __int16 v221 = 1024;
          *(_DWORD *)v222 = v139;
          *(_WORD *)&v222[4] = 2082;
          *(void *)&v222[6] = v161;
          _os_log_impl(&dword_1830D4000, v141, v142, "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v161);
        goto LABEL_396;
      }
      if (v162)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frame";
        __int16 v221 = 1024;
        *(_DWORD *)v222 = v139;
        v143 = "%{public}s os_channel_advance_slot(tx) %{darwin.errno}d, no backtrace";
LABEL_395:
        _os_log_impl(&dword_1830D4000, v141, v142, v143, buf, 0x12u);
      }
    }
LABEL_396:
    if (v140) {
      free(v140);
    }
    goto LABEL_25;
  }
LABEL_26:
  uint64_t v19 = a3 + 222;
  int v20 = a3[222];
  if ((v20 & 0x8000) != 0)
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
    }
    if (_nw_signposts_enabled && kdebug_is_enabled()) {
      kdebug_trace();
    }
    *((unsigned char *)a3 + 446) = ((unsigned __int16)*v19 | (*((unsigned __int8 *)a3 + 446) << 16) | 0x10000u) >> 16;
  }
  else
  {
    unsigned int v21 = (v20 | (*((unsigned __int8 *)a3 + 446) << 16)) & 0xFFFEFFFF;
    _WORD *v19 = v20;
    *((unsigned char *)a3 + 446) = BYTE2(v21);
    if (*((void *)a3 + 17))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
      if (os_channel_sync()) {
        nw_channel_check_defunct((uint64_t)a3);
      }
    }
  }
  if ((*v19 & 0x200) != 0)
  {
    if ((*((unsigned char *)a1 + 186) & 3) == 1)
    {
      if (*((void *)a3 + 17))
      {
        if (*((void *)a3 + 27))
        {
          unsigned int v216 = 0;
          *(_DWORD *)os_log_type_t type = 0;
          uint64_t v22 = *((void *)a3 + 46);
          while (v22)
          {
            uint64_t v58 = v22;
            uint64_t v22 = *(void *)(v22 + 40);
            uint64_t v59 = *(void *)(v58 + 24);
            ce_size_t count = os_channel_flow_adv_get_ce_count();
            if (ce_count)
            {
              if (ce_count == 6)
              {
                if (!gLogDatapath) {
                  continue;
                }
                v111 = __nwlog_obj();
                if (!os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG)) {
                  continue;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
                __int16 v221 = 2082;
                *(void *)v222 = v58 + 84;
                v99 = v111;
                v100 = "%{public}s Channel doesn't support flow-advisory %{public}s";
                goto LABEL_251;
              }
              if (ce_count != 22)
              {
                if (ce_count != 2) {
                  continue;
                }
                if (!gLogDatapath) {
                  continue;
                }
                BOOL v98 = __nwlog_obj();
                if (!os_log_type_enabled(v98, OS_LOG_TYPE_DEBUG)) {
                  continue;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
                __int16 v221 = 2082;
                *(void *)v222 = v58 + 84;
                v99 = v98;
                v100 = "%{public}s Flow advisory is not not valid for flow id %{public}s";
LABEL_251:
                _os_log_impl(&dword_1830D4000, v99, OS_LOG_TYPE_DEBUG, v100, buf, 0x16u);
                continue;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              uint64_t v83 = v58 + 84;
              *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
              __int16 v221 = 2082;
              *(void *)v222 = v83;
              *(_WORD *)&v222[8] = 1024;
              *(_DWORD *)&v222[10] = 22;
              char v84 = (const char *)_os_log_send_and_compose_impl();
              LOBYTE(v223) = 16;
              os_log_type_t v219 = OS_LOG_TYPE_DEFAULT;
              if (!__nwlog_fault(v84, &v223, &v219)) {
                goto LABEL_247;
              }
              if (v223 == 17)
              {
                __int16 v85 = __nwlog_obj();
                os_log_type_t v86 = v223;
                os_log_t loga = v85;
                if (os_log_type_enabled(v85, (os_log_type_t)v223))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
                  __int16 v221 = 2082;
                  *(void *)v222 = v83;
                  *(_WORD *)&v222[8] = 1024;
                  *(_DWORD *)&v222[10] = 22;
                  __int16 v87 = loga;
                  os_log_type_t v88 = v86;
                  BOOL v89 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d";
                  goto LABEL_246;
                }
                goto LABEL_247;
              }
              if (v219)
              {
                v104 = (char *)__nw_create_backtrace_string();
                v201 = __nwlog_obj();
                os_log_type_t v207 = v223;
                BOOL v105 = os_log_type_enabled(v201, (os_log_type_t)v223);
                if (v104)
                {
                  if (v105)
                  {
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
                    __int16 v221 = 2082;
                    *(void *)v222 = v83;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = 22;
                    *(_WORD *)&v222[14] = 2082;
                    *(void *)&v222[16] = v104;
                    _os_log_impl(&dword_1830D4000, v201, v207, "%{public}s Ring is not TX %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                  }
                  free(v104);
                  goto LABEL_247;
                }
                if (!v105)
                {
LABEL_247:
                  if (!v84) {
                    continue;
                  }
                  uint64_t v72 = (char *)v84;
                  goto LABEL_177;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
                __int16 v221 = 2082;
                *(void *)v222 = v83;
                *(_WORD *)&v222[8] = 1024;
                *(_DWORD *)&v222[10] = 22;
                __int16 v87 = v201;
                os_log_type_t v88 = v207;
                BOOL v89 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d, no backtrace";
              }
              else
              {
                v109 = __nwlog_obj();
                os_log_type_t v110 = v223;
                os_log_t logc = v109;
                if (!os_log_type_enabled(v109, (os_log_type_t)v223)) {
                  goto LABEL_247;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_channel_flows_adv_get_ce_count";
                __int16 v221 = 2082;
                *(void *)v222 = v83;
                *(_WORD *)&v222[8] = 1024;
                *(_DWORD *)&v222[10] = 22;
                __int16 v87 = logc;
                os_log_type_t v88 = v110;
                BOOL v89 = "%{public}s Ring is not TX %{public}s %{darwin.errno}d, backtrace limit exceeded";
              }
LABEL_246:
              _os_log_impl(&dword_1830D4000, v87, v88, v89, buf, 0x1Cu);
              goto LABEL_247;
            }
            if (*(_DWORD *)type) {
              BOOL v61 = v216 == 0;
            }
            else {
              BOOL v61 = 1;
            }
            if (v61) {
              continue;
            }
            unint64_t v223 = __PAIR64__(v216, *(unsigned int *)type);
            if (v59)
            {
              uint64_t v62 = *(void **)(v59 + 40);
              if (v62 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v63 = *(void *)(v59 + 88);
                if (v63) {
                  *(void *)(v59 + 88) = v63 + 1;
                }
              }
              uint64_t v64 = (void *)*((void *)a3 + 8);
              if (v64 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v65 = *((void *)a3 + 14);
                if (v65) {
                  *((void *)a3 + 14) = v65 + 1;
                }
              }
              uint64_t v66 = *(void *)(v59 + 24);
              if (v66)
              {
                BOOL v67 = *(void (**)(uint64_t, unsigned __int16 *, uint64_t, unint64_t *, uint64_t))(v66 + 160);
                if (v67)
                {
                  v67(v59, a3 + 12, 20, &v223, 8);
LABEL_165:
                  if (v64 == &nw_protocol_ref_counted_handle
                    && *((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v73 = *((void *)a3 + 14);
                    if (v73)
                    {
                      uint64_t v74 = v73 - 1;
                      *((void *)a3 + 14) = v74;
                      if (!v74)
                      {
                        v75 = (void (**)(void))*((void *)a3 + 11);
                        if (v75)
                        {
                          *((void *)a3 + 11) = 0;
                          v75[2](v75);
                          _Block_release(v75);
                        }
                        if (a3[48])
                        {
                          v76 = (const void *)*((void *)a3 + 11);
                          if (v76) {
                            _Block_release(v76);
                          }
                        }
                        free(a3 + 12);
                      }
                    }
                  }
                  if (v62 != &nw_protocol_ref_counted_handle) {
                    continue;
                  }
                  if (*(_UNKNOWN **)(v59 + 40) != &nw_protocol_ref_counted_handle) {
                    continue;
                  }
                  uint64_t v68 = *(void *)(v59 + 88);
                  if (!v68) {
                    continue;
                  }
                  uint64_t v69 = v68 - 1;
                  *(void *)(v59 + 88) = v69;
                  if (v69) {
                    continue;
                  }
                  uint64_t v70 = *(void (***)(void))(v59 + 64);
                  if (v70)
                  {
                    *(void *)(v59 + 64) = 0;
                    v70[2](v70);
                    _Block_release(v70);
                  }
                  if (*(unsigned char *)(v59 + 72))
                  {
                    uint64_t v71 = *(const void **)(v59 + 64);
                    if (v71) {
                      _Block_release(v71);
                    }
                  }
                  uint64_t v72 = (char *)v59;
                  goto LABEL_177;
                }
              }
              __nwlog_obj();
              char v77 = *(const char **)(v59 + 16);
              if (!v77) {
                char v77 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
              __int16 v221 = 2082;
              *(void *)v222 = v77;
              *(_WORD *)&v222[8] = 2048;
              *(void *)&v222[10] = v59;
              v78 = (const char *)_os_log_send_and_compose_impl();
              os_log_type_t v219 = OS_LOG_TYPE_ERROR;
              char v218 = 0;
              os_log_t log = (os_log_t)v78;
              if (!__nwlog_fault(v78, &v219, &v218)) {
                goto LABEL_233;
              }
              if (v219 == OS_LOG_TYPE_FAULT)
              {
                v203 = __nwlog_obj();
                os_log_type_t v198 = v219;
                if (os_log_type_enabled(v203, v219))
                {
                  os_log_type_t v79 = *(const char **)(v59 + 16);
                  if (!v79) {
                    os_log_type_t v79 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  __int16 v221 = 2082;
                  *(void *)v222 = v79;
                  *(_WORD *)&v222[8] = 2048;
                  *(void *)&v222[10] = v59;
                  v80 = v203;
                  os_log_type_t v81 = v198;
                  BOOL v82 = "%{public}s protocol %{public}s (%p) has invalid notify callback";
                  goto LABEL_232;
                }
                goto LABEL_233;
              }
              if (v218)
              {
                v204 = (char *)__nw_create_backtrace_string();
                v199 = __nwlog_obj();
                os_log_type_t v197 = v219;
                BOOL v96 = os_log_type_enabled(v199, v219);
                if (v204)
                {
                  if (v96)
                  {
                    v97 = *(const char **)(v59 + 16);
                    if (!v97) {
                      v97 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                    __int16 v221 = 2082;
                    *(void *)v222 = v97;
                    *(_WORD *)&v222[8] = 2048;
                    *(void *)&v222[10] = v59;
                    *(_WORD *)&v222[18] = 2082;
                    *(void *)&v222[20] = v204;
                    _os_log_impl(&dword_1830D4000, v199, v197, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }
                  free(v204);
                  goto LABEL_233;
                }
                if (!v96)
                {
LABEL_233:
                  if (log) {
                    free(log);
                  }
                  goto LABEL_165;
                }
                BOOL v106 = *(const char **)(v59 + 16);
                if (!v106) {
                  BOOL v106 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                __int16 v221 = 2082;
                *(void *)v222 = v106;
                *(_WORD *)&v222[8] = 2048;
                *(void *)&v222[10] = v59;
                v80 = v199;
                os_log_type_t v81 = v197;
                BOOL v82 = "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace";
              }
              else
              {
                v206 = __nwlog_obj();
                os_log_type_t v200 = v219;
                if (!os_log_type_enabled(v206, v219)) {
                  goto LABEL_233;
                }
                v103 = *(const char **)(v59 + 16);
                if (!v103) {
                  v103 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                __int16 v221 = 2082;
                *(void *)v222 = v103;
                *(_WORD *)&v222[8] = 2048;
                *(void *)&v222[10] = v59;
                v80 = v206;
                os_log_type_t v81 = v200;
                BOOL v82 = "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded";
              }
LABEL_232:
              _os_log_impl(&dword_1830D4000, v80, v81, v82, buf, 0x20u);
              goto LABEL_233;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
            v90 = (const char *)_os_log_send_and_compose_impl();
            os_log_type_t v219 = OS_LOG_TYPE_ERROR;
            char v218 = 0;
            if (__nwlog_fault(v90, &v219, &v218))
            {
              if (v219 == OS_LOG_TYPE_FAULT)
              {
                id v91 = __nwlog_obj();
                os_log_type_t v92 = v219;
                if (os_log_type_enabled(v91, v219))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  uint64_t v93 = v91;
                  os_log_type_t v94 = v92;
                  v95 = "%{public}s called with null protocol";
LABEL_239:
                  _os_log_impl(&dword_1830D4000, v93, v94, v95, buf, 0xCu);
                }
              }
              else if (v218)
              {
                v101 = (char *)__nw_create_backtrace_string();
                logb = __nwlog_obj();
                os_log_type_t v205 = v219;
                BOOL v102 = os_log_type_enabled(logb, v219);
                if (v101)
                {
                  if (v102)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                    __int16 v221 = 2082;
                    *(void *)v222 = v101;
                    _os_log_impl(&dword_1830D4000, logb, v205, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }
                  free(v101);
                  goto LABEL_240;
                }
                if (v102)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  uint64_t v93 = logb;
                  os_log_type_t v94 = v205;
                  v95 = "%{public}s called with null protocol, no backtrace";
                  goto LABEL_239;
                }
              }
              else
              {
                v107 = __nwlog_obj();
                os_log_type_t v108 = v219;
                if (os_log_type_enabled(v107, v219))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                  uint64_t v93 = v107;
                  os_log_type_t v94 = v108;
                  v95 = "%{public}s called with null protocol, backtrace limit exceeded";
                  goto LABEL_239;
                }
              }
            }
LABEL_240:
            if (!v90) {
              continue;
            }
            uint64_t v72 = (char *)v90;
LABEL_177:
            free(v72);
          }
        }
      }
    }
    if (*((void *)a3 + 17))
    {
      if (*((void *)a3 + 27))
      {
        uint64_t v112 = *((void *)a3 + 46);
        if (v112)
        {
          do
          {
            uint64_t v114 = *(void *)(v112 + 40);
            uint64_t v115 = *(void *)(v112 + 24);
            int v116 = os_channel_flow_admissible();
            if (v116)
            {
              int v118 = v116;
              if (v116 == 55)
              {
                if (nw_link_set_flow_control_status(*(void **)(v112 + 72), 1))
                {
                  char v119 = __nwlog_obj();
                  if (os_log_type_enabled(v119, OS_LOG_TYPE_INFO))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                    __int16 v221 = 2082;
                    *(void *)v222 = v112 + 84;
                    _os_log_impl(&dword_1830D4000, v119, OS_LOG_TYPE_INFO, "%{public}s Flow controlled for flow id %{public}s", buf, 0x16u);
                  }
                }
                if (v115)
                {
                  uint64_t v120 = *(void *)(v115 + 24);
                  if (v120)
                  {
                    v121 = *(void (**)(uint64_t, unsigned __int16 *))(v120 + 104);
                    if (v121 && *(void *)(v112 + 72) != 0)
                    {
                      if (*(_UNKNOWN **)(v115 + 40) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v130 = *(void *)(v115 + 88);
                        if (v130) {
                          *(void *)(v115 + 88) = v130 + 1;
                        }
                        *(void *)buf = v115;
                        char v123 = buf[8] | 1;
                      }
                      else
                      {
                        *(void *)buf = v115;
                        char v123 = buf[8] & 0xFE;
                      }
                      buf[8] = v123;
                      if (*((_UNKNOWN **)a3 + 8) == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v132 = *((void *)a3 + 14);
                        if (v132) {
                          *((void *)a3 + 14) = v132 + 1;
                        }
                        unint64_t v223 = (unint64_t)(a3 + 12);
                        char v131 = v224 | 1;
                      }
                      else
                      {
                        unint64_t v223 = (unint64_t)(a3 + 12);
                        char v131 = v224 & 0xFE;
                      }
                      LOBYTE(v224) = v131;
                      v121(v115, a3 + 12);
                      nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)&v223);
                      nw::retained_ptr<nw_protocol *>::~retained_ptr((uint64_t *)buf);
                    }
                  }
                }
                *(void *)(v112 + 56) = 0;
                v133 = (uint64_t *)*((void *)a3 + 49);
                *(void *)(v112 + 64) = v133;
                uint64_t *v133 = v112;
                *((void *)a3 + 49) = v112 + 56;
                *(unsigned char *)(v112 + 121) |= 2u;
              }
              else if (v116 == 2)
              {
                if (gLogDatapath)
                {
                  v138 = __nwlog_obj();
                  if (os_log_type_enabled(v138, OS_LOG_TYPE_DEBUG))
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                    __int16 v221 = 2082;
                    *(void *)v222 = v112 + 84;
                    _os_log_impl(&dword_1830D4000, v138, OS_LOG_TYPE_DEBUG, "%{public}s Flow(%{public}s) is no longer present, disconnecting", buf, 0x16u);
                  }
                }
                nw_channel_disconnect_flow((uint64_t)a3, v112);
              }
              else if ((nw_channel_check_defunct((uint64_t)a3) & 1) == 0)
              {
                __nwlog_obj();
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                __int16 v221 = 2082;
                *(void *)v222 = v112 + 84;
                *(_WORD *)&v222[8] = 1024;
                *(_DWORD *)&v222[10] = v118;
                int v124 = (const char *)_os_log_send_and_compose_impl();
                LOBYTE(v223) = 16;
                type[0] = OS_LOG_TYPE_DEFAULT;
                v215 = (char *)v124;
                if (!__nwlog_fault(v124, &v223, type)) {
                  goto LABEL_303;
                }
                if (v223 == 17)
                {
                  int v125 = __nwlog_obj();
                  os_log_type_t v126 = v223;
                  *(void *)v208 = v125;
                  if (os_log_type_enabled(v125, (os_log_type_t)v223))
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                    __int16 v221 = 2082;
                    uint64_t v127 = *(NSObject **)v208;
                    *(void *)v222 = v112 + 84;
                    *(_WORD *)&v222[8] = 1024;
                    *(_DWORD *)&v222[10] = v118;
                    os_log_type_t v128 = v126;
                    v129 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d";
                    goto LABEL_302;
                  }
                  goto LABEL_303;
                }
                if (type[0])
                {
                  v134 = (char *)__nw_create_backtrace_string();
                  v209 = __nwlog_obj();
                  os_log_type_t v202 = v223;
                  BOOL v135 = os_log_type_enabled(v209, (os_log_type_t)v223);
                  if (v134)
                  {
                    if (v135)
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                      __int16 v221 = 2082;
                      *(void *)v222 = v112 + 84;
                      *(_WORD *)&v222[8] = 1024;
                      *(_DWORD *)&v222[10] = v118;
                      *(_WORD *)&v222[14] = 2082;
                      *(void *)&v222[16] = v134;
                      _os_log_impl(&dword_1830D4000, v209, v202, "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x26u);
                    }
                    free(v134);
                    goto LABEL_303;
                  }
                  if (!v135)
                  {
LABEL_303:
                    if (v215) {
                      free(v215);
                    }
                    goto LABEL_260;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                  __int16 v221 = 2082;
                  uint64_t v127 = v209;
                  *(void *)v222 = v112 + 84;
                  *(_WORD *)&v222[8] = 1024;
                  *(_DWORD *)&v222[10] = v118;
                  os_log_type_t v128 = v202;
                  v129 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, no backtrace";
                }
                else
                {
                  v136 = __nwlog_obj();
                  os_log_type_t v137 = v223;
                  *(void *)v210 = v136;
                  if (!os_log_type_enabled(v136, (os_log_type_t)v223)) {
                    goto LABEL_303;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_channel_check_flows_controlled";
                  __int16 v221 = 2082;
                  uint64_t v127 = *(NSObject **)v210;
                  *(void *)v222 = v112 + 84;
                  *(_WORD *)&v222[8] = 1024;
                  *(_DWORD *)&v222[10] = v118;
                  os_log_type_t v128 = v137;
                  v129 = "%{public}s Flow admissible check failed %{public}s %{darwin.errno}d, backtrace limit exceeded";
                }
LABEL_302:
                _os_log_impl(&dword_1830D4000, v127, v128, v129, buf, 0x1Cu);
                goto LABEL_303;
              }
            }
LABEL_260:
            if (*(unsigned char *)(v112 + 121))
            {
              uint64_t v117 = *(void *)(v112 + 40);
              int v113 = *(void **)(v112 + 48);
              if (v117)
              {
                *(void *)(v117 + 48) = v113;
                int v113 = *(void **)(v112 + 48);
              }
              else
              {
                *((void *)a3 + 47) = v113;
              }
              *int v113 = v117;
              *(unsigned char *)(v112 + 121) &= ~1u;
            }
            uint64_t v112 = v114;
          }
          while (v114);
        }
      }
    }
  }
}

BOOL nw_hash_table_get_node(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v29 = "nw_hash_table_get_node";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v10, &type, &v26)) {
      goto LABEL_56;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v26)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (!os_log_type_enabled(v11, type)) {
          goto LABEL_56;
        }
        *(_DWORD *)buf = 136446210;
        char v29 = "nw_hash_table_get_node";
        os_log_type_t v13 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_55;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v21 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (!v21) {
          goto LABEL_56;
        }
        *(_DWORD *)buf = 136446210;
        char v29 = "nw_hash_table_get_node";
        os_log_type_t v13 = "%{public}s called with null table, no backtrace";
        goto LABEL_55;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446466;
        char v29 = "nw_hash_table_get_node";
        __int16 v30 = 2082;
        os_log_type_t v31 = backtrace_string;
        uint64_t v22 = "%{public}s called with null table, dumping backtrace:%{public}s";
LABEL_38:
        _os_log_impl(&dword_1830D4000, v11, v12, v22, buf, 0x16u);
      }
LABEL_39:
      free(backtrace_string);
      goto LABEL_56;
    }
    BOOL v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    if (!os_log_type_enabled(v11, type)) {
      goto LABEL_56;
    }
    *(_DWORD *)buf = 136446210;
    char v29 = "nw_hash_table_get_node";
    os_log_type_t v13 = "%{public}s called with null table";
LABEL_55:
    _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
LABEL_56:
    if (v10) {
      free(v10);
    }
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v29 = "nw_hash_table_get_node";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v10, &type, &v26)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      char v29 = "nw_hash_table_get_node";
      os_log_type_t v13 = "%{public}s called with null key";
      goto LABEL_55;
    }
    if (!v26)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      char v29 = "nw_hash_table_get_node";
      os_log_type_t v13 = "%{public}s called with null key, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v23 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        char v29 = "nw_hash_table_get_node";
        __int16 v30 = 2082;
        os_log_type_t v31 = backtrace_string;
        uint64_t v22 = "%{public}s called with null key, dumping backtrace:%{public}s";
        goto LABEL_38;
      }
      goto LABEL_39;
    }
    if (!v23) {
      goto LABEL_56;
    }
    *(_DWORD *)buf = 136446210;
    char v29 = "nw_hash_table_get_node";
    os_log_type_t v13 = "%{public}s called with null key, no backtrace";
    goto LABEL_55;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    int v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  __int16 v14 = __nwlog_obj();
  os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  char v29 = "nw_hash_table_lock";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v15);
  if (!result)
  {
    free(v15);
    int v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_6:
      if (v6)
      {
        BOOL v7 = *(uint64_t **)(a1
                         + 16
                         * ((*(unsigned int (**)(uint64_t, uint64_t))(a1 + 8))(a2, a3) % *(_DWORD *)(a1 + 32))
                         + 56);
        if (v7)
        {
          do
          {
            int v8 = (uint64_t *)*v7;
            if (*((unsigned char *)v7 + 30) == 1
              && ((*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(a1 + 16))(v7[2], a2, a3) & 1) != 0)
            {
              break;
            }
            BOOL v7 = v8;
          }
          while (v8);
        }
        if ((*(unsigned char *)(a1 + 48) & 2) != 0) {
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        }
        return (BOOL)v7;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      char v29 = "nw_hash_table_get_node";
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v26 = 0;
      if (__nwlog_fault(v16, &type, &v26))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          if (!os_log_type_enabled(v17, type)) {
            goto LABEL_61;
          }
          *(_DWORD *)buf = 136446210;
          char v29 = "nw_hash_table_get_node";
          uint64_t v19 = "%{public}s called with invalid hash table";
LABEL_60:
          _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
          goto LABEL_61;
        }
        if (!v26)
        {
          __int16 v17 = __nwlog_obj();
          os_log_type_t v18 = type;
          if (!os_log_type_enabled(v17, type)) {
            goto LABEL_61;
          }
          *(_DWORD *)buf = 136446210;
          char v29 = "nw_hash_table_get_node";
          uint64_t v19 = "%{public}s called with invalid hash table, backtrace limit exceeded";
          goto LABEL_60;
        }
        int v24 = (char *)__nw_create_backtrace_string();
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v25 = os_log_type_enabled(v17, type);
        if (!v24)
        {
          if (!v25) {
            goto LABEL_61;
          }
          *(_DWORD *)buf = 136446210;
          char v29 = "nw_hash_table_get_node";
          uint64_t v19 = "%{public}s called with invalid hash table, no backtrace";
          goto LABEL_60;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          char v29 = "nw_hash_table_get_node";
          __int16 v30 = 2082;
          os_log_type_t v31 = v24;
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v24);
      }
LABEL_61:
      if (v16) {
        free(v16);
      }
      if ((*(unsigned char *)(a1 + 48) & 2) != 0)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        return 0;
      }
      return 0;
    }
LABEL_5:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    int v6 = *(_DWORD *)(a1 + 48);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

uint64_t nw_channel_get_internet_checksum_handler(nw_frame *a1, BOOL *a2, unsigned __int16 *a3, unsigned __int16 *a4)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t metadata = nw_frame_get_metadata((uint64_t)a1);
  if (a4 && a3 && a2 && metadata)
  {
    if ((*(unsigned char *)(metadata + 24) & 1) == 0) {
      return 45;
    }
    __int16 inet_checksum = os_packet_get_inet_checksum();
    uint64_t result = 0;
    *a2 = inet_checksum & 1;
    int v12 = *((unsigned __int16 *)a1 + 102);
    BOOL v11 = (char *)a1 + 204;
    unsigned int v13 = v12 & 0xFFFFE1FF | (v11[2] << 16);
    *(_WORD *)BOOL v11 = v12 & 0xE1FF | (2 * inet_checksum) & 0x1E00;
    v11[2] = BYTE2(v13);
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v23 = "nw_channel_get_internet_checksum_handler";
  __int16 v14 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v14, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_channel_get_internet_checksum_handler";
        __int16 v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL)";
LABEL_22:
        _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v23 = "nw_channel_get_internet_checksum_handler";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && checksum_value != NULL), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_23;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_channel_get_internet_checksum_handler";
        __int16 v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL), no backtrace";
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v23 = "nw_channel_get_internet_checksum_handler";
        __int16 v17 = "%{public}s called with null (frame_info != NULL && is_partial_checksum != NULL && start_offset != NULL && "
              "checksum_value != NULL), backtrace limit exceeded";
        goto LABEL_22;
      }
    }
  }
LABEL_23:
  if (v14) {
    free(v14);
  }
  return 22;
}

uint64_t nw_frame_get_metadata(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 4) != 0) {
      return a1 + 208;
    }
    else {
      return 0;
    }
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "__nw_frame_get_metadata";
  nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_get_metadata";
        __int16 v5 = "%{public}s called with null frame";
LABEL_19:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "__nw_frame_get_metadata";
          __int16 v12 = 2082;
          unsigned int v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_get_metadata";
        __int16 v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_19;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_get_metadata";
        __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
  }
LABEL_20:
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t nw_context_endpoint_key_hash(void *a1)
{
  return [a1 getHash];
}

uint64_t nw_frame_effective_length(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(unsigned int *)(a1 + 52);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "__nw_frame_effective_length";
  nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_effective_length";
        __int16 v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "__nw_frame_effective_length";
          __int16 v12 = 2082;
          unsigned int v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_effective_length";
        __int16 v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_effective_length";
        __int16 v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

BOOL nw_association_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

BOOL nw_protocol_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

uint64_t nw_context_endpoint_matches_key(void *a1, void *a2)
{
  return nw_endpoint_is_equal(a1, a2, 31);
}

BOOL nw_flow_registration_matches_key(void *a1, void *a2)
{
  return a1[4] == *a2 && a1[5] == a2[1];
}

BOOL nw_protocol_custom_mapping_matches_key(char *a1, unsigned __int8 *a2, unsigned int a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (*(_DWORD *)a1 == a3)
  {
    if (!a3) {
      return 1;
    }
    uint64_t v3 = (unsigned __int8 *)(a1 + 4);
    uint64_t v4 = a3 - 1;
    do
    {
      int v6 = *v3++;
      int v5 = v6;
      int v8 = *a2++;
      int v7 = v8;
      BOOL v10 = v4-- != 0;
      BOOL result = v5 == v7;
    }
    while (v5 == v7 && v10);
    return result;
  }
  __int16 v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_protocol_custom_mapping_matches_key";
  unsigned int v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v13, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_custom_mapping_matches_key";
        os_log_type_t v16 = "%{public}s Cannot have custom mapping keys with different lengths";
LABEL_25:
        _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
      }
    }
    else
    {
      if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "nw_protocol_custom_mapping_matches_key";
            __int16 v23 = 2082;
            __int16 v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s Cannot have custom mapping keys with different lengths, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (!v18) {
          goto LABEL_26;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_custom_mapping_matches_key";
        os_log_type_t v16 = "%{public}s Cannot have custom mapping keys with different lengths, no backtrace";
        goto LABEL_25;
      }
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_protocol_custom_mapping_matches_key";
        os_log_type_t v16 = "%{public}s Cannot have custom mapping keys with different lengths, backtrace limit exceeded";
        goto LABEL_25;
      }
    }
LABEL_26:
  }
LABEL_27:
  if (v13) {
    free(v13);
  }
  return 0;
}

BOOL nw_flow_protocol_matches_key(char *a1, const void *a2, int a3)
{
  uint64_t v3 = 240;
  if (!a3) {
    uint64_t v3 = 248;
  }
  return *(void *)&a1[v3] == (void)a2;
}

void nw_socket_frame_output_finalizer(nw_frame *a1, nw_protocol *a2, char *a3)
{
  uint64_t v5 = *((void *)a1 + 2);
  int v6 = (void *)*((void *)a1 + 3);
  uint64_t v4 = (void *)((char *)a1 + 16);
  if (v5)
  {
    *(void *)(v5 + 24) = v6;
    int v6 = (void *)*((void *)a1 + 3);
  }
  else
  {
    *((void *)a3 + 28) = v6;
  }
  void *v6 = v5;
  void *v4 = 0;
  *((void *)a1 + 3) = 0;
  if (a2)
  {
    int v7 = (void *)*((void *)a3 + 30);
    *((void *)a1 + 3) = v7;
    void *v7 = a1;
    *((void *)a3 + 30) = v4;
    nw_socket_service_writes((uint64_t)a3);
  }
  else
  {
    int v8 = (void *)*((void *)a3 + 26);
    *((void *)a1 + 3) = v8;
    *int v8 = a1;
    *((void *)a3 + 26) = v4;
  }
  if ((*(_WORD *)(a3 + 301) & 8) != 0)
  {
    nw_socket_output_finished((nw_protocol *)(a3 - 96), a2);
  }
}

BOOL stream_matches_key(_DWORD *a1, _DWORD *a2)
{
  return a1[8] == *a2;
}

uint64_t stream_key_hash(unsigned int *a1, int a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2 == 4) {
    return *a1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  unsigned int v13 = "stream_key_hash";
  __int16 v14 = 1024;
  int v15 = a2;
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        int v7 = "%{public}s stream_key_hash called with invalid key_length %u";
LABEL_16:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0x12u);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          unsigned int v13 = "stream_key_hash";
          __int16 v14 = 1024;
          int v15 = a2;
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s stream_key_hash called with invalid key_length %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_17;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        int v7 = "%{public}s stream_key_hash called with invalid key_length %u, no backtrace";
        goto LABEL_16;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        int v7 = "%{public}s stream_key_hash called with invalid key_length %u, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_17:
  if (v4) {
    free(v4);
  }
  return 0;
}

{
  char *v4;
  NSObject *v5;
  os_log_type_t v6;
  const char *v7;
  char *backtrace_string;
  BOOL v9;
  char v10;
  os_log_type_t type;
  uint8_t buf[4];
  const char *v13;
  __int16 v14;
  int v15;
  __int16 v16;
  char *v17;
  uint64_t v18;

  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a2 == 4) {
    return *a1;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446466;
  unsigned int v13 = "stream_key_hash";
  __int16 v14 = 1024;
  int v15 = a2;
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v4, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        int v7 = "%{public}s stream_key_hash called with invalid key_length %u";
LABEL_16:
        _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0x12u);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446722;
          unsigned int v13 = "stream_key_hash";
          __int16 v14 = 1024;
          int v15 = a2;
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s stream_key_hash called with invalid key_length %u, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_17;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        int v7 = "%{public}s stream_key_hash called with invalid key_length %u, no backtrace";
        goto LABEL_16;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v13 = "stream_key_hash";
        __int16 v14 = 1024;
        int v15 = a2;
        int v7 = "%{public}s stream_key_hash called with invalid key_length %u, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_17:
  if (v4) {
    free(v4);
  }
  return 0;
}

BOOL nw_context_object_matches_key(const void *a1, const void *a2)
{
  return a1 == a2;
}

uint64_t nw_frame_is_wake_packet(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return (*(unsigned __int16 *)(a1 + 204) >> 14) & 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "__nw_frame_is_wake_packet";
  nw_path_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_is_wake_packet";
        uint64_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "__nw_frame_is_wake_packet";
          __int16 v12 = 2082;
          unsigned int v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_is_wake_packet";
        uint64_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "__nw_frame_is_wake_packet";
        uint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t nw_path_get_policy_id(uint64_t result)
{
  if (result) {
    return *(unsigned int *)(result + 340);
  }
  return result;
}

BOOL nw_path_copy_description(void *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = [v1 description];
  uint64_t v3 = v2;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_path_copy_description";
    os_log_type_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v6, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_path_copy_description";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s [path description] failed", buf, 0xCu);
        }
      }
      else if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v12 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v32 = "nw_path_copy_description";
            __int16 v33 = 2082;
            size_t v34 = (size_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s [path description] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v6) {
            goto LABEL_42;
          }
          goto LABEL_41;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_path_copy_description";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s [path description] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v12 = (id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_path_copy_description";
          _os_log_impl(&dword_1830D4000, v12, v20, "%{public}s [path description] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v6)
    {
LABEL_42:
      os_log_type_t v6 = 0;
      goto LABEL_43;
    }
LABEL_41:
    free(v6);
    goto LABEL_42;
  }
  uint64_t v4 = [v2 lengthOfBytesUsingEncoding:4];
  size_t v5 = v4 + 1;
  if (v4 == -1)
  {
    __int16 v23 = __nwlog_obj();
    os_log_type_enabled(v23, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "strict_malloc";
    LODWORD(v28) = 12;
    int v27 = buf;
    __int16 v24 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v24);
    if (result) {
      goto LABEL_51;
    }
    free(v24);
  }
  os_log_type_t v6 = (char *)malloc_type_malloc(v5, 0xF2B69DE5uLL);
  if (v6) {
    goto LABEL_4;
  }
  uint64_t v25 = __nwlog_obj();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  uint64_t v32 = "strict_malloc";
  __int16 v33 = 2048;
  size_t v34 = v5;
  LODWORD(v28) = 22;
  int v27 = buf;
  uint64_t v26 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
LABEL_4:
    if (objc_msgSend(v3, "getCString:maxLength:encoding:", v6, v5, 4, v27, v28))
    {
LABEL_43:

      return (BOOL)v6;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v32 = "nw_path_copy_description";
    char v8 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault((const char *)v8, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_path_copy_description";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s [desc getCString:maxLength:encoding:] failed", buf, 0xCu);
        }
      }
      else if (v29)
      {
        __int16 v17 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (id)gLogObj;
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v9, type);
        if (v17)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v32 = "nw_path_copy_description";
            __int16 v33 = 2082;
            size_t v34 = (size_t)v17;
            _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s [desc getCString:maxLength:encoding:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v17);
          if (!v8)
          {
LABEL_12:
            if (!v6) {
              goto LABEL_43;
            }
            goto LABEL_41;
          }
LABEL_11:
          free(v8);
          goto LABEL_12;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_path_copy_description";
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s [desc getCString:maxLength:encoding:] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v9 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v32 = "nw_path_copy_description";
          _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s [desc getCString:maxLength:encoding:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v8) {
      goto LABEL_12;
    }
    goto LABEL_11;
  }
LABEL_51:
  __break(1u);
  return result;
}

void sub_1830EC798(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1830ED9A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,uint64_t a59,id a60,char a61,uint64_t a62,uint64_t a63)
{
  _Block_object_dispose(&a61, 8);
  _Block_object_dispose(&a65, 8);
  _Block_object_dispose((const void *)(v67 - 184), 8);
  _Block_object_dispose((const void *)(v67 - 152), 8);

  _Block_object_dispose(&a55, 8);
  _Unwind_Resume(a1);
}

BOOL nw_path_uses_interface_type(nw_path_t path, nw_interface_type_t interface_type)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  nw_path_t v3 = path;
  nw_path_t v4 = v3;
  if (!v3)
  {
    __int16 v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v34 = "nw_path_uses_interface_type";
    __int16 v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v24, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v28 = type;
        BOOL v29 = os_log_type_enabled(v25, type);
        if (backtrace_string)
        {
          if (v29)
          {
            *(_DWORD *)buf = 136446466;
            size_t v34 = "nw_path_uses_interface_type";
            __int16 v35 = 2082;
            os_log_type_t v36 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v28, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_44;
        }
        if (v29)
        {
          *(_DWORD *)buf = 136446210;
          size_t v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_1830D4000, v25, v28, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v25 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v34 = "nw_path_uses_interface_type";
          _os_log_impl(&dword_1830D4000, v25, v30, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_44:
    if (v24) {
      free(v24);
    }
    BOOL v5 = 0;
    goto LABEL_25;
  }
  if (interface_type != nw_interface_type_cellular)
  {
    if (interface_type == nw_interface_type_wifi && (BYTE3(v3[59].isa) & 0x40) != 0)
    {
      BOOL v5 = 1;
      goto LABEL_25;
    }
    BOOL v5 = 0;
LABEL_7:
    os_log_type_t v6 = nw_path_copy_connected_interface(v3);
    id v7 = v6;
    if (v6)
    {
      char v8 = v6;
      int v9 = *((_DWORD *)v8 + 24);

      if (v9 == interface_type) {
        goto LABEL_23;
      }
    }
    int isa = (int)v4[47].isa;
    char v11 = !v5;
    if (isa != 3) {
      char v11 = 1;
    }
    if ((v11 & 1) == 0)
    {
      if (nw_path_has_unsatisfied_cellular_agent(v4, 0)) {
        goto LABEL_23;
      }
      int isa = (int)v4[47].isa;
    }
    if (isa != 1)
    {
      BOOL v5 = 0;
      int isa_high = HIDWORD(v4[47].isa);
      if (isa_high == 4 || isa_high == 30) {
        goto LABEL_24;
      }
    }
    Class v13 = v4[12].isa;
    if (!v13 || (uint64_t v14 = v13, v15 = *((_DWORD *)v14 + 24), v14, v15 != interface_type))
    {
      Class v16 = v4[13].isa;
      if (!v16 || (__int16 v17 = v16, v18 = *((_DWORD *)v17 + 24), v17, v18 != interface_type))
      {
        Class v19 = v4[14].isa;
        if (!v19 || (v20 = v19, int v21 = *((_DWORD *)v20 + 24), v20, v21 != interface_type))
        {
          BOOL v5 = 0;
          goto LABEL_24;
        }
      }
    }
LABEL_23:
    BOOL v5 = 1;
LABEL_24:

    goto LABEL_25;
  }
  BOOL v5 = 1;
  if ((SBYTE3(v3[59].isa) & 0x80000000) == 0) {
    goto LABEL_7;
  }
LABEL_25:

  return v5;
}

void sub_1830EDDF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_is_ultra_constrained(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    nw_path_t v3 = nw_path_copy_connected_interface(v1);
    nw_path_t v4 = v3;
    if (v3)
    {
      BOOL v5 = v3;
      __int16 v6 = *(_WORD *)(v5 + 85);

      if ((v6 & 4) != 0) {
        goto LABEL_12;
      }
    }
    if (!nw_path_agents_are_satisfied_update_reason(v2, 0, 0, 0, 0)) {
      goto LABEL_11;
    }
    direct = v2->direct;
    if (direct)
    {
      char v8 = direct;
      __int16 v9 = *(_WORD *)((char *)v8 + 85);

      if ((v9 & 4) != 0) {
        goto LABEL_12;
      }
    }
    delegate = v2->delegate;
    if (delegate)
    {
      char v11 = delegate;
      __int16 v12 = *(_WORD *)((char *)v11 + 85);

      if ((v12 & 4) != 0) {
        goto LABEL_12;
      }
    }
    fallback_interface = v2->fallback_interface;
    if (fallback_interface
      && (uint64_t v14 = fallback_interface, v15 = *(_WORD *)((char *)v14 + 85), v14, (v15 & 4) != 0))
    {
LABEL_12:
      uint64_t v16 = 1;
    }
    else
    {
LABEL_11:
      uint64_t v16 = 0;
    }

    goto LABEL_14;
  }
  int v18 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v29 = "nw_path_is_ultra_constrained";
  Class v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v19, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v29 = "nw_path_is_ultra_constrained";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v29 = "nw_path_is_ultra_constrained";
          __int16 v30 = 2082;
          char v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_31;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v29 = "nw_path_is_ultra_constrained";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v29 = "nw_path_is_ultra_constrained";
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_31:
  if (v19) {
    free(v19);
  }
  uint64_t v16 = 0;
LABEL_14:

  return v16;
}

void sub_1830EE12C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

atomic_uchar *nw_path_copy_connected_interface(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    nw_path_t v3 = v1[11];
    if (v3)
    {
      nw_path_t v4 = v3;
    }
    else
    {
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      Class v19 = __Block_byref_object_copy__68682;
      os_log_type_t v20 = __Block_byref_object_dispose__68683;
      id v21 = 0;
      BOOL v5 = v1[9];
      v15[0] = MEMORY[0x1E4F143A8];
      v15[1] = 3221225472;
      v15[2] = __nw_path_copy_connected_interface_block_invoke;
      v15[3] = &unk_1E5248058;
      v15[4] = buf;
      nw_array_apply(v5, (uint64_t)v15);
      nw_path_t v4 = (atomic_uchar *)*(id *)(*(void *)&buf[8] + 40);
      _Block_object_dispose(buf, 8);
    }
    goto LABEL_5;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
  char v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v8, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_connected_interface";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  nw_path_t v4 = 0;
LABEL_5:

  return v4;
}

BOOL nw_path_agents_are_satisfied_update_reason(NWConcrete_nw_path *a1, char a2, char a3, char a4, BOOL *a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  __int16 v9 = a1;
  os_log_type_t v10 = v9;
  if (v9)
  {
    if (a5) {
      *a5 = 0;
    }
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    BOOL v11 = 1;
    char v32 = 1;
    network_agent_dictionary = v9->network_agent_dictionary;
    if (network_agent_dictionary)
    {
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZL42nw_path_agents_are_satisfied_update_reasonP18NWConcrete_nw_pathbbbPb_block_invoke;
      applier[3] = &unk_1E5248438;
      char v26 = a3;
      char v27 = a4;
      os_log_type_t v23 = v9;
      BOOL v24 = buf;
      os_log_type_t v25 = a5;
      char v28 = a2;
      xpc_dictionary_apply(network_agent_dictionary, applier);

      BOOL v11 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    }
    _Block_object_dispose(buf, 8);
    goto LABEL_7;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_agents_are_satisfied_update_reason";
  __int16 v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (__nwlog_fault(v15, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_agents_are_satisfied_update_reason";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v16 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_agents_are_satisfied_update_reason";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_agents_are_satisfied_update_reason";
        _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v16 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_agents_are_satisfied_update_reason";
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v15) {
    free(v15);
  }
  BOOL v11 = 0;
LABEL_7:

  return v11;
}

void sub_1830EE7F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL nw_path_should_fallback(void *a1, char a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_path_t v3 = a1;
  nw_path_t v4 = v3;
  if (!v3)
  {
    char v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "nw_path_should_fallback";
    __int16 v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v19 = "nw_path_should_fallback";
            __int16 v20 = 2082;
            os_log_type_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_32;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_should_fallback";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_32:
    if (v9) {
      free(v9);
    }
    goto LABEL_6;
  }
  if ((a2 & 1) == 0
    && ((*((unsigned char *)v3 + 473) & 8) == 0 && (nw_parameters_get_no_fallback(v3[2]) & 1) != 0
     || (nw_parameters_get_fallback_applied(v4[2]) & 1) != 0))
  {
LABEL_6:
    BOOL v5 = 0;
    goto LABEL_15;
  }
  if (v4[14] || v4[21] && v4[22])
  {
    BOOL v5 = 1;
  }
  else
  {
    __int16 v6 = v4;
    if (nw_path_allows_multipath(v6)) {
      BOOL v5 = nw_parameters_multipath_fallback_allowed(v6[2]);
    }
    else {
      BOOL v5 = 0;
    }
  }
LABEL_15:

  return v5;
}

void sub_1830EEB24(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_no_fallback(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 108) >> 5) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_no_fallback";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_no_fallback";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_no_fallback";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_fallback_applied(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 108) >> 11) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_fallback_applied";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_fallback_applied";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_fallback_applied";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_allows_multipath(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    BOOL v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v16 = "nw_path_allows_multipath";
    __int16 v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            char v16 = "nw_path_allows_multipath";
            __int16 v17 = 2082;
            int v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          char v16 = "nw_path_allows_multipath";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v6) {
      free(v6);
    }
    goto LABEL_8;
  }
  if (nw_parameters_get_multipath(v1[2])
    && !*((_DWORD *)v2 + 88)
    && *((_DWORD *)v2 + 66) != 4
    && (nw_path_uses_interface_subtype(v2, 5001) & 1) == 0
    && (nw_parameters_multipath_fallback_allowed(v2[2])
     || !nw_parameters_get_required_interface_index(v2[2])))
  {
    uint64_t v3 = 1;
    goto LABEL_9;
  }
LABEL_8:
  uint64_t v3 = 0;
LABEL_9:

  return v3;
}

void sub_1830EF35C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_is_viable(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    if ((v1[474] & 8) == 0)
    {
      uint64_t v3 = v1;
      if (nw_path_uses_nexus_internal(v3, 0)
        && (uint64_t nexus_agent = nw_path_get_nexus_agent(v3, 0), *(_DWORD *)(nexus_agent + 212) > 0xCBu))
      {
        unsigned int v5 = *(_DWORD *)(nexus_agent + 216);

        if (v5 <= 4 && (v5 & 0xFFFFFFFD) != 0) {
          goto LABEL_7;
        }
      }
      else
      {
      }
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      char v21 = 0;
      flows = (atomic_uchar *)v3->flows;
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3221225472;
      v17[2] = __nw_path_is_viable_block_invoke;
      v17[3] = &unk_1E5248058;
      v17[4] = buf;
      nw_array_apply(flows, (uint64_t)v17);
      BOOL v6 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
      _Block_object_dispose(buf, 8);
      goto LABEL_10;
    }
LABEL_7:
    BOOL v6 = 1;
    goto LABEL_10;
  }
  __int16 v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_path_is_viable";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v10, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_viable";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_path_is_viable";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_viable";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_is_viable";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v10) {
    free(v10);
  }
  BOOL v6 = 0;
LABEL_10:

  return v6;
}

void sub_1830EF6E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_nexus_agent(NWConcrete_nw_path *a1, char a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  nw_path_t v4 = v3;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  uint64_t v21 = 0;
  if (v3->network_agent_dictionary)
  {
    if (v3->policy_result.num_interface_options)
    {
      unint64_t v5 = 0;
      uint64_t v6 = 8;
      do
      {
        id v7 = (const unsigned __int8 *)v4->policy_result.interface_options + v6;
        if (!uuid_is_null(v7))
        {
          memset(out, 0, 37);
          uuid_unparse(v7, out);
          os_log_type_t v8 = xpc_dictionary_get_value(v4->network_agent_dictionary, out);
          __int16 v9 = v8;
          if (v8)
          {
            size_t length = 0;
            data = xpc_dictionary_get_data(v8, "data", &length);
            if (data)
            {
              if (length >= 0xD8 && length == data[53] + 216)
              {
                int v11 = data[52];
                if ((v11 & 0xE080) != 0)
                {
                  char v12 = (v11 & 0x40) != 0 ? 0 : a2;
                  if ((data[52] & 0x13) != 1 && (v12 & 1) == 0)
                  {
                    v19[3] = (uint64_t)data;

                    break;
                  }
                }
              }
            }
          }
        }
        ++v5;
        v6 += 24;
      }
      while (v5 < v4->policy_result.num_interface_options);
    }
    uint64_t v13 = v19[3];
    if (!v13)
    {
      network_agent_dictionary = v4->network_agent_dictionary;
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZL23nw_path_get_nexus_agentP18NWConcrete_nw_pathb_block_invoke;
      applier[3] = &unk_1E52480F8;
      char v17 = a2;
      void applier[4] = &v18;
      xpc_dictionary_apply(network_agent_dictionary, applier);
      uint64_t v13 = v19[3];
    }
  }
  else
  {
    uint64_t v13 = 0;
  }
  _Block_object_dispose(&v18, 8);

  return v13;
}

void sub_1830EF900(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, ...)
{
  va_start(va, a8);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_path_is_expensive(nw_path_t path)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (!v1)
  {
    uint64_t v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v30 = "nw_path_is_expensive";
    uint64_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v20, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v30 = "nw_path_is_expensive";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v30 = "nw_path_is_expensive";
            __int16 v31 = 2082;
            char v32 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v30 = "nw_path_is_expensive";
          _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v30 = "nw_path_is_expensive";
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_35:
    if (v20) {
      free(v20);
    }
    BOOL v7 = 0;
    goto LABEL_18;
  }
  if ((BYTE3(v1[59].isa) & 8) == 0)
  {
    uint64_t v3 = nw_path_copy_connected_interface(v1);
    nw_path_t v4 = v3;
    if (v3)
    {
      unint64_t v5 = v3;
      __int16 v6 = *(_WORD *)(v5 + 85);

      if (v6) {
        goto LABEL_16;
      }
    }
    if (LODWORD(v2[47].isa) != 1)
    {
      BOOL v7 = 0;
      int isa_high = HIDWORD(v2[47].isa);
      if (isa_high == 4 || isa_high == 30) {
        goto LABEL_17;
      }
    }
    Class isa = v2[12].isa;
    if (isa)
    {
      os_log_type_t v10 = isa;
      __int16 v11 = *(_WORD *)(v10 + 85);

      if (v11) {
        goto LABEL_16;
      }
    }
    Class v12 = v2[13].isa;
    if (v12)
    {
      uint64_t v13 = v12;
      __int16 v14 = *(_WORD *)(v13 + 85);

      if (v14) {
        goto LABEL_16;
      }
    }
    Class v15 = v2[14].isa;
    if (v15 && (os_log_type_t v16 = v15, v17 = *(_WORD *)(v16 + 85), v16, (v17 & 1) != 0)) {
LABEL_16:
    }
      BOOL v7 = 1;
    else {
      BOOL v7 = 0;
    }
LABEL_17:

    goto LABEL_18;
  }
  BOOL v7 = 1;
LABEL_18:

  return v7;
}

void nw_path_update_dns(NWConcrete_nw_path *a1)
{
  nw_path_t v1 = a1;
  v3[0] = MEMORY[0x1E4F143A8];
  v3[1] = 3221225472;
  v3[2] = ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke;
  v3[3] = &unk_1E524BAA8;
  nw_path_t v2 = v1;
  nw_path_t v4 = v2;
  os_unfair_lock_lock(v2 + 2);
  ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke((uint64_t)v3);
  os_unfair_lock_unlock(v2 + 2);
}

void sub_1830EFD1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  int v2 = *(char *)(v1 + 474);
  if ((v2 & 0x80000000) == 0)
  {
    uint64_t v3 = *(void **)(v1 + 224);
    if (v3)
    {
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke_2;
      applier[3] = &unk_1E52480D0;
      id v6 = (id)v1;
      xpc_dictionary_apply(v3, applier);

      uint64_t v1 = *(void *)(a1 + 32);
      LOBYTE(v2) = *(unsigned char *)(v1 + 474);
    }
    *(unsigned char *)(v1 + 474) = v2 | 0x80;
  }
}

void sub_1830EFDE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_path_assert_required_agents_block_invoke(uint64_t a1, int a2, xpc_object_t xdict)
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  v6[0] = 0;
  if (xdict)
  {
    data = xpc_dictionary_get_data(xdict, "data", v6);
    if (data)
    {
      if (v6[0] >= 0xD8 && v6[0] == *((unsigned int *)data + 53) + 216 && (data[209] & 2) != 0)
      {
        *(_OWORD *)id v6 = *(_OWORD *)data;
        if (!uuid_is_null((const unsigned __int8 *)v6)) {
          nw_path_agent_action(*(NWConcrete_nw_path **)(a1 + 32), (const unsigned __int8 *)v6, 131);
        }
      }
    }
  }
  return 1;
}

id nw_path_copy_netagent_dictionary(uint64_t a1)
{
  if (a1 && (uint64_t v1 = *(void **)(a1 + 224)) != 0) {
    return v1;
  }
  else {
    return 0;
  }
}

id *nw_path_copy_direct_interface(id *result)
{
  if (result) {
    return (id *)result[12];
  }
  return result;
}

void sub_1830F00FC(uint64_t a1, unint64_t *a2)
{
  if (!*a2)
  {
    unint64_t ForeignTypeMetadata = swift_getForeignTypeMetadata();
    if (!v4) {
      atomic_store(ForeignTypeMetadata, a2);
    }
  }
}

void type metadata accessor for os_unfair_lock_s(uint64_t a1)
{
}

uint64_t sub_1830F0158(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return a1;
}

uint64_t NWActivity.__deallocating_deinit()
{
  swift_unknownObjectRelease();

  return swift_deallocClassInstance();
}

void *nw_frame_array_append_array(void *result, void *a2, int a3)
{
  uint64_t v3 = *a2;
  if (a3)
  {
    if (!v3) {
      return result;
    }
    uint64_t v4 = (void *)result[1];
    ++result;
    void *v4 = v3;
    *(void *)(*a2 + 40) = *result;
  }
  else
  {
    if (!v3) {
      return result;
    }
    unint64_t v5 = (void *)result[1];
    ++result;
    void *v5 = v3;
    *(void *)(*a2 + 24) = *result;
  }
  *BOOL result = a2[1];
  *a2 = 0;
  a2[1] = a2;
  return result;
}

nw_protocol_definition_t nw_protocol_copy_tcp_definition(void)
{
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
  }
  uint64_t v0 = (void *)g_tcp_definition;

  return (nw_protocol_definition_t)v0;
}

void nw_frame_set_buffer_used_manager(uint64_t a1, uint64_t a2)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    *(void *)(a1 + 104) = a2;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v11 = "__nw_frame_set_buffer_used_manager";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v11 = "__nw_frame_set_buffer_used_manager";
      unint64_t v5 = "%{public}s called with null frame";
      goto LABEL_17;
    }
    if (!v8)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v11 = "__nw_frame_set_buffer_used_manager";
      unint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_17;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (backtrace_string)
    {
      if (v7)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v11 = "__nw_frame_set_buffer_used_manager";
        __int16 v12 = 2082;
        uint64_t v13 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v11 = "__nw_frame_set_buffer_used_manager";
      unint64_t v5 = "%{public}s called with null frame, no backtrace";
LABEL_17:
      _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
}

id nw_protocol_copy_quic_stream_definition()
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
  }
  uint64_t v0 = (void *)nw_protocol_copy_quic_stream_definition::quic_definition;

  return v0;
}

void ___ZL26nw_path_watch_necp_changesPU24objcproto13OS_nw_context8NSObject_block_invoke(uint64_t a1)
{
  BOOL globals_for_path = nw_context_get_globals_for_path(*(void **)(a1 + 32));
  uint64_t v3 = (os_unfair_lock_s *)(globals_for_path + 124);
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
  unsigned int v4 = *(_DWORD *)(globals_for_path + 128);
  os_unfair_lock_unlock(v3);
  unint64_t v5 = *(void **)(a1 + 32);

  nw_path_necp_check_for_updates(v5, 0, v4);
}

BOOL nw_context_get_globals_for_channel(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  id v2 = &__block_literal_global_33_88204;
  if (!v1)
  {
    __int16 v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_context_get_globals_for_channel";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v22 = "nw_context_get_globals_for_channel";
            __int16 v23 = 2082;
            uint64_t v24 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v11 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_context_get_globals_for_channel";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_25:
    if (v10) {
      free(v10);
    }
    uint64_t v5 = 0;
    goto LABEL_6;
  }
  BOOL v3 = nw_context_copy_globals_context(v1);

  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(v3 + 32) + 40));
  uint64_t v4 = *(void *)(v3 + 32);
  uint64_t v5 = *(void *)(v4 + 60);
  if (v5)
  {
LABEL_5:
    os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 40));

LABEL_6:
    return v5;
  }
  id v6 = malloc_type_calloc(1uLL, 0x18uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_4:
    *(void *)(*(void *)(v3 + 32) + 60) = v6;
    BOOL v7 = *(void **)(*(void *)(v3 + 32) + 60);
    void *v7 = nw_dictionary_create();
    v7[1] = nw_array_create();
    v7[2] = 0;
    uint64_t v4 = *(void *)(v3 + 32);
    uint64_t v5 = *(void *)(v4 + 60);
    goto LABEL_5;
  }
  os_log_type_t v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v22 = "strict_calloc";
  __int16 v23 = 2048;
  uint64_t v24 = 1;
  __int16 v25 = 2048;
  uint64_t v26 = 24;
  __int16 v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void sub_1830F0B88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_watch_necp_changes(void *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
    uint64_t globals_for_path = nw_context_get_globals_for_path(v1);
    BOOL v3 = (os_unfair_lock_s *)(globals_for_path + 124);
    os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
    int v4 = nw_path_shared_necp_fd(v1);
    pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
    if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0) {
      goto LABEL_33;
    }
    if ((sNWDispatchAllowedNow & 1) == 0)
    {
      if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
        || (getpid(), sandbox_check() == 1))
      {
        sNWDispatchAllowedNow = 1;
      }
      else if (!sNWDispatchAllowedNow)
      {
LABEL_33:
        os_unfair_lock_unlock(v3);
        goto LABEL_34;
      }
    }
    if (v4 == -1 || *(void *)(globals_for_path + 56)) {
      goto LABEL_33;
    }
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 3221225472;
    v22[2] = ___ZL26nw_path_watch_necp_changesPU24objcproto13OS_nw_context8NSObject_block_invoke;
    v22[3] = &unk_1E524BAA8;
    id v23 = v1;
    BOOL source = nw_queue_context_create_source(v23, v4, 1, 0, v22, 0);
    *(void *)(globals_for_path + 56) = source;
    if (source)
    {
      nw_queue_activate_source(source);
LABEL_32:

      goto LABEL_33;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v27 = "nw_path_watch_necp_changes";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v7, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v8 = (id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v27 = "nw_path_watch_necp_changes";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
        }
      }
      else if (v24)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v27 = "nw_path_watch_necp_changes";
            __int16 v28 = 2082;
            char v29 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v27 = "nw_path_watch_necp_changes";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s nw_queue_context_create_source failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v27 = "nw_path_watch_necp_changes";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_30:
    if (v7) {
      free(v7);
    }
    goto LABEL_32;
  }
  os_log_type_t v14 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v27 = "nw_path_watch_necp_changes";
  BOOL v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v15, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_path_watch_necp_changes";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v24)
    {
      os_log_type_t v18 = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v27 = "nw_path_watch_necp_changes";
          __int16 v28 = 2082;
          char v29 = v18;
          _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        goto LABEL_51;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_path_watch_necp_changes";
        _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_path_watch_necp_changes";
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_51:
  if (v15) {
    free(v15);
  }
LABEL_34:
}

void sub_1830F11EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_shares_workloop(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  BOOL v3 = a1;
  int v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      id v6 = (void *)nw_context_copy_globals_context(v3);
      BOOL v7 = (void *)nw_context_copy_globals_context(v5);
      BOOL v8 = v6 == v7;

      goto LABEL_4;
    }
    os_log_type_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_context_shares_workloop";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null other", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null other, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null other, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_context_shares_workloop";
        __int16 v27 = 2082;
        __int16 v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null other, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_context_shares_workloop";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null context", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v26 = "nw_context_shares_workloop";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_context_shares_workloop";
        __int16 v27 = 2082;
        __int16 v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v11) {
    free(v11);
  }
  BOOL v8 = 0;
LABEL_4:

  return v8;
}

void sub_1830F16F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_custom_proxy_configs(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    BOOL v3 = nw_context_has_proxies(*(void **)(v1[13] + 136)) || v2[22] != 0;
    goto LABEL_5;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_has_custom_proxy_configs";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_5:

  return v3;
}

void sub_1830F19CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_has_proxies(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    if ((v1[34]._os_unfair_lock_opaque & 0x48) == 0x40 && !dispatch_workloop_is_current())
    {
      os_unfair_lock_lock(v2 + 20);
      uint64_t v7 = *(void *)&v2[14]._os_unfair_lock_opaque;
      if (!v7 || *(void *)(v7 + 16) == *(void *)(v7 + 24))
      {
        BOOL v8 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
        uint64_t v9 = *(void *)(v8 + 56);
        if (v9) {
          BOOL v4 = *(void *)(v9 + 16) != *(void *)(v9 + 24);
        }
        else {
          BOOL v4 = 0;
        }
      }
      else
      {
        BOOL v4 = 1;
      }
      os_unfair_lock_unlock(v2 + 20);
    }
    else
    {
      uint64_t v3 = *(void *)&v2[14]._os_unfair_lock_opaque;
      if (!v3 || *(void *)(v3 + 16) == *(void *)(v3 + 24))
      {
        BOOL v5 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
        uint64_t v6 = *(void *)(v5 + 56);
        if (v6) {
          BOOL v4 = *(void *)(v6 + 16) != *(void *)(v6 + 24);
        }
        else {
          BOOL v4 = 0;
        }
      }
      else
      {
        BOOL v4 = 1;
      }
    }
    goto LABEL_19;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v22 = "nw_context_has_proxies";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_context_has_proxies";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v22 = "nw_context_has_proxies";
          __int16 v23 = 2082;
          char v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_context_has_proxies";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v22 = "nw_context_has_proxies";
        _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_36:
  if (v12) {
    free(v12);
  }
  BOOL v4 = 0;
LABEL_19:

  return v4;
}

void sub_1830F1D34(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_interface *nw_path_copy_interface_with_generation(void *a1, unsigned int a2, int a3)
{
  *(void *)((char *)&v51[2] + 2) = *MEMORY[0x1E4F143B8];
  BOOL v5 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (a2)
  {
    uint64_t globals_for_path = nw_context_get_globals_for_path(v5);
    os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
    if (*(void *)(globals_for_path + 88))
    {
      if (*(void *)(globals_for_path + 104)) {
        goto LABEL_8;
      }
    }
    else
    {
      BOOL v8 = nw_dictionary_create();
      uint64_t v9 = *(void **)(globals_for_path + 88);
      *(void *)(globals_for_path + 88) = v8;

      if (*(void *)(globals_for_path + 104)) {
        goto LABEL_8;
      }
    }
    xpc_object_t v10 = xpc_dictionary_create(0, 0, 0);
    BOOL v11 = *(void **)(globals_for_path + 104);
    *(void *)(globals_for_path + 104) = v10;

LABEL_8:
    lock = (os_unfair_lock_s *)(globals_for_path + 124);
    id v12 = *(id *)(globals_for_path + 88);
    xpc_object_t xdict = *(id *)(globals_for_path + 104);
    uint64_t v13 = mach_continuous_time();
    if (v13 <= 1) {
      uint64_t v14 = 1;
    }
    else {
      uint64_t v14 = v13;
    }
    snprintf((char *)(globals_for_path + 141), 0xAuLL, "%u", a2);
    os_log_type_t v15 = nw_dictionary_copy_value((uint64_t)v12, globals_for_path + 141);
    os_log_type_t v16 = v15;
    if (v15 && ((BOOL v17 = v15, v18 = v17[23], v17, !a3) || v18 == a3))
    {
      uint64_t v7 = v17;
      os_log_type_t v21 = xdict;
      xpc_dictionary_set_uint64(xdict, (const char *)(globals_for_path + 141), v14);
    }
    else
    {
      uint64_t v19 = nw_path_shared_necp_fd(v5);
      uint64_t v7 = nw_interface_create_from_necp(v19, a2);
      if (v7)
      {
        xpc_dictionary_set_uint64(xdict, (const char *)(globals_for_path + 141), v14);
        nw_dictionary_set_value((uint64_t)v12, (const char *)(globals_for_path + 141), v7);
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (id)gLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v49 = "nw_path_copy_interface_with_generation";
          __int16 v50 = 1024;
          LODWORD(v51[0]) = a2;
          WORD2(v51[0]) = 1024;
          *(_DWORD *)((char *)v51 + 6) = a3;
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s Cache miss for interface for index %u (generation %u)", buf, 0x18u);
        }

        os_log_type_t v21 = xdict;
      }
      else
      {
        os_log_type_t v21 = xdict;
      }
    }
    if (nw_dictionary_get_count((uint64_t)v12) < 0x11) {
      goto LABEL_38;
    }
    uint64_t v22 = *(void *)(globals_for_path + 96);
    if (v22)
    {
      if ((unint64_t)nw_delta_nanos(v22, v14) < 0x77359401) {
        goto LABEL_38;
      }
    }
    *(void *)(globals_for_path + 96) = v14;
    if (!v5 || v5[31] != 4)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v23 = (id)gLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v49 = "nw_path_copy_interface_with_generation";
        __int16 v50 = 1024;
        LODWORD(v51[0]) = 16;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEFAULT, "%{public}s Interface cache hit limit (%u), purging all interfaces not used recently", buf, 0x12u);
      }
    }
    xpc_object_t v24 = xpc_array_create(0, 0);
    if (v24)
    {
      v42[0] = MEMORY[0x1E4F143A8];
      v42[1] = 3221225472;
      v42[2] = __nw_path_copy_interface_with_generation_block_invoke;
      v42[3] = &unk_1E5248080;
      id v25 = v21;
      id v43 = v25;
      uint64_t v45 = v14;
      id v26 = v24;
      id v44 = v26;
      nw_dictionary_apply((uint64_t)v12, (uint64_t)v42);
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = __nw_path_copy_interface_with_generation_block_invoke_2;
      applier[3] = &unk_1E52480A8;
      id v40 = v12;
      id v41 = v25;
      xpc_array_apply(v26, applier);

LABEL_37:
LABEL_38:
      os_unfair_lock_unlock(lock);

      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v49 = "nw_path_copy_interface_with_generation";
    __int16 v28 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v47 = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v28, &v47, &v46)) {
      goto LABEL_35;
    }
    if (v47 == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v29 = (id)gLogObj;
      os_log_type_t v30 = v47;
      if (os_log_type_enabled(v29, v47))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v49 = "nw_path_copy_interface_with_generation";
        _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s xpc_array_create failed", buf, 0xCu);
      }
    }
    else
    {
      if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v34 = v47;
        BOOL v35 = os_log_type_enabled(v33, v47);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v49 = "nw_path_copy_interface_with_generation";
            __int16 v50 = 2082;
            v51[0] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s xpc_array_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          os_log_type_t v21 = xdict;
          free(backtrace_string);
          if (!v28) {
            goto LABEL_37;
          }
          goto LABEL_36;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v49 = "nw_path_copy_interface_with_generation";
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s xpc_array_create failed, no backtrace", buf, 0xCu);
        }

        os_log_type_t v21 = xdict;
LABEL_35:
        if (!v28) {
          goto LABEL_37;
        }
LABEL_36:
        free(v28);
        goto LABEL_37;
      }
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v36 = v47;
      if (os_log_type_enabled(v29, v47))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v49 = "nw_path_copy_interface_with_generation";
        _os_log_impl(&dword_1830D4000, v29, v36, "%{public}s xpc_array_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_35;
  }
  uint64_t v7 = 0;
LABEL_39:

  return v7;
}

void sub_1830F242C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,void *a26)
{
  _Unwind_Resume(a1);
}

id nw_path_copy_dictionary_for_agent_with_generation(void *a1, const unsigned __int8 *a2, unsigned int a3, id *a4)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  int v53 = v7;
  uint64_t globals_for_path = nw_context_get_globals_for_path(v7);
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 124));
  if (*(void *)(globals_for_path + 64))
  {
    if (*(void *)(globals_for_path + 72)) {
      goto LABEL_6;
    }
  }
  else
  {
    xpc_object_t v9 = xpc_dictionary_create(0, 0, 0);
    xpc_object_t v10 = *(void **)(globals_for_path + 64);
    *(void *)(globals_for_path + 64) = v9;

    if (*(void *)(globals_for_path + 72)) {
      goto LABEL_6;
    }
  }
  xpc_object_t v11 = xpc_dictionary_create(0, 0, 0);
  id v12 = *(void **)(globals_for_path + 72);
  *(void *)(globals_for_path + 72) = v11;

LABEL_6:
  lock = (os_unfair_lock_s *)(globals_for_path + 124);
  if (!*(void *)(globals_for_path + 80))
  {
    uint64_t v13 = nw_dictionary_create();
    uint64_t v14 = *(void **)(globals_for_path + 80);
    *(void *)(globals_for_path + 80) = v13;
  }
  id v15 = *(id *)(globals_for_path + 64);
  xpc_object_t xdict = *(id *)(globals_for_path + 72);
  id v52 = *(id *)(globals_for_path + 80);
  uint64_t v16 = mach_continuous_time();
  if (v16 <= 1) {
    uint64_t v17 = 1;
  }
  else {
    uint64_t v17 = v16;
  }
  uint64_t value = v17;
  memset(out, 0, 37);
  uuid_unparse(a2, out);
  int v18 = xpc_dictionary_get_value(v15, out);
  uint64_t v19 = v18;
  if (a3 == -1 || !v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = (id)gLogObj;
    if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_20;
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
    __int16 v66 = 1042;
    *(_DWORD *)uint64_t v67 = 16;
    *(_WORD *)&v67[4] = 2098;
    *(void *)&v67[6] = a2;
    __int16 v23 = "%{public}s Agent for %{public,uuid_t}.16P cache miss";
    xpc_object_t v24 = v22;
    uint32_t v25 = 28;
LABEL_19:
    _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_DEBUG, v23, buf, v25);
LABEL_20:

    nw_path_shared_necp_fd(v7);
    xpc_object_t v26 = nw_network_agent_copy_dictionary_from_necp();
    if (!v26)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v31 = (id)gLogObj;
      if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
        __int16 v66 = 1042;
        *(_DWORD *)uint64_t v67 = 16;
        *(_WORD *)&v67[4] = 2098;
        *(void *)&v67[6] = a2;
        _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s Unable to lookup agent %{public,uuid_t}.16P dictionary from necp", buf, 0x1Cu);
      }
      id v27 = 0;
      goto LABEL_42;
    }
    id v27 = v26;
    os_log_type_t type = OS_LOG_TYPE_INFO;
    *(void *)buf = 0;
    data = (unsigned int *)xpc_dictionary_get_data(v26, "data", (size_t *)buf);
    if (!data || *(void *)buf < 0xD8uLL || (uint64_t v29 = data, v30 = data[53], *(void *)buf != v30 + 216))
    {
      __int16 v31 = 0;
      goto LABEL_33;
    }
    if (!strcmp((const char *)data + 16, "Network"))
    {
      __int16 v31 = 0;
      if (!strcmp((const char *)v29 + 48, "Proxy") && v30)
      {
        char v48 = nw_proxy_config_create_with_agent_data_extended((uint64_t)(v29 + 54), v30, v29, &type);
        __int16 v31 = v48;
        if (v48 && type)
        {
          nw_proxy_config_set_generation(v48, a3);
          nw_dictionary_set_value((uint64_t)v52, out, v31);
          uint64_t v29 = nw_network_agent_truncate_agent_data_in_dictionary(v27);
        }
        if (a4) {
          objc_storeStrong(a4, v31);
        }
        if (!v29) {
          goto LABEL_33;
        }
      }
    }
    else
    {
      __int16 v31 = 0;
    }
    if (!strcmp((const char *)v29 + 16, "Network")
      && !strcmp((const char *)v29 + 48, "Proxy")
      && v29[53]
      && type == OS_LOG_TYPE_DEFAULT)
    {
      char v32 = __nwlog_obj();
      if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
        __int16 v66 = 1042;
        *(_DWORD *)uint64_t v67 = 16;
        *(_WORD *)&v67[4] = 2098;
        *(void *)&v67[6] = a2;
        uint64_t v33 = "%{public}s Skipping saving agent %{public,uuid_t}.16P to the cache due to incomplete proxy config";
LABEL_35:
        _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, v33, buf, 0x1Cu);
        goto LABEL_36;
      }
      goto LABEL_36;
    }
LABEL_33:
    xpc_dictionary_set_uint64(v27, "generation", a3);
    xpc_dictionary_set_uint64(xdict, out, value);
    xpc_dictionary_set_value(v15, out, v27);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v32 = (id)gLogObj;
    if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
      __int16 v66 = 1042;
      *(_DWORD *)uint64_t v67 = 16;
      *(_WORD *)&v67[4] = 2098;
      *(void *)&v67[6] = a2;
      uint64_t v33 = "%{public}s Saved agent %{public,uuid_t}.16P to the cache";
      goto LABEL_35;
    }
LABEL_36:

    goto LABEL_42;
  }
  int uint64 = xpc_dictionary_get_uint64(v18, "generation");
  if (a3)
  {
    int v21 = uint64;
    if (uint64 != a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = (id)gLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
      __int16 v66 = 1042;
      *(_DWORD *)uint64_t v67 = 16;
      *(_WORD *)&v67[4] = 2098;
      *(void *)&v67[6] = a2;
      __int16 v68 = 1024;
      int v69 = v21;
      __int16 v70 = 1024;
      unsigned int v71 = a3;
      __int16 v23 = "%{public}s Agent for %{public,uuid_t}.16P has new generation (%u != %u)";
      xpc_object_t v24 = v22;
      uint32_t v25 = 40;
      goto LABEL_19;
    }
  }
  id v27 = v19;
  xpc_dictionary_set_uint64(xdict, out, value);
  if (!a4) {
    goto LABEL_43;
  }
  os_log_type_t v34 = nw_dictionary_copy_value((uint64_t)v52, (uint64_t)out);
  __int16 v31 = *a4;
  *a4 = v34;
LABEL_42:

LABEL_43:
  if (xpc_dictionary_get_count(v15) >= 0x21)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v35 = (id)gLogObj;
    if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
      __int16 v66 = 1024;
      *(_DWORD *)uint64_t v67 = 32;
      _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s Agent cache hit limit (%u), purging all agents not used recently", buf, 0x12u);
    }

    xpc_object_t v36 = xpc_array_create(0, 0);
    if (v36)
    {
      applier[0] = MEMORY[0x1E4F143A8];
      applier[1] = 3221225472;
      applier[2] = ___ZL49nw_path_copy_dictionary_for_agent_with_generationPU24objcproto13OS_nw_context8NSObjectPhjPU8__strongPU29objcproto18OS_nw_proxy_configS__block_invoke;
      applier[3] = &unk_1E5248528;
      id v37 = xdict;
      id v60 = v37;
      uint64_t v62 = value;
      id v38 = v36;
      id v61 = v38;
      xpc_dictionary_apply(v15, applier);
      v55[0] = MEMORY[0x1E4F143A8];
      v55[1] = 3221225472;
      v55[2] = ___ZL49nw_path_copy_dictionary_for_agent_with_generationPU24objcproto13OS_nw_context8NSObjectPhjPU8__strongPU29objcproto18OS_nw_proxy_configS__block_invoke_2;
      v55[3] = &unk_1E5248550;
      id v56 = v15;
      id v57 = v37;
      id v58 = v52;
      xpc_array_apply(v38, v55);

LABEL_55:
      goto LABEL_56;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v39 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
    id v40 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (!__nwlog_fault(v40, &type, &v63)) {
      goto LABEL_53;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v41 = (id)gLogObj;
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
        _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s xpc_array_create failed", buf, 0xCu);
      }
    }
    else
    {
      if (v63)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v45 = (id)gLogObj;
        os_log_type_t v46 = type;
        BOOL v47 = os_log_type_enabled(v45, type);
        if (backtrace_string)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
            __int16 v66 = 2082;
            *(void *)uint64_t v67 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s xpc_array_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v40) {
            goto LABEL_55;
          }
          goto LABEL_54;
        }
        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
          _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s xpc_array_create failed, no backtrace", buf, 0xCu);
        }

LABEL_53:
        if (!v40) {
          goto LABEL_55;
        }
LABEL_54:
        free(v40);
        goto LABEL_55;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v41 = (id)gLogObj;
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_path_copy_dictionary_for_agent_with_generation";
        _os_log_impl(&dword_1830D4000, v41, v49, "%{public}s xpc_array_create failed, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_53;
  }
LABEL_56:
  os_unfair_lock_unlock(lock);

  return v27;
}

void sub_1830F2F44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15, void *a16, void *a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,void *a23,void *a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,void *a30)
{
  _Unwind_Resume(a1);
}

void *nw_dictionary_copy_value(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy_value";
    BOOL v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      id v7 = "%{public}s called with null dictionary";
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_dictionary_copy_value";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_49:
        if (!v4) {
          return 0;
        }
LABEL_50:
        free(v4);
        return 0;
      }
      if (!v9) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      id v7 = "%{public}s called with null dictionary, no backtrace";
    }
    else
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      id v7 = "%{public}s called with null dictionary, backtrace limit exceeded";
    }
    goto LABEL_48;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy_value";
    BOOL v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14)) {
      goto LABEL_49;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v14)
      {
        BOOL v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_49;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_copy_value";
        id v7 = "%{public}s called with null key, backtrace limit exceeded";
        goto LABEL_48;
      }
      xpc_object_t v10 = (char *)__nw_create_backtrace_string();
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v11 = os_log_type_enabled(v5, type);
      if (!v10)
      {
        if (!v11) {
          goto LABEL_49;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_dictionary_copy_value";
        id v7 = "%{public}s called with null key, no backtrace";
        goto LABEL_48;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v17 = "nw_dictionary_copy_value";
        __int16 v18 = 2082;
        uint64_t v19 = v10;
        id v12 = "%{public}s called with null key, dumping backtrace:%{public}s";
LABEL_33:
        _os_log_impl(&dword_1830D4000, v5, v6, v12, buf, 0x16u);
      }
LABEL_34:
      free(v10);
      if (!v4) {
        return 0;
      }
      goto LABEL_50;
    }
    BOOL v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_49;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy_value";
    id v7 = "%{public}s called with null key";
LABEL_48:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    goto LABEL_49;
  }
  if (!*(void *)(a1 + 16))
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_dictionary_copy_value";
    BOOL v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v4, &type, &v14)) {
      goto LABEL_49;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      id v7 = "%{public}s called with null dictionary->xpc_object";
      goto LABEL_48;
    }
    if (!v14)
    {
      BOOL v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      id v7 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
      goto LABEL_48;
    }
    xpc_object_t v10 = (char *)__nw_create_backtrace_string();
    BOOL v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    BOOL v13 = os_log_type_enabled(v5, type);
    if (!v10)
    {
      if (!v13) {
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_dictionary_copy_value";
      id v7 = "%{public}s called with null dictionary->xpc_object, no backtrace";
      goto LABEL_48;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v17 = "nw_dictionary_copy_value";
      __int16 v18 = 2082;
      uint64_t v19 = v10;
      id v12 = "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s";
      goto LABEL_33;
    }
    goto LABEL_34;
  }
  pointer = (void *)xpc_dictionary_get_pointer();
  if (!pointer) {
    return 0;
  }

  return os_retain(pointer);
}

uint64_t nw_context_2k_buffer_manager(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    id v2 = v1;
    uint64_t v3 = nw_context_copy_globals_context(v1);

    uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 180);
    if (!v4)
    {
      *(void *)(*(void *)(v3 + 32) + 180) = nw_mem_buffer_manager_initialize(*(NSObject **)(v3 + 8), aNwcontextbuffe, dword_1E8F65118, (unsigned __int16)word_1E8F6511C);
      uint64_t v4 = *(void *)(*(void *)(v3 + 32) + 180);
    }
    goto LABEL_4;
  }
  os_log_type_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_context_2k_buffer_manager";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_context_2k_buffer_manager";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_context_2k_buffer_manager";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0;
  uint64_t v4 = 0;
LABEL_4:

  return v4;
}

void sub_1830F385C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_shared_necp_fd(void *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  uint64_t globals_for_path = nw_context_get_globals_for_path(v1);
  uint64_t v3 = (os_unfair_lock_s *)(globals_for_path + 120);
  os_unfair_lock_lock((os_unfair_lock_t)(globals_for_path + 120));
  if ((*(_DWORD *)(globals_for_path + 132) & 0x80000000) == 0) {
    goto LABEL_2;
  }
  int v6 = necp_open();
  if ((v6 & 0x80000000) == 0)
  {
    arc4random_buf((void *)(globals_for_path + 24), 8uLL);
    if (!change_fdguard_np())
    {
      *(unsigned char *)(globals_for_path + 140) |= 2u;
      *(_DWORD *)(globals_for_path + 132) = v6;
      goto LABEL_2;
    }
    int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    __int16 v23 = "nw_path_shared_necp_fd";
    __int16 v24 = 1024;
    int v25 = v6;
    __int16 v26 = 1024;
    int v27 = v7;
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v9, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446722;
          __int16 v23 = "nw_path_shared_necp_fd";
          __int16 v24 = 1024;
          int v25 = v6;
          __int16 v26 = 1024;
          int v27 = v7;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s Failed to guard necp fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }
      else if (v20)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          id v15 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v16 = (id)gLogObj;
          os_log_type_t v17 = type;
          if (os_log_type_enabled(v16, type))
          {
            *(_DWORD *)buf = 136446978;
            __int16 v23 = "nw_path_shared_necp_fd";
            __int16 v24 = 1024;
            int v25 = v6;
            __int16 v26 = 1024;
            int v27 = v7;
            __int16 v28 = 2082;
            uint64_t v29 = v15;
            _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Failed to guard necp fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(v15);
          if (!v9) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }
        xpc_object_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446722;
          __int16 v23 = "nw_path_shared_necp_fd";
          __int16 v24 = 1024;
          int v25 = v6;
          __int16 v26 = 1024;
          int v27 = v7;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s Failed to guard necp fd %d %{darwin.errno}d, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        xpc_object_t v10 = (id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446722;
          __int16 v23 = "nw_path_shared_necp_fd";
          __int16 v24 = 1024;
          int v25 = v6;
          __int16 v26 = 1024;
          int v27 = v7;
          _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s Failed to guard necp fd %d %{darwin.errno}d, backtrace limit exceeded", buf, 0x18u);
        }
      }
    }
    if (!v9)
    {
LABEL_12:
      close(v6);
      goto LABEL_2;
    }
LABEL_11:
    free(v9);
    goto LABEL_12;
  }
  int v12 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v13 = (id)gLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    __int16 v23 = "nw_path_shared_necp_fd";
    __int16 v24 = 1024;
    int v25 = v12;
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_ERROR, "%{public}s necp_open failed %{darwin.errno}d", buf, 0x12u);
  }

LABEL_2:
  uint64_t v4 = *(unsigned int *)(globals_for_path + 132);
  os_unfair_lock_unlock(v3);

  return v4;
}

void sub_1830F3D44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_get_globals_for_path(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = &__block_literal_global_413;
  if (!v1)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_context_get_globals_for_path";
    xpc_object_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_context_get_globals_for_path";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v22 = "nw_context_get_globals_for_path";
            __int16 v23 = 2082;
            uint64_t v24 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_context_get_globals_for_path";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v22 = "nw_context_get_globals_for_path";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_25:
    if (v10) {
      free(v10);
    }
    uint64_t v5 = 0;
    goto LABEL_6;
  }
  BOOL v3 = nw_context_copy_globals_context(v1);

  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(v3 + 32) + 44));
  uint64_t v4 = *(void *)(v3 + 32);
  uint64_t v5 = *(void *)(v4 + 68);
  if (v5)
  {
LABEL_5:
    os_unfair_lock_unlock((os_unfair_lock_t)(v4 + 44));

LABEL_6:
    return v5;
  }
  int v6 = malloc_type_calloc(1uLL, 0x98uLL, 0xEAFB8F1AuLL);
  if (v6)
  {
LABEL_4:
    *(void *)(*(void *)(v3 + 32) + 68) = v6;
    uint64_t v7 = *(void *)(*(void *)(v3 + 32) + 68);
    *(_OWORD *)(v7 + 112) = 0u;
    *(_OWORD *)(v7 + 128) = 0u;
    *(void *)(v7 + 144) = 0;
    *(_OWORD *)(v7 + 80) = 0u;
    *(_OWORD *)(v7 + 96) = 0u;
    *(_OWORD *)(v7 + 48) = 0u;
    *(_OWORD *)(v7 + 64) = 0u;
    *(_OWORD *)(v7 + 16) = 0u;
    *(_OWORD *)(v7 + 32) = 0u;
    *(_OWORD *)uint64_t v7 = 0u;
    *(void *)(v7 + 132) = -1;
    uint64_t v4 = *(void *)(v3 + 32);
    uint64_t v5 = *(void *)(v4 + 68);
    goto LABEL_5;
  }
  uint64_t v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v22 = "strict_calloc";
  __int16 v23 = 2048;
  uint64_t v24 = 1;
  __int16 v25 = 2048;
  uint64_t v26 = 152;
  os_log_type_t v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

void sub_1830F4140(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_copy_globals_context(NWConcrete_nw_context *a1)
{
  id v1 = a1;
  id v2 = v1;
  if ((*((unsigned char *)v1 + 136) & 5) != 0)
  {
    BOOL v3 = (NWConcrete_nw_context *)*((void *)v1 + 5);
    if (!v3) {
      BOOL v3 = v1;
    }
  }
  else
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    BOOL v3 = (NWConcrete_nw_context *)nw_context_copy_implicit_context::implicit_context;
  }
  uint64_t v4 = v3;
  if (*((void *)v4 + 4)) {
    goto LABEL_11;
  }
  uint64_t v5 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v5);
  int v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  uint64_t v7 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
LABEL_11:

    return (BOOL)v4;
  }
  __break(1u);
  return result;
}

size_t nw_dictionary_get_count(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v14 = "nw_dictionary_get_count";
    BOOL v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_dictionary_get_count";
      int v6 = "%{public}s called with null dictionary";
      goto LABEL_33;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_dictionary_get_count";
      int v6 = "%{public}s called with null dictionary, backtrace limit exceeded";
      goto LABEL_33;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (!v8) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_dictionary_get_count";
      int v6 = "%{public}s called with null dictionary, no backtrace";
      goto LABEL_33;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v14 = "nw_dictionary_get_count";
      __int16 v15 = 2082;
      uint64_t v16 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_34:
    if (!v3) {
      return 0;
    }
LABEL_35:
    free(v3);
    return 0;
  }
  id v1 = *(void **)(a1 + 16);
  if (!v1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v14 = "nw_dictionary_get_count";
    BOOL v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_dictionary_get_count";
      int v6 = "%{public}s called with null dictionary->xpc_object";
      goto LABEL_33;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_dictionary_get_count";
      int v6 = "%{public}s called with null dictionary->xpc_object, backtrace limit exceeded";
      goto LABEL_33;
    }
    os_log_type_t v9 = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (v9)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v14 = "nw_dictionary_get_count";
        __int16 v15 = 2082;
        uint64_t v16 = v9;
        _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null dictionary->xpc_object, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v9);
      if (!v3) {
        return 0;
      }
      goto LABEL_35;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v14 = "nw_dictionary_get_count";
      int v6 = "%{public}s called with null dictionary->xpc_object, no backtrace";
LABEL_33:
      _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      goto LABEL_34;
    }
    goto LABEL_34;
  }

  return xpc_dictionary_get_count(v1);
}

BOOL nw_context_get_logging_disabled(BOOL result)
{
  if (result) {
    return *(_DWORD *)(result + 124) == 4;
  }
  return result;
}

void nw_protocol_connected(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }
    if (a2)
    {
      int v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 88) = v7 + 1;
        }
      }
      uint64_t v8 = a1[3];
      if (v8)
      {
        os_log_type_t v9 = *(void (**)(void *, uint64_t))(v8 + 40);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }
      __nwlog_obj();
      os_log_type_t v18 = *(const char **)(v3 + 16);
      *(_DWORD *)buf = 136446722;
      os_log_type_t v42 = "__nw_protocol_connected";
      if (!v18) {
        os_log_type_t v18 = "invalid";
      }
      __int16 v43 = 2082;
      id v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      char v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v20 = __nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          uint64_t v22 = *(const char **)(v3 + 16);
          if (!v22) {
            uint64_t v22 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          __int16 v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
          goto LABEL_76;
        }
        if (!v39)
        {
          char v20 = __nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          id v37 = *(const char **)(v3 + 16);
          if (!v37) {
            id v37 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          __int16 v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
          goto LABEL_76;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            char v32 = *(const char **)(v3 + 16);
            if (!v32) {
              char v32 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v42 = "__nw_protocol_connected";
            __int16 v43 = 2082;
            id v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            char v48 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_77;
        }
        if (v31)
        {
          id v38 = *(const char **)(v3 + 16);
          if (!v38) {
            id v38 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          __int16 v23 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_1830D4000, v20, v21, v23, buf, 0x20u);
        }
      }
LABEL_77:
      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = *(void *)(v2 + 88);
        if (v14)
        {
          uint64_t v15 = v14 - 1;
          *(void *)(v2 + 88) = v15;
          if (!v15)
          {
            uint64_t v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0;
              v16[2](v16);
              _Block_release(v16);
            }
            if (*(unsigned char *)(v2 + 72))
            {
              uint64_t v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }
LABEL_32:
            free((void *)v2);
          }
        }
      }
LABEL_14:
      if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = *(void *)(v3 + 88);
        if (v10)
        {
          uint64_t v11 = v10 - 1;
          *(void *)(v3 + 88) = v11;
          if (!v11)
          {
            os_log_type_t v12 = *(void (***)(void))(v3 + 64);
            if (v12)
            {
              *(void *)(v3 + 64) = 0;
              v12[2](v12);
              _Block_release(v12);
            }
            if (*(unsigned char *)(v3 + 72))
            {
              os_log_type_t v13 = *(const void **)(v3 + 64);
              if (v13) {
                _Block_release(v13);
              }
            }
            goto LABEL_24;
          }
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v42 = "__nw_protocol_connected";
    uint64_t v2 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault((const char *)v2, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_91;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "__nw_protocol_connected";
        uint64_t v29 = "%{public}s called with null other_protocol";
        goto LABEL_90;
      }
      if (!v39)
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_91;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "__nw_protocol_connected";
        uint64_t v29 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_90;
      }
      BOOL v35 = (char *)__nw_create_backtrace_string();
      uint64_t v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v36 = os_log_type_enabled(v27, type);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = v35;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v35);
        if (v2) {
          goto LABEL_32;
        }
        goto LABEL_14;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v42 = "__nw_protocol_connected";
        uint64_t v29 = "%{public}s called with null other_protocol, no backtrace";
LABEL_90:
        _os_log_impl(&dword_1830D4000, v27, v28, v29, buf, 0xCu);
      }
    }
LABEL_91:
    if (!v2) {
      goto LABEL_14;
    }
    goto LABEL_32;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v42 = "__nw_protocol_connected";
  uint64_t v3 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v39 = 0;
  if (__nwlog_fault((const char *)v3, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v42 = "__nw_protocol_connected";
      uint64_t v26 = "%{public}s called with null protocol";
    }
    else if (v39)
    {
      uint64_t v33 = (char *)__nw_create_backtrace_string();
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v34 = os_log_type_enabled(v24, type);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v42 = "__nw_protocol_connected";
          __int16 v43 = 2082;
          id v44 = v33;
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v33);
        if (v3) {
          goto LABEL_24;
        }
        return;
      }
      if (!v34) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v42 = "__nw_protocol_connected";
      uint64_t v26 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v42 = "__nw_protocol_connected";
      uint64_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
  }
LABEL_86:
  if (v3) {
LABEL_24:
  }
    free((void *)v3);
}

void nw_flow_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v3 = a1;
  uint64_t v250 = *MEMORY[0x1E4F143B8];
  handle = (id *)a1->handle;
  id v5 = handle[20];
  if (v5)
  {
    id v221 = v5;
    int v6 = (NWConcrete_nw_endpoint_handler *)v5;
    uint64_t mode = v6->mode;

    if (mode != 2)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v27 = (id)gLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5) {
          os_log_type_t v28 = "unknown-mode";
        }
        else {
          os_log_type_t v28 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        v232 = "nw_flow_connected";
        __int16 v233 = 2082;
        v234 = (void *)v28;
        __int16 v235 = 2082;
        v236 = "flow";
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }

      goto LABEL_118;
    }
    v220 = nw_endpoint_handler_copy_flow(v6);
    if ((*((_WORD *)handle + 166) & 0x200) != 0)
    {
      uint64_t v29 = v6;
      char v30 = *((unsigned char *)v29 + 268);

      BOOL v31 = v220;
      if ((v30 & 0x20) != 0)
      {
LABEL_117:

LABEL_118:
        char v119 = v221;
        goto LABEL_119;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v32 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v32, OS_LOG_TYPE_ERROR))
      {
        uint64_t v33 = v29;

        BOOL v34 = v33;
        char v35 = *((unsigned char *)v29 + 268);

        if (v35) {
          BOOL v36 = "dry-run ";
        }
        else {
          BOOL v36 = "";
        }
        nw_endpoint_t v37 = nw_endpoint_handler_copy_endpoint(v34);
        logging_description = nw_endpoint_get_logging_description(v37);
        id_str = v33->id_str;
        id v40 = v34;
        id v41 = v40;
        uint64_t v42 = v40[30];
        if (v42 > 5) {
          __int16 v43 = "unknown-state";
        }
        else {
          __int16 v43 = off_1E523FB38[v42];
        }

        id v57 = v41;
        id v58 = v57;
        int v59 = v6->mode;
        id v60 = "path";
        switch(v59)
        {
          case 0:
            break;
          case 1:
            id v60 = "resolver";
            break;
          case 2:
            id v60 = nw_endpoint_flow_mode_string(v57[31]);
            break;
          case 3:
            id v60 = "proxy";
            break;
          case 4:
            id v60 = "fallback";
            break;
          case 5:
            id v60 = "transform";
            break;
          default:
            id v60 = "unknown-mode";
            break;
        }

        v78 = v58;
        os_unfair_lock_lock((os_unfair_lock_t)v78 + 28);
        id v79 = v78[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v78 + 28);

        *(_DWORD *)buf = 136447746;
        v232 = "nw_flow_connected";
        __int16 v233 = 2082;
        v234 = id_str;
        __int16 v235 = 2082;
        v236 = v36;
        __int16 v237 = 2082;
        v238 = (void *)logging_description;
        __int16 v239 = 2082;
        v240 = v43;
        __int16 v241 = 2082;
        v242 = v60;
        __int16 v243 = 2114;
        id v244 = v79;
        _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow was disconnected, skipping connected", buf, 0x48u);
      }
LABEL_116:
      BOOL v31 = v220;
      goto LABEL_117;
    }
    memset(__str, 0, sizeof(__str));
    if (a2 && a2->identifier) {
      snprintf(__str, 0x23uLL, " (%s)", a2->identifier->name);
    }
    char v218 = a2;
    if ((id *)((char *)v220 + 376) != handle) {
      goto LABEL_8;
    }
    if (v3->output_handler != a2)
    {
      if (*((nw_protocol **)v220 + 90) == a2)
      {
        v75 = "Transport";
      }
      else
      {
        if (*((nw_protocol **)v220 + 92) != a2)
        {
          if (*((nw_protocol **)v220 + 93) != a2) {
            goto LABEL_8;
          }
          v215 = v3;
          if (a2)
          {
            callbacks = a2->callbacks;
            if (callbacks)
            {
              waiting_for_output = (unsigned int (*)(nw_protocol *, nw_protocol *))callbacks->waiting_for_output;
              if (waiting_for_output)
              {
                if (waiting_for_output(a2, v3))
                {
                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v6);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v6);
                  if (minimize_logging)
                  {
                    a2 = v218;
                    if (logging_disabled) {
                      goto LABEL_8;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    id v52 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v6);
                      v188 = nw_endpoint_handler_dry_run_string(v6);
                      nw_endpoint_t v189 = nw_endpoint_handler_copy_endpoint(v6);
                      BOOL v190 = nw_endpoint_get_logging_description(v189);
                      v191 = nw_endpoint_handler_state_string(v6);
                      v192 = nw_endpoint_handler_mode_string(v6);
                      id v193 = nw_endpoint_handler_copy_current_path(v6);
                      *(_DWORD *)buf = 136448002;
                      v232 = "nw_flow_connected";
                      __int16 v233 = 2082;
                      v234 = (void *)id_string;
                      __int16 v235 = 2082;
                      v236 = v188;
                      __int16 v237 = 2082;
                      v238 = (void *)v190;
                      __int16 v239 = 2082;
                      v240 = v191;
                      __int16 v241 = 2082;
                      v242 = v192;
                      __int16 v243 = 2114;
                      id v244 = v193;
                      __int16 v245 = 2082;
                      v246 = __str;
                      _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol%{public}s waiting for output, ignore", buf, 0x52u);
                    }
LABEL_48:
                    char v48 = v52;
LABEL_96:

                    uint64_t v3 = v215;
                    a2 = v218;
                    goto LABEL_8;
                  }
                  a2 = v218;
                  if ((logging_disabled & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    char v48 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v48, OS_LOG_TYPE_INFO)) {
                      goto LABEL_96;
                    }
                    uint64_t v49 = nw_endpoint_handler_get_id_string(v6);
                    __int16 v50 = nw_endpoint_handler_dry_run_string(v6);
                    nw_endpoint_t v51 = nw_endpoint_handler_copy_endpoint(v6);
                    id v52 = v48;
                    int v53 = nw_endpoint_get_logging_description(v51);
                    uint64_t v54 = nw_endpoint_handler_state_string(v6);
                    uint64_t v55 = nw_endpoint_handler_mode_string(v6);
                    id v56 = nw_endpoint_handler_copy_current_path(v6);
                    *(_DWORD *)buf = 136448002;
                    v232 = "nw_flow_connected";
                    __int16 v233 = 2082;
                    v234 = (void *)v49;
                    __int16 v235 = 2082;
                    v236 = v50;
                    __int16 v237 = 2082;
                    v238 = (void *)v53;
                    __int16 v239 = 2082;
                    v240 = v54;
                    __int16 v241 = 2082;
                    v242 = v55;
                    __int16 v243 = 2114;
                    id v244 = v56;
                    __int16 v245 = 2082;
                    v246 = __str;
                    _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol%{public}s waiting for output, ignore", buf, 0x52u);

                    goto LABEL_48;
                  }
LABEL_8:
                  __int16 v8 = *((_WORD *)handle + 166);
                  if ((v8 & 0x400) != 0)
                  {
                    __int16 v9 = v8 & 0xFBFF;
                    *((_WORD *)handle + 166) = v8 & 0xFBFF;
                    uint64_t v10 = (void *)*((void *)v220 + 89);
                    if (v10)
                    {
                      v214 = v3;
                      id v11 = v10;
                      BOOL v12 = nw_read_request_list_remove_head(*((void **)v220 + 89));
                      os_log_type_t v13 = (void *)*((void *)v220 + 89);
                      *((void *)v220 + 89) = v12;

                      uint64_t v14 = v6;
                      BOOL v15 = (*((unsigned char *)v14 + 268) & 0x20) == 0;

                      if (v15)
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        uint64_t v16 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v16, OS_LOG_TYPE_DEBUG))
                        {
                          uint64_t v17 = v14;

                          os_log_type_t v18 = v17;
                          BOOL v19 = (*((unsigned char *)v14 + 268) & 1) == 0;

                          if (v19) {
                            char v20 = "";
                          }
                          else {
                            char v20 = "dry-run ";
                          }
                          nw_endpoint_t v21 = nw_endpoint_handler_copy_endpoint(v18);
                          uint64_t v22 = nw_endpoint_get_logging_description(v21);
                          __int16 v23 = v18;
                          uint64_t v24 = v23;
                          uint64_t v25 = v23[30];
                          os_log_t log = (os_log_t)v22;
                          if (v25 > 5) {
                            uint64_t v26 = "unknown-state";
                          }
                          else {
                            uint64_t v26 = off_1E523FB38[v25];
                          }
                          v201 = v26;

                          v76 = v24;
                          char v77 = "path";
                          switch(v6->mode)
                          {
                            case 0:
                              break;
                            case 1:
                              char v77 = "resolver";
                              break;
                            case 2:
                              char v77 = nw_endpoint_flow_mode_string(v76[31]);
                              break;
                            case 3:
                              char v77 = "proxy";
                              break;
                            case 4:
                              char v77 = "fallback";
                              break;
                            case 5:
                              char v77 = "transform";
                              break;
                            default:
                              char v77 = "unknown-mode";
                              break;
                          }
                          os_log_type_t v200 = v77;

                          uint64_t v112 = v17;
                          id v113 = v11;
                          nw_endpoint_t v114 = v21;
                          uint64_t v115 = v76;
                          os_unfair_lock_lock((os_unfair_lock_t)v115 + 28);
                          id v116 = v115[8];
                          os_unfair_lock_unlock((os_unfair_lock_t)v115 + 28);

                          nw_endpoint_t v117 = v114;
                          id v11 = v113;
                          *(_DWORD *)buf = 136448258;
                          v232 = "nw_flow_connected";
                          __int16 v233 = 2082;
                          v234 = v112->id_str;
                          __int16 v235 = 2082;
                          v236 = v20;
                          __int16 v237 = 2082;
                          v238 = log;
                          __int16 v239 = 2082;
                          v240 = v201;
                          __int16 v241 = 2082;
                          v242 = v200;
                          __int16 v243 = 2114;
                          id v244 = v116;
                          __int16 v245 = 2112;
                          v246 = v113;
                          __int16 v247 = 2048;
                          v248 = handle;
                          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Adding new flow read request %@ to %p", buf, 0x5Cu);
                        }
                      }
                      nw_flow_add_read_request(v14, (uint64_t)handle, v11);

                      uint64_t v3 = v214;
                      a2 = v218;
                    }
                    else
                    {
                      *((_WORD *)handle + 166) = v9 | 0x20;
                      a2 = v218;
                    }
                  }
                  default_input_handler = v3->default_input_handler;
                  if (default_input_handler)
                  {
                    nw_protocol_connected(default_input_handler, (uint64_t)a2);
                    if (v3->output_handler == a2) {
                      nw_protocol_connected(v3->default_input_handler->flow_id, (uint64_t)v3);
                    }
                  }
                  goto LABEL_116;
                }
              }
            }
          }
          int v120 = nw_endpoint_handler_get_minimize_logging(v6);
          char v121 = nw_endpoint_handler_get_logging_disabled(v6);
          if (v120)
          {
            if (v121) {
              goto LABEL_127;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v122 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEBUG))
            {
              v181 = nw_endpoint_handler_get_id_string(v6);
              logi = nw_endpoint_handler_dry_run_string(v6);
              nw_endpoint_t v182 = nw_endpoint_handler_copy_endpoint(v6);
              v183 = nw_endpoint_get_logging_description(v182);
              BOOL v184 = nw_endpoint_handler_state_string(v6);
              v185 = nw_endpoint_handler_mode_string(v6);
              id v186 = nw_endpoint_handler_copy_current_path(v6);
              *(_DWORD *)buf = 136448002;
              v232 = "nw_flow_connected";
              __int16 v233 = 2082;
              v234 = (void *)v181;
              __int16 v235 = 2082;
              v236 = logi;
              __int16 v237 = 2082;
              v238 = (void *)v183;
              __int16 v239 = 2082;
              v240 = v184;
              __int16 v241 = 2082;
              v242 = v185;
              __int16 v243 = 2114;
              id v244 = v186;
              __int16 v245 = 2082;
              v246 = __str;
              _os_log_impl(&dword_1830D4000, v122, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol connected%{public}s", buf, 0x52u);
            }
          }
          else
          {
            if (v121)
            {
LABEL_127:
              v6->event = (nw_endpoint_handler_event_s)917507;
              nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
              char v48 = nw_flow_get_remote(v3);
              if (!v48) {
                goto LABEL_96;
              }
              id v132 = handle[22];
              if (!v132 || !handle[23] || !nw_parameters_get_block_trackers(v132)) {
                goto LABEL_96;
              }
              v133 = v48;
              v134 = (atomic_uchar *)nw_endpoint_copy_cname_array(v48);
              BOOL v135 = v134;
              if (v134 && *((void *)v134 + 3) != *((void *)v134 + 2))
              {
                uint64_t v227 = 0;
                v228 = &v227;
                uint64_t v229 = 0x2020000000;
                char v230 = 0;
                v136 = nw_context_copy_tracker_lookup_callback(handle[23]);
                if (v136)
                {
                  v224[0] = MEMORY[0x1E4F143A8];
                  v224[1] = 3221225472;
                  v224[2] = ___ZL17nw_flow_connectedP11nw_protocolS0__block_invoke;
                  v224[3] = &unk_1E523D408;
                  os_log_type_t v137 = v136;
                  id v225 = v136;
                  v226 = &v227;
                  nw_array_apply(v135, (uint64_t)v224);

                  v136 = v137;
                }
                if (*((unsigned char *)v228 + 24))
                {
                  os_log_type_t v219 = v136;
                  int v138 = nw_endpoint_handler_get_minimize_logging(v6);
                  char v139 = nw_endpoint_handler_get_logging_disabled(v6);
                  if (v138)
                  {
                    if (v139) {
                      goto LABEL_144;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    v217 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v217, OS_LOG_TYPE_DEBUG))
                    {
                      v194 = nw_endpoint_handler_get_id_string(v6);
                      logj = nw_endpoint_handler_dry_run_string(v6);
                      nw_endpoint_t v195 = nw_endpoint_handler_copy_endpoint(v6);
                      BOOL v196 = nw_endpoint_get_logging_description(v195);
                      os_log_type_t v197 = nw_endpoint_handler_state_string(v6);
                      os_log_type_t v198 = nw_endpoint_handler_mode_string(v6);
                      id v199 = nw_endpoint_handler_copy_current_path(v6);
                      *(_DWORD *)buf = 136447746;
                      v232 = "nw_flow_connected";
                      __int16 v233 = 2082;
                      v234 = (void *)v194;
                      __int16 v235 = 2082;
                      v236 = logj;
                      __int16 v237 = 2082;
                      v238 = (void *)v196;
                      __int16 v239 = 2082;
                      v240 = v197;
                      __int16 v241 = 2082;
                      v242 = v198;
                      __int16 v243 = 2114;
                      id v244 = v199;
                      _os_log_impl(&dword_1830D4000, v217, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol detected tracker to block", buf, 0x48u);
                    }
                  }
                  else
                  {
                    if (v139)
                    {
LABEL_144:
                      id v147 = handle[23];
                      v222[0] = MEMORY[0x1E4F143A8];
                      v222[1] = 3221225472;
                      v222[2] = ___ZL17nw_flow_connectedP11nw_protocolS0__block_invoke_101;
                      v222[3] = &unk_1E524BAA8;
                      unint64_t v223 = v6;
                      nw_queue_context_async(v147, v222);

                      _Block_object_dispose(&v227, 8);
                      goto LABEL_116;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    v140 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v140, OS_LOG_TYPE_DEFAULT))
                    {
LABEL_143:

                      goto LABEL_144;
                    }
                    v217 = v140;
                    loge = nw_endpoint_handler_get_id_string(v6);
                    v141 = nw_endpoint_handler_dry_run_string(v6);
                    nw_endpoint_t v142 = nw_endpoint_handler_copy_endpoint(v6);
                    v143 = nw_endpoint_get_logging_description(v142);
                    v144 = nw_endpoint_handler_state_string(v6);
                    v145 = nw_endpoint_handler_mode_string(v6);
                    id v146 = nw_endpoint_handler_copy_current_path(v6);
                    *(_DWORD *)buf = 136447746;
                    v232 = "nw_flow_connected";
                    __int16 v233 = 2082;
                    v234 = (void *)loge;
                    __int16 v235 = 2082;
                    v236 = v141;
                    __int16 v237 = 2082;
                    v238 = (void *)v143;
                    __int16 v239 = 2082;
                    v240 = v144;
                    __int16 v241 = 2082;
                    v242 = v145;
                    __int16 v243 = 2114;
                    id v244 = v146;
                    _os_log_impl(&dword_1830D4000, v217, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol detected tracker to block", buf, 0x48u);
                  }
                  v140 = v217;
                  goto LABEL_143;
                }

                _Block_object_dispose(&v227, 8);
              }

              goto LABEL_96;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            v122 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v122, OS_LOG_TYPE_DEFAULT))
            {
              char v123 = nw_endpoint_handler_get_id_string(v6);
              int v124 = nw_endpoint_handler_dry_run_string(v6);
              nw_endpoint_t v125 = nw_endpoint_handler_copy_endpoint(v6);
              os_log_type_t v126 = v122;
              uint64_t v127 = v124;
              os_log_type_t v128 = nw_endpoint_get_logging_description(v125);
              v129 = nw_endpoint_handler_state_string(v6);
              uint64_t v130 = nw_endpoint_handler_mode_string(v6);
              id v131 = nw_endpoint_handler_copy_current_path(v6);
              *(_DWORD *)buf = 136448002;
              v232 = "nw_flow_connected";
              __int16 v233 = 2082;
              v234 = (void *)v123;
              __int16 v235 = 2082;
              v236 = v127;
              __int16 v237 = 2082;
              v238 = (void *)v128;
              __int16 v239 = 2082;
              v240 = v129;
              __int16 v241 = 2082;
              v242 = v130;
              __int16 v243 = 2114;
              id v244 = v131;
              __int16 v245 = 2082;
              v246 = __str;
              _os_log_impl(&dword_1830D4000, v126, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Proxy protocol connected%{public}s", buf, 0x52u);

              v122 = v126;
            }
          }

          uint64_t v3 = v215;
          goto LABEL_127;
        }
        v75 = "Joined";
      }
      v215 = v3;
      if (a2)
      {
        v90 = a2->callbacks;
        if (v90)
        {
          id v91 = (unsigned int (*)(nw_protocol *, nw_protocol *))v90->waiting_for_output;
          if (v91)
          {
            if (v91(a2, v3))
            {
              int v92 = nw_endpoint_handler_get_minimize_logging(v6);
              char v93 = nw_endpoint_handler_get_logging_disabled(v6);
              if (v92)
              {
                a2 = v218;
                if (v93) {
                  goto LABEL_8;
                }
                os_log_t loga = (os_log_t)v75;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                v161 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v161, OS_LOG_TYPE_DEBUG))
                {
                  BOOL v162 = nw_endpoint_handler_get_id_string(v6);
                  v163 = nw_endpoint_handler_dry_run_string(v6);
                  nw_endpoint_t v164 = nw_endpoint_handler_copy_endpoint(v6);
                  v165 = nw_endpoint_get_logging_description(v164);
                  v166 = nw_endpoint_handler_state_string(v6);
                  os_log_type_t v167 = nw_endpoint_handler_mode_string(v6);
                  id v168 = nw_endpoint_handler_copy_current_path(v6);
                  *(_DWORD *)buf = 136448258;
                  v232 = "nw_flow_connected";
                  __int16 v233 = 2082;
                  v234 = (void *)v162;
                  __int16 v235 = 2082;
                  v236 = v163;
                  __int16 v237 = 2082;
                  v238 = (void *)v165;
                  __int16 v239 = 2082;
                  v240 = v166;
                  __int16 v241 = 2082;
                  v242 = v167;
                  __int16 v243 = 2114;
                  id v244 = v168;
                  __int16 v245 = 2082;
                  v246 = loga;
                  __int16 v247 = 2082;
                  v248 = (id *)__str;
                  _os_log_impl(&dword_1830D4000, v161, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol%{public}s waiting for output, ignore", buf, 0x5Cu);
                }
                char v48 = v161;
                goto LABEL_96;
              }
              a2 = v218;
              if ((v93 & 1) == 0)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                char v48 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v48, OS_LOG_TYPE_INFO))
                {
                  os_log_type_t v94 = nw_endpoint_handler_get_id_string(v6);
                  v95 = nw_endpoint_handler_dry_run_string(v6);
                  os_log_t logc = v48;
                  nw_endpoint_t v96 = nw_endpoint_handler_copy_endpoint(v6);
                  v97 = nw_endpoint_get_logging_description(v96);
                  BOOL v98 = nw_endpoint_handler_state_string(v6);
                  v99 = nw_endpoint_handler_mode_string(v6);
                  id v100 = nw_endpoint_handler_copy_current_path(v6);
                  *(_DWORD *)buf = 136448258;
                  v232 = "nw_flow_connected";
                  __int16 v233 = 2082;
                  v234 = (void *)v94;
                  __int16 v235 = 2082;
                  v236 = v95;
                  __int16 v237 = 2082;
                  v238 = (void *)v97;
                  __int16 v239 = 2082;
                  v240 = v98;
                  __int16 v241 = 2082;
                  v242 = v99;
                  __int16 v243 = 2114;
                  id v244 = v100;
                  __int16 v245 = 2082;
                  v246 = v75;
                  __int16 v247 = 2082;
                  v248 = (id *)__str;
                  _os_log_impl(&dword_1830D4000, logc, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol%{public}s waiting for output, ignore", buf, 0x5Cu);

                  char v48 = logc;
                }
                goto LABEL_96;
              }
              goto LABEL_8;
            }
          }
        }
      }
      int v101 = nw_endpoint_handler_get_minimize_logging(v6);
      char v102 = nw_endpoint_handler_get_logging_disabled(v6);
      if (v101)
      {
        if (v102) {
          goto LABEL_104;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v103 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEBUG))
        {
          logf = nw_endpoint_handler_get_id_string(v6);
          os_log_type_t v202 = nw_endpoint_handler_dry_run_string(v6);
          nw_endpoint_t v156 = nw_endpoint_handler_copy_endpoint(v6);
          v157 = nw_endpoint_get_logging_description(v156);
          BOOL v158 = nw_endpoint_handler_state_string(v6);
          v159 = nw_endpoint_handler_mode_string(v6);
          id v160 = nw_endpoint_handler_copy_current_path(v6);
          *(_DWORD *)buf = 136448258;
          v232 = "nw_flow_connected";
          __int16 v233 = 2082;
          v234 = (void *)logf;
          __int16 v235 = 2082;
          v236 = v202;
          __int16 v237 = 2082;
          v238 = (void *)v157;
          __int16 v239 = 2082;
          v240 = v158;
          __int16 v241 = 2082;
          v242 = v159;
          __int16 v243 = 2114;
          id v244 = v160;
          __int16 v245 = 2082;
          v246 = v75;
          __int16 v247 = 2082;
          v248 = (id *)__str;
          _os_log_impl(&dword_1830D4000, v103, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol connected%{public}s", buf, 0x5Cu);
        }
      }
      else
      {
        if (v102)
        {
LABEL_104:
          v6->event = (nw_endpoint_handler_event_s)327683;
          nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
          a2 = v218;
          goto LABEL_8;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v103 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v103, OS_LOG_TYPE_DEFAULT))
        {
          logd = v103;
          v104 = nw_endpoint_handler_get_id_string(v6);
          BOOL v105 = nw_endpoint_handler_dry_run_string(v6);
          nw_endpoint_t v106 = nw_endpoint_handler_copy_endpoint(v6);
          v107 = v104;
          os_log_type_t v108 = nw_endpoint_get_logging_description(v106);
          v109 = nw_endpoint_handler_state_string(v6);
          os_log_type_t v110 = nw_endpoint_handler_mode_string(v6);
          id v111 = nw_endpoint_handler_copy_current_path(v6);
          *(_DWORD *)buf = 136448258;
          v232 = "nw_flow_connected";
          __int16 v233 = 2082;
          v234 = (void *)v107;
          __int16 v235 = 2082;
          v236 = v105;
          __int16 v237 = 2082;
          v238 = (void *)v108;
          __int16 v239 = 2082;
          v240 = v109;
          __int16 v241 = 2082;
          v242 = v110;
          __int16 v243 = 2114;
          id v244 = v111;
          __int16 v245 = 2082;
          v246 = v75;
          __int16 v247 = 2082;
          v248 = (id *)__str;
          _os_log_impl(&dword_1830D4000, logd, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %{public}s protocol connected%{public}s", buf, 0x5Cu);

          v103 = logd;
        }
      }

      uint64_t v3 = v215;
      goto LABEL_104;
    }
    if (a2)
    {
      id v61 = a2->callbacks;
      if (v61)
      {
        uint64_t v62 = (unsigned int (*)(nw_protocol *, nw_protocol *))v61->waiting_for_output;
        if (v62)
        {
          if (v62(a2, v3))
          {
            int v63 = nw_endpoint_handler_get_minimize_logging(v6);
            char v64 = nw_endpoint_handler_get_logging_disabled(v6);
            unsigned int v216 = v3;
            if (v63)
            {
              if (v64) {
                goto LABEL_64;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v65 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_DEBUG))
              {
                v175 = nw_endpoint_handler_get_id_string(v6);
                logh = nw_endpoint_handler_dry_run_string(v6);
                nw_endpoint_t v176 = nw_endpoint_handler_copy_endpoint(v6);
                os_log_type_t v177 = nw_endpoint_get_logging_description(v176);
                v178 = nw_endpoint_handler_state_string(v6);
                v179 = nw_endpoint_handler_mode_string(v6);
                id v180 = nw_endpoint_handler_copy_current_path(v6);
                *(_DWORD *)buf = 136447746;
                v232 = "nw_flow_connected";
                __int16 v233 = 2082;
                v234 = (void *)v175;
                __int16 v235 = 2082;
                v236 = logh;
                __int16 v237 = 2082;
                v238 = (void *)v177;
                __int16 v239 = 2082;
                v240 = v178;
                __int16 v241 = 2082;
                v242 = v179;
                __int16 v243 = 2114;
                id v244 = v180;
                _os_log_impl(&dword_1830D4000, v65, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fast open started, need initial data", buf, 0x48u);
              }
            }
            else
            {
              if (v64)
              {
LABEL_64:
                *((_WORD *)handle + 166) |= 0x800u;
                nw_endpoint_flow_add_initial_write_request(v6);
                a2 = v218;
                v6->event = (nw_endpoint_handler_event_s)589827;
                nw_endpoint_handler_report(v6, 0, &v6->event.domain, 0);
LABEL_84:
                nw_endpoint_handler_service_writes(v6);
                nw_endpoint_handler_service_reads(v6);
                goto LABEL_8;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v65 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v65, OS_LOG_TYPE_INFO))
              {
                __int16 v66 = nw_endpoint_handler_get_id_string(v6);
                uint64_t v67 = nw_endpoint_handler_dry_run_string(v6);
                nw_endpoint_t v68 = nw_endpoint_handler_copy_endpoint(v6);
                int v69 = v65;
                __int16 v70 = v67;
                unsigned int v71 = nw_endpoint_get_logging_description(v68);
                uint64_t v72 = nw_endpoint_handler_state_string(v6);
                uint64_t v73 = nw_endpoint_handler_mode_string(v6);
                id v74 = nw_endpoint_handler_copy_current_path(v6);
                *(_DWORD *)buf = 136447746;
                v232 = "nw_flow_connected";
                __int16 v233 = 2082;
                v234 = (void *)v66;
                __int16 v235 = 2082;
                v236 = v70;
                __int16 v237 = 2082;
                v238 = (void *)v71;
                __int16 v239 = 2082;
                v240 = v72;
                __int16 v241 = 2082;
                v242 = v73;
                __int16 v243 = 2114;
                id v244 = v74;
                _os_log_impl(&dword_1830D4000, v69, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Fast open started, need initial data", buf, 0x48u);

                uint64_t v65 = v69;
              }
            }

            uint64_t v3 = v216;
            goto LABEL_64;
          }
        }
      }
    }
    int v80 = nw_endpoint_handler_get_minimize_logging(v6);
    char v81 = nw_endpoint_handler_get_logging_disabled(v6);
    if (v80)
    {
      if (v81) {
        goto LABEL_83;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v82 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEBUG))
      {
        v169 = nw_endpoint_handler_get_id_string(v6);
        logg = nw_endpoint_handler_dry_run_string(v6);
        nw_endpoint_t v170 = nw_endpoint_handler_copy_endpoint(v6);
        os_log_type_t v171 = nw_endpoint_get_logging_description(v170);
        v172 = nw_endpoint_handler_state_string(v6);
        v173 = nw_endpoint_handler_mode_string(v6);
        id v174 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v232 = "nw_flow_connected";
        __int16 v233 = 2082;
        v234 = (void *)v169;
        __int16 v235 = 2082;
        v236 = logg;
        __int16 v237 = 2082;
        v238 = (void *)v171;
        __int16 v239 = 2082;
        v240 = v172;
        __int16 v241 = 2082;
        v242 = v173;
        __int16 v243 = 2114;
        id v244 = v174;
        __int16 v245 = 2082;
        v246 = __str;
        _os_log_impl(&dword_1830D4000, v82, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol connected%{public}s", buf, 0x52u);
      }
    }
    else
    {
      if (v81)
      {
LABEL_83:
        *((_WORD *)handle + 166) &= ~0x800u;
        *((_DWORD *)v220 + 251) = 0;
        nw_endpoint_flow_add_initial_write_request(v6);
        a2 = v218;
        nw_endpoint_flow_connected(v6);
        goto LABEL_84;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v82 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v82, OS_LOG_TYPE_DEFAULT))
      {
        logb = v82;
        uint64_t v83 = nw_endpoint_handler_get_id_string(v6);
        char v84 = nw_endpoint_handler_dry_run_string(v6);
        nw_endpoint_t v85 = nw_endpoint_handler_copy_endpoint(v6);
        os_log_type_t v86 = nw_endpoint_get_logging_description(v85);
        __int16 v87 = nw_endpoint_handler_state_string(v6);
        os_log_type_t v88 = nw_endpoint_handler_mode_string(v6);
        id v89 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448002;
        v232 = "nw_flow_connected";
        __int16 v233 = 2082;
        v234 = (void *)v83;
        __int16 v235 = 2082;
        v236 = v84;
        __int16 v237 = 2082;
        v238 = (void *)v86;
        __int16 v239 = 2082;
        v240 = v87;
        __int16 v241 = 2082;
        v242 = v88;
        __int16 v243 = 2114;
        id v244 = v89;
        __int16 v245 = 2082;
        v246 = __str;
        _os_log_impl(&dword_1830D4000, logb, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output protocol connected%{public}s", buf, 0x52u);

        BOOL v82 = logb;
      }
    }

    goto LABEL_83;
  }
  char v119 = 0;
  v148 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v232 = "nw_flow_connected";
  v149 = (char *)_os_log_send_and_compose_impl();

  __str[0] = 16;
  LOBYTE(v227) = 0;
  if (__nwlog_fault(v149, __str, &v227))
  {
    if (__str[0] == 17)
    {
      v150 = __nwlog_obj();
      os_log_type_t v151 = __str[0];
      if (os_log_type_enabled(v150, (os_log_type_t)__str[0]))
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_1830D4000, v150, v151, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v227)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v150 = __nwlog_obj();
      os_log_type_t v153 = __str[0];
      BOOL v154 = os_log_type_enabled(v150, (os_log_type_t)__str[0]);
      if (backtrace_string)
      {
        if (v154)
        {
          *(_DWORD *)buf = 136446466;
          v232 = "nw_flow_connected";
          __int16 v233 = 2082;
          v234 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v150, v153, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_163;
      }
      if (v154)
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_1830D4000, v150, v153, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v150 = __nwlog_obj();
      os_log_type_t v155 = __str[0];
      if (os_log_type_enabled(v150, (os_log_type_t)__str[0]))
      {
        *(_DWORD *)buf = 136446210;
        v232 = "nw_flow_connected";
        _os_log_impl(&dword_1830D4000, v150, v155, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_163:
  if (v149) {
    free(v149);
  }
LABEL_119:
}

void sub_1830F6BDC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,char a31)
{
  _Block_object_dispose(&a31, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_minimize_logging(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void *)*((void *)v1 + 4);
    if (v3)
    {
      uint64_t v4 = v3;
      uint64_t v5 = (v4[12] >> 38) & 1;
    }
    else
    {
      uint64_t v5 = 0;
    }
    goto LABEL_5;
  }
  uint64_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v18 = "nw_endpoint_handler_get_minimize_logging";
  __int16 v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_endpoint_handler_get_minimize_logging";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v18 = "nw_endpoint_handler_get_minimize_logging";
          __int16 v19 = 2082;
          char v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_endpoint_handler_get_minimize_logging";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v18 = "nw_endpoint_handler_get_minimize_logging";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  uint64_t v5 = 1;
LABEL_5:

  return v5;
}

id nw_endpoint_handler_copy_current_path(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    id v3 = *(id *)&v2[16]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v2 + 28);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_handler_copy_current_path";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_copy_current_path";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_handler_copy_current_path";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_copy_current_path";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_copy_current_path";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

const char *nw_endpoint_handler_get_id_string(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = (char *)v1;
  if (v1)
  {
    id v3 = v1 + 168;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_handler_get_id_string";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_get_id_string";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_handler_get_id_string";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_get_id_string";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_get_id_string";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = "";
LABEL_3:

  return v3;
}

const char *nw_endpoint_handler_dry_run_string(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if (*((unsigned char *)v1 + 268)) {
      id v3 = "dry-run ";
    }
    else {
      id v3 = "";
    }
    goto LABEL_5;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_handler_dry_run_string";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_dry_run_string";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_handler_dry_run_string";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_dry_run_string";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_dry_run_string";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v6) {
    free(v6);
  }
  id v3 = "";
LABEL_5:

  return v3;
}

const char *nw_endpoint_handler_state_string(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[30];
    if (v3 > 5) {
      uint64_t v4 = "unknown-state";
    }
    else {
      uint64_t v4 = off_1E523FB38[v3];
    }
    goto LABEL_5;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_endpoint_handler_state_string";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_endpoint_handler_state_string";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_endpoint_handler_state_string";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_endpoint_handler_state_string";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_endpoint_handler_state_string";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = "null";
LABEL_5:

  return v4;
}

const char *nw_endpoint_handler_mode_string(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = "path";
    switch(*((_DWORD *)v1 + 29))
    {
      case 0:
        goto LABEL_9;
      case 1:
        uint64_t v3 = "resolver";
        break;
      case 2:
        uint64_t v3 = nw_endpoint_flow_mode_string(v1[31]);
        break;
      case 3:
        uint64_t v3 = "proxy";
        break;
      case 4:
        uint64_t v3 = "fallback";
        break;
      case 5:
        uint64_t v3 = "transform";
        break;
      default:
        uint64_t v3 = "unknown-mode";
        break;
    }
    goto LABEL_9;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_handler_mode_string";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_mode_string";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_handler_mode_string";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_mode_string";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_mode_string";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_26:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = "null";
LABEL_9:

  return v3;
}

const char *nw_endpoint_flow_mode_string(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if ((v1[32] & 3) == 1)
    {
      uint64_t v3 = "parent-flow";
    }
    else if ((v1[32] & 2) != 0)
    {
      if (v1[33] < 0) {
        uint64_t v4 = "multipath-socket-flow";
      }
      else {
        uint64_t v4 = "socket-flow";
      }
      if ((v1[33] & 0x40) != 0) {
        uint64_t v3 = "channel-flow";
      }
      else {
        uint64_t v3 = v4;
      }
    }
    else
    {
      uint64_t v3 = "intermediate-flow";
    }
    goto LABEL_12;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_endpoint_flow_mode_string";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_endpoint_flow_mode_string";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_endpoint_flow_mode_string";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_endpoint_flow_mode_string";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_endpoint_flow_mode_string";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_29:
  if (v7) {
    free(v7);
  }
  uint64_t v3 = "null-flow";
LABEL_12:

  return v3;
}

uint64_t nw_endpoint_handler_get_logging_disabled(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[268] >> 5) & 1;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_handler_get_logging_disabled";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_handler_get_logging_disabled";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_handler_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 1;
LABEL_3:

  return v3;
}

BOOL nw_read_request_list_remove_head(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_read_request_list_remove_head";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_read_request_list_remove_head";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null head", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_read_request_list_remove_head";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null head, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_25;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_read_request_list_remove_head";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null head, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_read_request_list_remove_head";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null head, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_25:
    if (v8) {
      free(v8);
    }
    uint64_t v3 = 0;
    goto LABEL_6;
  }
  uint64_t v3 = *((id *)v1 + 1);
  uint64_t v4 = (void *)v2[1];
  v2[1] = 0;

  if (!v3)
  {
LABEL_5:
    v2[2] = 0;
LABEL_6:

    return (BOOL)v3;
  }
  uint64_t v5 = v2[2];
  if (v5)
  {
LABEL_4:
    v3[2] = v5;
    goto LABEL_5;
  }
  BOOL v11 = __nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_read_request_list_remove_head";
  os_log_type_t v12 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    uint64_t v5 = v2[2];
    goto LABEL_4;
  }
  __break(1u);
  return result;
}

uint64_t nw_socket_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle) {
      return *(unsigned __int16 *)&a1[6].flow_id[13] >> 15;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v14 = "nw_socket_waiting_for_output";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v3, &type, &v11)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_socket_waiting_for_output";
        int v6 = "%{public}s called with null socket_handler";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_socket_waiting_for_output";
        int v6 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v10 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_socket_waiting_for_output";
        int v6 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v14 = "nw_socket_waiting_for_output";
      __int16 v15 = 2082;
      os_log_type_t v16 = backtrace_string;
      os_log_type_t v9 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_21;
    }
    goto LABEL_22;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v14 = "nw_socket_waiting_for_output";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (!__nwlog_fault(v3, &type, &v11)) {
    goto LABEL_32;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v11)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_socket_waiting_for_output";
        int v6 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    BOOL v8 = os_log_type_enabled(v4, type);
    if (!backtrace_string)
    {
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v14 = "nw_socket_waiting_for_output";
        int v6 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_31;
      }
      goto LABEL_32;
    }
    if (v8)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v14 = "nw_socket_waiting_for_output";
      __int16 v15 = 2082;
      os_log_type_t v16 = backtrace_string;
      os_log_type_t v9 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v4, v5, v9, buf, 0x16u);
    }
LABEL_22:
    free(backtrace_string);
    goto LABEL_32;
  }
  uint64_t v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  if (os_log_type_enabled(v4, type))
  {
    *(_DWORD *)buf = 136446210;
    os_log_type_t v14 = "nw_socket_waiting_for_output";
    int v6 = "%{public}s called with null protocol";
LABEL_31:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
  }
LABEL_32:
  if (v3) {
    free(v3);
  }
  return 0;
}

void nw_ws_options_add_subprotocol(nw_protocol_options_t options, const char *subprotocol)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = options;
  if (!nw_protocol_options_is_ws(v3))
  {
    uint64_t v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v22 = "nw_ws_options_add_subprotocol";
    os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v5, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ws(options)", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_ws_options_add_subprotocol";
          __int16 v23 = 2082;
          uint64_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v5) {
          goto LABEL_4;
        }
LABEL_39:
        free(v5);
        goto LABEL_4;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ws(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_ws_options_add_subprotocol";
        _os_log_impl(&dword_1830D4000, v6, v16, "%{public}s called with null nw_protocol_options_is_ws(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (subprotocol)
  {
    v18[0] = MEMORY[0x1E4F143A8];
    v18[1] = 3221225472;
    v18[2] = __nw_ws_options_add_subprotocol_block_invoke;
    v18[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v18[4] = subprotocol;
    nw_protocol_options_access_handle(v3, v18);
    goto LABEL_4;
  }
  BOOL v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_ws_options_add_subprotocol";
  os_log_type_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v5, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v6 = __nwlog_obj();
    os_log_type_t v9 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_ws_options_add_subprotocol";
      _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null subprotocol", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    int v6 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_ws_options_add_subprotocol";
      _os_log_impl(&dword_1830D4000, v6, v17, "%{public}s called with null subprotocol, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  char v13 = (char *)__nw_create_backtrace_string();
  int v6 = __nwlog_obj();
  os_log_type_t v14 = type;
  BOOL v15 = os_log_type_enabled(v6, type);
  if (!v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v22 = "nw_ws_options_add_subprotocol";
      _os_log_impl(&dword_1830D4000, v6, v14, "%{public}s called with null subprotocol, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v22 = "nw_ws_options_add_subprotocol";
    __int16 v23 = 2082;
    uint64_t v24 = v13;
    _os_log_impl(&dword_1830D4000, v6, v14, "%{public}s called with null subprotocol, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
  if (v5) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_1830F8FB4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    os_log_type_t v5 = p_output_handler;
    int v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v7 = *((void *)v5 + 1);
      if (v7)
      {
        if (*(void *)(v7 + 80))
        {
          if (!a2
            || (output_handler_context = a2->output_handler_context) == 0
            || (output_handler_context[42] & 2) == 0)
          {
            uint64_t v9 = (v5[405] >> 3) & 1;
LABEL_11:

            return v9;
          }
LABEL_82:
          uint64_t v9 = 0;
          goto LABEL_11;
        }
        __int16 v21 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_protocol_implementation_waiting_for_output";
        os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v37 = 0;
        if (!__nwlog_fault((const char *)v16, &type, &v37))
        {
LABEL_80:
          if (v16) {
            free(v16);
          }
          goto LABEL_82;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v22 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            id v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
LABEL_79:

          goto LABEL_80;
        }
        if (!v37)
        {
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v36 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            id v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl(&dword_1830D4000, v17, v36, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_79;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v17, type);
        if (!backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446210;
            id v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_79;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          id v40 = "nw_protocol_implementation_waiting_for_output";
          __int16 v41 = 2082;
          uint64_t v42 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v31, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        char v19 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_protocol_implementation_waiting_for_output";
        os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v37 = 0;
        if (!__nwlog_fault((const char *)v16, &type, &v37)) {
          goto LABEL_80;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            id v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_79;
        }
        if (!v37)
        {
          os_log_type_t v17 = __nwlog_obj();
          os_log_type_t v35 = type;
          if (os_log_type_enabled(v17, type))
          {
            *(_DWORD *)buf = 136446210;
            id v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl(&dword_1830D4000, v17, v35, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_79;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v17, type);
        if (!backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            id v40 = "nw_protocol_implementation_waiting_for_output";
            _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_79;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          id v40 = "nw_protocol_implementation_waiting_for_output";
          __int16 v41 = 2082;
          uint64_t v42 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
    }
    else
    {
      BOOL v15 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v40 = "nw_protocol_implementation_waiting_for_output";
      os_log_type_t v16 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (!__nwlog_fault((const char *)v16, &type, &v37)) {
        goto LABEL_80;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          id v40 = "nw_protocol_implementation_waiting_for_output";
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_79;
      }
      if (!v37)
      {
        os_log_type_t v17 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)buf = 136446210;
          id v40 = "nw_protocol_implementation_waiting_for_output";
          _os_log_impl(&dword_1830D4000, v17, v34, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_79;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          id v40 = "nw_protocol_implementation_waiting_for_output";
          _os_log_impl(&dword_1830D4000, v17, v27, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_79;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        id v40 = "nw_protocol_implementation_waiting_for_output";
        __int16 v41 = 2082;
        uint64_t v42 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v27, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(backtrace_string);
    goto LABEL_80;
  }
  os_log_type_t v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v40 = "nw_protocol_implementation_waiting_for_output";
  BOOL v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (__nwlog_fault(v12, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_protocol_implementation_waiting_for_output";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v37)
    {
      __int16 v23 = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v13, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          id v40 = "nw_protocol_implementation_waiting_for_output";
          __int16 v41 = 2082;
          uint64_t v42 = v23;
          _os_log_impl(&dword_1830D4000, v13, v24, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
        goto LABEL_68;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_protocol_implementation_waiting_for_output";
        _os_log_impl(&dword_1830D4000, v13, v24, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        id v40 = "nw_protocol_implementation_waiting_for_output";
        _os_log_impl(&dword_1830D4000, v13, v33, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_68:
  if (v12) {
    free(v12);
  }
  return 0;
}

uint64_t nw_connection_used_fallback_locked(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    if ((*((unsigned char *)v1 + 109) & 0x40) != 0) {
      uint64_t v3 = nw_endpoint_handler_copy_connected_flow_handler(v1[18]);
    }
    else {
      uint64_t v3 = v1[19];
    }
    uint64_t v4 = v3;
    if (v3)
    {
      os_log_type_t v5 = v3;
      id v6 = v5[4];

      if (v6)
      {
        uint64_t v7 = v6;
        uint64_t v8 = (v7[12] >> 16) & 1;
      }
      else
      {
        uint64_t v8 = 0;
      }
    }
    else
    {
      uint64_t v8 = 0;
    }

    goto LABEL_12;
  }
  BOOL v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v21 = "nw_connection_used_fallback_locked";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_connection_used_fallback_locked";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v21 = "nw_connection_used_fallback_locked";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_connection_used_fallback_locked";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_connection_used_fallback_locked";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_29:
  if (v11) {
    free(v11);
  }
  uint64_t v8 = 0;
LABEL_12:

  return v8;
}

void sub_1830F9BBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_flow_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  handle = (nw_flow_protocol *)a1->handle;
  uint64_t v3 = handle->handler;
  uint64_t v4 = v3;
  if (v3)
  {
    os_log_type_t v5 = v3;
    uint64_t mode = v5->mode;

    if (mode == 2)
    {
      uint64_t v7 = nw_endpoint_handler_copy_flow(v5);
      nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v7, handle, 0);
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = (id)gLogObj;
      if (os_log_type_enabled(v8, OS_LOG_TYPE_DEFAULT))
      {
        if (mode > 5) {
          uint64_t v9 = "unknown-mode";
        }
        else {
          uint64_t v9 = off_1E523FB08[mode];
        }
        *(_DWORD *)buf = 136446722;
        __int16 v21 = "nw_flow_input_available";
        __int16 v22 = 2082;
        __int16 v23 = (void *)v9;
        __int16 v24 = 2082;
        BOOL v25 = "flow";
        _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
      }
    }
    goto LABEL_10;
  }
  BOOL v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v21 = "nw_flow_input_available";
  os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_flow_input_available";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v21 = "nw_flow_input_available";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_flow_input_available";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v21 = "nw_flow_input_available";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v11) {
    free(v11);
  }
LABEL_10:
}

void sub_1830F9F58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_service_reads(void *a1)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    char v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v28 = "nw_endpoint_handler_service_reads";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v8, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v25)
      {
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_1830D4000, v9, v24, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v28 = "nw_endpoint_handler_service_reads";
          _os_log_impl(&dword_1830D4000, v9, v22, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v28 = "nw_endpoint_handler_service_reads";
        __int16 v29 = 2082;
        BOOL v30 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v22, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_36:
    if (!v8) {
      goto LABEL_38;
    }
LABEL_37:
    free(v8);
    goto LABEL_38;
  }
  uint64_t v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode == 2)
  {
    os_log_type_t v5 = (NWConcrete_nw_endpoint_flow *)nw_endpoint_handler_copy_flow(v3);
    nw_flow_service_reads(v3, v5, &v5->shared_protocol, 0);

    goto LABEL_38;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  if (mode > 5) {
    uint64_t v7 = "unknown-mode";
  }
  else {
    uint64_t v7 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  BOOL v28 = "nw_endpoint_handler_service_reads";
  __int16 v29 = 2082;
  BOOL v30 = (void *)v7;
  __int16 v31 = 2082;
  BOOL v32 = "flow";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (!__nwlog_fault(v8, &type, &v25)) {
    goto LABEL_36;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v9, type))
    {
      if (mode > 5) {
        os_log_type_t v11 = "unknown-mode";
      }
      else {
        os_log_type_t v11 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v28 = "nw_endpoint_handler_service_reads";
      __int16 v29 = 2082;
      BOOL v30 = (void *)v11;
      __int16 v31 = 2082;
      BOOL v32 = "flow";
      _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!v25)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = (id)gLogObj;
    os_log_type_t v16 = type;
    if (os_log_type_enabled(v9, type))
    {
      if (mode > 5) {
        os_log_type_t v17 = "unknown-mode";
      }
      else {
        os_log_type_t v17 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v28 = "nw_endpoint_handler_service_reads";
      __int16 v29 = 2082;
      BOOL v30 = (void *)v17;
      __int16 v31 = 2082;
      BOOL v32 = "flow";
      _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_35;
  }
  BOOL v12 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v9 = (id)gLogObj;
  os_log_type_t v13 = type;
  BOOL v14 = os_log_type_enabled(v9, type);
  if (!v12)
  {
    if (v14)
    {
      if (mode > 5) {
        char v18 = "unknown-mode";
      }
      else {
        char v18 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      BOOL v28 = "nw_endpoint_handler_service_reads";
      __int16 v29 = 2082;
      BOOL v30 = (void *)v18;
      __int16 v31 = 2082;
      BOOL v32 = "flow";
      _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_35;
  }
  if (v14)
  {
    if (mode > 5) {
      os_log_type_t v15 = "unknown-mode";
    }
    else {
      os_log_type_t v15 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    BOOL v28 = "nw_endpoint_handler_service_reads";
    __int16 v29 = 2082;
    BOOL v30 = (void *)v15;
    __int16 v31 = 2082;
    BOOL v32 = "flow";
    __int16 v33 = 2082;
    os_log_type_t v34 = v12;
    _os_log_impl(&dword_1830D4000, v9, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v12);
  if (v8) {
    goto LABEL_37;
  }
LABEL_38:
}

void sub_1830FA5C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_flow_service_reads(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_flow_protocol *a3, int a4)
{
  LODWORD(v4) = a4;
  uint64_t v141 = *MEMORY[0x1E4F143B8];
  int v118 = a1;
  uint64_t v115 = a2;
  if (!a3)
  {
    char v84 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v126 = "nw_flow_service_reads";
    nw_endpoint_t v85 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(type.tqh_first) = 16;
    LOBYTE(v124) = 0;
    if (__nwlog_fault(v85, &type, &v124))
    {
      if (LOBYTE(type.tqh_first) == 17)
      {
        os_log_type_t v86 = __nwlog_obj();
        os_log_type_t tqh_first = (os_log_type_t)type.tqh_first;
        if (os_log_type_enabled(v86, (os_log_type_t)type.tqh_first))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v126 = "nw_flow_service_reads";
          _os_log_impl(&dword_1830D4000, v86, tqh_first, "%{public}s called with null flow_protocol", buf, 0xCu);
        }
      }
      else
      {
        if ((_BYTE)v124)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          id v89 = __nwlog_obj();
          os_log_type_t v90 = (os_log_type_t)type.tqh_first;
          BOOL v91 = os_log_type_enabled(v89, (os_log_type_t)type.tqh_first);
          if (backtrace_string)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v126 = "nw_flow_service_reads";
              __int16 v127 = 2082;
              os_log_type_t v128 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null flow_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v126 = "nw_flow_service_reads";
              _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null flow_protocol, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_132;
        }
        os_log_type_t v86 = __nwlog_obj();
        os_log_type_t v100 = (os_log_type_t)type.tqh_first;
        if (os_log_type_enabled(v86, (os_log_type_t)type.tqh_first))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v126 = "nw_flow_service_reads";
          _os_log_impl(&dword_1830D4000, v86, v100, "%{public}s called with null flow_protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_132:
    if (v85) {
      free(v85);
    }
    goto LABEL_15;
  }
  output_handler = a3->protocol.output_handler;
  if (!output_handler)
  {
    if ((nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_endpoint_handler_get_id_string(v118);
        BOOL v12 = nw_endpoint_handler_dry_run_string(v118);
        nw_endpoint_t v13 = nw_endpoint_handler_copy_endpoint(v118);
        logging_description = nw_endpoint_get_logging_description(v13);
        os_log_type_t v15 = nw_endpoint_handler_state_string(v118);
        os_log_type_t v16 = nw_endpoint_handler_mode_string(v118);
        id v17 = nw_endpoint_handler_copy_current_path(v118);
        *(_DWORD *)buf = 136447746;
        os_log_type_t v126 = "nw_flow_service_reads";
        __int16 v127 = 2082;
        os_log_type_t v128 = id_string;
        __int16 v129 = 2082;
        uint64_t v130 = v12;
        __int16 v131 = 2082;
        id v132 = logging_description;
        __int16 v133 = 2082;
        v134 = v15;
        __int16 v135 = 2082;
        v136 = v16;
        __int16 v137 = 2114;
        id v138 = v17;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] No output handler", buf, 0x48u);
      }
    }
LABEL_15:
    BOOL v111 = 0;
    goto LABEL_103;
  }
  uint64_t v124 = 0;
  callbacks = output_handler->callbacks;
  id v113 = output_handler;
  if (callbacks)
  {
    get_message_properties = (void (*)(void))callbacks->get_message_properties;
    if (get_message_properties) {
      get_message_properties();
    }
  }
  if (v4) {
    LODWORD(v4) = nw_endpoint_handler_get_state(v118) != 5 && (v124 & 0x100000000) == 0;
  }
  __int16 v18 = *((_WORD *)a3 + 166);
  BOOL v111 = (v18 & 4) == 0;
  if ((v18 & 4) == 0)
  {
    *((_WORD *)a3 + 166) = v18 | 4;
    request_list_report = (OS_nw_read_request *)nw_read_request_list_report(a3->read_requests);
    read_requests = a3->read_requests;
    a3->read_requests = request_list_report;

    char v110 = (char)v4;
    if (!a3->read_requests && gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v101 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v101, OS_LOG_TYPE_DEBUG))
      {
        char v102 = nw_endpoint_handler_get_id_string(v118);
        v103 = nw_endpoint_handler_dry_run_string(v118);
        nw_endpoint_t v104 = nw_endpoint_handler_copy_endpoint(v118);
        BOOL v105 = nw_endpoint_get_logging_description(v104);
        nw_endpoint_t v106 = nw_endpoint_handler_state_string(v118);
        v107 = nw_endpoint_handler_mode_string(v118);
        id v108 = nw_endpoint_handler_copy_current_path(v118);
        *(_DWORD *)buf = 136448002;
        os_log_type_t v126 = "nw_flow_service_reads";
        __int16 v127 = 2082;
        os_log_type_t v128 = v102;
        __int16 v129 = 2082;
        uint64_t v130 = v103;
        __int16 v131 = 2082;
        id v132 = v105;
        __int16 v133 = 2082;
        v134 = v106;
        __int16 v135 = 2082;
        v136 = v107;
        __int16 v137 = 2114;
        id v138 = v108;
        __int16 v139 = 2048;
        *(void *)v140 = a3;
        _os_log_impl(&dword_1830D4000, v101, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] %p No read requests, skipping read", buf, 0x52u);
      }
      LOBYTE(v4) = v110;
    }
    p_pending_input_frames = &a3->pending_input_frames;
    while (1)
    {
      if (a3->read_requests) {
        char v21 = 1;
      }
      else {
        char v21 = (char)v4;
      }
      if ((v21 & 1) == 0 && (*((_WORD *)a3 + 166) & 0x40) == 0)
      {
LABEL_95:
        if ((v4 & 1) != 0 || (__int16 v78 = *((_WORD *)a3 + 166), (v78 & 0x40) != 0))
        {
          if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v92 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v92, OS_LOG_TYPE_DEBUG))
            {
              char v93 = nw_endpoint_handler_get_id_string(v118);
              os_log_type_t v94 = nw_endpoint_handler_dry_run_string(v118);
              nw_endpoint_t v95 = nw_endpoint_handler_copy_endpoint(v118);
              nw_endpoint_t v96 = nw_endpoint_get_logging_description(v95);
              v97 = nw_endpoint_handler_state_string(v118);
              BOOL v98 = nw_endpoint_handler_mode_string(v118);
              id v99 = nw_endpoint_handler_copy_current_path(v118);
              *(_DWORD *)buf = 136447746;
              os_log_type_t v126 = "nw_flow_service_reads";
              __int16 v127 = 2082;
              os_log_type_t v128 = v93;
              __int16 v129 = 2082;
              uint64_t v130 = v94;
              __int16 v131 = 2082;
              id v132 = v96;
              __int16 v133 = 2082;
              v134 = v97;
              __int16 v135 = 2082;
              v136 = v98;
              __int16 v137 = 2114;
              id v138 = v99;
              _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Handling remaining read requests", buf, 0x48u);
            }
          }
          last_error = a3->last_error;
          int v80 = a3->read_requests;
          if (last_error)
          {
            nw_read_request_report_error_with_override(a3->read_requests, 0, last_error);
          }
          else
          {
            char v81 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 96);
            nw_read_request_report_error_with_override(v80, 0, v81);
          }
          BOOL v82 = a3->read_requests;
          a3->read_requests = 0;

          __int16 v78 = *((_WORD *)a3 + 166);
        }
        *((_WORD *)a3 + 166) = v78 & 0xFFFB;
        goto LABEL_103;
      }
      if ((v4 & 1) != 0 || (*((_WORD *)a3 + 166) & 0x40) != 0)
      {
        unsigned int v22 = BYTE4(v124) & 4;
        if ((v124 & 0x400000000) != 0) {
          unint64_t v23 = 1;
        }
        else {
          unint64_t v23 = 0xFFFFFFFFLL;
        }
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v48 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v49 = nw_endpoint_handler_get_id_string(v118);
            uint64_t v4 = nw_endpoint_handler_dry_run_string(v118);
            nw_endpoint_t v50 = nw_endpoint_handler_copy_endpoint(v118);
            nw_endpoint_t v51 = nw_endpoint_get_logging_description(v50);
            nw_endpoint_t v117 = nw_endpoint_handler_state_string(v118);
            id v52 = nw_endpoint_handler_mode_string(v118);
            id v53 = nw_endpoint_handler_copy_current_path(v118);
            *(_DWORD *)buf = 136448002;
            os_log_type_t v126 = "nw_flow_service_reads";
            __int16 v127 = 2082;
            os_log_type_t v128 = v49;
            __int16 v129 = 2082;
            uint64_t v130 = v4;
            __int16 v131 = 2082;
            id v132 = v51;
            __int16 v133 = 2082;
            v134 = v117;
            __int16 v135 = 2082;
            v136 = v52;
            __int16 v137 = 2114;
            id v138 = v53;
            __int16 v139 = 2048;
            *(void *)v140 = v23;
            _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Setting min_length on final data read to %zu", buf, 0x52u);

            LOBYTE(v4) = v110;
          }
        }
        v120[0] = MEMORY[0x1E4F143A8];
        v120[1] = 3221225472;
        v120[2] = ___ZL21nw_flow_service_readsP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocolb_block_invoke;
        v120[3] = &unk_1E523CA28;
        char v121 = v118;
        v122 = a3;
        char v123 = v22 >> 2;
        os_log_type_t v24 = nw_read_request_create(v23, 0xFFFFFFFFuLL, 0, 0, v120);
        BOOL request_list_append = nw_read_request_list_append(a3->read_requests, v24);
        uint64_t v26 = a3->read_requests;
        a3->read_requests = (OS_nw_read_request *)request_list_append;
      }
      if (p_pending_input_frames->tqh_first)
      {
        nw_flow_process_input_frames(v118, v115, &a3->protocol, p_pending_input_frames, BYTE4(v124) & 1, (v124 & 0x400000000) != 0, 0);
        os_log_type_t v27 = a3->read_requests;
        if (!v27) {
          goto LABEL_95;
        }
      }
      else
      {
        os_log_type_t v27 = a3->read_requests;
      }
      BOOL v28 = v27;
      __int16 v29 = v28;
      id v116 = v28;
      if ((v124 & 0x100000000) != 0)
      {
        maximum_datagram_size_t count = nw_read_request_get_maximum_datagram_count(v28);
        if (!maximum_datagram_count)
        {
          int v70 = -1;
LABEL_88:
          if ((nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            unsigned int v71 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v71, OS_LOG_TYPE_ERROR))
            {
              uint64_t v72 = nw_endpoint_handler_get_id_string(v118);
              uint64_t v73 = nw_endpoint_handler_dry_run_string(v118);
              uint64_t v4 = v72;
              nw_endpoint_t v114 = nw_endpoint_handler_copy_endpoint(v118);
              id v74 = nw_endpoint_get_logging_description(v114);
              v75 = nw_endpoint_handler_state_string(v118);
              v76 = nw_endpoint_handler_mode_string(v118);
              id v77 = nw_endpoint_handler_copy_current_path(v118);
              *(_DWORD *)buf = 136448258;
              os_log_type_t v126 = "nw_flow_service_reads";
              __int16 v127 = 2082;
              os_log_type_t v128 = v4;
              __int16 v129 = 2082;
              uint64_t v130 = v73;
              __int16 v131 = 2082;
              id v132 = v74;
              __int16 v133 = 2082;
              v134 = v75;
              __int16 v135 = 2082;
              v136 = v76;
              __int16 v137 = 2114;
              id v138 = v77;
              __int16 v139 = 1024;
              *(_DWORD *)v140 = maximum_datagram_count;
              *(_WORD *)&v140[4] = 1024;
              *(_DWORD *)&v140[6] = v70;
              _os_log_impl(&dword_1830D4000, v71, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Read request has %u frame count, %u byte count", buf, 0x54u);

              LOBYTE(v4) = v110;
            }
          }
          goto LABEL_95;
        }
      }
      else if (nw_read_request_get_next_max_size(a3->read_requests))
      {
        maximum_datagram_size_t count = -1;
      }
      else
      {
        int v70 = 0;
        maximum_datagram_size_t count = -1;
        if (!nw_read_request_is_metadata_only(v29)) {
          goto LABEL_88;
        }
      }
      __int16 v31 = v116;
      if (nw_read_request_is_metadata_only(v116)) {
        int v32 = 1;
      }
      else {
        int v32 = maximum_datagram_count;
      }
      type.os_log_type_t tqh_first = 0;
      type.tqh_last = (nw_frame **)&type;
      int v33 = ((uint64_t (*)(void))v113->callbacks->get_input_frames)();
      if (v32 == -1)
      {
        if (!gLogDatapath || (nw_endpoint_handler_get_logging_disabled(v118) & 1) != 0) {
          goto LABEL_54;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v34 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v54 = nw_endpoint_handler_get_id_string(v118);
          uint64_t v4 = nw_endpoint_handler_dry_run_string(v118);
          nw_endpoint_t v55 = nw_endpoint_handler_copy_endpoint(v118);
          id v56 = nw_endpoint_get_logging_description(v55);
          id v57 = nw_endpoint_handler_state_string(v118);
          id v58 = nw_endpoint_handler_mode_string(v118);
          id v59 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448002;
          os_log_type_t v126 = "nw_flow_service_reads";
          __int16 v127 = 2082;
          os_log_type_t v128 = v54;
          __int16 v129 = 2082;
          uint64_t v130 = v4;
          __int16 v131 = 2082;
          id v132 = v56;
          __int16 v133 = 2082;
          v134 = v57;
          __int16 v135 = 2082;
          v136 = v58;
          __int16 v137 = 2114;
          id v138 = v59;
          __int16 v139 = 1024;
          *(_DWORD *)v140 = v33;
          _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frames to read", buf, 0x4Eu);

          LOBYTE(v4) = v110;
        }
      }
      else
      {
        if (!gLogDatapath || (nw_endpoint_handler_get_logging_disabled(v118) & 1) != 0) {
          goto LABEL_54;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v34 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v35 = nw_endpoint_handler_get_id_string(v118);
          uint64_t v4 = nw_endpoint_handler_dry_run_string(v118);
          nw_endpoint_t v36 = nw_endpoint_handler_copy_endpoint(v118);
          char v37 = nw_endpoint_get_logging_description(v36);
          v109 = nw_endpoint_handler_state_string(v118);
          id v38 = nw_endpoint_handler_mode_string(v118);
          id v39 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448258;
          os_log_type_t v126 = "nw_flow_service_reads";
          __int16 v127 = 2082;
          os_log_type_t v128 = v35;
          __int16 v129 = 2082;
          uint64_t v130 = v4;
          __int16 v131 = 2082;
          id v132 = v37;
          __int16 v133 = 2082;
          v134 = v109;
          __int16 v135 = 2082;
          v136 = v38;
          __int16 v137 = 2114;
          id v138 = v39;
          __int16 v139 = 1024;
          *(_DWORD *)v140 = v33;
          *(_WORD *)&v140[4] = 1024;
          *(_DWORD *)&v140[6] = v32;
          _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler has %u frames to read, request wants %u frames", buf, 0x54u);

          LOBYTE(v4) = v110;
        }
      }

      __int16 v31 = v116;
LABEL_54:
      if (!type.tqh_first && v33 && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v40 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v40, OS_LOG_TYPE_ERROR))
        {
          uint64_t v4 = nw_endpoint_handler_get_id_string(v118);
          __int16 v41 = nw_endpoint_handler_dry_run_string(v118);
          nw_endpoint_t v42 = nw_endpoint_handler_copy_endpoint(v118);
          uint64_t v43 = nw_endpoint_get_logging_description(v42);
          id v44 = nw_endpoint_handler_state_string(v118);
          __int16 v45 = nw_endpoint_handler_mode_string(v118);
          id v46 = nw_endpoint_handler_copy_current_path(v118);
          *(_DWORD *)buf = 136448002;
          os_log_type_t v126 = "nw_flow_service_reads";
          __int16 v127 = 2082;
          os_log_type_t v128 = v4;
          __int16 v129 = 2082;
          uint64_t v130 = v41;
          __int16 v131 = 2082;
          id v132 = v43;
          __int16 v133 = 2082;
          v134 = v44;
          __int16 v135 = 2082;
          v136 = v45;
          __int16 v137 = 2114;
          id v138 = v46;
          __int16 v139 = 1024;
          *(_DWORD *)v140 = v33;
          _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Output handler reported %u frames to read, but array is empty", buf, 0x4Eu);

          LOBYTE(v4) = v110;
        }

        __int16 v31 = v116;
      }
      BOOL v47 = nw_flow_process_input_frames(v118, v115, &a3->protocol, &type, BYTE4(v124) & 1, (v124 & 0x400000000) != 0, 1);

      if (!v47) {
        goto LABEL_95;
      }
    }
  }
  if ((v18 & 0x40) == 0)
  {
    if (v4) {
      __int16 v60 = 64;
    }
    else {
      __int16 v60 = 0;
    }
    *((_WORD *)a3 + 166) = v18 & 0xFFBF | v60;
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v118) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v61 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v62 = nw_endpoint_handler_get_id_string(v118);
      int v63 = nw_endpoint_handler_dry_run_string(v118);
      nw_endpoint_t v64 = nw_endpoint_handler_copy_endpoint(v118);
      uint64_t v65 = nw_endpoint_get_logging_description(v64);
      __int16 v66 = nw_endpoint_handler_state_string(v118);
      uint64_t v67 = nw_endpoint_handler_mode_string(v118);
      id v68 = nw_endpoint_handler_copy_current_path(v118);
      int v69 = (*((unsigned __int16 *)a3 + 166) >> 6) & 1;
      *(_DWORD *)buf = 136448002;
      os_log_type_t v126 = "nw_flow_service_reads";
      __int16 v127 = 2082;
      os_log_type_t v128 = v62;
      __int16 v129 = 2082;
      uint64_t v130 = v63;
      __int16 v131 = 2082;
      id v132 = v65;
      __int16 v133 = 2082;
      v134 = v66;
      __int16 v135 = 2082;
      v136 = v67;
      __int16 v137 = 2114;
      id v138 = v68;
      __int16 v139 = 1024;
      *(_DWORD *)v140 = v69;
      _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Already servicing reads, ignore read (deferred final read is %{BOOL}d)", buf, 0x4Eu);
    }
  }
LABEL_103:

  return v111;
}

void sub_1830FB744(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,void *a26)
{
  _Unwind_Resume(a1);
}

unsigned char *nw_read_request_list_report(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    return v2;
  }
  uint64_t v3 = (id *)v1;
  do
  {
    if (((_BYTE)v3[22] & 1) == 0)
    {
      if (((_BYTE)v3[22] & 0xA) != 0 || (id v5 = v3[9], v3[11] >= v5) && (v5 || v3[10] || v3[17] && !v3[10]))
      {
        if (_nw_signposts_once == -1)
        {
          if (_nw_signposts_enabled) {
            goto LABEL_9;
          }
        }
        else
        {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
          if (_nw_signposts_enabled)
          {
LABEL_9:
            if (kdebug_is_enabled()) {
              kdebug_trace();
            }
          }
        }
        nw_read_request_report(v3, 0);
      }
    }
    uint64_t v4 = (id *)v3[1];

    uint64_t v3 = v4;
  }
  while (v4);
  do
  {
    if ((v2[176] & 1) == 0) {
      break;
    }
    BOOL v6 = nw_read_request_list_remove_head(v2);

    uint64_t v2 = (unsigned char *)v6;
  }
  while (v6);
  return v2;
}

void sub_1830FB9CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_default_get_message_properties(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a3)
    {
      uint64_t v3 = *(void *)(a1 + 32);
      if (v3)
      {
        uint64_t v4 = *(void *)(v3 + 24);
        if (v4)
        {
          id v5 = *(void (**)(void))(v4 + 248);
          if (v5)
          {
            v5();
          }
        }
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_default_get_message_properties";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_get_message_properties";
      uint64_t v9 = "%{public}s called with null protocol";
      goto LABEL_22;
    }
    if (!v12)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_23;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_get_message_properties";
      uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_22;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    BOOL v11 = os_log_type_enabled(v7, type);
    if (backtrace_string)
    {
      if (v11)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v15 = "nw_protocol_default_get_message_properties";
        __int16 v16 = 2082;
        id v17 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_23;
    }
    if (v11)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v15 = "nw_protocol_default_get_message_properties";
      uint64_t v9 = "%{public}s called with null protocol, no backtrace";
LABEL_22:
      _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    }
  }
LABEL_23:
  if (v6) {
    free(v6);
  }
}

BOOL nw_read_request_is_metadata_only(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_read_request_is_metadata_only";
    BOOL v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v6, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v16 = "nw_read_request_is_metadata_only";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null request", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v16 = "nw_read_request_is_metadata_only";
            __int16 v17 = 2082;
            uint64_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v16 = "nw_read_request_is_metadata_only";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v16 = "nw_read_request_is_metadata_only";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (v6) {
      free(v6);
    }
    goto LABEL_3;
  }
  if (!*((void *)v1 + 9))
  {
    BOOL v3 = *((void *)v1 + 10) == 0;
    goto LABEL_5;
  }
LABEL_3:
  BOOL v3 = 0;
LABEL_5:

  return v3;
}

void nw_protocol_socket_get_message_properties(uint64_t a1, uint64_t a2, int *a3)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_socket_get_message_properties";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_socket_get_message_properties";
      os_log_type_t v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_protocol_socket_get_message_properties";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v5) {
          return;
        }
LABEL_38:
        free(v5);
        return;
      }
      if (!v10) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_socket_get_message_properties";
      os_log_type_t v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      BOOL v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v16 = "nw_protocol_socket_get_message_properties";
      os_log_type_t v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_37;
  }
  if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
  {
    if (a3)
    {
      if (*(_DWORD *)(a1 + 272) == 1)
      {
        int v3 = *(_DWORD *)(a1 + 256);
        unsigned int v4 = a3[1] & 0xFFFFFFFB;
      }
      else
      {
        int v3 = -1;
        unsigned int v4 = a3[1] | 4;
      }
      *a3 = v3;
      a3[1] = v4;
      a3[1] = v4 & 0xFFFFFFFC | (*(_DWORD *)(a1 + 272) == 1);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_protocol_socket_get_message_properties";
  id v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13)) {
    goto LABEL_37;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_socket_get_message_properties";
    os_log_type_t v8 = "%{public}s called with null socket_handler";
    goto LABEL_36;
  }
  if (!v13)
  {
    BOOL v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_socket_get_message_properties";
    os_log_type_t v8 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    goto LABEL_36;
  }
  BOOL v11 = (char *)__nw_create_backtrace_string();
  BOOL v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_protocol_socket_get_message_properties";
    os_log_type_t v8 = "%{public}s called with null socket_handler, no backtrace";
    goto LABEL_36;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v16 = "nw_protocol_socket_get_message_properties";
    __int16 v17 = 2082;
    uint64_t v18 = v11;
    _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5) {
    goto LABEL_38;
  }
}

uint64_t nw_flow_passthrough_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
        os_log_type_t v15 = "%{public}s called with null protocol";
LABEL_38:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v18 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
          __int16 v25 = 2082;
          uint64_t v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v12) {
          return 0;
        }
LABEL_41:
        free(v12);
        return 0;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
        os_log_type_t v15 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_38;
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
        os_log_type_t v15 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __int16 v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v12, &type, &v21)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
        os_log_type_t v15 = "%{public}s called with null protocol->output_handler";
        goto LABEL_38;
      }
    }
    else
    {
      if (v21)
      {
        uint64_t v19 = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v20 = os_log_type_enabled(v13, type);
        if (v19)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
            __int16 v25 = 2082;
            uint64_t v26 = v19;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null protocol->output_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v19);
          if (!v12) {
            return 0;
          }
          goto LABEL_41;
        }
        if (!v20) {
          goto LABEL_39;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
        os_log_type_t v15 = "%{public}s called with null protocol->output_handler, no backtrace";
        goto LABEL_38;
      }
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
        os_log_type_t v15 = "%{public}s called with null protocol->output_handler, backtrace limit exceeded";
        goto LABEL_38;
      }
    }
    goto LABEL_39;
  }
  callbacks = output_handler->callbacks;
  if (!callbacks || (get_input_frames = (uint64_t (*)(void))callbacks->get_input_frames) == 0)
  {
    BOOL v10 = __nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_flow_passthrough_get_input_frames";
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s Output protocol handler does not support get_input_frames", buf, 0xCu);
    }

    return 0;
  }

  return get_input_frames();
}

nw_endpoint_t nw_flow_get_remote(nw_protocol *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = *((id *)a1->handle + 20);
  uint64_t v2 = v1;
  if (!v1)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_flow_get_remote";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v14, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v19 = os_log_type_enabled(v15, type);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v24 = "nw_flow_get_remote";
            __int16 v25 = 2082;
            uint64_t v26 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v24 = "nw_flow_get_remote";
          _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_35:
    if (v14) {
      free(v14);
    }
    goto LABEL_13;
  }
  int v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode == 2)
  {
    id v5 = nw_endpoint_handler_copy_flow(v3);
    BOOL v6 = v5;
    os_log_type_t v7 = (void *)*((void *)v5 + 121);
    if (v7)
    {
      nw_endpoint_t v8 = v7;
    }
    else
    {
      nw_endpoint_t v8 = (nw_endpoint_t)*((void *)v5 + 120);
      if (v8)
      {
        nw_flow_copy_flow_divert_endpoint(*((NWConcrete_nw_endpoint_flow **)v5 + 120));
      }
      else
      {
        BOOL v11 = nw_endpoint_flow_copy_path(v3);
        nw_endpoint_t v8 = nw_path_copy_effective_remote_endpoint(v11);
      }
    }

    goto LABEL_16;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v9 = (id)gLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      BOOL v10 = "unknown-mode";
    }
    else {
      BOOL v10 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v24 = "nw_flow_get_remote";
    __int16 v25 = 2082;
    uint64_t v26 = (void *)v10;
    __int16 v27 = 2082;
    BOOL v28 = "flow";
    _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_13:
  nw_endpoint_t v8 = 0;
LABEL_16:

  return v8;
}

void sub_1830FCBC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_path(void *a1)
{
  id v1 = a1;
  uint64_t v2 = nw_endpoint_handler_copy_flow(v1);
  int v3 = v2;
  id v5 = (id *)((char *)v2 + 16);
  unsigned int v4 = (void *)*((void *)v2 + 2);
  if (!v4)
  {
    os_log_type_t v7 = (void *)*((void *)v2 + 104);
    if (v7)
    {
      id v8 = (id)nw_path_flow_registration_copy_path(v7);
      if (v8)
      {
LABEL_5:
        os_unfair_lock_lock((os_unfair_lock_t)v3 + 220);
        objc_storeStrong(v5, v8);
        os_unfair_lock_unlock((os_unfair_lock_t)v3 + 220);
        id v6 = *((id *)v3 + 2);
LABEL_8:

        goto LABEL_9;
      }
    }
    else
    {
      id v8 = nw_endpoint_handler_copy_current_path(v1);
      if (v8) {
        goto LABEL_5;
      }
    }
    id v6 = 0;
    goto LABEL_8;
  }
  id v6 = v4;
LABEL_9:

  return v6;
}

void sub_1830FCC9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_handler *nw_endpoint_handler_copy_connected_flow_handler(void *a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    unsigned int v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          __int16 v32 = 2082;
          int v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_43;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_42:

    goto LABEL_43;
  }
  int v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    if (mode > 5) {
      id v8 = "unknown-mode";
    }
    else {
      id v8 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
    __int16 v32 = 2082;
    int v33 = (void *)v8;
    __int16 v34 = 2082;
    uint64_t v35 = "flow";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v10, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5) {
            char v13 = "unknown-mode";
          }
          else {
            char v13 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          __int16 v32 = 2082;
          int v33 = (void *)v13;
          __int16 v34 = 2082;
          uint64_t v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v28)
      {
        os_log_type_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            if (mode > 5) {
              __int16 v17 = "unknown-mode";
            }
            else {
              __int16 v17 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
            __int16 v32 = 2082;
            int v33 = (void *)v17;
            __int16 v34 = 2082;
            uint64_t v35 = "flow";
            __int16 v36 = 2082;
            char v37 = v14;
            _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v14);
          if (!v10) {
            goto LABEL_45;
          }
          goto LABEL_44;
        }
        if (v16)
        {
          if (mode > 5) {
            os_log_type_t v20 = "unknown-mode";
          }
          else {
            os_log_type_t v20 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          __int16 v32 = 2082;
          int v33 = (void *)v20;
          __int16 v34 = 2082;
          uint64_t v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5) {
            BOOL v19 = "unknown-mode";
          }
          else {
            BOOL v19 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          __int16 v31 = "nw_endpoint_handler_copy_connected_flow_handler";
          __int16 v32 = 2082;
          int v33 = (void *)v19;
          __int16 v34 = 2082;
          uint64_t v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_42;
    }
LABEL_43:
    if (!v10)
    {
LABEL_45:
      uint64_t v9 = 0;
      goto LABEL_46;
    }
LABEL_44:
    free(v10);
    goto LABEL_45;
  }
  id v5 = nw_endpoint_handler_copy_flow(v3);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
  if (*((unsigned char *)v5 + 32) & 2) != 0 || (*((unsigned char *)v5 + 33))
  {
    id v6 = v3;
  }
  else
  {
    if (!*((void *)v5 + 117))
    {
      uint64_t v9 = 0;
      goto LABEL_11;
    }
    id v6 = (NWConcrete_nw_endpoint_handler *)nw_endpoint_handler_copy_connected_flow_handler();
  }
  uint64_t v9 = v6;
LABEL_11:
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

LABEL_46:
  return v9;
}

void sub_1830FD338(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_flow(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    unsigned int v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v34 = "nw_endpoint_handler_copy_flow";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v24 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v34 = "nw_endpoint_handler_copy_flow";
            __int16 v35 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v24 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v34 = "nw_endpoint_handler_copy_flow";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_48:
    if (v23) {
      free(v23);
    }
    goto LABEL_30;
  }
  if (v1->mode != 2)
  {
    if ((*((unsigned char *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unsigned int v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if (*((unsigned char *)v2 + 268)) {
          id v5 = "dry-run ";
        }
        else {
          id v5 = "";
        }
        nw_endpoint_t v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        uint64_t state = v2->state;
        uint64_t v9 = logging_description;
        if (state > 5) {
          BOOL v10 = "unknown-state";
        }
        else {
          BOOL v10 = off_1E523FB38[state];
        }
        BOOL v30 = v10;
        BOOL v11 = v2;
        os_log_type_t v12 = (os_unfair_lock_s *)v11;
        char v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            char v13 = "resolver";
            break;
          case 2:
            char v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            char v13 = "proxy";
            break;
          case 4:
            char v13 = "fallback";
            break;
          case 5:
            char v13 = "transform";
            break;
          default:
            char v13 = "unknown-mode";
            break;
        }

        os_log_type_t v14 = v12 + 28;
        os_log_type_t v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        id v16 = v15[8];
        os_unfair_lock_unlock(v14);

        id v17 = v16;
        os_log_type_t v18 = v15;
        BOOL v19 = v18;
        os_log_type_t v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            os_log_type_t v20 = "resolver";
            break;
          case 2:
            os_log_type_t v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            os_log_type_t v20 = "proxy";
            break;
          case 4:
            os_log_type_t v20 = "fallback";
            break;
          case 5:
            os_log_type_t v20 = "transform";
            break;
          default:
            os_log_type_t v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        __int16 v34 = "nw_endpoint_handler_copy_flow";
        __int16 v35 = 2082;
        id_str = v2->id_str;
        __int16 v37 = 2082;
        uint64_t v38 = v5;
        __int16 v39 = 2082;
        id v40 = v9;
        __int16 v41 = 2082;
        nw_endpoint_t v42 = v30;
        __int16 v43 = 2082;
        id v44 = v13;
        __int16 v45 = 2114;
        id v46 = v17;
        __int16 v47 = 2082;
        char v48 = v20;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not a flow", buf, 0x52u);
      }
    }
LABEL_30:
    int v3 = 0;
    goto LABEL_31;
  }
  int v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

void sub_1830FD880(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_implementation_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle == &nw_protocol_ref_counted_handle) {
      os_log_type_t v14 = &a1[1].output_handler;
    }
    else {
      os_log_type_t v14 = 0;
    }
    os_log_type_t v15 = v14;
    id v16 = v15;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v17 = *((void *)v15 + 1);
      if (v17)
      {
        if (*(void *)(v17 + 80))
        {
          char v18 = v15[404];
          if ((v18 & 0x40) != 0)
          {
            v15[404] = v18 & 0xBF;
            nw_protocol_implementation_read((NWConcrete_nw_protocol_instance *)v15, a1->output_handler);
            char v18 = v16[404];
          }
          v16[404] = v18 | 0x20;
          BOOL v19 = a1->handle;
          if (v19 == &nw_protocol_ref_counted_handle) {
            os_log_type_t v20 = p_output_handler;
          }
          else {
            os_log_type_t v20 = 0;
          }
          char v21 = v20;
          unsigned int v22 = v21;
          if (v19 == &nw_protocol_ref_counted_handle)
          {
            os_log_type_t v23 = v21[1];
            if (v23)
            {
              if (v23[1].identifier)
              {
                uint64_t v115 = 0;
                id v116 = &v115;
                int v118 = 0;
                uint64_t v117 = 0x2020000000;
                if (*(_DWORD *)v23[1].flow_id != 3)
                {
                  int v33 = (nw_frame *)v21[23];
                  if (v33)
                  {
                    unsigned int v34 = *((_DWORD *)v21 + 51);
                    if (v34 >= a3)
                    {
                      if (v34 <= a4 && (unsigned int v35 = *((_DWORD *)v21 + 50), v35 <= a5))
                      {
                        *a6->tqh_last = v33;
                        v21[23]->handle = a6->tqh_last;
                        a6->tqh_last = (nw_frame **)v21[24];
                        v21[23] = 0;
                        v21[24] = (nw_protocol *)(v21 + 23);
                        *((_DWORD *)v116 + 6) = v35;
                        v21[25] = 0;
                      }
                      else
                      {
                        *(void *)os_log_type_t type = 0;
                        uint64_t v102 = (uint64_t)type;
                        uint64_t v103 = 0x2020000000;
                        LODWORD(v104) = a5;
                        uint64_t v111 = 0;
                        uint64_t v112 = &v111;
                        uint64_t v113 = 0x2020000000;
                        unsigned int v114 = a4;
                        *(void *)buf = MEMORY[0x1E4F143A8];
                        *(void *)&buf[8] = 3221225472;
                        *(void *)&buf[16] = ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_302;
                        int v120 = (const char *)&unk_1E523BFB0;
                        *((void *)&v121 + 1) = type;
                        v122 = &v111;
                        uint64_t v124 = a1;
                        *(void *)&long long v121 = v21;
                        char v123 = (nw_protocol *)&v115;
                        nw_endpoint_t v125 = a6;
                        __int16 v36 = v22;
                        __int16 v37 = v22[23];
                        do
                        {
                          if (!v37) {
                            break;
                          }
                          output_handler = v37->output_handler;
                          char v39 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
                          __int16 v37 = output_handler;
                        }
                        while ((v39 & 1) != 0);

                        unsigned int v22 = v36;
                        _Block_object_dispose(&v111, 8);
                        _Block_object_dispose(type, 8);
                      }
                      goto LABEL_51;
                    }
                  }
LABEL_195:
                  uint64_t v44 = 0;
                  goto LABEL_196;
                }
                os_log_type_t v100 = v16;
                if (a2)
                {
                  output_handler_context = (char *)a2->output_handler_context;
                  if (output_handler_context)
                  {
                    if ((*((_WORD *)output_handler_context + 42) & 2) == 0) {
                      *((unsigned char *)v21 + 402) |= 0x10u;
                    }
                    BOOL v26 = (uint64_t *)(output_handler_context + 48);
                    uint64_t v25 = *((void *)output_handler_context + 6);
                    if (v25)
                    {
                      id v99 = v21;
                      uint64_t v111 = 0;
                      uint64_t v112 = &v111;
                      uint64_t v113 = 0x2020000000;
                      unsigned int v114 = a5;
                      v109[0] = 0;
                      v109[1] = v109;
                      v109[2] = 0x2020000000;
                      unsigned int v110 = a4;
                      *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
                      uint64_t v102 = 3221225472;
                      uint64_t v103 = (uint64_t)___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
                      nw_endpoint_t v104 = &unk_1E523BF60;
                      BOOL v105 = &v111;
                      nw_endpoint_t v106 = &v115;
                      v107 = output_handler_context + 32;
                      id v108 = a6;
                      do
                      {
                        if (!v25) {
                          break;
                        }
                        uint64_t v27 = *(void *)(v25 + 32);
                        char v28 = ((uint64_t (*)(os_log_type_t *))v103)(type);
                        uint64_t v25 = v27;
                      }
                      while ((v28 & 1) != 0);
                      unsigned int v29 = *((_DWORD *)output_handler_context + 17);
                      if (v29 < a3)
                      {
                        if ((*((char *)v99 + 405) & 0x80000000) == 0 && gLogDatapath)
                        {
                          unsigned int v30 = *((_DWORD *)output_handler_context + 17);
                          char v31 = __nwlog_obj();
                          if (os_log_type_enabled(v31, OS_LOG_TYPE_DEBUG))
                          {
                            int v32 = *((_DWORD *)output_handler_context + 17);
                            *(_DWORD *)buf = 136447234;
                            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                            *(_WORD *)&unsigned char buf[12] = 2082;
                            *(void *)&buf[14] = (char *)v99 + 407;
                            *(_WORD *)&buf[22] = 2080;
                            int v120 = " ";
                            LOWORD(v121) = 1024;
                            *(_DWORD *)((char *)&v121 + 2) = v32;
                            WORD3(v121) = 1024;
                            DWORD2(v121) = a3;
                            _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sPending inbound bytes %u < minimum bytes %u", buf, 0x2Cu);
                          }

                          unsigned int v29 = v30;
                        }
                        goto LABEL_50;
                      }
                      if (v29 <= a4)
                      {
                        unsigned int v41 = *((_DWORD *)output_handler_context + 16);
                        uint64_t v40 = *((void *)output_handler_context + 6);
                        if (v41 <= a5)
                        {
                          if (v40)
                          {
                            *a6->tqh_last = (nw_frame *)v40;
                            *(void *)(*((void *)output_handler_context + 6) + 40) = a6->tqh_last;
                            a6->tqh_last = (nw_frame **)*((void *)output_handler_context + 7);
                            *((void *)output_handler_context + 6) = 0;
                            *((void *)output_handler_context + 7) = v26;
                          }
                          *((_DWORD *)v116 + 6) = v41;
                          *((void *)output_handler_context + 8) = 0;
LABEL_50:
                          _Block_object_dispose(v109, 8);
                          _Block_object_dispose(&v111, 8);
                          id v16 = v100;
                          unsigned int v22 = v99;
                          if (v29 >= a3)
                          {
LABEL_51:
                            uint64_t v44 = *((unsigned int *)v116 + 6);
LABEL_196:
                            _Block_object_dispose(&v115, 8);
LABEL_197:

LABEL_198:
                            return v44;
                          }
                          goto LABEL_195;
                        }
                      }
                      else
                      {
                        uint64_t v40 = *v26;
                      }
                      *(void *)buf = MEMORY[0x1E4F143A8];
                      *(void *)&buf[8] = 3221225472;
                      *(void *)&buf[16] = ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_301;
                      int v120 = (const char *)&unk_1E523BF88;
                      *(void *)&long long v121 = &v111;
                      *((void *)&v121 + 1) = v109;
                      v122 = &v115;
                      char v123 = a1;
                      uint64_t v124 = (nw_protocol *)(output_handler_context + 32);
                      nw_endpoint_t v125 = a6;
                      do
                      {
                        if (!v40) {
                          break;
                        }
                        uint64_t v42 = *(void *)(v40 + 32);
                        char v43 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
                        uint64_t v40 = v42;
                      }
                      while ((v43 & 1) != 0);
                      goto LABEL_50;
                    }
LABEL_200:
                    uint64_t v44 = 0;
                    id v16 = v100;
                    goto LABEL_196;
                  }
LABEL_191:
                  if ((*((char *)v22 + 405) & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    v97 = (id)gLogObj;
                    id v16 = v100;
                    if (os_log_type_enabled(v97, OS_LOG_TYPE_ERROR))
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = (char *)v22 + 407;
                      *(_WORD *)&buf[22] = 2080;
                      int v120 = " ";
                      LOWORD(v121) = 2048;
                      *(void *)((char *)&v121 + 2) = a2;
                      _os_log_impl(&dword_1830D4000, v97, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p", buf, 0x2Au);
                    }

                    goto LABEL_195;
                  }
                  goto LABEL_200;
                }
                int v80 = __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                char v81 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                LOBYTE(v111) = 0;
                if (__nwlog_fault(v81, type, &v111))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v82 = __nwlog_obj();
                    os_log_type_t v83 = type[0];
                    if (os_log_type_enabled(v82, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                      _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null protocol", buf, 0xCu);
                    }
                  }
                  else if ((_BYTE)v111)
                  {
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    BOOL v82 = __nwlog_obj();
                    os_log_type_t v87 = type[0];
                    BOOL v88 = os_log_type_enabled(v82, type[0]);
                    if (backtrace_string)
                    {
                      if (v88)
                      {
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                        *(_WORD *)&unsigned char buf[12] = 2082;
                        *(void *)&buf[14] = backtrace_string;
                        _os_log_impl(&dword_1830D4000, v82, v87, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      free(backtrace_string);
                      goto LABEL_189;
                    }
                    if (v88)
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                      _os_log_impl(&dword_1830D4000, v82, v87, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
                    }
                  }
                  else
                  {
                    BOOL v82 = __nwlog_obj();
                    os_log_type_t v96 = type[0];
                    if (os_log_type_enabled(v82, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_get_output_handler_context";
                      _os_log_impl(&dword_1830D4000, v82, v96, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
                    }
                  }
                }
LABEL_189:
                if (v81) {
                  free(v81);
                }
                goto LABEL_191;
              }
              int v63 = __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
              id v58 = (char *)_os_log_send_and_compose_impl();

              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v115) = 0;
              if (__nwlog_fault(v58, type, &v115))
              {
                if (type[0] == OS_LOG_TYPE_FAULT)
                {
                  id v59 = __nwlog_obj();
                  os_log_type_t v64 = type[0];
                  if (os_log_type_enabled(v59, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                    _os_log_impl(&dword_1830D4000, v59, v64, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
                  }
LABEL_179:

                  goto LABEL_180;
                }
                if (!(_BYTE)v115)
                {
                  id v59 = __nwlog_obj();
                  os_log_type_t v95 = type[0];
                  if (os_log_type_enabled(v59, type[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                    _os_log_impl(&dword_1830D4000, v59, v95, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
                  }
                  goto LABEL_179;
                }
                v75 = (char *)__nw_create_backtrace_string();
                id v59 = __nwlog_obj();
                os_log_type_t v84 = type[0];
                BOOL v85 = os_log_type_enabled(v59, type[0]);
                if (!v75)
                {
                  if (v85)
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                    _os_log_impl(&dword_1830D4000, v59, v84, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
                  }
                  goto LABEL_179;
                }
                if (v85)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v75;
                  _os_log_impl(&dword_1830D4000, v59, v84, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
                }
                goto LABEL_126;
              }
LABEL_180:
              if (v58) {
                free(v58);
              }
              uint64_t v44 = 0;
              goto LABEL_197;
            }
            id v61 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
            id v58 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v115) = 0;
            if (!__nwlog_fault(v58, type, &v115)) {
              goto LABEL_180;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              id v59 = __nwlog_obj();
              os_log_type_t v62 = type[0];
              if (os_log_type_enabled(v59, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null instance->parent_definition", buf, 0xCu);
              }
              goto LABEL_179;
            }
            if (!(_BYTE)v115)
            {
              id v59 = __nwlog_obj();
              os_log_type_t v94 = type[0];
              if (os_log_type_enabled(v59, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_1830D4000, v59, v94, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_179;
            }
            v75 = (char *)__nw_create_backtrace_string();
            id v59 = __nwlog_obj();
            os_log_type_t v78 = type[0];
            BOOL v79 = os_log_type_enabled(v59, type[0]);
            if (!v75)
            {
              if (v79)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_1830D4000, v59, v78, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
              }
              goto LABEL_179;
            }
            if (v79)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v75;
              _os_log_impl(&dword_1830D4000, v59, v78, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
          else
          {
            id v57 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
            id v58 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v115) = 0;
            if (!__nwlog_fault(v58, type, &v115)) {
              goto LABEL_180;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              id v59 = __nwlog_obj();
              os_log_type_t v60 = type[0];
              if (os_log_type_enabled(v59, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null instance", buf, 0xCu);
              }
              goto LABEL_179;
            }
            if (!(_BYTE)v115)
            {
              id v59 = __nwlog_obj();
              os_log_type_t v93 = type[0];
              if (os_log_type_enabled(v59, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_1830D4000, v59, v93, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
              }
              goto LABEL_179;
            }
            v75 = (char *)__nw_create_backtrace_string();
            id v59 = __nwlog_obj();
            os_log_type_t v76 = type[0];
            BOOL v77 = os_log_type_enabled(v59, type[0]);
            if (!v75)
            {
              if (v77)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
                _os_log_impl(&dword_1830D4000, v59, v76, "%{public}s called with null instance, no backtrace", buf, 0xCu);
              }
              goto LABEL_179;
            }
            if (v77)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_service_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v75;
              _os_log_impl(&dword_1830D4000, v59, v76, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
            }
          }
LABEL_126:

          free(v75);
          goto LABEL_180;
        }
        nw_endpoint_t v55 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        nw_endpoint_t v50 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        LOBYTE(v115) = 0;
        if (__nwlog_fault(v50, type, &v115))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            nw_endpoint_t v51 = __nwlog_obj();
            os_log_type_t v56 = type[0];
            if (os_log_type_enabled(v51, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
              _os_log_impl(&dword_1830D4000, v51, v56, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
            }
LABEL_167:

            goto LABEL_168;
          }
          if (!(_BYTE)v115)
          {
            nw_endpoint_t v51 = __nwlog_obj();
            os_log_type_t v92 = type[0];
            if (os_log_type_enabled(v51, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
              _os_log_impl(&dword_1830D4000, v51, v92, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_167;
          }
          id v68 = (char *)__nw_create_backtrace_string();
          nw_endpoint_t v51 = __nwlog_obj();
          os_log_type_t v73 = type[0];
          BOOL v74 = os_log_type_enabled(v51, type[0]);
          if (!v68)
          {
            if (v74)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
              _os_log_impl(&dword_1830D4000, v51, v73, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
            }
            goto LABEL_167;
          }
          if (v74)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v68;
            _os_log_impl(&dword_1830D4000, v51, v73, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
          }
          goto LABEL_106;
        }
LABEL_168:
        if (v50) {
          free(v50);
        }
        uint64_t v44 = 0;
        goto LABEL_198;
      }
      id v53 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
      nw_endpoint_t v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v115) = 0;
      if (!__nwlog_fault(v50, type, &v115)) {
        goto LABEL_168;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v51 = __nwlog_obj();
        os_log_type_t v54 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          _os_log_impl(&dword_1830D4000, v51, v54, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }
        goto LABEL_167;
      }
      if (!(_BYTE)v115)
      {
        nw_endpoint_t v51 = __nwlog_obj();
        os_log_type_t v91 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          _os_log_impl(&dword_1830D4000, v51, v91, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_167;
      }
      id v68 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v51 = __nwlog_obj();
      os_log_type_t v71 = type[0];
      BOOL v72 = os_log_type_enabled(v51, type[0]);
      if (!v68)
      {
        if (v72)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          _os_log_impl(&dword_1830D4000, v51, v71, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_167;
      }
      if (v72)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v68;
        _os_log_impl(&dword_1830D4000, v51, v71, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      uint64_t v49 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
      nw_endpoint_t v50 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v115) = 0;
      if (!__nwlog_fault(v50, type, &v115)) {
        goto LABEL_168;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v51 = __nwlog_obj();
        os_log_type_t v52 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_167;
      }
      if (!(_BYTE)v115)
      {
        nw_endpoint_t v51 = __nwlog_obj();
        os_log_type_t v90 = type[0];
        if (os_log_type_enabled(v51, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          _os_log_impl(&dword_1830D4000, v51, v90, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_167;
      }
      id v68 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v51 = __nwlog_obj();
      os_log_type_t v69 = type[0];
      BOOL v70 = os_log_type_enabled(v51, type[0]);
      if (!v68)
      {
        if (v70)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          _os_log_impl(&dword_1830D4000, v51, v69, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_167;
      }
      if (v70)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v68;
        _os_log_impl(&dword_1830D4000, v51, v69, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
LABEL_106:

    free(v68);
    goto LABEL_168;
  }
  __int16 v45 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
  id v46 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v115) = 0;
  if (__nwlog_fault(v46, type, &v115))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v47 = __nwlog_obj();
      os_log_type_t v48 = type[0];
      if (os_log_type_enabled(v47, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if ((_BYTE)v115)
    {
      uint64_t v65 = (char *)__nw_create_backtrace_string();
      __int16 v47 = __nwlog_obj();
      os_log_type_t v66 = type[0];
      BOOL v67 = os_log_type_enabled(v47, type[0]);
      if (v65)
      {
        if (v67)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v65;
          _os_log_impl(&dword_1830D4000, v47, v66, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v65);
        goto LABEL_156;
      }
      if (v67)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        _os_log_impl(&dword_1830D4000, v47, v66, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v47 = __nwlog_obj();
      os_log_type_t v89 = type[0];
      if (os_log_type_enabled(v47, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_frames";
        _os_log_impl(&dword_1830D4000, v47, v89, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_156:
  if (v46) {
    free(v46);
  }
  return 0;
}

void sub_1830FEF18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_http2_transport_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, int a5, nw_frame_array_s *a6)
{
  v84[2] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = (char *)a1->handle;
    if (handle)
    {
      if (gLogDatapath)
      {
        uint64_t v42 = __nwlog_obj();
        if (os_log_type_enabled(v42, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)BOOL v82 = 136447234;
          *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
          *(_WORD *)&v82[12] = 2082;
          *(void *)&v82[14] = handle + 205;
          *(_WORD *)&v82[22] = 1024;
          LODWORD(v83) = a3;
          WORD2(v83) = 1024;
          *(_DWORD *)((char *)&v83 + 6) = a4;
          WORD5(v83) = 1024;
          HIDWORD(v83) = a5;
          _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called min_bytes: %u, max_bytes: %u, max_frame_count: %u", v82, 0x28u);
        }
      }
      *(void *)BOOL v82 = 0;
      *(void *)&v82[8] = v82;
      *(void *)&v82[16] = 0x3802000000;
      *(void *)&long long v83 = __Block_byref_object_copy__38426;
      *((void *)&v83 + 1) = __Block_byref_object_dispose__38427;
      v84[0] = 0;
      v84[1] = v84;
      a6->os_log_type_t tqh_first = 0;
      a6->tqh_last = &a6->tqh_first;
      if (a2)
      {
        output_handler_context = a2->output_handler_context;
        if (output_handler_context)
        {
          char v13 = (void *)output_handler_context[4];
          if (v13)
          {
            *(void *)os_log_type_t type = 0;
            os_log_type_t v71 = type;
            int v73 = 0;
            uint64_t v72 = 0x2000000000;
            uint64_t v66 = 0;
            BOOL v67 = &v66;
            int v69 = 0;
            uint64_t v68 = 0x2000000000;
            v55[0] = MEMORY[0x1E4F143A8];
            v55[1] = 0x40000000;
            os_log_type_t v56 = ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            id v57 = &unk_1E5240B38;
            id v58 = type;
            id v59 = &v66;
            int v64 = a5;
            int v65 = a4;
            os_log_type_t v60 = v82;
            id v61 = handle;
            os_log_type_t v62 = v13;
            int v63 = a6;
            uint64_t v14 = *v13;
            do
            {
              if (!v14) {
                break;
              }
              uint64_t v15 = *(void *)(v14 + 16);
              char v16 = ((uint64_t (*)(void *))v56)(v55);
              uint64_t v14 = v15;
            }
            while ((v16 & 1) != 0);
            if (*((_DWORD *)v67 + 6) >= a3)
            {
              uint64_t v32 = *(void *)&v82[8];
              uint64_t v33 = *(void *)&v82[8] + 40;
              uint64_t v34 = *(void *)(*(void *)&v82[8] + 40);
              if (v34)
              {
                **((void **)handle + 19) = v34;
                *(void *)(*(void *)(v32 + 40) + 24) = *((void *)handle + 19);
                *((void *)handle + 19) = *(void *)(v32 + 48);
                *(void *)(v32 + 40) = 0;
                *(void *)(v32 + 48) = v33;
              }
              if (gLogDatapath)
              {
                os_log_type_t v48 = __nwlog_obj();
                if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
                {
                  int v49 = *((_DWORD *)v71 + 6);
                  int v50 = *((_DWORD *)v67 + 6);
                  *(_DWORD *)buf = 136446978;
                  v75 = "nw_protocol_http2_transport_get_input_frames";
                  __int16 v76 = 2082;
                  BOOL v77 = handle + 205;
                  __int16 v78 = 1024;
                  int v79 = v49;
                  __int16 v80 = 1024;
                  LODWORD(v81) = v50;
                  _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s returning %u frames (%u total bytes)", buf, 0x22u);
                }
              }
              uint64_t v22 = *((unsigned int *)v71 + 6);
            }
            else
            {
              if (*((_DWORD *)v71 + 6))
              {
                uint64_t v17 = *(void *)&v82[8];
                char v18 = (void *)(*(void *)&v82[8] + 40);
                if (*v13)
                {
                  **(void **)(*(void *)&v82[8] + 48) = *v13;
                  *(void *)(*v13 + 24) = *(void *)(v17 + 48);
                  *(void *)(v17 + 48) = v13[1];
                  *char v13 = 0;
                  v13[1] = v13;
                }
                if (*v18)
                {
                  *(void *)v13[1] = *v18;
                  *(void *)(*(void *)(v17 + 40) + 24) = v13[1];
                  v13[1] = *(void *)(v17 + 48);
                  *(void *)(v17 + 40) = 0;
                  *(void *)(v17 + 48) = v18;
                }
                v51[0] = MEMORY[0x1E4F143A8];
                v51[1] = 0x40000000;
                os_log_type_t v52 = ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_40;
                id v53 = &__block_descriptor_tmp_41_38435;
                os_log_type_t v54 = a6;
                os_log_type_t tqh_first = a6->tqh_first;
                do
                {
                  if (!tqh_first) {
                    break;
                  }
                  os_log_type_t v20 = (nw_frame *)*((void *)tqh_first + 4);
                  char v21 = ((uint64_t (*)(void *))v52)(v51);
                  os_log_type_t tqh_first = v20;
                }
                while ((v21 & 1) != 0);
                a6->os_log_type_t tqh_first = 0;
                a6->tqh_last = &a6->tqh_first;
              }
              if (gLogDatapath && (__int16 v47 = __nwlog_obj(), os_log_type_enabled(v47, OS_LOG_TYPE_DEBUG)))
              {
                *(_DWORD *)buf = 136446722;
                v75 = "nw_protocol_http2_transport_get_input_frames";
                __int16 v76 = 2082;
                BOOL v77 = handle + 205;
                __int16 v78 = 1024;
                int v79 = a3;
                _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s failed to find enough (%u) bytes to return, returning 0 frames", buf, 0x1Cu);
                uint64_t v22 = 0;
              }
              else
              {
                uint64_t v22 = 0;
              }
            }
            _Block_object_dispose(&v66, 8);
            _Block_object_dispose(type, 8);
            goto LABEL_45;
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v23 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          v75 = "nw_protocol_http2_transport_get_input_frames";
          __int16 v76 = 2082;
          BOOL v77 = handle + 205;
          __int16 v78 = 1042;
          int v79 = 16;
          __int16 v80 = 2098;
          char v81 = a2;
          _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s %{public}s can't find hash table entry for %{public,uuid_t}.16P", buf, 0x26u);
        }
LABEL_44:
        uint64_t v22 = 0;
LABEL_45:
        _Block_object_dispose(v82, 8);
        return v22;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      v75 = "nw_protocol_http2_transport_get_input_frames";
      os_log_type_t v24 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v66) = 0;
      if (__nwlog_fault(v24, type, &v66))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v25 = gLogObj;
          os_log_type_t v26 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_42;
          }
          *(_DWORD *)buf = 136446210;
          v75 = "nw_protocol_http2_transport_get_input_frames";
          uint64_t v27 = "%{public}s called with null input_protocol";
LABEL_40:
          unsigned int v35 = v25;
          os_log_type_t v36 = v26;
LABEL_41:
          _os_log_impl(&dword_1830D4000, v35, v36, v27, buf, 0xCu);
          goto LABEL_42;
        }
        if (!(_BYTE)v66)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v25 = gLogObj;
          os_log_type_t v26 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_42;
          }
          *(_DWORD *)buf = 136446210;
          v75 = "nw_protocol_http2_transport_get_input_frames";
          uint64_t v27 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_40;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        unsigned int v29 = gLogObj;
        os_log_type_t v30 = type[0];
        BOOL v31 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            v75 = "nw_protocol_http2_transport_get_input_frames";
            __int16 v76 = 2082;
            BOOL v77 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_42;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          v75 = "nw_protocol_http2_transport_get_input_frames";
          uint64_t v27 = "%{public}s called with null input_protocol, no backtrace";
          unsigned int v35 = v29;
          os_log_type_t v36 = v30;
          goto LABEL_41;
        }
      }
LABEL_42:
      if (v24) {
        free(v24);
      }
      goto LABEL_44;
    }
    __nwlog_obj();
    *(_DWORD *)BOOL v82 = 136446210;
    *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();
    buf[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v38, buf, type)) {
      goto LABEL_82;
    }
    if (buf[0] == 17)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = buf[0];
      if (os_log_type_enabled(v39, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)BOOL v82 = 136446210;
        *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
        unsigned int v41 = "%{public}s called with null http2_transport";
        goto LABEL_81;
      }
      goto LABEL_82;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = buf[0];
      if (os_log_type_enabled(v39, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)BOOL v82 = 136446210;
        *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
        unsigned int v41 = "%{public}s called with null http2_transport, backtrace limit exceeded";
        goto LABEL_81;
      }
      goto LABEL_82;
    }
    char v43 = (char *)__nw_create_backtrace_string();
    char v39 = __nwlog_obj();
    os_log_type_t v40 = buf[0];
    BOOL v46 = os_log_type_enabled(v39, (os_log_type_t)buf[0]);
    if (!v43)
    {
      if (v46)
      {
        *(_DWORD *)BOOL v82 = 136446210;
        *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
        unsigned int v41 = "%{public}s called with null http2_transport, no backtrace";
        goto LABEL_81;
      }
      goto LABEL_82;
    }
    if (v46)
    {
      *(_DWORD *)BOOL v82 = 136446466;
      *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
      *(_WORD *)&v82[12] = 2082;
      *(void *)&v82[14] = v43;
      __int16 v45 = "%{public}s called with null http2_transport, dumping backtrace:%{public}s";
      goto LABEL_67;
    }
    goto LABEL_68;
  }
  __nwlog_obj();
  *(_DWORD *)BOOL v82 = 136446210;
  *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
  uint64_t v38 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v38, buf, type)) {
    goto LABEL_82;
  }
  if (buf[0] != 17)
  {
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      char v39 = __nwlog_obj();
      os_log_type_t v40 = buf[0];
      if (os_log_type_enabled(v39, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)BOOL v82 = 136446210;
        *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
        unsigned int v41 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_81;
      }
      goto LABEL_82;
    }
    char v43 = (char *)__nw_create_backtrace_string();
    char v39 = __nwlog_obj();
    os_log_type_t v40 = buf[0];
    BOOL v44 = os_log_type_enabled(v39, (os_log_type_t)buf[0]);
    if (!v43)
    {
      if (v44)
      {
        *(_DWORD *)BOOL v82 = 136446210;
        *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
        unsigned int v41 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_81;
      }
      goto LABEL_82;
    }
    if (v44)
    {
      *(_DWORD *)BOOL v82 = 136446466;
      *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
      *(_WORD *)&v82[12] = 2082;
      *(void *)&v82[14] = v43;
      __int16 v45 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_67:
      _os_log_impl(&dword_1830D4000, v39, v40, v45, v82, 0x16u);
    }
LABEL_68:
    free(v43);
    goto LABEL_82;
  }
  char v39 = __nwlog_obj();
  os_log_type_t v40 = buf[0];
  if (os_log_type_enabled(v39, (os_log_type_t)buf[0]))
  {
    *(_DWORD *)BOOL v82 = 136446210;
    *(void *)&v82[4] = "nw_protocol_http2_transport_get_input_frames";
    unsigned int v41 = "%{public}s called with null protocol";
LABEL_81:
    _os_log_impl(&dword_1830D4000, v39, v40, v41, v82, 0xCu);
  }
LABEL_82:
  if (v38) {
    free(v38);
  }
  return 0;
}

void nw_protocol_release(void *a1)
{
  if (a1)
  {
    if ((_UNKNOWN *)a1[5] == &nw_protocol_ref_counted_handle)
    {
      uint64_t v2 = a1[11];
      if (v2)
      {
        uint64_t v3 = v2 - 1;
        a1[11] = v3;
        if (!v3)
        {
          unsigned int v4 = (void (**)(void))a1[8];
          if (v4)
          {
            a1[8] = 0;
            v4[2](v4);
            _Block_release(v4);
          }
          if (a1[9])
          {
            id v5 = (const void *)a1[8];
            if (v5) {
              _Block_release(v5);
            }
          }
          free(a1);
        }
      }
    }
  }
}

void sub_1831000F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18310195C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_array_create()
{
  objc_opt_class();
  uint64_t v0 = _os_object_alloc();
  uint64_t v1 = v0;
  if (v0)
  {
    *(void *)(v0 + 16) = 0;
    *(void *)(v0 + 24) = 0;
    *(void *)(v0 + 32) = 0;
    atomic_store(0, (unsigned __int8 *)(v0 + 40));
    return v1;
  }
  uint64_t v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  unsigned int v4 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v4);
  if (!result)
  {
    free(v4);
    return v1;
  }
  __break(1u);
  return result;
}

NWConcrete_nw_protocol_stack *nw_protocol_stack_copy(void *a1)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = objc_alloc_init(NWConcrete_nw_protocol_stack);
  if (v2)
  {
    if (v1[1])
    {
      BOOL v3 = nw_array_create();
      persistent_application_protocols = v2->persistent_application_protocols;
      v2->persistent_application_protocols = (OS_nw_array *)v3;

      id v5 = (atomic_uchar *)v1[1];
      v33[0] = MEMORY[0x1E4F143A8];
      v33[1] = 3221225472;
      v33[2] = __nw_protocol_stack_copy_block_invoke;
      v33[3] = &unk_1E524AE18;
      uint64_t v34 = v2;
      nw_array_apply(v5, (uint64_t)v33);
    }
    if (v1[2])
    {
      BOOL v6 = nw_array_create();
      application_protocols = v2->application_protocols;
      v2->application_protocols = (OS_nw_array *)v6;

      id v8 = (atomic_uchar *)v1[2];
      v31[0] = MEMORY[0x1E4F143A8];
      v31[1] = 3221225472;
      v31[2] = __nw_protocol_stack_copy_block_invoke_2;
      v31[3] = &unk_1E524AE18;
      uint64_t v32 = v2;
      nw_array_apply(v8, (uint64_t)v31);
    }
    uint64_t v9 = (void *)v1[3];
    if (v9)
    {
      BOOL v10 = nw_protocol_options_copy(v9);
      transport_uint64_t protocol = v2->transport_protocol;
      v2->transport_uint64_t protocol = (OS_nw_protocol_options *)v10;
    }
    os_log_type_t v12 = (void *)v1[4];
    if (v12)
    {
      char v13 = nw_protocol_options_copy(v12);
      secondary_transport_uint64_t protocol = v2->secondary_transport_protocol;
      v2->secondary_transport_uint64_t protocol = (OS_nw_protocol_options *)v13;
    }
    uint64_t v15 = (void *)v1[5];
    if (v15)
    {
      char v16 = nw_protocol_options_copy(v15);
      original_proxied_transport_uint64_t protocol = v2->original_proxied_transport_protocol;
      v2->original_proxied_transport_uint64_t protocol = (OS_nw_protocol_options *)v16;
    }
    char v18 = (void *)v1[6];
    if (v18)
    {
      BOOL v19 = nw_protocol_options_copy(v18);
      internet_uint64_t protocol = v2->internet_protocol;
      v2->internet_uint64_t protocol = (OS_nw_protocol_options *)v19;
    }
    char v21 = v2;
    goto LABEL_22;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v22 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v38 = "nw_protocol_stack_copy";
  os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v36 = OS_LOG_TYPE_ERROR;
  char v35 = 0;
  if (!__nwlog_fault(v23, &v36, &v35)) {
    goto LABEL_20;
  }
  if (v36 == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v24 = (id)gLogObj;
    os_log_type_t v25 = v36;
    if (os_log_type_enabled(v24, v36))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v38 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s [[nw_protocol_stack alloc] init] failed", buf, 0xCu);
    }
LABEL_19:

LABEL_20:
    if (!v23) {
      goto LABEL_22;
    }
LABEL_21:
    free(v23);
    goto LABEL_22;
  }
  if (!v35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v24 = (id)gLogObj;
    os_log_type_t v30 = v36;
    if (os_log_type_enabled(v24, v36))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v38 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_1830D4000, v24, v30, "%{public}s [[nw_protocol_stack alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_19;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v24 = (id)gLogObj;
  os_log_type_t v28 = v36;
  BOOL v29 = os_log_type_enabled(v24, v36);
  if (!backtrace_string)
  {
    if (v29)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v38 = "nw_protocol_stack_copy";
      _os_log_impl(&dword_1830D4000, v24, v28, "%{public}s [[nw_protocol_stack alloc] init] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_19;
  }
  if (v29)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v38 = "nw_protocol_stack_copy";
    __int16 v39 = 2082;
    os_log_type_t v40 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v24, v28, "%{public}s [[nw_protocol_stack alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v23) {
    goto LABEL_21;
  }
LABEL_22:

  return v2;
}

void sub_183101F48(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_protocol_options_copy(void *a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = [NWConcrete_nw_protocol_options alloc];
  id v3 = v1;
  id v4 = v3;
  if (!v2) {
    goto LABEL_12;
  }
  if (!v3)
  {
    uint64_t v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
    char v16 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v32.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v16, &v32, &type))
    {
      if (LOBYTE(v32.receiver) == 17)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t receiver = (os_log_type_t)v32.receiver;
        if (os_log_type_enabled(v17, (os_log_type_t)v32.receiver))
        {
          *(_DWORD *)buf = 136446210;
          char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_1830D4000, v17, receiver, "%{public}s called with null _options", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v24 = (os_log_type_t)v32.receiver;
        BOOL v25 = os_log_type_enabled(v17, (os_log_type_t)v32.receiver);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
            __int16 v36 = 2082;
            __int16 v37 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v17, v24, "%{public}s called with null _options, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_1830D4000, v17, v24, "%{public}s called with null _options, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v29 = (os_log_type_t)v32.receiver;
        if (os_log_type_enabled(v17, (os_log_type_t)v32.receiver))
        {
          *(_DWORD *)buf = 136446210;
          char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_1830D4000, v17, v29, "%{public}s called with null _options, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (v16) {
      free(v16);
    }

    goto LABEL_50;
  }
  v32.os_log_type_t receiver = v2;
  v32.super_class = (Class)NWConcrete_nw_protocol_options;
  id v5 = (NWConcrete_nw_protocol_options *)objc_msgSendSuper2(&v32, sel_init);
  uint64_t v2 = v5;
  if (!v5)
  {
    BOOL v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
    os_log_type_t v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v20, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v31)
      {
        os_log_type_t v26 = (char *)__nw_create_backtrace_string();
        char v21 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v21, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
            __int16 v36 = 2082;
            __int16 v37 = v26;
            _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v26);
          goto LABEL_48;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_1830D4000, v21, v27, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v21 = __nwlog_obj();
        os_log_type_t v30 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          char v35 = "-[NWConcrete_nw_protocol_options initWithOptions:]";
          _os_log_impl(&dword_1830D4000, v21, v30, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_48:
    if (v20) {
      free(v20);
    }
LABEL_50:
    uint64_t v2 = 0;
    goto LABEL_12;
  }
  objc_storeStrong((id *)&v5->definition, *((id *)v4 + 1));
  objc_storeStrong((id *)&v2->proxy_endpoint, *((id *)v4 + 3));
  uint64_t v6 = *((void *)v4 + 4);
  if (v6)
  {
    uint64_t v7 = nw_array_create();
    if (v7 != v6)
    {
      uint64_t v8 = v7;
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v7 + 16, *(void ***)(v6 + 16), *(void ***)(v6 + 24), (uint64_t)(*(void *)(v6 + 24) - *(void *)(v6 + 16)) >> 3);
      uint64_t v6 = v8;
    }
    proxy_next_hops = v2->proxy_next_hops;
    v2->proxy_next_hops = (OS_nw_array *)v6;
  }
  v2->override_stack_endpoint = *((unsigned char *)v4 + 152);
  v2->prohibit_joining = *((unsigned char *)v4 + 153);
  BOOL v10 = *(uint64_t (**)(void))(*((void *)v4 + 1) + 96);
  if (v10) {
    v2->handle = (void *)v10();
  }
  BOOL v11 = (void *)*((void *)v4 + 5);
  if (v11)
  {
    os_log_type_t v12 = (OS_xpc_object *)xpc_copy(v11);
    legacy_parameters = v2->legacy_parameters;
    v2->legacy_parameters = v12;
  }
LABEL_12:

  return v2;
}

void sub_1831024EC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ip_copy_options(void *a1, _OWORD *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    uint64_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v19 = "nw_ip_copy_options";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_ip_copy_options";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v19 = "nw_ip_copy_options";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_ip_copy_options";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v8 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_ip_copy_options";
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v7) {
      free(v7);
    }
    id v4 = 0;
    goto LABEL_4;
  }
  id v4 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    void *v4 = 0;
    v4[1] = 0;
    *(_OWORD *)id v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }
  BOOL v10 = __nwlog_obj();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  BOOL v19 = "strict_calloc";
  __int16 v20 = 2048;
  uint64_t v21 = 1;
  __int16 v22 = 2048;
  uint64_t v23 = 16;
  BOOL v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_18310287C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_tcp_copy_options(void *a1, long long *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_tcp_copy_options";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v9, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "nw_tcp_copy_options";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v21 = "nw_tcp_copy_options";
            __int16 v22 = 2082;
            uint64_t v23 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "nw_tcp_copy_options";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v10 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "nw_tcp_copy_options";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v9) {
      free(v9);
    }
    id v4 = 0;
    goto LABEL_4;
  }
  id v4 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    v4[4] = 0;
    *(_OWORD *)id v4 = 0u;
    *((_OWORD *)v4 + 1) = 0u;
    long long v5 = *a2;
    long long v6 = a2[1];
    v4[4] = *((void *)a2 + 4);
    *(_OWORD *)id v4 = v5;
    *((_OWORD *)v4 + 1) = v6;
LABEL_4:

    return (BOOL)v4;
  }
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  uint64_t v21 = "strict_calloc";
  __int16 v22 = 2048;
  uint64_t v23 = 1;
  __int16 v24 = 2048;
  uint64_t v25 = 40;
  os_log_type_t v13 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_183103164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_copy_options(void *a1, uint64_t a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    uint64_t v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_quic_connection_copy_options_internal";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v27, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_quic_connection_copy_options_internal";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        BOOL v34 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v39 = "nw_quic_connection_copy_options_internal";
            __int16 v40 = 2082;
            uint64_t v41 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_quic_connection_copy_options_internal";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v28 = __nwlog_obj();
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v39 = "nw_quic_connection_copy_options_internal";
          _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_33:
    if (v27) {
      free(v27);
    }
    id v4 = 0;
    goto LABEL_14;
  }
  id v4 = (char *)malloc_type_calloc(1uLL, 0xE0uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    objc_storeStrong((id *)v4 + 12, *(id *)(a2 + 96));
    *((_WORD *)v4 + 102) = *(_WORD *)(a2 + 204);
    *((_DWORD *)v4 + 48) = *(_DWORD *)(a2 + 192);
    *((_OWORD *)v4 + 2) = *(_OWORD *)(a2 + 32);
    *(_OWORD *)id v4 = *(_OWORD *)a2;
    *((_OWORD *)v4 + 1) = *(_OWORD *)(a2 + 16);
    *((_OWORD *)v4 + 3) = *(_OWORD *)(a2 + 48);
    *((_OWORD *)v4 + 4) = *(_OWORD *)(a2 + 64);
    *((_OWORD *)v4 + 5) = *(_OWORD *)(a2 + 80);
    CFArrayRef v5 = *(const __CFArray **)(a2 + 104);
    long long v6 = (CFAllocatorRef *)MEMORY[0x1E4F1CF80];
    if (v5) {
      *((void *)v4 + 13) = CFArrayCreateCopy((CFAllocatorRef)*MEMORY[0x1E4F1CF80], v5);
    }
    uint64_t v7 = *(const void **)(a2 + 112);
    if (v7) {
      *((void *)v4 + 14) = CFRetain(v7);
    }
    CFArrayRef v8 = *(const __CFArray **)(a2 + 120);
    if (v8) {
      *((void *)v4 + 15) = CFArrayCreateCopy(*v6, v8);
    }
    os_log_type_t v9 = *(const void **)(a2 + 128);
    if (v9) {
      *((void *)v4 + 16) = CFRetain(v9);
    }
    objc_storeStrong((id *)v4 + 17, *(id *)(a2 + 136));
    objc_storeStrong((id *)v4 + 18, *(id *)(a2 + 144));
    BOOL v10 = _Block_copy(*(const void **)(a2 + 160));
    os_log_type_t v11 = (void *)*((void *)v4 + 20);
    *((void *)v4 + 20) = v10;

    objc_storeStrong((id *)v4 + 21, *(id *)(a2 + 168));
    os_log_type_t v12 = _Block_copy(*(const void **)(a2 + 176));
    os_log_type_t v13 = (void *)*((void *)v4 + 22);
    *((void *)v4 + 22) = v12;

    objc_storeStrong((id *)v4 + 23, *(id *)(a2 + 184));
    int v14 = *(unsigned __int16 *)(v4 + 215);
    v4[214] = *(unsigned char *)(a2 + 214);
    unsigned int v15 = v14 & 0xFFFFFFFE | (v4[217] << 16) | *(_WORD *)(a2 + 215) & 1;
    *(_WORD *)(v4 + 215) = v15;
    unsigned int v16 = v15 & 0xFFFE7F11 | (*(unsigned __int16 *)(a2 + 215) | (*(unsigned __int8 *)(a2 + 217) << 16)) & 0x180EE;
    *(_WORD *)(v4 + 215) = v15 & 0x7F11 | *(_WORD *)(a2 + 215) & 0x80EE;
    unsigned int v17 = HIWORD(v16);
    v4[217] = BYTE2(v16);
    int v18 = *(_DWORD *)(a2 + 206);
    *((_WORD *)v4 + 105) = *(_WORD *)(a2 + 210);
    *(_DWORD *)(v4 + 206) = v18;
    LOWORD(v16) = *(_WORD *)(a2 + 215) & 0x10 | v16 & 0xFFEF;
    v4[217] = v17;
    *(_WORD *)(v4 + 215) = v16;
    v4[212] = *(unsigned char *)(a2 + 212);
    objc_storeStrong((id *)v4 + 19, *(id *)(a2 + 152));
    int v19 = *(unsigned __int16 *)(v4 + 215);
    unsigned int v20 = v19 & 0xFFFFFCFF | (v4[217] << 16) | ((HIBYTE(*(unsigned __int16 *)(a2 + 215)) & 3) << 8);
    *(_WORD *)(v4 + 215) = v19 & 0xFCFF | ((HIBYTE(*(_WORD *)(a2 + 215)) & 3) << 8);
    *((_DWORD *)v4 + 50) = *(_DWORD *)(a2 + 200);
    *(_WORD *)(v4 + 215) = *(_WORD *)(a2 + 215) & 0x7800 | v20 & 0x87FF;
    int v21 = os_variant_allows_internal_security_policies();
    unsigned int v22 = *(unsigned __int16 *)(v4 + 215) | (v4[217] << 16);
    if (v21)
    {
      unsigned int v23 = HIWORD(v22);
      unsigned int v22 = *(_WORD *)(v4 + 215) & 0xFBFF | (v4[217] << 16) | (((*(unsigned __int16 *)(a2 + 215) >> 10) & 1) << 10);
      v4[217] = v23;
      *(_WORD *)(v4 + 215) = v22;
    }
    int v24 = *(unsigned __int8 *)(a2 + 217) >> 1;
    *(_WORD *)(v4 + 215) = v22;
    v4[217] = (v22 & 0xFFC1FFFF | ((v24 & 0x1F) << 17)) >> 16;
LABEL_14:

    return (BOOL)v4;
  }
  os_log_type_t v30 = __nwlog_obj();
  os_log_type_enabled(v30, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __int16 v39 = "strict_calloc";
  __int16 v40 = 2048;
  uint64_t v41 = 1;
  __int16 v42 = 2048;
  uint64_t v43 = 224;
  char v31 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v31);
  if (!result)
  {
    free(v31);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_1831036F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_proxy_copy_options(void *a1, uint64_t a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    BOOL v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v25 = "nw_proxy_copy_options";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v11, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v25 = "nw_proxy_copy_options";
            __int16 v26 = 2082;
            uint64_t v27 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v25 = "nw_proxy_copy_options";
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v11) {
      free(v11);
    }
    id v4 = 0;
    goto LABEL_6;
  }
  id v4 = (void **)malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (!v4)
  {
    int v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    uint64_t v25 = "strict_calloc";
    __int16 v26 = 2048;
    uint64_t v27 = 1;
    __int16 v28 = 2048;
    uint64_t v29 = 16;
    unsigned int v15 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v15);
    if (result) {
      goto LABEL_30;
    }
    free(v15);
  }
  CFArrayRef v5 = _Block_copy(*(const void **)a2);
  long long v6 = *v4;
  char *v4 = v5;

  uint64_t v7 = *(const char **)(a2 + 8);
  if (!v7)
  {
LABEL_6:

    return (BOOL)v4;
  }
  CFArrayRef v8 = strdup(v7);
  if (v8)
  {
LABEL_5:
    v4[1] = v8;
    goto LABEL_6;
  }
  unsigned int v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v25 = "strict_strdup";
  unsigned int v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
    goto LABEL_5;
  }
LABEL_30:
  __break(1u);
  return result;
}

void sub_183103B28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_quic_stream_copy_options(void *a1, uint64_t a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v22 = "nw_quic_stream_copy_options";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v10, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_quic_stream_copy_options";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            char v22 = "nw_quic_stream_copy_options";
            __int16 v23 = 2082;
            uint64_t v24 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_quic_stream_copy_options";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          char v22 = "nw_quic_stream_copy_options";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v10) {
      free(v10);
    }
    id v4 = 0;
    goto LABEL_4;
  }
  id v4 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    CFArrayRef v5 = nw_protocol_options_copy(*(void **)(a2 + 16));
    long long v6 = (void *)v4[2];
    v4[2] = v5;

    char v7 = v4[3] & 0xFE | *(unsigned char *)(a2 + 24) & 1;
    *((unsigned char *)v4 + 24) = v7;
    *((unsigned char *)v4 + 24) = v7 & 0xFD | *(unsigned char *)(a2 + 24) & 2;
    *(_OWORD *)id v4 = *(_OWORD *)a2;
LABEL_4:

    return (BOOL)v4;
  }
  os_log_type_t v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  char v22 = "strict_calloc";
  __int16 v23 = 2048;
  uint64_t v24 = 1;
  __int16 v25 = 2048;
  uint64_t v26 = 32;
  int v14 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v14);
  if (!result)
  {
    free(v14);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_183103ED8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_copy_options(void *a1, _DWORD *a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (!a2)
  {
    long long v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v19 = "nw_udp_copy_options";
    char v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        CFArrayRef v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v19 = "nw_udp_copy_options";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null existing_handle", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        CFArrayRef v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            char v19 = "nw_udp_copy_options";
            __int16 v20 = 2082;
            uint64_t v21 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null existing_handle, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          char v19 = "nw_udp_copy_options";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null existing_handle, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        CFArrayRef v8 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v19 = "nw_udp_copy_options";
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null existing_handle, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v7) {
      free(v7);
    }
    id v4 = 0;
    goto LABEL_4;
  }
  id v4 = malloc_type_calloc(1uLL, 4uLL, 0xEAFB8F1AuLL);
  if (v4)
  {
LABEL_3:
    _DWORD *v4 = 0;
    _DWORD *v4 = *a2;
LABEL_4:

    return (BOOL)v4;
  }
  BOOL v10 = __nwlog_obj();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  char v19 = "strict_calloc";
  __int16 v20 = 2048;
  uint64_t v21 = 1;
  __int16 v22 = 2048;
  uint64_t v23 = 4;
  os_log_type_t v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_18310425C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_metadata_is_ip(nw_protocol_metadata_t metadata)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (metadata)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
    }
    uint64_t v2 = g_ip_definition;
    return nw_protocol_metadata_matches_definition((uint64_t)metadata, v2);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  os_log_type_t v15 = "nw_protocol_metadata_is_ip_unsafe";
  CFArrayRef v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v6 = (id)gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v6 = (id)gLogObj;
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v15 = "nw_protocol_metadata_is_ip_unsafe";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v6 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v15 = "nw_protocol_metadata_is_ip_unsafe";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v5) {
    free(v5);
  }
  return 0;
}

void nw_protocol_data_trim(void *a1, unsigned int a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    id v5 = v3;
    if (nw_frame_claim((uint64_t)v5, v6, a2, 0))
    {
      nw_frame_collapse((uint64_t)v5);
      nw_frame_unclaim((uint64_t)v5, v7, a2, 0);
    }

    goto LABEL_5;
  }
  CFArrayRef v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v19 = "nw_protocol_data_trim";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_data_trim";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null data", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          char v19 = "nw_protocol_data_trim";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_data_trim";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        char v19 = "nw_protocol_data_trim";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v9) {
    free(v9);
  }
LABEL_5:
}

uint64_t ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke_27(uint64_t a1, uint64_t a2)
{
  return 1;
}

void nw_socket_frame_input_finalizer(nw_frame *a1, BOOL a2, void *a3)
{
  nw_frame_free_buffer((uint64_t)a1);
  nw_frame_reset((uint64_t)a1, 0, 0, 0, 0);
  uint64_t v6 = *((void *)a1 + 2);
  uint64_t v7 = (void *)*((void *)a1 + 3);
  id v5 = (void *)((char *)a1 + 16);
  if (v6)
  {
    *(void *)(v6 + 24) = v7;
    uint64_t v7 = (void *)*((void *)a1 + 3);
  }
  else
  {
    a3[34] = v7;
  }
  void *v7 = v6;
  void *v5 = 0;
  *((void *)a1 + 3) = 0;
  CFArrayRef v8 = (void *)a3[32];
  *((void *)a1 + 3) = v8;
  *CFArrayRef v8 = a1;
  a3[32] = v5;
}

void nw_frame_free_buffer(uint64_t a1)
{
  if ((*(_WORD *)(a1 + 204) & 2) == 0)
  {
    uint64_t v2 = *(void **)(a1 + 112);
    if (!v2)
    {
LABEL_4:
      *(_WORD *)(a1 + 196) = 0;
      *(void *)(a1 + 48) = 0;
      return;
    }
LABEL_3:
    free(v2);
    *(void *)(a1 + 112) = 0;
    goto LABEL_4;
  }
  id v3 = __nwlog_obj();
  os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
  id v4 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v4))
  {
    free(v4);
    uint64_t v2 = *(void **)(a1 + 112);
    if (!v2) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  __break(1u);
}

uint64_t nw_protocol_udp_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, uint64_t a5, nw_frame_array_s *a6)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      __int16 output_handler_context_high = HIWORD(a1[2].output_handler_context);
      if (output_handler_context_high)
      {
        uint64_t v17 = 0;
        HIWORD(a1[2].output_handler_context) = output_handler_context_high | 2;
        return v17;
      }
      if (a3 >= 0xFFFFFFF8) {
        uint64_t v9 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v9 = a3 + 8;
      }
      if (a4 >= 0xFFFFFFF8) {
        uint64_t v10 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v10 = a4 + 8;
      }
      output_handler = a1->output_handler;
      if (output_handler)
      {
        handle = output_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
        }
        BOOL v14 = a1[1].callbacks;
        if (v14) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v14->add_input_handler + 1);
        }
        if (a6)
        {
          os_log_type_t v15 = output_handler->callbacks;
          if (v15)
          {
            get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, nw_frame_array_s *))v15->get_output_frames;
            if (get_output_frames)
            {
              uint64_t v17 = get_output_frames(output_handler, a1, v9, v10, a5, a6);
              goto LABEL_20;
            }
          }
          __nwlog_obj();
          name = output_handler->identifier->name;
          *(_DWORD *)buf = 136446722;
          int v69 = "__nw_protocol_get_output_frames";
          if (!name) {
            name = "invalid";
          }
          __int16 v70 = 2082;
          os_log_type_t v71 = (void *)name;
          __int16 v72 = 2048;
          int v73 = output_handler;
          os_log_type_t v35 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v66 = 0;
          if (__nwlog_fault(v35, &type, &v66))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              char v36 = __nwlog_obj();
              os_log_type_t v37 = type;
              if (!os_log_type_enabled(v36, type)) {
                goto LABEL_137;
              }
              uint64_t v38 = output_handler->identifier->name;
              if (!v38) {
                uint64_t v38 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              int v69 = "__nw_protocol_get_output_frames";
              __int16 v70 = 2082;
              os_log_type_t v71 = (void *)v38;
              __int16 v72 = 2048;
              int v73 = output_handler;
              __int16 v39 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_122:
              id v59 = v36;
              os_log_type_t v60 = v37;
              uint32_t v61 = 32;
LABEL_136:
              _os_log_impl(&dword_1830D4000, v59, v60, v39, buf, v61);
              goto LABEL_137;
            }
            if (!v66)
            {
              char v36 = __nwlog_obj();
              os_log_type_t v37 = type;
              if (!os_log_type_enabled(v36, type)) {
                goto LABEL_137;
              }
              id v57 = output_handler->identifier->name;
              if (!v57) {
                id v57 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              int v69 = "__nw_protocol_get_output_frames";
              __int16 v70 = 2082;
              os_log_type_t v71 = (void *)v57;
              __int16 v72 = 2048;
              int v73 = output_handler;
              __int16 v39 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
              goto LABEL_122;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            char v36 = __nwlog_obj();
            os_log_type_t v37 = type;
            BOOL v51 = os_log_type_enabled(v36, type);
            if (!backtrace_string)
            {
              if (!v51) {
                goto LABEL_137;
              }
              id v58 = output_handler->identifier->name;
              if (!v58) {
                id v58 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              int v69 = "__nw_protocol_get_output_frames";
              __int16 v70 = 2082;
              os_log_type_t v71 = (void *)v58;
              __int16 v72 = 2048;
              int v73 = output_handler;
              __int16 v39 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
              goto LABEL_122;
            }
            if (v51)
            {
              if (output_handler->identifier) {
                os_log_type_t v52 = output_handler->identifier->name;
              }
              else {
                os_log_type_t v52 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              int v69 = "__nw_protocol_get_output_frames";
              __int16 v70 = 2082;
              os_log_type_t v71 = (void *)v52;
              __int16 v72 = 2048;
              int v73 = output_handler;
              __int16 v74 = 2082;
              v75 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(backtrace_string);
          }
LABEL_137:
          if (!v35)
          {
LABEL_139:
            uint64_t v17 = 0;
LABEL_20:
            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              uint64_t v22 = a1[1].callbacks;
              if (v22)
              {
                uint64_t v23 = (nw_protocol_callbacks *)((char *)v22 - 1);
                a1[1].callbacks = v23;
                if (!v23)
                {
                  uint64_t v24 = *(void (***)(void))a1[1].flow_id;
                  if (v24)
                  {
                    *(void *)a1[1].flow_id = 0;
                    v24[2](v24);
                    _Block_release(v24);
                  }
                  if (a1[1].flow_id[8])
                  {
                    __int16 v25 = *(const void **)a1[1].flow_id;
                    if (v25) {
                      _Block_release(v25);
                    }
                  }
                  free(a1);
                }
              }
            }
            if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              uint64_t v26 = output_handler[1].callbacks;
              if (v26)
              {
                uint64_t v27 = (nw_protocol_callbacks *)((char *)v26 - 1);
                output_handler[1].callbacks = v27;
                if (!v27)
                {
                  __int16 v28 = *(void (***)(void))output_handler[1].flow_id;
                  if (v28)
                  {
                    *(void *)output_handler[1].flow_id = 0;
                    v28[2](v28);
                    _Block_release(v28);
                  }
                  if (output_handler[1].flow_id[8])
                  {
                    uint64_t v29 = *(const void **)output_handler[1].flow_id;
                    if (v29) {
                      _Block_release(v29);
                    }
                  }
                  free(output_handler);
                }
              }
            }
LABEL_23:
            v62[0] = MEMORY[0x1E4F143A8];
            v62[1] = 0x40000000;
            int v63 = ___ZL33nw_protocol_udp_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            int v64 = &__block_descriptor_tmp_21;
            int v65 = a1;
            os_log_type_t tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              char v19 = (nw_frame *)*((void *)tqh_first + 4);
              char v20 = ((uint64_t (*)(void *))v63)(v62);
              os_log_type_t tqh_first = v19;
            }
            while ((v20 & 1) != 0);
            if (_nw_signposts_once != -1) {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_17);
            }
            if (_nw_signposts_enabled && kdebug_is_enabled()) {
              kdebug_trace();
            }
            return v17;
          }
LABEL_138:
          free(v35);
          goto LABEL_139;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        int v69 = "__nw_protocol_get_output_frames";
        os_log_type_t v35 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v66 = 0;
        if (!__nwlog_fault(v35, &type, &v66)) {
          goto LABEL_137;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v48 = __nwlog_obj();
          os_log_type_t v49 = type;
          if (!os_log_type_enabled(v48, type)) {
            goto LABEL_137;
          }
          *(_DWORD *)buf = 136446210;
          int v69 = "__nw_protocol_get_output_frames";
          __int16 v39 = "%{public}s called with null return_array";
        }
        else if (v66)
        {
          nw_endpoint_t v55 = (char *)__nw_create_backtrace_string();
          os_log_type_t v48 = __nwlog_obj();
          os_log_type_t v49 = type;
          BOOL v56 = os_log_type_enabled(v48, type);
          if (v55)
          {
            if (v56)
            {
              *(_DWORD *)buf = 136446466;
              int v69 = "__nw_protocol_get_output_frames";
              __int16 v70 = 2082;
              os_log_type_t v71 = v55;
              _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null return_array, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v55);
            if (!v35) {
              goto LABEL_139;
            }
            goto LABEL_138;
          }
          if (!v56) {
            goto LABEL_137;
          }
          *(_DWORD *)buf = 136446210;
          int v69 = "__nw_protocol_get_output_frames";
          __int16 v39 = "%{public}s called with null return_array, no backtrace";
        }
        else
        {
          os_log_type_t v48 = __nwlog_obj();
          os_log_type_t v49 = type;
          if (!os_log_type_enabled(v48, type)) {
            goto LABEL_137;
          }
          *(_DWORD *)buf = 136446210;
          int v69 = "__nw_protocol_get_output_frames";
          __int16 v39 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        id v59 = v48;
        os_log_type_t v60 = v49;
        uint32_t v61 = 12;
        goto LABEL_136;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v69 = "__nw_protocol_get_output_frames";
      uint64_t v43 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v66 = 0;
      if (__nwlog_fault(v43, &type, &v66))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v44 = __nwlog_obj();
          os_log_type_t v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            int v69 = "__nw_protocol_get_output_frames";
            BOOL v46 = "%{public}s called with null protocol";
LABEL_129:
            _os_log_impl(&dword_1830D4000, v44, v45, v46, buf, 0xCu);
          }
        }
        else if (v66)
        {
          id v53 = (char *)__nw_create_backtrace_string();
          uint64_t v44 = __nwlog_obj();
          os_log_type_t v45 = type;
          BOOL v54 = os_log_type_enabled(v44, type);
          if (v53)
          {
            if (v54)
            {
              *(_DWORD *)buf = 136446466;
              int v69 = "__nw_protocol_get_output_frames";
              __int16 v70 = 2082;
              os_log_type_t v71 = v53;
              _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v53);
            goto LABEL_130;
          }
          if (v54)
          {
            *(_DWORD *)buf = 136446210;
            int v69 = "__nw_protocol_get_output_frames";
            BOOL v46 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_129;
          }
        }
        else
        {
          uint64_t v44 = __nwlog_obj();
          os_log_type_t v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            int v69 = "__nw_protocol_get_output_frames";
            BOOL v46 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_129;
          }
        }
      }
LABEL_130:
      if (v43) {
        free(v43);
      }
      uint64_t v17 = 0;
      goto LABEL_23;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v69 = "nw_protocol_udp_get_output_frames";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (!__nwlog_fault(v30, &type, &v66)) {
      goto LABEL_115;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        int v69 = "nw_protocol_udp_get_output_frames";
        os_log_type_t v33 = "%{public}s called with null udp";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    if (!v66)
    {
      char v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        int v69 = "nw_protocol_udp_get_output_frames";
        os_log_type_t v33 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    __int16 v40 = (char *)__nw_create_backtrace_string();
    char v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v47 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        int v69 = "nw_protocol_udp_get_output_frames";
        os_log_type_t v33 = "%{public}s called with null udp, no backtrace";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    if (v47)
    {
      *(_DWORD *)buf = 136446466;
      int v69 = "nw_protocol_udp_get_output_frames";
      __int16 v70 = 2082;
      os_log_type_t v71 = v40;
      __int16 v42 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_77;
    }
    goto LABEL_78;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v69 = "nw_protocol_udp_get_output_frames";
  uint64_t v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v66 = 0;
  if (!__nwlog_fault(v30, &type, &v66)) {
    goto LABEL_115;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v66)
    {
      char v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        int v69 = "nw_protocol_udp_get_output_frames";
        os_log_type_t v33 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    __int16 v40 = (char *)__nw_create_backtrace_string();
    char v31 = __nwlog_obj();
    os_log_type_t v32 = type;
    BOOL v41 = os_log_type_enabled(v31, type);
    if (!v40)
    {
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        int v69 = "nw_protocol_udp_get_output_frames";
        os_log_type_t v33 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_114;
      }
      goto LABEL_115;
    }
    if (v41)
    {
      *(_DWORD *)buf = 136446466;
      int v69 = "nw_protocol_udp_get_output_frames";
      __int16 v70 = 2082;
      os_log_type_t v71 = v40;
      __int16 v42 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_77:
      _os_log_impl(&dword_1830D4000, v31, v32, v42, buf, 0x16u);
    }
LABEL_78:
    free(v40);
    goto LABEL_115;
  }
  char v31 = __nwlog_obj();
  os_log_type_t v32 = type;
  if (os_log_type_enabled(v31, type))
  {
    *(_DWORD *)buf = 136446210;
    int v69 = "nw_protocol_udp_get_output_frames";
    os_log_type_t v33 = "%{public}s called with null protocol";
LABEL_114:
    _os_log_impl(&dword_1830D4000, v31, v32, v33, buf, 0xCu);
  }
LABEL_115:
  if (v30) {
    free(v30);
  }
  return 0;
}

uint64_t nw_protocol_ipv4_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, int a5, nw_frame_array_s *a6)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      if (a5 && LODWORD(a1[3].identifier) < a3 && ((uint64_t)a1[3].handle & 4) == 0)
      {
        BOOL v9 = nw_calloc_type<unsigned char>(a3);
        uint64_t v10 = nw_frame_create(0, v9, a3, (uint64_t)nw_protocol_ipv4_frame_output_finalizer, (uint64_t)&a1[1].output_handler);
        uint64_t v11 = v10;
        if (v10)
        {
          *(_WORD *)(v10 + 204) |= 1u;
          *(void *)(v10 + 16) = 0;
          char v12 = *(uint64_t **)&a1[3].flow_id[8];
          *(void *)(v10 + 24) = v12;
          uint64_t *v12 = v10;
          *(void *)&a1[3].flow_id[8] = v10 + 16;
LABEL_65:
          *(void *)(v11 + 32) = 0;
          tqh_last = a6->tqh_last;
          *(void *)(v11 + 40) = tqh_last;
          *tqh_last = (nw_frame *)v11;
          a6->tqh_last = (nw_frame **)(v11 + 32);
          return 1;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446466;
        __int16 v80 = "nw_protocol_ipv4_create_output_frame";
        __int16 v81 = 1024;
        *(_DWORD *)BOOL v82 = a3;
        os_log_type_t v33 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v77 = 0;
        if (__nwlog_fault(v33, &type, &v77))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v34 = gLogObj;
            os_log_type_t v35 = type;
            if (os_log_type_enabled((os_log_t)gLogObj, type))
            {
              *(_DWORD *)buf = 136446466;
              __int16 v80 = "nw_protocol_ipv4_create_output_frame";
              __int16 v81 = 1024;
              *(_DWORD *)BOOL v82 = a3;
              char v36 = "%{public}s nw_frame_create(%u) failed";
LABEL_60:
              _os_log_impl(&dword_1830D4000, v34, v35, v36, buf, 0x12u);
            }
          }
          else if (v77)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v34 = gLogObj;
            os_log_type_t v35 = type;
            BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (backtrace_string)
            {
              if (v38)
              {
                *(_DWORD *)buf = 136446722;
                __int16 v80 = "nw_protocol_ipv4_create_output_frame";
                __int16 v81 = 1024;
                *(_DWORD *)BOOL v82 = a3;
                *(_WORD *)&v82[4] = 2082;
                *(void *)&v82[6] = backtrace_string;
                _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(backtrace_string);
              goto LABEL_61;
            }
            if (v38)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v80 = "nw_protocol_ipv4_create_output_frame";
              __int16 v81 = 1024;
              *(_DWORD *)BOOL v82 = a3;
              char v36 = "%{public}s nw_frame_create(%u) failed, no backtrace";
              goto LABEL_60;
            }
          }
          else
          {
            BOOL v34 = __nwlog_obj();
            os_log_type_t v35 = type;
            if (os_log_type_enabled(v34, type))
            {
              *(_DWORD *)buf = 136446466;
              __int16 v80 = "nw_protocol_ipv4_create_output_frame";
              __int16 v81 = 1024;
              *(_DWORD *)BOOL v82 = a3;
              char v36 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
              goto LABEL_60;
            }
          }
        }
LABEL_61:
        if (v33) {
          free(v33);
        }
        if (v9) {
          free((void *)v9);
        }
        goto LABEL_65;
      }
      if (a3 >= 0xFFFFFFEC) {
        uint64_t v13 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v13 = a3 + 20;
      }
      if (a4 >= 0xFFFFFFEC) {
        uint64_t v14 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v14 = a4 + 20;
      }
      output_handler = a1->output_handler;
      if (output_handler)
      {
        handle = output_handler->handle;
        if (handle == &nw_protocol_ref_counted_handle)
        {
          callbacks = output_handler[1].callbacks;
          if (callbacks) {
            output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
        }
        uint64_t v18 = a1[1].callbacks;
        if (v18) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v18->add_input_handler + 1);
        }
        if (a6)
        {
          char v19 = output_handler->callbacks;
          if (v19)
          {
            get_output_frames = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t))v19->get_output_frames;
            if (get_output_frames)
            {
              uint64_t v21 = get_output_frames(output_handler, a1, v13, v14);
              goto LABEL_24;
            }
          }
          __nwlog_obj();
          name = output_handler->identifier->name;
          *(_DWORD *)buf = 136446722;
          __int16 v80 = "__nw_protocol_get_output_frames";
          if (!name) {
            name = "invalid";
          }
          __int16 v81 = 2082;
          *(void *)BOOL v82 = name;
          *(_WORD *)&v82[8] = 2048;
          *(void *)&v82[10] = output_handler;
          __int16 v42 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v77 = 0;
          if (__nwlog_fault(v42, &type, &v77))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              uint64_t v43 = __nwlog_obj();
              os_log_type_t v44 = type;
              if (!os_log_type_enabled(v43, type)) {
                goto LABEL_154;
              }
              os_log_type_t v45 = output_handler->identifier->name;
              if (!v45) {
                os_log_type_t v45 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              __int16 v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)BOOL v82 = v45;
              *(_WORD *)&v82[8] = 2048;
              *(void *)&v82[10] = output_handler;
              BOOL v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback";
LABEL_131:
              __int16 v70 = v43;
              os_log_type_t v71 = v44;
              uint32_t v72 = 32;
LABEL_153:
              _os_log_impl(&dword_1830D4000, v70, v71, v46, buf, v72);
              goto LABEL_154;
            }
            if (!v77)
            {
              uint64_t v43 = __nwlog_obj();
              os_log_type_t v44 = type;
              if (!os_log_type_enabled(v43, type)) {
                goto LABEL_154;
              }
              uint64_t v68 = output_handler->identifier->name;
              if (!v68) {
                uint64_t v68 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              __int16 v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)BOOL v82 = v68;
              *(_WORD *)&v82[8] = 2048;
              *(void *)&v82[10] = output_handler;
              BOOL v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, backtrace limit exceeded";
              goto LABEL_131;
            }
            id v57 = (char *)__nw_create_backtrace_string();
            uint64_t v43 = __nwlog_obj();
            os_log_type_t v44 = type;
            BOOL v58 = os_log_type_enabled(v43, type);
            if (!v57)
            {
              if (!v58) {
                goto LABEL_154;
              }
              int v69 = output_handler->identifier->name;
              if (!v69) {
                int v69 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              __int16 v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)BOOL v82 = v69;
              *(_WORD *)&v82[8] = 2048;
              *(void *)&v82[10] = output_handler;
              BOOL v46 = "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, no backtrace";
              goto LABEL_131;
            }
            if (v58)
            {
              id v59 = output_handler->identifier->name;
              if (!v59) {
                id v59 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              __int16 v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)BOOL v82 = v59;
              *(_WORD *)&v82[8] = 2048;
              *(void *)&v82[10] = output_handler;
              __int16 v83 = 2082;
              os_log_type_t v84 = v57;
              _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s protocol %{public}s (%p) has invalid get_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v57);
          }
LABEL_154:
          if (!v42)
          {
LABEL_156:
            uint64_t v21 = 0;
LABEL_24:
            if (a1->handle == &nw_protocol_ref_counted_handle)
            {
              __int16 v25 = a1[1].callbacks;
              if (v25)
              {
                uint64_t v26 = (nw_protocol_callbacks *)((char *)v25 - 1);
                a1[1].callbacks = v26;
                if (!v26)
                {
                  uint64_t v27 = *(void (***)(void))a1[1].flow_id;
                  if (v27)
                  {
                    *(void *)a1[1].flow_id = 0;
                    v27[2](v27);
                    _Block_release(v27);
                  }
                  if (a1[1].flow_id[8])
                  {
                    __int16 v28 = *(const void **)a1[1].flow_id;
                    if (v28) {
                      _Block_release(v28);
                    }
                  }
                  free(a1);
                }
              }
            }
            if (handle == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              uint64_t v29 = output_handler[1].callbacks;
              if (v29)
              {
                uint64_t v30 = (nw_protocol_callbacks *)((char *)v29 - 1);
                output_handler[1].callbacks = v30;
                if (!v30)
                {
                  char v31 = *(void (***)(void))output_handler[1].flow_id;
                  if (v31)
                  {
                    *(void *)output_handler[1].flow_id = 0;
                    v31[2](v31);
                    _Block_release(v31);
                  }
                  if (output_handler[1].flow_id[8])
                  {
                    os_log_type_t v32 = *(const void **)output_handler[1].flow_id;
                    if (v32) {
                      _Block_release(v32);
                    }
                  }
                  free(output_handler);
                }
              }
            }
LABEL_27:
            v73[0] = MEMORY[0x1E4F143A8];
            v73[1] = 0x40000000;
            __int16 v74 = ___ZL34nw_protocol_ipv4_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
            v75 = &__block_descriptor_tmp_31_87659;
            uint64_t v76 = a1;
            os_log_type_t tqh_first = a6->tqh_first;
            do
            {
              if (!tqh_first) {
                break;
              }
              uint64_t v23 = (nw_frame *)*((void *)tqh_first + 4);
              char v24 = ((uint64_t (*)(void *))v74)(v73);
              os_log_type_t tqh_first = v23;
            }
            while ((v24 & 1) != 0);
            return v21;
          }
LABEL_155:
          free(v42);
          goto LABEL_156;
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        __int16 v80 = "__nw_protocol_get_output_frames";
        __int16 v42 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v77 = 0;
        if (!__nwlog_fault(v42, &type, &v77)) {
          goto LABEL_154;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          nw_endpoint_t v55 = __nwlog_obj();
          os_log_type_t v56 = type;
          if (!os_log_type_enabled(v55, type)) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "__nw_protocol_get_output_frames";
          BOOL v46 = "%{public}s called with null return_array";
        }
        else if (v77)
        {
          char v66 = (char *)__nw_create_backtrace_string();
          nw_endpoint_t v55 = __nwlog_obj();
          os_log_type_t v56 = type;
          BOOL v67 = os_log_type_enabled(v55, type);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)BOOL v82 = v66;
              _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null return_array, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v66);
            if (!v42) {
              goto LABEL_156;
            }
            goto LABEL_155;
          }
          if (!v67) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "__nw_protocol_get_output_frames";
          BOOL v46 = "%{public}s called with null return_array, no backtrace";
        }
        else
        {
          nw_endpoint_t v55 = __nwlog_obj();
          os_log_type_t v56 = type;
          if (!os_log_type_enabled(v55, type)) {
            goto LABEL_154;
          }
          *(_DWORD *)buf = 136446210;
          __int16 v80 = "__nw_protocol_get_output_frames";
          BOOL v46 = "%{public}s called with null return_array, backtrace limit exceeded";
        }
        __int16 v70 = v55;
        os_log_type_t v71 = v56;
        uint32_t v72 = 12;
        goto LABEL_153;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      __int16 v80 = "__nw_protocol_get_output_frames";
      BOOL v51 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v77 = 0;
      if (__nwlog_fault(v51, &type, &v77))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v80 = "__nw_protocol_get_output_frames";
            BOOL v54 = "%{public}s called with null protocol";
LABEL_146:
            _os_log_impl(&dword_1830D4000, v52, v53, v54, buf, 0xCu);
          }
        }
        else if (v77)
        {
          int v64 = (char *)__nw_create_backtrace_string();
          os_log_type_t v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          BOOL v65 = os_log_type_enabled(v52, type);
          if (v64)
          {
            if (v65)
            {
              *(_DWORD *)buf = 136446466;
              __int16 v80 = "__nw_protocol_get_output_frames";
              __int16 v81 = 2082;
              *(void *)BOOL v82 = v64;
              _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v64);
            goto LABEL_147;
          }
          if (v65)
          {
            *(_DWORD *)buf = 136446210;
            __int16 v80 = "__nw_protocol_get_output_frames";
            BOOL v54 = "%{public}s called with null protocol, no backtrace";
            goto LABEL_146;
          }
        }
        else
        {
          os_log_type_t v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446210;
            __int16 v80 = "__nw_protocol_get_output_frames";
            BOOL v54 = "%{public}s called with null protocol, backtrace limit exceeded";
            goto LABEL_146;
          }
        }
      }
LABEL_147:
      if (v51) {
        free(v51);
      }
      uint64_t v21 = 0;
      goto LABEL_27;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v80 = "nw_protocol_ipv4_get_output_frames";
    BOOL v47 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (!__nwlog_fault(v47, &type, &v77)) {
      goto LABEL_141;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v80 = "nw_protocol_ipv4_get_output_frames";
        int v50 = "%{public}s called with null ipv4";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (!v77)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v80 = "nw_protocol_ipv4_get_output_frames";
        int v50 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    os_log_type_t v60 = (char *)__nw_create_backtrace_string();
    os_log_type_t v48 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v63 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v63)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v80 = "nw_protocol_ipv4_get_output_frames";
        int v50 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (v63)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "nw_protocol_ipv4_get_output_frames";
      __int16 v81 = 2082;
      *(void *)BOOL v82 = v60;
      os_log_type_t v62 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_106;
    }
    goto LABEL_107;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v80 = "nw_protocol_ipv4_get_output_frames";
  BOOL v47 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v77 = 0;
  if (!__nwlog_fault(v47, &type, &v77)) {
    goto LABEL_141;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v77)
    {
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v48, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v80 = "nw_protocol_ipv4_get_output_frames";
        int v50 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    os_log_type_t v60 = (char *)__nw_create_backtrace_string();
    os_log_type_t v48 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v61 = os_log_type_enabled(v48, type);
    if (!v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v80 = "nw_protocol_ipv4_get_output_frames";
        int v50 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_140;
      }
      goto LABEL_141;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v80 = "nw_protocol_ipv4_get_output_frames";
      __int16 v81 = 2082;
      *(void *)BOOL v82 = v60;
      os_log_type_t v62 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_106:
      _os_log_impl(&dword_1830D4000, v48, v49, v62, buf, 0x16u);
    }
LABEL_107:
    free(v60);
    goto LABEL_141;
  }
  os_log_type_t v48 = __nwlog_obj();
  os_log_type_t v49 = type;
  if (os_log_type_enabled(v48, type))
  {
    *(_DWORD *)buf = 136446210;
    __int16 v80 = "nw_protocol_ipv4_get_output_frames";
    int v50 = "%{public}s called with null protocol";
LABEL_140:
    _os_log_impl(&dword_1830D4000, v48, v49, v50, buf, 0xCu);
  }
LABEL_141:
  if (v47) {
    free(v47);
  }
  return 0;
}

uint64_t nw_channel_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(packet) = 0;
    if (!__nwlog_fault(v23, type, &packet)) {
      goto LABEL_113;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      uint64_t v26 = "%{public}s called with null channel_protocol";
      goto LABEL_189;
    }
    if ((_BYTE)packet)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      BOOL v88 = os_log_type_enabled(v81, type[0]);
      if (backtrace_string)
      {
        if (v88)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          os_log_type_t v89 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_168:
          _os_log_impl(&dword_1830D4000, v81, v82, v89, buf, 0x16u);
        }
LABEL_169:
        free(backtrace_string);
        goto LABEL_113;
      }
      if (!v88) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      uint64_t v26 = "%{public}s called with null channel_protocol, no backtrace";
    }
    else
    {
      __int16 v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      uint64_t v26 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
    }
LABEL_189:
    BOOL v67 = v81;
    os_log_type_t v68 = v82;
    uint32_t v69 = 12;
    goto LABEL_112;
  }
  handle = (char *)a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(packet) = 0;
    if (!__nwlog_fault(v23, type, &packet)) {
      goto LABEL_113;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      uint64_t v26 = "%{public}s called with null channel";
      goto LABEL_189;
    }
    if ((_BYTE)packet)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      BOOL v90 = os_log_type_enabled(v81, type[0]);
      if (backtrace_string)
      {
        if (v90)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          os_log_type_t v89 = "%{public}s called with null channel, dumping backtrace:%{public}s";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v90) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      uint64_t v26 = "%{public}s called with null channel, no backtrace";
    }
    else
    {
      __int16 v81 = __nwlog_obj();
      os_log_type_t v82 = type[0];
      if (!os_log_type_enabled(v81, type[0])) {
        goto LABEL_113;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      uint64_t v26 = "%{public}s called with null channel, backtrace limit exceeded";
    }
    goto LABEL_189;
  }
  a6->os_log_type_t tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!*((void *)handle + 17) || !*((void *)handle + 27)) {
    return 0;
  }
  os_log_type_t v100 = handle + 444;
  int v11 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
  *((_WORD *)handle + 222) = *((_WORD *)handle + 222);
  handle[446] = (v11 & 0xFFF9FFFF | 0x20000) >> 16;
  if ((v11 & 2) == 0 && *((void *)handle + 22))
  {
    unsigned int v12 = v11 & 0xFFF9FFFD | 0x20002;
    _WORD *v100 = v12;
    handle[446] = BYTE2(v12);
    unsigned int v13 = os_channel_available_slot_count();
    if (*((_DWORD *)handle + 105) - 1 >= v13) {
      int v14 = 0;
    }
    else {
      int v14 = *((_DWORD *)handle + 105);
    }
    int v15 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if (v13 == v14)
    {
      if ((*((_WORD *)handle + 222) & 0x10) != 0)
      {
        int v16 = *((_WORD *)handle + 222) & 0xFFEF | (handle[446] << 16);
        _WORD *v100 = *((_WORD *)handle + 222) & 0xFFEF;
        handle[446] = BYTE2(v16);
        nw_queue_resume_source(*((void *)handle + 22));
      }
    }
    else if ((*((_WORD *)handle + 222) & 0x10) == 0)
    {
      handle[446] = BYTE2(v15);
      _WORD *v100 = v15 | 0x10;
      nw_queue_suspend_source(*((void *)handle + 22));
    }
    int v17 = (unsigned __int16)*v100;
    unsigned int v18 = v17 & 0xFFFFFFFD | (handle[446] << 16);
    _WORD *v100 = v17 & 0xFFFD;
    handle[446] = BYTE2(v18);
  }
  unsigned int v19 = *((_DWORD *)handle + 109);
  unsigned int v20 = *((_DWORD *)handle + 110);
  if (!v20) {
    goto LABEL_28;
  }
  unsigned int v21 = 0xFFFFFFFF / v19;
  if (0xFFFFFFFF / v19 >= a5) {
    unsigned int v21 = a5;
  }
  if (v21 * v19 < a3)
  {
    if (0xFFFFFFFF / v20 >= a5) {
      unsigned int v22 = a5;
    }
    else {
      unsigned int v22 = 0xFFFFFFFF / v20;
    }
    if (v22 * v20 < a3)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v20;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v22;
      *(_WORD *)&unsigned char buf[24] = 1024;
      *(_DWORD *)&buf[26] = v22 * v20;
      *(_WORD *)&buf[30] = 1024;
      LODWORD(v109) = a3;
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(packet) = 0;
      if (!__nwlog_fault(v23, type, &packet)) {
        goto LABEL_113;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v24 = gLogObj;
        os_log_type_t v25 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_113;
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v22;
        *(_WORD *)&unsigned char buf[24] = 1024;
        *(_DWORD *)&buf[26] = v22 * v20;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v109) = a3;
        uint64_t v26 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u)";
        goto LABEL_111;
      }
      if (!(_BYTE)packet)
      {
        char v24 = __nwlog_obj();
        os_log_type_t v25 = type[0];
        if (!os_log_type_enabled(v24, type[0])) {
          goto LABEL_113;
        }
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v22;
        *(_WORD *)&unsigned char buf[24] = 1024;
        *(_DWORD *)&buf[26] = v22 * v20;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v109) = a3;
        uint64_t v26 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), backtrace limit exceeded";
        goto LABEL_111;
      }
      id v59 = (char *)__nw_create_backtrace_string();
      char v24 = __nwlog_obj();
      os_log_type_t v25 = type[0];
      BOOL v60 = os_log_type_enabled(v24, type[0]);
      if (v59)
      {
        if (v60)
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v20;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v22;
          *(_WORD *)&unsigned char buf[24] = 1024;
          *(_DWORD *)&buf[26] = v22 * v20;
          *(_WORD *)&buf[30] = 1024;
          LODWORD(v109) = a3;
          WORD2(v109) = 2082;
          *(void *)((char *)&v109 + 6) = v59;
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), dumping backtrace:%{public}s", buf, 0x2Eu);
        }
        free(v59);
        goto LABEL_113;
      }
      if (v60)
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_channel_get_output_frames";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v20;
        *(_WORD *)&buf[18] = 1024;
        *(_DWORD *)&buf[20] = v22;
        *(_WORD *)&unsigned char buf[24] = 1024;
        *(_DWORD *)&buf[26] = v22 * v20;
        *(_WORD *)&buf[30] = 1024;
        LODWORD(v109) = a3;
        uint64_t v26 = "%{public}s total bytes (%u * %u = %u) > minimum bytes (%u), no backtrace";
LABEL_111:
        BOOL v67 = v24;
        os_log_type_t v68 = v25;
        uint32_t v69 = 36;
LABEL_112:
        _os_log_impl(&dword_1830D4000, v67, v68, v26, buf, v69);
      }
LABEL_113:
      if (v23) {
        free(v23);
      }
      return 0;
    }
    char v98 = 1;
    unsigned int v19 = *((_DWORD *)handle + 110);
  }
  else
  {
LABEL_28:
    char v98 = 0;
  }
  unsigned int v27 = os_channel_available_slot_count();
  int v28 = *((_DWORD *)handle + 105);
  if (v28 - 1 >= v27) {
    int v28 = 0;
  }
  unsigned int v29 = v27 - v28;
  if (v29 >= a5) {
    unsigned int v29 = a5;
  }
  if (0xFFFFFFFF / v19 < v29) {
    unsigned int v29 = 0xFFFFFFFF / v19;
  }
  unsigned int v30 = v29 * v19;
  int v31 = a4 / v19;
  if (a4 % v19) {
    int v32 = v31 + 1;
  }
  else {
    int v32 = a4 / v19;
  }
  if (v30 > a4)
  {
    unsigned int v30 = v32 * v19;
    unsigned int v29 = v32;
  }
  unsigned int v99 = v29;
  if (v30 < a3)
  {
    int v33 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if ((v33 & 0x10000) == 0 || !*((void *)handle + 17)) {
      return 0;
    }
    unsigned int v34 = v33 & 0xFFFEFFFF;
    _WORD *v100 = v34;
    handle[446] = BYTE2(v34);
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
    }
    if (_nw_signposts_enabled && kdebug_is_enabled()) {
      kdebug_trace();
    }
    if os_channel_sync() && (nw_channel_check_defunct((uint64_t)handle)) {
      return 0;
    }
    unsigned int v35 = os_channel_available_slot_count();
    int v36 = *((_DWORD *)handle + 105);
    if (v36 - 1 >= v35) {
      int v36 = 0;
    }
    unsigned int v37 = v35 - v36;
    if (v37 >= a5) {
      unsigned int v37 = a5;
    }
    if (0xFFFFFFFF / v19 < v37) {
      unsigned int v37 = 0xFFFFFFFF / v19;
    }
    unsigned int v38 = v37 * v19;
    if (v31 * v19 == a4) {
      int v39 = a4 / v19;
    }
    else {
      int v39 = v31 + 1;
    }
    if (v38 > a4)
    {
      unsigned int v38 = v39 * v19;
      unsigned int v37 = v39;
    }
    unsigned int v99 = v37;
    if (v38 < a3) {
      return 0;
    }
  }
  long long v109 = 0u;
  long long v110 = 0u;
  memset(buf, 0, sizeof(buf));
  if (!*((void *)handle + 17)) {
    return 0;
  }
  uint64_t v40 = *((void *)handle + 36);
  uint64_t next_slot = os_channel_get_next_slot();
  uint64_t v42 = 0;
  if (!next_slot || !v99) {
    goto LABEL_131;
  }
  uint64_t v43 = 0;
  uint64_t v42 = 0;
  unint64_t StatusReg = _ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3));
  while (1)
  {
    uint64_t v44 = next_slot;
    uint64_t packet = 0;
    if (!v40)
    {
      nw_channel_allocate_frames(handle);
      uint64_t v40 = *((void *)handle + 36);
      if (!v40) {
        goto LABEL_129;
      }
    }
    if ((*v100 & 0x1000) != 0)
    {
      if (!*((void *)handle + 17)) {
        goto LABEL_77;
      }
      if (!((v98 & 1) != 0 ? os_channel_large_packet_alloc() : os_channel_packet_alloc())) {
        goto LABEL_77;
      }
      int v46 = **(_DWORD **)(StatusReg + 8);
      if (nw_channel_check_defunct((uint64_t)handle)) {
        goto LABEL_129;
      }
LABEL_100:
      BOOL v61 = __nwlog_obj();
      os_log_type_t v62 = v61;
      if (v46 == 35)
      {
        if (os_log_type_enabled(v61, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          BOOL v105 = "nw_channel_get_output_frames";
          __int16 v106 = 1024;
          LODWORD(v107[0]) = 35;
          _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_ERROR, "%{public}s failed to get packet from channel %{darwin.errno}d", (uint8_t *)type, 0x12u);
        }
        goto LABEL_129;
      }
      *(_DWORD *)os_log_type_t type = 136446466;
      BOOL v105 = "nw_channel_get_output_frames";
      __int16 v106 = 1024;
      LODWORD(v107[0]) = v46;
      BOOL v63 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v102 = OS_LOG_TYPE_ERROR;
      char v101 = 0;
      if (__nwlog_fault(v63, &v102, &v101))
      {
        if (v102 == OS_LOG_TYPE_FAULT)
        {
          int v64 = __nwlog_obj();
          os_log_type_t v65 = v102;
          if (!os_log_type_enabled(v64, v102)) {
            goto LABEL_127;
          }
          *(_DWORD *)os_log_type_t type = 136446466;
          BOOL v105 = "nw_channel_get_output_frames";
          __int16 v106 = 1024;
          LODWORD(v107[0]) = v46;
          char v66 = "%{public}s failed to get packet from channel %{darwin.errno}d";
          goto LABEL_126;
        }
        if (!v101)
        {
          int v64 = __nwlog_obj();
          os_log_type_t v65 = v102;
          if (!os_log_type_enabled(v64, v102)) {
            goto LABEL_127;
          }
          *(_DWORD *)os_log_type_t type = 136446466;
          BOOL v105 = "nw_channel_get_output_frames";
          __int16 v106 = 1024;
          LODWORD(v107[0]) = v46;
          char v66 = "%{public}s failed to get packet from channel %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_126;
        }
        os_log_type_t v71 = (char *)__nw_create_backtrace_string();
        int v64 = __nwlog_obj();
        os_log_type_t v65 = v102;
        BOOL v72 = os_log_type_enabled(v64, v102);
        if (v71)
        {
          if (v72)
          {
            *(_DWORD *)os_log_type_t type = 136446722;
            BOOL v105 = "nw_channel_get_output_frames";
            __int16 v106 = 1024;
            LODWORD(v107[0]) = v46;
            WORD2(v107[0]) = 2082;
            *(void *)((char *)v107 + 6) = v71;
            _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s failed to get packet from channel %{darwin.errno}d, dumping backtrace:%{public}s", (uint8_t *)type, 0x1Cu);
          }
          free(v71);
          goto LABEL_127;
        }
        if (v72)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          BOOL v105 = "nw_channel_get_output_frames";
          __int16 v106 = 1024;
          LODWORD(v107[0]) = v46;
          char v66 = "%{public}s failed to get packet from channel %{darwin.errno}d, no backtrace";
LABEL_126:
          _os_log_impl(&dword_1830D4000, v64, v65, v66, (uint8_t *)type, 0x12u);
        }
      }
LABEL_127:
      if (v63) {
        free(v63);
      }
      goto LABEL_129;
    }
    if (!*((void *)handle + 27)) {
      goto LABEL_77;
    }
    uint64_t packet = os_channel_slot_get_packet();
    if (!packet)
    {
      if (nw_channel_check_defunct((uint64_t)handle)) {
        goto LABEL_129;
      }
LABEL_77:
      int v46 = 0;
      goto LABEL_100;
    }
    uint64_t next_buflet = os_packet_get_next_buflet();
    if (!next_buflet) {
      break;
    }
    uint64_t v48 = next_buflet;
    uint64_t v49 = v43;
    unsigned int data_offset = os_buflet_get_data_offset();
    uint64_t object_address = os_buflet_get_object_address();
    int data_limit = os_buflet_get_data_limit();
    if (!data_limit)
    {
      uint64_t v43 = v49;
      if (nw_channel_check_defunct((uint64_t)handle)) {
        goto LABEL_129;
      }
      __nwlog_obj();
      *(_DWORD *)os_log_type_t type = 136446210;
      BOOL v105 = "nw_channel_get_output_frames";
      __int16 v83 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v102 = OS_LOG_TYPE_ERROR;
      char v101 = 0;
      if (!__nwlog_fault(v83, &v102, &v101)) {
        goto LABEL_198;
      }
      if (v102 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v84 = __nwlog_obj();
        os_log_type_t v85 = v102;
        if (!os_log_type_enabled(v84, v102)) {
          goto LABEL_198;
        }
        *(_DWORD *)os_log_type_t type = 136446210;
        BOOL v105 = "nw_channel_get_output_frames";
        os_log_type_t v86 = "%{public}s invalid buflet size";
      }
      else
      {
        if (v101)
        {
          os_log_type_t v93 = (char *)__nw_create_backtrace_string();
          os_log_type_t v94 = __nwlog_obj();
          os_log_type_t v85 = v102;
          BOOL v95 = os_log_type_enabled(v94, v102);
          if (v93)
          {
            if (v95)
            {
              *(_DWORD *)os_log_type_t type = 136446466;
              BOOL v105 = "nw_channel_get_output_frames";
              __int16 v106 = 2082;
              v107[0] = v93;
              _os_log_impl(&dword_1830D4000, v94, v85, "%{public}s invalid buflet size, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
            }
            free(v93);
            uint64_t v43 = v49;
            if (v83) {
              goto LABEL_199;
            }
            goto LABEL_200;
          }
          uint64_t v43 = v49;
          if (!v95) {
            goto LABEL_198;
          }
          *(_DWORD *)os_log_type_t type = 136446210;
          BOOL v105 = "nw_channel_get_output_frames";
          os_log_type_t v86 = "%{public}s invalid buflet size, no backtrace";
          os_log_type_t v96 = v94;
LABEL_197:
          _os_log_impl(&dword_1830D4000, v96, v85, v86, (uint8_t *)type, 0xCu);
          goto LABEL_198;
        }
        os_log_type_t v84 = __nwlog_obj();
        os_log_type_t v85 = v102;
        if (!os_log_type_enabled(v84, v102)) {
          goto LABEL_198;
        }
        *(_DWORD *)os_log_type_t type = 136446210;
        BOOL v105 = "nw_channel_get_output_frames";
        os_log_type_t v86 = "%{public}s invalid buflet size, backtrace limit exceeded";
      }
LABEL_196:
      os_log_type_t v96 = v84;
      goto LABEL_197;
    }
    nw_frame_reset(v40, object_address + data_offset, data_limit, (uint64_t)nw_channel_finalize_output_frame, (uint64_t)handle);
    os_packet_set_flow_uuid();
    if ((*(_WORD *)(v40 + 204) & 4) != 0)
    {
      *(void *)(v40 + 208) = packet;
      *(void *)(v40 + 216) = v48;
      *(void *)(v40 + 224) = v44;
      *(unsigned char *)(v40 + 232) = *(unsigned char *)(v40 + 232) & 0xFE | ((*v100 & 0x400) != 0);
    }
    uint64_t v54 = *(void *)(v40 + 16);
    nw_endpoint_t v55 = *(void **)(v40 + 24);
    os_log_type_t v53 = (void *)(v40 + 16);
    if (*(_OWORD *)(v40 + 16) == 0)
    {
      nw_endpoint_t v55 = 0;
      uint64_t v56 = 0;
    }
    else
    {
      uint64_t v56 = *(void *)(v40 + 16);
    }
    if (v54)
    {
      *(void *)(v54 + 24) = v55;
      nw_endpoint_t v55 = *(void **)(v40 + 24);
    }
    else
    {
      *((void *)handle + 37) = v55;
    }
    *nw_endpoint_t v55 = v54;
    void *v53 = 0;
    *(void *)(v40 + 24) = 0;
    id v57 = (uint64_t *)*((void *)handle + 39);
    *(void *)(v40 + 24) = v57;
    *id v57 = v40;
    *((void *)handle + 39) = v53;
    ++*((_DWORD *)handle + 105);
    *(void *)(v40 + 32) = 0;
    tqh_last = a6->tqh_last;
    *(void *)(v40 + 40) = tqh_last;
    *tqh_last = (nw_frame *)v40;
    a6->tqh_last = (nw_frame **)(v40 + 32);
    uint64_t v42 = (v42 + 1);
    uint64_t next_slot = os_channel_get_next_slot();
    if (next_slot)
    {
      uint64_t v40 = v56;
      uint64_t v43 = v44;
      if (v42 < v99) {
        continue;
      }
    }
    goto LABEL_130;
  }
  if (nw_channel_check_defunct((uint64_t)handle)) {
    goto LABEL_129;
  }
  __nwlog_obj();
  *(_DWORD *)os_log_type_t type = 136446210;
  BOOL v105 = "nw_channel_get_output_frames";
  __int16 v83 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t v102 = OS_LOG_TYPE_ERROR;
  char v101 = 0;
  if (!__nwlog_fault(v83, &v102, &v101)) {
    goto LABEL_198;
  }
  if (v102 != OS_LOG_TYPE_FAULT)
  {
    if (v101)
    {
      os_log_type_t v91 = (char *)__nw_create_backtrace_string();
      os_log_type_t v84 = __nwlog_obj();
      os_log_type_t v85 = v102;
      BOOL v92 = os_log_type_enabled(v84, v102);
      if (v91)
      {
        if (v92)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          BOOL v105 = "nw_channel_get_output_frames";
          __int16 v106 = 2082;
          v107[0] = v91;
          _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s failed to get buflet from packet, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
        }
        free(v91);
        goto LABEL_198;
      }
      if (!v92) {
        goto LABEL_198;
      }
      *(_DWORD *)os_log_type_t type = 136446210;
      BOOL v105 = "nw_channel_get_output_frames";
      os_log_type_t v86 = "%{public}s failed to get buflet from packet, no backtrace";
    }
    else
    {
      os_log_type_t v84 = __nwlog_obj();
      os_log_type_t v85 = v102;
      if (!os_log_type_enabled(v84, v102)) {
        goto LABEL_198;
      }
      *(_DWORD *)os_log_type_t type = 136446210;
      BOOL v105 = "nw_channel_get_output_frames";
      os_log_type_t v86 = "%{public}s failed to get buflet from packet, backtrace limit exceeded";
    }
    goto LABEL_196;
  }
  os_log_type_t v84 = __nwlog_obj();
  os_log_type_t v85 = v102;
  if (os_log_type_enabled(v84, v102))
  {
    *(_DWORD *)os_log_type_t type = 136446210;
    BOOL v105 = "nw_channel_get_output_frames";
    os_log_type_t v86 = "%{public}s failed to get buflet from packet";
    goto LABEL_196;
  }
LABEL_198:
  if (v83) {
LABEL_199:
  }
    free(v83);
LABEL_200:
  if ((*v100 & 0x1000) != 0 && *((void *)handle + 17) && os_channel_packet_free()) {
    nw_channel_check_defunct((uint64_t)handle);
  }
LABEL_129:
  uint64_t v44 = v43;
  if (!v43) {
    goto LABEL_131;
  }
LABEL_130:
  *((void *)handle + 51) = v44;
LABEL_131:
  int v73 = (unsigned __int16)*v100;
  int v74 = v73 | (handle[446] << 16);
  if ((v73 & 2) == 0 && *((void *)handle + 22))
  {
    handle[446] = BYTE2(v74);
    _WORD *v100 = v74 | 2;
    unsigned int v75 = os_channel_available_slot_count();
    if (*((_DWORD *)handle + 105) - 1 >= v75) {
      int v76 = 0;
    }
    else {
      int v76 = *((_DWORD *)handle + 105);
    }
    int v77 = *((unsigned __int16 *)handle + 222) | (handle[446] << 16);
    if (v75 == v76)
    {
      if ((*((_WORD *)handle + 222) & 0x10) != 0)
      {
        int v78 = *((_WORD *)handle + 222) & 0xFFEF | (handle[446] << 16);
        _WORD *v100 = *((_WORD *)handle + 222) & 0xFFEF;
        handle[446] = BYTE2(v78);
        nw_queue_resume_source(*((void *)handle + 22));
      }
    }
    else if ((*((_WORD *)handle + 222) & 0x10) == 0)
    {
      handle[446] = BYTE2(v77);
      _WORD *v100 = v77 | 0x10;
      nw_queue_suspend_source(*((void *)handle + 22));
    }
    int v79 = (unsigned __int16)*v100;
    unsigned int v80 = v79 & 0xFFFFFFFD | (handle[446] << 16);
    _WORD *v100 = v79 & 0xFFFD;
    handle[446] = BYTE2(v80);
  }
  return v42;
}

uint64_t nw_frame_create(int a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  uint64_t v10 = _os_object_alloc();
  uint64_t v11 = v10;
  if (v10)
  {
    if (a1) {
      *(_WORD *)(v10 + 204) |= 4u;
    }
    nw_frame_reset(v10, a2, a3, a4, a5);
    return v11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)buf = 136446210;
  uint64_t v26 = "nw_frame_create";
  unsigned int v12 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v12, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_frame_create";
      int v15 = "%{public}s nw_frame_obj_alloc failed";
LABEL_16:
      unsigned int v20 = v13;
      os_log_type_t v21 = v14;
LABEL_17:
      _os_log_impl(&dword_1830D4000, v20, v21, v15, buf, 0xCu);
      goto LABEL_18;
    }
    if (!v23)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v13 = gLogObj;
      os_log_type_t v14 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_frame_create";
      int v15 = "%{public}s nw_frame_obj_alloc failed, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v17 = gLogObj;
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v26 = "nw_frame_create";
        __int16 v27 = 2082;
        int v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s nw_frame_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_frame_create";
      int v15 = "%{public}s nw_frame_obj_alloc failed, no backtrace";
      unsigned int v20 = v17;
      os_log_type_t v21 = v18;
      goto LABEL_17;
    }
  }
LABEL_18:
  if (v12) {
    free(v12);
  }
  return v11;
}

void nw_frame_reset(uint64_t a1, uint64_t a2, int a3, uint64_t a4, uint64_t a5)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    int v6 = *(unsigned __int16 *)(a1 + 204);
    *(void *)(a1 + 80) = a4;
    *(void *)(a1 + 88) = a5;
    *(void *)(a1 + 112) = a2;
    *(void *)(a1 + 104) = 0;
    *(_WORD *)(a1 + 196) = 0;
    *(_DWORD *)(a1 + 48) = a3;
    *(_DWORD *)(a1 + 52) = a3;
    *(void *)(a1 + 56) = 0;
    *(_DWORD *)(a1 + 192) = 0;
    *(unsigned char *)(a1 + 200) = 0;
    unsigned int v7 = v6 & 0xFFFFFFC7 | (*(unsigned __int8 *)(a1 + 206) << 16);
    *(_WORD *)(a1 + 204) = v7;
    *(unsigned char *)(a1 + 206) = BYTE2(v7);
    uint64_t v9 = a1 + 64;
    CFArrayRef v8 = *(void **)(a1 + 64);
    if (v8)
    {
      uint64_t v10 = (void *)(a1 + 120);
      do
      {
        uint64_t v11 = (void *)*v8;
        unsigned int v12 = (void *)v8[6];
        uint64_t v13 = (void *)*v8;
        if (v12)
        {
          os_release(v12);
          v8[6] = 0;
          uint64_t v13 = (void *)*v8;
        }
        os_log_type_t v14 = (void *)v8[1];
        if (v13)
        {
          v13[1] = v14;
          os_log_type_t v14 = (void *)v8[1];
        }
        else
        {
          *(void *)(a1 + 72) = v14;
        }
        void *v14 = v13;
        if (v8 != v10) {
          free(v8);
        }
        CFArrayRef v8 = v11;
      }
      while (v11);
    }
    *(void *)(a1 + 64) = 0;
    *(void *)(a1 + 72) = v9;
    int v15 = *(void **)(a1 + 168);
    if (v15) {
      os_release(v15);
    }
    __int16 v17 = *(_WORD *)(a1 + 204);
    int v16 = (_WORD *)(a1 + 204);
    *(void *)(v16 - 10) = 0;
    *(_OWORD *)(v16 - 18) = 0u;
    *(_OWORD *)(v16 - 26) = 0u;
    *(_OWORD *)(v16 - 34) = 0u;
    *(_OWORD *)(v16 - 42) = 0u;
    *int v16 = v17 & 0x213F;
    *((unsigned char *)v16 - 1) = 0;
    *(v16 - 3) = 0;
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "__nw_frame_reset";
  os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v18, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "__nw_frame_reset";
      os_log_type_t v21 = "%{public}s called with null frame";
      goto LABEL_29;
    }
    if (!v24)
    {
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "__nw_frame_reset";
      os_log_type_t v21 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_29;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v23 = os_log_type_enabled(v19, type);
    if (backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "__nw_frame_reset";
        __int16 v28 = 2082;
        uint64_t v29 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_30;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "__nw_frame_reset";
      os_log_type_t v21 = "%{public}s called with null frame, no backtrace";
LABEL_29:
      _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
    }
  }
LABEL_30:
  if (v18) {
    free(v18);
  }
}

uint64_t ___ZL34nw_protocol_ipv4_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

BOOL nw_frame_claim(uint64_t a1, uint64_t a2, int a3, int a4)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x80) == 0) {
      goto LABEL_21;
    }
    if (!a4)
    {
LABEL_20:
      *(_WORD *)(a1 + 196) -= a3;
LABEL_21:
      unsigned int v13 = *(_DWORD *)(a1 + 56) + a3;
      int v14 = *(_DWORD *)(a1 + 60) + a4;
      if (v13 <= *(_DWORD *)(a1 + 52) - v14)
      {
        *(_DWORD *)(a1 + 56) = v13;
        *(_DWORD *)(a1 + 60) = v14;
        return 1;
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v15 = gLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
        if (result)
        {
          int v17 = *(_DWORD *)(a1 + 52);
          *(_DWORD *)buf = 136446978;
          __int16 v27 = "__nw_frame_claim_internal";
          __int16 v28 = 1024;
          LODWORD(v29) = v13;
          WORD2(v29) = 1024;
          *(_DWORD *)((char *)&v29 + 6) = v17;
          WORD5(v29) = 1024;
          HIDWORD(v29) = v14;
          _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s Claiming bytes failed because start (%u) is beyond end (%u - %u)", buf, 0x1Eu);
          return 0;
        }
      }
      return result;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "__nw_frame_claim_internal";
    __int16 v28 = 1024;
    LODWORD(v29) = a4;
    unsigned int v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (__nwlog_fault(v7, &type, &v24))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFArrayRef v8 = gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "__nw_frame_claim_internal";
        __int16 v28 = 1024;
        LODWORD(v29) = a4;
        uint64_t v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate";
        goto LABEL_17;
      }
      if (!v24)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        CFArrayRef v8 = gLogObj;
        os_log_type_t v9 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_18;
        }
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "__nw_frame_claim_internal";
        __int16 v28 = 1024;
        LODWORD(v29) = a4;
        uint64_t v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFArrayRef v8 = gLogObj;
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          __int16 v27 = "__nw_frame_claim_internal";
          __int16 v28 = 1024;
          LODWORD(v29) = a4;
          WORD2(v29) = 2082;
          *(void *)((char *)&v29 + 6) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446466;
        __int16 v27 = "__nw_frame_claim_internal";
        __int16 v28 = 1024;
        LODWORD(v29) = a4;
        uint64_t v10 = "%{public}s Trying to claim at the end %u bytes from a single-IP aggregate, no backtrace";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0x12u);
      }
    }
LABEL_18:
    if (v7) {
      free(v7);
    }
    goto LABEL_20;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "__nw_frame_claim_internal";
  os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v18, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "__nw_frame_claim_internal";
        os_log_type_t v21 = "%{public}s called with null frame";
LABEL_39:
        _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
      }
    }
    else if (v24)
    {
      unsigned int v22 = (char *)__nw_create_backtrace_string();
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v23 = os_log_type_enabled(v19, type);
      if (v22)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "__nw_frame_claim_internal";
          __int16 v28 = 2082;
          *(void *)&long long v29 = v22;
          _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v22);
        goto LABEL_40;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "__nw_frame_claim_internal";
        os_log_type_t v21 = "%{public}s called with null frame, no backtrace";
        goto LABEL_39;
      }
    }
    else
    {
      BOOL v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "__nw_frame_claim_internal";
        os_log_type_t v21 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_39;
      }
    }
  }
LABEL_40:
  if (v18) {
    free(v18);
  }
  return 0;
}

uint64_t ___ZL33nw_protocol_udp_get_output_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  id v4 = (id)nw_hash_node_get_object(a2);
  if ((nw_endpoint_is_active(v4, 1) & 1) != 0 || nw_hash_table_remove_node(*(void *)(a1 + 40), a2)) {
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  uint64_t v6 = *(void *)(a1 + 32);
  *(_DWORD *)buf = 136446978;
  uint64_t v26 = "nw_context_purge_endpoint_hash_table_block_invoke_2";
  __int16 v27 = 2114;
  uint64_t v28 = v6;
  __int16 v29 = 2082;
  logging_description = nw_endpoint_get_logging_description(v4);
  __int16 v31 = 2048;
  uint64_t v32 = a2;
  unsigned int v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v7, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFArrayRef v8 = (id)gLogObj;
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        uint64_t v10 = *(void *)(a1 + 32);
        uint64_t v11 = nw_endpoint_get_logging_description(v4);
        *(_DWORD *)buf = 136446978;
        uint64_t v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v10;
        __int16 v29 = 2082;
        logging_description = v11;
        __int16 v31 = 2048;
        uint64_t v32 = a2;
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p", buf, 0x2Au);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFArrayRef v8 = (id)gLogObj;
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v15)
        {
          uint64_t v16 = *(void *)(a1 + 32);
          int v17 = nw_endpoint_get_logging_description(v4);
          *(_DWORD *)buf = 136447234;
          uint64_t v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
          __int16 v27 = 2114;
          uint64_t v28 = v16;
          __int16 v29 = 2082;
          logging_description = v17;
          __int16 v31 = 2048;
          uint64_t v32 = a2;
          __int16 v33 = 2082;
          unsigned int v34 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v14, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p, dumping backtrace:%{public}s", buf, 0x34u);
        }

        free(backtrace_string);
        if (v7) {
          goto LABEL_9;
        }
        goto LABEL_10;
      }
      if (v15)
      {
        uint64_t v21 = *(void *)(a1 + 32);
        unsigned int v22 = nw_endpoint_get_logging_description(v4);
        *(_DWORD *)buf = 136446978;
        uint64_t v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v21;
        __int16 v29 = 2082;
        logging_description = v22;
        __int16 v31 = 2048;
        uint64_t v32 = a2;
        _os_log_impl(&dword_1830D4000, v8, v14, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p, no backtrace", buf, 0x2Au);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      CFArrayRef v8 = (id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        uint64_t v19 = *(void *)(a1 + 32);
        os_log_type_t v20 = nw_endpoint_get_logging_description(v4);
        *(_DWORD *)buf = 136446978;
        uint64_t v26 = "nw_context_purge_endpoint_hash_table_block_invoke";
        __int16 v27 = 2114;
        uint64_t v28 = v19;
        __int16 v29 = 2082;
        logging_description = v20;
        __int16 v31 = 2048;
        uint64_t v32 = a2;
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s %{public}@ failed to remove endpoint %{public}s for node %p, backtrace limit exceeded", buf, 0x2Au);
      }
    }
  }
  if (v7) {
LABEL_9:
  }
    free(v7);
LABEL_10:

  return 1;
}

void sub_1831087C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183108A88(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_url_endpoint;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void sub_183108D6C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, objc_super a11)
{
  a11.super_class = (Class)NWConcrete_nw_endpoint;
  [(_Unwind_Exception *)&a11 dealloc];
  _Unwind_Resume(a1);
}

void nw_endpoint_clear_alternatives(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __nw_endpoint_clear_alternatives_block_invoke;
    v11[3] = &unk_1E524BAA8;
    id v12 = v1;
    nw_endpoint_locked(v12, v11);

    goto LABEL_3;
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_endpoint_clear_alternatives";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v4, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_endpoint_clear_alternatives";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_endpoint_clear_alternatives";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

void sub_1831090A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_locked(void *a1, void *a2)
{
  id v4 = a1;
  id v3 = a2;
  os_unfair_lock_lock(v4 + 44);
  v3[2](v3);

  os_unfair_lock_unlock(v4 + 44);
}

void sub_183109138(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_clear_alternatives_block_invoke(uint64_t a1)
{
  id v1 = *(void **)(*(void *)(a1 + 32) + 160);
  if (v1)
  {
    do
    {
      id v3 = (void *)*v1;
      id v4 = (void *)v1[2];
      v1[2] = 0;

      id v5 = (void *)v1[3];
      v1[3] = 0;

      os_log_type_t v6 = (void *)*v1;
      unsigned int v7 = (void *)v1[1];
      if (*v1)
      {
        v6[1] = v7;
        unsigned int v7 = (void *)v1[1];
      }
      else
      {
        *(void *)(*(void *)(a1 + 32) + 168) = v7;
      }
      void *v7 = v6;
      *id v1 = 0;
      v1[1] = 0;
      if (v1 != (void *)(*(void *)(a1 + 32) + 128)) {
        free(v1);
      }
      id v1 = v3;
    }
    while (v3);
  }
}

uint64_t __nw_endpoint_enumerate_alternatives_block_invoke(uint64_t result)
{
  uint64_t v1 = result;
  uint64_t v2 = (void *)(*(void *)(result + 32) + 160);
  do
  {
    uint64_t v2 = (void *)*v2;
    if (!v2) {
      break;
    }
    BOOL result = (*(uint64_t (**)(void))(*(void *)(v1 + 40) + 16))();
  }
  while ((result & 1) != 0);
  return result;
}

uint64_t nw_endpoint_is_active(void *a1, int a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (!a2) {
      goto LABEL_6;
    }
    id v5 = (os_unfair_lock_s *)v3;
    *(void *)BOOL v61 = 0;
    *(void *)&v61[8] = v61;
    *(void *)&v61[16] = 0x2020000000;
    char v62 = 0;
    *(void *)os_log_type_t type = 0;
    uint64_t v55 = (uint64_t)type;
    uint64_t v56 = 0x2020000000;
    LOBYTE(v57) = 0;
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke;
    int v64 = &unk_1E524B978;
    os_log_type_t v65 = v5;
    char v66 = type;
    nw_endpoint_locked(v5, buf);
    char v6 = *(unsigned char *)(v55 + 24);

    _Block_object_dispose(type, 8);
    *(unsigned char *)(*(void *)&v61[8] + 24) = v6;
    _Block_object_dispose(v61, 8);
    if (v6)
    {
      if (gLogDatapath)
      {
        uint64_t v44 = __nwlog_obj();
        if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
        {
          logging_description = nw_endpoint_get_logging_description(v5);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = logging_description;
          _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has active edges", buf, 0x16u);
        }
      }
      int v7 = 1;
    }
    else
    {
LABEL_6:
      int v7 = 0;
    }
    os_log_type_t v8 = v4;
    Class isa = v8[26].isa;
    if (isa)
    {
      if (gLogDatapath)
      {
        uint64_t v35 = __nwlog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          int v36 = nw_endpoint_get_logging_description(v8);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
          *(_WORD *)&unsigned char buf[12] = 2080;
          *(void *)&buf[14] = v36;
          _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s before cleanup, has registrar", buf, 0x16u);
        }

        Class isa = v8[26].isa;
      }
      if (!nw_protocol_instance_registrar_get_instance_count(isa))
      {
        if (gLogDatapath)
        {
          uint64_t v48 = __nwlog_obj();
          if (os_log_type_enabled(v48, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v49 = nw_endpoint_get_logging_description(v8);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v49;
            _os_log_impl(&dword_1830D4000, v48, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s registrar empty, removing", buf, 0x16u);
          }
        }
        os_log_type_t v10 = v8[26].isa;
        v8[26].Class isa = 0;
        goto LABEL_19;
      }
      if (!gLogDatapath) {
        goto LABEL_20;
      }
      os_log_type_t v10 = __nwlog_obj();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG)) {
        goto LABEL_19;
      }
      uint64_t v11 = nw_endpoint_get_logging_description(v8);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v11;
      id v12 = "%{public}s endpoint %s registrar not empty, keeping";
    }
    else
    {
      if (!gLogDatapath) {
        goto LABEL_20;
      }
      os_log_type_t v10 = __nwlog_obj();
      if (!os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
LABEL_19:

LABEL_20:
        Class v14 = v8[26].isa;
        if (v14)
        {
          BOOL v15 = nw_protocol_instance_registrar_get_instance_count(v14) == 0;

          if (v15)
          {
            int v16 = 0;
LABEL_27:
            os_log_type_t v18 = v8;
            Class v19 = v18[1].isa;
            if (v19)
            {
              os_log_type_t v20 = v19;
              uint64_t v21 = v20;
              if (((_BYTE)v20[17] & 8) == 0) {
                dispatch_assert_queue_V2(v20[1]);
              }

              Class v22 = v18[25].isa;
              if (v22 && *((_DWORD *)v22 + 10))
              {
                *(void *)buf = MEMORY[0x1E4F143A8];
                *(void *)&buf[8] = 3221225472;
                *(void *)&buf[16] = __nw_endpoint_has_associations_block_invoke;
                int v64 = &unk_1E524AF58;
                char v23 = v18;
                os_log_type_t v65 = v23;
                nw_hash_table_apply((char *)v22, (uint64_t)buf);
                *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
                uint64_t v55 = 3221225472;
                uint64_t v56 = (uint64_t)__nw_endpoint_has_associations_block_invoke_36;
                id v57 = &unk_1E524BAA8;
                char v24 = v23;
                BOOL v58 = v24;
                os_unfair_lock_lock(v23 + 45);
                ((void (*)(os_log_type_t *))v56)(type);
                os_unfair_lock_unlock(v23 + 45);
                BOOL v25 = nw_hash_table_count((uint64_t)v18[25].isa) == 0;

                if (!v25)
                {
                  if (gLogDatapath)
                  {
                    int v46 = __nwlog_obj();
                    if (os_log_type_enabled(v46, OS_LOG_TYPE_DEBUG))
                    {
                      BOOL v47 = nw_endpoint_get_logging_description(v24);
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
                      *(_WORD *)&unsigned char buf[12] = 2080;
                      *(void *)&buf[14] = v47;
                      _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has associations", buf, 0x16u);
                    }
                  }
                  int v26 = 1;
                  goto LABEL_89;
                }
LABEL_88:
                int v26 = 0;
LABEL_89:
                uint64_t v52 = v7 | v16 | v26;
                goto LABEL_90;
              }
LABEL_87:

              goto LABEL_88;
            }
            __int16 v31 = __nwlog_obj();
            *(_DWORD *)BOOL v61 = 136446210;
            *(void *)&v61[4] = "nw_endpoint_has_associations";
            uint64_t v32 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v60 = OS_LOG_TYPE_ERROR;
            char v59 = 0;
            if (__nwlog_fault(v32, &v60, &v59))
            {
              if (v60 == OS_LOG_TYPE_FAULT)
              {
                __int16 v33 = __nwlog_obj();
                os_log_type_t v34 = v60;
                if (os_log_type_enabled(v33, v60))
                {
                  *(_DWORD *)BOOL v61 = 136446210;
                  *(void *)&v61[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null endpoint->context", v61, 0xCu);
                }
              }
              else if (v59)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                __int16 v33 = __nwlog_obj();
                os_log_type_t v41 = v60;
                BOOL v42 = os_log_type_enabled(v33, v60);
                if (backtrace_string)
                {
                  if (v42)
                  {
                    *(_DWORD *)BOOL v61 = 136446466;
                    *(void *)&v61[4] = "nw_endpoint_has_associations";
                    *(_WORD *)&v61[12] = 2082;
                    *(void *)&v61[14] = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v33, v41, "%{public}s called with null endpoint->context, dumping backtrace:%{public}s", v61, 0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_85;
                }
                if (v42)
                {
                  *(_DWORD *)BOOL v61 = 136446210;
                  *(void *)&v61[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_1830D4000, v33, v41, "%{public}s called with null endpoint->context, no backtrace", v61, 0xCu);
                }
              }
              else
              {
                __int16 v33 = __nwlog_obj();
                os_log_type_t v51 = v60;
                if (os_log_type_enabled(v33, v60))
                {
                  *(_DWORD *)BOOL v61 = 136446210;
                  *(void *)&v61[4] = "nw_endpoint_has_associations";
                  _os_log_impl(&dword_1830D4000, v33, v51, "%{public}s called with null endpoint->context, backtrace limit exceeded", v61, 0xCu);
                }
              }
            }
LABEL_85:
            if (v32) {
              free(v32);
            }
            goto LABEL_87;
          }
          if (!gLogDatapath)
          {
            int v16 = 1;
            goto LABEL_27;
          }
          __int16 v17 = __nwlog_obj();
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v43 = nw_endpoint_get_logging_description(v8);
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = v43;
            _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s endpoint %s has active protocol registrars", buf, 0x16u);
          }
          int v16 = 1;
        }
        else
        {
          int v16 = 0;
          __int16 v17 = v8;
        }

        goto LABEL_27;
      }
      char v13 = nw_endpoint_get_logging_description(v8);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_cleanup_empty_registrars";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = v13;
      id v12 = "%{public}s endpoint %s has nothing to cleanup, no protocol instance registrars";
    }
    _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, v12, buf, 0x16u);
    goto LABEL_19;
  }
  __int16 v27 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
  uint64_t v28 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v61[0] = 0;
  if (__nwlog_fault(v28, type, v61))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v29 = __nwlog_obj();
      os_log_type_t v30 = type[0];
      if (os_log_type_enabled(v29, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v61[0])
    {
      unsigned int v37 = (char *)__nw_create_backtrace_string();
      __int16 v29 = __nwlog_obj();
      os_log_type_t v38 = type[0];
      BOOL v39 = os_log_type_enabled(v29, type[0]);
      if (v37)
      {
        if (v39)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v37;
          _os_log_impl(&dword_1830D4000, v29, v38, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v37);
        goto LABEL_79;
      }
      if (v39)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_1830D4000, v29, v38, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v29 = __nwlog_obj();
      os_log_type_t v50 = type[0];
      if (os_log_type_enabled(v29, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_is_active";
        _os_log_impl(&dword_1830D4000, v29, v50, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_79:
  if (v28) {
    free(v28);
  }
  uint64_t v52 = 0;
LABEL_90:

  return v52;
}

void sub_183109D30(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_has_associations_block_invoke_36(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 231) & 8) != 0)
  {
    *(unsigned char *)(v2 + 231) &= ~8u;
  }
  else
  {
    id v3 = *(void **)(v2 + 64);
    if (v3)
    {
      free(v3);
      *(void *)(v2 + 64) = 0;
    }
    id v4 = *(void **)(v2 + 56);
    *(void *)(v2 + 56) = 0;
  }
  uint64_t v5 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v5 + 231) & 0x10) != 0)
  {
    *(unsigned char *)(v5 + 231) &= ~0x10u;
  }
  else
  {
    char v6 = *(void **)(v5 + 80);
    if (v6)
    {
      free(v6);
      *(void *)(v5 + 80) = 0;
    }
    int v7 = *(void **)(v5 + 72);
    *(void *)(v5 + 72) = 0;
  }
}

void ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 216);
  if (v2)
  {
    v3[0] = MEMORY[0x1E4F143A8];
    v3[1] = 3221225472;
    v3[2] = ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke_2;
    v3[3] = &unk_1E523B750;
    void v3[4] = *(void *)(a1 + 40);
    nw_array_remove_objects(v2, (uint64_t)v3);
  }
}

void __nw_endpoint_add_alternative_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  id v3 = *(void **)(v2 + 160);
  if (!v3) {
    goto LABEL_24;
  }
  id v4 = *(void **)(a1 + 40);
  if (v4 == &__block_literal_global_6268)
  {
    while (1)
    {
      id v12 = (void *)*v3;
      if (v3[3] == *(void *)(a1 + 48) && (_UNKNOWN *)v3[2] == &__block_literal_global_6268) {
        return;
      }
      id v3 = (void *)*v3;
      if (!v12) {
        goto LABEL_22;
      }
    }
  }
  while (1)
  {
    uint64_t v5 = (void *)*v3;
    if (v4 == &__block_literal_global_6268)
    {
      if (v3[3] == *(void *)(a1 + 48) && (_UNKNOWN *)v3[2] == &__block_literal_global_6268) {
        return;
      }
    }
    else
    {
      uint64_t v6 = *(void *)(a1 + 48);
      if (v6 && (_UNKNOWN *)v3[2] == &__block_literal_global_6268 && v3[3] == v6)
      {
        os_log_type_t v8 = (void *)v3[1];
        if (v5)
        {
          v5[1] = v8;
          os_log_type_t v8 = (void *)v3[1];
        }
        else
        {
          *(void *)(*(void *)(a1 + 32) + 168) = v8;
        }
        *os_log_type_t v8 = v5;
        *id v3 = 0;
        v3[1] = 0;
        if (v3 != (void *)(*(void *)(a1 + 32) + 128)) {
          free(v3);
        }
      }
      else if (v3[3] == v6)
      {
        int v7 = (void *)v3[2];
        if (v7 != &__block_literal_global_6268 && (nw_endpoint_is_equal(v7, v4, 31) & 1) != 0) {
          return;
        }
      }
    }
    if (!v5) {
      break;
    }
    id v4 = *(void **)(a1 + 40);
    id v3 = v5;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 160))
  {
LABEL_24:
    objc_storeStrong((id *)(v2 + 144), *(id *)(a1 + 40));
    objc_storeStrong((id *)(*(void *)(a1 + 32) + 152), *(id *)(a1 + 48));
    *(void *)(*(void *)(a1 + 32) + 128) = 0;
    *(void *)(*(void *)(a1 + 32) + 136) = *(void *)(*(void *)(a1 + 32) + 168);
    **(void **)(*(void *)(a1 + 32) + 168) = *(void *)(a1 + 32) + 128;
    uint64_t v11 = *(void *)(a1 + 32);
    BOOL v9 = (id *)(v11 + 128);
    goto LABEL_25;
  }
LABEL_22:
  BOOL v9 = (id *)malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v9)
  {
LABEL_23:
    objc_storeStrong(v9 + 2, *(id *)(a1 + 40));
    objc_storeStrong(v9 + 3, *(id *)(a1 + 48));
    id *v9 = 0;
    os_log_type_t v10 = *(id ***)(*(void *)(a1 + 32) + 168);
    v9[1] = v10;
    NSObject *v10 = v9;
    uint64_t v11 = *(void *)(a1 + 32);
LABEL_25:
    *(void *)(v11 + 168) = v9;
    return;
  }
  char v13 = __nwlog_obj();
  os_log_type_enabled(v13, OS_LOG_TYPE_ERROR);
  Class v14 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v14))
  {
    free(v14);
    goto LABEL_23;
  }
  __break(1u);
}

uint64_t __nw_endpoint_copy_properties_block_invoke(uint64_t a1, void *a2, void *a3)
{
  return 1;
}

void nw_endpoint_add_alternative(void *a1, void *a2, void *a3)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  int v7 = a3;
  os_log_type_t v8 = v7;
  if (!v5)
  {
    id v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_endpoint_add_alternative";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      Class v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v35)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      Class v14 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_endpoint_add_alternative";
          __int16 v39 = 2082;
          uint64_t v40 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_66:
        if (!v13) {
          goto LABEL_16;
        }
LABEL_67:
        free(v13);
        goto LABEL_16;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      Class v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_65:

    goto LABEL_66;
  }
  if (!v6)
  {
    int v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_endpoint_add_alternative";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      Class v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null alternative_endpoint", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (!v35)
    {
      Class v14 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null alternative_endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_65;
    }
    char v23 = (char *)__nw_create_backtrace_string();
    Class v14 = __nwlog_obj();
    os_log_type_t v24 = type;
    BOOL v25 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null alternative_endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (v25)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v38 = "nw_endpoint_add_alternative";
      __int16 v39 = 2082;
      uint64_t v40 = v23;
      _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null alternative_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_46;
  }
  if (v5 == v6)
  {
    os_log_type_t v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_endpoint_add_alternative";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      Class v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null (endpoint != alternative_endpoint)", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (!v35)
    {
      Class v14 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v30, "%{public}s called with null (endpoint != alternative_endpoint), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_65;
    }
    char v23 = (char *)__nw_create_backtrace_string();
    Class v14 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v27 = os_log_type_enabled(v14, type);
    if (!v23)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_endpoint_add_alternative";
        _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null (endpoint != alternative_endpoint), no backtrace", buf, 0xCu);
      }
      goto LABEL_65;
    }
    if (v27)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v38 = "nw_endpoint_add_alternative";
      __int16 v39 = 2082;
      uint64_t v40 = v23;
      _os_log_impl(&dword_1830D4000, v14, v26, "%{public}s called with null (endpoint != alternative_endpoint), dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_46:

    free(v23);
    if (!v13) {
      goto LABEL_16;
    }
    goto LABEL_67;
  }
  if (v6 != &__block_literal_global_6268 || v7)
  {
    if (v7)
    {
      if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
        dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55981);
      }
      id v9 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v8, (uint64_t)v9);

      if (is_equal_unsafe)
      {
        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        uint64_t v11 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;

        os_log_type_t v8 = v11;
      }
    }
    v31[0] = MEMORY[0x1E4F143A8];
    v31[1] = 3221225472;
    v31[2] = __nw_endpoint_add_alternative_block_invoke;
    v31[3] = &unk_1E5249868;
    id v32 = v5;
    id v33 = v6;
    os_log_type_t v34 = v8;
    os_log_type_t v8 = v8;
    nw_endpoint_locked(v32, v31);
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v8 = (id)gLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v38 = "nw_endpoint_add_alternative";
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s Cannot set an unknown alternative endpoint without a protocol", buf, 0xCu);
    }
  }
LABEL_16:
}

void sub_18310AA60(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_connection_create_with_id_block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  if (!v6)
  {
    if (v5 == &__block_literal_global_6268) {
      goto LABEL_25;
    }
    uint64_t v13 = *(void *)(*(void *)(a1 + 32) + 16);
    if (!v13 || nw_path_parameters_get_logging_disabled(*(void *)(v13 + 104))) {
      goto LABEL_25;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v8 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    int v14 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
    int v17 = 136446722;
    os_log_type_t v18 = "nw_connection_create_with_id_block_invoke";
    __int16 v19 = 1024;
    int v20 = v14;
    __int16 v21 = 2082;
    logging_description = nw_endpoint_get_logging_description(v5);
    os_log_type_t v10 = "%{public}s [C%u] has alternative %{public}s";
LABEL_22:
    uint64_t v11 = v8;
    uint32_t v12 = 28;
    goto LABEL_23;
  }
  uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 16);
  if (v5 == &__block_literal_global_6268)
  {
    if (!v7 || nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104))) {
      goto LABEL_25;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v8 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
    int v17 = 136446722;
    os_log_type_t v18 = "nw_connection_create_with_id_block_invoke";
    __int16 v19 = 1024;
    int v20 = v15;
    __int16 v21 = 2114;
    logging_description = v6;
    os_log_type_t v10 = "%{public}s [C%u] has alternative UNKNOWN for %{public}@";
    goto LABEL_22;
  }
  if (v7 && !nw_path_parameters_get_logging_disabled(*(void *)(v7 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v8 = (id)gconnectionLogObj;
    if (!os_log_type_enabled(v8, OS_LOG_TYPE_INFO)) {
      goto LABEL_24;
    }
    int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
    int v17 = 136446978;
    os_log_type_t v18 = "nw_connection_create_with_id_block_invoke";
    __int16 v19 = 1024;
    int v20 = v9;
    __int16 v21 = 2082;
    logging_description = nw_endpoint_get_logging_description(v5);
    __int16 v23 = 2114;
    os_log_type_t v24 = v6;
    os_log_type_t v10 = "%{public}s [C%u] has alternative %{public}s for %{public}@";
    uint64_t v11 = v8;
    uint32_t v12 = 38;
LABEL_23:
    _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, v10, (uint8_t *)&v17, v12);
LABEL_24:
  }
LABEL_25:

  return 1;
}

void sub_18310AD78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_enumerate_edges_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 216);
  uint64_t v3 = nw_array_create();
  uint64_t v4 = v3;
  if (v2)
  {
    if (v3 == v2) {
      uint64_t v4 = v2;
    }
    else {
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v3 + 16, *(void ***)(v2 + 16), *(void ***)(v2 + 24), (uint64_t)(*(void *)(v2 + 24) - *(void *)(v2 + 16)) >> 3);
    }
  }
  uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
  id v6 = *(void **)(v5 + 40);
  *(void *)(v5 + 40) = v4;
}

uint64_t nw_protocol_instance_registrar_get_instance_count(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    uint64_t v20 = 0;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_protocol_instance_registrar_get_instance_count_block_invoke;
    aBlock[3] = &unk_1E524B978;
    int v16 = buf;
    int v15 = v1;
    uint64_t v3 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 2);
    v3[2](v3);
    os_unfair_lock_unlock(v2 + 2);

    uint64_t v4 = *(void *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null registrar", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null registrar, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null registrar, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_instance_registrar_get_instance_count";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null registrar, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0;
LABEL_3:

  return v4;
}

void sub_18310B164(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_instance_registrar_get_instance_count_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(void *)(*(void *)(result + 32) + 64);
  return result;
}

void nw_protocol_remove_instance(uint64_t a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_protocol_remove_instance";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v9, &type, &v18)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_remove_instance";
      BOOL v12 = "%{public}s called with null protocol";
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v21 = "nw_protocol_remove_instance";
          __int16 v22 = 2082;
          __int16 v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_38;
      }
      if (!v16)
      {
LABEL_38:
        if (v9) {
          free(v9);
        }
        return;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_remove_instance";
      BOOL v12 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (!os_log_type_enabled(v10, type)) {
        goto LABEL_38;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "nw_protocol_remove_instance";
      BOOL v12 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
    goto LABEL_38;
  }
  nw_allow_use_of_dispatch_internal();
  if (gLogDatapath)
  {
    os_log_type_t v13 = __nwlog_obj();
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v14 = *(void *)(a1 + 16);
      *(_DWORD *)buf = 136446722;
      uint64_t v21 = "nw_protocol_remove_instance";
      __int16 v22 = 2048;
      __int16 v23 = (char *)a1;
      __int16 v24 = 2080;
      uint64_t v25 = v14;
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s checking to remove instance %p of %s", buf, 0x20u);
    }
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v2 = *(void **)(a1 + 16);
  uint64_t v3 = &g_registration_list;
  while (1)
  {
    uint64_t v3 = (uint64_t *)*v3;
    if (!v3) {
      break;
    }
    if (*v2 == v3[4] && v2[1] == v3[5] && v2[2] == v3[6] && v2[3] == v3[7] && v2[4] == v3[8])
    {
      uint64_t v8 = v3[9];
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 0x40000000;
      v17[2] = __nw_protocol_remove_instance_block_invoke;
      v17[3] = &__block_descriptor_tmp_44323;
      v17[4] = a1;
      nw_array_remove_objects(v8, (uint64_t)v17);
      break;
    }
  }
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
}

void nw_array_remove_objects(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    int v22 = 136446210;
    *(_DWORD *)buf = 136446210;
    uint64_t v3 = "nw_array_remove_objects";
    uint64_t v26 = "nw_array_remove_objects";
    uint64_t v5 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault((const char *)v5, &type, &v23)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_array_remove_objects";
      os_log_type_t v13 = "%{public}s called with null array";
      goto LABEL_55;
    }
LABEL_36:
    if (!v23)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = v22;
      uint64_t v26 = v3;
      os_log_type_t v13 = "%{public}s called with null array, backtrace limit exceeded";
      goto LABEL_55;
    }
    char v17 = v3;
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (!v19) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = v17;
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      uint64_t v20 = "%{public}s called with null array, dumping backtrace:%{public}s";
      goto LABEL_44;
    }
    if (v19)
    {
      *(_DWORD *)buf = v22;
      uint64_t v26 = v17;
      os_log_type_t v13 = "%{public}s called with null array, no backtrace";
LABEL_55:
      _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      goto LABEL_56;
    }
    goto LABEL_56;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_array_remove_objects";
    uint64_t v5 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault((const char *)v5, &type, &v23)) {
      goto LABEL_56;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_array_remove_objects";
      os_log_type_t v13 = "%{public}s called with null remove_block";
      goto LABEL_55;
    }
    if (!v23)
    {
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_56;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_array_remove_objects";
      os_log_type_t v13 = "%{public}s called with null remove_block, backtrace limit exceeded";
      goto LABEL_55;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v21 = os_log_type_enabled(v11, type);
    if (backtrace_string)
    {
      if (!v21) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v26 = "nw_array_remove_objects";
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      uint64_t v20 = "%{public}s called with null remove_block, dumping backtrace:%{public}s";
LABEL_44:
      _os_log_impl(&dword_1830D4000, v11, v12, v20, buf, 0x16u);
LABEL_45:
      free(backtrace_string);
      if (!v5) {
        return;
      }
LABEL_57:
      free((void *)v5);
      return;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_array_remove_objects";
      os_log_type_t v13 = "%{public}s called with null remove_block, no backtrace";
      goto LABEL_55;
    }
LABEL_56:
    if (!v5) {
      return;
    }
    goto LABEL_57;
  }
  uint64_t v5 = a1;
  __swp(v2, (unsigned int *)(a1 + 40));
  if (v2)
  {
    uint64_t v14 = __nwlog_obj();
    os_log_type_enabled(v14, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_array_remove_objects";
    int v15 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v15))
    {
      free(v15);
      atomic_exchange_explicit((atomic_uchar *volatile)(v5 + 40), v2, memory_order_release);
      return;
    }
LABEL_35:
    __break(1u);
    goto LABEL_36;
  }
  id v6 = *(void ***)(a1 + 16);
  uint64_t v3 = *(const char **)(a1 + 24);
  if (v6 != (void **)v3)
  {
    while (((*(uint64_t (**)(uint64_t, void *))(a2 + 16))(a2, *v6) & 1) == 0)
    {
      if (++v6 == (void **)v3)
      {
        id v6 = (void **)v3;
        goto LABEL_16;
      }
    }
    if (v6 != (void **)v3)
    {
      for (i = (const char *)(v6 + 1); i != v3; i += 8)
      {
        if (((*(uint64_t (**)(uint64_t, void))(a2 + 16))(a2, *(void *)i) & 1) == 0)
        {
          if (*v6) {
            os_release(*v6);
          }
          *v6++ = *(void **)i;
          *(void *)i = 0;
        }
      }
    }
  }
LABEL_16:
  uint64_t v8 = *(void ***)(v5 + 24);
  if (v6 != v8)
  {
    uint64_t v3 = *(const char **)(v5 + 24);
    do
    {
      os_log_type_t v10 = (void *)*((void *)v3 - 1);
      v3 -= 8;
      os_log_type_t v9 = v10;
      if (v10) {
        os_release(v9);
      }
      *(v8 - 1) = 0;
      uint64_t v8 = (void **)v3;
    }
    while (v3 != (const char *)v6);
    *(void *)(v5 + 24) = v6;
  }
  if (atomic_exchange_explicit((atomic_uchar *volatile)(v5 + 40), 0, memory_order_release) != 255)
  {
    BOOL v16 = __nwlog_obj();
    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_array_remove_objects";
    uint64_t v5 = _os_log_send_and_compose_impl();
    if (!__nwlog_abort(v5)) {
      goto LABEL_57;
    }
    goto LABEL_35;
  }
}

uint64_t ___ZL33nw_endpoint_remove_inactive_edgesP22NWConcrete_nw_endpoint_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v18 = "nw_endpoint_edge_is_active";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_endpoint_edge_is_active";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null edge", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            char v18 = "nw_endpoint_edge_is_active";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null edge, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_endpoint_edge_is_active";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null edge, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_endpoint_edge_is_active";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null edge, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v8) {
      free(v8);
    }
    return 1;
  }
  id WeakRetained = objc_loadWeakRetained((id *)(a2 + 48));
  if (!WeakRetained) {
    return 1;
  }
  uint64_t v4 = WeakRetained;
  int is_active = nw_endpoint_is_active(WeakRetained, 0);

  uint64_t result = 1;
  if (is_active)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
    return 0;
  }
  return result;
}

void sub_18310BE2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_proxy_copy_http_connect_definition()
{
  if (nw_proxy_copy_http_connect_definition::onceToken != -1) {
    dispatch_once(&nw_proxy_copy_http_connect_definition::onceToken, &__block_literal_global_102_35650);
  }
  uint64_t v0 = (void *)nw_proxy_copy_http_connect_definition::proxy_definition;

  return v0;
}

uint64_t ___ZL25nw_resolver_update_clientP22NWConcrete_nw_resolverU13block_pointerFvvE_block_invoke(void *a1)
{
  unsigned int v2 = (os_unfair_lock_s *)a1[4];
  uint64_t v3 = v2 + 3;
  uint64_t v4 = v2;
  os_unfair_lock_lock(v3);
  uint64_t v5 = *(void *)&v4[24]._os_unfair_lock_opaque;
  os_unfair_lock_unlock(v3);

  if (v5) {
    (*(void (**)(void))(a1[6] + 16))();
  }
  uint64_t result = a1[7];
  if (result)
  {
    id v7 = *(uint64_t (**)(void))(result + 16);
    return v7();
  }
  return result;
}

void sub_18310BFA4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_resolver_receive_report(void *a1, int a2, unsigned int a3, unsigned __int16 *a4, void *a5, void *a6)
{
  uint64_t v310 = *MEMORY[0x1E4F143B8];
  object = a1;
  id v268 = a5;
  id v12 = a6;
  v269 = v12;
  if (!v12)
  {
    v185 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
    id v186 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v286 = 0;
    if (__nwlog_fault(v186, type, &v286))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v187 = __nwlog_obj();
        os_log_type_t v188 = type[0];
        if (os_log_type_enabled(v187, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
          _os_log_impl(&dword_1830D4000, v187, v188, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v286)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v187 = __nwlog_obj();
        os_log_type_t v190 = type[0];
        BOOL v191 = os_log_type_enabled(v187, type[0]);
        if (backtrace_string)
        {
          if (v191)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v187, v190, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_226;
        }
        if (v191)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
          _os_log_impl(&dword_1830D4000, v187, v190, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v187 = __nwlog_obj();
        os_log_type_t v192 = type[0];
        if (os_log_type_enabled(v187, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
          _os_log_impl(&dword_1830D4000, v187, v192, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_226:
    if (v186) {
      free(v186);
    }
    goto LABEL_18;
  }
  BOOL v13 = (unsigned int *)v12;
  uint64_t v14 = v13[29];

  if (v14 == 1)
  {
    id obj = a1;
    char v15 = v13;
    char v16 = *((unsigned char *)v15 + 268);

    char v17 = &unk_1EB267000;
    v267 = v15;
    v256 = a4;
    unsigned int v259 = a3;
    if ((v16 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v18 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        __int16 v19 = v15;

        uint64_t v20 = v19;
        char v21 = *((unsigned char *)v15 + 268);

        if (v21) {
          int v22 = "dry-run ";
        }
        else {
          int v22 = "";
        }
        os_log_t log = v18;
        nw_endpoint_t v249 = nw_endpoint_handler_copy_endpoint(v20);
        logging_description = nw_endpoint_get_logging_description(v249);
        __int16 v24 = v20;
        uint64_t v25 = v24;
        uint64_t v26 = v24[30];
        if (v26 > 5) {
          __int16 v27 = "unknown-state";
        }
        else {
          __int16 v27 = off_1E523FB38[v26];
        }
        __int16 v247 = v27;

        __int16 v31 = v25;
        v248 = logging_description;
        id v32 = "path";
        switch(v13[29])
        {
          case 0u:
            break;
          case 1u:
            id v32 = "resolver";
            break;
          case 2u:
            id v32 = nw_endpoint_flow_mode_string(v31[31]);
            break;
          case 3u:
            id v32 = "proxy";
            break;
          case 4u:
            id v32 = "fallback";
            break;
          case 5u:
            id v32 = "transform";
            break;
          default:
            id v32 = "unknown-mode";
            break;
        }
        v246 = v32;

        id v33 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v33 + 28);
        id v34 = v33[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v33 + 28);

        id v35 = v34;
        id_string = nw_endpoint_handler_get_id_string(object);
        unsigned int v37 = nw_endpoint_handler_dry_run_string(object);
        nw_endpoint_t v38 = nw_endpoint_handler_copy_endpoint(object);
        __int16 v39 = v22;
        int v245 = a2;
        v252 = v13;
        uint64_t v40 = nw_endpoint_get_logging_description(v38);
        uint64_t v41 = (char *)(v19 + 42);
        BOOL v42 = nw_endpoint_handler_state_string(object);
        uint64_t v43 = nw_endpoint_handler_mode_string(object);
        id v44 = nw_endpoint_handler_copy_current_path(object);
        *(_DWORD *)buf = 136449282;
        *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v41;
        __int16 v288 = 2082;
        v289 = v39;
        __int16 v290 = 2082;
        v291 = v248;
        __int16 v292 = 2082;
        v293 = (void *)v247;
        __int16 v294 = 2082;
        v295 = v246;
        __int16 v296 = 2114;
        id v297 = v35;
        __int16 v298 = 2082;
        uint64_t v299 = (uint64_t)id_string;
        __int16 v300 = 2082;
        v301 = v37;
        __int16 v302 = 2082;
        v303 = v40;
        __int16 v304 = 2082;
        v305 = v42;
        __int16 v306 = 2082;
        v307 = v43;
        __int16 v308 = 2114;
        id v309 = v44;
        char v18 = log;
        _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

        char v17 = &unk_1EB267000;
        BOOL v13 = v252;
        a2 = v245;
      }
      char v15 = v267;
      a4 = v256;
      a3 = v259;
    }
    nw_endpoint_handler_report(v15, object, a4, v268);
    os_log_type_t v45 = nw_endpoint_handler_copy_resolver((NWConcrete_nw_endpoint_handler *)v15);
    uint64_t v46 = *((void *)v45 + 5);
    if (v46 && object)
    {
      uint64_t v48 = *(id **)(v46 + 16);
      BOOL v47 = *(id **)(v46 + 24);
      if (v48 != v47)
      {
        while (*v48 != object)
        {
          if (++v48 == v47)
          {
            uint64_t v48 = *(id **)(v46 + 24);
            break;
          }
        }
      }
      if (v48 != v47)
      {
        if (a4 && *a4 - 1 <= 1 && a4[1] == 7)
        {
          int v49 = 1;
LABEL_87:
          BOOL v84 = networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_no_happy_eyeballs_full_stack);
          BOOL v85 = 0;
          if (v259 == 2 && a4) {
            BOOL v85 = *a4 == 3 && a4[1] == 5;
          }
          if (v268)
          {
            os_log_type_t v86 = v268;
            unsigned int v87 = v86[3];

            if (v87 > 0x3D) {
              LODWORD(v88) = 1;
            }
            else {
              unint64_t v88 = (0xFFFFFFFFFFFFFFEuLL >> v87) & 1;
            }
          }
          else
          {
            LODWORD(v88) = 0;
          }
          if (v259 != 3)
          {
            int v105 = *((unsigned __int8 *)v45 + 24);
            char v106 = v88 & v105;
            int v107 = v84 ? v85 : v88 & v105;
            if ((v106 & 1) == 0 && !v107)
            {
              if (v259 == 4)
              {
                uint64_t v108 = *((void *)v45 + 6);
                if (v108)
                {
                  long long v110 = *(id **)(v108 + 16);
                  long long v109 = *(id **)(v108 + 24);
                  if (v110 != v109)
                  {
                    while (*v110 != object)
                    {
                      if (++v110 == v109)
                      {
                        long long v110 = *(id **)(v108 + 24);
                        break;
                      }
                    }
                  }
                  uint64_t v111 = v267;
                  if (v110 != v109)
                  {
LABEL_130:
                    unsigned int v114 = v111;
                    int state = v114->state;

                    if (state != 5)
                    {
                      uint64_t v116 = *((void *)v45 + 6);
                      if (v116) {
                        uint64_t v116 = (uint64_t)(*(void *)(v116 + 24) - *(void *)(v116 + 16)) >> 3;
                      }
                      uint64_t v117 = *((void *)v45 + 5);
                      if (v117) {
                        uint64_t v117 = (uint64_t)(*(void *)(v117 + 24) - *(void *)(v117 + 16)) >> 3;
                      }
                      if (v116 == v117)
                      {
                        char v118 = *((unsigned char *)v45 + 24);
                        if ((v118 & 4) == 0)
                        {
                          nw_endpoint_resolver_check_desperate_ivan(v114);
                          char v118 = *((unsigned char *)v45 + 24);
                        }
                        if ((v118 & 8) != 0 && nw_endpoint_resolver_add_desperate_ivan(v114))
                        {
                          id v119 = nw_endpoint_handler_copy_context(v114);
                          v280[0] = MEMORY[0x1E4F143A8];
                          v280[1] = 3221225472;
                          v280[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_2;
                          v280[3] = &unk_1E524BAA8;
                          v281 = v114;
                          nw_queue_context_async(v119, v280);

                          p_super = &v281->super;
                          goto LABEL_159;
                        }
                        int v166 = *((_DWORD *)v45 + 4);
                        int minimize_logging = nw_endpoint_handler_get_minimize_logging(v114);
                        char logging_disabled = nw_endpoint_handler_get_logging_disabled(v114);
                        if (v166 == 1)
                        {
                          if (minimize_logging)
                          {
                            if (logging_disabled) {
                              goto LABEL_190;
                            }
                            if (v17[191] != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                            }
                            p_super = (id)gconnectionLogObj;
                            if (os_log_type_enabled(p_super, OS_LOG_TYPE_DEBUG))
                            {
                              v232 = nw_endpoint_handler_get_id_string(v114);
                              __int16 v233 = nw_endpoint_handler_dry_run_string(v114);
                              nw_endpoint_t v234 = nw_endpoint_handler_copy_endpoint(v114);
                              __int16 v235 = nw_endpoint_get_logging_description(v234);
                              v236 = nw_endpoint_handler_state_string(v114);
                              __int16 v237 = nw_endpoint_handler_mode_string(v114);
                              id v238 = nw_endpoint_handler_copy_current_path(v114);
                              *(_DWORD *)buf = 136447746;
                              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                              *(_WORD *)&unsigned char buf[12] = 2082;
                              *(void *)&buf[14] = v232;
                              __int16 v288 = 2082;
                              v289 = v233;
                              __int16 v290 = 2082;
                              v291 = v235;
                              __int16 v292 = 2082;
                              v293 = (void *)v236;
                              __int16 v294 = 2082;
                              v295 = v237;
                              __int16 v296 = 2114;
                              id v297 = v238;
                              _os_log_impl(&dword_1830D4000, p_super, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed, but resolver isn't done. Wait.", buf, 0x48u);
                            }
                          }
                          else
                          {
                            if (logging_disabled) {
                              goto LABEL_190;
                            }
                            if (v17[191] != -1) {
                              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                            }
                            p_super = (id)gconnectionLogObj;
                            if (os_log_type_enabled(p_super, OS_LOG_TYPE_INFO))
                            {
                              v169 = nw_endpoint_handler_get_id_string(v114);
                              nw_endpoint_t v170 = nw_endpoint_handler_dry_run_string(v114);
                              nw_endpoint_t v171 = nw_endpoint_handler_copy_endpoint(v114);
                              v172 = nw_endpoint_get_logging_description(v171);
                              v173 = nw_endpoint_handler_state_string(v114);
                              id v174 = nw_endpoint_handler_mode_string(v114);
                              id v175 = nw_endpoint_handler_copy_current_path(v114);
                              *(_DWORD *)buf = 136447746;
                              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                              *(_WORD *)&unsigned char buf[12] = 2082;
                              *(void *)&buf[14] = v169;
                              __int16 v288 = 2082;
                              v289 = v170;
                              __int16 v290 = 2082;
                              v291 = v172;
                              __int16 v292 = 2082;
                              v293 = (void *)v173;
                              __int16 v294 = 2082;
                              v295 = v174;
                              __int16 v296 = 2114;
                              id v297 = v175;
                              _os_log_impl(&dword_1830D4000, p_super, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed, but resolver isn't done. Wait.", buf, 0x48u);
                            }
                          }
                          goto LABEL_159;
                        }
                        if (minimize_logging)
                        {
                          if (logging_disabled) {
                            goto LABEL_206;
                          }
                          if (v17[191] != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          nw_endpoint_t v176 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v176, OS_LOG_TYPE_DEBUG))
                          {
                            v266 = nw_endpoint_handler_get_id_string(v114);
                            __int16 v239 = nw_endpoint_handler_dry_run_string(v114);
                            nw_endpoint_t v240 = nw_endpoint_handler_copy_endpoint(v114);
                            __int16 v241 = nw_endpoint_get_logging_description(v240);
                            v242 = nw_endpoint_handler_state_string(v114);
                            __int16 v243 = nw_endpoint_handler_mode_string(v114);
                            id v244 = nw_endpoint_handler_copy_current_path(v114);
                            *(_DWORD *)buf = 136447746;
                            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                            *(_WORD *)&unsigned char buf[12] = 2082;
                            *(void *)&buf[14] = v266;
                            __int16 v288 = 2082;
                            v289 = v239;
                            __int16 v290 = 2082;
                            v291 = v241;
                            __int16 v292 = 2082;
                            v293 = (void *)v242;
                            __int16 v294 = 2082;
                            v295 = v243;
                            __int16 v296 = 2114;
                            id v297 = v244;
                            _os_log_impl(&dword_1830D4000, v176, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed", buf, 0x48u);
                          }
                        }
                        else
                        {
                          if (logging_disabled)
                          {
LABEL_206:
                            nw_endpoint_handler_handle_failure(v114);
                            if (v49) {
                              __int16 v184 = 7;
                            }
                            else {
                              __int16 v184 = 5;
                            }
                            v114->event.domain = 2;
                            v114->event.event = v184;
                            nw_endpoint_handler_report(v114, 0, &v114->event.domain, 0);
                            goto LABEL_190;
                          }
                          if (v17[191] != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          nw_endpoint_t v176 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v176, OS_LOG_TYPE_INFO))
                          {
                            v263 = v176;
                            os_log_type_t v177 = nw_endpoint_handler_get_id_string(v114);
                            v178 = nw_endpoint_handler_dry_run_string(v114);
                            nw_endpoint_t v179 = nw_endpoint_handler_copy_endpoint(v114);
                            id v180 = nw_endpoint_get_logging_description(v179);
                            v181 = nw_endpoint_handler_state_string(v114);
                            nw_endpoint_t v182 = nw_endpoint_handler_mode_string(v114);
                            id v183 = nw_endpoint_handler_copy_current_path(v114);
                            *(_DWORD *)buf = 136447746;
                            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                            *(_WORD *)&unsigned char buf[12] = 2082;
                            *(void *)&buf[14] = v177;
                            __int16 v288 = 2082;
                            v289 = v178;
                            __int16 v290 = 2082;
                            v291 = v180;
                            __int16 v292 = 2082;
                            v293 = (void *)v181;
                            __int16 v294 = 2082;
                            v295 = v182;
                            __int16 v296 = 2114;
                            id v297 = v183;
                            _os_log_impl(&dword_1830D4000, v263, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all children failed", buf, 0x48u);

                            nw_endpoint_t v176 = v263;
                          }
                        }

                        goto LABEL_206;
                      }
                      if (v116 != *((_DWORD *)v45 + 5)) {
                        goto LABEL_190;
                      }
                      int v151 = nw_endpoint_handler_get_minimize_logging(v114);
                      char v152 = nw_endpoint_handler_get_logging_disabled(v114);
                      if (v151)
                      {
                        if (v152) {
                          goto LABEL_179;
                        }
                        if (v17[191] != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        id v225 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v225, OS_LOG_TYPE_DEBUG))
                        {
                          v265 = nw_endpoint_handler_get_id_string(v114);
                          v226 = nw_endpoint_handler_dry_run_string(v114);
                          nw_endpoint_t v227 = nw_endpoint_handler_copy_endpoint(v114);
                          v228 = nw_endpoint_get_logging_description(v227);
                          uint64_t v229 = nw_endpoint_handler_state_string(v114);
                          char v230 = nw_endpoint_handler_mode_string(v114);
                          id v231 = nw_endpoint_handler_copy_current_path(v114);
                          *(_DWORD *)buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                          *(_WORD *)&unsigned char buf[12] = 2082;
                          *(void *)&buf[14] = v265;
                          __int16 v288 = 2082;
                          v289 = v226;
                          __int16 v290 = 2082;
                          v291 = v228;
                          __int16 v292 = 2082;
                          v293 = (void *)v229;
                          __int16 v294 = 2082;
                          v295 = v230;
                          __int16 v296 = 2114;
                          id v297 = v231;
                          _os_log_impl(&dword_1830D4000, v225, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started children failed, start next child.", buf, 0x48u);
                        }
                        os_log_type_t v153 = v225;
                      }
                      else
                      {
                        if (v152)
                        {
LABEL_179:
                          if (v49)
                          {
                            v161 = (void *)*((void *)v45 + 4);
                            *((void *)v45 + 4) = 0;
                          }
                          id v162 = nw_endpoint_handler_copy_context(v114);
                          v278[0] = MEMORY[0x1E4F143A8];
                          v278[1] = 3221225472;
                          v278[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_114;
                          v278[3] = &unk_1E524BAA8;
                          v279 = v114;
                          nw_queue_context_async(v162, v278);

                          p_super = &v279->super;
                          goto LABEL_159;
                        }
                        if (v17[191] != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        os_log_type_t v153 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v153, OS_LOG_TYPE_INFO))
                        {
                          BOOL v154 = nw_endpoint_handler_get_id_string(v114);
                          os_log_type_t v155 = nw_endpoint_handler_dry_run_string(v114);
                          v262 = v153;
                          nw_endpoint_t v156 = nw_endpoint_handler_copy_endpoint(v114);
                          v157 = nw_endpoint_get_logging_description(v156);
                          BOOL v158 = nw_endpoint_handler_state_string(v114);
                          v159 = nw_endpoint_handler_mode_string(v114);
                          id v160 = nw_endpoint_handler_copy_current_path(v114);
                          *(_DWORD *)buf = 136447746;
                          *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                          *(_WORD *)&unsigned char buf[12] = 2082;
                          *(void *)&buf[14] = v154;
                          __int16 v288 = 2082;
                          v289 = v155;
                          __int16 v290 = 2082;
                          v291 = v157;
                          __int16 v292 = 2082;
                          v293 = (void *)v158;
                          __int16 v294 = 2082;
                          v295 = v159;
                          __int16 v296 = 2114;
                          id v297 = v160;
                          _os_log_impl(&dword_1830D4000, v262, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] all started children failed, start next child.", buf, 0x48u);

                          os_log_type_t v153 = v262;
                        }
                      }

                      goto LABEL_179;
                    }
LABEL_190:

                    uint64_t v30 = 1;
                    goto LABEL_191;
                  }
                }
                else
                {
                  BOOL v112 = nw_array_create();
                  uint64_t v113 = (void *)*((void *)v45 + 6);
                  *((void *)v45 + 6) = v112;

                  uint64_t v108 = *((void *)v45 + 6);
                }
                nw_array_append(v108, object);
                uint64_t v111 = v267;
                goto LABEL_130;
              }
              if (v105 & 1 | !v85) {
                goto LABEL_190;
              }
              *((unsigned char *)v45 + 24) = v105 | 1;
              if (!*((void *)v45 + 7)) {
                goto LABEL_190;
              }
              int v124 = nw_endpoint_handler_get_minimize_logging(v267);
              char v125 = nw_endpoint_handler_get_logging_disabled(v267);
              if (v124)
              {
                if (v125) {
                  goto LABEL_155;
                }
                if (v17[191] != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v126 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
                {
                  os_log_type_t v207 = nw_endpoint_handler_get_id_string(v267);
                  v208 = nw_endpoint_handler_dry_run_string(v267);
                  nw_endpoint_t v209 = nw_endpoint_handler_copy_endpoint(v267);
                  v210 = nw_endpoint_get_logging_description(v209);
                  v211 = nw_endpoint_handler_state_string(v267);
                  v212 = nw_endpoint_handler_mode_string(v267);
                  id v213 = nw_endpoint_handler_copy_current_path(v267);
                  *(_DWORD *)buf = 136448002;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v207;
                  __int16 v288 = 2082;
                  v289 = v208;
                  __int16 v290 = 2082;
                  v291 = v210;
                  __int16 v292 = 2082;
                  v293 = (void *)v211;
                  __int16 v294 = 2082;
                  v295 = v212;
                  __int16 v296 = 2114;
                  id v297 = v213;
                  __int16 v298 = 2048;
                  uint64_t v299 = 2000;
                  _os_log_impl(&dword_1830D4000, v126, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] pushing out endpoint race by %llums", buf, 0x52u);
                }
              }
              else
              {
                if (v125)
                {
LABEL_155:
                  uint64_t v134 = *((void *)v45 + 7);
                  dispatch_time_t v135 = dispatch_time(0x8000000000000000, 2000000000);
                  nw_queue_set_timer_values(v134, v135, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
                  goto LABEL_190;
                }
                if (v17[191] != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v126 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v126, OS_LOG_TYPE_INFO))
                {
                  __int16 v127 = nw_endpoint_handler_get_id_string(v267);
                  os_log_type_t v128 = nw_endpoint_handler_dry_run_string(v267);
                  nw_endpoint_t v129 = nw_endpoint_handler_copy_endpoint(v267);
                  uint64_t v130 = nw_endpoint_get_logging_description(v129);
                  __int16 v131 = nw_endpoint_handler_state_string(v267);
                  id v132 = nw_endpoint_handler_mode_string(v267);
                  id v133 = nw_endpoint_handler_copy_current_path(v267);
                  *(_DWORD *)buf = 136448002;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v127;
                  __int16 v288 = 2082;
                  v289 = v128;
                  __int16 v290 = 2082;
                  v291 = v130;
                  __int16 v292 = 2082;
                  v293 = (void *)v131;
                  __int16 v294 = 2082;
                  v295 = v132;
                  __int16 v296 = 2114;
                  id v297 = v133;
                  __int16 v298 = 2048;
                  uint64_t v299 = 2000;
                  _os_log_impl(&dword_1830D4000, v126, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] pushing out endpoint race by %llums", buf, 0x52u);
                }
              }

              goto LABEL_155;
            }
          }
          uint64_t v89 = *((void *)v45 + 7);
          if (v89)
          {
            nw_queue_cancel_source(v89);
            *((void *)v45 + 7) = 0;
          }
          uint64_t v90 = *((void *)v45 + 8);
          if (v90)
          {
            nw_queue_cancel_source(v90);
            *((void *)v45 + 8) = 0;
          }
          uint64_t v91 = *((void *)v45 + 9);
          if (v91)
          {
            nw_queue_cancel_source(v91);
            *((void *)v45 + 9) = 0;
          }
          if (v259 != 4)
          {
            objc_storeStrong((id *)v45 + 4, obj);
            if (v259 == 3)
            {
              int v120 = v267;
              v120[30] = 3;
            }
            nw_endpoint_handler_report(v267, 0, v256, 0);
            long long v121 = (atomic_uchar *)*((void *)v45 + 5);
            v282[0] = MEMORY[0x1E4F143A8];
            v282[1] = 3221225472;
            v282[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_113;
            v282[3] = &unk_1E524AE18;
            v283 = object;
            nw_array_apply(v121, (uint64_t)v282);
            if (*((void *)v45 + 1))
            {
              v122 = v267;
              id v123 = v122[4];

              if (nw_parameters_get_use_long_outstanding_queries(v123))
              {
              }
              else
              {
                v136 = nw_endpoint_handler_copy_endpoint(v122);
                BOOL v137 = nw_endpoint_get_type(v136) == nw_endpoint_type_bonjour_service;

                if (v137) {
                  nw_resolver_cancel(*((void **)v45 + 1));
                }
              }
            }
            p_super = v283;
            goto LABEL_159;
          }
          if (nw_endpoint_handler_get_minimize_logging(v267))
          {
            if (nw_endpoint_handler_get_logging_disabled(v267)) {
              goto LABEL_189;
            }
            if (v17[191] != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v94 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v94, OS_LOG_TYPE_DEBUG))
            {
              id v193 = nw_endpoint_handler_get_id_string(v267);
              v194 = nw_endpoint_handler_dry_run_string(v267);
              nw_endpoint_t v195 = nw_endpoint_handler_copy_endpoint(v267);
              BOOL v196 = nw_endpoint_get_logging_description(v195);
              os_log_type_t v197 = nw_endpoint_handler_state_string(v267);
              os_log_type_t v198 = nw_endpoint_handler_mode_string(v267);
              id v199 = nw_endpoint_handler_copy_current_path(v267);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v193;
              __int16 v288 = 2082;
              v289 = v194;
              __int16 v290 = 2082;
              v291 = v196;
              __int16 v292 = 2082;
              v293 = (void *)v197;
              __int16 v294 = 2082;
              v295 = v198;
              __int16 v296 = 2114;
              id v297 = v199;
              _os_log_impl(&dword_1830D4000, v94, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed after transport finished", buf, 0x48u);
            }
          }
          else
          {
            BOOL v92 = v267;
            BOOL v93 = (v267[67] & 0x20) == 0;

            if (!v93)
            {
LABEL_189:
              nw_endpoint_handler_handle_failure(v267);
              v267[20] = 327682;
              nw_endpoint_handler_report(v267, 0, (_WORD *)v267 + 40, 0);
              goto LABEL_190;
            }
            if (v17[191] != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v94 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v94, OS_LOG_TYPE_INFO))
            {
              BOOL v95 = v92;

              os_log_type_t v96 = v95;
              BOOL v97 = (v267[67] & 1) == 0;

              if (v97) {
                char v98 = "";
              }
              else {
                char v98 = "dry-run ";
              }
              nw_endpoint_t v99 = nw_endpoint_handler_copy_endpoint(v96);
              os_log_type_t v100 = nw_endpoint_get_logging_description(v99);
              char v101 = v96;
              os_log_type_t v102 = v101;
              uint64_t v103 = v101[30];
              if (v103 > 5) {
                nw_endpoint_t v104 = "unknown-state";
              }
              else {
                nw_endpoint_t v104 = off_1E523FB38[v103];
              }
              os_log_t v261 = (os_log_t)v104;

              id v138 = v102;
              __int16 v139 = v138;
              v140 = "path";
              switch(v13[29])
              {
                case 0u:
                  break;
                case 1u:
                  v140 = "resolver";
                  break;
                case 2u:
                  v140 = nw_endpoint_flow_mode_string(v138[31]);
                  break;
                case 3u:
                  v140 = "proxy";
                  break;
                case 4u:
                  v140 = "fallback";
                  break;
                case 5u:
                  v140 = "transform";
                  break;
                default:
                  v140 = "unknown-mode";
                  break;
              }

              v163 = v139;
              os_unfair_lock_lock((os_unfair_lock_t)v163 + 28);
              id v164 = v163[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v163 + 28);

              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v95 + 168;
              __int16 v288 = 2082;
              v289 = v98;
              __int16 v290 = 2082;
              v291 = v100;
              __int16 v292 = 2082;
              v293 = v261;
              __int16 v294 = 2082;
              v295 = v140;
              __int16 v296 = 2114;
              id v297 = v164;
              _os_log_impl(&dword_1830D4000, v94, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed after transport finished", buf, 0x48u);
            }
          }

          goto LABEL_189;
        }
        if (*((NSObject **)v45 + 4) != object)
        {
          if (a2 == 2 && a3 == 4)
          {
            p_super = nw_endpoint_handler_copy_endpoint(object);
            if (nw_endpoint_get_type(p_super) == nw_endpoint_type_address)
            {
              BOOL v63 = v15;
              os_unfair_lock_lock((os_unfair_lock_t)v63 + 28);
              int v64 = (NWConcrete_nw_path *)*((id *)v63 + 8);
              os_unfair_lock_unlock((os_unfair_lock_t)v63 + 28);

              *(_DWORD *)os_log_type_t type = 0;
              *(void *)buf = 0;
              *(void *)&buf[8] = 0;
              if (nw_path_get_vpn_config_uuid(v64, (unsigned __int8 (*)[16])buf, (int *)type, 1, 1))
              {
                address = nw_endpoint_get_address(p_super);
                if (nw_path_voluntary_agent_matches_address(v64, (uint64_t)address))
                {
                  id v66 = nw_endpoint_handler_copy_context(v63);
                  v284[0] = MEMORY[0x1E4F143A8];
                  v284[1] = 3221225472;
                  v284[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke;
                  v284[3] = &unk_1E524BAA8;
                  v285 = v63;
                  nw_queue_context_async(v66, v284);

                  goto LABEL_159;
                }
              }
            }
LABEL_86:

            int v49 = 0;
            a4 = v256;
            goto LABEL_87;
          }
          if (a2 != 3 || (int v72 = *((_DWORD *)v45 + 5)) == 0 || !*((void *)v45 + 7))
          {
            int v49 = 0;
            goto LABEL_87;
          }
          p_super = nw_array_get_object_at_index(v46, (v72 - 1));
          if (p_super != object) {
            goto LABEL_86;
          }
          int v73 = nw_endpoint_handler_get_minimize_logging(v267);
          char v74 = nw_endpoint_handler_get_logging_disabled(v267);
          if (v73)
          {
            if (v74)
            {
LABEL_82:
              uint64_t v83 = *((void *)v45 + 7);
              p_super = object;
              if (v83)
              {
                nw_queue_cancel_source(v83);
                *((void *)v45 + 7) = 0;
                p_super = object;
              }
              goto LABEL_86;
            }
            v254 = v13;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            unsigned int v75 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v75, OS_LOG_TYPE_DEBUG))
            {
              os_log_t loga = nw_endpoint_handler_get_id_string(v267);
              v214 = nw_endpoint_handler_dry_run_string(v267);
              nw_endpoint_t v215 = nw_endpoint_handler_copy_endpoint(v267);
              unsigned int v216 = nw_endpoint_get_logging_description(v215);
              v217 = nw_endpoint_handler_state_string(v267);
              char v218 = nw_endpoint_handler_mode_string(v267);
              id v219 = nw_endpoint_handler_copy_current_path(v267);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = loga;
              __int16 v288 = 2082;
              v289 = v214;
              __int16 v290 = 2082;
              v291 = v216;
              __int16 v292 = 2082;
              v293 = (void *)v217;
              __int16 v294 = 2082;
              v295 = v218;
              __int16 v296 = 2114;
              id v297 = v219;
              _os_log_impl(&dword_1830D4000, v75, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child is proxy, cancelling happy eyeballs timer", buf, 0x48u);

              BOOL v13 = v254;
              char v17 = &unk_1EB267000;
            }
          }
          else
          {
            if (v74) {
              goto LABEL_82;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            unsigned int v75 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v75, OS_LOG_TYPE_INFO))
            {
              int v76 = nw_endpoint_handler_get_id_string(v267);
              int v77 = nw_endpoint_handler_dry_run_string(v267);
              nw_endpoint_t v78 = nw_endpoint_handler_copy_endpoint(v267);
              v253 = v13;
              int v79 = nw_endpoint_get_logging_description(v78);
              unsigned int v80 = nw_endpoint_handler_state_string(v267);
              __int16 v81 = nw_endpoint_handler_mode_string(v267);
              id v82 = nw_endpoint_handler_copy_current_path(v267);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v76;
              __int16 v288 = 2082;
              v289 = v77;
              __int16 v290 = 2082;
              v291 = v79;
              __int16 v292 = 2082;
              v293 = (void *)v80;
              __int16 v294 = 2082;
              v295 = v81;
              __int16 v296 = 2114;
              id v297 = v82;
              _os_log_impl(&dword_1830D4000, v75, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child is proxy, cancelling happy eyeballs timer", buf, 0x48u);

              char v17 = (void *)&unk_1EB267000;
              BOOL v13 = v253;
            }
          }

          goto LABEL_82;
        }
        if (a3 != 4) {
          goto LABEL_70;
        }
        uint64_t v67 = v15;
        BOOL v68 = (v15[67] & 8) == 0;

        char v15 = v267;
        a3 = v259;
        if (v68
          || (id v69 = nw_endpoint_handler_copy_parent(v67),
              BOOL v70 = v69 == 0,
              v69,
              char v15 = v267,
              a3 = v259,
              !v70))
        {
LABEL_70:
          os_log_type_t v71 = v15;
          v71[30] = a3;

          nw_endpoint_handler_report(v71, 0, v256, 0);
          goto LABEL_190;
        }
        int v141 = nw_endpoint_handler_get_minimize_logging(v67);
        char v142 = nw_endpoint_handler_get_logging_disabled(v67);
        if (v141)
        {
          if (v142) {
            goto LABEL_170;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v143 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v143, OS_LOG_TYPE_DEBUG))
          {
            os_log_type_t v200 = nw_endpoint_handler_get_id_string(v67);
            v201 = nw_endpoint_handler_dry_run_string(v67);
            nw_endpoint_t v202 = nw_endpoint_handler_copy_endpoint(v67);
            v203 = nw_endpoint_get_logging_description(v202);
            v204 = nw_endpoint_handler_state_string(v67);
            os_log_type_t v205 = nw_endpoint_handler_mode_string(v67);
            id v206 = nw_endpoint_handler_copy_current_path(v67);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v200;
            __int16 v288 = 2082;
            v289 = v201;
            __int16 v290 = 2082;
            v291 = v203;
            __int16 v292 = 2082;
            v293 = (void *)v204;
            __int16 v294 = 2082;
            v295 = v205;
            __int16 v296 = 2114;
            id v297 = v206;
            _os_log_impl(&dword_1830D4000, v143, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected child failed when a better path is available", buf, 0x48u);
          }
        }
        else
        {
          if (v142)
          {
LABEL_170:
            nw_endpoint_handler_handle_failure(v67);
            goto LABEL_190;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v143 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v143, OS_LOG_TYPE_INFO))
          {
            v144 = nw_endpoint_handler_get_id_string(v67);
            v145 = nw_endpoint_handler_dry_run_string(v67);
            nw_endpoint_t v146 = nw_endpoint_handler_copy_endpoint(v67);
            id v147 = nw_endpoint_get_logging_description(v146);
            v148 = nw_endpoint_handler_state_string(v67);
            v149 = nw_endpoint_handler_mode_string(v67);
            id v150 = nw_endpoint_handler_copy_current_path(v67);
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v144;
            __int16 v288 = 2082;
            v289 = v145;
            __int16 v290 = 2082;
            v291 = v147;
            __int16 v292 = 2082;
            v293 = (void *)v148;
            __int16 v294 = 2082;
            v295 = v149;
            __int16 v296 = 2114;
            id v297 = v150;
            _os_log_impl(&dword_1830D4000, v143, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected child failed when a better path is available", buf, 0x48u);
          }
        }

        goto LABEL_170;
      }
    }
    if (a3 | a2 || !a4 || *a4 != 1 || a4[1] != 1) {
      goto LABEL_190;
    }
    p_super = nw_endpoint_handler_copy_parameters(object);
    if (!nw_parameters_get_desperate_ivan(p_super)) {
      goto LABEL_159;
    }
    id v51 = nw_endpoint_handler_copy_parameters(v15);
    if (nw_parameters_get_desperate_ivan(v51))
    {
LABEL_59:

LABEL_159:
      goto LABEL_190;
    }
    nw_endpoint_t v52 = nw_endpoint_handler_copy_endpoint(object);
    if (nw_endpoint_get_type(v52) != nw_endpoint_type_address
      || nw_endpoint_get_address_family(v52) != 30)
    {
LABEL_58:

      goto LABEL_59;
    }
    *(void *)os_log_type_t type = 0;
    v275 = type;
    uint64_t v276 = 0x2020000000;
    char v277 = 0;
    os_log_type_t v53 = (atomic_uchar *)*((void *)v45 + 5);
    v271[0] = MEMORY[0x1E4F143A8];
    v271[1] = 3221225472;
    v271[2] = ___ZL35nw_endpoint_resolver_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke_115;
    v271[3] = &unk_1E524A2E8;
    v272 = v52;
    v273 = type;
    nw_array_apply(v53, (uint64_t)v271);
    if (!*((unsigned char *)v275 + 24))
    {
LABEL_57:

      _Block_object_dispose(type, 8);
      goto LABEL_58;
    }
    int v54 = nw_endpoint_handler_get_minimize_logging(v267);
    char v55 = nw_endpoint_handler_get_logging_disabled(v267);
    if (v54)
    {
      if (v55) {
        goto LABEL_56;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v56 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
      {
        v264 = nw_endpoint_handler_get_id_string(v267);
        v258 = nw_endpoint_handler_dry_run_string(v267);
        nw_endpoint_t v220 = nw_endpoint_handler_copy_endpoint(v267);
        id v221 = nw_endpoint_get_logging_description(v220);
        v222 = nw_endpoint_handler_state_string(v267);
        unint64_t v223 = nw_endpoint_handler_mode_string(v267);
        id v224 = nw_endpoint_handler_copy_current_path(v267);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v264;
        __int16 v288 = 2082;
        v289 = v258;
        __int16 v290 = 2082;
        v291 = v221;
        __int16 v292 = 2082;
        v293 = (void *)v222;
        __int16 v294 = 2082;
        v295 = v223;
        __int16 v296 = 2114;
        id v297 = v224;
        _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping DesperateIvan, address already started", buf, 0x48u);
      }
    }
    else
    {
      if (v55)
      {
LABEL_56:
        nw_endpoint_handler_cancel(object, 0, 1);
        goto LABEL_57;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v56 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v56, OS_LOG_TYPE_INFO))
      {
        id v57 = nw_endpoint_handler_get_id_string(v267);
        v257 = nw_endpoint_handler_dry_run_string(v267);
        v260 = v56;
        nw_endpoint_t v58 = nw_endpoint_handler_copy_endpoint(v267);
        char v59 = nw_endpoint_get_logging_description(v58);
        os_log_type_t v60 = nw_endpoint_handler_state_string(v267);
        BOOL v61 = nw_endpoint_handler_mode_string(v267);
        id v62 = nw_endpoint_handler_copy_current_path(v267);
        *(_DWORD *)buf = 136447746;
        *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v57;
        __int16 v288 = 2082;
        v289 = v257;
        __int16 v290 = 2082;
        v291 = v59;
        __int16 v292 = 2082;
        v293 = (void *)v60;
        __int16 v294 = 2082;
        v295 = v61;
        __int16 v296 = 2114;
        id v297 = v62;
        _os_log_impl(&dword_1830D4000, v260, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping DesperateIvan, address already started", buf, 0x48u);

        uint64_t v56 = v260;
      }
    }

    goto LABEL_56;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v28 = (id)gLogObj;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    if (v14 > 5) {
      uint64_t v29 = "unknown-mode";
    }
    else {
      uint64_t v29 = off_1E523FB08[v14];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_receive_report";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v29;
    __int16 v288 = 2082;
    v289 = "resolver";
    _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_18:
  uint64_t v30 = 0;
LABEL_191:

  return v30;
}

void sub_18310E268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,uint64_t a22,void *a23,uint64_t a24,void *a25)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_endpoint_mode_handler *nw_endpoint_handler_copy_resolver(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  unsigned int v2 = v1;
  if (!v1)
  {
    int v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_endpoint_handler_copy_resolver";
    char v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_endpoint_handler_copy_resolver";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v24 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            id v34 = "nw_endpoint_handler_copy_resolver";
            __int16 v35 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_48;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_endpoint_handler_copy_resolver";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v24 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_endpoint_handler_copy_resolver";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_48:
    if (v23) {
      free(v23);
    }
    goto LABEL_30;
  }
  if (v1->mode != 1)
  {
    if ((*((unsigned char *)v1 + 268) & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        if (*((unsigned char *)v2 + 268)) {
          uint64_t v5 = "dry-run ";
        }
        else {
          uint64_t v5 = "";
        }
        nw_endpoint_t v6 = nw_endpoint_handler_copy_endpoint(v2);
        logging_description = nw_endpoint_get_logging_description(v6);
        uint64_t state = v2->state;
        os_log_type_t v9 = logging_description;
        if (state > 5) {
          os_log_type_t v10 = "unknown-state";
        }
        else {
          os_log_type_t v10 = off_1E523FB38[state];
        }
        uint64_t v30 = v10;
        os_log_type_t v11 = v2;
        id v12 = (os_unfair_lock_s *)v11;
        BOOL v13 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            BOOL v13 = "resolver";
            break;
          case 2:
            BOOL v13 = nw_endpoint_flow_mode_string(v11->mode_handler);
            break;
          case 3:
            BOOL v13 = "proxy";
            break;
          case 4:
            BOOL v13 = "fallback";
            break;
          case 5:
            BOOL v13 = "transform";
            break;
          default:
            BOOL v13 = "unknown-mode";
            break;
        }

        uint64_t v14 = v12 + 28;
        char v15 = v12;
        os_unfair_lock_lock(v12 + 28);
        id v16 = v15[8];
        os_unfair_lock_unlock(v14);

        id v17 = v16;
        char v18 = v15;
        __int16 v19 = v18;
        uint64_t v20 = "path";
        switch(v2->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v20 = "resolver";
            break;
          case 2:
            uint64_t v20 = nw_endpoint_flow_mode_string(v18[31]);
            break;
          case 3:
            uint64_t v20 = "proxy";
            break;
          case 4:
            uint64_t v20 = "fallback";
            break;
          case 5:
            uint64_t v20 = "transform";
            break;
          default:
            uint64_t v20 = "unknown-mode";
            break;
        }

        *(_DWORD *)buf = 136448002;
        id v34 = "nw_endpoint_handler_copy_resolver";
        __int16 v35 = 2082;
        id_str = v2->id_str;
        __int16 v37 = 2082;
        nw_endpoint_t v38 = v5;
        __int16 v39 = 2082;
        uint64_t v40 = v9;
        __int16 v41 = 2082;
        BOOL v42 = v30;
        __int16 v43 = 2082;
        id v44 = v13;
        __int16 v45 = 2114;
        id v46 = v17;
        __int16 v47 = 2082;
        uint64_t v48 = v20;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Endpoint handler is %{public}s, not a resolver", buf, 0x52u);
      }
    }
LABEL_30:
    uint64_t v3 = 0;
    goto LABEL_31;
  }
  uint64_t v3 = v1->mode_handler;
LABEL_31:

  return v3;
}

void sub_18310EA74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL networkd_settings_get_BOOL(const char *a1)
{
  networkd_settings_init(a1);
  if (!sCachedSettings) {
    return 0;
  }
  pthread_mutex_lock(&sSettingsMutex);
  unsigned int v2 = (void *)sCachedSettings;
  if (!sCachedSettings) {
    goto LABEL_7;
  }
  Class Class = object_getClass((id)sCachedSettings);
  BOOL v4 = 0;
  if (!a1 || Class != (Class)MEMORY[0x1E4F14590]) {
    goto LABEL_8;
  }
  xpc_object_t value = xpc_dictionary_get_value(v2, a1);
  if (value && (nw_endpoint_t v6 = value, object_getClass(value) == (Class)MEMORY[0x1E4F14570])) {
    BOOL v4 = xpc_BOOL_get_value(v6);
  }
  else {
LABEL_7:
  }
    BOOL v4 = 0;
LABEL_8:
  pthread_mutex_unlock(&sSettingsMutex);
  return v4;
}

void sub_18310F104(_Unwind_Exception *exception_object)
{
}

void nw_allow_use_of_dispatch_internal()
{
  if (sNWIsBetweenForkAndExec != 1
    || (sNWParentAllowedDispatch & 1) == 0 && !_dispatch_is_fork_of_multithreaded_parent())
  {
    goto LABEL_6;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  uint64_t v0 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v0))
  {
    free(v0);
LABEL_6:
    pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
    sNWDispatchAllowedNow = 1;
    networkd_settings_init();
    networkd_settings_setup_notify_watch();
    return;
  }
  __break(1u);
}

int64_t networkd_settings_get_int64_with_default(const char *a1, int64_t a2)
{
  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    BOOL v4 = (void *)sCachedSettings;
    if (sCachedSettings)
    {
      Class Class = object_getClass((id)sCachedSettings);
      if (a1)
      {
        if (Class == (Class)MEMORY[0x1E4F14590])
        {
          xpc_object_t value = xpc_dictionary_get_value(v4, a1);
          if (value)
          {
            id v7 = value;
            if (object_getClass(value) == (Class)MEMORY[0x1E4F145C0]) {
              a2 = xpc_int64_get_value(v7);
            }
          }
        }
      }
    }
    pthread_mutex_unlock(&sSettingsMutex);
  }
  return a2;
}

uint64_t networkd_settings_init()
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t result = pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sSettingsInitState != 2)
  {
    pthread_mutex_lock(&sSettingsMutex);
    if (sSettingsInitState) {
      return pthread_mutex_unlock(&sSettingsMutex);
    }
    sSettingsInitState = 1;
    networkd_settings_setup_notify_watch();
    networkd_settings_read_from_file();
    int out_token = -1;
    uint32_t v1 = notify_register_check((const char *)nw_notification_name_settings, &out_token);
    if (!v1 && out_token != -1)
    {
      networkd_settings_update_from_token(out_token);
LABEL_19:
      if (out_token != -1) {
        notify_cancel(out_token);
      }
      sSettingsInitState = 2;
      return pthread_mutex_unlock(&sSettingsMutex);
    }
    if (nw_settings_should_be_able_to_use_notify_apis(void)::onceToken[0] != -1) {
      dispatch_once(nw_settings_should_be_able_to_use_notify_apis(void)::onceToken, &__block_literal_global_9_90022);
    }
    char v2 = nw_settings_should_be_able_to_use_notify_apis(void)::has_notify_apis;
    uint64_t v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v3);
    uint64_t v4 = gLogObj;
    if (v1 == 1000000 && (v2 & 1) != 0)
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_19;
      }
      uint64_t v5 = "";
      *(_DWORD *)buf = 136447234;
      if (sNWIsBetweenForkAndExec) {
        uint64_t v5 = " (forked)";
      }
      id v12 = "networkd_settings_init";
      __int16 v13 = 2082;
      uint64_t v14 = nw_notification_name_settings;
      __int16 v15 = 1024;
      int v16 = 1000000;
      __int16 v17 = 1024;
      int v18 = out_token;
      __int16 v19 = 2082;
      uint64_t v20 = v5;
      nw_endpoint_t v6 = "%{public}s [sandboxed: ok] notify_register_check(%{public}s) status %u token %d%{public}s failed";
      id v7 = v4;
      os_log_type_t v8 = OS_LOG_TYPE_DEFAULT;
    }
    else
    {
      if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_19;
      }
      os_log_type_t v9 = "";
      *(_DWORD *)buf = 136447234;
      if (sNWIsBetweenForkAndExec) {
        os_log_type_t v9 = " (forked)";
      }
      id v12 = "networkd_settings_init";
      __int16 v13 = 2082;
      uint64_t v14 = nw_notification_name_settings;
      __int16 v15 = 1024;
      int v16 = v1;
      __int16 v17 = 1024;
      int v18 = out_token;
      __int16 v19 = 2082;
      uint64_t v20 = v9;
      nw_endpoint_t v6 = "%{public}s notify_register_check(%{public}s) status %u token %d%{public}s";
      id v7 = v4;
      os_log_type_t v8 = OS_LOG_TYPE_ERROR;
    }
    _os_log_impl(&dword_1830D4000, v7, v8, v6, buf, 0x2Cu);
    goto LABEL_19;
  }
  return result;
}

void networkd_settings_setup_notify_watch(void)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
  {
    if ((sNWDispatchAllowedNow & 1) == 0)
    {
      if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
        || (getpid(), sandbox_check() == 1))
      {
        sNWDispatchAllowedNow = 1;
      }
      else if (!sNWDispatchAllowedNow)
      {
        return;
      }
    }
    if (!networkd_settings_setup_notify_watch(void)::queue)
    {
      pthread_mutex_lock(&sSettingsMutex);
      if (networkd_settings_setup_notify_watch(void)::queue) {
        goto LABEL_11;
      }
      nw_endpoint_t v6 = (const char *)nw_notification_name_settings;
      id v7 = dispatch_queue_attr_make_with_autorelease_frequency(0, DISPATCH_AUTORELEASE_FREQUENCY_WORK_ITEM);
      os_log_type_t v8 = dispatch_queue_create(v6, v7);
      networkd_settings_setup_notify_watch(void)::queue = (uint64_t)v8;
      if (!v8) {
        goto LABEL_11;
      }
      int out_token = 0;
      uint32_t v9 = notify_register_dispatch((const char *)nw_notification_name_settings, &out_token, v8, &__block_literal_global_90080);
      pthread_mutex_unlock(&sSettingsMutex);
      if (!v9)
      {
LABEL_12:
        if (networkd_settings_setup_notify_watch(void)::queue) {
          return;
        }
        uint64_t v0 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v0);
        int out_token = 136446466;
        id v32 = "networkd_settings_setup_notify_watch";
        __int16 v33 = 2082;
        uint64_t v34 = nw_notification_name_settings;
        uint32_t v1 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v29 = 0;
        if (!__nwlog_fault(v1, &type, &v29)) {
          goto LABEL_48;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v2 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v2);
          uint64_t v3 = gLogObj;
          os_log_type_t v4 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_48;
          }
          int out_token = 136446466;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          uint64_t v5 = "%{public}s dispatch_queue_create(%{public}s) failed";
        }
        else if (v29)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v15 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v15);
          uint64_t v3 = gLogObj;
          os_log_type_t v4 = type;
          BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v16)
            {
              int out_token = 136446722;
              id v32 = "networkd_settings_setup_notify_watch";
              __int16 v33 = 2082;
              uint64_t v34 = nw_notification_name_settings;
              __int16 v35 = 2082;
              *(void *)int v36 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s dispatch_queue_create(%{public}s) failed, dumping backtrace:%{public}s", (uint8_t *)&out_token, 0x20u);
            }
            free(backtrace_string);
            goto LABEL_48;
          }
          if (!v16)
          {
LABEL_48:
            if (v1) {
              free(v1);
            }
            return;
          }
          int out_token = 136446466;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          uint64_t v5 = "%{public}s dispatch_queue_create(%{public}s) failed, no backtrace";
        }
        else
        {
          uint64_t v23 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v23);
          uint64_t v3 = gLogObj;
          os_log_type_t v4 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_48;
          }
          int out_token = 136446466;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          uint64_t v5 = "%{public}s dispatch_queue_create(%{public}s) failed, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v3, v4, v5, (uint8_t *)&out_token, 0x16u);
        goto LABEL_48;
      }
      if (nw_settings_should_be_able_to_use_notify_apis(void)::onceToken[0] != -1) {
        dispatch_once(nw_settings_should_be_able_to_use_notify_apis(void)::onceToken, &__block_literal_global_9_90022);
      }
      int v10 = nw_settings_should_be_able_to_use_notify_apis(void)::has_notify_apis;
      uint64_t v11 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v11);
      id v12 = gLogObj;
      if (v10 == 1 && v9 == 1000000)
      {
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
        {
          if (sNWIsBetweenForkAndExec) {
            __int16 v13 = " (forked)";
          }
          else {
            __int16 v13 = "";
          }
          int out_token = 136446978;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          __int16 v35 = 1024;
          *(_DWORD *)int v36 = 1000000;
          *(_WORD *)&v36[4] = 2082;
          *(void *)&v36[6] = v13;
          _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEFAULT, "%{public}s [sandboxed: ok] notify_register_dispatch(%{public}s) [status %u]%{public}s failed", (uint8_t *)&out_token, 0x26u);
        }
LABEL_72:
        pthread_mutex_lock(&sSettingsMutex);
        networkd_settings_read_from_file();
LABEL_11:
        pthread_mutex_unlock(&sSettingsMutex);
        goto LABEL_12;
      }
      if (sNWIsBetweenForkAndExec) {
        __int16 v17 = " (forked)";
      }
      else {
        __int16 v17 = "";
      }
      int out_token = 136446978;
      id v32 = "networkd_settings_setup_notify_watch";
      __int16 v33 = 2082;
      uint64_t v34 = nw_notification_name_settings;
      __int16 v35 = 1024;
      *(_DWORD *)int v36 = v9;
      *(_WORD *)&v36[4] = 2082;
      *(void *)&v36[6] = v17;
      int v18 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v29 = 0;
      if (__nwlog_fault(v18, &type, &v29))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          __int16 v19 = __nwlog_obj();
          os_log_type_t v20 = type;
          if (!os_log_type_enabled(v19, type)) {
            goto LABEL_70;
          }
          if (sNWIsBetweenForkAndExec) {
            uint64_t v21 = " (forked)";
          }
          else {
            uint64_t v21 = "";
          }
          int out_token = 136446978;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          __int16 v35 = 1024;
          *(_DWORD *)int v36 = v9;
          *(_WORD *)&v36[4] = 2082;
          *(void *)&v36[6] = v21;
          int v22 = "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed";
          goto LABEL_69;
        }
        if (!v29)
        {
          __int16 v19 = __nwlog_obj();
          os_log_type_t v20 = type;
          if (!os_log_type_enabled(v19, type)) {
            goto LABEL_70;
          }
          if (sNWIsBetweenForkAndExec) {
            os_log_type_t v27 = " (forked)";
          }
          else {
            os_log_type_t v27 = "";
          }
          int out_token = 136446978;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          __int16 v35 = 1024;
          *(_DWORD *)int v36 = v9;
          *(_WORD *)&v36[4] = 2082;
          *(void *)&v36[6] = v27;
          int v22 = "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed, backtrace limit exceeded";
          goto LABEL_69;
        }
        __int16 v24 = (char *)__nw_create_backtrace_string();
        __int16 v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v25 = os_log_type_enabled(v19, type);
        if (v24)
        {
          if (v25)
          {
            if (sNWIsBetweenForkAndExec) {
              uint64_t v26 = " (forked)";
            }
            else {
              uint64_t v26 = "";
            }
            int out_token = 136447234;
            id v32 = "networkd_settings_setup_notify_watch";
            __int16 v33 = 2082;
            uint64_t v34 = nw_notification_name_settings;
            __int16 v35 = 1024;
            *(_DWORD *)int v36 = v9;
            *(_WORD *)&v36[4] = 2082;
            *(void *)&v36[6] = v26;
            __int16 v37 = 2082;
            nw_endpoint_t v38 = v24;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed, dumping backtrace:%{public}s", (uint8_t *)&out_token, 0x30u);
          }
          free(v24);
          goto LABEL_70;
        }
        if (v25)
        {
          if (sNWIsBetweenForkAndExec) {
            BOOL v28 = " (forked)";
          }
          else {
            BOOL v28 = "";
          }
          int out_token = 136446978;
          id v32 = "networkd_settings_setup_notify_watch";
          __int16 v33 = 2082;
          uint64_t v34 = nw_notification_name_settings;
          __int16 v35 = 1024;
          *(_DWORD *)int v36 = v9;
          *(_WORD *)&v36[4] = 2082;
          *(void *)&v36[6] = v28;
          int v22 = "%{public}s notify_register_dispatch(%{public}s) [status %u]%{public}s failed, no backtrace";
LABEL_69:
          _os_log_impl(&dword_1830D4000, v19, v20, v22, (uint8_t *)&out_token, 0x26u);
        }
      }
LABEL_70:
      if (v18) {
        free(v18);
      }
      goto LABEL_72;
    }
  }
}

void nw_quic_connection_get_application_result_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_connection(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_connection_get_application_result_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v18 = "nw_quic_connection_get_application_result_handler";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v18 = "nw_quic_connection_get_application_result_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v18 = "nw_quic_connection_get_application_result_handler";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v18 = "nw_quic_connection_get_application_result_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v18 = "nw_quic_connection_get_application_result_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_connection(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_1831100A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_connection_get_application_result_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 212);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 212));
  uint64_t v5 = _Block_copy(*(const void **)(a1 + 32));
  nw_endpoint_t v6 = *(void **)(a2 + 192);
  *(void *)(a2 + 192) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t ___ZL38nw_protocol_udp_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  nw_frame_unclaim(a2, a2, 8u, 0);
  unsigned int v93 = 0;
  uint64_t v4 = nw_frame_unclaimed_bytes(a2, &v93);
  if (v4)
  {
    uint64_t v5 = v4;
    uint64_t v6 = *(void *)(a1 + 48);
    uint64_t v7 = *(void *)(v6 + 64);
    if (v7) {
      ++*(void *)(v7 + 120);
    }
    *(_DWORD *)uint64_t v4 = *(_DWORD *)(v6 + 88);
    *(_WORD *)(v4 + 4) = bswap32((unsigned __int16)v93) >> 16;
    if (a2)
    {
      if (*(_DWORD *)(a2 + 176)) {
        goto LABEL_30;
      }
      int v8 = *(_DWORD *)(v6 + 80);
      if (v8 > 499)
      {
        if (v8 <= 699)
        {
          if (v8 == 500)
          {
            int v8 = 2621728;
            goto LABEL_29;
          }
          if (v8 == 600)
          {
            int v8 = 3146000;
            goto LABEL_29;
          }
        }
        else
        {
          switch(v8)
          {
            case 700:
              int v8 = 3670272;
              goto LABEL_29;
            case 800:
              int v8 = 4194688;
              goto LABEL_29;
            case 900:
              int v8 = 4718992;
              goto LABEL_29;
          }
        }
      }
      else if (v8 <= 199)
      {
        if (!v8) {
          goto LABEL_29;
        }
        if (v8 == 100)
        {
          int v8 = 524432;
          goto LABEL_29;
        }
      }
      else
      {
        switch(v8)
        {
          case 200:
            int v8 = 1048704;
            goto LABEL_29;
          case 300:
            int v8 = 1572880;
            goto LABEL_29;
          case 400:
            int v8 = 2097184;
LABEL_29:
            *(_DWORD *)(a2 + 176) = v8;
            goto LABEL_30;
        }
      }
      int v8 = 0;
      goto LABEL_29;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v97 = "__nw_frame_get_service_class";
    uint64_t v40 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v94 = 0;
    if (__nwlog_fault(v40, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v97 = "__nw_frame_get_service_class";
        __int16 v43 = "%{public}s called with null frame";
LABEL_135:
        _os_log_impl(&dword_1830D4000, v41, v42, v43, buf, 0xCu);
        goto LABEL_136;
      }
      if (!v94)
      {
        __int16 v41 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (!os_log_type_enabled(v41, type)) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v97 = "__nw_frame_get_service_class";
        __int16 v43 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_135;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      BOOL v45 = os_log_type_enabled(v41, type);
      if (!backtrace_string)
      {
        if (!v45) {
          goto LABEL_136;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v97 = "__nw_frame_get_service_class";
        __int16 v43 = "%{public}s called with null frame, no backtrace";
        goto LABEL_135;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v97 = "__nw_frame_get_service_class";
        __int16 v98 = 2082;
        nw_endpoint_t v99 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
    }
LABEL_136:
    if (v40) {
      free(v40);
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v97 = "__nw_frame_set_traffic_class";
    BOOL v68 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v94 = 0;
    if (!__nwlog_fault(v68, &type, &v94)) {
      goto LABEL_152;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v97 = "__nw_frame_set_traffic_class";
        os_log_type_t v71 = "%{public}s called with null frame";
LABEL_151:
        _os_log_impl(&dword_1830D4000, v69, v70, v71, buf, 0xCu);
      }
    }
    else if (v94)
    {
      int v72 = (char *)__nw_create_backtrace_string();
      id v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      BOOL v73 = os_log_type_enabled(v69, type);
      if (v72)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v97 = "__nw_frame_set_traffic_class";
          __int16 v98 = 2082;
          nw_endpoint_t v99 = v72;
          _os_log_impl(&dword_1830D4000, v69, v70, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v72);
        goto LABEL_152;
      }
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v97 = "__nw_frame_set_traffic_class";
        os_log_type_t v71 = "%{public}s called with null frame, no backtrace";
        goto LABEL_151;
      }
    }
    else
    {
      id v69 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v69, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v97 = "__nw_frame_set_traffic_class";
        os_log_type_t v71 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_151;
      }
    }
LABEL_152:
    if (v68) {
      free(v68);
    }
    uint64_t v6 = *(void *)(a1 + 48);
LABEL_30:
    int v9 = *(unsigned __int16 *)(v6 + 94);
    if ((~v9 & 0x14) == 0) {
      goto LABEL_31;
    }
    if ((v9 & 4) != 0)
    {
      unint64_t v12 = *(unsigned int *)(v6 + 48) + (unint64_t)*(unsigned int *)(v6 + 32) + bswap32(v93 + 17);
      LODWORD(v12) = ((WORD1(v12) + (unsigned __int16)v12 + HIDWORD(v12)) >> 16)
                   + (unsigned __int16)(WORD1(v12) + v12 + WORD2(v12));
      LODWORD(v12) = ((WORD1(v12) + (unsigned __int16)v12) >> 16) + (unsigned __int16)(WORD1(v12) + v12);
      int v11 = v12 + WORD1(v12);
    }
    else
    {
      LOWORD(v11) = in6_pseudo((unsigned __int16 *)(v6 + 32), (unsigned __int16 *)(v6 + 48), bswap32(v93 + 17));
    }
    *(_WORD *)(v5 + 6) = v11;
    uint64_t v13 = *(void *)(a1 + 48);
    __int16 v14 = *(_WORD *)(v13 + 94);
    if ((v14 & 0x100) == 0)
    {
LABEL_44:
      uint64_t v10 = *(void *)(a1 + 48);
      __int16 v16 = *(_WORD *)(v10 + 94);
      if ((v16 & 0x100) != 0) {
        goto LABEL_52;
      }
      if ((v16 & 8) == 0) {
        goto LABEL_46;
      }
      if ((v16 & 4) != 0) {
        uint64_t v24 = 20;
      }
      else {
        uint64_t v24 = 40;
      }
      if ((v16 & 4) != 0) {
        uint64_t v25 = 26;
      }
      else {
        uint64_t v25 = 46;
      }
      if (a2)
      {
        if ((*(_WORD *)(a2 + 204) & 0x100) == 0) {
          goto LABEL_46;
        }
        uint64_t v26 = (uint64_t (*)(uint64_t, uint64_t, uint64_t, uint64_t))g_channel_set_internet_checksum_handler;
        if (!g_channel_set_internet_checksum_handler) {
          goto LABEL_46;
        }
        *(unsigned char *)(a2 + 203) |= 3u;
        int v27 = v26(a2, 3, v24, v25);
        if (!v27) {
          goto LABEL_31;
        }
        int v28 = v27;
        if (v27 == 45)
        {
LABEL_46:
          uint64_t v17 = *(void *)(a1 + 48);
          __int16 v18 = *(_WORD *)(v17 + 94);
          if (in_finalize_cksum(a2, 6u, 1))
          {
            if (a2)
            {
              if ((*(_WORD *)(a2 + 204) & 0x100) != 0
                && g_channel_check_validity
                && (g_channel_check_validity(a2, *(void *)(a2 + 88)) & 1) == 0)
              {
LABEL_214:
                *(void *)(v17 + 64) = 0;
                *(void *)(v17 + 72) = 0;
                goto LABEL_31;
              }
LABEL_82:
              int v32 = *(_DWORD *)(a2 + 52);
              if (v32)
              {
                uint64_t v33 = (v32 - (*(_DWORD *)(a2 + 56) + *(_DWORD *)(a2 + 60)));
                uint64_t v34 = *(void **)(v17 + 64);
                if ((v18 & 4) != 0)
                {
LABEL_199:
                  if (v34)
                  {
                    uint64_t v85 = v34[17] + v33;
                    ++v34[16];
                    v34[17] = v85;
                  }
                  goto LABEL_31;
                }
              }
              else
              {
                uint64_t v33 = 0;
                uint64_t v34 = *(void **)(v17 + 64);
                if ((v18 & 4) != 0) {
                  goto LABEL_199;
                }
              }
LABEL_86:
              if (v34)
              {
                uint64_t v35 = v34[19] + v33;
                ++v34[18];
                v34[19] = v35;
              }
LABEL_31:
              uint64_t v10 = *(void *)(a1 + 48);
              if (!v10) {
                goto LABEL_58;
              }
LABEL_52:
              uint64_t v19 = *(void *)(v10 + 72);
              if (!v19
                || (++*(void *)(v19 + 32), (uint64_t v20 = *(void *)(a1 + 48)) == 0)
                || (uint64_t v21 = *(void *)(v20 + 72)) == 0)
              {
LABEL_58:
                ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
                if (_nw_signposts_once != -1) {
                  dispatch_once(&_nw_signposts_once, &__block_literal_global_17);
                }
                if (!_nw_signposts_enabled || !kdebug_is_enabled()) {
                  goto LABEL_62;
                }
                if (a2)
                {
LABEL_100:
                  kdebug_trace();
LABEL_62:
                  if (v93 >= 9) {
                    **(void **)(a1 + 48) = v93 + **(void **)(a1 + 48) - 8;
                  }
                  return 1;
                }
                __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                BOOL v97 = "__nw_frame_effective_length";
                os_log_type_t v86 = (char *)_os_log_send_and_compose_impl();
                os_log_type_t type = OS_LOG_TYPE_ERROR;
                char v94 = 0;
                if (__nwlog_fault(v86, &type, &v94))
                {
                  if (type == OS_LOG_TYPE_FAULT)
                  {
                    unsigned int v87 = __nwlog_obj();
                    os_log_type_t v88 = type;
                    if (!os_log_type_enabled(v87, type)) {
                      goto LABEL_235;
                    }
                    *(_DWORD *)buf = 136446210;
                    BOOL v97 = "__nw_frame_effective_length";
                    uint64_t v89 = "%{public}s called with null frame";
                    goto LABEL_234;
                  }
                  if (!v94)
                  {
                    unsigned int v87 = __nwlog_obj();
                    os_log_type_t v88 = type;
                    if (!os_log_type_enabled(v87, type)) {
                      goto LABEL_235;
                    }
                    *(_DWORD *)buf = 136446210;
                    BOOL v97 = "__nw_frame_effective_length";
                    uint64_t v89 = "%{public}s called with null frame, backtrace limit exceeded";
                    goto LABEL_234;
                  }
                  uint64_t v90 = (char *)__nw_create_backtrace_string();
                  unsigned int v87 = __nwlog_obj();
                  os_log_type_t v88 = type;
                  BOOL v91 = os_log_type_enabled(v87, type);
                  if (v90)
                  {
                    if (v91)
                    {
                      *(_DWORD *)buf = 136446466;
                      BOOL v97 = "__nw_frame_effective_length";
                      __int16 v98 = 2082;
                      nw_endpoint_t v99 = v90;
                      _os_log_impl(&dword_1830D4000, v87, v88, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v90);
                    goto LABEL_235;
                  }
                  if (v91)
                  {
                    *(_DWORD *)buf = 136446210;
                    BOOL v97 = "__nw_frame_effective_length";
                    uint64_t v89 = "%{public}s called with null frame, no backtrace";
LABEL_234:
                    _os_log_impl(&dword_1830D4000, v87, v88, v89, buf, 0xCu);
                  }
                }
LABEL_235:
                if (v86) {
                  free(v86);
                }
                goto LABEL_100;
              }
              if (a2)
              {
                uint64_t v22 = *(unsigned int *)(a2 + 52);
LABEL_57:
                *(void *)(v21 + 40) += v22;
                goto LABEL_58;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              BOOL v97 = "__nw_frame_effective_length";
              int v54 = (char *)_os_log_send_and_compose_impl();
              os_log_type_t type = OS_LOG_TYPE_ERROR;
              char v94 = 0;
              if (__nwlog_fault(v54, &type, &v94))
              {
                if (type == OS_LOG_TYPE_FAULT)
                {
                  char v55 = __nwlog_obj();
                  os_log_type_t v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    BOOL v97 = "__nw_frame_effective_length";
                    id v57 = "%{public}s called with null frame";
LABEL_205:
                    _os_log_impl(&dword_1830D4000, v55, v56, v57, buf, 0xCu);
                  }
                }
                else if (v94)
                {
                  int v76 = (char *)__nw_create_backtrace_string();
                  char v55 = __nwlog_obj();
                  os_log_type_t v56 = type;
                  BOOL v77 = os_log_type_enabled(v55, type);
                  if (v76)
                  {
                    if (v77)
                    {
                      *(_DWORD *)buf = 136446466;
                      BOOL v97 = "__nw_frame_effective_length";
                      __int16 v98 = 2082;
                      nw_endpoint_t v99 = v76;
                      _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    free(v76);
                    goto LABEL_206;
                  }
                  if (v77)
                  {
                    *(_DWORD *)buf = 136446210;
                    BOOL v97 = "__nw_frame_effective_length";
                    id v57 = "%{public}s called with null frame, no backtrace";
                    goto LABEL_205;
                  }
                }
                else
                {
                  char v55 = __nwlog_obj();
                  os_log_type_t v56 = type;
                  if (os_log_type_enabled(v55, type))
                  {
                    *(_DWORD *)buf = 136446210;
                    BOOL v97 = "__nw_frame_effective_length";
                    id v57 = "%{public}s called with null frame, backtrace limit exceeded";
                    goto LABEL_205;
                  }
                }
              }
LABEL_206:
              if (v54) {
                free(v54);
              }
              uint64_t v22 = 0;
              uint64_t v21 = *(void *)(*(void *)(a1 + 48) + 72);
              goto LABEL_57;
            }
            __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            BOOL v97 = "__nw_frame_check_validity";
            nw_endpoint_t v58 = (char *)_os_log_send_and_compose_impl();
            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v94 = 0;
            if (__nwlog_fault(v58, &type, &v94))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                char v59 = __nwlog_obj();
                os_log_type_t v60 = type;
                if (!os_log_type_enabled(v59, type)) {
                  goto LABEL_212;
                }
                *(_DWORD *)buf = 136446210;
                BOOL v97 = "__nw_frame_check_validity";
                BOOL v61 = "%{public}s called with null frame";
                goto LABEL_211;
              }
              if (!v94)
              {
                char v59 = __nwlog_obj();
                os_log_type_t v60 = type;
                if (!os_log_type_enabled(v59, type)) {
                  goto LABEL_212;
                }
                *(_DWORD *)buf = 136446210;
                BOOL v97 = "__nw_frame_check_validity";
                BOOL v61 = "%{public}s called with null frame, backtrace limit exceeded";
                goto LABEL_211;
              }
              nw_endpoint_t v78 = (char *)__nw_create_backtrace_string();
              char v59 = __nwlog_obj();
              os_log_type_t v60 = type;
              BOOL v79 = os_log_type_enabled(v59, type);
              if (v78)
              {
                if (v79)
                {
                  *(_DWORD *)buf = 136446466;
                  BOOL v97 = "__nw_frame_check_validity";
                  __int16 v98 = 2082;
                  nw_endpoint_t v99 = v78;
                  _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
                }
                free(v78);
                goto LABEL_212;
              }
              if (v79)
              {
                *(_DWORD *)buf = 136446210;
                BOOL v97 = "__nw_frame_check_validity";
                BOOL v61 = "%{public}s called with null frame, no backtrace";
LABEL_211:
                _os_log_impl(&dword_1830D4000, v59, v60, v61, buf, 0xCu);
              }
            }
LABEL_212:
            if (v58) {
              free(v58);
            }
            goto LABEL_214;
          }
          if (a2) {
            goto LABEL_82;
          }
          char v92 = v18;
          __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          BOOL v97 = "__nw_frame_unclaimed_length";
          os_log_type_t v50 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v94 = 0;
          if (__nwlog_fault(v50, &type, &v94))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              id v51 = __nwlog_obj();
              os_log_type_t v52 = type;
              if (!os_log_type_enabled(v51, type)) {
                goto LABEL_196;
              }
              *(_DWORD *)buf = 136446210;
              BOOL v97 = "__nw_frame_unclaimed_length";
              os_log_type_t v53 = "%{public}s called with null frame";
LABEL_195:
              _os_log_impl(&dword_1830D4000, v51, v52, v53, buf, 0xCu);
              goto LABEL_196;
            }
            if (!v94)
            {
              id v51 = __nwlog_obj();
              os_log_type_t v52 = type;
              if (!os_log_type_enabled(v51, type)) {
                goto LABEL_196;
              }
              *(_DWORD *)buf = 136446210;
              BOOL v97 = "__nw_frame_unclaimed_length";
              os_log_type_t v53 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_195;
            }
            char v74 = (char *)__nw_create_backtrace_string();
            id v51 = __nwlog_obj();
            os_log_type_t v52 = type;
            BOOL v75 = os_log_type_enabled(v51, type);
            if (!v74)
            {
              if (!v75) {
                goto LABEL_196;
              }
              *(_DWORD *)buf = 136446210;
              BOOL v97 = "__nw_frame_unclaimed_length";
              os_log_type_t v53 = "%{public}s called with null frame, no backtrace";
              goto LABEL_195;
            }
            if (v75)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v97 = "__nw_frame_unclaimed_length";
              __int16 v98 = 2082;
              nw_endpoint_t v99 = v74;
              _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v74);
          }
LABEL_196:
          if (v50) {
            free(v50);
          }
          uint64_t v33 = 0;
          uint64_t v34 = *(void **)(v17 + 64);
          if ((v92 & 4) != 0) {
            goto LABEL_199;
          }
          goto LABEL_86;
        }
LABEL_76:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v29 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          uint64_t v30 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136446722;
          BOOL v97 = "nw_protocol_udp_finalize_output_frames_block_invoke";
          if (v30) {
            char v31 = (const char *)(v30 + 96);
          }
          else {
            char v31 = "";
          }
          __int16 v98 = 2082;
          nw_endpoint_t v99 = (void *)v31;
          __int16 v100 = 1024;
          int v101 = v28;
          _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp set internet checksum offload failed (err %d)", buf, 0x1Cu);
        }
        goto LABEL_46;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      BOOL v97 = "__nw_frame_set_internet_checksum";
      id v62 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v94 = 0;
      if (__nwlog_fault(v62, &type, &v94))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v63 = __nwlog_obj();
          os_log_type_t v64 = type;
          if (os_log_type_enabled(v63, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v97 = "__nw_frame_set_internet_checksum";
            os_log_type_t v65 = "%{public}s called with null frame";
LABEL_217:
            _os_log_impl(&dword_1830D4000, v63, v64, v65, buf, 0xCu);
          }
        }
        else if (v94)
        {
          unsigned int v80 = (char *)__nw_create_backtrace_string();
          BOOL v63 = __nwlog_obj();
          os_log_type_t v64 = type;
          BOOL v81 = os_log_type_enabled(v63, type);
          if (v80)
          {
            if (v81)
            {
              *(_DWORD *)buf = 136446466;
              BOOL v97 = "__nw_frame_set_internet_checksum";
              __int16 v98 = 2082;
              nw_endpoint_t v99 = v80;
              _os_log_impl(&dword_1830D4000, v63, v64, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v80);
            goto LABEL_218;
          }
          if (v81)
          {
            *(_DWORD *)buf = 136446210;
            BOOL v97 = "__nw_frame_set_internet_checksum";
            os_log_type_t v65 = "%{public}s called with null frame, no backtrace";
            goto LABEL_217;
          }
        }
        else
        {
          BOOL v63 = __nwlog_obj();
          os_log_type_t v64 = type;
          if (os_log_type_enabled(v63, type))
          {
            *(_DWORD *)buf = 136446210;
            BOOL v97 = "__nw_frame_set_internet_checksum";
            os_log_type_t v65 = "%{public}s called with null frame, backtrace limit exceeded";
            goto LABEL_217;
          }
        }
      }
LABEL_218:
      if (v62) {
        free(v62);
      }
      int v28 = 22;
      goto LABEL_76;
    }
    if ((v14 & 4) != 0) {
      char v15 = 18;
    }
    else {
      char v15 = 66;
    }
    if (a2)
    {
      if ((*(_WORD *)(a2 + 204) & 0x100) != 0) {
        *(unsigned char *)(a2 + 203) |= v15;
      }
      else {
        *(_WORD *)(v13 + 94) = v14 & 0xFEFF;
      }
      goto LABEL_44;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v97 = "__nw_frame_add_internet_csum_flags";
    id v46 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v94 = 0;
    if (__nwlog_fault(v46, &type, &v94))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v47 = __nwlog_obj();
        os_log_type_t v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v97 = "__nw_frame_add_internet_csum_flags";
          uint64_t v49 = "%{public}s called with null frame";
LABEL_183:
          _os_log_impl(&dword_1830D4000, v47, v48, v49, buf, 0xCu);
        }
      }
      else if (v94)
      {
        id v66 = (char *)__nw_create_backtrace_string();
        __int16 v47 = __nwlog_obj();
        os_log_type_t v48 = type;
        BOOL v67 = os_log_type_enabled(v47, type);
        if (v66)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v97 = "__nw_frame_add_internet_csum_flags";
            __int16 v98 = 2082;
            nw_endpoint_t v99 = v66;
            _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v66);
          goto LABEL_184;
        }
        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v97 = "__nw_frame_add_internet_csum_flags";
          uint64_t v49 = "%{public}s called with null frame, no backtrace";
          goto LABEL_183;
        }
      }
      else
      {
        __int16 v47 = __nwlog_obj();
        os_log_type_t v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v97 = "__nw_frame_add_internet_csum_flags";
          uint64_t v49 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_183;
        }
      }
    }
LABEL_184:
    if (v46) {
      free(v46);
    }
    *(_WORD *)(*(void *)(a1 + 48) + 94) &= ~0x100u;
    id v82 = __nwlog_obj();
    if (os_log_type_enabled(v82, OS_LOG_TYPE_ERROR))
    {
      uint64_t v83 = *(void *)(a1 + 48);
      *(_DWORD *)buf = 136446722;
      BOOL v97 = "nw_protocol_udp_finalize_output_frames_block_invoke";
      if (v83) {
        BOOL v84 = (const char *)(v83 + 96);
      }
      else {
        BOOL v84 = "";
      }
      __int16 v98 = 2082;
      nw_endpoint_t v99 = (void *)v84;
      __int16 v100 = 1024;
      int v101 = 22;
      _os_log_impl(&dword_1830D4000, v82, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp set internet checksum offload failed (err %d)", buf, 0x1Cu);
    }
    goto LABEL_44;
  }
  int v36 = __nwlog_obj();
  if (os_log_type_enabled(v36, OS_LOG_TYPE_INFO))
  {
    uint64_t v37 = *(void *)(a1 + 48);
    if (v37) {
      nw_endpoint_t v38 = (const char *)(v37 + 96);
    }
    else {
      nw_endpoint_t v38 = "";
    }
    *(_DWORD *)buf = 136446466;
    BOOL v97 = "nw_protocol_udp_finalize_output_frames_block_invoke";
    __int16 v98 = 2082;
    nw_endpoint_t v99 = (void *)v38;
    _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_INFO, "%{public}s %{public}s UDP frame is no longer valid", buf, 0x16u);
  }
  uint64_t v39 = *(void *)(a1 + 48);
  if (v39)
  {
    *(void *)(v39 + 64) = 0;
    *(void *)(v39 + 72) = 0;
  }
  return 1;
}

uint64_t nw_channel_set_internet_checksum_handler(nw_frame *a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  uint64_t metadata = nw_frame_get_metadata((uint64_t)a1);
  if (metadata)
  {
    if ((*(unsigned char *)(metadata + 24) & 1) == 0) {
      return 45;
    }
    uint64_t v8 = *(void *)metadata;
    return MEMORY[0x1F40CD4C0](v8, a2, a3, a4);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_channel_set_internet_checksum_handler";
  int v9 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_channel_set_internet_checksum_handler";
        unint64_t v12 = "%{public}s called with null frame_info";
LABEL_20:
        _os_log_impl(&dword_1830D4000, v10, v11, v12, buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_channel_set_internet_checksum_handler";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null frame_info, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_channel_set_internet_checksum_handler";
        unint64_t v12 = "%{public}s called with null frame_info, no backtrace";
        goto LABEL_20;
      }
    }
    else
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_channel_set_internet_checksum_handler";
        unint64_t v12 = "%{public}s called with null frame_info, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
  }
LABEL_21:
  if (v9) {
    free(v9);
  }
  return 22;
}

uint64_t nw_protocol_ipv4_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
      int v27 = "%{public}s called with null protocol";
LABEL_89:
      _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0xCu);
      goto LABEL_90;
    }
    if (!v44)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
        int v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v32 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
        int v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v32) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
    __int16 v48 = 2082;
    uint64_t v49 = backtrace_string;
    uint64_t v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_62:
    _os_log_impl(&dword_1830D4000, v25, v26, v33, buf, 0x16u);
    goto LABEL_63;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
      int v27 = "%{public}s called with null ipv4";
      goto LABEL_89;
    }
    if (!v44)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
        int v27 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v34 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v34)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
        int v27 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (!v34) {
      goto LABEL_63;
    }
    *(_DWORD *)buf = 136446466;
    __int16 v47 = "nw_protocol_ipv4_finalize_output_frames";
    __int16 v48 = 2082;
    uint64_t v49 = backtrace_string;
    uint64_t v33 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
    goto LABEL_62;
  }
  v38[0] = MEMORY[0x1E4F143A8];
  v38[1] = 0x40000000;
  uint64_t v39 = ___ZL39nw_protocol_ipv4_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
  uint64_t v40 = &__block_descriptor_tmp_35_87631;
  p_output_handler = &a1[1].output_handler;
  os_log_type_t v42 = a2;
  __int16 v43 = a1;
  os_log_type_t tqh_first = a2->tqh_first;
  do
  {
    if (!tqh_first) {
      break;
    }
    uint64_t v5 = (nw_frame *)*((void *)tqh_first + 4);
    char v6 = ((uint64_t (*)(void *))v39)(v38);
    os_log_type_t tqh_first = v5;
  }
  while ((v6 & 1) != 0);
  output_handler = a1->output_handler;
  if (!output_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v47 = "__nw_protocol_finalize_output_frames";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v44 = 0;
    if (!__nwlog_fault(v24, &type, &v44)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "__nw_protocol_finalize_output_frames";
        int v27 = "%{public}s called with null protocol";
        goto LABEL_89;
      }
LABEL_90:
      if (v24) {
        free(v24);
      }
      return 0;
    }
    if (!v44)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v25, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "__nw_protocol_finalize_output_frames";
        int v27 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v25 = __nwlog_obj();
    os_log_type_t v26 = type;
    BOOL v35 = os_log_type_enabled(v25, type);
    if (!backtrace_string)
    {
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v47 = "__nw_protocol_finalize_output_frames";
        int v27 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_89;
      }
      goto LABEL_90;
    }
    if (v35)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v47 = "__nw_protocol_finalize_output_frames";
      __int16 v48 = 2082;
      uint64_t v49 = backtrace_string;
      uint64_t v33 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_62;
    }
LABEL_63:
    free(backtrace_string);
    goto LABEL_90;
  }
  handle = output_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = output_handler[1].callbacks;
    if (callbacks) {
      output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }
  uint64_t v10 = output_handler->callbacks;
  if (v10)
  {
    finalize_output_frames = (uint64_t (*)(nw_protocol *, nw_frame_array_s *))v10->finalize_output_frames;
    if (finalize_output_frames)
    {
      uint64_t v12 = finalize_output_frames(output_handler, a2);
      if (handle != &nw_protocol_ref_counted_handle) {
        return v12;
      }
      goto LABEL_13;
    }
  }
  __nwlog_obj();
  name = output_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  __int16 v47 = "__nw_protocol_finalize_output_frames";
  if (!name) {
    name = "invalid";
  }
  __int16 v48 = 2082;
  uint64_t v49 = (void *)name;
  __int16 v50 = 2048;
  id v51 = output_handler;
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v44 = 0;
  if (!__nwlog_fault(v19, &type, &v44)) {
    goto LABEL_73;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    __int16 v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_73;
    }
    uint64_t v22 = output_handler->identifier->name;
    if (!v22) {
      uint64_t v22 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    __int16 v47 = "__nw_protocol_finalize_output_frames";
    __int16 v48 = 2082;
    uint64_t v49 = (void *)v22;
    __int16 v50 = 2048;
    id v51 = output_handler;
    uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_72:
    _os_log_impl(&dword_1830D4000, v20, v21, v23, buf, 0x20u);
    goto LABEL_73;
  }
  if (!v44)
  {
    __int16 v20 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (!os_log_type_enabled(v20, type)) {
      goto LABEL_73;
    }
    int v36 = output_handler->identifier->name;
    if (!v36) {
      int v36 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    __int16 v47 = "__nw_protocol_finalize_output_frames";
    __int16 v48 = 2082;
    uint64_t v49 = (void *)v36;
    __int16 v50 = 2048;
    id v51 = output_handler;
    uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
    goto LABEL_72;
  }
  int v28 = (char *)__nw_create_backtrace_string();
  __int16 v20 = __nwlog_obj();
  os_log_type_t v21 = type;
  BOOL v29 = os_log_type_enabled(v20, type);
  if (!v28)
  {
    if (!v29) {
      goto LABEL_73;
    }
    uint64_t v37 = output_handler->identifier->name;
    if (!v37) {
      uint64_t v37 = "invalid";
    }
    *(_DWORD *)buf = 136446722;
    __int16 v47 = "__nw_protocol_finalize_output_frames";
    __int16 v48 = 2082;
    uint64_t v49 = (void *)v37;
    __int16 v50 = 2048;
    id v51 = output_handler;
    uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
    goto LABEL_72;
  }
  if (v29)
  {
    uint64_t v30 = output_handler->identifier->name;
    if (!v30) {
      uint64_t v30 = "invalid";
    }
    *(_DWORD *)buf = 136446978;
    __int16 v47 = "__nw_protocol_finalize_output_frames";
    __int16 v48 = 2082;
    uint64_t v49 = (void *)v30;
    __int16 v50 = 2048;
    id v51 = output_handler;
    __int16 v52 = 2082;
    os_log_type_t v53 = v28;
    _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
  }
  free(v28);
LABEL_73:
  if (v19) {
    free(v19);
  }
  uint64_t v12 = 0;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_13:
    if (output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      BOOL v14 = output_handler[1].callbacks;
      if (v14)
      {
        char v15 = (nw_protocol_callbacks *)((char *)v14 - 1);
        output_handler[1].callbacks = v15;
        if (!v15)
        {
          char v16 = *(void (***)(void))output_handler[1].flow_id;
          if (v16)
          {
            *(void *)output_handler[1].flow_id = 0;
            v16[2](v16);
            _Block_release(v16);
          }
          if (output_handler[1].flow_id[8])
          {
            uint64_t v17 = *(const void **)output_handler[1].flow_id;
            if (v17) {
              _Block_release(v17);
            }
          }
          free(output_handler);
        }
      }
    }
  }
  return v12;
}

uint64_t ___ZL39nw_protocol_ipv4_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  if (nw_frame_get_finalizer_context(a2) == *(void *)(a1 + 32))
  {
    uint64_t v14 = *(void *)(a2 + 32);
    char v15 = *(void **)(a2 + 40);
    if (v14)
    {
      *(void *)(v14 + 40) = v15;
      char v15 = *(void **)(a2 + 40);
    }
    else
    {
      *(void *)(*(void *)(a1 + 40) + 8) = v15;
    }
    void *v15 = v14;
    *(void *)(a2 + 32) = 0;
    *(void *)(a2 + 40) = 0;
    nw_frame_finalize(a2);
  }
  else
  {
    nw_frame_unclaim(a2, v4, 0x14u, 0);
    int v52 = 0;
    uint64_t v5 = nw_frame_unclaimed_bytes(a2, &v52);
    uint64_t v6 = *(void *)(a1 + 32);
    if (v5)
    {
      uint64_t v7 = v5;
      uint64_t v8 = *(void *)(v6 + 48);
      if (v8) {
        ++*(void *)(v8 + 232);
      }
      *(void *)(v5 + 12) = *(void *)(v6 + 56);
      *(unsigned char *)(v5 + 9) = *(unsigned char *)(v6 + 134);
      *(unsigned char *)(v5 + 8) = *(unsigned char *)(v6 + 135);
      *(unsigned char *)uint64_t v5 = 69;
      *(_WORD *)(v5 + 2) = bswap32((unsigned __int16)v52) >> 16;
      if (a2)
      {
        char v9 = *(unsigned char *)(a2 + 186) & 3;
        *(unsigned char *)(v5 + 1) = v9;
        if (*(unsigned char *)(a2 + 184)) {
          *(unsigned char *)(v5 + 1) = v9 | (4 * *(unsigned char *)(a2 + 184));
        }
        int v10 = *(_DWORD *)(a2 + 180);
        if (v10 == 2) {
          goto LABEL_11;
        }
        uint64_t v11 = *(void *)(a1 + 32);
        if (v10)
        {
LABEL_76:
          int v13 = 0;
          *(_DWORD *)(v7 + 4) = 0x400000;
          goto LABEL_77;
        }
LABEL_10:
        if ((*(unsigned char *)(v11 + 136) & 8) != 0)
        {
LABEL_11:
          *(_WORD *)(v7 + 6) = 0;
          LOWORD(__buf) = 0;
          int v12 = (BYTE4(a2) ^ BYTE6(a2) ^ BYTE2(a2) ^ a2);
          do
            arc4random_buf(&__buf, 2uLL);
          while (v12 == (unsigned __int16)__buf);
          int v13 = (unsigned __int16)__buf ^ v12;
          *(_WORD *)(v7 + 4) = v13;
          uint64_t v11 = *(void *)(a1 + 32);
LABEL_77:
          *(_WORD *)(v7 + 10) = 0;
          if ((*(unsigned char *)(v11 + 136) & 0x20) != 0)
          {
            if ((*(unsigned char *)(v11 + 136) & 0x40) != 0)
            {
              *(_WORD *)(v7 + 10) = nw_ipv4_checksum((unsigned __int16 *)v7);
              uint64_t v45 = *(void *)(v11 + 48);
              if (v45) {
                *(int64x2_t *)(v45 + 312) = vaddq_s64(*(int64x2_t *)(v45 + 312), (int64x2_t)xmmword_183D5CDF0);
              }
              *(unsigned char *)(v11 + 136) &= ~0x40u;
            }
            else
            {
              *(_WORD *)(v7 + 10) = -16657;
              *(unsigned char *)(v11 + 136) |= 0x40u;
            }
            goto LABEL_87;
          }
          if ((*(unsigned char *)(v11 + 136) & 0x10) == 0)
          {
            if ((v7 & 3) != 0)
            {
              v38.i16[0] = *(_WORD *)(v7 + 2);
              v38.i16[1] = *(_WORD *)v7;
              v38.i32[1] = *(_DWORD *)(v7 + 6);
              int v39 = vaddvq_s32((int32x4_t)vaddl_u16(v38, *(uint16x4_t *)(v7 + 12)));
              LODWORD(v40) = ((v39 + v13) >> 16)
                           + (unsigned __int16)(v39 + v13)
                           + ((((v39 + v13) >> 16) + (unsigned __int16)(v39 + v13)) >> 16);
            }
            else
            {
              unint64_t v41 = vaddlvq_u32(*(uint32x4_t *)v7);
              unint64_t v42 = ((v41 + *(unsigned int *)(v7 + 16)) >> 32) + (v41 + *(_DWORD *)(v7 + 16));
              unint64_t v40 = (((v42 >> 16) + (unsigned __int16)v42) >> 16) + (unsigned __int16)(WORD1(v42) + v42);
              LOWORD(v40) = WORD1(v40) + v40;
            }
            *(_WORD *)(v7 + 10) = ~(_WORD)v40;
            uint64_t v43 = *(void *)(v11 + 48);
            if (v43) {
              *(int64x2_t *)(v43 + 312) = vaddq_s64(*(int64x2_t *)(v43 + 312), (int64x2_t)xmmword_183D5CDF0);
            }
LABEL_87:
            ++**(void **)(a1 + 32);
            return 1;
          }
          if (a2)
          {
            if ((*(_WORD *)(a2 + 204) & 0x100) != 0) {
              *(unsigned char *)(a2 + 203) |= 4u;
            }
            goto LABEL_87;
          }
          __nwlog_obj();
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_add_internet_csum_flags";
          id v46 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v53 = 0;
          if (__nwlog_fault(v46, &type, &v53))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              __int16 v47 = __nwlog_obj();
              os_log_type_t v48 = type;
              if (!os_log_type_enabled(v47, type)) {
                goto LABEL_108;
              }
              int __buf = 136446210;
              os_log_type_t v56 = "__nw_frame_add_internet_csum_flags";
              uint64_t v49 = "%{public}s called with null frame";
              goto LABEL_107;
            }
            if (!v53)
            {
              __int16 v47 = __nwlog_obj();
              os_log_type_t v48 = type;
              if (!os_log_type_enabled(v47, type)) {
                goto LABEL_108;
              }
              int __buf = 136446210;
              os_log_type_t v56 = "__nw_frame_add_internet_csum_flags";
              uint64_t v49 = "%{public}s called with null frame, backtrace limit exceeded";
              goto LABEL_107;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            __int16 v47 = __nwlog_obj();
            os_log_type_t v48 = type;
            BOOL v51 = os_log_type_enabled(v47, type);
            if (backtrace_string)
            {
              if (v51)
              {
                int __buf = 136446466;
                os_log_type_t v56 = "__nw_frame_add_internet_csum_flags";
                __int16 v57 = 2082;
                nw_endpoint_t v58 = backtrace_string;
                _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
              }
              free(backtrace_string);
              goto LABEL_108;
            }
            if (v51)
            {
              int __buf = 136446210;
              os_log_type_t v56 = "__nw_frame_add_internet_csum_flags";
              uint64_t v49 = "%{public}s called with null frame, no backtrace";
LABEL_107:
              _os_log_impl(&dword_1830D4000, v47, v48, v49, (uint8_t *)&__buf, 0xCu);
            }
          }
LABEL_108:
          if (v46) {
            free(v46);
          }
          goto LABEL_87;
        }
        goto LABEL_76;
      }
      __nwlog_obj();
      int __buf = 136446210;
      os_log_type_t v56 = "__nw_frame_get_ecn_flag";
      __int16 v20 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v53 = 0;
      if (__nwlog_fault(v20, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v21 = __nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_41;
          }
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_ecn_flag";
          uint64_t v23 = "%{public}s called with null frame";
LABEL_40:
          _os_log_impl(&dword_1830D4000, v21, v22, v23, (uint8_t *)&__buf, 0xCu);
          goto LABEL_41;
        }
        if (!v53)
        {
          os_log_type_t v21 = __nwlog_obj();
          os_log_type_t v22 = type;
          if (!os_log_type_enabled(v21, type)) {
            goto LABEL_41;
          }
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_ecn_flag";
          uint64_t v23 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_40;
        }
        uint64_t v24 = (char *)__nw_create_backtrace_string();
        os_log_type_t v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (!v24)
        {
          if (!v25) {
            goto LABEL_41;
          }
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_ecn_flag";
          uint64_t v23 = "%{public}s called with null frame, no backtrace";
          goto LABEL_40;
        }
        if (v25)
        {
          int __buf = 136446466;
          os_log_type_t v56 = "__nw_frame_get_ecn_flag";
          __int16 v57 = 2082;
          nw_endpoint_t v58 = v24;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
        }
        free(v24);
      }
LABEL_41:
      if (v20) {
        free(v20);
      }
      *(unsigned char *)(v7 + 1) = 0;
      __nwlog_obj();
      int __buf = 136446210;
      os_log_type_t v56 = "__nw_frame_get_dscp_value";
      os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v53 = 0;
      if (__nwlog_fault(v26, &type, &v53))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v27 = __nwlog_obj();
          os_log_type_t v28 = type;
          if (!os_log_type_enabled(v27, type)) {
            goto LABEL_57;
          }
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_dscp_value";
          BOOL v29 = "%{public}s called with null frame";
LABEL_56:
          _os_log_impl(&dword_1830D4000, v27, v28, v29, (uint8_t *)&__buf, 0xCu);
          goto LABEL_57;
        }
        if (!v53)
        {
          int v27 = __nwlog_obj();
          os_log_type_t v28 = type;
          if (!os_log_type_enabled(v27, type)) {
            goto LABEL_57;
          }
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_dscp_value";
          BOOL v29 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_56;
        }
        uint64_t v30 = (char *)__nw_create_backtrace_string();
        int v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        BOOL v31 = os_log_type_enabled(v27, type);
        if (!v30)
        {
          if (!v31) {
            goto LABEL_57;
          }
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_dscp_value";
          BOOL v29 = "%{public}s called with null frame, no backtrace";
          goto LABEL_56;
        }
        if (v31)
        {
          int __buf = 136446466;
          os_log_type_t v56 = "__nw_frame_get_dscp_value";
          __int16 v57 = 2082;
          nw_endpoint_t v58 = v30;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
        }
        free(v30);
      }
LABEL_57:
      if (v26) {
        free(v26);
      }
      __nwlog_obj();
      int __buf = 136446210;
      os_log_type_t v56 = "__nw_frame_get_fragmentation";
      BOOL v32 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v53 = 0;
      if (!__nwlog_fault(v32, &type, &v53)) {
        goto LABEL_73;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_fragmentation";
          BOOL v35 = "%{public}s called with null frame";
LABEL_72:
          _os_log_impl(&dword_1830D4000, v33, v34, v35, (uint8_t *)&__buf, 0xCu);
        }
      }
      else if (v53)
      {
        int v36 = (char *)__nw_create_backtrace_string();
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        BOOL v37 = os_log_type_enabled(v33, type);
        if (v36)
        {
          if (v37)
          {
            int __buf = 136446466;
            os_log_type_t v56 = "__nw_frame_get_fragmentation";
            __int16 v57 = 2082;
            nw_endpoint_t v58 = v36;
            _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null frame, dumping backtrace:%{public}s", (uint8_t *)&__buf, 0x16u);
          }
          free(v36);
          goto LABEL_73;
        }
        if (v37)
        {
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_fragmentation";
          BOOL v35 = "%{public}s called with null frame, no backtrace";
          goto LABEL_72;
        }
      }
      else
      {
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          int __buf = 136446210;
          os_log_type_t v56 = "__nw_frame_get_fragmentation";
          BOOL v35 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_72;
        }
      }
LABEL_73:
      if (v32) {
        free(v32);
      }
      uint64_t v11 = *(void *)(a1 + 32);
      goto LABEL_10;
    }
    if (!v6 || (*(unsigned char *)(v6 + 136) & 1) == 0)
    {
      char v16 = __nwlog_obj();
      BOOL v17 = os_log_type_enabled(v16, OS_LOG_TYPE_INFO);
      uint64_t v6 = *(void *)(a1 + 32);
      if (v17)
      {
        __int16 v18 = (const char *)(v6 + 137);
        if (!v6) {
          __int16 v18 = "";
        }
        int __buf = 136446978;
        os_log_type_t v56 = "nw_protocol_ipv4_finalize_output_frames_block_invoke";
        __int16 v57 = 2082;
        nw_endpoint_t v58 = (void *)v18;
        uint64_t v19 = " ";
        if (!v6) {
          uint64_t v19 = "";
        }
        __int16 v59 = 2080;
        os_log_type_t v60 = v19;
        __int16 v61 = 2048;
        uint64_t v62 = v6;
        _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", (uint8_t *)&__buf, 0x2Au);
        uint64_t v6 = *(void *)(a1 + 32);
      }
    }
    *(void *)(v6 + 48) = 0;
  }
  return 1;
}

uint64_t nw_frame_unclaimed_bytes(uint64_t a1, _DWORD *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v15 = "__nw_frame_unclaimed_bytes";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12)) {
      goto LABEL_27;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "__nw_frame_unclaimed_bytes";
      char v9 = "%{public}s called with null frame";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v15 = "__nw_frame_unclaimed_bytes";
          __int16 v16 = 2082;
          BOOL v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_27;
      }
      if (!v11)
      {
LABEL_27:
        if (v6) {
          free(v6);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "__nw_frame_unclaimed_bytes";
      char v9 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_27;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "__nw_frame_unclaimed_bytes";
      char v9 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    goto LABEL_27;
  }
  if (!*(void *)(a1 + 112)) {
    return 0;
  }
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0
    && g_channel_check_validity
    && (g_channel_check_validity(a1, *(void *)(a1 + 88)) & 1) == 0)
  {
    uint64_t result = 0;
    if (a2) {
      *a2 = 0;
    }
  }
  else
  {
    if (a2)
    {
      int v4 = *(_DWORD *)(a1 + 52);
      if (v4) {
        v4 -= *(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60);
      }
      *a2 = v4;
    }
    return *(void *)(a1 + 112) + *(unsigned int *)(a1 + 56);
  }
  return result;
}

BOOL nw_frame_unclaim(uint64_t a1, uint64_t a2, unsigned int a3, unsigned int a4)
{
  *(void *)&v36[13] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v34 = "__nw_frame_unclaim_internal";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v25, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "__nw_frame_unclaim_internal";
          os_log_type_t v28 = "%{public}s called with null frame";
LABEL_43:
          _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v34 = "__nw_frame_unclaim_internal";
            __int16 v35 = 2082;
            *(void *)int v36 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_44;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "__nw_frame_unclaim_internal";
          os_log_type_t v28 = "%{public}s called with null frame, no backtrace";
          goto LABEL_43;
        }
      }
      else
      {
        os_log_type_t v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v34 = "__nw_frame_unclaim_internal";
          os_log_type_t v28 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_43;
        }
      }
    }
LABEL_44:
    if (v25) {
      free(v25);
    }
    return 0;
  }
  if ((*(_WORD *)(a1 + 204) & 0x80) == 0) {
    goto LABEL_21;
  }
  if (a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v34 = "__nw_frame_unclaim_internal";
    __int16 v35 = 1024;
    *(_DWORD *)int v36 = a4;
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v7, &type, &v31)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v34 = "__nw_frame_unclaim_internal";
      __int16 v35 = 1024;
      *(_DWORD *)int v36 = a4;
      int v10 = "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate";
    }
    else if (v31)
    {
      BOOL v11 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = gLogObj;
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (v11)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v34 = "__nw_frame_unclaim_internal";
          __int16 v35 = 1024;
          *(_DWORD *)int v36 = a4;
          v36[2] = 2082;
          *(void *)&v36[3] = v11;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v11);
        goto LABEL_18;
      }
      if (!v12)
      {
LABEL_18:
        if (v7) {
          free(v7);
        }
        goto LABEL_20;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v34 = "__nw_frame_unclaim_internal";
      __int16 v35 = 1024;
      *(_DWORD *)int v36 = a4;
      int v10 = "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = gLogObj;
      os_log_type_t v9 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v34 = "__nw_frame_unclaim_internal";
      __int16 v35 = 1024;
      *(_DWORD *)int v36 = a4;
      int v10 = "%{public}s Trying to unclaim at the end %u bytes from a single-IP aggregate, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0x12u);
    goto LABEL_18;
  }
LABEL_20:
  *(_WORD *)(a1 + 196) += a3;
LABEL_21:
  unsigned int v13 = *(_DWORD *)(a1 + 56);
  BOOL v14 = v13 >= a3;
  unsigned int v15 = v13 - a3;
  if (v14)
  {
    unsigned int v21 = *(_DWORD *)(a1 + 60);
    BOOL v14 = v21 >= a4;
    unsigned int v22 = v21 - a4;
    if (v14)
    {
      *(_DWORD *)(a1 + 56) = v15;
      *(_DWORD *)(a1 + 60) = v22;
      return 1;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v23 = gLogObj;
      BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      if (result)
      {
        int v24 = *(_DWORD *)(a1 + 60);
        *(_DWORD *)buf = 136446722;
        os_log_type_t v34 = "__nw_frame_unclaim_internal";
        __int16 v35 = 1024;
        *(_DWORD *)int v36 = a4;
        v36[2] = 1024;
        *(_DWORD *)&v36[3] = v24;
        uint64_t v19 = "%{public}s Frame cannot unclaim %u end bytes (has %u left)";
        __int16 v20 = v23;
        goto LABEL_27;
      }
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v16 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (result)
    {
      int v18 = *(_DWORD *)(a1 + 56);
      *(_DWORD *)buf = 136446722;
      os_log_type_t v34 = "__nw_frame_unclaim_internal";
      __int16 v35 = 1024;
      *(_DWORD *)int v36 = a3;
      v36[2] = 1024;
      *(_DWORD *)&v36[3] = v18;
      uint64_t v19 = "%{public}s Frame cannot unclaim %u start bytes (has %u left)";
      __int16 v20 = v16;
LABEL_27:
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, v19, buf, 0x18u);
      return 0;
    }
  }
  return result;
}

uint64_t nw_frame_get_finalizer_context(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 88);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v11 = "nw_frame_get_finalizer_context";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "nw_frame_get_finalizer_context";
        uint64_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v11 = "nw_frame_get_finalizer_context";
          __int16 v12 = 2082;
          unsigned int v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "nw_frame_get_finalizer_context";
        uint64_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      id v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v11 = "nw_frame_get_finalizer_context";
        uint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t nw_channel_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    handle = a1->handle;
    if (handle)
    {
      unsigned int v4 = ((unsigned __int16)handle[222] | (*((unsigned __int8 *)handle + 446) << 16)) & 0xFFF9FFFF | 0x20000;
      handle[222] = handle[222];
      *((unsigned char *)handle + 446) = BYTE2(v4);
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x2000000000;
      uint64_t v28 = 0;
      if (_nw_signposts_once == -1)
      {
        if (!_nw_signposts_enabled) {
          goto LABEL_12;
        }
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
        if (!_nw_signposts_enabled) {
          goto LABEL_12;
        }
      }
      if (kdebug_is_enabled())
      {
        *(_DWORD *)os_log_type_t type = 0;
        nw_frame_array_get_frame_count((uint64_t *)a2, 1, type);
      }
LABEL_12:
      *(void *)os_log_type_t type = 0;
      BOOL v25 = type;
      os_log_type_t tqh_first = a2->tqh_first;
      if (a2->tqh_first)
      {
        *((void *)tqh_first + 5) = type;
        tqh_last = a2->tqh_last;
        *(void *)os_log_type_t type = tqh_first;
        BOOL v25 = (os_log_type_t *)tqh_last;
        a2->os_log_type_t tqh_first = 0;
        a2->tqh_last = &a2->tqh_first;
      }
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 0x40000000;
      unsigned int v21 = ___ZL33nw_channel_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke;
      unsigned int v22 = &unk_1E524B8A8;
      uint64_t v23 = buf;
      do
      {
        uint64_t v8 = *(void *)type;
        if (!*(void *)type) {
          break;
        }
        uint64_t v10 = *(void *)(*(void *)type + 32);
        BOOL v7 = *(void **)(*(void *)type + 40);
        os_log_type_t v9 = (void *)(*(void *)type + 32);
        if (v10)
        {
          *(void *)(v10 + 40) = v7;
          BOOL v7 = *(void **)(v8 + 40);
        }
        else
        {
          BOOL v25 = *(os_log_type_t **)(*(void *)type + 40);
        }
        void *v7 = v10;
        void *v9 = 0;
        *(void *)(v8 + 40) = 0;
      }
      while ((((uint64_t (*)(void *))v21)(v20) & 1) != 0);
      if (_nw_signposts_once == -1)
      {
        if (_nw_signposts_enabled) {
          goto LABEL_22;
        }
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
        if (_nw_signposts_enabled)
        {
LABEL_22:
          if (kdebug_is_enabled()) {
            kdebug_trace();
          }
        }
      }
      _Block_object_dispose(buf, 8);
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
    __int16 v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v12, type, &v26)) {
      goto LABEL_56;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
        unsigned int v15 = "%{public}s called with null channel";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (!v26)
    {
      unsigned int v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
        unsigned int v15 = "%{public}s called with null channel, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v13 = __nwlog_obj();
    os_log_type_t v14 = type[0];
    BOOL v19 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
        unsigned int v15 = "%{public}s called with null channel, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v18 = "%{public}s called with null channel, dumping backtrace:%{public}s";
      goto LABEL_45;
    }
    goto LABEL_46;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
  __int16 v12 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault(v12, type, &v26)) {
    goto LABEL_56;
  }
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (!v26)
    {
      unsigned int v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (os_log_type_enabled(v13, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
        unsigned int v15 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v13 = __nwlog_obj();
    os_log_type_t v14 = type[0];
    BOOL v17 = os_log_type_enabled(v13, type[0]);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
        unsigned int v15 = "%{public}s called with null channel_protocol, no backtrace";
        goto LABEL_55;
      }
      goto LABEL_56;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      int v18 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_45:
      _os_log_impl(&dword_1830D4000, v13, v14, v18, buf, 0x16u);
    }
LABEL_46:
    free(backtrace_string);
    goto LABEL_56;
  }
  unsigned int v13 = __nwlog_obj();
  os_log_type_t v14 = type[0];
  if (os_log_type_enabled(v13, type[0]))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_finalize_output_frames";
    unsigned int v15 = "%{public}s called with null channel_protocol";
LABEL_55:
    _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
  }
LABEL_56:
  if (v12) {
    free(v12);
  }
  return 0;
}

uint64_t nw_parameters_get_is_probe(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint32_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[97] >> 2) & 1;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_parameters_get_is_probe";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_parameters_get_is_probe";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_is_probe";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_context_64k_buffer_length()
{
  return dword_1E8F651F0;
}

BOOL nw_settings_get_quic_enabled()
{
  uint64_t v0 = (const char *)nw_setting_enable_quic;
  networkd_settings_init();
  if (!sCachedSettings) {
    return 0;
  }
  pthread_mutex_lock(&sSettingsMutex);
  uint32_t v1 = (void *)sCachedSettings;
  if (!sCachedSettings) {
    goto LABEL_7;
  }
  Class Class = object_getClass((id)sCachedSettings);
  BOOL v3 = 0;
  if (!v0 || Class != (Class)MEMORY[0x1E4F14590]) {
    goto LABEL_8;
  }
  xpc_object_t value = xpc_dictionary_get_value(v1, v0);
  if (value && (uint64_t v5 = value, object_getClass(value) == (Class)MEMORY[0x1E4F14570])) {
    BOOL v3 = xpc_BOOL_get_value(v5);
  }
  else {
LABEL_7:
  }
    BOOL v3 = 0;
LABEL_8:
  pthread_mutex_unlock(&sSettingsMutex);
  return v3;
}

id *nw_quic_create_stream_metadata()
{
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
  }
  uint64_t v0 = (void *)nw_protocol_copy_quic_stream_definition::quic_definition;

  return nw_protocol_metadata_create_singleton(v0);
}

void ___ZL26nw_listener_start_on_queueP22NWConcrete_nw_listener_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  uint64_t v4 = *(void *)(*(void *)(a1 + 32) + 16);
  if (v4 && !nw_path_parameters_get_logging_disabled(*(void *)(v4 + 104)))
  {
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
    }
    uint64_t v5 = (id)glistenerLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
      int v7 = 136446722;
      os_log_type_t v8 = "nw_listener_start_on_queue_block_invoke";
      __int16 v9 = 2082;
      os_log_type_t v10 = id_string;
      __int16 v11 = 2114;
      id v12 = v3;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s [%{public}s] Handling new path %{public}@", (uint8_t *)&v7, 0x20u);
    }
  }
  nw_listener_handle_new_path_on_queue(*(void **)(a1 + 32), v3);
}

void sub_183114164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_listener_handle_new_path_on_queue(void *a1, void *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  nw_context_assert_queue(*((void **)v3 + 3));
  if ((*((_DWORD *)v3 + 32) - 1) <= 1 && (*((unsigned char *)v3 + 302) & 1) == 0)
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = ___ZL36nw_listener_handle_new_path_on_queueP22NWConcrete_nw_listenerPU21objcproto10OS_nw_path8NSObject_block_invoke;
    aBlock[3] = &unk_1E524B9A0;
    id v5 = v3;
    id v70 = v5;
    id v71 = v4;
    uint64_t v6 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 2);
    v6[2](v6);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 2);

    if (nw_path_get_status(*((nw_path_t *)v5 + 22)) != nw_path_status_satisfiable)
    {
      nw_listener_clear_trigger_agents_on_queue((NWConcrete_nw_listener *)v5);
LABEL_121:
      nw_listener_reconcile_inboxes_on_queue((NWConcrete_nw_listener *)v5);

      goto LABEL_122;
    }
    int v7 = (char *)v5;
    nw_context_assert_queue(*((void **)v3 + 3));
    os_log_type_t v8 = (id *)(v7 + 200);
    if (!*((void *)v7 + 25))
    {

      goto LABEL_14;
    }
    if (*((void *)v7 + 24))
    {
      __int16 v9 = nw_path_copy_inactive_agent_uuids(*((void **)v5 + 22), 0);
      os_log_type_t v10 = v9;
      if (v9 && xpc_array_get_count(v9))
      {
        xpc_object_t v11 = xpc_array_create(0, 0);
        if (v11)
        {
          id v12 = *((id *)v7 + 24);
          uint64_t v13 = *((void *)v5 + 22);
          if (v13 && (os_log_type_t v14 = *(void **)(v13 + 224)) != 0) {
            id v15 = v14;
          }
          else {
            id v15 = 0;
          }
          BOOL v32 = (void *)*((void *)v7 + 25);
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 3221225472;
          *(void *)&buf[16] = ___ZL42nw_listener_update_trigger_agents_on_queueP22NWConcrete_nw_listener_block_invoke;
          *(void *)&long long v75 = &unk_1E523D0C0;
          id v67 = v12;
          *((void *)&v75 + 1) = v67;
          id v68 = v15;
          id v76 = v68;
          id v33 = v11;
          id v77 = v33;
          os_log_type_t v34 = v7;
          nw_endpoint_t v78 = v34;
          xpc_array_apply(v32, buf);
          __int16 v35 = v33;
          size_t count = xpc_array_get_count(v33);
          if (count)
          {
            objc_storeStrong((id *)v7 + 25, v11);
            id v37 = v68;
            uint16x4_t v38 = *((void *)v7 + 24);
            *((void *)v7 + 24) = v37;
          }
          else
          {
            nw_listener_clear_trigger_agents_on_queue(v34);
            uint64_t v43 = *((void *)v34 + 2);
            if (!v43 || nw_path_parameters_get_logging_disabled(*(void *)(v43 + 104)))
            {
LABEL_61:

              if (!count)
              {
LABEL_31:
                uint64_t v24 = *((void *)v7 + 2);
                if (!v24 || nw_path_parameters_get_logging_disabled(*(void *)(v24 + 104))) {
                  goto LABEL_121;
                }
                if (__nwlog_listener_log::onceToken != -1) {
                  dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
                }
                uint64_t v16 = (id)glistenerLogObj;
                if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
                {
                  BOOL v25 = v7;

                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_listener_handle_new_path_on_queue";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v25 + 42;
                  _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] agents failed to become active", buf, 0x16u);
                }
                goto LABEL_120;
              }
LABEL_14:
              uint64_t v16 = v7;
              nw_context_assert_queue(*((void **)v3 + 3));
              id v17 = nw_path_copy_inactive_agent_uuids(*((void **)v5 + 22), 0);
              int v18 = v17;
              if (!v17 || !xpc_array_get_count(v17)) {
                goto LABEL_119;
              }
              if (*v8 || (Class v26 = v16[23].isa) != 0 && xpc_equal(v26, v18))
              {
                Class isa = v16[2].isa;
                if (!isa || nw_path_parameters_get_logging_disabled(*((void *)isa + 13))) {
                  goto LABEL_119;
                }
                if (__nwlog_listener_log::onceToken != -1) {
                  dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
                }
                __int16 v20 = (id)glistenerLogObj;
                if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
                {
                  id_string = nw_listener_get_id_string(v16);
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = id_string;
                  _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}s] Already triggered agents", buf, 0x16u);
                }
                goto LABEL_118;
              }
              nw_listener_clear_trigger_agents_on_queue((NWConcrete_nw_listener *)v16);
              __int16 v20 = xpc_array_create(0, 0);
              if (v20)
              {
                int v27 = nw_path_evaluator_trigger_agents(v16[21].isa, 0, 0, v20);
                int v28 = v27;
                if (v27 == 1)
                {
                  Class v57 = v16[2].isa;
                  if (!v57 || nw_path_parameters_get_logging_disabled(*((void *)v57 + 13))) {
                    goto LABEL_118;
                  }
                  if (__nwlog_listener_log::onceToken != -1) {
                    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
                  }
                  char v53 = (id)glistenerLogObj;
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
                  {
                    nw_endpoint_t v58 = nw_listener_get_id_string(v16);
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = v58;
                    *(_WORD *)&unsigned char buf[22] = 1024;
                    LODWORD(v75) = 1;
                    WORD2(v75) = 2082;
                    *(void *)((char *)&v75 + 6) = "cannot satisfy";
                    _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}s] Trigger failed: [%d] %{public}s", buf, 0x26u);
                  }
                }
                else if (v27 || !xpc_array_get_count(v20))
                {
                  Class v52 = v16[2].isa;
                  if (!v52 || nw_path_parameters_get_logging_disabled(*((void *)v52 + 13))) {
                    goto LABEL_118;
                  }
                  if (__nwlog_listener_log::onceToken != -1) {
                    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
                  }
                  char v53 = (id)glistenerLogObj;
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
                  {
                    uint64_t v54 = nw_listener_get_id_string(v16);
                    char v55 = off_1E5248590[v28];
                    *(_DWORD *)buf = 136446978;
                    *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = v54;
                    *(_WORD *)&unsigned char buf[22] = 1024;
                    LODWORD(v75) = v28;
                    WORD2(v75) = 2082;
                    *(void *)((char *)&v75 + 6) = v55;
                    _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Trigger failed: [%d] %{public}s", buf, 0x26u);
                  }
                }
                else
                {
                  objc_storeStrong((id *)&v16[23].isa, v18);
                  uint64_t v29 = *((void *)v5 + 22);
                  if (v29 && (BOOL v30 = *(void **)(v29 + 224)) != 0) {
                    char v31 = v30;
                  }
                  else {
                    char v31 = 0;
                  }
                  Class v62 = v16[24].isa;
                  v16[24].Class isa = v31;

                  objc_storeStrong(v8, v20);
                  Class v63 = v16[2].isa;
                  if (!v63 || nw_path_parameters_get_logging_disabled(*((void *)v63 + 13))) {
                    goto LABEL_118;
                  }
                  if (__nwlog_listener_log::onceToken != -1) {
                    dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
                  }
                  char v53 = (id)glistenerLogObj;
                  if (os_log_type_enabled(v53, OS_LOG_TYPE_DEBUG))
                  {
                    os_log_type_t v64 = nw_listener_get_id_string(v16);
                    size_t v65 = xpc_array_get_count(v18);
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = v64;
                    *(_WORD *)&unsigned char buf[22] = 2048;
                    *(void *)&long long v75 = v65;
                    _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_DEBUG, "%{public}s [%{public}s] Triggered %zu agents", buf, 0x20u);
                  }
                }

LABEL_118:
LABEL_119:

LABEL_120:
                goto LABEL_121;
              }
              os_log_type_t v48 = __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
              uint64_t v49 = (char *)_os_log_send_and_compose_impl();

              v79[0] = 16;
              os_log_type_t type = OS_LOG_TYPE_DEFAULT;
              if (__nwlog_fault(v49, v79, &type))
              {
                if (v79[0] == 17)
                {
                  __int16 v50 = __nwlog_obj();
                  os_log_type_t v51 = v79[0];
                  if (os_log_type_enabled(v50, (os_log_type_t)v79[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                    _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s xpc_array_create failed", buf, 0xCu);
                  }
                }
                else if (type)
                {
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  __int16 v50 = __nwlog_obj();
                  os_log_type_t v60 = v79[0];
                  BOOL v61 = os_log_type_enabled(v50, (os_log_type_t)v79[0]);
                  if (backtrace_string)
                  {
                    if (v61)
                    {
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = backtrace_string;
                      _os_log_impl(&dword_1830D4000, v50, v60, "%{public}s xpc_array_create failed, dumping backtrace:%{public}s", buf, 0x16u);
                    }

                    free(backtrace_string);
                    goto LABEL_115;
                  }
                  if (v61)
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                    _os_log_impl(&dword_1830D4000, v50, v60, "%{public}s xpc_array_create failed, no backtrace", buf, 0xCu);
                  }
                }
                else
                {
                  __int16 v50 = __nwlog_obj();
                  os_log_type_t v66 = v79[0];
                  if (os_log_type_enabled(v50, (os_log_type_t)v79[0]))
                  {
                    *(_DWORD *)buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_listener_trigger_agents_on_queue";
                    _os_log_impl(&dword_1830D4000, v50, v66, "%{public}s xpc_array_create failed, backtrace limit exceeded", buf, 0xCu);
                  }
                }
              }
LABEL_115:
              if (v49) {
                free(v49);
              }
              __int16 v20 = 0;
              goto LABEL_118;
            }
            if (__nwlog_listener_log::onceToken != -1) {
              dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
            }
            uint16x4_t v38 = (id)glistenerLogObj;
            if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
            {
              char v44 = nw_listener_get_id_string(v34);
              *(_DWORD *)BOOL v79 = 136446466;
              unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
              __int16 v81 = 2082;
              id v82 = (void *)v44;
              _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_INFO, "%{public}s [%{public}s] all triggered agents updated", v79, 0x16u);
            }
          }

          goto LABEL_61;
        }
        int v39 = __nwlog_obj();
        *(_DWORD *)BOOL v79 = 136446210;
        unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
        unint64_t v40 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v72 = 0;
        if (__nwlog_fault(v40, &type, &v72))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            unint64_t v41 = __nwlog_obj();
            os_log_type_t v42 = type;
            if (os_log_type_enabled(v41, type))
            {
              *(_DWORD *)BOOL v79 = 136446210;
              unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
              _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s xpc_array_create failed", v79, 0xCu);
            }
          }
          else if (v72)
          {
            uint64_t v45 = (char *)__nw_create_backtrace_string();
            unint64_t v41 = __nwlog_obj();
            os_log_type_t v46 = type;
            BOOL v47 = os_log_type_enabled(v41, type);
            if (v45)
            {
              if (v47)
              {
                *(_DWORD *)BOOL v79 = 136446466;
                unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
                __int16 v81 = 2082;
                id v82 = v45;
                _os_log_impl(&dword_1830D4000, v41, v46, "%{public}s xpc_array_create failed, dumping backtrace:%{public}s", v79, 0x16u);
              }

              free(v45);
              goto LABEL_98;
            }
            if (v47)
            {
              *(_DWORD *)BOOL v79 = 136446210;
              unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
              _os_log_impl(&dword_1830D4000, v41, v46, "%{public}s xpc_array_create failed, no backtrace", v79, 0xCu);
            }
          }
          else
          {
            unint64_t v41 = __nwlog_obj();
            os_log_type_t v56 = type;
            if (os_log_type_enabled(v41, type))
            {
              *(_DWORD *)BOOL v79 = 136446210;
              unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
              _os_log_impl(&dword_1830D4000, v41, v56, "%{public}s xpc_array_create failed, backtrace limit exceeded", v79, 0xCu);
            }
          }
        }
LABEL_98:
        if (v40) {
          free(v40);
        }

        goto LABEL_14;
      }
      nw_listener_clear_trigger_agents_on_queue((NWConcrete_nw_listener *)v7);
    }
    else
    {
      nw_listener_clear_trigger_agents_on_queue((NWConcrete_nw_listener *)v7);
      uint64_t v22 = *((void *)v7 + 2);
      if (!v22 || nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
      {

        goto LABEL_31;
      }
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      os_log_type_t v10 = (id)glistenerLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        uint64_t v23 = nw_listener_get_id_string(v7);
        *(_DWORD *)BOOL v79 = 136446466;
        unsigned int v80 = "nw_listener_update_trigger_agents_on_queue";
        __int16 v81 = 2082;
        id v82 = (void *)v23;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] no inactive agent information", v79, 0x16u);
      }
    }

    goto LABEL_31;
  }
LABEL_122:
}

void sub_183114EE8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_is_constrained(nw_path_t path)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (!v1)
  {
    uint64_t v19 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v30 = "nw_path_is_constrained";
    __int16 v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v20, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v30 = "nw_path_is_constrained";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v21 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v30 = "nw_path_is_constrained";
            __int16 v31 = 2082;
            BOOL v32 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v30 = "nw_path_is_constrained";
          _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unsigned int v21 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v30 = "nw_path_is_constrained";
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_35:
    if (v20) {
      free(v20);
    }
    BOOL v7 = 0;
    goto LABEL_18;
  }
  if ((BYTE3(v1[59].isa) & 0x10) == 0)
  {
    id v3 = nw_path_copy_connected_interface(v1);
    id v4 = v3;
    if (v3)
    {
      id v5 = v3;
      __int16 v6 = *(_WORD *)(v5 + 85);

      if ((v6 & 2) != 0) {
        goto LABEL_16;
      }
    }
    if (LODWORD(v2[47].isa) != 1)
    {
      BOOL v7 = 0;
      int isa_high = HIDWORD(v2[47].isa);
      if (isa_high == 4 || isa_high == 30) {
        goto LABEL_17;
      }
    }
    Class isa = v2[12].isa;
    if (isa)
    {
      os_log_type_t v10 = isa;
      __int16 v11 = *(_WORD *)(v10 + 85);

      if ((v11 & 2) != 0) {
        goto LABEL_16;
      }
    }
    Class v12 = v2[13].isa;
    if (v12)
    {
      uint64_t v13 = v12;
      __int16 v14 = *(_WORD *)(v13 + 85);

      if ((v14 & 2) != 0) {
        goto LABEL_16;
      }
    }
    Class v15 = v2[14].isa;
    if (v15 && (uint64_t v16 = v15, v17 = *(_WORD *)(v16 + 85), v16, (v17 & 2) != 0)) {
LABEL_16:
    }
      BOOL v7 = 1;
    else {
      BOOL v7 = 0;
    }
LABEL_17:

    goto LABEL_18;
  }
  BOOL v7 = 1;
LABEL_18:

  return v7;
}

void sub_183115434(_Unwind_Exception *a1)
{
  objc_sync_exit(v1);
  _Unwind_Resume(a1);
}

nw_path_status_t nw_path_get_status(nw_path_t path)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (v1)
  {
    nw_path_status_t isa = (nw_path_status_t)v1[47].isa;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_path_get_status";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_get_status";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_path_get_status";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_get_status";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_get_status";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_path_status_t isa = nw_path_status_invalid;
LABEL_3:

  return isa;
}

void ___ZL36nw_listener_handle_new_path_on_queueP22NWConcrete_nw_listenerPU21objcproto10OS_nw_path8NSObject_block_invoke(uint64_t a1)
{
}

void nw_listener_clear_trigger_agents_on_queue(NWConcrete_nw_listener *a1)
{
  id v4 = a1;
  nw_context_assert_queue(*((void **)v4 + 3));
  nw_path_t v1 = (void *)*((void *)v4 + 23);
  *((void *)v4 + 23) = 0;

  nw_path_t v2 = (void *)*((void *)v4 + 24);
  *((void *)v4 + 24) = 0;

  id v3 = (void *)*((void *)v4 + 25);
  *((void *)v4 + 25) = 0;
}

void sub_18311577C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void sub_1831157F0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_context;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void nw_context_dealloc(NWConcrete_nw_context *a1, int a2)
{
  uint64_t v76 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3 || *((_DWORD *)v3 + 31) != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      id v69 = "nw_context_dealloc";
      __int16 v70 = 2114;
      __uint64_t v71 = (__uint64_t)v4;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_INFO, "%{public}s Deallocating context %{public}@", buf, 0x16u);
    }
  }
  __uint64_t v67 = 0;
  pthread_threadid_np(0, &v67);
  if (*((_DWORD *)v4 + 30) == 4)
  {
    __uint64_t v43 = 0;
    atomic_compare_exchange_strong((atomic_ullong *volatile)v4 + 14, &v43, v67);
    if (v43)
    {
      char v44 = __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      id v69 = "nw_context_dealloc";
      __int16 v70 = 2048;
      __uint64_t v71 = v67;
      __int16 v72 = 2048;
      __uint64_t v62 = v43;
      __uint64_t v73 = v43;
      uint64_t v45 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v65 = 0;
      if (__nwlog_fault(v45, &type, &v65))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v46 = __nwlog_obj();
          os_log_type_t v47 = type;
          if (os_log_type_enabled(v46, type))
          {
            *(_DWORD *)buf = 136446722;
            id v69 = "nw_context_dealloc";
            __int16 v70 = 2048;
            __uint64_t v71 = v67;
            __int16 v72 = 2048;
            __uint64_t v73 = v62;
            _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu", buf, 0x20u);
          }
        }
        else if (v65)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v46 = __nwlog_obj();
          os_log_type_t v55 = type;
          BOOL v56 = os_log_type_enabled(v46, type);
          if (backtrace_string)
          {
            if (v56)
            {
              *(_DWORD *)buf = 136446978;
              id v69 = "nw_context_dealloc";
              __int16 v70 = 2048;
              __uint64_t v71 = v67;
              __int16 v72 = 2048;
              __uint64_t v73 = v62;
              __int16 v74 = 2082;
              long long v75 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v46, v55, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(backtrace_string);
            goto LABEL_99;
          }
          if (v56)
          {
            *(_DWORD *)buf = 136446722;
            id v69 = "nw_context_dealloc";
            __int16 v70 = 2048;
            __uint64_t v71 = v67;
            __int16 v72 = 2048;
            __uint64_t v73 = v62;
            _os_log_impl(&dword_1830D4000, v46, v55, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          os_log_type_t v46 = __nwlog_obj();
          os_log_type_t v60 = type;
          if (os_log_type_enabled(v46, type))
          {
            *(_DWORD *)buf = 136446722;
            id v69 = "nw_context_dealloc";
            __int16 v70 = 2048;
            __uint64_t v71 = v67;
            __int16 v72 = 2048;
            __uint64_t v73 = v62;
            _os_log_impl(&dword_1830D4000, v46, v60, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
LABEL_99:
      if (v45) {
        free(v45);
      }
    }
  }
  __int16 v6 = (void *)*((void *)v4 + 5);
  if (v6)
  {
    BOOL v7 = v6;
    os_log_type_t v8 = v7;
    if ((v7[136] & 8) != 0)
    {
      nw_context_purge_all_endpoints(v7);
    }
    else
    {
      v63[0] = MEMORY[0x1E4F143A8];
      v63[1] = 3221225472;
      v63[2] = ___ZL18nw_context_deallocP21NWConcrete_nw_contextb_block_invoke;
      v63[3] = &unk_1E524BAA8;
      os_log_type_t v64 = v7;
      nw_queue_context_async(v64, v63);
    }
    if (a2)
    {
      uint64_t v9 = v8[4];
      if (v9)
      {
        uint64_t v10 = *(void *)(v9 + 68);
        if (v10)
        {
          nw_path_release_globals(v10, 0);
          uint64_t v9 = v8[4];
          BOOL v11 = *(void **)(v9 + 68);
          if (v11)
          {
            free(v11);
            *(void *)(v8[4] + 68) = 0;
            uint64_t v9 = v8[4];
          }
        }
        os_log_type_t v12 = *(void **)(v9 + 180);
        if (v12)
        {
          nw_mem_buffer_manager_close(v12);
          *(void *)(v8[4] + 180) = 0;
          uint64_t v9 = v8[4];
        }
        char v13 = *(void **)(v9 + 172);
        if (v13)
        {
          nw_mem_buffer_manager_close(v13);
          *(void *)(v8[4] + 172) = 0;
          uint64_t v9 = v8[4];
        }
        __int16 v14 = *(void **)(v9 + 164);
        if (v14)
        {
          nw_mem_buffer_manager_close(v14);
          *(void *)(v8[4] + 164) = 0;
          uint64_t v9 = v8[4];
        }
        Class v15 = *(void **)(v9 + 156);
        if (v15)
        {
          nw_mem_buffer_manager_close(v15);
          *(void *)(v8[4] + 156) = 0;
          uint64_t v9 = v8[4];
        }
        uint64_t v16 = *(void **)(v9 + 148);
        if (v16)
        {
          nw_mem_buffer_manager_close(v16);
          *(void *)(v8[4] + 148) = 0;
        }
      }
    }
  }
  __int16 v17 = v4;
  uint64_t v18 = *((void *)v17 + 3);
  if (v18)
  {
    if (*(void *)(v18 + 56))
    {
      nw_queue_cancel_source(*(void *)(v18 + 56));
      *(void *)(*((void *)v17 + 3) + 56) = 0;
      uint64_t v18 = *((void *)v17 + 3);
    }
    if (*(void *)(v18 + 32))
    {
      _nw_hash_table_release(*(os_unfair_lock_s **)(v18 + 32));
      *(void *)(*((void *)v17 + 3) + 32) = 0;
      uint64_t v18 = *((void *)v17 + 3);
    }
    if (*(void *)(v18 + 40))
    {
      _nw_hash_table_release(*(os_unfair_lock_s **)(v18 + 40));
      *(void *)(*((void *)v17 + 3) + 40) = 0;
      uint64_t v18 = *((void *)v17 + 3);
    }
    if (!*(void *)(v18 + 48)
      || (_nw_hash_table_release(*(os_unfair_lock_s **)(v18 + 48)),
          *(void *)(*((void *)v17 + 3) + 48) = 0,
          (uint64_t v18 = *((void *)v17 + 3)) != 0))
    {
      free((void *)v18);
      *((void *)v17 + 3) = 0;
    }
  }

  uint64_t v19 = v17;
  uint64_t v20 = *((void *)v19 + 4);
  if (v20)
  {
    unsigned int v21 = *(void **)(v20 + 84);
    *(void *)(v20 + 84) = 0;

    uint64_t v23 = (char *)v19 + 32;
    uint64_t v22 = *((void *)v19 + 4);
    os_log_type_t v24 = *(void **)(v22 + 92);
    *(void *)(v22 + 92) = 0;

    BOOL v25 = *(void **)(*((void *)v19 + 4) + 100);
    *(void *)(*(void *)v23 + 100) = 0;

    os_log_type_t v26 = *(void **)(*((void *)v19 + 4) + 108);
    *(void *)(*(void *)v23 + 108) = 0;

    char v27 = *(void **)(*((void *)v19 + 4) + 116);
    *(void *)(*(void *)v23 + 116) = 0;

    int v28 = *(void **)(*((void *)v19 + 4) + 124);
    *(void *)(*(void *)v23 + 124) = 0;

    uint64_t v29 = *((void *)v19 + 4);
    if (*(void *)v29)
    {
      nw_queue_cancel_source(*(void *)v29);
      **((void **)v19 + 4) = 0;
      uint64_t v29 = *((void *)v19 + 4);
    }
    BOOL v30 = *(os_unfair_lock_s **)(v29 + 24);
    if (v30)
    {
      _nw_hash_table_release(v30);
      *(void *)(*((void *)v19 + 4) + 24) = 0;
      uint64_t v29 = *((void *)v19 + 4);
    }
    __int16 v31 = *(char **)(v29 + 52);
    if (v31)
    {
      nw_hash_table_apply(v31, (uint64_t)&__block_literal_global_122);
      uint64_t v29 = *((void *)v19 + 4);
      BOOL v32 = *(os_unfair_lock_s **)(v29 + 52);
      if (v32)
      {
        _nw_hash_table_release(v32);
        *(void *)(*((void *)v19 + 4) + 52) = 0;
        uint64_t v29 = *((void *)v19 + 4);
      }
    }
    uint64_t v33 = *(void *)(v29 + 60);
    if (v33)
    {
      if (*(void *)v33)
      {
        os_release(*(void **)v33);
        *(void *)uint64_t v33 = 0;
      }
      os_log_type_t v34 = *(void **)(v33 + 8);
      if (v34)
      {
        os_release(v34);
        *(void *)(v33 + 8) = 0;
      }
      uint64_t v29 = *((void *)v19 + 4);
      __int16 v35 = *(void **)(v29 + 60);
      if (v35)
      {
        free(v35);
        *(void *)(*((void *)v19 + 4) + 60) = 0;
        uint64_t v29 = *((void *)v19 + 4);
      }
    }
    uint64_t v36 = *(void *)(v29 + 68);
    if (v36)
    {
      nw_path_release_globals(v36, 0);
      uint64_t v29 = *((void *)v19 + 4);
      id v37 = *(void **)(v29 + 68);
      if (v37)
      {
        free(v37);
        *(void *)(*((void *)v19 + 4) + 68) = 0;
        uint64_t v29 = *((void *)v19 + 4);
      }
    }
    uint16x4_t v38 = *(void **)(v29 + 180);
    if (v38)
    {
      nw_mem_buffer_manager_close(v38);
      *(void *)(*((void *)v19 + 4) + 180) = 0;
      uint64_t v29 = *((void *)v19 + 4);
    }
    int v39 = *(void **)(v29 + 172);
    if (v39)
    {
      nw_mem_buffer_manager_close(v39);
      *(void *)(*((void *)v19 + 4) + 172) = 0;
      uint64_t v29 = *((void *)v19 + 4);
    }
    unint64_t v40 = *(void **)(v29 + 164);
    if (v40)
    {
      nw_mem_buffer_manager_close(v40);
      *(void *)(*((void *)v19 + 4) + 164) = 0;
      uint64_t v29 = *((void *)v19 + 4);
    }
    unint64_t v41 = *(void **)(v29 + 156);
    if (v41)
    {
      nw_mem_buffer_manager_close(v41);
      *(void *)(*((void *)v19 + 4) + 156) = 0;
      uint64_t v29 = *((void *)v19 + 4);
    }
    os_log_type_t v42 = *(void **)(v29 + 148);
    if (!v42
      || (nw_mem_buffer_manager_close(v42),
          *(void *)(*((void *)v19 + 4) + 148) = 0,
          (uint64_t v29 = *((void *)v19 + 4)) != 0))
    {

      free((void *)v29);
      *((void *)v19 + 4) = 0;
    }
  }

  if ((*((unsigned char *)v19 + 136) & 8) != 0)
  {
    __uint64_t v48 = v67;
    __uint64_t v49 = v67;
    atomic_compare_exchange_strong((atomic_ullong *volatile)v19 + 14, &v49, 0);
    if (v49 != v48)
    {
      __int16 v50 = __nwlog_obj();
      *(_DWORD *)buf = 136446722;
      id v69 = "nw_context_dealloc";
      __int16 v70 = 2048;
      __uint64_t v71 = v67;
      __int16 v72 = 2048;
      __uint64_t v73 = v49;
      os_log_type_t v51 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v65 = 0;
      if (__nwlog_fault(v51, &type, &v65))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          Class v52 = __nwlog_obj();
          os_log_type_t v53 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446722;
            id v69 = "nw_context_dealloc";
            __int16 v70 = 2048;
            __uint64_t v71 = v67;
            __int16 v72 = 2048;
            __uint64_t v73 = v49;
            _os_log_impl(&dword_1830D4000, v52, v53, "%{public}s Exiting call, expected inline TID to be %llu but got %llu", buf, 0x20u);
          }
        }
        else if (v65)
        {
          Class v57 = (char *)__nw_create_backtrace_string();
          Class v52 = __nwlog_obj();
          os_log_type_t v58 = type;
          BOOL v59 = os_log_type_enabled(v52, type);
          if (v57)
          {
            if (v59)
            {
              *(_DWORD *)buf = 136446978;
              id v69 = "nw_context_dealloc";
              __int16 v70 = 2048;
              __uint64_t v71 = v67;
              __int16 v72 = 2048;
              __uint64_t v73 = v49;
              __int16 v74 = 2082;
              long long v75 = v57;
              _os_log_impl(&dword_1830D4000, v52, v58, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v57);
            goto LABEL_104;
          }
          if (v59)
          {
            *(_DWORD *)buf = 136446722;
            id v69 = "nw_context_dealloc";
            __int16 v70 = 2048;
            __uint64_t v71 = v67;
            __int16 v72 = 2048;
            __uint64_t v73 = v49;
            _os_log_impl(&dword_1830D4000, v52, v58, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          Class v52 = __nwlog_obj();
          os_log_type_t v61 = type;
          if (os_log_type_enabled(v52, type))
          {
            *(_DWORD *)buf = 136446722;
            id v69 = "nw_context_dealloc";
            __int16 v70 = 2048;
            __uint64_t v71 = v67;
            __int16 v72 = 2048;
            __uint64_t v73 = v49;
            _os_log_impl(&dword_1830D4000, v52, v61, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
LABEL_104:
      if (v51) {
        free(v51);
      }
    }
  }
}

void sub_183116254(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_should_run_probe_locked(NWConcrete_nw_connection *a1)
{
  *(void *)&v38[5] = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    BOOL v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v36 = "nw_connection_should_run_probe_locked";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v33 = 0;
    if (__nwlog_fault(v26, &type, &v33))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_connection_should_run_probe_locked";
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v33)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v27 = __nwlog_obj();
        os_log_type_t v30 = type;
        BOOL v31 = os_log_type_enabled(v27, type);
        if (backtrace_string)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v36 = "nw_connection_should_run_probe_locked";
            __int16 v37 = 2082;
            *(void *)uint16x4_t v38 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_78;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_connection_should_run_probe_locked";
          _os_log_impl(&dword_1830D4000, v27, v30, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v27 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v27, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v36 = "nw_connection_should_run_probe_locked";
          _os_log_impl(&dword_1830D4000, v27, v32, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_78:
    if (v26) {
      free(v26);
    }
    goto LABEL_51;
  }
  if (nw_parameters_get_is_probe(v1->parameters))
  {
    parameters = v2->parameters;
    if (!parameters || nw_path_parameters_get_logging_disabled(*((void *)parameters + 13))) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int top_id = v2->top_id;
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)uint16x4_t v38 = top_id;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a probe", buf, 0x12u);
    }
LABEL_50:

LABEL_51:
    BOOL v19 = 0;
    goto LABEL_52;
  }
  if (nw_context_is_inline(v2->context))
  {
    __int16 v6 = v2->parameters;
    if (!v6 || nw_path_parameters_get_logging_disabled(*((void *)v6 + 13))) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v7 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)uint16x4_t v38 = v7;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing when context is inline", buf, 0x12u);
    }
    goto LABEL_50;
  }
  os_log_type_t v8 = (uint64_t *)v2->parameters;
  if (v2->state == 5)
  {
    if (!v8 || nw_path_parameters_get_logging_disabled(v8[13])) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v9 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)uint16x4_t v38 = v9;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a cancelled connection", buf, 0x12u);
    }
    goto LABEL_50;
  }
  if (nw_parameters_get_data_mode(v8) != 2 && nw_parameters_get_data_mode(v2->parameters))
  {
    uint64_t v10 = v2->parameters;
    if (!v10 || nw_path_parameters_get_logging_disabled(*((void *)v10 + 13))) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v11 = v2->top_id;
      data_uint64_t mode = nw_parameters_get_data_mode(v2->parameters);
      *(_DWORD *)buf = 136446722;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)uint16x4_t v38 = v11;
      void v38[2] = 1024;
      *(_DWORD *)&v38[3] = data_mode;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a connection that was specified yet not streaming: %d", buf, 0x18u);
    }
    goto LABEL_50;
  }
  server_uint64_t mode = nw_parameters_get_server_mode(v2->parameters);
  __int16 v14 = (uint64_t *)v2->parameters;
  if (server_mode)
  {
    if (!v14 || nw_path_parameters_get_logging_disabled(v14[13])) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v15 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)uint16x4_t v38 = v15;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a connection that was not a client", buf, 0x12u);
    }
    goto LABEL_50;
  }
  int https_proxy_over_tls = nw_parameters_get_https_proxy_over_tls(v14);
  __int16 v17 = (uint64_t *)v2->parameters;
  if (https_proxy_over_tls)
  {
    if (!v17 || nw_path_parameters_get_logging_disabled(v17[13])) {
      goto LABEL_51;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      unsigned int v18 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      uint64_t v36 = "nw_connection_should_run_probe_locked";
      __int16 v37 = 1024;
      *(_DWORD *)uint16x4_t v38 = v18;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a connection for an HTTPS proxy over TLS", buf, 0x12u);
    }
    goto LABEL_50;
  }
  unsigned int v21 = v17;
  BOOL v19 = v21 != 0;
  if (!v21)
  {
    uint64_t v22 = v2->parameters;
    if (v22)
    {
      if (!nw_path_parameters_get_logging_disabled(*((void *)v22 + 13)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v23 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          unsigned int v24 = v2->top_id;
          *(_DWORD *)buf = 136446466;
          uint64_t v36 = "nw_connection_should_run_probe_locked";
          __int16 v37 = 1024;
          *(_DWORD *)uint16x4_t v38 = v24;
          _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Not probing a connection for which we cannot get the parameters", buf, 0x12u);
        }
      }
    }
  }

LABEL_52:
  return v19;
}

void sub_183116A94(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_server_mode(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[97] >> 7;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_parameters_get_server_mode";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_server_mode";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_parameters_get_server_mode";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_server_mode";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_server_mode";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_data_mode(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_parameters_get_data_mode";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v16 = "nw_parameters_get_data_mode";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v6 = (id)gLogObj;
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v16 = "nw_parameters_get_data_mode";
            __int16 v17 = 2082;
            unsigned int v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v5) {
            goto LABEL_10;
          }
          goto LABEL_9;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v16 = "nw_parameters_get_data_mode";
          _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v6 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v16 = "nw_parameters_get_data_mode";
          _os_log_impl(&dword_1830D4000, v6, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v5)
    {
LABEL_10:
      uint64_t v3 = 0;
      goto LABEL_11;
    }
LABEL_9:
    free(v5);
    goto LABEL_10;
  }
  uint64_t v3 = v1[92];
LABEL_11:

  return v3;
}

uint64_t nw_parameters_get_https_proxy_over_tls(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[98] >> 5) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_parameters_get_https_proxy_over_tls";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_parameters_get_https_proxy_over_tls";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_parameters_get_https_proxy_over_tls";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void sub_1831179F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_queue_context_async_if_needed(void *a1, void *a2)
{
  id v5 = a1;
  uint64_t v3 = a2;
  if (nw_context_is_inline(v5))
  {
    v3[2](v3);
  }
  else
  {
    BOOL v4 = nw_context_copy_workloop(v5);
    if (dispatch_workloop_is_current()) {
      v3[2](v3);
    }
    else {
      dispatch_async((dispatch_queue_t)v4, v3);
    }
  }
}

void sub_183117B0C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void nw_release(void *obj)
{
  if (obj) {
    os_release(obj);
  }
}

void nw_queue_context_async(void *a1, void *a2)
{
  id v5 = a1;
  id v3 = a2;
  if (nw_context_is_inline(v5))
  {
    nw_context_queue_block(v5, v3);
  }
  else
  {
    BOOL v4 = nw_context_copy_workloop(v5);
    dispatch_async((dispatch_queue_t)v4, v3);
  }
}

void sub_183117BC4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

BOOL nw_queue_context_create_source(void *a1, int a2, int a3, unsigned int a4, void *a5, void *a6)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  id v12 = a1;
  id v13 = a5;
  id v14 = a6;
  if (a2 == -1)
  {
    uint64_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __uint64_t v62 = "nw_queue_context_create_source";
    unsigned int v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v21, &type, &v59)) {
      goto LABEL_79;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __uint64_t v62 = "nw_queue_context_create_source";
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null (fd != -1)", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (!v59)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v53 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __uint64_t v62 = "nw_queue_context_create_source";
        _os_log_impl(&dword_1830D4000, v22, v53, "%{public}s called with null (fd != -1), backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v49 = type;
    BOOL v50 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        __uint64_t v62 = "nw_queue_context_create_source";
        _os_log_impl(&dword_1830D4000, v22, v49, "%{public}s called with null (fd != -1), no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v50)
    {
      *(_DWORD *)buf = 136446466;
      __uint64_t v62 = "nw_queue_context_create_source";
      __int16 v63 = 2082;
      uint64_t v64 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v22, v49, "%{public}s called with null (fd != -1), dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_66;
  }
  if (!v13)
  {
    unsigned int v24 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __uint64_t v62 = "nw_queue_context_create_source";
    unsigned int v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v59 = 0;
    if (!__nwlog_fault(v21, &type, &v59)) {
      goto LABEL_79;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __uint64_t v62 = "nw_queue_context_create_source";
        _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null block", buf, 0xCu);
      }
LABEL_78:

LABEL_79:
      if (v21) {
        free(v21);
      }
      goto LABEL_18;
    }
    if (!v59)
    {
      uint64_t v22 = __nwlog_obj();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        __uint64_t v62 = "nw_queue_context_create_source";
        _os_log_impl(&dword_1830D4000, v22, v54, "%{public}s called with null block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_78;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v22 = __nwlog_obj();
    os_log_type_t v51 = type;
    BOOL v52 = os_log_type_enabled(v22, type);
    if (!backtrace_string)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        __uint64_t v62 = "nw_queue_context_create_source";
        _os_log_impl(&dword_1830D4000, v22, v51, "%{public}s called with null block, no backtrace", buf, 0xCu);
      }
      goto LABEL_78;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      __uint64_t v62 = "nw_queue_context_create_source";
      __int16 v63 = 2082;
      uint64_t v64 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v22, v51, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_66:

    free(backtrace_string);
    goto LABEL_79;
  }
  if (a3 == 1)
  {
    unsigned int v15 = (const dispatch_source_type_s *)MEMORY[0x1E4F14478];
    goto LABEL_11;
  }
  if (a3 == 2)
  {
    unsigned int v15 = (const dispatch_source_type_s *)MEMORY[0x1E4F144B0];
    goto LABEL_11;
  }
  if ((a3 & 0xFFFFFFFB) == 3)
  {
    unsigned int v15 = (const dispatch_source_type_s *)MEMORY[0x1E4F14490];
    goto LABEL_11;
  }
  if ((a3 - 4) >= 3)
  {
    uint64_t v18 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init(v18);
    uint64_t v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      __uint64_t v62 = "nw_queue_context_create_source";
      __int16 v63 = 1024;
      LODWORD(v64) = a3;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s Bad source type %d", buf, 0x12u);
    }

LABEL_18:
    uint64_t v16 = 0;
LABEL_55:

    return (BOOL)v16;
  }
  unsigned int v15 = (const dispatch_source_type_s *)qword_1E5247AB0[a3 - 4];
LABEL_11:
  uint64_t v16 = (id *)malloc_type_calloc(1uLL, 0x38uLL, 0xEAFB8F1AuLL);
  if (v16)
  {
    if (v12)
    {
LABEL_13:
      if (nw_context_is_inline(v12))
      {
        objc_storeStrong(v16 + 1, a1);
        char v44 = _Block_copy(v13);
        id v45 = v16[2];
        v16[2] = v44;

        os_log_type_t v46 = _Block_copy(v14);
        id v47 = v16[3];
        v16[3] = v46;

        *((unsigned char *)v16 + 48) = a3 == 3;
        v16[4] = (id)-1;
        v16[5] = (id)-1;
        goto LABEL_55;
      }
      uint64_t v17 = nw_context_copy_workloop(v12);
LABEL_32:
      os_log_type_t v28 = (void *)v17;
      dispatch_source_t v29 = dispatch_source_create(v15, a2, a4, (dispatch_queue_t)v17);
      dispatch_source_t v30 = (dispatch_source_t)*v16;
      *uint64_t v16 = v29;

      if (*v16)
      {
        dispatch_source_set_event_handler((dispatch_source_t)*v16, v13);
        BOOL v31 = *v16;
        handler[0] = MEMORY[0x1E4F143A8];
        handler[1] = 3221225472;
        handler[2] = __nw_queue_context_create_source_block_invoke;
        handler[3] = &unk_1E5249D98;
        id v57 = v14;
        os_log_type_t v58 = v16;
        dispatch_source_set_cancel_handler(v31, handler);

LABEL_54:
        goto LABEL_55;
      }
      free(v16);
      uint64_t v32 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v32);
      id v33 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      __uint64_t v62 = "nw_queue_context_create_source";
      os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v59 = 0;
      if (__nwlog_fault(v34, &type, &v59))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v35 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v35);
          uint64_t v36 = (id)gLogObj;
          os_log_type_t v37 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            __uint64_t v62 = "nw_queue_context_create_source";
            _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s dispatch_source_create failed", buf, 0xCu);
          }
        }
        else if (v59)
        {
          uint16x4_t v38 = (char *)__nw_create_backtrace_string();
          uint64_t v39 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v39);
          uint64_t v36 = (id)gLogObj;
          os_log_type_t v40 = type;
          BOOL v41 = os_log_type_enabled(v36, type);
          if (v38)
          {
            if (v41)
            {
              *(_DWORD *)buf = 136446466;
              __uint64_t v62 = "nw_queue_context_create_source";
              __int16 v63 = 2082;
              uint64_t v64 = (uint64_t)v38;
              _os_log_impl(&dword_1830D4000, v36, v40, "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v38);
            if (!v34) {
              goto LABEL_53;
            }
            goto LABEL_52;
          }
          if (v41)
          {
            *(_DWORD *)buf = 136446210;
            __uint64_t v62 = "nw_queue_context_create_source";
            _os_log_impl(&dword_1830D4000, v36, v40, "%{public}s dispatch_source_create failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v42 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v42);
          uint64_t v36 = (id)gLogObj;
          os_log_type_t v43 = type;
          if (os_log_type_enabled(v36, type))
          {
            *(_DWORD *)buf = 136446210;
            __uint64_t v62 = "nw_queue_context_create_source";
            _os_log_impl(&dword_1830D4000, v36, v43, "%{public}s dispatch_source_create failed, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v34)
      {
LABEL_53:
        uint64_t v16 = 0;
        goto LABEL_54;
      }
LABEL_52:
      free(v34);
      goto LABEL_53;
    }
LABEL_31:
    uint64_t v17 = dispatch_workloop_copy_current();
    goto LABEL_32;
  }
  os_log_type_t v55 = __nwlog_obj();
  os_log_type_enabled(v55, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  __uint64_t v62 = "strict_calloc";
  __int16 v63 = 2048;
  uint64_t v64 = 1;
  __int16 v65 = 2048;
  uint64_t v66 = 56;
  os_log_type_t v26 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    if (v12) {
      goto LABEL_13;
    }
    goto LABEL_31;
  }
  __break(1u);
  return result;
}

void sub_1831185F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_is_inline(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    unsigned int v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_context_is_inline";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v10, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_context_is_inline";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_context_is_inline";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_context_is_inline";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_context_is_inline";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v10) {
      free(v10);
    }
    uint64_t v8 = 0;
    goto LABEL_6;
  }
  unsigned int v3 = v1[136];
  if ((v3 & 0x40) != 0)
  {
LABEL_5:
    uint64_t v8 = (v3 >> 3) & 1;
LABEL_6:

    return v8;
  }
  uint64_t v4 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v4);
  id v5 = (id)gLogObj;
  os_log_type_enabled(v5, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_context_is_inline";
  __int16 v6 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v6);
  if (!result)
  {
    free(v6);
    unsigned int v3 = v2[136];
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

BOOL nw_context_copy_workloop(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  nw_path_t v2 = v1;
  if (!v1)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_context_copy_workloop";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v24 = "nw_context_copy_workloop";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null context", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v21)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v24 = "nw_context_copy_workloop";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v24 = "nw_context_copy_workloop";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v24 = "nw_context_copy_workloop";
        __int16 v25 = 2082;
        os_log_type_t v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
LABEL_40:
    if (v9) {
      free(v9);
    }
    id v7 = 0;
    goto LABEL_7;
  }
  if (((_BYTE)v1[17] & 8) != 0)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v24 = "nw_context_copy_workloop";
    unsigned int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v24 = "nw_context_copy_workloop";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null !context->is_inline", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v21)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v24 = "nw_context_copy_workloop";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null !context->is_inline, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          unsigned int v24 = "nw_context_copy_workloop";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null !context->is_inline, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        unsigned int v24 = "nw_context_copy_workloop";
        __int16 v25 = 2082;
        os_log_type_t v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null !context->is_inline, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
    goto LABEL_40;
  }
  if (((_BYTE)v1[17] & 0x40) != 0)
  {
LABEL_6:
    id v7 = v2[1];
LABEL_7:

    return (BOOL)v7;
  }
  uint64_t v3 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v3);
  uint64_t v4 = (id)gLogObj;
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  unsigned int v24 = "nw_context_copy_workloop";
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
    goto LABEL_6;
  }
  __break(1u);
  return result;
}

uint64_t nw_parameters_get_pid(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned int *)(*((void *)v1 + 13) + 64);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_pid";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_pid";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_pid";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_effective_bundle_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_path_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 14);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_effective_bundle_id";
  __int16 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_effective_bundle_id";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_effective_bundle_id";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_endpoint_handler_get_next_top_id()
{
  uint64_t v7 = *MEMORY[0x1E4F143B8];
  unsigned int add = atomic_fetch_add(nw_endpoint_handler_get_next_top_id::s_last_top_level_id, 1u);
  uint64_t result = add + 1;
  if (add == -1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_path_t v2 = (id)gLogObj;
    if (os_log_type_enabled(v2, OS_LOG_TYPE_ERROR))
    {
      int v3 = 136446466;
      uint64_t v4 = "nw_endpoint_handler_get_next_top_id";
      __int16 v5 = 1024;
      int v6 = 0;
      _os_log_impl(&dword_1830D4000, v2, OS_LOG_TYPE_ERROR, "%{public}s reached %u endpoint top ids, wrapping", (uint8_t *)&v3, 0x12u);
    }

    return nw_endpoint_handler_get_next_top_id();
  }
  return result;
}

void __nw_context_purge_all_endpoints_block_invoke(uint64_t a1)
{
}

void nw_parameters_set_no_cellular_fallback(void *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = *((void *)v3 + 13);
    int v7 = *(unsigned __int16 *)(v5 + 108);
    uint64_t v6 = v5 + 108;
    int v8 = v7 | (*(unsigned __int8 *)(v6 + 2) << 16);
    if (a2) {
      __int16 v9 = 64;
    }
    else {
      __int16 v9 = 0;
    }
    unsigned int v10 = v8 & 0xFFFFFFBF;
    *(_WORD *)uint64_t v6 = v10 | v9;
    *(unsigned char *)(v6 + 2) = BYTE2(v10);
    goto LABEL_6;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v22 = "nw_parameters_set_no_cellular_fallback";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_parameters_set_no_cellular_fallback";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v22 = "nw_parameters_set_no_cellular_fallback";
          __int16 v23 = 2082;
          unsigned int v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_parameters_set_no_cellular_fallback";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v22 = "nw_parameters_set_no_cellular_fallback";
        _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v12) {
    free(v12);
  }
LABEL_6:
}

void ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_2(uint64_t a1)
{
}

void sub_1831199E0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, objc_super a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Block_object_dispose((const void *)(v19 - 80), 8);
  a11.super_class = (Class)NWConcrete_nw_association;
  [(_Unwind_Exception *)&a11 dealloc];
  _Unwind_Resume(a1);
}

void nw_association_mark_flow_connected(void *a1, void *a2)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    BOOL v56 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __uint64_t v71 = "nw_association_mark_flow_connected";
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v57 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          __uint64_t v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_1830D4000, v16, v57, "%{public}s called with null association", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v68 == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v65 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          __uint64_t v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_1830D4000, v16, v65, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_89;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v61 = type;
      BOOL v62 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          __uint64_t v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_1830D4000, v16, v61, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v62)
      {
        *(_DWORD *)buf = 136446466;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v16, v61, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    goto LABEL_90;
  }
  if (!v4)
  {
    os_log_type_t v58 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __uint64_t v71 = "nw_association_mark_flow_connected";
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v59 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          __uint64_t v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_1830D4000, v16, v59, "%{public}s called with null handle", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v68 == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v16 = __nwlog_obj();
        os_log_type_t v66 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          __uint64_t v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_1830D4000, v16, v66, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_89;
      }
      unsigned int v24 = (char *)__nw_create_backtrace_string();
      os_log_type_t v16 = __nwlog_obj();
      os_log_type_t v63 = type;
      BOOL v64 = os_log_type_enabled(v16, type);
      if (!v24)
      {
        if (v64)
        {
          *(_DWORD *)buf = 136446210;
          __uint64_t v71 = "nw_association_mark_flow_connected";
          _os_log_impl(&dword_1830D4000, v16, v63, "%{public}s called with null handle, no backtrace", buf, 0xCu);
        }
        goto LABEL_89;
      }
      if (v64)
      {
        *(_DWORD *)buf = 136446466;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = v24;
        _os_log_impl(&dword_1830D4000, v16, v63, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_60;
    }
LABEL_90:
    if (!v15) {
      goto LABEL_93;
    }
    goto LABEL_91;
  }
  id v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);

  uint64_t v7 = *((void *)v3 + 5);
  if (!v7)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_93;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v13 = (id)gconnectionLogObj;
    logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446466;
    __uint64_t v71 = "nw_association_mark_flow_connected";
    __int16 v72 = 2082;
    __uint64_t v73 = (void *)logging_description;
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &type, &v68)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        os_log_type_t v18 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v18;
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s <nw_association %{public}s> does not have a handle hash table", buf, 0x16u);
      }
      goto LABEL_89;
    }
    if (v68 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v16, type))
      {
        uint64_t v39 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v39;
        _os_log_impl(&dword_1830D4000, v16, v38, "%{public}s <nw_association %{public}s> does not have a handle hash table, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_89;
    }
    __int16 v23 = __nw_create_backtrace_string();
    if (!v23)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      os_log_type_t v40 = type;
      if (os_log_type_enabled(v16, type))
      {
        BOOL v41 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446466;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v41;
        _os_log_impl(&dword_1830D4000, v16, v40, "%{public}s <nw_association %{public}s> does not have a handle hash table, no backtrace", buf, 0x16u);
      }
      goto LABEL_89;
    }
    unsigned int v24 = (char *)v23;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v16 = (id)gconnectionLogObj;
    os_log_type_t v25 = type;
    if (os_log_type_enabled(v16, type))
    {
      os_log_type_t v26 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446722;
      __uint64_t v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      __uint64_t v73 = (void *)v26;
      __int16 v74 = 2082;
      long long v75 = v24;
      _os_log_impl(&dword_1830D4000, v16, v25, "%{public}s <nw_association %{public}s> does not have a handle hash table, dumping backtrace:%{public}s", buf, 0x20u);
    }
    goto LABEL_60;
  }
  BOOL node = nw_hash_table_get_node(v7, (uint64_t)v5, 0);
  if (!node)
  {
    if (nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
      goto LABEL_93;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v19 = (id)gconnectionLogObj;
    os_log_type_t v20 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136446722;
    __uint64_t v71 = "nw_association_mark_flow_connected";
    __int16 v72 = 2082;
    __uint64_t v73 = (void *)v20;
    __int16 v74 = 2048;
    long long v75 = v5;
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v68 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v15, &type, &v68)) {
      goto LABEL_90;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v16, type))
      {
        uint64_t v22 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v22;
        __int16 v74 = 2048;
        long long v75 = v5;
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s <nw_association %{public}s> does not have handle %p registered", buf, 0x20u);
      }
LABEL_89:

      goto LABEL_90;
    }
    if (v68 == OS_LOG_TYPE_DEFAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v16, type))
      {
        os_log_type_t v43 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v43;
        __int16 v74 = 2048;
        long long v75 = v5;
        _os_log_impl(&dword_1830D4000, v16, v42, "%{public}s <nw_association %{public}s> does not have handle %p registered, backtrace limit exceeded", buf, 0x20u);
      }
      goto LABEL_89;
    }
    uint64_t v35 = __nw_create_backtrace_string();
    if (!v35)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v16, type))
      {
        BOOL v50 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v50;
        __int16 v74 = 2048;
        long long v75 = v5;
        _os_log_impl(&dword_1830D4000, v16, v49, "%{public}s <nw_association %{public}s> does not have handle %p registered, no backtrace", buf, 0x20u);
      }
      goto LABEL_89;
    }
    unsigned int v24 = (char *)v35;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v16 = (id)gconnectionLogObj;
    os_log_type_t v36 = type;
    if (os_log_type_enabled(v16, type))
    {
      os_log_type_t v37 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      __uint64_t v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      __uint64_t v73 = (void *)v37;
      __int16 v74 = 2048;
      long long v75 = v5;
      __int16 v76 = 2082;
      id v77 = v24;
      _os_log_impl(&dword_1830D4000, v16, v36, "%{public}s <nw_association %{public}s> does not have handle %p registered, dumping backtrace:%{public}s", buf, 0x2Au);
    }
LABEL_60:

    free(v24);
    if (!v15) {
      goto LABEL_93;
    }
LABEL_91:
    os_log_type_t v51 = (char *)v15;
LABEL_92:
    free(v51);
    goto LABEL_93;
  }
  BOOL v9 = node;
  uint64_t internal = *((void *)v3 + 6);
  if (!internal)
  {
    uint64_t internal = nw_hash_table_create_internal(7u, 16, (const void *(*)(const void *, unsigned int *))nw_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_association_matches_key, (void (*)(void *))nw_association_release);
    if (internal) {
      *(_DWORD *)(internal + 48) &= ~2u;
    }
    *((void *)v3 + 6) = internal;
  }
  if (nw_hash_table_get_node(internal, (uint64_t)v5, 0))
  {
    if (!nw_path_parameters_get_logging_disabled(*((void *)v3 + 2)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v12 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        __uint64_t v71 = "nw_association_mark_flow_connected";
        __int16 v72 = 2082;
        __uint64_t v73 = (void *)v12;
        __int16 v74 = 2048;
        long long v75 = v5;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s <nw_association %{public}s> already has connected flow %p registered", buf, 0x20u);
      }
    }
    goto LABEL_93;
  }
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  uint64_t v27 = *((void *)v3 + 6);
  os_log_type_t v28 = v5;
  nw_hash_table_add_object(v27, (uint64_t)v28, (char *)&type);
  if (type || nw_path_parameters_get_logging_disabled(*((void *)v3 + 2))) {
    goto LABEL_93;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  id v29 = (id)gconnectionLogObj;
  dispatch_source_t v30 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
  *(_DWORD *)buf = 136446978;
  __uint64_t v71 = "nw_association_mark_flow_connected";
  __int16 v72 = 2082;
  __uint64_t v73 = (void *)v30;
  __int16 v74 = 2048;
  long long v75 = v28;
  __int16 v76 = 2048;
  id v77 = (char *)v9;
  BOOL v31 = (const char *)_os_log_send_and_compose_impl();

  os_log_type_t v68 = OS_LOG_TYPE_ERROR;
  char v67 = 0;
  if (!__nwlog_fault(v31, &v68, &v67)) {
    goto LABEL_104;
  }
  if (v68 == OS_LOG_TYPE_FAULT)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v32 = (id)gconnectionLogObj;
    os_log_type_t v33 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      os_log_type_t v34 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      __uint64_t v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      __uint64_t v73 = (void *)v34;
      __int16 v74 = 2048;
      long long v75 = v28;
      __int16 v76 = 2048;
      id v77 = (char *)v9;
      _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p)", buf, 0x2Au);
    }
LABEL_103:

LABEL_104:
    if (!v31) {
      goto LABEL_93;
    }
    goto LABEL_105;
  }
  if (!v67)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v32 = (id)gconnectionLogObj;
    os_log_type_t v52 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      os_log_type_t v53 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      __uint64_t v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      __uint64_t v73 = (void *)v53;
      __int16 v74 = 2048;
      long long v75 = v28;
      __int16 v76 = 2048;
      id v77 = (char *)v9;
      _os_log_impl(&dword_1830D4000, v32, v52, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), backtrace limit exceeded", buf, 0x2Au);
    }
    goto LABEL_103;
  }
  char v44 = __nw_create_backtrace_string();
  if (!v44)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v32 = (id)gconnectionLogObj;
    os_log_type_t v54 = v68;
    if (os_log_type_enabled(v32, v68))
    {
      os_log_type_t v55 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
      *(_DWORD *)buf = 136446978;
      __uint64_t v71 = "nw_association_mark_flow_connected";
      __int16 v72 = 2082;
      __uint64_t v73 = (void *)v55;
      __int16 v74 = 2048;
      long long v75 = v28;
      __int16 v76 = 2048;
      id v77 = (char *)v9;
      _os_log_impl(&dword_1830D4000, v32, v54, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), no backtrace", buf, 0x2Au);
    }
    goto LABEL_103;
  }
  id v45 = (char *)v44;
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v46 = (id)gconnectionLogObj;
  os_log_type_t v47 = v68;
  if (os_log_type_enabled(v46, v68))
  {
    __uint64_t v48 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
    *(_DWORD *)buf = 136447234;
    __uint64_t v71 = "nw_association_mark_flow_connected";
    __int16 v72 = 2082;
    __uint64_t v73 = (void *)v48;
    __int16 v74 = 2048;
    long long v75 = v28;
    __int16 v76 = 2048;
    id v77 = (char *)v9;
    __int16 v78 = 2082;
    BOOL v79 = v45;
    _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s <nw_association %{public}s> failed to add new connected flow for %p (node %p), dumping backtrace:%{public}s", buf, 0x34u);
  }

  free(v45);
  if (v31)
  {
LABEL_105:
    os_log_type_t v51 = (char *)v31;
    goto LABEL_92;
  }
LABEL_93:
}

void sub_18311AAA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_association_register_internal(void *a1, void *a2, void *a3, int a4, int a5, void *a6)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  id v11 = a1;
  id v97 = a2;
  id v12 = a3;
  id v13 = a6;
  if (!v11)
  {
    __int16 v70 = v13;
    __uint64_t v71 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v102 = "nw_association_register_internal";
    __int16 v72 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v99 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v72, &type, &v99)) {
      goto LABEL_151;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      __uint64_t v73 = __nwlog_obj();
      os_log_type_t v74 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v102 = "nw_association_register_internal";
        _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null association", buf, 0xCu);
      }
      goto LABEL_141;
    }
    if (v99 == OS_LOG_TYPE_DEFAULT)
    {
      __uint64_t v73 = __nwlog_obj();
      os_log_type_t v92 = type;
      if (os_log_type_enabled(v73, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v102 = "nw_association_register_internal";
        _os_log_impl(&dword_1830D4000, v73, v92, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_141;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    id v82 = __nwlog_obj();
    os_log_type_t v83 = type;
    BOOL v84 = os_log_type_enabled(v82, type);
    if (backtrace_string)
    {
      if (v84)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v102 = "nw_association_register_internal";
        __int16 v103 = 2082;
        nw_endpoint_t v104 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
LABEL_151:
      if (!v72) {
        goto LABEL_104;
      }
LABEL_152:
      free(v72);
      goto LABEL_104;
    }
    if (v84)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v102 = "nw_association_register_internal";
      _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null association, no backtrace", buf, 0xCu);
    }
LABEL_150:

    goto LABEL_151;
  }
  if (v12)
  {
    aBlock = v13;
    if (v13)
    {
      id v14 = nw_path_parameters_copy_context(*((void **)v11 + 2));
      nw_context_assert_queue(v14);

      if (!*((void *)v11 + 5))
      {
        uint64_t internal = nw_hash_table_create_internal(7u, 16, (const void *(*)(const void *, unsigned int *))nw_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_association_matches_key, (void (*)(void *))nw_association_release);
        if (internal) {
          *(_DWORD *)(internal + 48) &= ~2u;
        }
        *((void *)v11 + 5) = internal;
      }
      nw_association_activate(v11, v97, a5, 0);
      BOOL node = nw_hash_table_get_node(*((void *)v11 + 5), (uint64_t)v12, 0);
      if (!node) {
        goto LABEL_70;
      }
      uint64_t v17 = node;
      os_log_type_t v18 = &unk_183D5C000;
      if (nw_path_parameters_get_logging_disabled(*((void *)v11 + 2))) {
        goto LABEL_39;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v19 = (id)gconnectionLogObj;
      logging_description = nw_endpoint_get_logging_description(*((void **)v11 + 1));
      *(_DWORD *)buf = 136446722;
      uint64_t v102 = "nw_association_register_internal";
      __int16 v103 = 2082;
      nw_endpoint_t v104 = (void *)logging_description;
      __int16 v105 = 2048;
      uint64_t v106 = (uint64_t)v12;
      os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v99 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v21, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v22 = (id)gconnectionLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled(v22, type))
          {
            unsigned int v24 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446722;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v24;
            __int16 v105 = 2048;
            uint64_t v106 = (uint64_t)v12;
            _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s <nw_association %{public}s> already has handle %p registered", buf, 0x20u);
          }
        }
        else if (v99)
        {
          os_log_type_t v25 = __nw_create_backtrace_string();
          if (v25)
          {
            os_log_type_t v26 = (char *)v25;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v27 = (id)gconnectionLogObj;
            os_log_type_t v28 = type;
            if (os_log_type_enabled(v27, type))
            {
              id v29 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
              *(_DWORD *)buf = 136446978;
              uint64_t v102 = "nw_association_register_internal";
              __int16 v103 = 2082;
              nw_endpoint_t v104 = (void *)v29;
              __int16 v105 = 2048;
              uint64_t v106 = (uint64_t)v12;
              __int16 v107 = 2082;
              uint64_t v108 = v26;
              _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s <nw_association %{public}s> already has handle %p registered, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v26);
            os_log_type_t v18 = (void *)&unk_183D5C000;
            if (v21) {
              goto LABEL_38;
            }
            goto LABEL_39;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v22 = (id)gconnectionLogObj;
          os_log_type_t v32 = type;
          if (os_log_type_enabled(v22, type))
          {
            os_log_type_t v33 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446722;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v33;
            __int16 v105 = 2048;
            uint64_t v106 = (uint64_t)v12;
            _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s <nw_association %{public}s> already has handle %p registered, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v22 = (id)gconnectionLogObj;
          os_log_type_t v30 = type;
          if (os_log_type_enabled(v22, type))
          {
            BOOL v31 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446722;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v31;
            __int16 v105 = 2048;
            uint64_t v106 = (uint64_t)v12;
            _os_log_impl(&dword_1830D4000, v22, v30, "%{public}s <nw_association %{public}s> already has handle %p registered, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
      os_log_type_t v18 = &unk_183D5C000;
      if (v21) {
LABEL_38:
      }
        free(v21);
LABEL_39:
      if (nw_hash_table_remove_node(*((void *)v11 + 5), v17)
        || nw_path_parameters_get_logging_disabled(*((void *)v11 + 2)))
      {
        goto LABEL_70;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v34 = (id)gconnectionLogObj;
      uint64_t v35 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
      int v95 = v18[309];
      *(_DWORD *)buf = v95;
      uint64_t v102 = "nw_association_register_internal";
      __int16 v103 = 2082;
      nw_endpoint_t v104 = (void *)v35;
      __int16 v105 = 2048;
      uint64_t v106 = v17;
      os_log_type_t v36 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      os_log_type_t v99 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v36, &type, &v99))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v37 = (id)gconnectionLogObj;
          os_log_type_t v38 = type;
          if (os_log_type_enabled(v37, type))
          {
            uint64_t v39 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = v95;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v39;
            __int16 v105 = 2048;
            uint64_t v106 = v17;
            _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s <nw_association %{public}s> failed to remove handle for node %p", buf, 0x20u);
          }
        }
        else if (v99)
        {
          os_log_type_t v40 = __nw_create_backtrace_string();
          if (v40)
          {
            BOOL v41 = (char *)v40;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v42 = (id)gconnectionLogObj;
            os_log_type_t v43 = type;
            if (os_log_type_enabled(v42, type))
            {
              char v44 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
              *(_DWORD *)buf = 136446978;
              uint64_t v102 = "nw_association_register_internal";
              __int16 v103 = 2082;
              nw_endpoint_t v104 = (void *)v44;
              __int16 v105 = 2048;
              uint64_t v106 = v17;
              __int16 v107 = 2082;
              uint64_t v108 = v41;
              _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s <nw_association %{public}s> failed to remove handle for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v41);
            if (v36) {
              goto LABEL_69;
            }
            goto LABEL_70;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v37 = (id)gconnectionLogObj;
          os_log_type_t v47 = type;
          if (os_log_type_enabled(v37, type))
          {
            __uint64_t v48 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = v95;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v48;
            __int16 v105 = 2048;
            uint64_t v106 = v17;
            _os_log_impl(&dword_1830D4000, v37, v47, "%{public}s <nw_association %{public}s> failed to remove handle for node %p, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v37 = (id)gconnectionLogObj;
          os_log_type_t v45 = type;
          if (os_log_type_enabled(v37, type))
          {
            os_log_type_t v46 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = v95;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v46;
            __int16 v105 = 2048;
            uint64_t v106 = v17;
            _os_log_impl(&dword_1830D4000, v37, v45, "%{public}s <nw_association %{public}s> failed to remove handle for node %p, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
      if (v36) {
LABEL_69:
      }
        free(v36);
LABEL_70:
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      uint64_t v49 = *((void *)v11 + 5);
      id v50 = v12;
      BOOL v51 = nw_hash_table_add_object(v49, (uint64_t)v50, (char *)&type);
      if (type || nw_path_parameters_get_logging_disabled(*((void *)v11 + 2)))
      {
LABEL_101:
        uint64_t extra = nw_hash_node_get_extra(v51);
        os_log_type_t v68 = _Block_copy(aBlock);
        id v69 = *(void **)extra;
        *(void *)uint64_t extra = v68;

        *(unsigned char *)(extra + 8) = *(unsigned char *)(extra + 8) & 0xFE | a4;
        if (a4) {
          ++*((_DWORD *)v11 + 18);
        }
LABEL_103:
        __int16 v70 = (void *)aBlock;
        goto LABEL_104;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v52 = (id)gconnectionLogObj;
      os_log_type_t v53 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
      *(_DWORD *)buf = 136446978;
      uint64_t v102 = "nw_association_register_internal";
      __int16 v103 = 2082;
      nw_endpoint_t v104 = (void *)v53;
      __int16 v105 = 2048;
      uint64_t v106 = (uint64_t)v50;
      __int16 v107 = 2048;
      uint64_t v108 = (char *)v51;
      os_log_type_t v54 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t v99 = OS_LOG_TYPE_ERROR;
      char v98 = 0;
      if (__nwlog_fault((const char *)v54, &v99, &v98))
      {
        if (v99 == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v55 = (id)gconnectionLogObj;
          os_log_type_t v56 = v99;
          if (os_log_type_enabled(v55, v99))
          {
            os_log_type_t v57 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446978;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v57;
            __int16 v105 = 2048;
            uint64_t v106 = (uint64_t)v50;
            __int16 v107 = 2048;
            uint64_t v108 = (char *)v51;
            _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p)", buf, 0x2Au);
          }
        }
        else if (v98)
        {
          os_log_type_t v58 = __nw_create_backtrace_string();
          if (v58)
          {
            os_log_type_t v59 = (char *)v58;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v60 = (id)gconnectionLogObj;
            os_log_type_t v61 = v99;
            if (os_log_type_enabled(v60, v99))
            {
              BOOL v62 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
              *(_DWORD *)buf = 136447234;
              uint64_t v102 = "nw_association_register_internal";
              __int16 v103 = 2082;
              nw_endpoint_t v104 = (void *)v62;
              __int16 v105 = 2048;
              uint64_t v106 = (uint64_t)v50;
              __int16 v107 = 2048;
              uint64_t v108 = (char *)v51;
              __int16 v109 = 2082;
              long long v110 = v59;
              _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), dumping backtrace:%{public}s", buf, 0x34u);
            }

            free(v59);
            if (!v54) {
              goto LABEL_101;
            }
LABEL_100:
            free(v54);
            goto LABEL_101;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v55 = (id)gconnectionLogObj;
          os_log_type_t v65 = v99;
          if (os_log_type_enabled(v55, v99))
          {
            os_log_type_t v66 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446978;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v66;
            __int16 v105 = 2048;
            uint64_t v106 = (uint64_t)v50;
            __int16 v107 = 2048;
            uint64_t v108 = (char *)v51;
            _os_log_impl(&dword_1830D4000, v55, v65, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), no backtrace", buf, 0x2Au);
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v55 = (id)gconnectionLogObj;
          os_log_type_t v63 = v99;
          if (os_log_type_enabled(v55, v99))
          {
            BOOL v64 = nw_endpoint_get_logging_description(*((void **)v11 + 1));
            *(_DWORD *)buf = 136446978;
            uint64_t v102 = "nw_association_register_internal";
            __int16 v103 = 2082;
            nw_endpoint_t v104 = (void *)v64;
            __int16 v105 = 2048;
            uint64_t v106 = (uint64_t)v50;
            __int16 v107 = 2048;
            uint64_t v108 = (char *)v51;
            _os_log_impl(&dword_1830D4000, v55, v63, "%{public}s <nw_association %{public}s> failed to add new handle for %p (node %p), backtrace limit exceeded", buf, 0x2Au);
          }
        }
      }
      if (!v54) {
        goto LABEL_101;
      }
      goto LABEL_100;
    }
    id v77 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v102 = "nw_association_register_internal";
    __int16 v78 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    os_log_type_t v99 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v78, &type, &v99))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v79 = __nwlog_obj();
        os_log_type_t v80 = type;
        if (os_log_type_enabled(v79, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v102 = "nw_association_register_internal";
          _os_log_impl(&dword_1830D4000, v79, v80, "%{public}s called with null update_handler", buf, 0xCu);
        }
      }
      else
      {
        if (v99)
        {
          os_log_type_t v88 = (char *)__nw_create_backtrace_string();
          uint64_t v89 = __nwlog_obj();
          os_log_type_t v90 = type;
          BOOL v91 = os_log_type_enabled(v89, type);
          if (v88)
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v102 = "nw_association_register_internal";
              __int16 v103 = 2082;
              nw_endpoint_t v104 = v88;
              _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null update_handler, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v88);
          }
          else
          {
            if (v91)
            {
              *(_DWORD *)buf = 136446210;
              uint64_t v102 = "nw_association_register_internal";
              _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null update_handler, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_156;
        }
        BOOL v79 = __nwlog_obj();
        os_log_type_t v94 = type;
        if (os_log_type_enabled(v79, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v102 = "nw_association_register_internal";
          _os_log_impl(&dword_1830D4000, v79, v94, "%{public}s called with null update_handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_156:
    if (v78) {
      free(v78);
    }
    goto LABEL_103;
  }
  __int16 v70 = v13;
  long long v75 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v102 = "nw_association_register_internal";
  __int16 v72 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  os_log_type_t v99 = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v72, &type, &v99)) {
    goto LABEL_151;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    __uint64_t v73 = __nwlog_obj();
    os_log_type_t v76 = type;
    if (os_log_type_enabled(v73, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v102 = "nw_association_register_internal";
      _os_log_impl(&dword_1830D4000, v73, v76, "%{public}s called with null handle", buf, 0xCu);
    }
LABEL_141:

    goto LABEL_151;
  }
  if (v99 == OS_LOG_TYPE_DEFAULT)
  {
    __uint64_t v73 = __nwlog_obj();
    os_log_type_t v93 = type;
    if (os_log_type_enabled(v73, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v102 = "nw_association_register_internal";
      _os_log_impl(&dword_1830D4000, v73, v93, "%{public}s called with null handle, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_141;
  }
  uint64_t v85 = (char *)__nw_create_backtrace_string();
  id v82 = __nwlog_obj();
  os_log_type_t v86 = type;
  BOOL v87 = os_log_type_enabled(v82, type);
  if (!v85)
  {
    if (v87)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v102 = "nw_association_register_internal";
      _os_log_impl(&dword_1830D4000, v82, v86, "%{public}s called with null handle, no backtrace", buf, 0xCu);
    }
    goto LABEL_150;
  }
  if (v87)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v102 = "nw_association_register_internal";
    __int16 v103 = 2082;
    nw_endpoint_t v104 = v85;
    _os_log_impl(&dword_1830D4000, v82, v86, "%{public}s called with null handle, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v85);
  if (v72) {
    goto LABEL_152;
  }
LABEL_104:
}

void sub_18311BE28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

BOOL nw_hash_table_add_object(uint64_t a1, uint64_t a2, char *a3)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "nw_hash_table_add_object";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v16, &type, &v34)) {
      goto LABEL_66;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v34)
      {
        uint64_t v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (!os_log_type_enabled(v17, type)) {
          goto LABEL_66;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_hash_table_add_object";
        id v19 = "%{public}s called with null table, backtrace limit exceeded";
        goto LABEL_65;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v29 = os_log_type_enabled(v17, type);
      if (!backtrace_string)
      {
        if (!v29) {
          goto LABEL_66;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_hash_table_add_object";
        id v19 = "%{public}s called with null table, no backtrace";
        goto LABEL_65;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v37 = "nw_hash_table_add_object";
        __int16 v38 = 2082;
        uint64_t v39 = (uint64_t)backtrace_string;
        os_log_type_t v30 = "%{public}s called with null table, dumping backtrace:%{public}s";
LABEL_48:
        _os_log_impl(&dword_1830D4000, v17, v18, v30, buf, 0x16u);
      }
LABEL_49:
      free(backtrace_string);
      goto LABEL_66;
    }
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (!os_log_type_enabled(v17, type)) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "nw_hash_table_add_object";
    id v19 = "%{public}s called with null table";
LABEL_65:
    _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0xCu);
LABEL_66:
    if (v16) {
      free(v16);
    }
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "nw_hash_table_add_object";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v16, &type, &v34)) {
      goto LABEL_66;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v37 = "nw_hash_table_add_object";
      id v19 = "%{public}s called with null object";
      goto LABEL_65;
    }
    if (!v34)
    {
      uint64_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_66;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v37 = "nw_hash_table_add_object";
      id v19 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_65;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v31 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v37 = "nw_hash_table_add_object";
        __int16 v38 = 2082;
        uint64_t v39 = (uint64_t)backtrace_string;
        os_log_type_t v30 = "%{public}s called with null object, dumping backtrace:%{public}s";
        goto LABEL_48;
      }
      goto LABEL_49;
    }
    if (!v31) {
      goto LABEL_66;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "nw_hash_table_add_object";
    id v19 = "%{public}s called with null object, no backtrace";
    goto LABEL_65;
  }
  if (*(_DWORD *)(a1 + 32))
  {
    int v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0) {
      goto LABEL_6;
    }
    goto LABEL_5;
  }
  os_log_type_t v20 = __nwlog_obj();
  os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v37 = "nw_hash_table_lock";
  os_log_type_t v21 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v21);
  if (!result)
  {
    free(v21);
    int v6 = *(_DWORD *)(a1 + 48);
    if ((v6 & 2) == 0)
    {
LABEL_6:
      if (v6)
      {
        *(_DWORD *)buf = 0;
        uint64_t v7 = (*(uint64_t (**)(uint64_t, uint8_t *))a1)(a2, buf);
        uint64_t v8 = (*(unsigned int (**)(uint64_t, void))(a1 + 8))(v7, *(unsigned int *)buf) % *(_DWORD *)(a1 + 32);
        uint64_t v9 = a1 + 56;
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_63663);
        }
        unsigned int v10 = (unsigned char *)(v9 + 16 * v8);
        if (_nw_signposts_enabled && kdebug_is_enabled()) {
          kdebug_trace();
        }
        while (1)
        {
          unsigned int v10 = *(unsigned char **)v10;
          if (!v10) {
            break;
          }
          if (v10[30] == 1 && *((void *)v10 + 2) == a2)
          {
            char v11 = 0;
            if (!a3) {
              goto LABEL_20;
            }
            goto LABEL_19;
          }
        }
        size_t v12 = *(unsigned int *)(a1 + 36) + 32;
        char v11 = 1;
        unsigned int v10 = malloc_type_calloc(1uLL, v12, 0xEAFB8F1AuLL);
        if (!v10)
        {
          os_log_type_t v26 = __nwlog_obj();
          os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446722;
          os_log_type_t v37 = "strict_calloc";
          __int16 v38 = 2048;
          uint64_t v39 = 1;
          __int16 v40 = 2048;
          size_t v41 = v12;
          uint64_t v27 = (void *)_os_log_send_and_compose_impl();
          BOOL result = __nwlog_abort((uint64_t)v27);
          if (result) {
            goto LABEL_76;
          }
          free(v27);
        }
        *((_DWORD *)v10 + 6) = v8;
        *((void *)v10 + 2) = a2;
        *(void *)unsigned int v10 = 0;
        uint64_t v13 = v9 + 16 * v8;
        id v14 = *(void **)(v13 + 8);
        *((void *)v10 + 1) = v14;
        void *v14 = v10;
        *(void *)(v13 + 8) = v10;
        v10[30] = 1;
        ++*(_DWORD *)(a1 + 40);
        if (a3) {
LABEL_19:
        }
          *a3 = v11;
LABEL_20:
        if ((*(unsigned char *)(a1 + 48) & 2) != 0) {
          os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        }
        return (BOOL)v10;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      os_log_type_t v37 = "nw_hash_table_add_object";
      uint64_t v22 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (__nwlog_fault(v22, &type, &v34))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v24 = type;
          if (!os_log_type_enabled(v23, type)) {
            goto LABEL_71;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "nw_hash_table_add_object";
          os_log_type_t v25 = "%{public}s called with invalid hash table";
LABEL_70:
          _os_log_impl(&dword_1830D4000, v23, v24, v25, buf, 0xCu);
          goto LABEL_71;
        }
        if (!v34)
        {
          os_log_type_t v23 = __nwlog_obj();
          os_log_type_t v24 = type;
          if (!os_log_type_enabled(v23, type)) {
            goto LABEL_71;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "nw_hash_table_add_object";
          os_log_type_t v25 = "%{public}s called with invalid hash table, backtrace limit exceeded";
          goto LABEL_70;
        }
        os_log_type_t v32 = (char *)__nw_create_backtrace_string();
        os_log_type_t v23 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v33 = os_log_type_enabled(v23, type);
        if (!v32)
        {
          if (!v33) {
            goto LABEL_71;
          }
          *(_DWORD *)buf = 136446210;
          os_log_type_t v37 = "nw_hash_table_add_object";
          os_log_type_t v25 = "%{public}s called with invalid hash table, no backtrace";
          goto LABEL_70;
        }
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_hash_table_add_object";
          __int16 v38 = 2082;
          uint64_t v39 = (uint64_t)v32;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v32);
      }
LABEL_71:
      if (v22) {
        free(v22);
      }
      if ((*(unsigned char *)(a1 + 48) & 2) != 0)
      {
        os_unfair_lock_unlock((os_unfair_lock_t)(a1 + 52));
        return 0;
      }
      return 0;
    }
LABEL_5:
    os_unfair_lock_lock((os_unfair_lock_t)(a1 + 52));
    int v6 = *(_DWORD *)(a1 + 48);
    goto LABEL_6;
  }
LABEL_76:
  __break(1u);
  return result;
}

uint64_t nw_endpoint_association_key_hash(void *a1)
{
  return nw_path_parameters_get_hash(a1);
}

uint64_t nw_path_parameters_get_hash(void *a1)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    memset(&c, 0, sizeof(c));
    CC_SHA256_Init(&c);
    CC_SHA256_Update(&c, v1 + 8, 0x40u);
    CC_SHA256_Update(&c, v1 + 72, 0x1Eu);
    CC_SHA256_Update(&c, v1 + 102, 9u);
    if (*((void *)v1 + 17)) {
      CC_SHA256_Update(&c, v1 + 136, 8u);
    }
    nw_path_t v2 = (const void *)*((void *)v1 + 14);
    if (v2)
    {
      CC_LONG v3 = strlen(*((const char **)v1 + 14));
      CC_SHA256_Update(&c, v2, v3);
    }
    uint64_t v4 = (const void *)*((void *)v1 + 15);
    if (v4)
    {
      CC_LONG v5 = strlen(*((const char **)v1 + 15));
      CC_SHA256_Update(&c, v4, v5);
    }
    int v6 = (const void *)*((void *)v1 + 16);
    if (v6)
    {
      CC_LONG v7 = strlen(*((const char **)v1 + 16));
      CC_SHA256_Update(&c, v6, v7);
    }
    CC_SHA256_Final(md, &c);
    int8x16_t v32 = *(int8x16_t *)md;
    int8x16_t v33 = v36;
    uint64_t v8 = [*((id *)v1 + 20) getHash];
    uint64_t shallow_hash = nw_interface_get_shallow_hash(*((void **)v1 + 21));
    uint64_t hash = nw_protocol_options_get_hash(*((void **)v1 + 18));
    uint64_t v11 = nw_protocol_options_get_hash(*((void **)v1 + 19));
    int8x16_t v12 = veorq_s8(v32, v33);
    uint64_t v13 = v8 ^ *(void *)&veor_s8(*(int8x8_t *)v12.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v12, v12, 8uLL)) ^ shallow_hash ^ hash ^ v11;
    uint64_t v14 = *((void *)v1 + 22);
    if (v14)
    {
      if (*(void *)v14)
      {
        v13 ^= xpc_hash(*(xpc_object_t *)v14);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v15 = *(void **)(v14 + 8);
      if (v15)
      {
        v13 ^= xpc_hash(v15);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v16 = *(void **)(v14 + 16);
      if (v16)
      {
        v13 ^= xpc_hash(v16);
        uint64_t v14 = *((void *)v1 + 22);
      }
      uint64_t v17 = *(void **)(v14 + 24);
      if (v17)
      {
        v13 ^= xpc_hash(v17);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v18 = *(void **)(v14 + 32);
      if (v18)
      {
        v13 ^= xpc_hash(v18);
        uint64_t v14 = *((void *)v1 + 22);
      }
      id v19 = *(void **)(v14 + 40);
      if (v19)
      {
        v13 ^= xpc_hash(v19);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v20 = *(void **)(v14 + 48);
      if (v20)
      {
        v13 ^= xpc_hash(v20);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v21 = *(void **)(v14 + 56);
      if (v21)
      {
        v13 ^= xpc_hash(v21);
        uint64_t v14 = *((void *)v1 + 22);
      }
      uint64_t v22 = *(void **)(v14 + 64);
      if (v22)
      {
        v13 ^= xpc_hash(v22);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v23 = *(void **)(v14 + 72);
      if (v23)
      {
        v13 ^= xpc_hash(v23);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v24 = *(void **)(v14 + 80);
      if (v24)
      {
        v13 ^= xpc_hash(v24);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v25 = *(void **)(v14 + 88);
      if (v25)
      {
        v13 ^= xpc_hash(v25);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v26 = *(void **)(v14 + 96);
      if (v26)
      {
        v13 ^= xpc_hash(v26);
        uint64_t v14 = *((void *)v1 + 22);
      }
      uint64_t v27 = *(void **)(v14 + 104);
      if (v27)
      {
        v13 ^= xpc_hash(v27);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v28 = *(void **)(v14 + 112);
      if (v28)
      {
        v13 ^= xpc_hash(v28);
        uint64_t v14 = *((void *)v1 + 22);
      }
      BOOL v29 = *(void **)(v14 + 120);
      if (v29)
      {
        v13 ^= xpc_hash(v29);
        uint64_t v14 = *((void *)v1 + 22);
      }
      os_log_type_t v30 = *(void **)(v14 + 136);
      if (v30)
      {
        v13 ^= xpc_hash(v30);
        uint64_t v14 = *((void *)v1 + 22);
      }
      v13 ^= nw_protocol_options_get_hash(*(void **)(v14 + 128));
    }
  }
  else
  {
    uint64_t v13 = 0;
  }

  return v13;
}

void sub_18311C9F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_get_hash(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    memset(&v7, 0, sizeof(v7));
    CC_SHA256_Init(&v7);
    uint64_t v2 = v1[1];
    if (v2) {
      CC_SHA256_Update(&v7, (const void *)(v2 + 8), 0x28u);
    }
    CC_SHA256_Final(md, &v7);
    int8x16_t v3 = veorq_s8(*(int8x16_t *)md, v9);
    int8x8_t v4 = veor_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
    CC_LONG v5 = (void *)v1[5];
    if (v5) {
      *(void *)&v4 ^= xpc_hash(v5);
    }
  }
  else
  {
    int8x8_t v4 = 0;
  }

  return (uint64_t)v4;
}

void sub_18311CAE4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_interface_get_shallow_hash(void *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    memset(&v6, 0, sizeof(v6));
    CC_SHA256_Init(&v6);
    CC_SHA256_Update(&v6, v1 + 96, 4u);
    CC_SHA256_Update(&v6, v1 + 100, 4u);
    CC_SHA256_Update(&v6, v1 + 8, 4u);
    CC_LONG v2 = strlen(v1 + 104);
    CC_SHA256_Update(&v6, v1 + 104, v2);
    CC_SHA256_Final(md, &v6);
    int8x16_t v3 = veorq_s8(*(int8x16_t *)md, v8);
    int8x8_t v4 = veor_s8(*(int8x8_t *)v3.i8, (int8x8_t)*(_OWORD *)&vextq_s8(v3, v3, 8uLL));
  }
  else
  {
    int8x8_t v4 = 0;
  }

  return (uint64_t)v4;
}

void sub_18311CCBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_association_copy_current_path(void *a1, void *a2)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  int8x16_t v3 = a1;
  id v4 = a2;
  if (!v3)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v27 = "nw_association_copy_current_path";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int8x16_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null association", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v24)
    {
      int8x16_t v12 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int8x16_t v12 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v18)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v27 = "nw_association_copy_current_path";
      __int16 v28 = 2082;
      BOOL v29 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  id v5 = nw_path_parameters_copy_context(v3[2]);
  nw_context_assert_queue(v5);

  nw_association_activate(v3, v4, 0, 1);
  if (*((unsigned char *)v3 + 76))
  {
    uint64_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v27 = "nw_association_copy_current_path";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v11, &type, &v24)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int8x16_t v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null !association->dormant", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v11) {
        free(v11);
      }
      goto LABEL_39;
    }
    if (!v24)
    {
      int8x16_t v12 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null !association->dormant, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int8x16_t v12 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v27 = "nw_association_copy_current_path";
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null !association->dormant, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v27 = "nw_association_copy_current_path";
      __int16 v28 = 2082;
      BOOL v29 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null !association->dormant, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  CC_SHA256_CTX v6 = (os_unfair_lock_s *)v3[3];
  if (!v6)
  {
LABEL_39:
    id v9 = 0;
    goto LABEL_40;
  }
  CC_SHA256_CTX v7 = v6 + 24;
  int8x16_t v8 = v6;
  os_unfair_lock_lock(v7);
  id v9 = v8[6];
  os_unfair_lock_unlock(v7);

LABEL_40:
  return v9;
}

void sub_18311D1E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_parameters_copy_context(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  CC_LONG v2 = v1;
  if (v1)
  {
    id v3 = v1[17];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_path_parameters_copy_context";
  CC_SHA256_CTX v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      CC_SHA256_CTX v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      CC_SHA256_CTX v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_path_parameters_copy_context";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      CC_SHA256_CTX v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_path_parameters_copy_context";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void nw_association_activate(void *a1, void *a2, int a3, int a4)
{
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = *((void *)v7 + 8);
  if (v9)
  {
    nw_queue_cancel_source(v9);
    *((void *)v7 + 8) = 0;
  }
  if (*((unsigned char *)v7 + 76))
  {
    *((unsigned char *)v7 + 76) &= ~1u;
    evaluator_for_endpoint = nw_path_create_evaluator_for_endpoint(*((void **)v7 + 1), v8);
    BOOL v11 = (void *)*((void *)v7 + 3);
    *((void *)v7 + 3) = evaluator_for_endpoint;

    os_log_type_t v12 = (os_unfair_lock_s *)*((void *)v7 + 3);
    if (v12)
    {
      char v13 = v12 + 24;
      uint64_t v14 = v12;
      os_unfair_lock_lock(v13);
      id v15 = v14[6];
      os_unfair_lock_unlock(v13);
    }
    else
    {
      id v15 = 0;
    }
    os_log_type_t v16 = nw_path_copy_without_parameters(v15);
    __int16 v17 = (void *)*((void *)v7 + 4);
    *((void *)v7 + 4) = v16;

    nw_path_evaluator_set_logging(*((void **)v7 + 3));
    BOOL v18 = (void *)*((void *)v7 + 3);
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    void v20[2] = ___ZL23nw_association_activateP25NWConcrete_nw_associationPU27objcproto16OS_nw_parameters8NSObjectbb_block_invoke;
    v20[3] = &unk_1E524AEE0;
    uint64_t v19 = (NWConcrete_nw_association *)v7;
    os_log_type_t v21 = v19;
    nw_path_evaluator_set_update_handler(v18, 0, v20);
    if (a4) {
      nw_association_schedule_deactivation(v19);
    }
  }
  else if (a3)
  {
    nw_path_evaluator_force_update(*((void **)v7 + 3), 0);
  }
}

void sub_18311D61C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_custom_mapping_key_hash(uint8x8_t *a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 > 7)
  {
    if (a2 >= 0x20)
    {
      int32x4_t v5 = 0uLL;
      uint64_t v2 = a2 & 0xFFFFFFE0;
      int32x4_t v6 = 0uLL;
      id v7 = a1 + 2;
      uint64_t v8 = v2;
      int32x4_t v9 = 0uLL;
      int32x4_t v10 = 0uLL;
      int32x4_t v11 = 0uLL;
      int32x4_t v12 = 0uLL;
      int32x4_t v13 = 0uLL;
      int32x4_t v14 = 0uLL;
      do
      {
        uint8x16_t v15 = *(uint8x16_t *)v7[-2].i8;
        uint16x8_t v16 = vmovl_u8(*(uint8x8_t *)v15.i8);
        uint16x8_t v17 = vmovl_high_u8(v15);
        uint16x8_t v18 = vmovl_u8(*v7);
        uint16x8_t v19 = vmovl_high_u8(*(uint8x16_t *)v7->i8);
        int32x4_t v10 = (int32x4_t)vaddw_high_u16((uint32x4_t)v10, v17);
        int32x4_t v9 = (int32x4_t)vaddw_u16((uint32x4_t)v9, *(uint16x4_t *)v17.i8);
        int32x4_t v6 = (int32x4_t)vaddw_high_u16((uint32x4_t)v6, v16);
        int32x4_t v5 = (int32x4_t)vaddw_u16((uint32x4_t)v5, *(uint16x4_t *)v16.i8);
        int32x4_t v14 = (int32x4_t)vaddw_high_u16((uint32x4_t)v14, v19);
        int32x4_t v13 = (int32x4_t)vaddw_u16((uint32x4_t)v13, *(uint16x4_t *)v19.i8);
        int32x4_t v12 = (int32x4_t)vaddw_high_u16((uint32x4_t)v12, v18);
        int32x4_t v11 = (int32x4_t)vaddw_u16((uint32x4_t)v11, *(uint16x4_t *)v18.i8);
        v7 += 4;
        v8 -= 32;
      }
      while (v8);
      uint64_t v3 = vaddvq_s32(vaddq_s32(vaddq_s32(vaddq_s32(v11, v5), vaddq_s32(v13, v9)), vaddq_s32(vaddq_s32(v12, v6), vaddq_s32(v14, v10))));
      if (v2 == a2) {
        return v3;
      }
      if ((a2 & 0x18) == 0) {
        goto LABEL_14;
      }
    }
    else
    {
      LODWORD(v3) = 0;
      uint64_t v2 = 0;
    }
    uint64_t v20 = v2;
    uint64_t v2 = a2 & 0xFFFFFFF8;
    int32x4_t v21 = 0uLL;
    int32x4_t v22 = (int32x4_t)v3;
    uint64_t v23 = v20 - v2;
    char v24 = (uint8x8_t *)((char *)a1 + v20);
    do
    {
      uint8x8_t v25 = *v24++;
      uint16x8_t v26 = vmovl_u8(v25);
      int32x4_t v21 = (int32x4_t)vaddw_high_u16((uint32x4_t)v21, v26);
      int32x4_t v22 = (int32x4_t)vaddw_u16((uint32x4_t)v22, *(uint16x4_t *)v26.i8);
      v23 += 8;
    }
    while (v23);
    uint64_t v3 = vaddvq_s32(vaddq_s32(v22, v21));
    if (v2 == a2) {
      return v3;
    }
    goto LABEL_14;
  }
  uint64_t v2 = 0;
  LODWORD(v3) = 0;
LABEL_14:
  uint64_t v27 = a2 - v2;
  __int16 v28 = (unsigned __int8 *)a1 + v2;
  do
  {
    int v29 = *v28++;
    uint64_t v3 = (v3 + v29);
    --v27;
  }
  while (v27);
  return v3;
}

uint64_t nw_flow_registration_key_hash(int32x4_t *a1)
{
  return vaddvq_s32(*a1);
}

id nw_endpoint_association_get_key(void *a1, unsigned int *a2)
{
  id v2 = nw_association_copy_path_parameters(a1);

  return v2;
}

void nw_path_evaluator_set_logging(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 24);
    HIBYTE(v2[26]._os_unfair_lock_opaque) &= ~0x40u;
    os_unfair_lock_unlock(v2 + 24);
    goto LABEL_3;
  }
  uint64_t v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int32x4_t v14 = "nw_path_evaluator_set_logging";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int32x4_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null evaluator", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int32x4_t v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          int32x4_t v14 = "nw_path_evaluator_set_logging";
          __int16 v15 = 2082;
          uint16x8_t v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null evaluator, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null evaluator, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int32x4_t v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        int32x4_t v14 = "nw_path_evaluator_set_logging";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null evaluator, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

uint64_t nw_flow_registration_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 16;
  return (uint64_t)a1 + 32;
}

void nw_protocol_get_key(const void *a1, unsigned int *a2)
{
  *a2 = 8;
}

_DWORD *nw_protocol_custom_mapping_get_key(unsigned int *a1, unsigned int *a2)
{
  unsigned int v3 = *a1;
  BOOL result = a1 + 1;
  *a2 = v3;
  return result;
}

uint64_t nw_flow_protocol_get_key(void *a1, BOOL *a2)
{
  uint64_t v2 = a1[30];
  BOOL v3 = v2 == 0;
  BOOL v4 = v2 != 0;
  uint64_t v5 = 31;
  if (!v3) {
    uint64_t v5 = 30;
  }
  *a2 = v4;
  return a1[v5];
}

uint64_t nw_context_timer_object_get_key(void *a1, unsigned int *a2)
{
  return a1[3];
}

uint64_t nw_protocol_metadata_copy_identifier(void *a1, _OWORD *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  BOOL v4 = v3;
  if (v3)
  {
    if (a2)
    {
      *a2 = *((_OWORD *)v3 + 1);
      uint64_t v5 = 1;
      goto LABEL_4;
    }
    char v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_metadata_copy_identifier";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null out_identifier", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v20)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null out_identifier, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null out_identifier, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_protocol_metadata_copy_identifier";
        __int16 v24 = 2082;
        uint8x8_t v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null out_identifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    id v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_protocol_metadata_copy_identifier";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v20)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_protocol_metadata_copy_identifier";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_protocol_metadata_copy_identifier";
        __int16 v24 = 2082;
        uint8x8_t v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0;
LABEL_4:

  return v5;
}

void nw_socket_release_frame_array(nw_frame_array_s *a1)
{
  while (1)
  {
    os_log_type_t tqh_first = a1->tqh_first;
    if (!a1->tqh_first) {
      break;
    }
    uint64_t v3 = *((void *)tqh_first + 2);
    BOOL v4 = (nw_frame **)*((void *)tqh_first + 3);
    if (v3)
    {
      *(void *)(v3 + 24) = v4;
      BOOL v4 = (nw_frame **)*((void *)tqh_first + 3);
    }
    else
    {
      a1->tqh_last = v4;
    }
    void *v4 = (nw_frame *)v3;
    *((void *)tqh_first + 2) = 0;
    *((void *)tqh_first + 3) = 0;
    if (nw_frame_uses_external_data((uint64_t)tqh_first)) {
      nw_frame_set_external_data((uint64_t)tqh_first, 0, 0);
    }
    else {
      nw_frame_free_buffer((uint64_t)tqh_first);
    }
    nw_frame_reset((uint64_t)tqh_first, 0, 0, 0, 0);
    os_release(tqh_first);
  }
}

BOOL nw_flow_process_input_frames(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_flow *a2, nw_protocol *a3, nw_frame_array_s *a4, int a5, char a6, int a7)
{
  uint64_t v286 = *MEMORY[0x1E4F143B8];
  char v230 = a1;
  os_log_type_t v10 = a2;
  handle = (char *)a3->handle;
  v226 = a4;
  os_log_type_t tqh_first = a4->tqh_first;
  v248 = v10;
  nw_endpoint_t v249 = handle;
  if (!a4->tqh_first)
  {
    if ((*((_WORD *)handle + 166) & 0x10) == 0) {
      goto LABEL_361;
    }
    int v29 = (void *)*((void *)handle + 33);
    if (!v29)
    {
      uint64_t v186 = *((void *)handle + 32);
      if (v186 && nw_dictionary_get_count(v186))
      {
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000;
        v274 = __Block_byref_object_copy__16663;
        *(void *)v275 = __Block_byref_object_dispose__16664;
        *(void *)&v275[8] = 0;
        memset(out, 0, sizeof(out));
        uint64_t v187 = *((void *)handle + 32);
        v270[0] = MEMORY[0x1E4F143A8];
        v270[1] = 3221225472;
        v270[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke;
        v270[3] = &unk_1E523CA50;
        v270[4] = buf;
        v270[5] = out;
        nw_dictionary_apply(v187, (uint64_t)v270);
        nw_dictionary_set_value(*((void *)handle + 32), out, 0);

        if (nw_content_context_get_is_final(*(nw_content_context_t *)(*(void *)&buf[8] + 40))) {
          *((_WORD *)handle + 166) |= 0x80u;
        }
        _Block_object_dispose(buf, 8);
      }
      else
      {

        *((_WORD *)handle + 166) |= 0x80u;
      }
      goto LABEL_342;
    }
    id v30 = v29;
    BOOL v31 = (void *)*((void *)handle + 33);
    *((void *)handle + 33) = 0;

    int8x16_t v32 = v30;
    int8x16_t v33 = v32;
    if (v32 == (unsigned char *)&__block_literal_global_42249 || v32 == (unsigned char *)&__block_literal_global_10_42276)
    {

      goto LABEL_342;
    }
    if (v32 == (unsigned char *)&__block_literal_global_6_42258 || v32 == (unsigned char *)&__block_literal_global_8_42267)
    {
    }
    else
    {
      char v36 = v32[118];

      if ((v36 & 1) == 0)
      {
LABEL_38:

LABEL_342:
        request_list_report = nw_read_request_list_report(*((void **)handle + 27));
        os_log_type_t v198 = *((void *)handle + 27);
        *((void *)handle + 27) = request_list_report;
        goto LABEL_360;
      }
    }
    *((_WORD *)handle + 166) |= 0x80u;
    goto LABEL_38;
  }
  BOOL is_inline = nw_context_is_inline(*((void **)handle + 23));
  os_log_type_t v12 = a4->tqh_first;
  int32x4_t v13 = v12;
  BOOL v269 = 0;
  os_log_type_t v14 = (void *)*((void *)handle + 27);
  if (v14) {
    BOOL v15 = v12 == 0;
  }
  else {
    BOOL v15 = 1;
  }
  if (v15 || (*((_WORD *)v12 + 102) & 1) != 0)
  {
LABEL_19:
    LODWORD(v17) = 0;
    alloCC_SHA256_CTX c = 0;
    goto LABEL_20;
  }
  alloCC_SHA256_CTX c = 0;
  LODWORD(v17) = 0;
  if (!*((void *)v12 + 13) && (a5 & 1) == 0)
  {
    os_log_type_t v18 = v14;
    int v19 = v18[17];

    if (v19 != 3)
    {
      *(_DWORD *)buf = 0;
      nw_frame_array_get_frame_count((uint64_t *)a4, 1, buf);
      unsigned int v20 = *(_DWORD *)buf;
      unsigned int next_max_size = nw_read_request_get_next_max_size(*((void **)handle + 27));
      if (next_max_size)
      {
        if (v20 >= next_max_size) {
          size_t v17 = next_max_size;
        }
        else {
          size_t v17 = v20;
        }
        if (is_inline) {
          goto LABEL_18;
        }
        uint64_t buffer_manager_with_context = nw_frame_get_buffer_manager_with_context(*((void **)handle + 23), v17);
        if (!buffer_manager_with_context) {
          goto LABEL_18;
        }
        uint64_t v23 = buffer_manager_with_context;
        BOOL v24 = nw_mem_buffer_allocate(buffer_manager_with_context);
        BOOL v269 = v24;
        if (!v24) {
          goto LABEL_18;
        }
        uint8x8_t v25 = (const void *)v24;
        BOOL v26 = nw_queue_copy_current_workloop();
        destructor[0] = MEMORY[0x1E4F143A8];
        destructor[1] = 3221225472;
        destructor[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_2;
        destructor[3] = &__block_descriptor_48_e5_v8__0l;
        destructor[4] = v23;
        destructor[5] = v269;
        alloCC_SHA256_CTX c = (uint64_t)dispatch_data_create(v25, v17, (dispatch_queue_t)v26, destructor);

        handle = v249;
        if (!alloc) {
LABEL_18:
        }
          alloCC_SHA256_CTX c = dispatch_data_create_alloc();
        goto LABEL_20;
      }
    }
    goto LABEL_19;
  }
LABEL_20:
  uint64_t v27 = (void *)*((void *)handle + 27);
  if (v27) {
    BOOL v28 = v13 == 0;
  }
  else {
    BOOL v28 = 1;
  }
  if (v28)
  {
    data1 = 0;
    goto LABEL_347;
  }
  unsigned int v239 = v17;
  data1 = 0;
  unsigned int v250 = 0;
  uint64_t v37 = (id *)(handle + 264);
  dispatch_block_t v222 = (dispatch_block_t)*MEMORY[0x1E4F143F0];
  uint64_t v38 = (uint64_t)v13;
  __int16 v235 = (id *)(handle + 264);
  while (1)
  {
    uint64_t v39 = *(void **)(v38 + 32);
    __int16 v237 = (void *)(v38 + 32);
    if (!v39 && !*(void *)(v38 + 40)) {
      uint64_t v39 = 0;
    }
    os_log_t v246 = v39;
    if (!*(void *)(v38 + 112)
      || (*(_WORD *)(v38 + 204) & 0x100) != 0
      && g_channel_check_validity
      && !g_channel_check_validity(v38, *(void *)(v38 + 88)))
    {
      unsigned int v42 = 0;
      buffer = 0;
    }
    else
    {
      int v41 = *(_DWORD *)(v38 + 52);
      uint64_t v40 = *(unsigned int *)(v38 + 56);
      unsigned int v42 = v41 ? v41 - (v40 + *(_DWORD *)(v38 + 60)) : 0;
      buffer = (char *)(*(void *)(v38 + 112) + v40);
    }
    memset(uu, 0, sizeof(uu));
    memset(out, 0, sizeof(out));
    __int16 v43 = *(_WORD *)(v38 + 204);
    uint64_t v44 = *(void *)(v38 + 64);
    dispatch_data_t data = (dispatch_data_t)alloc;
    unsigned int v45 = v42;
    if (v44)
    {
      int v243 = (*(unsigned __int8 *)(v44 + 66) >> 6) & 1;
      if (*(void *)(v44 + 48))
      {
        *(_OWORD *)uu = *(_OWORD *)(v44 + 16);
LABEL_57:
        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v230) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v255 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v255, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v230);
            BOOL v137 = nw_endpoint_handler_dry_run_string(v230);
            nw_endpoint_t v138 = nw_endpoint_handler_copy_endpoint(v230);
            logging_description = nw_endpoint_get_logging_description(v138);
            v140 = nw_endpoint_handler_state_string(v230);
            int v141 = nw_endpoint_handler_mode_string(v230);
            id v142 = nw_endpoint_handler_copy_current_path(v230);
            v143 = v142;
            *(_DWORD *)buf = 136448770;
            v144 = ", complete";
            if (!v243) {
              v144 = "";
            }
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            v145 = ", wake_packet";
            if ((v43 & 0x4000) == 0) {
              v145 = "";
            }
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = id_string;
            *(_WORD *)&unsigned char buf[22] = 2082;
            v274 = (uint64_t (*)(uint64_t, uint64_t))v137;
            *(_WORD *)v275 = 2082;
            *(void *)&v275[2] = logging_description;
            *(_WORD *)&v275[10] = 2082;
            *(void *)&v275[12] = v140;
            __int16 v276 = 2082;
            char v277 = v141;
            __int16 v278 = 2114;
            id v279 = v142;
            __int16 v280 = 1042;
            *(_DWORD *)v281 = 16;
            *(_WORD *)&v281[4] = 2098;
            *(void *)&v281[6] = uu;
            *(_WORD *)&v281[14] = 2080;
            *(void *)&v281[16] = v144;
            *(_WORD *)&v281[24] = 2080;
            *(void *)&v281[26] = v145;
            _os_log_impl(&dword_1830D4000, v255, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Found frame with context %{public,uuid_t}.16P%s%s", buf, 0x6Cu);
          }
          handle = v249;
          uint64_t v37 = v235;
        }
        if ((a6 & 1) != 0 || v248->multiplexed_message_definition)
        {
          id v47 = *v37;
          if (v47)
          {
LABEL_61:
            __uint64_t v48 = v47;
            uint64_t v49 = v48;
            goto LABEL_64;
          }
          uint64_t v49 = nw_content_context_create(*(const char **)(*((void *)handle + 4) + 16));
          nw_content_context_set_is_final(v49, 1);
          objc_storeStrong(v37, v49);
        }
        else
        {
          if (!*((void *)handle + 32))
          {
            uint64_t v116 = nw_dictionary_create();
            uint64_t v117 = (void *)*((void *)handle + 32);
            *((void *)handle + 32) = v116;

            handle = v249;
          }
          uuid_unparse_upper(uu, out);
          id v47 = nw_dictionary_copy_value(*((void *)handle + 32), (uint64_t)out);
          if (v47) {
            goto LABEL_61;
          }
          uint64_t v49 = nw_content_context_create(*(const char **)(*((void *)handle + 4) + 16));
          nw_dictionary_set_value(*((void *)handle + 32), out, v49);
        }
        __uint64_t v48 = 0;
LABEL_64:

        v264[0] = MEMORY[0x1E4F143A8];
        v264[1] = 3221225472;
        v264[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_82;
        v264[3] = &unk_1E523CA98;
        v267 = v249;
        v265 = v248;
        id v50 = v49;
        v266 = v50;
        nw_frame_foreach_protocol_metadata(v38, a5, (uint64_t)v264);
        os_log_t v253 = v50;
        if ((v43 & 0x4000) == 0) {
          goto LABEL_78;
        }
        BOOL v51 = v50;
        id v52 = v51;
        if (v51)
        {
          if (v51 != &__block_literal_global_10_42276
            && v51 != &__block_literal_global_8_42267
            && v51 != &__block_literal_global_6_42258
            && v51 != &__block_literal_global_42249)
          {
            BYTE6(v51[14].isa) |= 0x80u;
          }
LABEL_71:

          int minimize_logging = nw_endpoint_handler_get_minimize_logging(v230);
          char logging_disabled = nw_endpoint_handler_get_logging_disabled(v230);
          if (minimize_logging)
          {
            if (logging_disabled) {
              goto LABEL_78;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v55 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v55, OS_LOG_TYPE_DEBUG))
            {
              id v150 = nw_endpoint_handler_get_id_string(v230);
              int v151 = nw_endpoint_handler_dry_run_string(v230);
              nw_endpoint_t v152 = nw_endpoint_handler_copy_endpoint(v230);
              os_log_type_t v153 = nw_endpoint_get_logging_description(v152);
              BOOL v154 = nw_endpoint_handler_state_string(v230);
              os_log_type_t v155 = nw_endpoint_handler_mode_string(v230);
              id v156 = nw_endpoint_handler_copy_current_path(v230);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v150;
              *(_WORD *)&unsigned char buf[22] = 2082;
              v274 = (uint64_t (*)(uint64_t, uint64_t))v151;
              *(_WORD *)v275 = 2082;
              *(void *)&v275[2] = v153;
              *(_WORD *)&v275[10] = 2082;
              *(void *)&v275[12] = v154;
              __int16 v276 = 2082;
              char v277 = v155;
              __int16 v278 = 2114;
              id v279 = v156;
              _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] content_context is wake packet", buf, 0x48u);
            }
            goto LABEL_77;
          }
          if ((logging_disabled & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v55 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
            {
              os_log_type_t v56 = nw_endpoint_handler_get_id_string(v230);
              os_log_type_t v57 = nw_endpoint_handler_dry_run_string(v230);
              nw_endpoint_t v58 = nw_endpoint_handler_copy_endpoint(v230);
              os_log_type_t v59 = nw_endpoint_get_logging_description(v58);
              os_log_type_t v60 = nw_endpoint_handler_state_string(v230);
              os_log_type_t v61 = nw_endpoint_handler_mode_string(v230);
              id v62 = nw_endpoint_handler_copy_current_path(v230);
              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v56;
              *(_WORD *)&unsigned char buf[22] = 2082;
              v274 = (uint64_t (*)(uint64_t, uint64_t))v57;
              *(_WORD *)v275 = 2082;
              *(void *)&v275[2] = v59;
              *(_WORD *)&v275[10] = 2082;
              *(void *)&v275[12] = v60;
              __int16 v276 = 2082;
              char v277 = v61;
              __int16 v278 = 2114;
              id v279 = v62;
              _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] content_context is wake packet", buf, 0x48u);
            }
LABEL_77:
          }
LABEL_78:

          os_log_type_t v46 = v253;
          alloCC_SHA256_CTX c = (uint64_t)data;
          handle = v249;
          unsigned int v42 = v45;
          goto LABEL_79;
        }
        nw_endpoint_t v146 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
        id v147 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v271 = 0;
        if (__nwlog_fault(v147, &type, &v271))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            v148 = __nwlog_obj();
            os_log_type_t v149 = type;
            if (os_log_type_enabled(v148, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
              _os_log_impl(&dword_1830D4000, v148, v149, "%{public}s called with null context", buf, 0xCu);
            }
          }
          else
          {
            if (v271)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              int v166 = __nwlog_obj();
              os_log_type_t v167 = type;
              BOOL v168 = os_log_type_enabled(v166, type);
              if (backtrace_string)
              {
                if (v168)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v166, v167, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
              }
              else
              {
                if (v168)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
                  _os_log_impl(&dword_1830D4000, v166, v167, "%{public}s called with null context, no backtrace", buf, 0xCu);
                }
              }
              goto LABEL_303;
            }
            v148 = __nwlog_obj();
            os_log_type_t v169 = type;
            if (os_log_type_enabled(v148, type))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_content_context_set_is_wake_packet";
              _os_log_impl(&dword_1830D4000, v148, v169, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_303:
        if (v147) {
          free(v147);
        }
        goto LABEL_71;
      }
    }
    else
    {
      int v243 = 0;
    }
    if ((*(_WORD *)(v38 + 204) & 0x4000) != 0) {
      goto LABEL_57;
    }
    os_log_type_t v46 = 0;
LABEL_79:
    os_log_type_t v63 = (void *)*((void *)handle + 27);
    os_log_t v254 = v46;
    if (!v63 || v42) {
      break;
    }
    if (!alloc || !v246 || v250 >= v239)
    {
      if (alloc)
      {
        alloCC_SHA256_CTX c = (uint64_t)data1;
      }
      else
      {
        dispatch_data_t v118 = 0;
        dispatch_data_t data = data1;
        if (!data1) {
          goto LABEL_221;
        }
      }
      if (dispatch_data_get_size(data))
      {
        id v119 = (void *)*((void *)handle + 40);
        if (!v119 || (*((unsigned char *)v248 + 36) & 1) == 0)
        {
          dispatch_data_t v118 = data;
          goto LABEL_221;
        }
        *((void *)handle + 40) = 0;

        last_error = v248->last_error;
        v248->last_error = 0;

        *((unsigned char *)v248 + 36) &= ~1u;
        dispatch_data_t v118 = data;
      }
      else
      {

        dispatch_data_t v118 = 0;
      }
      handle = v249;
LABEL_221:

      if (v46) {
        BOOL v125 = v243 != 0;
      }
      else {
        BOOL v125 = 0;
      }
      if (!v125) {
        goto LABEL_231;
      }
      uint64_t v126 = v46;
      if (v126 == &__block_literal_global_42249 || v126 == &__block_literal_global_10_42276)
      {

        goto LABEL_231;
      }
      if (v126 == &__block_literal_global_6_42258 || v126 == &__block_literal_global_8_42267)
      {
      }
      else
      {
        BOOL v127 = (BYTE6(v126[14].isa) & 1) == 0;

        if (v127)
        {
LABEL_231:

          unsigned int v64 = 0;
          dispatch_data_t data = 0;
          data1 = alloc;
          goto LABEL_232;
        }
      }
      *((_WORD *)v249 + 166) |= 0x80u;
      goto LABEL_231;
    }
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v230) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v157 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v157, OS_LOG_TYPE_DEBUG))
      {
        BOOL v158 = nw_endpoint_handler_get_id_string(v230);
        v159 = nw_endpoint_handler_dry_run_string(v230);
        nw_endpoint_t v160 = nw_endpoint_handler_copy_endpoint(v230);
        v161 = nw_endpoint_get_logging_description(v160);
        id v162 = nw_endpoint_handler_state_string(v230);
        v163 = nw_endpoint_handler_mode_string(v230);
        id v164 = nw_endpoint_handler_copy_current_path(v230);
        *(_DWORD *)buf = 136449026;
        *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v158;
        *(_WORD *)&unsigned char buf[22] = 2082;
        v274 = (uint64_t (*)(uint64_t, uint64_t))v159;
        *(_WORD *)v275 = 2082;
        *(void *)&v275[2] = v161;
        *(_WORD *)&v275[10] = 2082;
        *(void *)&v275[12] = v162;
        __int16 v276 = 2082;
        char v277 = v163;
        __int16 v278 = 2114;
        id v279 = v164;
        __int16 v280 = 2048;
        *(void *)v281 = v38;
        *(_WORD *)&v281[8] = 2112;
        *(void *)&v281[10] = data;
        *(_WORD *)&v281[18] = 2048;
        *(void *)&v281[20] = v246;
        *(_WORD *)&v281[28] = 1024;
        *(_DWORD *)&v281[30] = v250;
        __int16 v282 = 1024;
        unsigned int v283 = v239;
        _os_log_impl(&dword_1830D4000, v157, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Skipping 0 length frame %p, aggregated_data %@, next_frame %p, aggregrated_amount_read %u, aggregated_data_length %u", buf, 0x72u);
      }
      unsigned int v64 = 0;
LABEL_232:
      handle = v249;
      os_log_type_t v46 = v254;
LABEL_233:
      unsigned int v42 = v45;
LABEL_234:
      if (v64 < v42) {
        goto LABEL_305;
      }
    }
LABEL_235:
    if (v46 && v243)
    {
      if (*v235 == v46)
      {
        *__int16 v235 = 0;
      }
      else
      {
        uint64_t v128 = *((void *)handle + 32);
        if (v128) {
          nw_dictionary_set_value(v128, out, 0);
        }
      }
    }
    uint64_t v129 = *(void *)(v38 + 32);
    uint64_t v130 = *(nw_frame ***)(v38 + 40);
    if (v129)
    {
      *(void *)(v129 + 40) = v130;
      uint64_t v130 = *(nw_frame ***)(v38 + 40);
    }
    else
    {
      v226->tqh_last = v130;
    }
    *uint64_t v130 = (nw_frame *)v129;
    *__int16 v237 = 0;
    *(void *)(v38 + 40) = 0;
    nw_frame_finalize(v38);
    int32x4_t v13 = v246;

    handle = v249;
    uint64_t v27 = (void *)*((void *)v249 + 27);
    if (!v27) {
      goto LABEL_346;
    }
    uint64_t v38 = (uint64_t)v13;
    alloCC_SHA256_CTX c = (uint64_t)data;
    uint64_t v37 = v235;
    if (!v13) {
      goto LABEL_347;
    }
  }
  unsigned int v64 = 0;
  if (!v63 || !v42) {
    goto LABEL_234;
  }
  unsigned int v64 = 0;
  int v65 = a5;
  if (!v246) {
    int v65 = 1;
  }
  int v228 = v65;
  BOOL v67 = v46 == &__block_literal_global_42249 || v46 == &__block_literal_global_10_42276;
  BOOL v233 = v67;
  BOOL v69 = v46 == &__block_literal_global_6_42258 || v46 == &__block_literal_global_8_42267;
  BOOL v231 = v69;
  size_t v70 = v42;
  while (2)
  {
    unsigned int v71 = nw_read_request_get_next_max_size(v63);
    unsigned int v72 = v71;
    if (!v71) {
      goto LABEL_234;
    }
    size_t v73 = v70;
    unsigned int v74 = v42 - v64;
    if (v42 - v64 >= v71) {
      size_t v75 = v71;
    }
    else {
      size_t v75 = v74;
    }
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v230) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      __int16 v107 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v107, OS_LOG_TYPE_DEBUG))
      {
        os_log_t log = v107;
        uint64_t v108 = nw_endpoint_handler_get_id_string(v230);
        char v218 = nw_endpoint_handler_dry_run_string(v230);
        nw_endpoint_t v216 = nw_endpoint_handler_copy_endpoint(v230);
        __int16 v109 = nw_endpoint_get_logging_description(v216);
        nw_endpoint_t v215 = nw_endpoint_handler_state_string(v230);
        v214 = nw_endpoint_handler_mode_string(v230);
        id v110 = nw_endpoint_handler_copy_current_path(v230);
        *(_DWORD *)buf = 136448770;
        *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v108;
        *(_WORD *)&unsigned char buf[22] = 2082;
        v274 = (uint64_t (*)(uint64_t, uint64_t))v218;
        *(_WORD *)v275 = 2082;
        *(void *)&v275[2] = v109;
        *(_WORD *)&v275[10] = 2082;
        *(void *)&v275[12] = v215;
        __int16 v276 = 2082;
        char v277 = v214;
        __int16 v278 = 2114;
        id v279 = v110;
        __int16 v280 = 1024;
        *(_DWORD *)v281 = v75;
        *(_WORD *)&v281[4] = 1024;
        *(_DWORD *)&v281[6] = v45;
        *(_WORD *)&v281[10] = 1024;
        *(_DWORD *)&v281[12] = v72;
        *(_WORD *)&v281[16] = 1024;
        *(_DWORD *)&v281[18] = v64;
        _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reading %u bytes out of a %u byte frame (max %u, %u so far)", buf, 0x60u);

        __int16 v107 = log;
      }

      handle = v249;
      os_log_type_t v46 = v254;
    }
    dispatch_data_t v76 = data;
    if (data)
    {
      if (v239 >= v250 && v75 <= v239 - v250)
      {
        memcpy((void *)(v269 + v250), &buffer[v64], v75);
        unint64_t v77 = v75;
        goto LABEL_152;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v120 = (id)gLogObj;
      *(_DWORD *)buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v75;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v239;
      LOWORD(v274) = 1024;
      *(_DWORD *)((char *)&v274 + 2) = v250;
      long long v121 = (void *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v271 = 0;
      if (__nwlog_fault((const char *)v121, &type, &v271))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v122 = (id)gLogObj;
          os_log_type_t v123 = type;
          if (os_log_type_enabled(v122, type))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v75;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v239;
            LOWORD(v274) = 1024;
            *(_DWORD *)((char *)&v274 + 2) = v250;
            _os_log_impl(&dword_1830D4000, v122, v123, "%{public}s Trying to write beyond buffer: %u > %u - %u", buf, 0x1Eu);
          }
          goto LABEL_218;
        }
        if (v271)
        {
          __int16 v131 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v132 = (id)gLogObj;
          os_log_type_t v133 = type;
          BOOL v134 = os_log_type_enabled(v132, type);
          if (v131)
          {
            if (v134)
            {
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v75;
              *(_WORD *)&buf[18] = 1024;
              *(_DWORD *)&buf[20] = v239;
              LOWORD(v274) = 1024;
              *(_DWORD *)((char *)&v274 + 2) = v250;
              HIWORD(v274) = 2082;
              *(void *)v275 = v131;
              _os_log_impl(&dword_1830D4000, v132, v133, "%{public}s Trying to write beyond buffer: %u > %u - %u, dumping backtrace:%{public}s", buf, 0x28u);
            }

            free(v131);
            os_log_type_t v46 = v254;
            if (!v121) {
              goto LABEL_263;
            }
LABEL_262:
            free(v121);
LABEL_263:
            handle = v249;
            goto LABEL_233;
          }
          if (v134)
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v75;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v239;
            LOWORD(v274) = 1024;
            *(_DWORD *)((char *)&v274 + 2) = v250;
            _os_log_impl(&dword_1830D4000, v132, v133, "%{public}s Trying to write beyond buffer: %u > %u - %u, no backtrace", buf, 0x1Eu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          v122 = (id)gLogObj;
          os_log_type_t v135 = type;
          if (os_log_type_enabled(v122, type))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v75;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v239;
            LOWORD(v274) = 1024;
            *(_DWORD *)((char *)&v274 + 2) = v250;
            _os_log_impl(&dword_1830D4000, v122, v135, "%{public}s Trying to write beyond buffer: %u > %u - %u, backtrace limit exceeded", buf, 0x1Eu);
          }
LABEL_218:
        }
      }
      os_log_type_t v46 = v254;
      if (v121) {
        goto LABEL_262;
      }
      goto LABEL_263;
    }
    if (nw_frame_buffer_used_malloc(v38)
      && (char *)nw_frame_get_buffer(v38, 0) == buffer
      && !v64
      && v75 == v45)
    {
      __int16 v78 = dispatch_data_create(buffer, v73, 0, v222);
      BOOL v79 = v78;
      if (data1 && v78)
      {
        os_log_type_t v80 = data1;
        dispatch_data_t concat = dispatch_data_create_concat(data1, v78);
      }
      else
      {
        dispatch_data_t concat = v78;
        os_log_type_t v80 = data1;
      }

      nw_frame_will_free_buffer_externally(v38);
      goto LABEL_148;
    }
    if (nw_frame_buffer_used_manager(v38)
      && (char *)nw_frame_get_buffer(v38, 0) == buffer
      && !v64
      && v75 == v45)
    {
      uint64_t finalizer_context = nw_frame_get_finalizer_context(v38);
      char v83 = is_inline;
      if (!finalizer_context) {
        char v83 = 1;
      }
      if ((v83 & 1) == 0)
      {
        uint64_t manager = nw_frame_buffer_get_manager(v38);
        nw_frame_will_free_buffer_externally(v38);
        BOOL v95 = nw_queue_copy_current_workloop();
        v263[0] = MEMORY[0x1E4F143A8];
        v263[1] = 3221225472;
        v263[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_84;
        v263[3] = &__block_descriptor_48_e5_v8__0l;
        v263[4] = manager;
        v263[5] = buffer;
        os_log_type_t v96 = dispatch_data_create(buffer, v73, (dispatch_queue_t)v95, v263);

        if (data1 && v96)
        {
          id v97 = data1;
          dispatch_data_t concat = dispatch_data_create_concat(data1, v96);
        }
        else
        {
          dispatch_data_t concat = v96;
          id v97 = data1;
        }

LABEL_148:
        unint64_t v77 = v73;
        goto LABEL_149;
      }
    }
    if (v64 || v75 != v45)
    {
      BOOL v91 = &buffer[v64];
      if (!data1)
      {
        *(void *)buf = 0;
        data1 = dispatch_data_create_alloc();
        memcpy(*(void **)buf, v91, v75);
        unint64_t v77 = v75;
        dispatch_data_t v76 = 0;
        goto LABEL_151;
      }
      *(void *)buf = 0;
      os_log_type_t v92 = dispatch_data_create_alloc();
      memcpy(*(void **)buf, v91, v75);
      dispatch_data_t concat = dispatch_data_create_concat(data1, v92);

      unint64_t v77 = v75;
LABEL_149:
      data1 = concat;
      goto LABEL_150;
    }
    if (is_inline
      || (uint64_t v84 = nw_frame_get_buffer_manager_with_context(*((void **)handle + 23), v45), *(void *)buf = 0, !v84))
    {
      *(void *)buf = 0;
    }
    else
    {
      uint64_t v85 = v84;
      BOOL v86 = nw_mem_buffer_allocate(v84);
      *(void *)buf = v86;
      if (v86)
      {
        BOOL v87 = (const void *)v86;
        BOOL v88 = nw_queue_copy_current_workloop();
        v262[0] = MEMORY[0x1E4F143A8];
        v262[1] = 3221225472;
        v262[2] = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_2_85;
        v262[3] = &__block_descriptor_48_e5_v8__0l;
        v262[4] = v85;
        v262[5] = *(void *)buf;
        uint64_t v89 = dispatch_data_create(v87, v73, (dispatch_queue_t)v88, v262);

        size_t v90 = v73;
        goto LABEL_136;
      }
    }
    size_t v90 = v73;
    uint64_t v89 = dispatch_data_create_alloc();
LABEL_136:
    memcpy(*(void **)buf, buffer, v90);
    if (data1)
    {
      dispatch_data_t v93 = dispatch_data_create_concat(data1, v89);

      data1 = v93;
    }
    else
    {
      data1 = v89;
    }

    unint64_t v77 = v73;
LABEL_150:
    dispatch_data_t v76 = 0;
    handle = v249;
LABEL_151:
    os_log_type_t v46 = v254;
LABEL_152:
    v248->received_application_byte_count += v77;
    if ((*((unsigned char *)v248 + 34) & 0x20) == 0) {
      nw_context_count_input_bytes(*((void **)handle + 23), v77);
    }
    v64 += v75;
    v250 += v75;
    if (v76)
    {
      unsigned int v42 = v45;
      if (v246 && v250 < v239) {
        goto LABEL_234;
      }
LABEL_161:
      if (v243) {
        BOOL v99 = v64 >= v42;
      }
      else {
        BOOL v99 = 0;
      }
      int v100 = v99;
      if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v230) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v111 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v111, OS_LOG_TYPE_DEBUG))
        {
          BOOL v112 = nw_endpoint_handler_get_id_string(v230);
          uint64_t v113 = nw_endpoint_handler_dry_run_string(v230);
          os_log_t loga = nw_endpoint_handler_copy_endpoint(v230);
          unsigned int v114 = nw_endpoint_get_logging_description(loga);
          id v219 = nw_endpoint_handler_state_string(v230);
          v217 = nw_endpoint_handler_mode_string(v230);
          id v115 = nw_endpoint_handler_copy_current_path(v230);
          *(_DWORD *)buf = 136448770;
          *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v112;
          *(_WORD *)&unsigned char buf[22] = 2082;
          v274 = (uint64_t (*)(uint64_t, uint64_t))v113;
          *(_WORD *)v275 = 2082;
          *(void *)&v275[2] = v114;
          *(_WORD *)&v275[10] = 2082;
          *(void *)&v275[12] = v219;
          __int16 v276 = 2082;
          char v277 = v217;
          __int16 v278 = 2114;
          id v279 = v115;
          __int16 v280 = 1024;
          *(_DWORD *)v281 = v100;
          *(_WORD *)&v281[4] = 1024;
          *(_DWORD *)&v281[6] = v243;
          *(_WORD *)&v281[10] = 1024;
          *(_DWORD *)&v281[12] = v64;
          *(_WORD *)&v281[16] = 1024;
          *(_DWORD *)&v281[18] = v45;
          _os_log_impl(&dword_1830D4000, v111, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] mark_complete: %u, context_complete: %u, amount_read: %u, frame_length: %u", buf, 0x60u);
        }
        os_log_type_t v46 = v254;
        dispatch_data_t v76 = data;
        handle = v249;
      }
      int v101 = (void *)*((void *)handle + 40);
      if (v101 && (*((unsigned char *)v248 + 36) & 1) != 0)
      {
        *((void *)handle + 40) = 0;

        uint64_t v102 = v248->last_error;
        v248->last_error = 0;

        handle = v249;
        *((unsigned char *)v248 + 36) &= ~1u;
        os_log_type_t v46 = v254;
        dispatch_data_t v76 = data;
      }
      if (v76)
      {
        request_receive = nw_read_request_receive(*((void **)handle + 27), v76, v46, v100, *((void **)handle + 40));
        goto LABEL_173;
      }
      if (data1)
      {
        request_receive = nw_read_request_receive(*((void **)handle + 27), data1, v46, v100, *((void **)handle + 40));
        dispatch_data_t v76 = data1;
        data1 = 0;
LABEL_173:

        handle = v249;
        os_log_type_t v46 = v254;
      }
      else
      {
        data1 = 0;
      }
      if (v46) {
        int v104 = v100;
      }
      else {
        int v104 = 0;
      }
      size_t v70 = v73;
      if (v104 == 1)
      {
        __int16 v105 = v46;
        if (v233)
        {

          handle = v249;
          os_log_type_t v46 = v254;
          size_t v70 = v73;
        }
        else if (v231)
        {

          handle = v249;
          os_log_type_t v46 = v254;
          size_t v70 = v73;
LABEL_183:
          *((_WORD *)handle + 166) |= 0x80u;
        }
        else
        {
          BOOL v106 = (BYTE6(v46[14].isa) & 1) == 0;

          handle = v249;
          os_log_type_t v46 = v254;
          size_t v70 = v73;
          if (!v106) {
            goto LABEL_183;
          }
        }
      }
      dispatch_data_t data = 0;
      os_log_type_t v63 = (void *)*((void *)handle + 27);
      if (!v63) {
        goto LABEL_233;
      }
      unsigned int v42 = v45;
      if (v64 >= v45) {
        goto LABEL_234;
      }
      continue;
    }
    break;
  }
  int v98 = v228;
  if (v74 >= v72) {
    int v98 = 1;
  }
  unsigned int v42 = v45;
  if (v98 == 1) {
    goto LABEL_161;
  }
  dispatch_data_t data = 0;
  if (v64 >= v45) {
    goto LABEL_235;
  }
LABEL_305:
  char v170 = nw_endpoint_handler_get_logging_disabled(v230);
  if (v46)
  {
    if ((v170 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      v172 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v172, OS_LOG_TYPE_DEBUG))
      {
        v173 = nw_endpoint_handler_get_id_string(v230);
        id v174 = nw_endpoint_handler_dry_run_string(v230);
        nw_endpoint_t v251 = nw_endpoint_handler_copy_endpoint(v230);
        id v175 = nw_endpoint_get_logging_description(v251);
        nw_endpoint_t v176 = nw_endpoint_handler_state_string(v230);
        os_log_type_t v177 = nw_endpoint_handler_mode_string(v230);
        id v178 = nw_endpoint_handler_copy_current_path(v230);
        *(_DWORD *)buf = 136448514;
        *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v173;
        *(_WORD *)&unsigned char buf[22] = 2082;
        v274 = (uint64_t (*)(uint64_t, uint64_t))v174;
        *(_WORD *)v275 = 2082;
        *(void *)&v275[2] = v175;
        *(_WORD *)&v275[10] = 2082;
        *(void *)&v275[12] = v176;
        __int16 v276 = 2082;
        char v277 = v177;
        __int16 v278 = 2114;
        id v279 = v178;
        __int16 v280 = 1024;
        *(_DWORD *)v281 = v64;
        *(_WORD *)&v281[4] = 1024;
        *(_DWORD *)&v281[6] = v45;
        *(_WORD *)&v281[10] = 2082;
        *(void *)&v281[12] = out;
        _os_log_impl(&dword_1830D4000, v172, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Could not read entire frame (requests only took %u, had %u), saving for context %{public}s", buf, 0x5Eu);
      }
      os_log_type_t v46 = v254;
    }
    nw_frame_claim(v38, v171, v64, 0);
    if (a7)
    {
      do
      {
        id v180 = (void *)(v38 + 32);
        nw_endpoint_t v179 = *(void **)(v38 + 32);
        if (!v179 && !*(void *)(v38 + 40)) {
          nw_endpoint_t v179 = 0;
        }
        id v181 = v179;

        if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v230) & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v247 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v247, OS_LOG_TYPE_DEBUG))
          {
            buffera = nw_endpoint_handler_get_id_string(v230);
            nw_endpoint_t v240 = nw_endpoint_handler_dry_run_string(v230);
            nw_endpoint_t v236 = nw_endpoint_handler_copy_endpoint(v230);
            id v238 = nw_endpoint_get_logging_description(v236);
            nw_endpoint_t v234 = nw_endpoint_handler_state_string(v230);
            v232 = nw_endpoint_handler_mode_string(v230);
            id v244 = nw_endpoint_handler_copy_current_path(v230);
            int v185 = nw_frame_unclaimed_length((_DWORD *)v38);
            *(_DWORD *)buf = 136448514;
            *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = buffera;
            *(_WORD *)&unsigned char buf[22] = 2082;
            v274 = (uint64_t (*)(uint64_t, uint64_t))v240;
            *(_WORD *)v275 = 2082;
            *(void *)&v275[2] = v238;
            *(_WORD *)&v275[10] = 2082;
            *(void *)&v275[12] = v234;
            __int16 v276 = 2082;
            char v277 = v232;
            __int16 v278 = 2114;
            id v279 = v244;
            __int16 v280 = 2048;
            *(void *)v281 = v38;
            *(_WORD *)&v281[8] = 1024;
            *(_DWORD *)&v281[10] = v185;
            *(_WORD *)&v281[14] = 2082;
            *(void *)&v281[16] = out;
            _os_log_impl(&dword_1830D4000, v247, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Saving frame %p of length %u for context %{public}s", buf, 0x62u);
          }
        }
        uint64_t v182 = *(void *)(v38 + 32);
        id v183 = *(nw_frame ***)(v38 + 40);
        if (v182)
        {
          *(void *)(v182 + 40) = v183;
          id v183 = *(nw_frame ***)(v38 + 40);
        }
        else
        {
          v226->tqh_last = v183;
        }
        const char *v183 = (nw_frame *)v182;
        *id v180 = 0;
        *(void *)(v38 + 40) = 0;
        __int16 v184 = (uint64_t *)*((void *)v249 + 35);
        *(void *)(v38 + 40) = v184;
        *__int16 v184 = v38;
        *((void *)v249 + 35) = v180;
        os_log_t v246 = (os_log_t)v181;

        uint64_t v38 = (uint64_t)v246;
      }
      while (v246);
      os_log_t v246 = 0;
      os_log_type_t v46 = v254;
    }
  }
  else
  {
    if ((v170 & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v188 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v188, OS_LOG_TYPE_ERROR))
      {
        nw_endpoint_t v189 = nw_endpoint_handler_get_id_string(v230);
        os_log_type_t v190 = nw_endpoint_handler_dry_run_string(v230);
        nw_endpoint_t v252 = nw_endpoint_handler_copy_endpoint(v230);
        BOOL v191 = nw_endpoint_get_logging_description(v252);
        os_log_type_t v192 = nw_endpoint_handler_state_string(v230);
        id v193 = nw_endpoint_handler_mode_string(v230);
        id v194 = nw_endpoint_handler_copy_current_path(v230);
        *(_DWORD *)buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v189;
        *(_WORD *)&unsigned char buf[22] = 2082;
        v274 = (uint64_t (*)(uint64_t, uint64_t))v190;
        *(_WORD *)v275 = 2082;
        *(void *)&v275[2] = v191;
        *(_WORD *)&v275[10] = 2082;
        *(void *)&v275[12] = v192;
        __int16 v276 = 2082;
        char v277 = v193;
        __int16 v278 = 2114;
        id v279 = v194;
        __int16 v280 = 1024;
        *(_DWORD *)v281 = v64;
        *(_WORD *)&v281[4] = 1024;
        *(_DWORD *)&v281[6] = v45;
        _os_log_impl(&dword_1830D4000, v188, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Could not read entire frame (requests only took %u, had %u)", buf, 0x54u);
      }
      os_log_type_t v46 = v254;
    }
    uint64_t v195 = *(void *)(v38 + 32);
    BOOL v196 = *(nw_frame ***)(v38 + 40);
    if (v195)
    {
      *(void *)(v195 + 40) = v196;
      BOOL v196 = *(nw_frame ***)(v38 + 40);
    }
    else
    {
      v226->tqh_last = v196;
    }
    *BOOL v196 = (nw_frame *)v195;
    *__int16 v237 = 0;
    *(void *)(v38 + 40) = 0;
    nw_frame_finalize(v38);
  }

  handle = v249;
  uint64_t v27 = (void *)*((void *)v249 + 27);
  int32x4_t v13 = v38;
LABEL_346:
  alloCC_SHA256_CTX c = (uint64_t)data;
LABEL_347:
  dispatch_data_t dataa = (dispatch_data_t)alloc;
  id v199 = nw_read_request_list_report(v27);
  os_log_type_t v200 = (void *)*((void *)handle + 27);
  *((void *)handle + 27) = v199;

  if (a7)
  {
    v201 = v226->tqh_first;
    if (v226->tqh_first)
    {
      *(void *)uuid_string_t out = 0;
      *(void *)&out[8] = out;
      *(_DWORD *)&out[24] = 0;
      *(void *)&out[16] = 0x2020000000;
      v258[0] = MEMORY[0x1E4F143A8];
      v258[1] = 3221225472;
      unsigned int v259 = ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_86;
      v260 = &unk_1E523CAC0;
      os_log_t v261 = out;
      do
      {
        if (!v201) {
          break;
        }
        nw_endpoint_t v202 = (nw_frame *)*((void *)v201 + 4);
        char v203 = ((uint64_t (*)(void *))v259)(v258);
        v201 = v202;
      }
      while ((v203 & 1) != 0);
      if ((nw_endpoint_handler_get_logging_disabled(v230) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        v204 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v204, OS_LOG_TYPE_ERROR))
        {
          os_log_type_t v205 = nw_endpoint_handler_get_id_string(v230);
          id v206 = nw_endpoint_handler_dry_run_string(v230);
          nw_endpoint_t v207 = nw_endpoint_handler_copy_endpoint(v230);
          v208 = nw_endpoint_get_logging_description(v207);
          nw_endpoint_t v209 = nw_endpoint_handler_state_string(v230);
          v210 = nw_endpoint_handler_mode_string(v230);
          id v211 = nw_endpoint_handler_copy_current_path(v230);
          int v212 = *(_DWORD *)(*(void *)&out[8] + 24);
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_flow_process_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v205;
          *(_WORD *)&unsigned char buf[22] = 2082;
          v274 = (uint64_t (*)(uint64_t, uint64_t))v206;
          *(_WORD *)v275 = 2082;
          *(void *)&v275[2] = v208;
          *(_WORD *)&v275[10] = 2082;
          *(void *)&v275[12] = v209;
          __int16 v276 = 2082;
          char v277 = v210;
          __int16 v278 = 2114;
          id v279 = v211;
          __int16 v280 = 1024;
          *(_DWORD *)v281 = v212;
          _os_log_impl(&dword_1830D4000, v204, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to use %u frames, marking as failed", buf, 0x4Eu);
        }
      }
      _Block_object_dispose(out, 8);
    }
  }

  os_log_type_t v198 = data1;
LABEL_360:

LABEL_361:
  return tqh_first != 0;
}

void sub_1831205FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,void *a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,void *a51,void *a52,void *a53,uint64_t a54,uint64_t a55,uint64_t a56,void *a57,void *a58)
{
  _Unwind_Resume(a1);
}

uint64_t nw_read_request_get_next_max_size(void *a1)
{
  id v1 = a1;
  if (!v1) {
    return 0;
  }
  id v2 = v1;
  uint64_t v3 = 0xFFFFFFFFLL;
  while (1)
  {
    BOOL v4 = (char *)v2;
    uint64_t v5 = v4;
    if (v4[176]) {
      goto LABEL_4;
    }
    int v6 = *((_DWORD *)v4 + 17);
    if ((v6 - 1) >= 2)
    {
      if (v6 == 3)
      {
        if (*((void *)v4 + 10) > *((void *)v4 + 11)) {
          goto LABEL_16;
        }
        goto LABEL_4;
      }
      if (v6 != 4) {
        goto LABEL_4;
      }
    }
    unint64_t v7 = *((void *)v4 + 10);
    unint64_t v8 = *((void *)v4 + 11);
    BOOL v9 = v7 >= v8;
    uint64_t v10 = v7 - v8;
    if (v10 != 0 && v9) {
      break;
    }
    if (*(_OWORD *)(v4 + 72) == 0)
    {
      uint64_t v3 = 0;
      goto LABEL_16;
    }
LABEL_4:
    id v2 = *((id *)v4 + 1);

    if (!v2) {
      return 0;
    }
  }
  if (v9) {
    uint64_t v3 = v10;
  }
  else {
    uint64_t v3 = 0;
  }
LABEL_16:

  return v3;
}

void nw_mem_buffer_free(uint64_t a1, unint64_t a2)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v23, &type, &v38)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer_manager";
      goto LABEL_74;
    }
    if (!v38)
    {
      BOOL v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
      goto LABEL_74;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v31 = os_log_type_enabled(v24, type);
    if (!backtrace_string)
    {
      if (!v31) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer_manager, no backtrace";
      goto LABEL_74;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null buffer_manager, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_75:
    if (!v23) {
      return;
    }
    goto LABEL_76;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (!__nwlog_fault(v23, &type, &v38)) {
      goto LABEL_75;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer";
      goto LABEL_74;
    }
    if (!v38)
    {
      BOOL v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_75;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_74;
    }
    int8x16_t v32 = (char *)__nw_create_backtrace_string();
    BOOL v24 = __nwlog_obj();
    os_log_type_t v25 = type;
    BOOL v33 = os_log_type_enabled(v24, type);
    if (v32)
    {
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v32;
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null buffer, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v32);
      if (!v23) {
        return;
      }
LABEL_76:
      free(v23);
      return;
    }
    if (v33)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
      BOOL v26 = "%{public}s called with null buffer, no backtrace";
LABEL_74:
      _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
      goto LABEL_75;
    }
    goto LABEL_75;
  }
  if (*(void *)(a1 + 88))
  {
    g_transaction_touched = 1;
    nw_mem_cache_update_set_timer();
    uint64_t v4 = *(void *)(a1 + 88);
    nw_mem_cache_operations_during_interval = 1;
    if ((*(unsigned char *)(v4 + 176) & 2) != 0)
    {
      uint64_t v27 = *(void *)(v4 + 288) + 8 * ((a2 >> *(void *)(v4 + 272)) & *(void *)(v4 + 280));
      while (1)
      {
        uint64_t v27 = *(void *)v27;
        if (!v27) {
          break;
        }
        if (*(void *)(v27 + 8) == a2)
        {
          *(void *)buf = 0;
          *(void *)&buf[8] = 0;
          gettimeofday((timeval *)buf, 0);
          *(void *)(v27 + 32) = 1000 * *(void *)buf + *(_DWORD *)&buf[8] / 1000;
          *(_DWORD *)(v27 + 44) = backtrace((void **)(v27 + 48), 16);
          goto LABEL_5;
        }
      }
      BOOL v28 = __nwlog_obj();
      os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_mem_audit_buf";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v4 + 96;
      __int16 v41 = 2048;
      unint64_t v42 = a2;
      int v29 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v29))
      {
LABEL_77:
        __break(1u);
        return;
      }
      free(v29);
      *(void *)buf = 0;
      *(void *)&buf[8] = 0;
      gettimeofday((timeval *)buf, 0);
      MEMORY[0x20] = 1000 * *(void *)buf + *(_DWORD *)&buf[8] / 1000;
      MEMORY[0x2C] = backtrace((void **)0x30, 16);
    }
LABEL_5:
    unsigned int v5 = *(_DWORD *)(v4 + 552);
    unsigned int v6 = *(_DWORD *)(v4 + 560);
    if (v5 < v6)
    {
LABEL_6:
      uint64_t v7 = *(void *)(v4 + 520);
      *(_DWORD *)(v4 + 552) = v5 + 1;
      *(void *)(v7 + 8 * (int)v5 + 8) = a2;
      ++*(void *)(v4 + 544);
      return;
    }
    while (1)
    {
      if (!*(_DWORD *)(v4 + 556))
      {
        *(_DWORD *)(v4 + 556) = v5;
        *(int8x16_t *)(v4 + 520) = vextq_s8(*(int8x16_t *)(v4 + 520), *(int8x16_t *)(v4 + 520), 8uLL);
LABEL_11:
        *(_DWORD *)(v4 + 552) = 0;
        goto LABEL_12;
      }
      if (!v6)
      {
        int32x4_t v22 = *(void (**)(unint64_t, void))(v4 + 192);
        if (v22) {
          v22(a2, *(void *)(v4 + 208));
        }
        nw_mem_slab_free(v4, a2);
        return;
      }
      BOOL v9 = *(void **)(v4 + 384);
      if (v9)
      {
        *(void *)(v4 + 384) = *v9;
        unsigned int v10 = *(_DWORD *)(v4 + 392) - 1;
        *(_DWORD *)(v4 + 392) = v10;
        if (v10 < *(_DWORD *)(v4 + 396)) {
          *(_DWORD *)(v4 + 396) = v10;
        }
        ++*(void *)(v4 + 376);
        char v11 = *(void **)(v4 + 528);
        if (v11)
        {
          *char v11 = *(void *)(v4 + 352);
          *(void *)(v4 + 352) = v11;
          ++*(_DWORD *)(v4 + 360);
        }
        *(void *)(v4 + 528) = *(void *)(v4 + 520);
        *(_DWORD *)(v4 + 556) = v5;
        *(void *)(v4 + 520) = v9;
        goto LABEL_11;
      }
      os_log_type_t v12 = *(int **)(v4 + 336);
      int32x4_t v13 = (malloc_zone_t *)g_slab_zone;
      size_t v14 = v12[1];
      uint64_t v15 = 8 * *v12;
      size_t v16 = v15 + 8;
      if (v15 == -8)
      {
        os_log_type_t v18 = __nwlog_obj();
        os_log_type_enabled(v18, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
        char v34 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort((uint64_t)v34)) {
          goto LABEL_77;
        }
        free(v34);
        if (v14 <= 7)
        {
LABEL_30:
          int v19 = __nwlog_obj();
          os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
          *(_WORD *)&unsigned char buf[12] = 2048;
          *(void *)&buf[14] = v14;
          uint64_t v35 = (void *)_os_log_send_and_compose_impl();
          if (__nwlog_abort((uint64_t)v35)) {
            goto LABEL_77;
          }
          free(v35);
        }
      }
      else if (v14 <= 7)
      {
        goto LABEL_30;
      }
      if ((v14 & (v14 - 1)) != 0)
      {
        unsigned int v20 = __nwlog_obj();
        os_log_type_enabled(v20, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v14;
        char v36 = (void *)_os_log_send_and_compose_impl();
        if (__nwlog_abort((uint64_t)v36)) {
          goto LABEL_77;
        }
        free(v36);
      }
      size_t v17 = malloc_type_zone_memalign(v13, v14, v16, 0xD927051FuLL);
      if (v17)
      {
        unsigned int v6 = *(_DWORD *)(v4 + 560);
        if (v6 != *v12)
        {
          malloc_zone_free((malloc_zone_t *)g_slab_zone, v17);
          unsigned int v6 = *(_DWORD *)(v4 + 560);
          goto LABEL_12;
        }
LABEL_26:
        void *v17 = *(void *)(v4 + 384);
        *(void *)(v4 + 384) = v17;
        ++*(_DWORD *)(v4 + 392);
        goto LABEL_12;
      }
      uint64_t v37 = __nwlog_obj();
      os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "strict_malloc_zone_memalign";
      *(_WORD *)&unsigned char buf[12] = 2048;
      *(void *)&buf[14] = v14;
      __int16 v41 = 2048;
      unint64_t v42 = v16;
      int32x4_t v21 = (void *)_os_log_send_and_compose_impl();
      if (__nwlog_abort((uint64_t)v21)) {
        goto LABEL_77;
      }
      free(v21);
      unsigned int v6 = *(_DWORD *)(v4 + 560);
      if (v6 == *v12) {
        goto LABEL_26;
      }
LABEL_12:
      unsigned int v5 = *(_DWORD *)(v4 + 552);
      if (v5 < v6) {
        goto LABEL_6;
      }
    }
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  unint64_t v8 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_mem_buffer_free";
    _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s buffer cache is NULL", buf, 0xCu);
  }
}

BOOL nw_mem_buffer_allocate(uint64_t a1)
{
  info[6] = *(mach_timebase_info *)MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    info[0].numer = 136446210;
    *(void *)&info[0].denom = "nw_mem_buffer_allocate";
    id v50 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v65) = 0;
    if (!__nwlog_fault(v50, type, &v65)) {
      goto LABEL_86;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v51 = __nwlog_obj();
      os_log_type_t v52 = type[0];
      if (!os_log_type_enabled(v51, type[0])) {
        goto LABEL_86;
      }
      info[0].numer = 136446210;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      os_log_type_t v53 = "%{public}s called with null buffer_manager";
    }
    else if ((_BYTE)v65)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v51 = __nwlog_obj();
      os_log_type_t v52 = type[0];
      BOOL v55 = os_log_type_enabled(v51, type[0]);
      if (backtrace_string)
      {
        if (v55)
        {
          info[0].numer = 136446466;
          *(void *)&info[0].denom = "nw_mem_buffer_allocate";
          LOWORD(info[1].denom) = 2082;
          *(void *)((char *)&info[1].denom + 2) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s called with null buffer_manager, dumping backtrace:%{public}s", (uint8_t *)info, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_86;
      }
      if (!v55)
      {
LABEL_86:
        if (v50) {
          free(v50);
        }
        return 0;
      }
      info[0].numer = 136446210;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      os_log_type_t v53 = "%{public}s called with null buffer_manager, no backtrace";
    }
    else
    {
      BOOL v51 = __nwlog_obj();
      os_log_type_t v52 = type[0];
      if (!os_log_type_enabled(v51, type[0])) {
        goto LABEL_86;
      }
      info[0].numer = 136446210;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      os_log_type_t v53 = "%{public}s called with null buffer_manager, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v51, v52, v53, (uint8_t *)info, 0xCu);
    goto LABEL_86;
  }
  if (!*(void *)(a1 + 88))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v9 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      info[0].numer = 136446466;
      *(void *)&info[0].denom = "nw_mem_buffer_allocate";
      LOWORD(info[1].denom) = 2082;
      *(void *)((char *)&info[1].denom + 2) = a1 + 96;
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s buffer cache is NULL for %{public}s", (uint8_t *)info, 0x16u);
    }
    return 0;
  }
  g_transaction_touched = 1;
  nw_mem_cache_update_set_timer();
  uint64_t v2 = *(void *)(a1 + 88);
  *(_OWORD *)os_log_type_t type = 0u;
  long long v68 = 0u;
  long long v65 = 0u;
  long long v66 = 0u;
  nw_mem_cache_operations_during_interval = 1;
  info[0] = 0;
  if (!mach_timebase_info(info))
  {
    uint64_t v3 = mach_absolute_time() * info[0].numer / info[0].denom;
    *(void *)&nw_mem_get_current_time::current_time = v3 / 0x3B9ACA00;
    *((void *)&nw_mem_get_current_time::current_time + 1) = v3 % 0x3B9ACA00;
    *(_OWORD *)(v2 + 408) = nw_mem_get_current_time::current_time;
  }
  int v4 = *(_DWORD *)(v2 + 552);
  if (v4 < 1)
  {
    int v11 = *(_DWORD *)(v2 + 556);
    while (1)
    {
      int v12 = v4;
      if (v11 >= 1)
      {
        unsigned int v5 = *(void **)(v2 + 528);
        *(void *)(v2 + 528) = *(void *)(v2 + 520);
        *(_DWORD *)(v2 + 556) = v4;
        *(void *)(v2 + 520) = v5;
        int v4 = v11;
        goto LABEL_7;
      }
      int v4 = *(_DWORD *)(v2 + 560);
      if (!v4) {
        break;
      }
      unsigned int v5 = *(void **)(v2 + 352);
      if (!v5) {
        break;
      }
      *(void *)(v2 + 352) = *v5;
      unsigned int v13 = *(_DWORD *)(v2 + 360) - 1;
      *(_DWORD *)(v2 + 360) = v13;
      if (v13 < *(_DWORD *)(v2 + 364)) {
        *(_DWORD *)(v2 + 364) = v13;
      }
      ++*(void *)(v2 + 344);
      size_t v14 = *(void **)(v2 + 528);
      if (v14)
      {
        void *v14 = *(void *)(v2 + 384);
        *(void *)(v2 + 384) = v14;
        ++*(_DWORD *)(v2 + 392);
      }
      *(void *)(v2 + 528) = *(void *)(v2 + 520);
      *(_DWORD *)(v2 + 556) = v12;
      *(void *)(v2 + 520) = v5;
      *(_DWORD *)(v2 + 552) = v4;
      int v11 = v12;
      if (v4 > 0) {
        goto LABEL_7;
      }
    }
    ++*(void *)(v2 + 48);
    uint64_t v15 = *(_DWORD **)(v2 + 296);
    if (v15)
    {
      LODWORD(v16) = v15[17];
    }
    else
    {
      uint64_t v17 = *(void *)(v2 + 216);
      unint64_t v18 = *(void *)(v17 + 120);
      unint64_t v19 = *(void *)(v2 + 248);
      uint64_t v70 = 0;
      uint64_t v71 = 0;
      uint64_t v69 = 0;
      BOOL v20 = nw_mem_region_alloc(v17, &v69, &v71, &v70, 1);
      if (!v20)
      {
        if (gLogDatapath)
        {
          os_log_type_t v63 = __nwlog_obj();
          if (os_log_type_enabled(v63, OS_LOG_TYPE_DEBUG))
          {
            info[0].numer = 136446210;
            *(void *)&info[0].denom = "nw_mem_slab_create";
            _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s nw mem region alloc failure", (uint8_t *)info, 0xCu);
          }
        }
        unint64_t v7 = 0;
        ++*(void *)v2;
        return v7;
      }
      BOOL v21 = v20;
      uint64_t v15 = malloc_type_zone_memalign((malloc_zone_t *)g_slab_zone, 8uLL, 0x48uLL, 0xD927051FuLL);
      if (!v15)
      {
        nw_endpoint_t v58 = __nwlog_obj();
        os_log_type_enabled(v58, OS_LOG_TYPE_ERROR);
        info[0].numer = 136446722;
        *(void *)&info[0].denom = "strict_malloc_zone_memalign";
        LOWORD(info[1].denom) = 2048;
        *(void *)((char *)&info[1].denom + 2) = 8;
        HIWORD(info[2].denom) = 2048;
        info[3] = (mach_timebase_info)72;
        os_log_type_t v59 = (void *)_os_log_send_and_compose_impl();
        BOOL result = __nwlog_abort((uint64_t)v59);
        if (result) {
          goto LABEL_99;
        }
        free(v59);
      }
      *((void *)v15 + 8) = 0;
      *((_OWORD *)v15 + 2) = 0u;
      *((_OWORD *)v15 + 3) = 0u;
      *(_OWORD *)uint64_t v15 = 0u;
      *((_OWORD *)v15 + 1) = 0u;
      *((void *)v15 + 2) = v2;
      *((void *)v15 + 3) = v21;
      uint64_t v22 = v69;
      unint64_t v23 = v19 / v18;
      v15[17] = v19 / v18;
      uint64_t v24 = v71;
      *((void *)v15 + 4) = v22;
      *((void *)v15 + 5) = v24;
      *((void *)v15 + 6) = v70;
      if ((nw_mem_debug & 2) != 0) {
        size_t v25 = 176;
      }
      else {
        size_t v25 = 40;
      }
      uint64_t v26 = (v19 / v18);
      if (v23)
      {
        uint64_t v27 = v21;
        do
        {
          BOOL v28 = malloc_type_zone_memalign((malloc_zone_t *)g_slab_zone, 8uLL, v25, 0xD927051FuLL);
          if (!v28)
          {
            int v29 = __nwlog_obj();
            os_log_type_enabled(v29, OS_LOG_TYPE_ERROR);
            info[0].numer = 136446722;
            *(void *)&info[0].denom = "strict_malloc_zone_memalign";
            LOWORD(info[1].denom) = 2048;
            *(void *)((char *)&info[1].denom + 2) = 8;
            HIWORD(info[2].denom) = 2048;
            info[3] = (mach_timebase_info)v25;
            unsigned int v64 = (void *)_os_log_send_and_compose_impl();
            BOOL result = __nwlog_abort((uint64_t)v64);
            if (result) {
              goto LABEL_99;
            }
            free(v64);
          }
          bzero(v28, v25);
          v28[1] = v27;
          v28[2] = v22;
          v28[3] = v15;
          *((_DWORD *)v28 + 8) = v15[17] - v26;
          void *v28 = *((void *)v15 + 7);
          *((void *)v15 + 7) = v28;
          v27 += v18;
          if (v22) {
            v22 += v18;
          }
          else {
            uint64_t v22 = 0;
          }
          --v26;
        }
        while (v26);
      }
      if (gLogDatapath)
      {
        os_log_type_t v60 = __nwlog_obj();
        if (os_log_type_enabled(v60, OS_LOG_TYPE_DEBUG))
        {
          info[0].numer = 136446722;
          *(void *)&info[0].denom = "nw_mem_slab_create";
          LOWORD(info[1].denom) = 2048;
          *(void *)((char *)&info[1].denom + 2) = v2;
          HIWORD(info[2].denom) = 2048;
          info[3] = (mach_timebase_info)v15;
          _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_DEBUG, "%{public}s nwm %p sl %p", (uint8_t *)info, 0x20u);
        }
        if (gLogDatapath)
        {
          os_log_type_t v61 = __nwlog_obj();
          if (os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
          {
            uint32_t v62 = *(_DWORD *)(*((void *)v15 + 5) + 40);
            info[0].numer = 136446978;
            *(void *)&info[0].denom = "nw_mem_slab_create";
            LOWORD(info[1].denom) = 1024;
            *(uint32_t *)((char *)&info[1].denom + 2) = v62;
            HIWORD(info[2].numer) = 2048;
            *(void *)&info[2].denom = v21;
            LOWORD(info[3].denom) = 2048;
            *(void *)((char *)&info[3].denom + 2) = v21 + v18;
            _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_DEBUG, "%{public}s   [%u] [%p-%p)", (uint8_t *)info, 0x26u);
          }
        }
      }
      ++*(void *)(v2 + 32);
      uint64_t v16 = v15[17];
      unint64_t v30 = *(void *)(v2 + 16);
      unint64_t v31 = *(void *)(v2 + 8) + v16;
      *(void *)(v2 + 8) = v31;
      if (v31 > v30) {
        *(void *)(v2 + 16) = v31;
      }
    }
    int v32 = v15[16];
    v15[16] = v32 + 1;
    BOOL v33 = (uint64_t *)*((void *)v15 + 7);
    uint64_t v34 = *v33;
    *((void *)v15 + 7) = *v33;
    unint64_t v7 = v33[1];
    uint64_t v35 = *(void *)(v2 + 240);
    *(void *)os_log_type_t type = v7;
    *(void *)&os_log_type_t type[8] = v35;
    uint64_t v36 = *((void *)v15 + 5);
    unsigned int v37 = *((_DWORD *)v33 + 8);
    unsigned int v38 = v37 + v16 * *(_DWORD *)(v36 + 40);
    *(void *)&long long v68 = __PAIR64__(v37, v38);
    *((void *)&v68 + 1) = v36;
    long long v65 = 0u;
    long long v66 = 0u;
    uint64_t v39 = v33[2];
    if (v39)
    {
      *(void *)&long long v65 = v33[2];
      *((void *)&v65 + 1) = v35;
      *(void *)&long long v66 = __PAIR64__(v37, v38);
      *((void *)&v66 + 1) = *((void *)v15 + 6);
    }
    uint64_t v40 = *(void *)(v2 + 288);
    uint64_t v41 = 8 * ((v7 >> *(void *)(v2 + 272)) & *(void *)(v2 + 280));
    uint64_t *v33 = *(void *)(v40 + v41);
    *(void *)(v40 + v41) = v33;
    if (v34)
    {
      if (v32)
      {
        if ((*(unsigned char *)(v2 + 176) & 2) == 0) {
          goto LABEL_51;
        }
        goto LABEL_68;
      }
      os_log_type_t v46 = (void *)(v2 + 296);
      uint64_t v47 = *(void *)(v2 + 296);
      *(void *)uint64_t v15 = v47;
      __uint64_t v48 = (void *)(v2 + 304);
    }
    else
    {
      if (v32)
      {
        uint64_t v44 = *(void *)v15;
        unsigned int v45 = (void *)*((void *)v15 + 1);
        if (*(void *)v15)
        {
          *(void *)(v44 + 8) = v45;
          unsigned int v45 = (void *)*((void *)v15 + 1);
        }
        else
        {
          *(void *)(v2 + 304) = v45;
        }
        *unsigned int v45 = v44;
      }
      os_log_type_t v46 = (void *)(v2 + 312);
      uint64_t v47 = *(void *)(v2 + 312);
      *(void *)uint64_t v15 = v47;
      __uint64_t v48 = (void *)(v2 + 320);
    }
    if (v47) {
      uint64_t v49 = (void *)(v47 + 8);
    }
    else {
      uint64_t v49 = v48;
    }
    void *v49 = v15;
    void *v46 = v15;
    *((void *)v15 + 1) = v46;
    if ((*(unsigned char *)(v2 + 176) & 2) == 0)
    {
LABEL_51:
      unint64_t v42 = *(unsigned int (**)(os_log_type_t *, long long *, void, uint64_t))(v2 + 184);
      if (!v42) {
        return v7;
      }
      goto LABEL_52;
    }
LABEL_68:
    info[0] = 0;
    info[1] = 0;
    gettimeofday((timeval *)info, 0);
    void v33[4] = 1000 * *(void *)info + (signed int)info[1].numer / 1000;
    *((_DWORD *)v33 + 11) = backtrace((void **)v33 + 6, 16);
    unint64_t v42 = *(unsigned int (**)(os_log_type_t *, long long *, void, uint64_t))(v2 + 184);
    if (!v42) {
      return v7;
    }
LABEL_52:
    if (v39) {
      uint64_t v43 = &v65;
    }
    else {
      uint64_t v43 = 0;
    }
    if (!v42(type, v43, *(void *)(v2 + 208), 1)) {
      return v7;
    }
    ++*(void *)v2;
    nw_mem_slab_free(v2, v7);
    return 0;
  }
  unsigned int v5 = *(void **)(v2 + 520);
LABEL_7:
  unsigned int v6 = v4 - 1;
  *(_DWORD *)(v2 + 552) = v6;
  unint64_t v7 = v5[v6 + 1];
  ++*(void *)(v2 + 536);
  if ((*(unsigned char *)(v2 + 176) & 2) == 0) {
    return v7;
  }
  uint64_t v8 = *(void *)(v2 + 288) + 8 * ((v7 >> *(void *)(v2 + 272)) & *(void *)(v2 + 280));
  while (1)
  {
    uint64_t v8 = *(void *)v8;
    if (!v8) {
      break;
    }
    if (*(void *)(v8 + 8) == v7)
    {
      info[0] = 0;
      info[1] = 0;
      gettimeofday((timeval *)info, 0);
      *(void *)(v8 + 32) = 1000 * *(void *)info + (signed int)info[1].numer / 1000;
      *(_DWORD *)(v8 + 44) = backtrace((void **)(v8 + 48), 16);
      return v7;
    }
  }
  os_log_type_t v56 = __nwlog_obj();
  os_log_type_enabled(v56, OS_LOG_TYPE_ERROR);
  info[0].numer = 136446722;
  *(void *)&info[0].denom = "nw_mem_audit_buf";
  LOWORD(info[1].denom) = 2082;
  *(void *)((char *)&info[1].denom + 2) = v2 + 96;
  HIWORD(info[2].denom) = 2048;
  info[3] = (mach_timebase_info)v7;
  os_log_type_t v57 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v57);
  if (!result)
  {
    free(v57);
    info[0] = 0;
    info[1] = 0;
    gettimeofday((timeval *)info, 0);
    MEMORY[0x20] = 1000 * *(void *)info + (signed int)info[1].numer / 1000;
    MEMORY[0x2C] = backtrace((void **)0x30, 16);
    return v7;
  }
LABEL_99:
  __break(1u);
  return result;
}

void nw_mem_cache_update_set_timer()
{
  if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
  {
    os_unfair_lock_lock((os_unfair_lock_t)&nw_mem_cache_lock);
    if ((nw_mem_cache_update_set_timer::cache_update_timer_set & 1) == 0)
    {
      uint64_t source = nw_mem_cache_update_source;
      if (nw_mem_cache_update_source
        || (id v1 = nw_context_copy_implicit_context(),
            uint64_t source = nw_queue_context_create_source(v1, 2, 3, 0, &__block_literal_global_55839, 0),
            (nw_mem_cache_update_uint64_t source = source) != 0))
      {
        dispatch_time_t v2 = dispatch_time(0x8000000000000000, 11000000000);
        nw_queue_set_timer_values(source, v2, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        nw_queue_activate_source(nw_mem_cache_update_source);
        nw_mem_cache_update_set_timer::cache_update_timer_set = 1;
      }
    }
    os_unfair_lock_unlock((os_unfair_lock_t)&nw_mem_cache_lock);
  }
}

void nw_frame_will_free_buffer_externally(uint64_t a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(void *)(a1 + 104))
    {
      *(void *)(a1 + 104) = 0;
      *(void *)(a1 + 112) = 0;
      return;
    }
    int v1 = *(unsigned __int16 *)(a1 + 204);
    int v2 = v1 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if (v1)
    {
      *(unsigned char *)(a1 + 206) = BYTE2(v2);
      *(_WORD *)(a1 + 204) = v2 & 0xFFFE;
      *(void *)(a1 + 112) = 0;
      return;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_frame_will_free_buffer_externally";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v3, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v18 = "nw_frame_will_free_buffer_externally";
        unsigned int v6 = "%{public}s Frame buffer cannot be freed externally";
        goto LABEL_17;
      }
      if (!v15)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v4 = gLogObj;
        os_log_type_t v5 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v18 = "nw_frame_will_free_buffer_externally";
        unsigned int v6 = "%{public}s Frame buffer cannot be freed externally, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v8 = gLogObj;
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v18 = "nw_frame_will_free_buffer_externally";
          __int16 v19 = 2082;
          BOOL v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Frame buffer cannot be freed externally, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
      }
      else if (v10)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v18 = "nw_frame_will_free_buffer_externally";
        unsigned int v6 = "%{public}s Frame buffer cannot be freed externally, no backtrace";
        int v11 = v8;
        os_log_type_t v12 = v9;
        goto LABEL_18;
      }
    }
LABEL_19:
    if (!v3) {
      return;
    }
    goto LABEL_20;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v18 = "nw_frame_will_free_buffer_externally";
  uint64_t v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v3, &type, &v15)) {
    goto LABEL_19;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_frame_will_free_buffer_externally";
    unsigned int v6 = "%{public}s called with null frame";
    goto LABEL_17;
  }
  if (!v15)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_frame_will_free_buffer_externally";
    unsigned int v6 = "%{public}s called with null frame, backtrace limit exceeded";
    goto LABEL_17;
  }
  unsigned int v13 = (char *)__nw_create_backtrace_string();
  int v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v14 = os_log_type_enabled(v4, type);
  if (!v13)
  {
    if (!v14) {
      goto LABEL_19;
    }
    *(_DWORD *)buf = 136446210;
    unint64_t v18 = "nw_frame_will_free_buffer_externally";
    unsigned int v6 = "%{public}s called with null frame, no backtrace";
LABEL_17:
    int v11 = v4;
    os_log_type_t v12 = v5;
LABEL_18:
    _os_log_impl(&dword_1830D4000, v11, v12, v6, buf, 0xCu);
    goto LABEL_19;
  }
  if (v14)
  {
    *(_DWORD *)buf = 136446466;
    unint64_t v18 = "nw_frame_will_free_buffer_externally";
    __int16 v19 = 2082;
    BOOL v20 = v13;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v13);
  if (v3) {
LABEL_20:
  }
    free(v3);
}

uint64_t nw_frame_buffer_used_malloc(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(_WORD *)(a1 + 204) & 1;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v11 = "nw_frame_buffer_used_malloc";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_frame_buffer_used_malloc";
        os_log_type_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          int v11 = "nw_frame_buffer_used_malloc";
          __int16 v12 = 2082;
          unsigned int v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_frame_buffer_used_malloc";
        os_log_type_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "nw_frame_buffer_used_malloc";
        os_log_type_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_context_count_input_bytes(void *a1, unint64_t a2)
{
  uint64_t v3 = a1;
  os_log_type_t v4 = v3;
  if (g_some_context_has_cap == 1)
  {
    nw_context_assert_queue(v3);
    BOOL v15 = nw_context_copy_globals_context(v4);

    uint64_t v3 = (NWConcrete_nw_context *)v15;
    uint64_t v5 = *(void *)(v15 + 32);
    unint64_t v6 = *(void *)(v5 + 76);
    if (v6)
    {
      BOOL v7 = v6 > a2;
      unint64_t v8 = v6 - a2;
      if (v7)
      {
        *(void *)(v5 + 76) = v8;
      }
      else
      {
        *(void *)(v5 + 76) = 0;
        os_log_type_t v9 = _Block_copy(*(const void **)(v5 + 92));
        uint64_t v10 = *(void *)(v15 + 32);
        int v11 = *(void **)(v10 + 84);
        *(void *)(v10 + 84) = 0;
        __int16 v12 = v11;

        uint64_t v13 = *(void *)(v15 + 32);
        uint64_t v14 = *(void **)(v13 + 92);
        *(void *)(v13 + 92) = 0;

        dispatch_async(v12, v9);
        uint64_t v3 = (NWConcrete_nw_context *)v15;
      }
    }
  }
}

void sub_183122728(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_queue_copy_current_workloop()
{
  uint64_t v0 = dispatch_workloop_copy_current();
  if (v0) {
    return v0;
  }
  int v2 = __nwlog_obj();
  os_log_type_enabled(v2, OS_LOG_TYPE_ERROR);
  uint64_t v3 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v3);
  if (!result)
  {
    free(v3);
    return v0;
  }
  __break(1u);
  return result;
}

BOOL nw_frame_buffer_used_manager(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 104) != 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v11 = "__nw_frame_buffer_used_manager";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "__nw_frame_buffer_used_manager";
        uint64_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          int v11 = "__nw_frame_buffer_used_manager";
          __int16 v12 = 2082;
          uint64_t v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "__nw_frame_buffer_used_manager";
        uint64_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "__nw_frame_buffer_used_manager";
        uint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

uint64_t nw_frame_buffer_get_manager(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 104);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v11 = "__nw_frame_buffer_get_manager";
  int v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "__nw_frame_buffer_get_manager";
        uint64_t v5 = "%{public}s called with null frame";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          int v11 = "__nw_frame_buffer_get_manager";
          __int16 v12 = 2082;
          uint64_t v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "__nw_frame_buffer_get_manager";
        uint64_t v5 = "%{public}s called with null frame, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        int v11 = "__nw_frame_buffer_get_manager";
        uint64_t v5 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

id nw_context_copy_implicit_context()
{
  if (nw_context_copy_implicit_context::onceToken != -1) {
    dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
  }
  uint64_t v0 = (void *)nw_context_copy_implicit_context::implicit_context;

  return v0;
}

NSObject *nw_read_request_receive(void *a1, void *a2, void *a3, int a4, void *a5)
{
  uint64_t v123 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  uint64_t v10 = a2;
  id obj = a3;
  id v11 = a3;
  id v86 = a5;
  id v90 = a5;
  if (v9)
  {
    int v85 = a4;
    int v89 = a4 ^ 1;
    LOBYTE(v12) = 1;
    while (1)
    {
      uint64_t v13 = (id *)v9;
      uint64_t v14 = v13;
      if (((_BYTE)v13[22] & 1) == 0) {
        break;
      }
LABEL_158:
      id v9 = v14[1];

      if (!v9) {
        goto LABEL_159;
      }
    }
    uint64_t v16 = v13 + 17;
    id v15 = v13[17];
    if (v15 != v11 && ((v15 == 0) & v12) == 0)
    {
LABEL_141:
      if (!v11 || *v16 == v11)
      {
        unsigned int v80 = *((_DWORD *)v14 + 17);
        BOOL v81 = v80 != 4 && v10 == 0;
        int v82 = v89;
        if (!v81) {
          int v82 = 1;
        }
        if (v82 != 1 || v80 == 4 && (v14[10] <= v14[11] || v85))
        {
          *((unsigned char *)v14 + 176) |= 2u;
          if (_nw_signposts_once != -1) {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
          }
          if (_nw_signposts_enabled && kdebug_is_enabled()) {
            kdebug_trace();
          }
        }
      }
      LOBYTE(v12) = (v10 != 0) | v12;
      goto LABEL_158;
    }
    objc_storeStrong(v13 + 17, obj);
    if (v90) {
      objc_storeStrong(v14 + 19, v86);
    }
    if (!v10)
    {
LABEL_140:
      LOBYTE(v12) = 0;
      goto LABEL_141;
    }
    size_t size = dispatch_data_get_size(v10);
    size_t v12 = size;
    if (!size) {
      goto LABEL_141;
    }
    unsigned int v19 = *((_DWORD *)v14 + 17);
    if (v19 - 1 >= 2)
    {
      if (v19 == 3)
      {
        if (v14[11] >= v14[10]) {
          goto LABEL_135;
        }
        nw_array_append((uint64_t)v14[20], v10);
        nw_array_append((uint64_t)v14[21], v11);
        v14[11] = (char *)v14[11] + 1;

        id v77 = v14[17];
        v14[17] = 0;

        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
        }
        if (!_nw_signposts_enabled)
        {
          uint64_t v10 = 0;
LABEL_137:
          if (_nw_signposts_enabled && kdebug_is_enabled()) {
            kdebug_trace();
          }
          goto LABEL_140;
        }
        if (kdebug_is_enabled())
        {
          uint64_t v10 = 0;
          kdebug_trace();
          goto LABEL_135;
        }
LABEL_120:
        uint64_t v10 = 0;
LABEL_135:
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
        }
        goto LABEL_137;
      }
      if (v19 != 4) {
        goto LABEL_135;
      }
      uint64_t v105 = 0;
      uint64_t v106 = (uint64_t)&v105;
      uint64_t v107 = 0x3032000000;
      uint64_t v108 = __Block_byref_object_copy__52816;
      __int16 v109 = __Block_byref_object_dispose__52817;
      BOOL v20 = v10;
      id v110 = v20;
      unint64_t v22 = (unint64_t)v14[10];
      unint64_t v21 = (unint64_t)v14[11];
      BOOL v23 = v22 >= v21;
      size_t v24 = v22 - v21;
      if (v24 == 0 || !v23)
      {
LABEL_119:

        _Block_object_dispose(&v105, 8);
        goto LABEL_120;
      }
      if (v23) {
        size_t v25 = v24;
      }
      else {
        size_t v25 = 0;
      }
      uint64_t v112 = 0;
      uint64_t v113 = &v112;
      uint64_t v114 = 0x2020000000;
      LOBYTE(v115) = 0;
      uint64_t v88 = MEMORY[0x1E4F143A8];
      uint64_t v26 = &v115;
      while (1)
      {
        uint64_t v98 = 0;
        BOOL v99 = &v98;
        int v101 = 0;
        uint64_t v100 = 0x2020000000;
        *(unsigned char *)uint64_t v26 = 0;
        uint64_t v27 = *(NSObject **)(v106 + 40);
        size_t v28 = dispatch_data_get_size(v27);
        size_t v29 = v28;
        applier[0] = v88;
        if (v25 >= v28) {
          int v30 = v28;
        }
        else {
          int v30 = v25;
        }
        applier[1] = 3221225472;
        applier[2] = __nw_read_request_receive_block_invoke;
        applier[3] = &unk_1E5243F10;
        int v97 = v30;
        unint64_t v31 = v14;
        os_log_type_t v92 = v31;
        dispatch_data_t v93 = &v105;
        os_log_type_t v94 = &v98;
        BOOL v95 = &v112;
        size_t v96 = v29;
        dispatch_data_apply(v27, applier);
        int v32 = (char *)v14[11] + *((unsigned int *)v99 + 6);
        v14[11] = v32;
        if (!v32 || ((_BYTE)v14[22] & 4) != 0) {
          goto LABEL_49;
        }
        BOOL v33 = v31;
        uint64_t v34 = v14[7];
        if (!v34)
        {
          os_log_type_t v59 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          id v120 = "nw_read_request_start_file_updates";
          os_log_type_t v60 = (char *)_os_log_send_and_compose_impl();

          LOBYTE(location) = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v60, &location, &type))
          {
            if (location == 17)
            {
              os_log_type_t v61 = __nwlog_obj();
              os_log_type_t v62 = location;
              if (os_log_type_enabled(v61, (os_log_type_t)location))
              {
                *(_DWORD *)buf = 136446210;
                id v120 = "nw_read_request_start_file_updates";
                _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s called with null request->connection", buf, 0xCu);
              }
              goto LABEL_87;
            }
            if (type)
            {
              backtrace_string = (char *)__nw_create_backtrace_string();
              unsigned int v64 = __nwlog_obj();
              os_log_type_t v65 = location;
              BOOL v66 = os_log_type_enabled(v64, (os_log_type_t)location);
              if (backtrace_string)
              {
                if (v66)
                {
                  *(_DWORD *)buf = 136446466;
                  id v120 = "nw_read_request_start_file_updates";
                  __int16 v121 = 2082;
                  *(void *)v122 = backtrace_string;
                  _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null request->connection, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(backtrace_string);
              }
              else
              {
                if (v66)
                {
                  *(_DWORD *)buf = 136446210;
                  id v120 = "nw_read_request_start_file_updates";
                  _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null request->connection, no backtrace", buf, 0xCu);
                }
              }
            }
            else
            {
              os_log_type_t v61 = __nwlog_obj();
              os_log_type_t v67 = location;
              if (os_log_type_enabled(v61, (os_log_type_t)location))
              {
                *(_DWORD *)buf = 136446210;
                id v120 = "nw_read_request_start_file_updates";
                _os_log_impl(&dword_1830D4000, v61, v67, "%{public}s called with null request->connection, backtrace limit exceeded", buf, 0xCu);
              }
LABEL_87:
            }
          }
          if (v60) {
            free(v60);
          }
          goto LABEL_48;
        }
        *((unsigned char *)v14 + 176) |= 4u;
        uint64_t v35 = v34[2];
        if (v35 && !nw_path_parameters_get_logging_disabled(*(void *)(v35 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v36 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
          {
            int v37 = *((_DWORD *)v14[7] + 112);
            id v38 = v14[12];
            *(_DWORD *)buf = 136446722;
            id v120 = "nw_read_request_start_file_updates";
            __int16 v121 = 1024;
            *(_DWORD *)v122 = v37;
            *(_WORD *)&v122[4] = 2112;
            *(void *)&v122[6] = v38;
            _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Activating progress updates on read request on %@", buf, 0x1Cu);
          }
        }
        uint64_t v39 = (uint64_t)v14[13];
        if (v39)
        {
          nw_queue_cancel_source(v39);
          v14[13] = 0;
        }
        objc_initWeak(&location, v33);
        uint64_t v40 = (void *)*((void *)v14[7] + 3);
        *(void *)uint64_t v116 = MEMORY[0x1E4F143A8];
        *(void *)&v116[8] = 3221225472;
        *(void *)&v116[16] = ___ZL34nw_read_request_start_file_updatesP26NWConcrete_nw_read_request_block_invoke;
        uint64_t v117 = &unk_1E5243FB0;
        objc_copyWeak(v118, &location);
        uint64_t source = nw_queue_context_create_source(v40, 2, 3, 0, v116, 0);
        v14[13] = (id)source;
        if (source)
        {
          dispatch_time_t v42 = dispatch_time(0x8000000000000000, 1000000);
          uint64_t v43 = 1000000 * *((unsigned int *)v14 + 28);
          if (*(void *)source)
          {
            dispatch_source_set_timer(*(dispatch_source_t *)source, v42, v43, 0x3E8uLL);
          }
          else
          {
            *(void *)(source + 32) = v42;
            *(void *)(source + 40) = v43;
            if (*(unsigned char *)(source + 48) && *(unsigned char *)(source + 49)) {
              nw_queue_source_run_timer(source);
            }
          }
          nw_queue_activate_source((uint64_t)v14[13]);
          goto LABEL_47;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        id v120 = "nw_read_request_start_file_updates";
        unsigned int v45 = (void *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v102 = 0;
        if (__nwlog_fault((const char *)v45, &type, &v102))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v46 = (id)gLogObj;
            os_log_type_t v47 = type;
            if (os_log_type_enabled(v46, type))
            {
              *(_DWORD *)buf = 136446210;
              id v120 = "nw_read_request_start_file_updates";
              _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed", buf, 0xCu);
            }
LABEL_44:

            goto LABEL_45;
          }
          if (!v102)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v46 = (id)gLogObj;
            os_log_type_t v58 = type;
            if (os_log_type_enabled(v46, type))
            {
              *(_DWORD *)buf = 136446210;
              id v120 = "nw_read_request_start_file_updates";
              _os_log_impl(&dword_1830D4000, v46, v58, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_44;
          }
          os_log_type_t v54 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v55 = (id)gLogObj;
          os_log_type_t v56 = type;
          BOOL v57 = os_log_type_enabled(v55, type);
          if (v54)
          {
            if (v57)
            {
              *(_DWORD *)buf = 136446466;
              id v120 = "nw_read_request_start_file_updates";
              __int16 v121 = 2082;
              *(void *)v122 = v54;
              _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v54);
            if (!v45) {
              goto LABEL_47;
            }
LABEL_46:
            free(v45);
            goto LABEL_47;
          }
          if (v57)
          {
            *(_DWORD *)buf = 136446210;
            id v120 = "nw_read_request_start_file_updates";
            _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s call to nw_queue_context_create_source(timer) for read request updates failed, no backtrace", buf, 0xCu);
          }
        }
LABEL_45:
        if (v45) {
          goto LABEL_46;
        }
LABEL_47:
        objc_destroyWeak(v118);
        objc_destroyWeak(&location);
LABEL_48:

LABEL_49:
        if (*((unsigned char *)v113 + 24))
        {
          if (*(void *)(v106 + 40))
          {
            uint64_t v48 = *((void *)v14[7] + 2);
            if (v48)
            {
              if (!nw_path_parameters_get_logging_disabled(*(void *)(v48 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v49 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v49, OS_LOG_TYPE_DEBUG))
                {
                  int v50 = *((_DWORD *)v14[7] + 112);
                  *(_DWORD *)uint64_t v116 = 136446466;
                  *(void *)&v116[4] = "nw_read_request_receive";
                  *(_WORD *)&v116[12] = 1024;
                  *(_DWORD *)&v116[14] = v50;
                  _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Retrying write to file descriptor, partial write without eof", v116, 0x12u);
                }
              }
            }
          }
        }
        unint64_t v52 = (unint64_t)v14[10];
        unint64_t v51 = (unint64_t)v14[11];
        BOOL v23 = v52 >= v51;
        size_t v53 = v52 - v51;
        if (v23) {
          size_t v25 = v53;
        }
        else {
          size_t v25 = 0;
        }
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
        }
        if (_nw_signposts_enabled && kdebug_is_enabled()) {
          kdebug_trace();
        }

        _Block_object_dispose(&v98, 8);
        uint64_t v26 = v113 + 3;
        if (!*((unsigned char *)v113 + 24))
        {
          _Block_object_dispose(&v112, 8);
          goto LABEL_119;
        }
      }
    }
    unint64_t v69 = (unint64_t)v14[10];
    unint64_t v68 = (unint64_t)v14[11];
    BOOL v23 = v69 >= v68;
    size_t v71 = v69 - v68;
    BOOL v70 = v71 != 0 && v23;
    if (!v23) {
      size_t v71 = 0;
    }
    if (!v70) {
      goto LABEL_135;
    }
    if (v71 >= size) {
      size_t v72 = size;
    }
    else {
      size_t v72 = v71;
    }
    if (v19 == 2)
    {
      uint64_t v78 = (uint64_t)v14[15] + v68;
      *(void *)uint64_t v116 = 0;
      *(void *)&v116[8] = v116;
      *(void *)&v116[16] = 0x2000000000;
      uint64_t v117 = 0;
      uint64_t v112 = 0;
      uint64_t v113 = &v112;
      uint64_t v114 = 0x2000000000;
      uint64_t v115 = v78;
      uint64_t v105 = MEMORY[0x1E4F143A8];
      uint64_t v106 = 0x40000000;
      uint64_t v107 = (uint64_t)__nw_dispatch_data_copyout_block_invoke;
      uint64_t v108 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E5242B60;
      id v110 = &v112;
      size_t v111 = v72;
      __int16 v109 = (void (*)(uint64_t))v116;
      dispatch_data_apply(v10, &v105);
      size_t v72 = *(void *)(*(void *)&v116[8] + 24);
      _Block_object_dispose(&v112, 8);
      _Block_object_dispose(v116, 8);
      if (v12 == v72)
      {
        dispatch_data_t subrange = 0;
        size_t v72 = v12;
      }
      else
      {
        dispatch_data_t subrange = dispatch_data_create_subrange(v10, v72, v12 - v72);
      }
      goto LABEL_129;
    }
    if (v19 != 1)
    {
      size_t v72 = 0;
LABEL_130:
      v14[11] = (char *)v14[11] + v72;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
      }
      if (!_nw_signposts_enabled) {
        goto LABEL_137;
      }
      if (kdebug_is_enabled()) {
        kdebug_trace();
      }
      goto LABEL_135;
    }
    if (size <= v71)
    {
      dispatch_data_t subrange = 0;
      size_t v75 = v14[16];
      if (!v75) {
        goto LABEL_112;
      }
    }
    else
    {
      dispatch_data_t v73 = dispatch_data_create_subrange(v10, 0, v72);
      dispatch_data_t subrange = dispatch_data_create_subrange(v10, v72, v12 - v72);

      uint64_t v10 = v73;
      size_t v75 = v14[16];
      if (!v75)
      {
LABEL_112:
        dispatch_data_t concat = v10;
LABEL_127:
        id v79 = v14[16];
        v14[16] = concat;

LABEL_129:
        uint64_t v10 = subrange;
        goto LABEL_130;
      }
    }
    dispatch_data_t concat = dispatch_data_create_concat(v75, v10);
    goto LABEL_127;
  }
LABEL_159:
  char v83 = v10;

  return v83;
}

void sub_183123C40(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,id *location,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,void *a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,id a48,uint64_t a49,char a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,uint64_t a55,uint64_t a56,char a57)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_is_multicast(void *a1)
{
  *(void *)&v43[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  int v2 = v1;
  if (!v1)
  {
    size_t v29 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v41 = "nw_endpoint_is_multicast";
    int v30 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v30, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unint64_t v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_endpoint_is_multicast";
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unint64_t v31 = __nwlog_obj();
        os_log_type_t v34 = type;
        BOOL v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v41 = "nw_endpoint_is_multicast";
            __int16 v42 = 2082;
            *(void *)uint64_t v43 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_endpoint_is_multicast";
          _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unint64_t v31 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v41 = "nw_endpoint_is_multicast";
          _os_log_impl(&dword_1830D4000, v31, v36, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_50:
    if (!v30) {
      goto LABEL_32;
    }
    uint64_t v27 = (char *)v30;
    goto LABEL_31;
  }
  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    id v9 = v3;
    int v10 = [v9 type];

    *(_DWORD *)buf = 136446466;
    uint64_t v41 = "nw_endpoint_is_multicast";
    __int16 v42 = 1024;
    *(_DWORD *)uint64_t v43 = v10;
    LODWORD(v37) = 18;
    id v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v11, &type, &v38))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          id v14 = v9;
          int v15 = objc_msgSend(v14, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          uint64_t v41 = "nw_endpoint_is_multicast";
          __int16 v42 = 1024;
          *(_DWORD *)uint64_t v43 = v15;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v38)
      {
        uint64_t v16 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v12 = (id)gLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v12, type);
        if (v16)
        {
          if (v18)
          {
            id v19 = v9;
            int v20 = objc_msgSend(v19, "type", buf, v37);

            *(_DWORD *)buf = 136446722;
            uint64_t v41 = "nw_endpoint_is_multicast";
            __int16 v42 = 1024;
            *(_DWORD *)uint64_t v43 = v20;
            v43[2] = 2082;
            *(void *)&v43[3] = v16;
            _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v16);
          if (!v11) {
            goto LABEL_32;
          }
LABEL_30:
          uint64_t v27 = (char *)v11;
LABEL_31:
          free(v27);
          goto LABEL_32;
        }
        if (v18)
        {
          id v25 = v9;
          int v26 = objc_msgSend(v25, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          uint64_t v41 = "nw_endpoint_is_multicast";
          __int16 v42 = 1024;
          *(_DWORD *)uint64_t v43 = v26;
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        size_t v12 = (id)gLogObj;
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          id v23 = v9;
          int v24 = objc_msgSend(v23, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          uint64_t v41 = "nw_endpoint_is_multicast";
          __int16 v42 = 1024;
          *(_DWORD *)uint64_t v43 = v24;
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v11)
    {
LABEL_32:
      uint64_t v21 = 0;
      goto LABEL_33;
    }
    goto LABEL_30;
  }
  uint64_t v5 = v3;
  int v6 = *((unsigned __int8 *)v5 + 233);
  if (v6 == 30)
  {
    BOOL v7 = *((unsigned __int8 *)v5 + 240) == 255;
LABEL_18:
    uint64_t v21 = v7;
    goto LABEL_22;
  }
  if (v6 == 2)
  {
    BOOL v7 = (v5[59] & 0xF0) == 224;
    goto LABEL_18;
  }
  uint64_t v21 = 0;
LABEL_22:

LABEL_33:
  return v21;
}

void sub_183124304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

xpc_object_t NWUtilsCreateXPCDictionaryFromNSDictionary(void *a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  xpc_object_t xdict = xpc_dictionary_create(0, 0, 0);
  long long v33 = 0u;
  long long v34 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  id v2 = v1;
  uint64_t v3 = [v2 countByEnumeratingWithState:&v33 objects:v43 count:16];
  if (v3)
  {
    uint64_t v5 = v3;
    int v6 = @"INT64-";
    unint64_t v7 = 0x1E4F1C000uLL;
    uint64_t v8 = *(void *)v34;
    *(void *)&long long v4 = 136446722;
    long long v30 = v4;
    id v9 = @"UINT64-";
    do
    {
      for (uint64_t i = 0; i != v5; ++i)
      {
        if (*(void *)v34 != v8) {
          objc_enumerationMutation(v2);
        }
        id v11 = *(id *)(*((void *)&v33 + 1) + 8 * i);
        if ([v11 hasPrefix:v6])
        {
          size_t v12 = v6;
LABEL_17:
          objc_msgSend(v11, "substringFromIndex:", -[__CFString length](v12, "length", v30));
          id v13 = (id)objc_claimAutoreleasedReturnValue();
          goto LABEL_18;
        }
        if ([v11 hasPrefix:@"DOUBLE-"])
        {
          size_t v12 = @"DOUBLE-";
          goto LABEL_17;
        }
        if ([v11 hasPrefix:@"UINT64-"]
          || (id v9 = @"BOOL-", [v11 hasPrefix:@"BOOL-"]))
        {
          size_t v12 = v9;
          goto LABEL_17;
        }
        id v13 = v11;
LABEL_18:
        id v14 = v13;

        int v15 = [v2 objectForKeyedSubscript:v11];
        objc_opt_class();
        if (objc_opt_isKindOfClass())
        {
          xpc_object_t XPCArrayFromNSArray = NWUtilsCreateXPCArrayFromNSArray(v11, v15);
          if (!XPCArrayFromNSArray) {
            goto LABEL_26;
          }
        }
        else
        {
          os_log_type_t v32 = v14;
          uint64_t v18 = v5;
          uint64_t v19 = v8;
          int v20 = v6;
          unint64_t v21 = v7;
          id v22 = v15;
          objc_opt_class();
          isKindOfClass Class = objc_opt_isKindOfClass();

          if (isKindOfClass) {
            uint64_t XPCDictionaryFromNSDictionary = NWUtilsCreateXPCDictionaryFromNSDictionary(v22);
          }
          else {
            uint64_t XPCDictionaryFromNSDictionary = NWUtilsCreateXPCObjectFromSimpleNSObject(v11, v22);
          }
          xpc_object_t XPCArrayFromNSArray = (xpc_object_t)XPCDictionaryFromNSDictionary;
          unint64_t v7 = v21;
          int v6 = v20;
          uint64_t v8 = v19;
          uint64_t v5 = v18;
          id v14 = v32;
          if (!XPCDictionaryFromNSDictionary)
          {
LABEL_26:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v25 = (id)gLogObj;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              char v38 = "NWUtilsCreateXPCDictionaryFromNSDictionary";
              __int16 v39 = 2114;
              uint64_t v40 = v15;
              int v26 = v25;
              uint64_t v27 = "%{public}s Could not create xpc object for %{public}@";
              uint32_t v28 = 22;
              goto LABEL_5;
            }
LABEL_6:

            goto LABEL_7;
          }
        }
        os_log_type_t v17 = (const char *)objc_msgSend(v14, "UTF8String", v30);
        if (!v17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v25 = (id)gLogObj;
          if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = v30;
            char v38 = "NWUtilsCreateXPCDictionaryFromNSDictionary";
            __int16 v39 = 2114;
            uint64_t v40 = v14;
            __int16 v41 = 2114;
            __int16 v42 = v15;
            int v26 = v25;
            uint64_t v27 = "%{public}s Could not parse trimmed key %{public}@ for %{public}@";
            uint32_t v28 = 32;
LABEL_5:
            _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, v27, buf, v28);
          }
          goto LABEL_6;
        }
        xpc_dictionary_set_value(xdict, v17, XPCArrayFromNSArray);
LABEL_7:

        id v9 = @"UINT64-";
      }
      uint64_t v5 = [v2 countByEnumeratingWithState:&v33 objects:v43 count:16];
    }
    while (v5);
  }

  return xdict;
}

uint64_t nw_path_struct_size_for_endpoint_and_metadata(void *a1, unint64_t *a2, char a3)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  nw_endpoint_type_t v6 = nw_endpoint_get_type(v5);
  nw_txt_record_t v7 = nw_endpoint_copy_txt_record(v5);
  switch(v6)
  {
    case nw_endpoint_type_address:
      address = nw_endpoint_get_address(v5);
      if (a2)
      {
        if (address) {
          unint64_t sa_len = address->sa_len;
        }
        else {
          unint64_t sa_len = 0;
        }
        *a2 = sa_len;
      }
      if (address)
      {
        unint64_t v9 = address->sa_len;
        if (!v7) {
          goto LABEL_77;
        }
      }
      else
      {
        unint64_t v9 = 0;
        if (!v7)
        {
LABEL_77:
          if (a2) {
            goto LABEL_5;
          }
          goto LABEL_6;
        }
      }
      unint64_t v9 = (unint64_t)v7[2].isa + 28;
      goto LABEL_77;
    case nw_endpoint_type_host:
    case nw_endpoint_type_url|nw_endpoint_type_address:
      BOOL domain_for_policy = nw_endpoint_get_domain_for_policy(v5);
      if (domain_for_policy)
      {
        unint64_t v9 = strlen((const char *)domain_for_policy) + 9;
        if (v7) {
          goto LABEL_4;
        }
      }
      else
      {
        unint64_t v9 = 9;
        if (v7)
        {
LABEL_4:
          v9 += (unint64_t)v7[2].isa;
          if (!a2) {
            goto LABEL_6;
          }
          goto LABEL_5;
        }
      }
      if (a2) {
        goto LABEL_5;
      }
      goto LABEL_6;
    case nw_endpoint_type_bonjour_service:
      bonjour_service_name = nw_endpoint_get_bonjour_service_name(v5);
      bonjour_service_os_log_type_t type = nw_endpoint_get_bonjour_service_type(v5);
      bonjour_service_domain = nw_endpoint_get_bonjour_service_domain(v5);
      if (bonjour_service_name)
      {
        size_t v29 = strlen(bonjour_service_name) + 9;
        if (bonjour_service_type) {
          goto LABEL_40;
        }
      }
      else
      {
        size_t v29 = 9;
        if (bonjour_service_type)
        {
LABEL_40:
          size_t v30 = strlen(bonjour_service_type) + 1;
          if (bonjour_service_domain) {
            goto LABEL_41;
          }
          goto LABEL_60;
        }
      }
      size_t v30 = 1;
      if (bonjour_service_domain)
      {
LABEL_41:
        size_t v31 = strlen(bonjour_service_domain) + 1;
        if (v7)
        {
LABEL_42:
          Class isa = v7[2].isa;
          goto LABEL_62;
        }
LABEL_61:
        Class isa = 0;
LABEL_62:
        unint64_t v9 = (unint64_t)isa + v31 + v30 + v29;
        if (!a2) {
          goto LABEL_6;
        }
LABEL_5:
        *a2 = v9;
LABEL_6:
        if (v9 <= 0x1C) {
          uint64_t v10 = 28;
        }
        else {
          uint64_t v10 = v9;
        }
        goto LABEL_9;
      }
LABEL_60:
      size_t v31 = 1;
      if (v7) {
        goto LABEL_42;
      }
      goto LABEL_61;
    case nw_endpoint_type_url:
      url = nw_endpoint_get_url(v5);
      if (url)
      {
        unint64_t v9 = strlen(url) + 9;
        if (a2) {
          goto LABEL_5;
        }
      }
      else
      {
        unint64_t v9 = 9;
        if (a2) {
          goto LABEL_5;
        }
      }
      goto LABEL_6;
    case nw_endpoint_type_url|nw_endpoint_type_host:
      application_service_alias = (const char *)nw_endpoint_get_application_service_alias(v5);
      application_service_name = (const char *)nw_endpoint_get_application_service_name(v5);
      nw_endpoint_get_service_identifier(v5, uu);
      device_name = (const char *)nw_endpoint_get_device_name(v5);
      device_model = (const char *)nw_endpoint_get_device_model(v5);
      contact_id = (const char *)nw_endpoint_get_contact_id(v5);
      if (application_service_alias)
      {
        size_t v38 = strlen(application_service_alias) + 9;
        if (application_service_name) {
          goto LABEL_45;
        }
      }
      else
      {
        size_t v38 = 9;
        if (application_service_name)
        {
LABEL_45:
          size_t v39 = strlen(application_service_name) + 1;
          if (device_name) {
            goto LABEL_46;
          }
          goto LABEL_66;
        }
      }
      size_t v39 = 1;
      if (device_name)
      {
LABEL_46:
        size_t v40 = strlen(device_name) + 1;
        if (device_model) {
          goto LABEL_47;
        }
        goto LABEL_67;
      }
LABEL_66:
      size_t v40 = 1;
      if (device_model)
      {
LABEL_47:
        size_t v41 = strlen(device_model) + 1;
        if (contact_id) {
          goto LABEL_48;
        }
        goto LABEL_68;
      }
LABEL_67:
      size_t v41 = 1;
      if (contact_id)
      {
LABEL_48:
        size_t v42 = strlen(contact_id) + 1;
        if (v7)
        {
LABEL_49:
          Class v43 = v7[2].isa;
          goto LABEL_70;
        }
LABEL_69:
        Class v43 = 0;
LABEL_70:
        unint64_t v9 = (unint64_t)v43 + v42 + v38 + v39 + v40 + v41 + 24;
        if (!a2) {
          goto LABEL_6;
        }
        goto LABEL_5;
      }
LABEL_68:
      size_t v42 = 1;
      if (v7) {
        goto LABEL_49;
      }
      goto LABEL_69;
    default:
      if (!nw_endpoint_is_custom_type(v5)) {
        goto LABEL_101;
      }
      custom_data_size_t length = nw_endpoint_get_custom_data_length(v5);
      if (!custom_data_length) {
        goto LABEL_101;
      }
      if (custom_data_length <= 0x400)
      {
        char v45 = -9;
        if (custom_data_length < 0xF7) {
          char v45 = custom_data_length;
        }
        unsigned __int8 v46 = v45 + 8;
        if (a2) {
          *a2 = v46;
        }
        if (v46 <= 0x1Cu) {
          uint64_t v10 = 28;
        }
        else {
          uint64_t v10 = v46;
        }
        goto LABEL_9;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      *(_DWORD *)uu = 136446466;
      *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
      *(_WORD *)&uu[12] = 1024;
      *(_DWORD *)&uu[14] = 1024;
      LODWORD(v52) = 18;
      unint64_t v51 = uu;
      unint64_t v21 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v57 = 0;
      if (!__nwlog_fault(v21, &type, &v57)) {
        goto LABEL_99;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)uu = 136446466;
          *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s Custom data size must be no larger than %d", uu, 0x12u);
        }
LABEL_98:

        goto LABEL_99;
      }
      if (!v57)
      {
        id v22 = __nwlog_obj();
        os_log_type_t v50 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)uu = 136446466;
          *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl(&dword_1830D4000, v22, v50, "%{public}s Custom data size must be no larger than %d, backtrace limit exceeded", uu, 0x12u);
        }
        goto LABEL_98;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v22 = __nwlog_obj();
      os_log_type_t v48 = type;
      BOOL v49 = os_log_type_enabled(v22, type);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)uu = 136446466;
          *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
          *(_WORD *)&uu[12] = 1024;
          *(_DWORD *)&uu[14] = 1024;
          _os_log_impl(&dword_1830D4000, v22, v48, "%{public}s Custom data size must be no larger than %d, no backtrace", uu, 0x12u);
        }
        goto LABEL_98;
      }
      if (v49)
      {
        *(_DWORD *)uu = 136446722;
        *(void *)&uu[4] = "nw_path_struct_size_for_endpoint";
        *(_WORD *)&uu[12] = 1024;
        *(_DWORD *)&uu[14] = 1024;
        __int16 v61 = 2082;
        os_log_type_t v62 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v22, v48, "%{public}s Custom data size must be no larger than %d, dumping backtrace:%{public}s", uu, 0x1Cu);
      }

      free(backtrace_string);
LABEL_99:
      if (v21) {
        free(v21);
      }
LABEL_101:
      uint64_t v10 = 28;
LABEL_9:

      uint64_t v11 = v10 + 5;
      if (a3)
      {
        *(void *)uu = 0;
        *(void *)&uu[8] = 0;
        nw_endpoint_get_agent_identifier(v5, uu);
        if (!uuid_is_null(uu)) {
          uint64_t v11 = v10 + 26;
        }
      }
      if ((a3 & 2) != 0)
      {
        device_id = (const char *)nw_endpoint_get_device_id(v5);
        if (device_id) {
          size_t v13 = strlen(device_id) + 5;
        }
        else {
          size_t v13 = 0;
        }
        v11 += v13;
      }
      if ((a3 & 4) != 0)
      {
        long long v55 = 0u;
        long long v56 = 0u;
        long long v53 = 0u;
        long long v54 = 0u;
        id v14 = nw_endpoint_copy_public_keys(v5);
        uint64_t v15 = [v14 countByEnumeratingWithState:&v53 objects:v59 count:16];
        if (v15)
        {
          uint64_t v16 = *(void *)v54;
          do
          {
            for (uint64_t i = 0; i != v15; ++i)
            {
              if (*(void *)v54 != v16) {
                objc_enumerationMutation(v14);
              }
              v11 += objc_msgSend(*(id *)(*((void *)&v53 + 1) + 8 * i), "length", v51, v52) + 5;
            }
            uint64_t v15 = [v14 countByEnumeratingWithState:&v53 objects:v59 count:16];
          }
          while (v15);
        }
      }
      return v11;
  }
}

void sub_1831256A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_copy_properties(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  long long v4 = a2;
  uint64_t v5 = v4;
  if (!v4)
  {
    uint64_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v28 = "nw_endpoint_copy_properties";
    size_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v12, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        size_t v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null copy", buf, 0xCu);
        }
      }
      else if (v25)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        size_t v13 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)buf = 136446466;
            uint32_t v28 = "nw_endpoint_copy_properties";
            __int16 v29 = 2082;
            size_t v30 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null copy, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null copy, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        size_t v13 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          uint32_t v28 = "nw_endpoint_copy_properties";
          _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null copy, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_28:
    if (v12) {
      free(v12);
    }
    goto LABEL_7;
  }
  *((_WORD *)v4 + 114) = *((_WORD *)v3 + 114);
  objc_storeStrong(v4 + 2, *((id *)v3 + 2));
  *((_DWORD *)v5 + 6) = *((_DWORD *)v3 + 6);
  objc_storeStrong(v5 + 23, *((id *)v3 + 23));
  objc_storeStrong(v5 + 24, *((id *)v3 + 24));
  *(_OWORD *)((char *)v5 + 28) = *(_OWORD *)(v3 + 28);
  objc_storeStrong(v5 + 1, *((id *)v3 + 1));
  char v6 = v3[231] & 1 | *((unsigned char *)v5 + 231);
  *((unsigned char *)v5 + 231) = v6;
  *((unsigned char *)v5 + 231) = v3[231] & 2 | v6 & 0xFD;
  objc_storeStrong(v5 + 14, *((id *)v3 + 14));
  *((unsigned char *)v5 + 231) = *((unsigned char *)v5 + 231) & 0xDF | v3[231] & 0x20;
  objc_storeStrong(v5 + 15, *((id *)v3 + 15));
  *((_DWORD *)v5 + 56) = *((_DWORD *)v3 + 56);
  nw_txt_record_t v7 = (char *)*((void *)v3 + 11);
  if (v7)
  {
    nw_txt_record_t v7 = strdup(v7);
    if (!v7)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      uint32_t v28 = "strict_strdup";
      uint64_t v16 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v16)) {
        goto LABEL_30;
      }
      free(v16);
      nw_txt_record_t v7 = 0;
    }
  }
  v5[11] = v7;
  uint64_t v8 = (char *)*((void *)v3 + 12);
  if (!v8) {
    goto LABEL_6;
  }
  uint64_t v8 = strdup(v8);
  if (v8) {
    goto LABEL_6;
  }
  os_log_type_t v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint32_t v28 = "strict_strdup";
  uint64_t v18 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v18))
  {
    free(v18);
    uint64_t v8 = 0;
LABEL_6:
    v5[12] = v8;
    int v9 = *((unsigned char *)v5 + 231) & 0xBF | (((v3[231] >> 6) & 1) << 6);
    *((unsigned char *)v5 + 231) = *((unsigned char *)v5 + 231) & 0xBF | (((v3[231] & 0x40) != 0) << 6);
    *((unsigned char *)v5 + 231) = v3[231] & 0x80 | v9 & 0x7F;
    *(_OWORD *)((char *)v5 + 28) = *(_OWORD *)(v3 + 28);
    nw_endpoint_set_device_id(v5, *((const char **)v3 + 13));
    id v10 = nw_endpoint_copy_public_keys(v3);
    nw_endpoint_set_public_keys(v5, v10);

    v23[0] = MEMORY[0x1E4F143A8];
    v23[1] = 3221225472;
    v23[2] = __nw_endpoint_copy_properties_block_invoke;
    v23[3] = &unk_1E523B6D8;
    int v24 = v5;
    nw_endpoint_enumerate_alternatives(v3, v23);

LABEL_7:
    return;
  }
LABEL_30:
  __break(1u);
}

void sub_183125C74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_public_keys(void *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x3032000000;
  BOOL v21 = __Block_byref_object_copy__6444;
  os_log_type_t v22 = __Block_byref_object_dispose__6445;
  id v23 = 0;
  if (v1)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_endpoint_copy_public_keys_block_invoke;
    v13[3] = &unk_1E524B978;
    uint64_t v15 = &v18;
    os_log_type_t v14 = v1;
    os_unfair_lock_lock(v2 + 44);
    __nw_endpoint_copy_public_keys_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 44);
    id v3 = (id)v19[5];

    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v25 = "nw_endpoint_copy_public_keys";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v25 = "nw_endpoint_copy_public_keys";
          __int16 v26 = 2082;
          uint64_t v27 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v25 = "nw_endpoint_copy_public_keys";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:
  _Block_object_dispose(&v18, 8);

  return v3;
}

void __nw_endpoint_copy_public_keys_block_invoke(uint64_t a1)
{
}

void nw_endpoint_enumerate_alternatives(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    char v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_endpoint_enumerate_alternatives";
    nw_txt_record_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23)) {
      goto LABEL_39;
    }
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v26 = "nw_endpoint_enumerate_alternatives";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_endpoint_enumerate_alternatives";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    if (v3[20])
    {
      v20[0] = MEMORY[0x1E4F143A8];
      v20[1] = 3221225472;
      void v20[2] = __nw_endpoint_enumerate_alternatives_block_invoke;
      v20[3] = &unk_1E524B950;
      BOOL v21 = v3;
      id v22 = v5;
      nw_endpoint_locked(v21, v20);
    }
    goto LABEL_5;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v26 = "nw_endpoint_enumerate_alternatives";
  nw_txt_record_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23)) {
    goto LABEL_39;
  }
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v23)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  uint64_t v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = v24;
  BOOL v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v26 = "nw_endpoint_enumerate_alternatives";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v26 = "nw_endpoint_enumerate_alternatives";
    __int16 v27 = 2082;
    uint64_t v28 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

void sub_183126558(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_device_id(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    nw_txt_record_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_endpoint_set_device_id";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v8, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_endpoint_set_device_id";
            __int16 v21 = 2082;
            id v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_endpoint_set_device_id";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v8) {
      free(v8);
    }
    goto LABEL_7;
  }
  uint64_t v5 = (void *)v3[13];
  if (v5)
  {
    free(v5);
    v4[13] = 0;
  }
  if (!a2) {
    goto LABEL_7;
  }
  char v6 = strdup(a2);
  if (v6)
  {
LABEL_6:
    v4[13] = v6;
LABEL_7:

    return;
  }
  os_log_type_t v11 = __nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "strict_strdup";
  os_log_type_t v12 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v12))
  {
    free(v12);
    goto LABEL_6;
  }
  __break(1u);
}

void nw_endpoint_set_public_keys(void *a1, void *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if ((unint64_t)[v4 count] > 0x10)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = (id)gLogObj;
      *(_DWORD *)buf = 136446210;
      long long v33 = "nw_endpoint_set_public_keys";
      nw_txt_record_t v7 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v30 = 0;
      if (!__nwlog_fault(v7, &type, &v30)) {
        goto LABEL_40;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Setting too many keys", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s Setting too many keys, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s Setting too many keys, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        long long v33 = "nw_endpoint_set_public_keys";
        __int16 v34 = 2082;
        unint64_t v35 = (unint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s Setting too many keys, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
      if (!v7) {
        goto LABEL_42;
      }
      goto LABEL_41;
    }
    accumulated_size_t size = nw_endpoint_get_accumulated_size(v5);
    if (accumulated_size < 0x1389)
    {
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      v27[2] = __nw_endpoint_set_public_keys_block_invoke;
      v27[3] = &unk_1E524B9A0;
      uint64_t v28 = v3;
      id v29 = v5;
      os_unfair_lock_lock(v3 + 44);
      __nw_endpoint_set_public_keys_block_invoke((uint64_t)v27);
      os_unfair_lock_unlock(v3 + 44);

      goto LABEL_42;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v11 = (id)gLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      long long v33 = "nw_endpoint_set_public_keys";
      __int16 v34 = 2048;
      unint64_t v35 = accumulated_size;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s Accumulated key-size %zu", buf, 0x16u);
    }

    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v12 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    long long v33 = "nw_endpoint_set_public_keys";
    nw_txt_record_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v7, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s Accumulated key-size too large", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v30)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s Accumulated key-size too large, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s Accumulated key-size too large, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        long long v33 = "nw_endpoint_set_public_keys";
        __int16 v34 = 2082;
        unint64_t v35 = (unint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s Accumulated key-size too large, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    __int16 v21 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    long long v33 = "nw_endpoint_set_public_keys";
    nw_txt_record_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v7, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v22, "%{public}s called with null endpoint", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v30)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v26, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      uint64_t v23 = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v8, type);
      if (!v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          long long v33 = "nw_endpoint_set_public_keys";
          _os_log_impl(&dword_1830D4000, v8, v24, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        long long v33 = "nw_endpoint_set_public_keys";
        __int16 v34 = 2082;
        unint64_t v35 = (unint64_t)v23;
        _os_log_impl(&dword_1830D4000, v8, v24, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v23);
    }
  }
LABEL_40:
  if (v7) {
LABEL_41:
  }
    free(v7);
LABEL_42:
}

void sub_183127188(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_endpoint_set_public_keys_block_invoke(uint64_t a1)
{
}

uint64_t nw_endpoint_get_accumulated_size(void *a1)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  long long v14 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v17 = 0u;
  id v1 = a1;
  uint64_t v2 = 0;
  uint64_t v3 = [v1 countByEnumeratingWithState:&v14 objects:v26 count:16];
  if (v3)
  {
    uint64_t v5 = *(void *)v15;
    *(void *)&long long v4 = 136446978;
    long long v13 = v4;
    do
    {
      for (uint64_t i = 0; i != v3; ++i)
      {
        if (*(void *)v15 != v5) {
          objc_enumerationMutation(v1);
        }
        nw_txt_record_t v7 = *(void **)(*((void *)&v14 + 1) + 8 * i);
        uint64_t v8 = objc_msgSend(v7, "length", v13, (void)v14);
        BOOL v9 = __CFADD__(v2, v8);
        v2 += v8;
        if (v9)
        {
          if (gLogDatapath)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v10 = (id)gLogObj;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v11 = [v7 length];
              *(_DWORD *)buf = v13;
              os_log_type_t v19 = "nw_endpoint_get_accumulated_size";
              __int16 v20 = 2082;
              __int16 v21 = "sum";
              __int16 v22 = 2048;
              uint64_t v23 = v11;
              __int16 v24 = 2048;
              uint64_t v25 = v2;
              _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", buf, 0x2Au);
            }
          }
          uint64_t v2 = -1;
        }
      }
      uint64_t v3 = [v1 countByEnumeratingWithState:&v14 objects:v26 count:16];
    }
    while (v3);
  }

  return v2;
}

void sub_183127394(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_txt_record_t nw_endpoint_copy_txt_record(nw_endpoint_t endpoint)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_endpoint_t v1 = endpoint;
  nw_endpoint_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[23].isa;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  long long v16 = "nw_endpoint_copy_txt_record";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_copy_txt_record";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          long long v16 = "nw_endpoint_copy_txt_record";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_copy_txt_record";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_copy_txt_record";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_endpoint_get_domain_for_policy(void *a1)
{
  id v1 = a1;
  nw_endpoint_t v2 = v1;
  if (!v1)
  {
    uint64_t domain_for_policy = 0;
LABEL_11:

    return domain_for_policy;
  }
  uint64_t v3 = v1;
  uint64_t domain_for_policy = [v3 domainForPolicy];
  if (domain_for_policy)
  {
LABEL_10:

    goto LABEL_11;
  }
  uint64_t v5 = (void *)v3[14];
  if (!v5)
  {
    uint64_t domain_for_policy = 0;
    goto LABEL_10;
  }
  if (v5 != v3)
  {
LABEL_7:
    uint64_t domain_for_policy = nw_endpoint_get_domain_for_policy(v5);
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  nw_txt_record_t v7 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    uint64_t v5 = (void *)v3[14];
    goto LABEL_7;
  }
  __break(1u);
  return result;
}

void sub_1831277C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_get_agent_identifier(void *a1, _OWORD *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  long long v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 28);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  long long v16 = "nw_endpoint_get_agent_identifier";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          long long v16 = "nw_endpoint_get_agent_identifier";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_get_agent_identifier";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

uint64_t nw_endpoint_get_device_id(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_endpoint_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 13);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  long long v16 = "nw_endpoint_get_device_id";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_get_device_id";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          long long v16 = "nw_endpoint_get_device_id";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_get_device_id";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_txt_record_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_endpoint_get_device_id";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t NWUtilsCreateXPCObjectFromSimpleNSObject(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  objc_opt_class();
  if ((objc_opt_isKindOfClass() & 1) != 0
    || (id v5 = v4,
        objc_opt_class(),
        isKindOfClass Class = objc_opt_isKindOfClass(),
        v5,
        (isKindOfClass & 1) != 0))
  {
    uint64_t v7 = _CFXPCCreateXPCObjectFromCFObject();
LABEL_4:
    uint64_t v8 = v7;
    goto LABEL_5;
  }
  id v10 = v5;
  objc_opt_class();
  char v11 = objc_opt_isKindOfClass();

  if (v11)
  {
    *(void *)uuid = 0;
    *(void *)&uuid[8] = 0;
    [v10 getUUIDBytes:uuid];
    uint64_t v7 = (uint64_t)xpc_uuid_create(uuid);
    goto LABEL_4;
  }
  id v12 = v10;
  objc_opt_class();
  char v13 = objc_opt_isKindOfClass();

  if (v13)
  {
    if ([v3 hasPrefix:@"INT64-"])
    {
      uint64_t v7 = (uint64_t)xpc_int64_create([v12 longLongValue]);
    }
    else if ([v3 hasPrefix:@"DOUBLE-"])
    {
      [v12 doubleValue];
      uint64_t v7 = (uint64_t)xpc_double_create(v22);
    }
    else if ([v3 hasPrefix:@"BOOL-"])
    {
      uint64_t v7 = (uint64_t)xpc_BOOL_create([v12 BOOLValue]);
    }
    else
    {
      uint64_t v7 = (uint64_t)xpc_uint64_create([v12 unsignedLongLongValue]);
    }
    goto LABEL_4;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v14 = (id)gLogObj;
  *(_DWORD *)uuid = 136446466;
  *(void *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
  *(_WORD *)&uuid[12] = 2114;
  *(void *)&uuid[14] = objc_opt_class();
  id v15 = *(id *)&uuid[14];
  long long v16 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v29 = 0;
  if (__nwlog_fault(v16, &type, &v29))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      __int16 v17 = (id)gLogObj;
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        uint64_t v19 = objc_opt_class();
        *(_DWORD *)uuid = 136446466;
        *(void *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
        *(_WORD *)&uuid[12] = 2114;
        *(void *)&uuid[14] = v19;
        id v20 = v19;
        __int16 v21 = "%{public}s Unknown NSObject type %{public}@";
LABEL_29:
        _os_log_impl(&dword_1830D4000, v17, v18, v21, uuid, 0x16u);
      }
    }
    else
    {
      if (v29)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v17 = __nwlog_obj();
        os_log_type_t v18 = type;
        BOOL v24 = os_log_type_enabled(v17, type);
        if (backtrace_string)
        {
          if (v24)
          {
            uint64_t v25 = objc_opt_class();
            *(_DWORD *)uuid = 136446722;
            *(void *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
            *(_WORD *)&uuid[12] = 2114;
            *(void *)&uuid[14] = v25;
            __int16 v32 = 2082;
            long long v33 = backtrace_string;
            id v26 = v25;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Unknown NSObject type %{public}@, dumping backtrace:%{public}s", uuid, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_31;
        }
        if (!v24) {
          goto LABEL_30;
        }
        uint64_t v28 = objc_opt_class();
        *(_DWORD *)uuid = 136446466;
        *(void *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
        *(_WORD *)&uuid[12] = 2114;
        *(void *)&uuid[14] = v28;
        id v20 = v28;
        __int16 v21 = "%{public}s Unknown NSObject type %{public}@, no backtrace";
        goto LABEL_29;
      }
      __int16 v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        uint64_t v27 = objc_opt_class();
        *(_DWORD *)uuid = 136446466;
        *(void *)&uuid[4] = "NWUtilsCreateXPCObjectFromSimpleNSObject";
        *(_WORD *)&uuid[12] = 2114;
        *(void *)&uuid[14] = v27;
        id v20 = v27;
        __int16 v21 = "%{public}s Unknown NSObject type %{public}@, backtrace limit exceeded";
        goto LABEL_29;
      }
    }
LABEL_30:
  }
LABEL_31:
  if (v16) {
    free(v16);
  }
  uint64_t v8 = 0;
LABEL_5:

  return v8;
}

void ___ZL36nw_http_fillout_binary_message_innerP20nw_protocol_metadatabPKhmPhm_block_invoke_18(uint64_t a1, char *__s)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  if (!__s)
  {
    size_t v5 = 0;
    goto LABEL_6;
  }
  size_t v4 = strlen(__s);
  size_t v5 = v4;
  if (v4 <= 0x3F)
  {
LABEL_6:
    __srCC_SHA256_CTX c = v5;
    size_t v6 = 1;
    goto LABEL_7;
  }
  if (!(v4 >> 14))
  {
    __srCC_SHA256_CTX c = bswap32(v4 | 0x4000) >> 16;
    size_t v6 = 2;
    goto LABEL_7;
  }
  if (!(v4 >> 30))
  {
    __srCC_SHA256_CTX c = bswap32(v4 | 0x80000000);
    size_t v6 = 4;
    goto LABEL_7;
  }
  if (!(v4 >> 62))
  {
    __srCC_SHA256_CTX c = bswap64(v4 | 0xC000000000000000);
    size_t v6 = 8;
LABEL_7:
    uint64_t v8 = *(void *)(a1 + 32);
    uint64_t v7 = (void *)(a1 + 32);
    BOOL v9 = *(char **)(*(void *)(v8 + 8) + 24);
    id v10 = v7 + 1;
    if (v9)
    {
      uint64_t v11 = *(void *)(v7[1] + 8);
      if (*(void *)(v11 + 24) >= v6)
      {
        memcpy(v9, &__src, v6);
        unint64_t v12 = *(void *)(v11 + 24);
        *(void *)(v11 + 24) = v12 - v6;
        if (v12 < v6)
        {
          if (gLogDatapath)
          {
            size_t v38 = __nwlog_obj();
            if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v39 = *(void *)(v11 + 24);
              *(_DWORD *)buf = 136446978;
              unint64_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              long long v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v6;
              __int16 v56 = 2048;
              uint64_t v57 = v39;
              _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v11 + 24) = 0;
        }
        char v13 = &v9[v6];
        goto LABEL_13;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          id v26 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (!v48)
      {
        BOOL v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          id v26 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v40 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          id v26 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v40)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        long long v53 = backtrace_string;
        uint64_t v37 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_74;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      uint64_t v23 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v48 = 0;
      if (!__nwlog_fault(v23, &type, &v48)) {
        goto LABEL_112;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer";
LABEL_111:
          _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
        }
LABEL_112:
        if (v23) {
          free(v23);
        }
        char v13 = 0;
        goto LABEL_13;
      }
      if (!v48)
      {
        BOOL v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, backtrace limit exceeded";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v36 = os_log_type_enabled(v24, type);
      if (!backtrace_string)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          id v26 = "%{public}s called with null buffer, no backtrace";
          goto LABEL_111;
        }
        goto LABEL_112;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        long long v53 = backtrace_string;
        uint64_t v37 = "%{public}s called with null buffer, dumping backtrace:%{public}s";
LABEL_74:
        _os_log_impl(&dword_1830D4000, v24, v25, v37, buf, 0x16u);
      }
    }
    free(backtrace_string);
    goto LABEL_112;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  unint64_t v51 = "_http_vle_encode";
  __int16 v52 = 2048;
  long long v53 = (const char *)v5;
  __int16 v17 = (void *)_os_log_send_and_compose_impl();
  if (__nwlog_abort((uint64_t)v17))
  {
    __break(1u);
    return;
  }
  free(v17);
  uint64_t v18 = *(void *)(a1 + 32);
  uint64_t v7 = (void *)(a1 + 32);
  char v13 = *(char **)(*(void *)(v18 + 8) + 24);
  id v10 = v7 + 1;
LABEL_13:
  *(void *)(*(void *)(*v7 + 8) + 24) = v13;
  id v14 = *(char **)(*(void *)(*v7 + 8) + 24);
  if (!v14)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v19, &type, &v48)) {
      goto LABEL_101;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (!os_log_type_enabled(v20, type)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      double v22 = "%{public}s called with null cursor";
    }
    else
    {
      if (!v48)
      {
        id v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (!os_log_type_enabled(v20, type)) {
          goto LABEL_101;
        }
        *(_DWORD *)buf = 136446210;
        unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
        double v22 = "%{public}s called with null cursor, backtrace limit exceeded";
        goto LABEL_100;
      }
      uint64_t v31 = (char *)__nw_create_backtrace_string();
      id v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v32 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
          __int16 v52 = 2082;
          long long v53 = v31;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v31);
        if (v19) {
          goto LABEL_102;
        }
        return;
      }
      if (!v32) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      double v22 = "%{public}s called with null cursor, no backtrace";
    }
LABEL_100:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
    goto LABEL_101;
  }
  if (v5)
  {
    if (__s)
    {
      uint64_t v15 = *(void *)(*v10 + 8);
      if (*(void *)(v15 + 24) >= v5)
      {
        memcpy(v14, __s, v5);
        unint64_t v16 = *(void *)(v15 + 24);
        *(void *)(v15 + 24) = v16 - v5;
        if (v16 < v5)
        {
          if (gLogDatapath)
          {
            uint64_t v44 = __nwlog_obj();
            if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v45 = *(void *)(v15 + 24);
              *(_DWORD *)buf = 136446978;
              unint64_t v51 = "_http_safe_append";
              __int16 v52 = 2082;
              long long v53 = "*remaining";
              __int16 v54 = 2048;
              size_t v55 = v5;
              __int16 v56 = 2048;
              uint64_t v57 = v45;
              _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", buf, 0x2Au);
            }
          }
          *(void *)(v15 + 24) = 0;
        }
        v14 += v5;
        goto LABEL_21;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length)";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      size_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v46 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          char v30 = "%{public}s called with null (*remaining >= length), no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v46)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        long long v53 = v41;
        Class v43 = "%{public}s called with null (*remaining >= length), dumping backtrace:%{public}s";
        goto LABEL_86;
      }
    }
    else
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "_http_safe_append";
      uint64_t v27 = (char *)_os_log_send_and_compose_impl();
      LOBYTE(__src) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v27, &__src, &type)) {
        goto LABEL_120;
      }
      if (__src == 17)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data";
LABEL_119:
          _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
        }
LABEL_120:
        if (v27) {
          free(v27);
        }
        id v14 = 0;
        goto LABEL_21;
      }
      if (type == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = __src;
        if (os_log_type_enabled(v28, (os_log_type_t)__src))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data, backtrace limit exceeded";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      size_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = __src;
      BOOL v42 = os_log_type_enabled(v28, (os_log_type_t)__src);
      if (!v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "_http_safe_append";
          char v30 = "%{public}s called with null data, no backtrace";
          goto LABEL_119;
        }
        goto LABEL_120;
      }
      if (v42)
      {
        *(_DWORD *)buf = 136446466;
        unint64_t v51 = "_http_safe_append";
        __int16 v52 = 2082;
        long long v53 = v41;
        Class v43 = "%{public}s called with null data, dumping backtrace:%{public}s";
LABEL_86:
        _os_log_impl(&dword_1830D4000, v28, v29, v43, buf, 0x16u);
      }
    }
    free(v41);
    goto LABEL_120;
  }
LABEL_21:
  *(void *)(*(void *)(*v7 + 8) + 24) = v14;
  if (*(void *)(*(void *)(*v7 + 8) + 24)) {
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
  uint64_t v19 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(__src) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v19, &__src, &type))
  {
    if (__src == 17)
    {
      id v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      double v22 = "%{public}s called with null cursor";
      goto LABEL_100;
    }
    if (type == OS_LOG_TYPE_DEFAULT)
    {
      id v20 = __nwlog_obj();
      os_log_type_t v21 = __src;
      if (!os_log_type_enabled(v20, (os_log_type_t)__src)) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      double v22 = "%{public}s called with null cursor, backtrace limit exceeded";
      goto LABEL_100;
    }
    long long v33 = (char *)__nw_create_backtrace_string();
    id v20 = __nwlog_obj();
    os_log_type_t v21 = __src;
    BOOL v34 = os_log_type_enabled(v20, (os_log_type_t)__src);
    if (!v33)
    {
      if (!v34) {
        goto LABEL_101;
      }
      *(_DWORD *)buf = 136446210;
      unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      double v22 = "%{public}s called with null cursor, no backtrace";
      goto LABEL_100;
    }
    if (v34)
    {
      *(_DWORD *)buf = 136446466;
      unint64_t v51 = "nw_http_fillout_binary_message_inner_block_invoke";
      __int16 v52 = 2082;
      long long v53 = v33;
      _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null cursor, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v33);
  }
LABEL_101:
  if (v19) {
LABEL_102:
  }
    free(v19);
}

const char *__cdecl nw_endpoint_get_bonjour_service_domain(nw_endpoint_t endpoint)
{
  *(void *)&v40[13] = *MEMORY[0x1E4F143B8];
  id v1 = endpoint;
  nw_endpoint_t v2 = v1;
  if (!v1)
  {
    id v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v38 = "nw_endpoint_get_bonjour_service_domain";
    uint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v38 = "nw_endpoint_get_bonjour_service_domain";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            size_t v38 = "nw_endpoint_get_bonjour_service_domain";
            __int16 v39 = 2082;
            *(void *)BOOL v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          size_t v38 = "nw_endpoint_get_bonjour_service_domain";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v38 = "nw_endpoint_get_bonjour_service_domain";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v27) {
      goto LABEL_24;
    }
    BOOL v24 = (char *)v27;
    goto LABEL_23;
  }
  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    uint64_t v7 = v3;
    int v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    size_t v38 = "nw_endpoint_get_bonjour_service_domain";
    __int16 v39 = 1024;
    *(_DWORD *)BOOL v40 = v8;
    LODWORD(v34) = 18;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          unint64_t v12 = v7;
          int v13 = [v12 type];

          *(_DWORD *)buf = 136446466;
          size_t v38 = "nw_endpoint_get_bonjour_service_domain";
          __int16 v39 = 1024;
          *(_DWORD *)BOOL v40 = v13;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        id v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            __int16 v17 = v7;
            int v18 = [v17 type];

            *(_DWORD *)buf = 136446722;
            size_t v38 = "nw_endpoint_get_bonjour_service_domain";
            __int16 v39 = 1024;
            *(_DWORD *)BOOL v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          BOOL v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          double v22 = v7;
          int v23 = [v22 type];

          *(_DWORD *)buf = 136446466;
          size_t v38 = "nw_endpoint_get_bonjour_service_domain";
          __int16 v39 = 1024;
          *(_DWORD *)BOOL v40 = v23;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          id v20 = v7;
          int v21 = [v20 type];

          *(_DWORD *)buf = 136446466;
          size_t v38 = "nw_endpoint_get_bonjour_service_domain";
          __int16 v39 = 1024;
          *(_DWORD *)BOOL v40 = v21;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v9)
    {
LABEL_24:
      Class isa = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  Class isa = (const char *)v3[31].isa;
LABEL_25:

  return isa;
}

void sub_183129514(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_contact_id(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_endpoint_t v2 = v1;
  if (!v1)
  {
    id v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v38 = "nw_endpoint_get_contact_id";
    uint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v38 = "nw_endpoint_get_contact_id";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            size_t v38 = "nw_endpoint_get_contact_id";
            __int16 v39 = 2082;
            *(void *)BOOL v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          size_t v38 = "nw_endpoint_get_contact_id";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v38 = "nw_endpoint_get_contact_id";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v27) {
      goto LABEL_24;
    }
    BOOL v24 = (char *)v27;
    goto LABEL_23;
  }
  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    uint64_t v7 = v3;
    int v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    size_t v38 = "nw_endpoint_get_contact_id";
    __int16 v39 = 1024;
    *(_DWORD *)BOOL v40 = v8;
    LODWORD(v34) = 18;
    BOOL v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          unint64_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          size_t v38 = "nw_endpoint_get_contact_id";
          __int16 v39 = 1024;
          *(_DWORD *)BOOL v40 = v13;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        id v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            __int16 v17 = v7;
            int v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            size_t v38 = "nw_endpoint_get_contact_id";
            __int16 v39 = 1024;
            *(_DWORD *)BOOL v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          BOOL v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          double v22 = v7;
          int v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          size_t v38 = "nw_endpoint_get_contact_id";
          __int16 v39 = 1024;
          *(_DWORD *)BOOL v40 = v23;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          id v20 = v7;
          int v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          size_t v38 = "nw_endpoint_get_contact_id";
          __int16 v39 = 1024;
          *(_DWORD *)BOOL v40 = v21;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  uint64_t v5 = v3[36];
LABEL_25:

  return v5;
}

void sub_183129B58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

xpc_object_t NWUtilsCreateXPCArrayFromNSArray(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  xpc_object_t v5 = xpc_array_create(0, 0);
  long long v18 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v21 = 0u;
  id v6 = v4;
  uint64_t v7 = [v6 countByEnumeratingWithState:&v18 objects:v26 count:16];
  if (v7)
  {
    uint64_t v8 = v7;
    uint64_t v9 = *(void *)v19;
    do
    {
      for (uint64_t i = 0; i != v8; ++i)
      {
        if (*(void *)v19 != v9) {
          objc_enumerationMutation(v6);
        }
        id v11 = *(id *)(*((void *)&v18 + 1) + 8 * i);
        objc_opt_class();
        isKindOfClass Class = objc_opt_isKindOfClass();

        if (isKindOfClass)
        {
          xpc_object_t XPCArrayFromNSArray = (void *)NWUtilsCreateXPCArrayFromNSArray(v3, v11);
          if (XPCArrayFromNSArray) {
            goto LABEL_14;
          }
        }
        else
        {
          id v14 = v11;
          objc_opt_class();
          char v15 = objc_opt_isKindOfClass();

          if (v15)
          {
            xpc_object_t XPCArrayFromNSArray = (void *)NWUtilsCreateXPCDictionaryFromNSDictionary(v14);
            if (XPCArrayFromNSArray) {
              goto LABEL_14;
            }
          }
          else
          {
            xpc_object_t XPCArrayFromNSArray = (void *)NWUtilsCreateXPCObjectFromSimpleNSObject(v3, v14);
            if (XPCArrayFromNSArray)
            {
LABEL_14:
              xpc_array_append_value(v5, XPCArrayFromNSArray);
              goto LABEL_6;
            }
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v16 = (id)gLogObj;
        if (os_log_type_enabled(v16, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446466;
          int v23 = "NWUtilsCreateXPCArrayFromNSArray";
          __int16 v24 = 2114;
          id v25 = v11;
          _os_log_impl(&dword_1830D4000, v16, OS_LOG_TYPE_ERROR, "%{public}s Could not create xpc object for %{public}@", buf, 0x16u);
        }

LABEL_6:
      }
      uint64_t v8 = [v6 countByEnumeratingWithState:&v18 objects:v26 count:16];
    }
    while (v8);
  }

  return v5;
}

uint64_t sub_183129E28(uint64_t a1, uint64_t a2)
{
  return (*(uint64_t (**)(void))(*(void *)(*(void *)(a2 + 16) - 8) + 8))();
}

uint64_t sub_183129E54@<X0>(unint64_t a1@<X0>, unint64_t a2@<X1>, uint64_t a3@<X2>, char *a4@<X3>, char *a5@<X4>, uint64_t a6@<X8>)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(&qword_1E8F61F40);
  uint64_t v14 = MEMORY[0x1F4188790](v13 - 8);
  BOOL v16 = (char *)&v28 - ((v15 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v14);
  uint64_t v29 = (uint64_t)&v28 - v17;
  uint64_t v18 = HIBYTE(a2) & 0xF;
  if ((a2 & 0x2000000000000000) == 0) {
    uint64_t v18 = a1;
  }
  uint64_t v19 = 7;
  if (((a2 >> 60) & ((a1 & 0x800000000000000) == 0)) != 0) {
    uint64_t v19 = 11;
  }
  unint64_t v20 = sub_1835945A4(0xFuLL, v19 | (v18 << 16), a1, a2);
  if ((v20 & 0x8000000000000000) != 0) {
    __break(1u);
  }
  int64_t v21 = v20;
  sub_1834BFB88(a3);
  uint64_t isStackAllocationSafe = sub_1834BFB88(a3);
  if (v21 < 1025 || (uint64_t isStackAllocationSafe = swift_stdlib_isStackAllocationSafe(), (isStackAllocationSafe & 1) != 0))
  {
    uint64_t v28 = a6;
    char v30 = &v28;
    MEMORY[0x1F4188790](isStackAllocationSafe);
    __int16 v24 = (char *)&v28 - v23;
    sub_1834BFB88(a3);
    sub_1834A42B0(v24, (char *)v21, a1, a2, a3, a4, a5, (uint64_t)v16);
    if (v6)
    {
      swift_willThrow();
    }
    else
    {
      uint64_t v25 = v29;
      sub_183594E58((uint64_t)v16, v29);
      sub_183594E58(v25, v28);
    }
  }
  else
  {
    id v26 = (char *)swift_slowAlloc();
    sub_1834BFB88(a3);
    sub_1834A42B0(v26, (char *)v21, a1, a2, a3, a4, a5, a6);
    MEMORY[0x185318E50](v26, -1, -1);
  }
  sub_18312A0D8(a3);
  sub_18312A0D8(a3);
  return sub_18312A0D8(a3);
}

uint64_t sub_18312A0D8(uint64_t a1)
{
  return a1;
}

ValueMetadata *type metadata accessor for NWInterface()
{
  return &type metadata for NWInterface;
}

uint64_t storeEnumTagSinglePayload for NWEndpoint.Host(uint64_t result, unsigned int a2, unsigned int a3)
{
  if (a2 > 0xFD)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    *(unsigned char *)(result + 24) = 0;
    *(void *)BOOL result = a2 - 254;
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 25) = 1;
    }
  }
  else
  {
    if (a3 >= 0xFE) {
      *(unsigned char *)(result + 25) = 0;
    }
    if (a2) {
      *(unsigned char *)(result + 24) = -(char)a2;
    }
  }
  return result;
}

uint64_t getEnumTagSinglePayload for NWEndpoint.Host(uint64_t a1, unsigned int a2)
{
  if (!a2) {
    return 0;
  }
  if (a2 >= 0xFE && *(unsigned char *)(a1 + 25)) {
    return (*(_DWORD *)a1 + 254);
  }
  unsigned int v3 = *(unsigned __int8 *)(a1 + 24);
  if (v3 <= 2) {
    int v4 = -1;
  }
  else {
    int v4 = v3 ^ 0xFF;
  }
  return (v4 + 1);
}

void NWActivity.complete(reason:)(uint64_t a1)
{
  uint64_t v2 = *(void *)a1;
  uint64_t v3 = *(void *)(a1 + 8);
  uint64_t v4 = *(void *)(a1 + 16);
  if (*(unsigned char *)(a1 + 24) == 1)
  {
    if (v4 < (uint64_t)0xFFFFFFFF80000000)
    {
LABEL_38:
      __break(1u);
      goto LABEL_39;
    }
    if (v4 > 0x7FFFFFFF)
    {
LABEL_39:
      __break(1u);
      return;
    }
    uint64_t v7 = *(void **)(v1 + 16);
    uint64_t v8 = sub_183D44BAC();
    nw_activity_complete_with_reason_and_underlying_error_string(v7, 3u, v8 + 32, v4);
    swift_release();
  }
  else
  {
    if (!*(unsigned char *)(a1 + 24))
    {
      if (v2 > 0x7FFFFFFF)
      {
        __break(1u);
      }
      else if (v2 >= (uint64_t)0xFFFFFFFF80000000 && v3 >= (uint64_t)0xFFFFFFFF80000000)
      {
        if (v3 <= 0x7FFFFFFF)
        {
          uint64_t v6 = *(void **)(v1 + 16);
          nw_activity_complete_with_reason_and_underlying_error(v6, 3u, v2, v3);
          return;
        }
        goto LABEL_37;
      }
      __break(1u);
LABEL_37:
      __break(1u);
      goto LABEL_38;
    }
    uint64_t v9 = *(void **)(v1 + 16);
    if (v4 | v3) {
      BOOL v10 = 0;
    }
    else {
      BOOL v10 = v2 == 2;
    }
    if (v10) {
      int v11 = 3;
    }
    else {
      int v11 = 4;
    }
    if (v2 == 1 && (v4 | v3) == 0) {
      int v13 = 2;
    }
    else {
      int v13 = v11;
    }
    if (v4 | v3 | v2) {
      uint32_t v14 = v13;
    }
    else {
      uint32_t v14 = 1;
    }
    nw_activity_complete_with_reason(v9, v14);
  }
}

uint64_t destroy for NWActivity.CompletionReason(uint64_t a1)
{
  return sub_18312A3B8(*(void *)a1, *(void *)(a1 + 8), *(void *)(a1 + 16), *(unsigned char *)(a1 + 24));
}

uint64_t sub_18312A324(uint64_t result, unsigned int a2)
{
  uint64_t v2 = a2 - 2;
  if (a2 >= 2)
  {
    *(void *)(result + 8) = 0;
    *(void *)(result + 16) = 0;
    LOBYTE(a2) = 2;
    *(void *)BOOL result = v2;
  }
  *(unsigned char *)(result + 24) = a2;
  return result;
}

uint64_t initializeWithCopy for NWActivity.CompletionReason(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = *(void *)a2;
  uint64_t v4 = *(void *)(a2 + 8);
  uint64_t v5 = *(void *)(a2 + 16);
  char v6 = *(unsigned char *)(a2 + 24);
  sub_18312A3A0(*(void *)a2, v4, v5, v6);
  *(void *)a1 = v3;
  *(void *)(a1 + 8) = v4;
  *(void *)(a1 + 16) = v5;
  *(unsigned char *)(a1 + 24) = v6;
  return a1;
}

uint64_t sub_18312A3A0(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (a4 == 1) {
    return swift_bridgeObjectRetain();
  }
  return result;
}

uint64_t sub_18312A3B8(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (a4 == 1) {
    return swift_bridgeObjectRelease();
  }
  return result;
}

void ___ZL27nw_endpoint_resolver_updateP30NWConcrete_nw_endpoint_handlerPU25objcproto14OS_nw_resolver8NSObject20nw_resolver_status_t_block_invoke_108(uint64_t a1)
{
}

uint64_t ___ZL34nw_resolver_remove_endpoint_lockedP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectU13block_pointerFbS3_S3_E_block_invoke(uint64_t *a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  if ((*(unsigned int (**)(void))(a1[6] + 16))()) {
    *(unsigned char *)(*(void *)(a1[7] + 8) + 24) = 1;
  }
  else {
    nw_array_append(a1[5], v4);
  }

  return 1;
}

void sub_18312A444(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_2_215(uint64_t a1, void *a2)
{
  return nw_endpoint_address_endpoint_matches_address(a2, *(unsigned __int8 **)(a1 + 32), *(_DWORD *)(a1 + 40), 0);
}

void ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_39(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40) && *(void *)(*(void *)(a1 + 32) + 136)) {
    os_channel_sync();
  }
  *(_WORD *)(*(void *)(a1 + 32) + 444) |= 4u;
  nw_channel_update_input_source(*(void *)(a1 + 32), 0, 1);
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int16 *)(v2 + 444);
  unsigned int v4 = v3 & 0xFFFFFFFB | (*(unsigned __int8 *)(v2 + 446) << 16);
  *(_WORD *)(v2 + 444) = v3 & 0xFFFB;
  *(unsigned char *)(v2 + 446) = BYTE2(v4);
}

uint64_t nw_protocol_get_input_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6)
{
  uint64_t v64 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v8 = *(void **)(a1 + 40);
    if (v8 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v9 = *(void *)(a1 + 88);
      if (v9) {
        *(void *)(a1 + 88) = v9 + 1;
      }
    }
    if (a2)
    {
      BOOL v10 = *(void **)(a2 + 40);
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(a2 + 88);
        if (v11) {
          *(void *)(a2 + 88) = v11 + 1;
        }
      }
      if (a6)
      {
        uint64_t v12 = *(void *)(a1 + 24);
        if (v12)
        {
          int v13 = *(uint64_t (**)(uint64_t, uint64_t))(v12 + 80);
          if (v13)
          {
            uint64_t v14 = v13(a1, a2);
            if (v10 == &nw_protocol_ref_counted_handle)
            {
LABEL_13:
              if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v20 = *(void *)(a2 + 88);
                if (v20)
                {
                  uint64_t v21 = v20 - 1;
                  *(void *)(a2 + 88) = v21;
                  if (!v21)
                  {
                    double v22 = *(void (***)(void))(a2 + 64);
                    if (v22)
                    {
                      *(void *)(a2 + 64) = 0;
                      v22[2](v22);
                      _Block_release(v22);
                    }
                    if (*(unsigned char *)(a2 + 72))
                    {
                      uint64_t v23 = *(const void **)(a2 + 64);
                      if (v23) {
                        _Block_release(v23);
                      }
                    }
                    free((void *)a2);
                  }
                }
              }
            }
LABEL_14:
            if (v8 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v16 = *(void *)(a1 + 88);
              if (v16)
              {
                uint64_t v17 = v16 - 1;
                *(void *)(a1 + 88) = v17;
                if (!v17)
                {
                  uint64_t v18 = *(void (***)(void))(a1 + 64);
                  if (v18)
                  {
                    *(void *)(a1 + 64) = 0;
                    v18[2](v18);
                    _Block_release(v18);
                  }
                  if (*(unsigned char *)(a1 + 72))
                  {
                    uint64_t v19 = *(const void **)(a1 + 64);
                    if (v19) {
                      _Block_release(v19);
                    }
                  }
                  free((void *)a1);
                }
              }
            }
            return v14;
          }
        }
        __nwlog_obj();
        __int16 v24 = *(const char **)(a1 + 16);
        *(_DWORD *)buf = 136446722;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        if (!v24) {
          __int16 v24 = "invalid";
        }
        __int16 v58 = 2082;
        os_log_type_t v59 = (void *)v24;
        __int16 v60 = 2048;
        uint64_t v61 = a1;
        uint64_t v25 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v54 = 0;
        if (__nwlog_fault(v25, &type, &v54))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            id v26 = __nwlog_obj();
            os_log_type_t v27 = type;
            if (!os_log_type_enabled(v26, type)) {
              goto LABEL_107;
            }
            uint64_t v28 = *(const char **)(a1 + 16);
            if (!v28) {
              uint64_t v28 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v57 = "__nw_protocol_get_input_frames";
            __int16 v58 = 2082;
            os_log_type_t v59 = (void *)v28;
            __int16 v60 = 2048;
            uint64_t v61 = a1;
            uint64_t v29 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_84:
            unint64_t v51 = v26;
            os_log_type_t v52 = v27;
            uint32_t v53 = 32;
LABEL_106:
            _os_log_impl(&dword_1830D4000, v51, v52, v29, buf, v53);
            goto LABEL_107;
          }
          if (!v54)
          {
            id v26 = __nwlog_obj();
            os_log_type_t v27 = type;
            if (!os_log_type_enabled(v26, type)) {
              goto LABEL_107;
            }
            BOOL v49 = *(const char **)(a1 + 16);
            if (!v49) {
              BOOL v49 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v57 = "__nw_protocol_get_input_frames";
            __int16 v58 = 2082;
            os_log_type_t v59 = (void *)v49;
            __int16 v60 = 2048;
            uint64_t v61 = a1;
            uint64_t v29 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            goto LABEL_84;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          id v26 = __nwlog_obj();
          os_log_type_t v27 = type;
          BOOL v41 = os_log_type_enabled(v26, type);
          if (!backtrace_string)
          {
            if (!v41) {
              goto LABEL_107;
            }
            os_log_type_t v50 = *(const char **)(a1 + 16);
            if (!v50) {
              os_log_type_t v50 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v57 = "__nw_protocol_get_input_frames";
            __int16 v58 = 2082;
            os_log_type_t v59 = (void *)v50;
            __int16 v60 = 2048;
            uint64_t v61 = a1;
            uint64_t v29 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            goto LABEL_84;
          }
          if (v41)
          {
            BOOL v42 = *(const char **)(a1 + 16);
            if (!v42) {
              BOOL v42 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            uint64_t v57 = "__nw_protocol_get_input_frames";
            __int16 v58 = 2082;
            os_log_type_t v59 = (void *)v42;
            __int16 v60 = 2048;
            uint64_t v61 = a1;
            __int16 v62 = 2082;
            uint64_t v63 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
        }
LABEL_107:
        if (!v25) {
          goto LABEL_109;
        }
        goto LABEL_108;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v57 = "__nw_protocol_get_input_frames";
      uint64_t v25 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v54 = 0;
      if (!__nwlog_fault(v25, &type, &v54)) {
        goto LABEL_107;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        size_t v38 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        uint64_t v29 = "%{public}s called with null return_array";
      }
      else if (v54)
      {
        os_log_type_t v47 = (char *)__nw_create_backtrace_string();
        size_t v38 = __nwlog_obj();
        os_log_type_t v39 = type;
        BOOL v48 = os_log_type_enabled(v38, type);
        if (v47)
        {
          if (v48)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v57 = "__nw_protocol_get_input_frames";
            __int16 v58 = 2082;
            os_log_type_t v59 = v47;
            _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s called with null return_array, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v47);
          if (!v25)
          {
LABEL_109:
            uint64_t v14 = 0;
            if (v10 == &nw_protocol_ref_counted_handle) {
              goto LABEL_13;
            }
            goto LABEL_14;
          }
LABEL_108:
          free(v25);
          goto LABEL_109;
        }
        if (!v48) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        uint64_t v29 = "%{public}s called with null return_array, no backtrace";
      }
      else
      {
        size_t v38 = __nwlog_obj();
        os_log_type_t v39 = type;
        if (!os_log_type_enabled(v38, type)) {
          goto LABEL_107;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        uint64_t v29 = "%{public}s called with null return_array, backtrace limit exceeded";
      }
      unint64_t v51 = v38;
      os_log_type_t v52 = v39;
      uint32_t v53 = 12;
      goto LABEL_106;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v57 = "__nw_protocol_get_input_frames";
    uint64_t v34 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (__nwlog_fault(v34, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v35 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "__nw_protocol_get_input_frames";
          uint64_t v37 = "%{public}s called with null input_protocol";
LABEL_99:
          _os_log_impl(&dword_1830D4000, v35, v36, v37, buf, 0xCu);
        }
      }
      else if (v54)
      {
        uint64_t v45 = (char *)__nw_create_backtrace_string();
        char v35 = __nwlog_obj();
        os_log_type_t v36 = type;
        BOOL v46 = os_log_type_enabled(v35, type);
        if (v45)
        {
          if (v46)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v57 = "__nw_protocol_get_input_frames";
            __int16 v58 = 2082;
            os_log_type_t v59 = v45;
            _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v45);
          goto LABEL_100;
        }
        if (v46)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "__nw_protocol_get_input_frames";
          uint64_t v37 = "%{public}s called with null input_protocol, no backtrace";
          goto LABEL_99;
        }
      }
      else
      {
        char v35 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v57 = "__nw_protocol_get_input_frames";
          uint64_t v37 = "%{public}s called with null input_protocol, backtrace limit exceeded";
          goto LABEL_99;
        }
      }
    }
LABEL_100:
    if (v34) {
      free(v34);
    }
    uint64_t v14 = 0;
    goto LABEL_14;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v57 = "__nw_protocol_get_input_frames";
  char v30 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v54 = 0;
  if (__nwlog_fault(v30, &type, &v54))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        os_log_type_t v33 = "%{public}s called with null protocol";
LABEL_93:
        _os_log_impl(&dword_1830D4000, v31, v32, v33, buf, 0xCu);
      }
    }
    else if (v54)
    {
      Class v43 = (char *)__nw_create_backtrace_string();
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v44 = os_log_type_enabled(v31, type);
      if (v43)
      {
        if (v44)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v57 = "__nw_protocol_get_input_frames";
          __int16 v58 = 2082;
          os_log_type_t v59 = v43;
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v43);
        goto LABEL_94;
      }
      if (v44)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        os_log_type_t v33 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
    }
    else
    {
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v31, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v57 = "__nw_protocol_get_input_frames";
        os_log_type_t v33 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
    }
  }
LABEL_94:
  if (v30) {
    free(v30);
  }
  return 0;
}

uint64_t nw_protocol_ipv4_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v206 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
    int v124 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v124, &v192, v188)) {
      goto LABEL_245;
    }
    if (v192 == 17)
    {
      __int16 v121 = __nwlog_obj();
      os_log_type_t v122 = v192;
      if (os_log_type_enabled(v121, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        uint64_t v123 = "%{public}s called with null protocol";
LABEL_244:
        _os_log_impl(&dword_1830D4000, v121, v122, v123, buf, 0xCu);
      }
LABEL_245:
      if (v124) {
        free(v124);
      }
      return 0;
    }
    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v121 = __nwlog_obj();
      os_log_type_t v122 = v192;
      if (os_log_type_enabled(v121, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        uint64_t v123 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v121 = __nwlog_obj();
    os_log_type_t v122 = v192;
    BOOL v128 = os_log_type_enabled(v121, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v128)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        uint64_t v123 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v128)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v129 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_234:
      _os_log_impl(&dword_1830D4000, v121, v122, v129, buf, 0x16u);
    }
LABEL_235:
    free(backtrace_string);
    goto LABEL_245;
  }
  handle = a1->handle;
  p_output_handler = &a1[1].output_handler;
  if (handle == &nw_protocol_ref_counted_handle) {
    uint64_t v8 = &a1[1].output_handler;
  }
  else {
    uint64_t v8 = 0;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
    int v124 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v192) = 16;
    v188[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v124, &v192, v188)) {
      goto LABEL_245;
    }
    if (v192 == 17)
    {
      __int16 v121 = __nwlog_obj();
      os_log_type_t v122 = v192;
      if (os_log_type_enabled(v121, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        uint64_t v123 = "%{public}s called with null ipv4";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v188[0] == OS_LOG_TYPE_DEFAULT)
    {
      __int16 v121 = __nwlog_obj();
      os_log_type_t v122 = v192;
      if (os_log_type_enabled(v121, (os_log_type_t)v192))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        uint64_t v123 = "%{public}s called with null ipv4, backtrace limit exceeded";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    __int16 v121 = __nwlog_obj();
    os_log_type_t v122 = v192;
    BOOL v130 = os_log_type_enabled(v121, (os_log_type_t)v192);
    if (!backtrace_string)
    {
      if (v130)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
        uint64_t v123 = "%{public}s called with null ipv4, no backtrace";
        goto LABEL_244;
      }
      goto LABEL_245;
    }
    if (v130)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v129 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_234;
    }
    goto LABEL_235;
  }
  if (a3 >= 0xFFFFFFEC) {
    int v9 = -1;
  }
  else {
    int v9 = a3 + 20;
  }
  int v10 = a4 + 20;
  if (a4 >= 0xFFFFFFEC) {
    int v10 = -1;
  }
  unsigned int v147 = v10;
  unsigned int v148 = v9;
  uint64_t v192 = 0;
  id v193 = &v192;
  int v195 = 0;
  uint64_t v194 = 0x2000000000;
  v144 = (char *)&a1[3].handle + 1;
  output_handler = a1->output_handler;
  if (!output_handler)
  {
LABEL_195:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
    uint64_t v113 = (char *)_os_log_send_and_compose_impl();
    v188[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v186[0]) = 0;
    if (!__nwlog_fault(v113, v188, v186)) {
      goto LABEL_209;
    }
    if (v188[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v114 = __nwlog_obj();
      os_log_type_t v115 = v188[0];
      if (!os_log_type_enabled(v114, v188[0])) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v116 = "%{public}s called with null protocol";
    }
    else if (LOBYTE(v186[0]))
    {
      uint64_t v117 = (char *)__nw_create_backtrace_string();
      uint64_t v114 = __nwlog_obj();
      os_log_type_t v115 = v188[0];
      BOOL v118 = os_log_type_enabled(v114, v188[0]);
      if (v117)
      {
        if (v118)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v117;
          _os_log_impl(&dword_1830D4000, v114, v115, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v117);
LABEL_209:
        if (v113) {
          free(v113);
        }
        *((_DWORD *)v193 + 6) = 0;
LABEL_212:
        if (((uint64_t)a1[3].handle & 1) == 0)
        {
          if (gLogDatapath)
          {
            uint64_t v126 = __nwlog_obj();
            if (os_log_type_enabled(v126, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v144;
              *(_WORD *)&unsigned char buf[22] = 2080;
              id v199 = " ";
              __int16 v200 = 2048;
              v201 = (char *)p_output_handler;
              _os_log_impl(&dword_1830D4000, v126, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p No IPv4 input frame", buf, 0x2Au);
            }
          }
        }
        goto LABEL_214;
      }
      if (!v118) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v116 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v114 = __nwlog_obj();
      os_log_type_t v115 = v188[0];
      if (!os_log_type_enabled(v114, v188[0])) {
        goto LABEL_209;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      uint64_t v116 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v114, v115, v116, buf, 0xCu);
    goto LABEL_209;
  }
  uint64_t v12 = a6;
  while (2)
  {
    id v150 = output_handler->handle;
    if (v150 == &nw_protocol_ref_counted_handle)
    {
      callbacks = output_handler[1].callbacks;
      if (callbacks) {
        output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
    }
    uint64_t v14 = a1->handle;
    if (v14 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v15 = a1[1].callbacks;
      if (v15) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v15->add_input_handler + 1);
      }
    }
    if (!v12)
    {
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      BOOL v95 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      os_log_t logc = (os_log_t)v95;
      if (!__nwlog_fault(v95, v188, v186)) {
        goto LABEL_186;
      }
      if (v188[0] == OS_LOG_TYPE_FAULT)
      {
        size_t v96 = __nwlog_obj();
        os_log_type_t v97 = v188[0];
        *(void *)typeb = v96;
        if (!os_log_type_enabled(v96, v188[0])) {
          goto LABEL_186;
        }
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        os_log_type_t v92 = *(NSObject **)typeb;
        os_log_type_t v93 = v97;
        os_log_type_t v94 = "%{public}s called with null return_array";
        uint32_t v98 = 12;
        goto LABEL_185;
      }
      if (LOBYTE(v186[0]))
      {
        BOOL v99 = (char *)__nw_create_backtrace_string();
        typed = __nwlog_obj();
        os_log_type_t v132 = v188[0];
        BOOL v106 = os_log_type_enabled(typed, v188[0]);
        if (v99)
        {
          if (v106)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v99;
            char v102 = typed;
            os_log_type_t v103 = v132;
            int v104 = "%{public}s called with null return_array, dumping backtrace:%{public}s";
            uint32_t v105 = 22;
LABEL_174:
            _os_log_impl(&dword_1830D4000, v102, v103, v104, buf, v105);
          }
LABEL_175:
          free(v99);
          goto LABEL_186;
        }
        if (v106)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          os_log_type_t v92 = typed;
          os_log_type_t v93 = v132;
          os_log_type_t v94 = "%{public}s called with null return_array, no backtrace";
          uint32_t v98 = 12;
          goto LABEL_185;
        }
      }
      else
      {
        size_t v111 = __nwlog_obj();
        os_log_type_t v112 = v188[0];
        *(void *)typef = v111;
        if (os_log_type_enabled(v111, v188[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          os_log_type_t v92 = *(NSObject **)typef;
          os_log_type_t v93 = v112;
          os_log_type_t v94 = "%{public}s called with null return_array, backtrace limit exceeded";
          uint32_t v98 = 12;
          goto LABEL_185;
        }
      }
LABEL_186:
      if (logc) {
        free(logc);
      }
      int v18 = 0;
      if (v14 != &nw_protocol_ref_counted_handle) {
        goto LABEL_26;
      }
      goto LABEL_25;
    }
    uint64_t v16 = output_handler->callbacks;
    if (!v16
      || (get_input_frames = (uint64_t (*)(void, void, void, void, void, void))v16->get_input_frames) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      name = output_handler->identifier->name;
      if (!name) {
        name = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = name;
      *(_WORD *)&unsigned char buf[22] = 2048;
      id v199 = (const char *)output_handler;
      uint64_t v88 = (const char *)_os_log_send_and_compose_impl();
      v188[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v186[0]) = 0;
      os_log_t logc = (os_log_t)v88;
      if (__nwlog_fault(v88, v188, v186))
      {
        if (v188[0] == OS_LOG_TYPE_FAULT)
        {
          int v89 = __nwlog_obj();
          os_log_type_t v90 = v188[0];
          *(void *)typea = v89;
          if (!os_log_type_enabled(v89, v188[0])) {
            goto LABEL_186;
          }
          BOOL v91 = output_handler->identifier->name;
          if (!v91) {
            BOOL v91 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v91;
          *(_WORD *)&unsigned char buf[22] = 2048;
          id v199 = (const char *)output_handler;
          os_log_type_t v92 = *(NSObject **)typea;
          os_log_type_t v93 = v90;
          os_log_type_t v94 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_184:
          uint32_t v98 = 32;
LABEL_185:
          _os_log_impl(&dword_1830D4000, v92, v93, v94, buf, v98);
          goto LABEL_186;
        }
        if (!LOBYTE(v186[0]))
        {
          uint64_t v107 = __nwlog_obj();
          os_log_type_t v108 = v188[0];
          *(void *)typee = v107;
          if (!os_log_type_enabled(v107, v188[0])) {
            goto LABEL_186;
          }
          __int16 v109 = output_handler->identifier->name;
          if (!v109) {
            __int16 v109 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v109;
          *(_WORD *)&unsigned char buf[22] = 2048;
          id v199 = (const char *)output_handler;
          os_log_type_t v92 = *(NSObject **)typee;
          os_log_type_t v93 = v108;
          os_log_type_t v94 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
          goto LABEL_184;
        }
        BOOL v99 = (char *)__nw_create_backtrace_string();
        typeCC_SHA256_CTX c = __nwlog_obj();
        os_log_type_t v131 = v188[0];
        BOOL v100 = os_log_type_enabled(typec, v188[0]);
        if (!v99)
        {
          if (!v100) {
            goto LABEL_186;
          }
          id v110 = output_handler->identifier->name;
          if (!v110) {
            id v110 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v110;
          *(_WORD *)&unsigned char buf[22] = 2048;
          id v199 = (const char *)output_handler;
          os_log_type_t v92 = typec;
          os_log_type_t v93 = v131;
          os_log_type_t v94 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
          goto LABEL_184;
        }
        if (v100)
        {
          int v101 = output_handler->identifier->name;
          if (!v101) {
            int v101 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v101;
          *(_WORD *)&unsigned char buf[22] = 2048;
          id v199 = (const char *)output_handler;
          __int16 v200 = 2082;
          v201 = v99;
          char v102 = typec;
          os_log_type_t v103 = v131;
          int v104 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s";
          uint32_t v105 = 42;
          goto LABEL_174;
        }
        goto LABEL_175;
      }
      goto LABEL_186;
    }
    int v18 = get_input_frames(output_handler, a1, v148, v147, a5, v12);
    if (v14 == &nw_protocol_ref_counted_handle)
    {
LABEL_25:
      if (a1->handle == &nw_protocol_ref_counted_handle)
      {
        char v83 = a1[1].callbacks;
        if (v83)
        {
          uint64_t v84 = (nw_protocol_callbacks *)((char *)v83 - 1);
          a1[1].callbacks = v84;
          if (!v84)
          {
            int v85 = *(void (***)(void))a1[1].flow_id;
            if (v85)
            {
              *(void *)a1[1].flow_id = 0;
              v85[2](v85);
              _Block_release(v85);
            }
            if (a1[1].flow_id[8])
            {
              id v86 = *(const void **)a1[1].flow_id;
              if (v86) {
                _Block_release(v86);
              }
            }
            free(a1);
          }
        }
      }
    }
LABEL_26:
    if (v150 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
    {
      id v79 = output_handler[1].callbacks;
      if (v79)
      {
        unsigned int v80 = (nw_protocol_callbacks *)((char *)v79 - 1);
        output_handler[1].callbacks = v80;
        if (!v80)
        {
          BOOL v81 = *(void (***)(void))output_handler[1].flow_id;
          if (v81)
          {
            *(void *)output_handler[1].flow_id = 0;
            v81[2](v81);
            _Block_release(v81);
          }
          if (output_handler[1].flow_id[8])
          {
            int v82 = *(const void **)output_handler[1].flow_id;
            if (v82) {
              _Block_release(v82);
            }
          }
          free(output_handler);
        }
      }
    }
    *((_DWORD *)v193 + 6) = v18;
    if (!v18) {
      goto LABEL_212;
    }
    *(void *)os_log_type_t v188 = 0;
    nw_endpoint_t v189 = v188;
    int v191 = 0;
    uint64_t v190 = 0x2000000000;
    v186[0] = 0;
    v186[1] = v186;
    v186[2] = 0x2000000000;
    char v187 = 0;
    v182[0] = 0;
    v182[1] = v182;
    v182[2] = 0x2000000000;
    char v183 = 0;
    uint64_t v184 = 0;
    int v185 = (nw_frame **)&v184;
    v172[0] = MEMORY[0x1E4F143A8];
    v172[1] = 0x40000000;
    v173 = (uint64_t (*)(void *))___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    id v174 = &unk_1E524B0D8;
    id v175 = v186;
    nw_endpoint_t v176 = v182;
    nw_endpoint_t v179 = v12;
    id v180 = v8;
    id v181 = &v184;
    os_log_type_t v177 = &v192;
    id v178 = v188;
    os_log_type_t tqh_first = v12->tqh_first;
    do
    {
      if (!tqh_first) {
        break;
      }
      uint64_t v20 = (nw_frame *)*((void *)tqh_first + 4);
      char v21 = v173(v172);
      os_log_type_t tqh_first = v20;
    }
    while ((v21 & 1) != 0);
    char v171 = 0;
    do
    {
      int v24 = nw_protocol_ipv4_process_reassembly((uint64_t)v8, 0, (uint64_t)&v184, 0, &v171);
      *((_DWORD *)v193 + 6) += v24;
      if (!v171) {
        break;
      }
      v170[0] = 0;
      v170[1] = v170;
      uint64_t v166 = 0;
      os_log_type_t v167 = &v166;
      int v169 = 0;
      uint64_t v168 = 0x2000000000;
      uint64_t v25 = a1->output_handler;
      if (!v25)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        char v54 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t v197 = OS_LOG_TYPE_ERROR;
        char v196 = 0;
        if (!__nwlog_fault(v54, &v197, &v196)) {
          goto LABEL_127;
        }
        if (v197 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v55 = gLogObj;
          os_log_type_t v56 = v197;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            uint64_t v57 = v55;
            os_log_type_t v58 = v56;
            os_log_type_t v59 = "%{public}s called with null protocol";
            goto LABEL_126;
          }
          goto LABEL_127;
        }
        if (v196)
        {
          BOOL v66 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v67 = gLogObj;
          os_log_type_t v68 = v197;
          BOOL v69 = os_log_type_enabled((os_log_t)gLogObj, v197);
          if (v66)
          {
            if (v69)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v66;
              _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v66);
            goto LABEL_127;
          }
          if (!v69)
          {
LABEL_127:
            if (v54) {
              free(v54);
            }
            int v32 = 0;
            goto LABEL_52;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          uint64_t v57 = v67;
          os_log_type_t v58 = v68;
          os_log_type_t v59 = "%{public}s called with null protocol, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v73 = gLogObj;
          os_log_type_t v74 = v197;
          if (!os_log_type_enabled((os_log_t)gLogObj, v197)) {
            goto LABEL_127;
          }
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          uint64_t v57 = v73;
          os_log_type_t v58 = v74;
          os_log_type_t v59 = "%{public}s called with null protocol, backtrace limit exceeded";
        }
LABEL_126:
        _os_log_impl(&dword_1830D4000, v57, v58, v59, buf, 0xCu);
        goto LABEL_127;
      }
      id v26 = v25->handle;
      if (v26 == &nw_protocol_ref_counted_handle)
      {
        os_log_type_t v27 = v25[1].callbacks;
        if (v27) {
          v25[1].callbacks = (nw_protocol_callbacks *)((char *)&v27->add_input_handler + 1);
        }
      }
      uint64_t v28 = a1->handle;
      if (v28 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v29 = a1[1].callbacks;
        if (v29) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v29->add_input_handler + 1);
        }
      }
      char v30 = v25->callbacks;
      if (!v30
        || (uint64_t v31 = (uint64_t (*)(nw_protocol *, nw_protocol *, uint64_t, uint64_t, uint64_t, void *))v30->get_input_frames) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v47 = v25->identifier->name;
        if (!v47) {
          os_log_type_t v47 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v47;
        *(_WORD *)&unsigned char buf[22] = 2048;
        id v199 = (const char *)v25;
        BOOL v48 = (const char *)_os_log_send_and_compose_impl();
        os_log_type_t v197 = OS_LOG_TYPE_ERROR;
        char v196 = 0;
        int v151 = (char *)v48;
        if (__nwlog_fault(v48, &v197, &v196))
        {
          if (v197 != OS_LOG_TYPE_FAULT)
          {
            if (v196)
            {
              __int16 v60 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_t loga = gLogObj;
              os_log_type_t type = v197;
              BOOL v61 = os_log_type_enabled((os_log_t)gLogObj, v197);
              if (v60)
              {
                if (v61)
                {
                  __int16 v62 = v25->identifier->name;
                  if (!v62) {
                    __int16 v62 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v62;
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  id v199 = (const char *)v25;
                  __int16 v200 = 2082;
                  v201 = v60;
                  _os_log_impl(&dword_1830D4000, loga, type, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }
                free(v60);
                goto LABEL_118;
              }
              if (!v61) {
                goto LABEL_118;
              }
              size_t v72 = v25->identifier->name;
              if (!v72) {
                size_t v72 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v72;
              *(_WORD *)&unsigned char buf[22] = 2048;
              id v199 = (const char *)v25;
              unint64_t v51 = loga;
              os_log_type_t v52 = type;
              uint32_t v53 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v70 = v197;
              os_log_t logb = (os_log_t)gLogObj;
              if (!os_log_type_enabled((os_log_t)gLogObj, v197)) {
                goto LABEL_118;
              }
              size_t v71 = v25->identifier->name;
              if (!v71) {
                size_t v71 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v71;
              *(_WORD *)&unsigned char buf[22] = 2048;
              id v199 = (const char *)v25;
              unint64_t v51 = logb;
              os_log_type_t v52 = v70;
              uint32_t v53 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
            }
LABEL_117:
            _os_log_impl(&dword_1830D4000, v51, v52, v53, buf, 0x20u);
            goto LABEL_118;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v49 = v197;
          os_log_t log = (os_log_t)gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, v197))
          {
            os_log_type_t v50 = v25->identifier->name;
            if (!v50) {
              os_log_type_t v50 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v50;
            *(_WORD *)&unsigned char buf[22] = 2048;
            id v199 = (const char *)v25;
            unint64_t v51 = log;
            os_log_type_t v52 = v49;
            uint32_t v53 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
            goto LABEL_117;
          }
        }
LABEL_118:
        if (v151) {
          free(v151);
        }
        int v32 = 0;
        if (v28 != &nw_protocol_ref_counted_handle) {
          goto LABEL_50;
        }
LABEL_49:
        if (a1->handle == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v39 = a1[1].callbacks;
          if (v39)
          {
            BOOL v40 = (nw_protocol_callbacks *)((char *)v39 - 1);
            a1[1].callbacks = v40;
            if (!v40)
            {
              BOOL v41 = *(void (***)(void))a1[1].flow_id;
              if (v41)
              {
                *(void *)a1[1].flow_id = 0;
                v41[2](v41);
                _Block_release(v41);
              }
              if (a1[1].flow_id[8])
              {
                BOOL v42 = *(const void **)a1[1].flow_id;
                if (v42) {
                  _Block_release(v42);
                }
              }
              free(a1);
            }
          }
        }
        goto LABEL_50;
      }
      int v32 = v31(v25, a1, 1, 0xFFFFFFFFLL, 1, v170);
      if (v28 == &nw_protocol_ref_counted_handle) {
        goto LABEL_49;
      }
LABEL_50:
      if (v26 == &nw_protocol_ref_counted_handle && v25->handle == &nw_protocol_ref_counted_handle)
      {
        Class v43 = v25[1].callbacks;
        if (v43)
        {
          BOOL v44 = (nw_protocol_callbacks *)((char *)v43 - 1);
          v25[1].callbacks = v44;
          if (!v44)
          {
            uint64_t v45 = *(void (***)(void))v25[1].flow_id;
            if (v45)
            {
              *(void *)v25[1].flow_id = 0;
              v45[2](v45);
              _Block_release(v45);
            }
            if (v25[1].flow_id[8])
            {
              BOOL v46 = *(const void **)v25[1].flow_id;
              if (v46) {
                _Block_release(v46);
              }
            }
            free(v25);
          }
        }
      }
LABEL_52:
      int v169 = v32;
      if (*((_DWORD *)v167 + 6))
      {
        if (((uint64_t)a1[3].handle & 1) == 0)
        {
          if (gLogDatapath)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v63 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
            {
              int v64 = *((_DWORD *)v167 + 6);
              os_log_type_t v65 = "s";
              if (v64 == 1) {
                os_log_type_t v65 = "";
              }
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v144;
              *(_WORD *)&unsigned char buf[22] = 2080;
              id v199 = " ";
              __int16 v200 = 2048;
              v201 = (char *)p_output_handler;
              __int16 v202 = 1024;
              int v203 = v64;
              __int16 v204 = 2080;
              os_log_type_t v205 = v65;
              _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Found %u IPv4 extra fragment%s", buf, 0x3Au);
            }
          }
        }
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2000000000;
        LOBYTE(v199) = 0;
        v157[0] = MEMORY[0x1E4F143A8];
        v157[1] = 0x40000000;
        BOOL v158 = (uint64_t (*)(void *))___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_22;
        v159 = &unk_1E524B100;
        id v164 = v170;
        v165 = &v184;
        nw_endpoint_t v160 = &v166;
        v161 = v188;
        id v162 = buf;
        v163 = v8;
        uint64_t v33 = v170[0];
        do
        {
          if (!v33) {
            break;
          }
          uint64_t v34 = *(void *)(v33 + 32);
          char v35 = v158(v157);
          uint64_t v33 = v34;
        }
        while ((v35 & 1) != 0);
        v152[0] = MEMORY[0x1E4F143A8];
        v152[1] = 0x40000000;
        os_log_type_t v153 = ___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke_2;
        BOOL v154 = &__block_descriptor_tmp_24_87680;
        os_log_type_t v155 = v170;
        id v156 = v8;
        uint64_t v36 = v170[0];
        do
        {
          if (!v36) {
            break;
          }
          uint64_t v37 = *(void *)(v36 + 32);
          char v38 = ((uint64_t (*)(void *))v153)(v152);
          uint64_t v36 = v37;
        }
        while ((v38 & 1) != 0);
        if (*(unsigned char *)(*(void *)&buf[8] + 24)) {
          int v22 = 34;
        }
        else {
          int v22 = 0;
        }
        _Block_object_dispose(buf, 8);
      }
      else
      {
        int v22 = 34;
      }
      _Block_object_dispose(&v166, 8);
      if (v22) {
        BOOL v23 = 1;
      }
      else {
        BOOL v23 = v171 == 0;
      }
    }
    while (!v23);
    uint64_t v12 = a6;
    if (v184)
    {
      *a6->tqh_last = (nw_frame *)v184;
      size_t v75 = v185;
      *(void *)(v184 + 40) = a6->tqh_last;
      a6->tqh_last = v75;
      uint64_t v184 = 0;
      int v185 = (nw_frame **)&v184;
    }
    *((_DWORD *)v193 + 6) += *((_DWORD *)v189 + 6);
    int v76 = nw_protocol_ipv4_process_reassembly((uint64_t)v8, 0, (uint64_t)a6, 1, 0);
    int v77 = *((_DWORD *)v193 + 6) + v76;
    *((_DWORD *)v193 + 6) = v77;
    if (!v77)
    {
      if (((uint64_t)a1[3].handle & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v78 = gLogObj;
        if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_get_input_frames";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v144;
          *(_WORD *)&unsigned char buf[22] = 2080;
          id v199 = " ";
          __int16 v200 = 2048;
          v201 = (char *)p_output_handler;
          _os_log_impl(&dword_1830D4000, v78, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Dropped inbound packets, checking for more", buf, 0x2Au);
        }
      }
      _Block_object_dispose(v182, 8);
      _Block_object_dispose(v186, 8);
      _Block_object_dispose(v188, 8);
      output_handler = a1->output_handler;
      if (!output_handler) {
        goto LABEL_195;
      }
      continue;
    }
    break;
  }
  _Block_object_dispose(v182, 8);
  _Block_object_dispose(v186, 8);
  _Block_object_dispose(v188, 8);
LABEL_214:
  uint64_t v119 = *((unsigned int *)v193 + 6);
  _Block_object_dispose(&v192, 8);
  return v119;
}

uint64_t nw_protocol_ipv4_process_reassembly(uint64_t a1, int a2, uint64_t a3, int a4, unsigned char *a5)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = *(void *)(a1 + 64);
  if (!v8)
  {
    uint64_t v12 = 0;
    goto LABEL_84;
  }
  if (!a5 && *(unsigned __int16 *)(a1 + 132) == a2 && a4 == 0)
  {
    uint64_t v12 = 0;
LABEL_85:
    *(_WORD *)(a1 + 132) = a2;
    return v12;
  }
  if (!a3)
  {
    uint64_t v12 = 0;
    if (!a4) {
      goto LABEL_84;
    }
    goto LABEL_74;
  }
  uint64_t v87 = 0;
  uint64_t v88 = &v87;
  uint64_t v89 = 0x2000000000;
  char v90 = 0;
  uint64_t v83 = 0;
  uint64_t v84 = &v83;
  uint64_t v85 = 0x2000000000;
  __int16 v86 = 0;
  v77[0] = MEMORY[0x1E4F143A8];
  v77[1] = 0x40000000;
  uint64_t v78 = (uint64_t (*)(void *))___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke;
  id v79 = &unk_1E524B170;
  BOOL v81 = &v87;
  uint64_t v82 = a1;
  unsigned int v80 = &v83;
  do
  {
    if (!v8) {
      break;
    }
    uint64_t v13 = *(void *)(v8 + 32);
    char v14 = v78(v77);
    uint64_t v8 = v13;
  }
  while ((v14 & 1) != 0);
  if (*((unsigned char *)v88 + 24))
  {
    int v15 = *((unsigned __int16 *)v84 + 12) + 20;
    uint64_t v16 = nw_calloc_type<unsigned char>(*((unsigned __int16 *)v84 + 12) + 20);
    uint64_t v17 = nw_frame_create(0, v16, v15, (uint64_t)nw_protocol_ipv4_frame_input_finalizer, a1);
    if (v17)
    {
      uint64_t v18 = v17;
      if ((*(unsigned char *)(a1 + 136) & 1) == 0)
      {
        if (gLogDatapath)
        {
          os_log_type_t v52 = __nwlog_obj();
          if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
          {
            int v53 = *(unsigned __int16 *)(a1 + 132);
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            LOWORD(v92) = 2048;
            *(void *)((char *)&v92 + 2) = a1;
            WORD5(v92) = 1024;
            HIDWORD(v92) = v53;
            *(_WORD *)os_log_type_t v93 = 1024;
            *(_DWORD *)&v93[2] = v15;
            _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Fragments for IP ID %u are complete, aggregate length %u", buf, 0x36u);
          }
        }
      }
      uint64_t v19 = *(void *)(a1 + 64);
      unsigned int v76 = 0;
      uint64_t v20 = nw_frame_unclaimed_bytes(v19, &v76);
      if (!v20)
      {
        if ((*(unsigned char *)(a1 + 136) & 1) == 0)
        {
          char v54 = __nwlog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            LOWORD(v92) = 2048;
            *(void *)((char *)&v92 + 2) = a1;
            _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
          }
        }
        *(void *)(a1 + 48) = 0;
        goto LABEL_114;
      }
      if (v76 > 0x13)
      {
        int v22 = *(_DWORD *)(v20 + 16);
        *(_OWORD *)uint64_t v16 = *(_OWORD *)v20;
        *(_DWORD *)(v16 + 16) = v22;
        *(_WORD *)(v16 + 2) = bswap32(v15) >> 16;
        *(_WORD *)(v16 + 6) = 0;
        if ((*(_WORD *)(v18 + 204) & 8) == 0)
        {
          uint64_t v23 = v18 + 120;
          int v24 = *(void **)(v18 + 168);
          if (v24)
          {
            os_release(v24);
            *(void *)(v18 + 168) = 0;
          }
          uint64_t v25 = *(void *)(v18 + 64);
          *(unsigned char *)(v18 + 186) |= 0x40u;
          if (v25)
          {
            if (v25 != v23)
            {
              __nwlog_obj();
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v25;
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)&unsigned char buf[24] = v18 + 120;
              type[0] = OS_LOG_TYPE_ERROR;
              LOBYTE(v74[0]) = 0;
              os_log_type_t v68 = (char *)_os_log_send_and_compose_impl();
              if (!__nwlog_fault(v68, type, v74)) {
                goto LABEL_64;
              }
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                BOOL v66 = __nwlog_obj();
                os_log_type_t log = type[0];
                if (!os_log_type_enabled(v66, type[0])) {
                  goto LABEL_64;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v25;
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)&unsigned char buf[24] = v18 + 120;
                id v26 = "%{public}s Existing metadata %p doesn't match expected %p";
              }
              else
              {
                if (LOBYTE(v74[0]))
                {
                  backtrace_string = __nw_create_backtrace_string();
                  os_log_t loga = __nwlog_obj();
                  os_log_type_t v63 = type[0];
                  BOOL v33 = os_log_type_enabled(loga, type[0]);
                  uint64_t v34 = (char *)backtrace_string;
                  if (backtrace_string)
                  {
                    if (v33)
                    {
                      *(_DWORD *)buf = 136446978;
                      *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                      *(_WORD *)&unsigned char buf[12] = 2048;
                      *(void *)&buf[14] = v25;
                      *(_WORD *)&unsigned char buf[22] = 2048;
                      *(void *)&unsigned char buf[24] = v18 + 120;
                      LOWORD(v92) = 2082;
                      *(void *)((char *)&v92 + 2) = backtrace_string;
                      _os_log_impl(&dword_1830D4000, loga, v63, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
                      uint64_t v34 = (char *)backtrace_string;
                    }
                    free(v34);
                    goto LABEL_64;
                  }
                  if (!v33)
                  {
LABEL_64:
                    if (v68) {
                      free(v68);
                    }
                    goto LABEL_66;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                  *(_WORD *)&unsigned char buf[12] = 2048;
                  *(void *)&buf[14] = v25;
                  *(_WORD *)&unsigned char buf[22] = 2048;
                  *(void *)&unsigned char buf[24] = v18 + 120;
                  id v26 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
                  char v35 = loga;
                  os_log_type_t v36 = v63;
LABEL_63:
                  _os_log_impl(&dword_1830D4000, v35, v36, v26, buf, 0x20u);
                  goto LABEL_64;
                }
                BOOL v66 = __nwlog_obj();
                os_log_type_t log = type[0];
                if (!os_log_type_enabled(v66, type[0])) {
                  goto LABEL_64;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = v25;
                *(_WORD *)&unsigned char buf[22] = 2048;
                *(void *)&unsigned char buf[24] = v18 + 120;
                id v26 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
              }
              char v35 = v66;
              os_log_type_t v36 = log;
              goto LABEL_63;
            }
          }
          else
          {
            *(void *)(v18 + 64) = v23;
            *(void *)(v18 + 72) = v23;
            *(void *)(v18 + 120) = 0;
            *(void *)(v18 + 128) = v18 + 64;
          }
        }
LABEL_66:
        nw_frame_claim(v18, v21, 20, 0);
        v74[0] = 0;
        v74[1] = v74;
        int v75 = 20;
        v74[2] = 0x2000000000;
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 0x40000000;
        *(void *)&buf[16] = ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke_27;
        *(void *)&unsigned char buf[24] = &unk_1E524B198;
        *(void *)&long long v92 = v74;
        *((void *)&v92 + 1) = a1;
        *(_DWORD *)&v93[8] = v15;
        *(void *)os_log_type_t v93 = v16;
        uint64_t v37 = *(void *)(a1 + 64);
        do
        {
          if (!v37) {
            break;
          }
          uint64_t v38 = *(void *)(v37 + 32);
          char v39 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
          uint64_t v37 = v38;
        }
        while ((v39 & 1) != 0);
        *(void *)(v18 + 16) = 0;
        BOOL v40 = *(uint64_t **)(a1 + 88);
        *(void *)(v18 + 24) = v40;
        uint64_t *v40 = v18;
        *(void *)(a1 + 88) = v18 + 16;
        *(void *)(v18 + 32) = 0;
        BOOL v41 = *(uint64_t **)(a3 + 8);
        *(void *)(v18 + 40) = v41;
        uint64_t *v41 = v18;
        *(void *)(a3 + 8) = v18 + 32;
        *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
        uint64_t v70 = 0x40000000;
        size_t v71 = ___ZL43nw_protocol_ipv4_append_reassembled_packetsP16nw_protocol_ipv4P16nw_frame_array_sPb_block_invoke_29;
        size_t v72 = &__block_descriptor_tmp_30_87745;
        uint64_t v73 = a1;
        uint64_t v42 = *(void *)(a1 + 64);
        do
        {
          if (!v42) {
            break;
          }
          uint64_t v43 = *(void *)(v42 + 32);
          char v44 = ((uint64_t (*)(os_log_type_t *))v71)(type);
          uint64_t v42 = v43;
        }
        while ((v44 & 1) != 0);
        _Block_object_dispose(v74, 8);
        uint64_t v12 = 1;
        goto LABEL_73;
      }
      if (*(unsigned char *)(a1 + 136))
      {
LABEL_114:
        os_release((void *)v18);
        uint64_t v12 = 0;
        goto LABEL_73;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = a1 + 137;
      *(_WORD *)&unsigned char buf[22] = 2080;
      *(void *)&unsigned char buf[24] = " ";
      LOWORD(v92) = 2048;
      *(void *)((char *)&v92 + 2) = a1;
      WORD5(v92) = 1024;
      HIDWORD(v92) = v76;
      uint64_t v55 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(v74[0]) = 0;
      if (__nwlog_fault(v55, type, v74))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v56 = __nwlog_obj();
          os_log_type_t v57 = type[0];
          if (!os_log_type_enabled(v56, type[0])) {
            goto LABEL_112;
          }
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 137;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          LOWORD(v92) = 2048;
          *(void *)((char *)&v92 + 2) = a1;
          WORD5(v92) = 1024;
          HIDWORD(v92) = v76;
          os_log_type_t v58 = "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u)";
          goto LABEL_111;
        }
        if (!LOBYTE(v74[0]))
        {
          os_log_type_t v56 = __nwlog_obj();
          os_log_type_t v57 = type[0];
          if (!os_log_type_enabled(v56, type[0])) {
            goto LABEL_112;
          }
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 137;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          LOWORD(v92) = 2048;
          *(void *)((char *)&v92 + 2) = a1;
          WORD5(v92) = 1024;
          HIDWORD(v92) = v76;
          os_log_type_t v58 = "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u), backtrace limit exceeded";
          goto LABEL_111;
        }
        BOOL v61 = (char *)__nw_create_backtrace_string();
        os_log_type_t v56 = __nwlog_obj();
        os_log_type_t v57 = type[0];
        BOOL v62 = os_log_type_enabled(v56, type[0]);
        if (v61)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&unsigned char buf[22] = 2080;
            *(void *)&unsigned char buf[24] = " ";
            LOWORD(v92) = 2048;
            *(void *)((char *)&v92 + 2) = a1;
            WORD5(v92) = 1024;
            HIDWORD(v92) = v76;
            *(_WORD *)os_log_type_t v93 = 2082;
            *(void *)&v93[2] = v61;
            _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u), dumping backtrace:%{public}s", buf, 0x3Au);
          }
          free(v61);
          goto LABEL_112;
        }
        if (v62)
        {
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 137;
          *(_WORD *)&unsigned char buf[22] = 2080;
          *(void *)&unsigned char buf[24] = " ";
          LOWORD(v92) = 2048;
          *(void *)((char *)&v92 + 2) = a1;
          WORD5(v92) = 1024;
          HIDWORD(v92) = v76;
          os_log_type_t v58 = "%{public}s %{public}s%s%p Invalid first IP reassembly frame (length %u), no backtrace";
LABEL_111:
          _os_log_impl(&dword_1830D4000, v56, v57, v58, buf, 0x30u);
        }
      }
LABEL_112:
      if (v55) {
        free(v55);
      }
      goto LABEL_114;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v15;
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v74[0]) = 0;
    if (!__nwlog_fault(v27, type, v74)) {
      goto LABEL_55;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        char v30 = "%{public}s nw_frame_create(%u) failed";
LABEL_54:
        _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0x12u);
      }
    }
    else if (LOBYTE(v74[0]))
    {
      uint64_t v31 = (char *)__nw_create_backtrace_string();
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      BOOL v32 = os_log_type_enabled(v28, type[0]);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v15;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v31;
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s nw_frame_create(%u) failed, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v31);
        goto LABEL_55;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        char v30 = "%{public}s nw_frame_create(%u) failed, no backtrace";
        goto LABEL_54;
      }
    }
    else
    {
      uint64_t v28 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v28, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v15;
        char v30 = "%{public}s nw_frame_create(%u) failed, backtrace limit exceeded";
        goto LABEL_54;
      }
    }
LABEL_55:
    if (v27) {
      free(v27);
    }
    if (v16) {
      free((void *)v16);
    }
    uint64_t v12 = 0;
    goto LABEL_73;
  }
  if ((*(unsigned char *)(a1 + 136) & 1) == 0)
  {
    if (gLogDatapath)
    {
      os_log_type_t v59 = __nwlog_obj();
      if (os_log_type_enabled(v59, OS_LOG_TYPE_DEBUG))
      {
        int v60 = *(unsigned __int16 *)(a1 + 132);
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_append_reassembled_packets";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v92) = 2048;
        *(void *)((char *)&v92 + 2) = a1;
        WORD5(v92) = 1024;
        HIDWORD(v92) = v60;
        _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Fragments for IP ID %u incomplete", buf, 0x30u);
      }
    }
  }
  uint64_t v12 = 0;
  if (a5) {
    *a5 = 1;
  }
LABEL_73:
  _Block_object_dispose(&v83, 8);
  _Block_object_dispose(&v87, 8);
  if (!a4) {
    goto LABEL_84;
  }
LABEL_74:
  for (int i = 0; ; ++i)
  {
    uint64_t v46 = *(void *)(a1 + 64);
    if (!v46) {
      break;
    }
    uint64_t v47 = *(void *)(v46 + 32);
    BOOL v48 = *(void **)(v46 + 40);
    if (v47)
    {
      *(void *)(v47 + 40) = v48;
      BOOL v48 = *(void **)(v46 + 40);
    }
    else
    {
      *(void *)(a1 + 72) = v48;
    }
    void *v48 = v47;
    *(void *)(v46 + 32) = 0;
    *(void *)(v46 + 40) = 0;
    nw_frame_finalize(v46);
  }
  if (i)
  {
    if ((*(unsigned char *)(a1 + 136) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v49 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        int v50 = *(unsigned __int16 *)(a1 + 132);
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_reassembly";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&unsigned char buf[22] = 2080;
        *(void *)&unsigned char buf[24] = " ";
        LOWORD(v92) = 2048;
        *(void *)((char *)&v92 + 2) = a1;
        WORD5(v92) = 1024;
        HIDWORD(v92) = v50;
        *(_WORD *)os_log_type_t v93 = 1024;
        *(_DWORD *)&v93[2] = i;
        _os_log_impl(&dword_1830D4000, v49, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Failed to reassemble IP ID %u, dropping %u frames", buf, 0x36u);
      }
    }
  }
LABEL_84:
  if (!a5) {
    goto LABEL_85;
  }
  return v12;
}

uint64_t nw_channel_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, int a4, int a5, nw_frame_array_s *a6)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, type, &v41)) {
      goto LABEL_52;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null channel_protocol";
      goto LABEL_51;
    }
    if (!v41)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null channel_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v24 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v24) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null channel_protocol, no backtrace";
      goto LABEL_51;
    }
    if (!v24) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v25 = "%{public}s called with null channel_protocol, dumping backtrace:%{public}s";
LABEL_37:
    _os_log_impl(&dword_1830D4000, v20, v21, v25, buf, 0x16u);
    goto LABEL_38;
  }
  handle = a1->handle;
  if (!handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, type, &v41)) {
      goto LABEL_52;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null channel";
      goto LABEL_51;
    }
    if (!v41)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null channel, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v26 = os_log_type_enabled(v20, type[0]);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null channel, no backtrace";
      goto LABEL_51;
    }
    if (!v26) {
      goto LABEL_38;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v25 = "%{public}s called with null channel, dumping backtrace:%{public}s";
    goto LABEL_37;
  }
  a6->os_log_type_t tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v19, type, &v41)) {
      goto LABEL_52;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null input_protocol";
      goto LABEL_51;
    }
    if (!v41)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled(v20, type[0])) {
        goto LABEL_52;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      int v22 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_51;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v20 = __nwlog_obj();
    os_log_type_t v21 = type[0];
    BOOL v27 = os_log_type_enabled(v20, type[0]);
    if (backtrace_string)
    {
      if (v27)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        uint64_t v25 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_37;
      }
LABEL_38:
      free(backtrace_string);
      goto LABEL_52;
    }
    if (!v27) {
      goto LABEL_52;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
    int v22 = "%{public}s called with null input_protocol, no backtrace";
LABEL_51:
    _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
LABEL_52:
    if (v19) {
      free(v19);
    }
    return 0;
  }
  unsigned int v11 = ((unsigned __int16)handle[222] | (*((unsigned __int8 *)handle + 446) << 16)) & 0xFFF9FFFF | 0x20000;
  handle[222] = handle[222];
  *((unsigned char *)handle + 446) = BYTE2(v11);
  nw_channel_update_input_source((uint64_t)handle, (uint64_t)a2, 0);
  output_handler_context = a2->output_handler_context;
  if (!output_handler_context)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_channel_get_input_frames";
      *(_WORD *)&unsigned char buf[12] = 1042;
      *(_DWORD *)&buf[14] = 16;
      *(_WORD *)&buf[18] = 2098;
      *(void *)&buf[20] = a2;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, "%{public}s Can't find hash table entry for %{public,uuid_t}.16P", buf, 0x1Cu);
    }
    return 0;
  }
  *(void *)buf = 0;
  *(void *)&buf[8] = buf;
  *(_DWORD *)&unsigned char buf[24] = 0;
  *(void *)&buf[16] = 0x2000000000;
  *(void *)os_log_type_t type = 0;
  uint64_t v38 = type;
  int v40 = 0;
  uint64_t v39 = 0x2000000000;
  v28[0] = MEMORY[0x1E4F143A8];
  v28[1] = 0x40000000;
  os_log_type_t v29 = ___ZL27nw_channel_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
  char v30 = &unk_1E524B880;
  uint64_t v31 = buf;
  BOOL v32 = type;
  int v35 = a5;
  int v36 = a4;
  BOOL v33 = (char *)(output_handler_context + 4);
  uint64_t v34 = a6;
  uint64_t v13 = output_handler_context[4];
  do
  {
    if (!v13) {
      break;
    }
    uint64_t v14 = *(void *)(v13 + 32);
    char v15 = ((uint64_t (*)(void *))v29)(v28);
    uint64_t v13 = v14;
  }
  while ((v15 & 1) != 0);
  uint64_t v16 = *(unsigned int *)(*(void *)&buf[8] + 24);
  _Block_object_dispose(type, 8);
  _Block_object_dispose(buf, 8);
  return v16;
}

void nw_channel_update_input_source(uint64_t a1, uint64_t a2, int a3)
{
  if ((*(_WORD *)(a1 + 444) & 1) == 0 && *(void *)(a1 + 168) && *(void *)(a1 + 224))
  {
    if (!uuid_is_null((const unsigned __int8 *)(a1 + 352))
      && (unint64_t)*(unsigned int *)(a1 + 416) >= *(void *)(a1 + 112) >> 1)
    {
      v21[0] = MEMORY[0x1E4F143A8];
      v21[1] = 0x40000000;
      int v22 = ___ZL30nw_channel_update_input_sourceP10nw_channelP11nw_protocolb_block_invoke;
      uint64_t v23 = &__block_descriptor_tmp_67_88452;
      uint64_t v24 = a1;
      uint64_t v6 = *(void *)(a1 + 336);
      do
      {
        if (!v6) {
          break;
        }
        uint64_t v7 = *(void *)(v6 + 32);
        char v8 = ((uint64_t (*)(void *))v22)(v21);
        uint64_t v6 = v7;
      }
      while ((v8 & 1) != 0);
    }
    if (*(void *)(a1 + 224))
    {
      int v9 = (_WORD *)(a1 + 444);
      *(_WORD *)(a1 + 444) |= 1u;
      unsigned int v10 = os_channel_available_slot_count();
      if (v10) {
        BOOL v11 = 1;
      }
      else {
        BOOL v11 = a3 == 0;
      }
      if (v11)
      {
        unsigned int v12 = v10;
        if (*(_DWORD *)(a1 + 416) - 1 >= v10) {
          int v13 = 0;
        }
        else {
          int v13 = *(_DWORD *)(a1 + 416);
        }
        if (v10)
        {
          int v14 = (unsigned __int16)*v9;
          int v15 = v14 | (*(unsigned __int8 *)(a1 + 446) << 16);
          if ((v14 & 8) == 0)
          {
            *(unsigned char *)(a1 + 446) = BYTE2(v15);
            _WORD *v9 = v15 | 8;
            nw_queue_suspend_source(*(void *)(a1 + 168));
          }
        }
        if (v12 != v13)
        {
          do
          {
            char v16 = nw_channel_add_input_frames(a1, a2);
            if (!*(void *)(a1 + 224)) {
              break;
            }
            unsigned int v17 = os_channel_available_slot_count();
            unsigned int v12 = v17;
            if ((v16 & 1) == 0) {
              break;
            }
            int v18 = *(_DWORD *)(a1 + 416);
            if (v18 - 1 >= v17) {
              int v18 = 0;
            }
          }
          while (v17 != v18);
        }
        if (v12) {
          goto LABEL_30;
        }
      }
      else if (nw_channel_check_defunct(a1))
      {
LABEL_30:
        *v9 &= ~1u;
        return;
      }
      int v19 = (unsigned __int16)*v9;
      if ((v19 & 8) != 0)
      {
        unsigned int v20 = v19 & 0xFFFFFFF7 | (*(unsigned __int8 *)(a1 + 446) << 16);
        _WORD *v9 = v19 & 0xFFF7;
        *(unsigned char *)(a1 + 446) = BYTE2(v20);
        nw_queue_resume_source(*(void *)(a1 + 168));
      }
      goto LABEL_30;
    }
  }
}

uint64_t ___ZL33nw_protocol_ipv4_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)(a1[4] + 8);
  if (!*(unsigned char *)(v4 + 24))
  {
    if (a2)
    {
      unsigned int v6 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
      goto LABEL_12;
    }
LABEL_49:
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v39 = "__nw_frame_is_single_ip_aggregate";
    char v30 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v30, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v39 = "__nw_frame_is_single_ip_aggregate";
          BOOL v33 = "%{public}s called with null frame";
LABEL_62:
          _os_log_impl(&dword_1830D4000, v31, v32, v33, buf, 0xCu);
        }
      }
      else if (v36)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        BOOL v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v39 = "__nw_frame_is_single_ip_aggregate";
            __int16 v40 = 2082;
            char v41 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_63;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v39 = "__nw_frame_is_single_ip_aggregate";
          BOOL v33 = "%{public}s called with null frame, no backtrace";
          goto LABEL_62;
        }
      }
      else
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v39 = "__nw_frame_is_single_ip_aggregate";
          BOOL v33 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_62;
        }
      }
    }
LABEL_63:
    if (v30) {
      free(v30);
    }
    LOBYTE(v15) = 0;
    uint64_t v4 = *(void *)(a1[4] + 8);
    goto LABEL_13;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v39 = "__nw_frame_is_packet_chain_member";
    uint64_t v24 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v24, &type, &v36)) {
      goto LABEL_47;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "__nw_frame_is_packet_chain_member";
      BOOL v27 = "%{public}s called with null frame";
    }
    else if (v36)
    {
      uint64_t v28 = (char *)__nw_create_backtrace_string();
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v29 = os_log_type_enabled(v25, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v39 = "__nw_frame_is_packet_chain_member";
          __int16 v40 = 2082;
          char v41 = v28;
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v28);
        goto LABEL_47;
      }
      if (!v29)
      {
LABEL_47:
        if (v24) {
          free(v24);
        }
        goto LABEL_49;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "__nw_frame_is_packet_chain_member";
      BOOL v27 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v25 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (!os_log_type_enabled(v25, type)) {
        goto LABEL_47;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v39 = "__nw_frame_is_packet_chain_member";
      BOOL v27 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0xCu);
    goto LABEL_47;
  }
  int v5 = *(unsigned __int16 *)(a2 + 204);
  unsigned int v6 = v5 | (*(unsigned __int8 *)(a2 + 206) << 16);
  if ((v5 & 0x40) == 0)
  {
LABEL_12:
    int v15 = (v6 >> 7) & 1;
LABEL_13:
    *(unsigned char *)(v4 + 24) = v15;
    *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = nw_protocol_ipv4_process_input_frame(a1[9], a2, a1[8], a1[10], (_DWORD *)(*(void *)(a1[6] + 8) + 24), (_DWORD *)(*(void *)(a1[7] + 8) + 24));
    if (*(unsigned char *)(*(void *)(a1[5] + 8) + 24)) {
      return 1;
    }
    --*(_DWORD *)(*(void *)(a1[6] + 8) + 24);
    goto LABEL_15;
  }
  if (*(unsigned char *)(*(void *)(a1[5] + 8) + 24)) {
    return 1;
  }
  uint64_t v7 = *(void *)(a1[6] + 8);
  int v8 = *(_DWORD *)(v7 + 24);
  *(_DWORD *)(v7 + 24) = v8 - 1;
  if (!v8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
    *(_DWORD *)buf = 136446978;
    uint64_t v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
    __int16 v40 = 2082;
    char v41 = "count";
    __int16 v42 = 2048;
    uint64_t v43 = 1;
    __int16 v44 = 2048;
    uint64_t v45 = v9;
    unsigned int v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (__nwlog_fault(v10, &type, &v36))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v13 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          uint64_t v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          __int16 v40 = 2082;
          char v41 = "count";
          __int16 v42 = 2048;
          uint64_t v43 = 1;
          __int16 v44 = 2048;
          uint64_t v45 = v13;
          int v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu";
LABEL_29:
          _os_log_impl(&dword_1830D4000, v11, v12, v14, buf, 0x2Au);
        }
      }
      else if (v36)
      {
        int v19 = (char *)__nw_create_backtrace_string();
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v20 = os_log_type_enabled(v11, type);
        if (v19)
        {
          if (v20)
          {
            uint64_t v21 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
            *(_DWORD *)buf = 136447234;
            uint64_t v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
            __int16 v40 = 2082;
            char v41 = "count";
            __int16 v42 = 2048;
            uint64_t v43 = 1;
            __int16 v44 = 2048;
            uint64_t v45 = v21;
            __int16 v46 = 2082;
            uint64_t v47 = v19;
            _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Underflow: %{public}s, decrement %llu, result %llu, dumping backtrace:%{public}s", buf, 0x34u);
          }
          free(v19);
          goto LABEL_30;
        }
        if (v20)
        {
          uint64_t v23 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          uint64_t v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          __int16 v40 = 2082;
          char v41 = "count";
          __int16 v42 = 2048;
          uint64_t v43 = 1;
          __int16 v44 = 2048;
          uint64_t v45 = v23;
          int v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, no backtrace";
          goto LABEL_29;
        }
      }
      else
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          uint64_t v22 = *(unsigned int *)(*(void *)(a1[6] + 8) + 24);
          *(_DWORD *)buf = 136446978;
          uint64_t v39 = "nw_protocol_ipv4_get_input_frames_block_invoke";
          __int16 v40 = 2082;
          char v41 = "count";
          __int16 v42 = 2048;
          uint64_t v43 = 1;
          __int16 v44 = 2048;
          uint64_t v45 = v22;
          int v14 = "%{public}s Underflow: %{public}s, decrement %llu, result %llu, backtrace limit exceeded";
          goto LABEL_29;
        }
      }
    }
LABEL_30:
    if (v10) {
      free(v10);
    }
    *(_DWORD *)(*(void *)(a1[6] + 8) + 24) = 0;
  }
LABEL_15:
  uint64_t v16 = *(void *)(a2 + 32);
  unsigned int v17 = *(void **)(a2 + 40);
  if (v16)
  {
    *(void *)(v16 + 40) = v17;
    unsigned int v17 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(a1[8] + 8) = v17;
  }
  void *v17 = v16;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  nw_frame_finalize(a2);
  return 1;
}

uint64_t ___ZL44nw_endpoint_resolver_array_contains_endpointPU22objcproto11OS_nw_array8NSObjectPU25objcproto14OS_nw_endpointS__block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  return nw_endpoint_is_equal(*(void **)(a1 + 32), a3, 1) ^ 1;
}

uint64_t ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  object = (void *)nw_hash_node_get_object(a2);
  if (object)
  {
    uint64_t v4 = object;
    uint64_t v5 = *(void *)(a1 + 32);
    unsigned int v6 = (void *)object[5];
    if (v6 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = object[11];
      if (v8) {
        object[11] = v8 + 1;
      }
      char v7 = -1;
    }
    else
    {
      char v7 = 0;
    }
    *(void *)uint64_t v48 = object;
    char v49 = v7;
    if (v5)
    {
      uint64_t v9 = *(void **)(v5 + 40);
      if (v9 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v11 = *(void *)(v5 + 88);
        if (v11) {
          *(void *)(v5 + 88) = v11 + 1;
        }
        char v10 = -1;
      }
      else
      {
        char v10 = 0;
      }
      *(void *)uint64_t v45 = v5;
      char v46 = v10;
      uint64_t v12 = object[3];
      if (v12)
      {
        uint64_t v13 = *(void (**)(void *))(v12 + 40);
        if (v13)
        {
          v13(object);
LABEL_16:
          if (v9 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v45);
          }
LABEL_18:
          if (v6 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v48);
          }
          return 1;
        }
      }
      int v15 = __nwlog_obj();
      uint64_t v16 = (const char *)v4[2];
      *(_DWORD *)buf = 136446722;
      unint64_t v51 = "__nw_protocol_connected";
      if (!v16) {
        uint64_t v16 = "invalid";
      }
      __int16 v52 = 2082;
      int v53 = (void *)v16;
      __int16 v54 = 2048;
      uint64_t v55 = v4;
      unsigned int v17 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v44 = 0;
      if (__nwlog_fault(v17, &type, &v44))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          int v18 = __nwlog_obj();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v18, type))
          {
            BOOL v20 = (const char *)v4[2];
            if (!v20) {
              BOOL v20 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            unint64_t v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            int v53 = (void *)v20;
            __int16 v54 = 2048;
            uint64_t v55 = v4;
            _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s protocol %{public}s (%p) has invalid connected callback", buf, 0x20u);
          }
        }
        else if (v44)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          int v18 = __nwlog_obj();
          os_log_type_t v30 = type;
          BOOL v31 = os_log_type_enabled(v18, type);
          if (backtrace_string)
          {
            if (v31)
            {
              os_log_type_t v32 = (const char *)v4[2];
              if (!v32) {
                os_log_type_t v32 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              unint64_t v51 = "__nw_protocol_connected";
              __int16 v52 = 2082;
              int v53 = (void *)v32;
              __int16 v54 = 2048;
              uint64_t v55 = v4;
              __int16 v56 = 2082;
              os_log_type_t v57 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v18, v30, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(backtrace_string);
            goto LABEL_67;
          }
          if (v31)
          {
            char v41 = (const char *)v4[2];
            if (!v41) {
              char v41 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            unint64_t v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            int v53 = (void *)v41;
            __int16 v54 = 2048;
            uint64_t v55 = v4;
            _os_log_impl(&dword_1830D4000, v18, v30, "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          int v18 = __nwlog_obj();
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v18, type))
          {
            __int16 v40 = (const char *)v4[2];
            if (!v40) {
              __int16 v40 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            unint64_t v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            int v53 = (void *)v40;
            __int16 v54 = 2048;
            uint64_t v55 = v4;
            _os_log_impl(&dword_1830D4000, v18, v39, "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
LABEL_67:
      if (v17) {
        free(v17);
      }
      goto LABEL_16;
    }
    uint64_t v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unint64_t v51 = "__nw_protocol_connected";
    os_log_type_t v26 = (char *)_os_log_send_and_compose_impl();

    v45[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v26, v45, &type))
    {
      if (v45[0] == OS_LOG_TYPE_FAULT)
      {
        BOOL v27 = __nwlog_obj();
        os_log_type_t v28 = v45[0];
        if (os_log_type_enabled(v27, v45[0]))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "__nw_protocol_connected";
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }
      else if (type)
      {
        char v36 = (char *)__nw_create_backtrace_string();
        BOOL v27 = __nwlog_obj();
        os_log_type_t v37 = v45[0];
        BOOL v38 = os_log_type_enabled(v27, v45[0]);
        if (v36)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            unint64_t v51 = "__nw_protocol_connected";
            __int16 v52 = 2082;
            int v53 = v36;
            _os_log_impl(&dword_1830D4000, v27, v37, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v36);
          goto LABEL_83;
        }
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "__nw_protocol_connected";
          _os_log_impl(&dword_1830D4000, v27, v37, "%{public}s called with null other_protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v27 = __nwlog_obj();
        os_log_type_t v43 = v45[0];
        if (os_log_type_enabled(v27, v45[0]))
        {
          *(_DWORD *)buf = 136446210;
          unint64_t v51 = "__nw_protocol_connected";
          _os_log_impl(&dword_1830D4000, v27, v43, "%{public}s called with null other_protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_83:
    if (v26) {
      free(v26);
    }
    goto LABEL_18;
  }
  uint64_t v21 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v51 = "__nw_protocol_connected";
  uint64_t v22 = (char *)_os_log_send_and_compose_impl();

  v48[0] = OS_LOG_TYPE_ERROR;
  v45[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v22, v48, v45))
  {
    if (v48[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v24 = v48[0];
      if (os_log_type_enabled(v23, v48[0]))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v51 = "__nw_protocol_connected";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v45[0])
    {
      BOOL v33 = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v34 = v48[0];
      BOOL v35 = os_log_type_enabled(v23, v48[0]);
      if (v33)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v51 = "__nw_protocol_connected";
          __int16 v52 = 2082;
          int v53 = v33;
          _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v33);
        goto LABEL_78;
      }
      if (v35)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v51 = "__nw_protocol_connected";
        _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v42 = v48[0];
      if (os_log_type_enabled(v23, v48[0]))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v51 = "__nw_protocol_connected";
        _os_log_impl(&dword_1830D4000, v23, v42, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_78:
  if (v22) {
    free(v22);
  }
  return 1;
}

void sub_18312EEA8(_Unwind_Exception *exception_object)
{
}

uint64_t ___ZL34nw_channel_notify_output_availableP10nw_channel_block_invoke(uint64_t a1, uint64_t a2)
{
  object = (void *)nw_hash_node_get_object(a2);
  uint64_t v4 = *(void *)(a1 + 32);
  if (object)
  {
    uint64_t v5 = object;
    uint64_t v6 = object[3];
    if (v6)
    {
      char v7 = *(void (**)(void *, uint64_t))(v6 + 72);
      if (v7)
      {
        uint64_t v8 = (void *)object[5];
        if (v8 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v9 = object[11];
          if (v9) {
            object[11] = v9 + 1;
          }
        }
        if (*(_UNKNOWN **)(v4 + 64) == &nw_protocol_ref_counted_handle)
        {
          uint64_t v10 = *(void *)(v4 + 112);
          if (v10) {
            *(void *)(v4 + 112) = v10 + 1;
          }
          v7(object, v4 + 24);
          if (*(_UNKNOWN **)(v4 + 64) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v14 = *(void *)(v4 + 112);
            if (v14)
            {
              uint64_t v15 = v14 - 1;
              *(void *)(v4 + 112) = v15;
              if (!v15)
              {
                uint64_t v16 = *(void (***)(void))(v4 + 88);
                if (v16)
                {
                  *(void *)(v4 + 88) = 0;
                  v16[2](v16);
                  _Block_release(v16);
                }
                if (*(unsigned char *)(v4 + 96))
                {
                  unsigned int v17 = *(const void **)(v4 + 88);
                  if (v17) {
                    _Block_release(v17);
                  }
                }
                free((void *)(v4 + 24));
              }
            }
          }
        }
        else
        {
          v7(object, v4 + 24);
        }
        if (v8 == &nw_protocol_ref_counted_handle && (_UNKNOWN *)v5[5] == &nw_protocol_ref_counted_handle)
        {
          uint64_t v18 = v5[11];
          if (v18)
          {
            uint64_t v19 = v18 - 1;
            v5[11] = v19;
            if (!v19)
            {
              BOOL v20 = (void (**)(void))v5[8];
              if (v20)
              {
                v5[8] = 0;
                v20[2](v20);
                _Block_release(v20);
              }
              if (v5[9])
              {
                uint64_t v21 = (const void *)v5[8];
                if (v21) {
                  _Block_release(v21);
                }
              }
              free(v5);
            }
          }
        }
        uint64_t v4 = *(void *)(a1 + 32);
      }
    }
  }
  if (!*(void *)(v4 + 176)) {
    return 0;
  }
  uint64_t result = *(void *)(v4 + 216);
  if (result)
  {
    unsigned int v12 = os_channel_available_slot_count();
    int v13 = *(_DWORD *)(*(void *)(a1 + 32) + 420);
    if (v13 - 1 >= v12) {
      int v13 = 0;
    }
    return v12 != v13;
  }
  return result;
}

uint64_t __nw_context_endpoint_get_active_instance_count_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v3 = (id)nw_hash_node_get_object(a2);
  uint64_t v4 = v3;
  if (!v3)
  {
    char v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_endpoint_get_active_instance_count";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_endpoint_get_active_instance_count";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v19 = "nw_endpoint_get_active_instance_count";
            __int16 v20 = 2082;
            uint64_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_endpoint_get_active_instance_count";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v19 = "nw_endpoint_get_active_instance_count";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v8) {
      free(v8);
    }
    goto LABEL_22;
  }
  uint64_t v5 = (void *)*((void *)v3 + 26);
  if (!v5)
  {
LABEL_22:
    instance_size_t count = 0;
    goto LABEL_23;
  }
  instance_size_t count = nw_protocol_instance_registrar_get_instance_count(v5);
LABEL_23:

  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += instance_count;
  return 1;
}

void sub_18312F41C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_endpoint_get_connected_flow_count_block_invoke(uint64_t a1, uint64_t a2)
{
  id v3 = (id)nw_hash_node_get_object(a2);
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += nw_association_get_connected_flow_count(v3);

  return 1;
}

void sub_18312F484(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_are_equivalent_for_path_evaluation(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (v3)
  {
    if (v4)
    {
      id v6 = nw_parameters_copy_path_parameters(v3, 0);
      id v7 = nw_parameters_copy_path_parameters(v5, 0);
      BOOL v8 = nw_path_parameters_are_equal(v6, v7, 1u);

      goto LABEL_4;
    }
    os_log_type_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null right", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null right, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null right, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null right, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null left", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null left, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null left, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v26 = "nw_parameters_are_equivalent_for_path_evaluation";
        __int16 v27 = 2082;
        os_log_type_t v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null left, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v11) {
    free(v11);
  }
  BOOL v8 = 0;
LABEL_4:

  return v8;
}

void sub_18312F978(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  object = (char *)nw_hash_node_get_object(a2);
  v26[0] = MEMORY[0x1E4F143A8];
  v26[1] = 3221225472;
  v26[2] = ___ZL36nw_context_purge_endpoint_hash_tableP21NWConcrete_nw_contextP13nw_hash_tablePKc_block_invoke_2;
  v26[3] = &unk_1E523CB38;
  os_log_type_t v28 = object;
  id v27 = *(id *)(a1 + 32);
  nw_hash_table_apply(object, (uint64_t)v26);
  if (nw_hash_table_count((uint64_t)object) || nw_hash_table_remove_node(*(void *)(a1 + 40), a2)) {
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  uint64_t v6 = *(void *)(a1 + 32);
  uint64_t v7 = *(void *)(a1 + 48);
  *(_DWORD *)buf = 136446978;
  os_log_type_t v30 = "nw_context_purge_endpoint_hash_table_block_invoke";
  __int16 v31 = 2114;
  uint64_t v32 = v6;
  __int16 v33 = 2080;
  uint64_t v34 = v7;
  __int16 v35 = 2048;
  uint64_t v36 = a2;
  BOOL v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v8, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        uint64_t v11 = *(void *)(a1 + 32);
        uint64_t v12 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v30 = "nw_context_purge_endpoint_hash_table_block_invoke";
        __int16 v31 = 2114;
        uint64_t v32 = v11;
        __int16 v33 = 2080;
        uint64_t v34 = v12;
        __int16 v35 = 2048;
        uint64_t v36 = a2;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s %{public}@ failed to remove %s hash table for node %p", buf, 0x2Au);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (id)gLogObj;
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v16)
        {
          uint64_t v17 = *(void *)(a1 + 32);
          uint64_t v18 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136447234;
          os_log_type_t v30 = "nw_context_purge_endpoint_hash_table_block_invoke";
          __int16 v31 = 2114;
          uint64_t v32 = v17;
          __int16 v33 = 2080;
          uint64_t v34 = v18;
          __int16 v35 = 2048;
          uint64_t v36 = a2;
          __int16 v37 = 2082;
          BOOL v38 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v15, "%{public}s %{public}@ failed to remove %s hash table for node %p, dumping backtrace:%{public}s", buf, 0x34u);
        }

        free(backtrace_string);
        if (v8) {
          goto LABEL_9;
        }
        goto LABEL_10;
      }
      if (v16)
      {
        uint64_t v22 = *(void *)(a1 + 32);
        uint64_t v23 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v30 = "nw_context_purge_endpoint_hash_table_block_invoke";
        __int16 v31 = 2114;
        uint64_t v32 = v22;
        __int16 v33 = 2080;
        uint64_t v34 = v23;
        __int16 v35 = 2048;
        uint64_t v36 = a2;
        _os_log_impl(&dword_1830D4000, v9, v15, "%{public}s %{public}@ failed to remove %s hash table for node %p, no backtrace", buf, 0x2Au);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        uint64_t v20 = *(void *)(a1 + 32);
        uint64_t v21 = *(void *)(a1 + 48);
        *(_DWORD *)buf = 136446978;
        os_log_type_t v30 = "nw_context_purge_endpoint_hash_table_block_invoke";
        __int16 v31 = 2114;
        uint64_t v32 = v20;
        __int16 v33 = 2080;
        uint64_t v34 = v21;
        __int16 v35 = 2048;
        uint64_t v36 = a2;
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s %{public}@ failed to remove %s hash table for node %p, backtrace limit exceeded", buf, 0x2Au);
      }
    }
  }
  if (v8) {
LABEL_9:
  }
    free(v8);
LABEL_10:

  return 1;
}

void *nw_context_endpoint_table_get_key(os_unfair_lock_s *a1, unsigned int *a2)
{
  some_BOOL node = nw_hash_table_get_some_node(a1);
  id v3 = nw_hash_node_get_object(some_node);

  return v3;
}

BOOL nw_endpoint_association_matches_key(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = nw_association_copy_path_parameters(a1);
  BOOL v5 = nw_path_parameters_are_equal(v4, v3, 1u);

  return v5;
}

void sub_18312FEA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_association_copy_path_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[2];
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_association_copy_path_parameters";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_association_copy_path_parameters";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_association_copy_path_parameters";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_association_copy_path_parameters";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_association_copy_path_parameters";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_context_endpoint_table_matches_key(os_unfair_lock_s *a1, void *a2)
{
  id v3 = a2;
  some_BOOL node = nw_hash_table_get_some_node(a1);
  BOOL v5 = nw_hash_node_get_object(some_node);
  uint64_t is_equal = nw_endpoint_is_equal(v3, v5, 0);

  return is_equal;
}

void sub_1831301C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_hash_table_get_some_node(os_unfair_lock_s *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v25 = "nw_hash_table_get_some_node";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v8, &type, &v22)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v25 = "nw_hash_table_get_some_node";
      BOOL v11 = "%{public}s called with null table";
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v19 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v25 = "nw_hash_table_get_some_node";
          __int16 v26 = 2082;
          id v27 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_45;
      }
      if (!v19)
      {
LABEL_45:
        if (v8) {
          free(v8);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v25 = "nw_hash_table_get_some_node";
      BOOL v11 = "%{public}s called with null table, no backtrace";
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_45;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v25 = "nw_hash_table_get_some_node";
      BOOL v11 = "%{public}s called with null table, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
    goto LABEL_45;
  }
  if (a1[8]._os_unfair_lock_opaque)
  {
    uint32_t os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 2) == 0) {
      goto LABEL_5;
    }
    goto LABEL_4;
  }
  os_log_type_t v12 = __nwlog_obj();
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v25 = "nw_hash_table_lock";
  char v13 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v13);
  if (!result)
  {
    free(v13);
    uint32_t os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 2) == 0)
    {
LABEL_5:
      if (os_unfair_lock_opaque)
      {
        uint32_t v3 = a1[8]._os_unfair_lock_opaque;
        if (v3)
        {
          int v4 = 0;
          BOOL v5 = a1 + 14;
          do
          {
            uint64_t v6 = v5;
            while (1)
            {
              uint64_t v6 = *(os_unfair_lock_s **)&v6->_os_unfair_lock_opaque;
              if (!v6) {
                break;
              }
              if (BYTE2(v6[7]._os_unfair_lock_opaque) == 1) {
                goto LABEL_14;
              }
            }
            ++v4;
            v5 += 4;
          }
          while (v4 != v3);
        }
        uint64_t v6 = 0;
LABEL_14:
        if ((os_unfair_lock_opaque & 2) != 0) {
          os_unfair_lock_unlock(a1 + 13);
        }
        return (BOOL)v6;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v25 = "nw_hash_table_get_some_node";
      os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v22 = 0;
      if (__nwlog_fault(v14, &type, &v22))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v15 = __nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_50;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v25 = "nw_hash_table_get_some_node";
          __int16 v17 = "%{public}s called with invalid hash table";
LABEL_49:
          _os_log_impl(&dword_1830D4000, v15, v16, v17, buf, 0xCu);
          goto LABEL_50;
        }
        if (!v22)
        {
          os_log_type_t v15 = __nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_50;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v25 = "nw_hash_table_get_some_node";
          __int16 v17 = "%{public}s called with invalid hash table, backtrace limit exceeded";
          goto LABEL_49;
        }
        uint64_t v20 = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v21 = os_log_type_enabled(v15, type);
        if (!v20)
        {
          if (!v21) {
            goto LABEL_50;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v25 = "nw_hash_table_get_some_node";
          __int16 v17 = "%{public}s called with invalid hash table, no backtrace";
          goto LABEL_49;
        }
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v25 = "nw_hash_table_get_some_node";
          __int16 v26 = 2082;
          id v27 = v20;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v20);
      }
LABEL_50:
      if (v14) {
        free(v14);
      }
      if ((a1[12]._os_unfair_lock_opaque & 2) != 0)
      {
        os_unfair_lock_unlock(a1 + 13);
        return 0;
      }
      return 0;
    }
LABEL_4:
    os_unfair_lock_lock(a1 + 13);
    uint32_t os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    goto LABEL_5;
  }
  __break(1u);
  return result;
}

uint64_t ___ZL49nw_protocol_instance_flush_batched_input_internalP31NWConcrete_nw_protocol_instance_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  uint64_t extra = nw_hash_node_get_extra(a2);
  object = (void *)nw_hash_node_get_object(a2);
  __int16 v6 = *(_WORD *)(extra + 52);
  if ((v6 & 0x10) == 0) {
    return 1;
  }
  uint64_t v7 = object;
  if (*(void *)(extra + 16))
  {
    uint64_t v8 = *(void *)(a1 + 32);
    if (v8) {
      uint64_t v9 = v8 - 96;
    }
    else {
      uint64_t v9 = 0;
    }
    if (object)
    {
      os_log_type_t v10 = (void *)object[5];
      if (v10 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v12 = object[11];
        if (v12) {
          object[11] = v12 + 1;
        }
        char v11 = -1;
      }
      else
      {
        char v11 = 0;
      }
      *(void *)BOOL v91 = object;
      char v92 = v11;
      if (v8)
      {
        char v13 = *(void **)(v9 + 40);
        if (v13 == &nw_protocol_ref_counted_handle)
        {
          uint64_t v15 = *(void *)(v9 + 88);
          if (v15) {
            *(void *)(v9 + 88) = v15 + 1;
          }
          char v14 = -1;
        }
        else
        {
          char v14 = 0;
        }
        *(void *)uint64_t v88 = v9;
        char v89 = v14;
        uint64_t v16 = object[3];
        if (v16)
        {
          __int16 v17 = *(void (**)(void *))(v16 + 64);
          if (v17)
          {
            v17(object);
LABEL_21:
            if (v13 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)v88);
            }
LABEL_23:
            if (v10 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)v91);
            }
LABEL_25:
            __int16 v6 = *(_WORD *)(extra + 52);
            goto LABEL_26;
          }
        }
        uint64_t v29 = __nwlog_obj();
        os_log_type_t v30 = (const char *)v7[2];
        *(_DWORD *)buf = 136446722;
        uint64_t v94 = "__nw_protocol_input_available";
        if (!v30) {
          os_log_type_t v30 = "invalid";
        }
        __int16 v95 = 2082;
        size_t v96 = (void *)v30;
        __int16 v97 = 2048;
        uint32_t v98 = v7;
        __int16 v31 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v87 = 0;
        if (__nwlog_fault(v31, &type, &v87))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v32 = __nwlog_obj();
            os_log_type_t v33 = type;
            if (os_log_type_enabled(v32, type))
            {
              uint64_t v34 = (const char *)v7[2];
              if (!v34) {
                uint64_t v34 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              uint64_t v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              size_t v96 = (void *)v34;
              __int16 v97 = 2048;
              uint32_t v98 = v7;
              _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s protocol %{public}s (%p) has invalid input_available callback", buf, 0x20u);
            }
          }
          else if (v87)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            uint64_t v32 = __nwlog_obj();
            os_log_type_t v50 = type;
            BOOL v51 = os_log_type_enabled(v32, type);
            if (backtrace_string)
            {
              if (v51)
              {
                __int16 v52 = (const char *)v7[2];
                if (!v52) {
                  __int16 v52 = "invalid";
                }
                *(_DWORD *)buf = 136446978;
                uint64_t v94 = "__nw_protocol_input_available";
                __int16 v95 = 2082;
                size_t v96 = (void *)v52;
                __int16 v97 = 2048;
                uint32_t v98 = v7;
                __int16 v99 = 2082;
                BOOL v100 = backtrace_string;
                _os_log_impl(&dword_1830D4000, v32, v50, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
              }

              free(backtrace_string);
              goto LABEL_137;
            }
            if (v51)
            {
              BOOL v81 = (const char *)v7[2];
              if (!v81) {
                BOOL v81 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              uint64_t v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              size_t v96 = (void *)v81;
              __int16 v97 = 2048;
              uint32_t v98 = v7;
              _os_log_impl(&dword_1830D4000, v32, v50, "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace", buf, 0x20u);
            }
          }
          else
          {
            uint64_t v32 = __nwlog_obj();
            os_log_type_t v77 = type;
            if (os_log_type_enabled(v32, type))
            {
              uint64_t v78 = (const char *)v7[2];
              if (!v78) {
                uint64_t v78 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              uint64_t v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              size_t v96 = (void *)v78;
              __int16 v97 = 2048;
              uint32_t v98 = v7;
              _os_log_impl(&dword_1830D4000, v32, v77, "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded", buf, 0x20u);
            }
          }
        }
LABEL_137:
        if (v31) {
          free(v31);
        }
        goto LABEL_21;
      }
      uint64_t v45 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v94 = "__nw_protocol_input_available";
      char v46 = (char *)_os_log_send_and_compose_impl();

      v88[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v46, v88, &type))
      {
        if (v88[0] == OS_LOG_TYPE_FAULT)
        {
          uint64_t v47 = __nwlog_obj();
          os_log_type_t v48 = v88[0];
          if (os_log_type_enabled(v47, v88[0]))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v94 = "__nw_protocol_input_available";
            _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null other_protocol", buf, 0xCu);
          }
        }
        else if (type)
        {
          os_log_type_t v68 = (char *)__nw_create_backtrace_string();
          uint64_t v47 = __nwlog_obj();
          os_log_type_t v69 = v88[0];
          BOOL v70 = os_log_type_enabled(v47, v88[0]);
          if (v68)
          {
            if (v70)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v94 = "__nw_protocol_input_available";
              __int16 v95 = 2082;
              size_t v96 = v68;
              _os_log_impl(&dword_1830D4000, v47, v69, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v68);
            goto LABEL_166;
          }
          if (v70)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v94 = "__nw_protocol_input_available";
            _os_log_impl(&dword_1830D4000, v47, v69, "%{public}s called with null other_protocol, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v47 = __nwlog_obj();
          os_log_type_t v83 = v88[0];
          if (os_log_type_enabled(v47, v88[0]))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v94 = "__nw_protocol_input_available";
            _os_log_impl(&dword_1830D4000, v47, v83, "%{public}s called with null other_protocol, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_166:
      if (v46) {
        free(v46);
      }
      goto LABEL_23;
    }
    char v41 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v94 = "__nw_protocol_input_available";
    os_log_type_t v42 = (char *)_os_log_send_and_compose_impl();

    v91[0] = OS_LOG_TYPE_ERROR;
    v88[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v42, v91, v88))
    {
      if (v91[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v43 = __nwlog_obj();
        os_log_type_t v44 = v91[0];
        if (os_log_type_enabled(v43, v91[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v94 = "__nw_protocol_input_available";
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if (v88[0])
      {
        os_log_type_t v65 = (char *)__nw_create_backtrace_string();
        os_log_type_t v43 = __nwlog_obj();
        os_log_type_t v66 = v91[0];
        BOOL v67 = os_log_type_enabled(v43, v91[0]);
        if (v65)
        {
          if (v67)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v94 = "__nw_protocol_input_available";
            __int16 v95 = 2082;
            size_t v96 = v65;
            _os_log_impl(&dword_1830D4000, v43, v66, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v65);
          goto LABEL_161;
        }
        if (v67)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v94 = "__nw_protocol_input_available";
          _os_log_impl(&dword_1830D4000, v43, v66, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v43 = __nwlog_obj();
        os_log_type_t v82 = v91[0];
        if (os_log_type_enabled(v43, v91[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v94 = "__nw_protocol_input_available";
          _os_log_impl(&dword_1830D4000, v43, v82, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_161:
    if (v42) {
      free(v42);
    }
    goto LABEL_25;
  }
LABEL_26:
  if ((v6 & 0x40) == 0) {
    return 1;
  }
  *(_WORD *)(extra + 52) = v6 & 0xFFBF;
  uint64_t v18 = *(void *)(a1 + 32);
  if (v18) {
    uint64_t v19 = v18 - 96;
  }
  else {
    uint64_t v19 = 0;
  }
  if (v7)
  {
    uint64_t v20 = (void *)v7[5];
    if (v20 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v22 = v7[11];
      if (v22) {
        v7[11] = v22 + 1;
      }
      char v21 = -1;
    }
    else
    {
      char v21 = 0;
    }
    *(void *)BOOL v91 = v7;
    char v92 = v21;
    if (v18)
    {
      uint64_t v23 = *(void **)(v19 + 40);
      if (v23 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v25 = *(void *)(v19 + 88);
        if (v25) {
          *(void *)(v19 + 88) = v25 + 1;
        }
        char v24 = -1;
      }
      else
      {
        char v24 = 0;
      }
      *(void *)uint64_t v88 = v19;
      char v89 = v24;
      uint64_t v26 = v7[3];
      if (v26)
      {
        id v27 = *(void (**)(void *))(v26 + 184);
        if (v27)
        {
          v27(v7);
LABEL_45:
          if (v23 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v88);
          }
LABEL_47:
          if (v20 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v91);
          }
          return 1;
        }
      }
      __int16 v35 = __nwlog_obj();
      uint64_t v36 = (const char *)v7[2];
      *(_DWORD *)buf = 136446722;
      uint64_t v94 = "__nw_protocol_input_finished";
      if (!v36) {
        uint64_t v36 = "invalid";
      }
      __int16 v95 = 2082;
      size_t v96 = (void *)v36;
      __int16 v97 = 2048;
      uint32_t v98 = v7;
      __int16 v37 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v87 = 0;
      if (__nwlog_fault(v37, &type, &v87))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v38 = __nwlog_obj();
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            __int16 v40 = (const char *)v7[2];
            if (!v40) {
              __int16 v40 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v94 = "__nw_protocol_input_finished";
            __int16 v95 = 2082;
            size_t v96 = (void *)v40;
            __int16 v97 = 2048;
            uint32_t v98 = v7;
            _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s protocol %{public}s (%p) has invalid input_finished callback", buf, 0x20u);
          }
        }
        else if (v87)
        {
          BOOL v61 = (char *)__nw_create_backtrace_string();
          BOOL v38 = __nwlog_obj();
          os_log_type_t v62 = type;
          BOOL v63 = os_log_type_enabled(v38, type);
          if (v61)
          {
            if (v63)
            {
              int v64 = (const char *)v7[2];
              if (!v64) {
                int v64 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              uint64_t v94 = "__nw_protocol_input_finished";
              __int16 v95 = 2082;
              size_t v96 = (void *)v64;
              __int16 v97 = 2048;
              uint32_t v98 = v7;
              __int16 v99 = 2082;
              BOOL v100 = v61;
              _os_log_impl(&dword_1830D4000, v38, v62, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v61);
            goto LABEL_150;
          }
          if (v63)
          {
            uint64_t v84 = (const char *)v7[2];
            if (!v84) {
              uint64_t v84 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v94 = "__nw_protocol_input_finished";
            __int16 v95 = 2082;
            size_t v96 = (void *)v84;
            __int16 v97 = 2048;
            uint32_t v98 = v7;
            _os_log_impl(&dword_1830D4000, v38, v62, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          BOOL v38 = __nwlog_obj();
          os_log_type_t v79 = type;
          if (os_log_type_enabled(v38, type))
          {
            unsigned int v80 = (const char *)v7[2];
            if (!v80) {
              unsigned int v80 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            uint64_t v94 = "__nw_protocol_input_finished";
            __int16 v95 = 2082;
            size_t v96 = (void *)v80;
            __int16 v97 = 2048;
            uint32_t v98 = v7;
            _os_log_impl(&dword_1830D4000, v38, v79, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
LABEL_150:
      if (v37) {
        free(v37);
      }
      goto LABEL_45;
    }
    os_log_type_t v57 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v94 = "__nw_protocol_input_finished";
    uint64_t v58 = (char *)_os_log_send_and_compose_impl();

    v88[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v58, v88, &type))
    {
      if (v88[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v59 = __nwlog_obj();
        os_log_type_t v60 = v88[0];
        if (os_log_type_enabled(v59, v88[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v94 = "__nw_protocol_input_finished";
          _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null other_protocol", buf, 0xCu);
        }
      }
      else if (type)
      {
        os_log_type_t v74 = (char *)__nw_create_backtrace_string();
        os_log_type_t v59 = __nwlog_obj();
        os_log_type_t v75 = v88[0];
        BOOL v76 = os_log_type_enabled(v59, v88[0]);
        if (v74)
        {
          if (v76)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v94 = "__nw_protocol_input_finished";
            __int16 v95 = 2082;
            size_t v96 = v74;
            _os_log_impl(&dword_1830D4000, v59, v75, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v74);
          goto LABEL_176;
        }
        if (v76)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v94 = "__nw_protocol_input_finished";
          _os_log_impl(&dword_1830D4000, v59, v75, "%{public}s called with null other_protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v59 = __nwlog_obj();
        os_log_type_t v86 = v88[0];
        if (os_log_type_enabled(v59, v88[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v94 = "__nw_protocol_input_finished";
          _os_log_impl(&dword_1830D4000, v59, v86, "%{public}s called with null other_protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_176:
    if (v58) {
      free(v58);
    }
    goto LABEL_47;
  }
  int v53 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v94 = "__nw_protocol_input_finished";
  __int16 v54 = (char *)_os_log_send_and_compose_impl();

  v91[0] = OS_LOG_TYPE_ERROR;
  v88[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v54, v91, v88))
  {
    if (v91[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v56 = v91[0];
      if (os_log_type_enabled(v55, v91[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v94 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v88[0])
    {
      size_t v71 = (char *)__nw_create_backtrace_string();
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v72 = v91[0];
      BOOL v73 = os_log_type_enabled(v55, v91[0]);
      if (v71)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v94 = "__nw_protocol_input_finished";
          __int16 v95 = 2082;
          size_t v96 = v71;
          _os_log_impl(&dword_1830D4000, v55, v72, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v71);
        goto LABEL_171;
      }
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v94 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_1830D4000, v55, v72, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v85 = v91[0];
      if (os_log_type_enabled(v55, v91[0]))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v94 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_1830D4000, v55, v85, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_171:
  if (v54) {
    free(v54);
  }
  return 1;
}

void sub_1831316C8(_Unwind_Exception *exception_object)
{
}

uint64_t nw_hash_node_get_object(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return *(void *)(a1 + 16);
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v11 = "nw_hash_node_get_object";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint32_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "nw_hash_node_get_object";
        BOOL v5 = "%{public}s called with null node";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint32_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          char v11 = "nw_hash_node_get_object";
          __int16 v12 = 2082;
          char v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "nw_hash_node_get_object";
        BOOL v5 = "%{public}s called with null node, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint32_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        char v11 = "nw_hash_node_get_object";
        BOOL v5 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

BOOL nw_path_parameters_are_equal(void *a1, void *a2, unsigned int a3)
{
  BOOL v5 = a1;
  __int16 v6 = a2;
  BOOL v7 = v6;
  BOOL v8 = v5 == v6;
  if (v5 != v6 && v5 && v6)
  {
    if (*((void *)v5 + 9) != *((void *)v6 + 9)
      || *((void *)v5 + 10) != *((void *)v6 + 10)
      || *((void *)v5 + 11) != *((void *)v6 + 11)
      || *(void *)(v5 + 94) != *(void *)(v6 + 94))
    {
      goto LABEL_14;
    }
    if (a3 != 3)
    {
      uint64_t v16 = *((void *)v6 + 1);
      uint64_t v17 = *((void *)v6 + 2);
      uint64_t v18 = *((void *)v6 + 3);
      uint64_t v19 = *((void *)v6 + 4);
      uint64_t v20 = *((void *)v6 + 5);
      BOOL v21 = *((void *)v5 + 1) == v16 && *((void *)v5 + 2) == v17;
      BOOL v22 = v21 && *((void *)v5 + 3) == v18;
      BOOL v23 = v22 && *((void *)v5 + 4) == v19;
      BOOL v24 = v23 && *((void *)v5 + 5) == v20;
      BOOL v25 = v24 && *((void *)v5 + 6) == v7[6];
      BOOL v26 = v25 && *((void *)v5 + 7) == v7[7];
      if (!v26 || *((void *)v5 + 8) != v7[8]) {
        goto LABEL_14;
      }
      if (a3 <= 1
        && (*(void *)(v5 + 102) != *(void *)((char *)v7 + 102)
         || v5[110] != (unint64_t)*((unsigned __int8 *)v7 + 110)))
      {
        goto LABEL_14;
      }
    }
    if (!nw_context_shares_workloop(*((void **)v5 + 17), (void *)v7[17])) {
      goto LABEL_14;
    }
    if (a3 - 5 < 0xFFFFFFFE
      || ((*((unsigned __int16 *)v5 + 54) | (v5[110] << 16)) & 0x20000) != 0
      || ((*((unsigned __int16 *)v7 + 54) | (*((unsigned __int8 *)v7 + 110) << 16)) & 0x20000) != 0)
    {
      char v13 = (void *)*((void *)v5 + 17);
      if (v13 != (void *)v7[17]
        && (nw_context_get_isolate_protocol_cache(v13) || nw_context_get_isolate_protocol_cache((void *)v7[17])))
      {
        goto LABEL_14;
      }
    }
    uint64_t v14 = (const char *)*((void *)v5 + 14);
    uint64_t v15 = (const char *)v7[14];
    if (v14 != v15 && v14 && v15)
    {
      if (strcmp(v14, v15)) {
        goto LABEL_14;
      }
    }
    else if (v14 != v15)
    {
      goto LABEL_14;
    }
    if (a3 <= 2)
    {
      uint64_t v29 = (const char *)*((void *)v5 + 15);
      os_log_type_t v30 = (const char *)v7[15];
      if (v29 != v30 && v29 && v30)
      {
        if (strcmp(v29, v30)) {
          goto LABEL_14;
        }
      }
      else if (v29 != v30)
      {
        goto LABEL_14;
      }
      __int16 v31 = (const char *)*((void *)v5 + 16);
      uint64_t v32 = (const char *)v7[16];
      if (v31 != v32 && v31 && v32)
      {
        if (strcmp(v31, v32)) {
          goto LABEL_14;
        }
      }
      else if (v31 != v32)
      {
        goto LABEL_14;
      }
    }
    if (nw_protocol_option_is_equal(*((void **)v5 + 18), (void *)v7[18])
      && nw_protocol_option_is_equal(*((void **)v5 + 19), (void *)v7[19]))
    {
      os_log_type_t v33 = (void *)*((void *)v5 + 20);
      if (a3)
      {
        if (!v33 || (uint64_t v34 = (void *)v7[20]) == 0 || (nw_endpoint_is_equal(v33, v34, 0) & 1) != 0)
        {
LABEL_81:
          if (nw_interface_shallow_compare(*((void **)v5 + 21), (void *)v7[21]))
          {
            __int16 v35 = (xpc_object_t *)*((void *)v5 + 22);
            uint64_t v36 = (xpc_object_t *)v7[22];
            if (v35)
            {
              if (v36
                && nw_unordered_xpc_array_is_equal(*v35, *v36)
                && nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 8), *(xpc_object_t *)(v7[22] + 8))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 16), *(xpc_object_t *)(v7[22] + 16))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 24), *(xpc_object_t *)(v7[22] + 24))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 32), *(xpc_object_t *)(v7[22] + 32))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 40), *(xpc_object_t *)(v7[22] + 40))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 48), *(xpc_object_t *)(v7[22] + 48))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 56),
                                   *(xpc_object_t *)(v7[22] + 56))
                && nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 64), *(xpc_object_t *)(v7[22] + 64))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 72), *(xpc_object_t *)(v7[22] + 72))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 80), *(xpc_object_t *)(v7[22] + 80))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 88), *(xpc_object_t *)(v7[22] + 88))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 96), *(xpc_object_t *)(v7[22] + 96))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 104), *(xpc_object_t *)(v7[22] + 104))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 112),
                                   *(xpc_object_t *)(v7[22] + 112))
                && nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 120), *(xpc_object_t *)(v7[22] + 120))&& nw_unordered_xpc_array_is_equal(*(xpc_object_t *)(*((void *)v5 + 22) + 136), *(xpc_object_t *)(v7[22] + 136))&& nw_protocol_option_is_equal(*(void **)(*((void *)v5 + 22) + 128), *(void **)(v7[22] + 128)))
              {
                goto LABEL_104;
              }
            }
            else if (!v36)
            {
LABEL_104:
              BOOL v8 = 1;
              goto LABEL_15;
            }
          }
        }
      }
      else if (nw_endpoint_is_equal(v33, (void *)v7[20], 0))
      {
        goto LABEL_81;
      }
    }
LABEL_14:
    BOOL v8 = 0;
  }
LABEL_15:

  return v8;
}

void sub_183131D74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_option_is_equal(void *a1, void *a2)
{
  uint32_t v3 = a1;
  os_log_type_t v4 = a2;
  BOOL v5 = v4;
  if (v3 == v4) {
    goto LABEL_17;
  }
  uint64_t v6 = 0;
  if (v3 && v4)
  {
    if (nw_endpoint_is_equal(v3[3], v4[3], 0)
      && *((unsigned __int8 *)v3 + 152) == *((unsigned __int8 *)v5 + 152)
      && nw_protocol_definition_is_equal_unsafe((uint64_t)v3[1], (uint64_t)v5[1]))
    {
      BOOL v7 = v5[5];
      id v8 = v3[5];
      id v9 = v7;
      os_log_type_t v10 = v9;
      BOOL v11 = v8 == v9;
      if (v8 != v9 && v8 && v9) {
        BOOL v11 = xpc_equal(v8, v9);
      }

      if (v11)
      {
        __int16 v12 = v3[1];
        char v13 = (uint64_t (*)(void))*((void *)v12 + 15);
        if (v13 || (char v13 = (uint64_t (*)(void))*((void *)v12 + 14)) != 0)
        {
          uint64_t v6 = v13();
          goto LABEL_18;
        }
LABEL_17:
        uint64_t v6 = 1;
        goto LABEL_18;
      }
    }
    uint64_t v6 = 0;
  }
LABEL_18:

  return v6;
}

void sub_183131EB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_is_equal(void *a1, void *a2, uint64_t a3)
{
  unint64_t v5 = a1;
  unint64_t v6 = a2;
  BOOL v7 = (void *)v6;
  if (v5 | v6)
  {
    uint64_t v8 = 0;
    if (v5 && v6)
    {
      int v9 = [(id)v5 type];
      if ((v9 - 1) < 4 || v9 == 6) {
        uint64_t v8 = [(id)v5 isEqualToEndpoint:v7 matchFlags:a3];
      }
      else {
        uint64_t v8 = 0;
      }
    }
  }
  else
  {
    uint64_t v8 = 1;
  }

  return v8;
}

void sub_183131F78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183132134(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1831321E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ip_option_is_equal(uint64_t a1, void *a2, void *a3)
{
  return *a2 == *a3 && a2[1] == a3[1];
}

BOOL nw_interface_shallow_compare(void *a1, void *a2)
{
  uint32_t v3 = a1;
  os_log_type_t v4 = a2;
  unint64_t v5 = (char *)v4;
  BOOL v6 = v3 == v4;
  if (v3 != v4 && v3 && v4)
  {
    int v7 = *((_DWORD *)v4 + 24);
    v6 = (!v7 || (int v8 = *((_DWORD *)v3 + 24)) == 0 || v8 == v7)
      && ((v9 = *((_DWORD *)v4 + 25)) == 0 || (int v10 = *((_DWORD *)v3 + 25)) == 0 || v10 == v9)
      && *((_DWORD *)v3 + 2) == *((_DWORD *)v4 + 2)
      && strncmp(v3 + 104, v4 + 104, 0x19uLL) == 0;
  }

  return v6;
}

BOOL nw_tcp_option_is_equal(uint64_t a1, void *a2, void *a3)
{
  if (!a2 || !a3) {
    return a2 == a3;
  }
  return *a2 == *a3 && a2[1] == a3[1] && a2[2] == a3[2] && a2[3] == a3[3] && a2[4] == a3[4];
}

uint64_t nw_association_get_connected_flow_count(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    BOOL v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_association_get_connected_flow_count";
    int v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_association_get_connected_flow_count";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v18 = "nw_association_get_connected_flow_count";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_association_get_connected_flow_count";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v18 = "nw_association_get_connected_flow_count";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v7) {
      free(v7);
    }
    goto LABEL_22;
  }
  id v3 = nw_path_parameters_copy_context(*((void **)v1 + 2));
  nw_context_assert_queue(v3);

  uint64_t v4 = v2[6];
  if (!v4)
  {
LABEL_22:
    uint64_t v5 = 0;
    goto LABEL_23;
  }
  uint64_t v5 = *(unsigned int *)(v4 + 40);
LABEL_23:

  return v5;
}

void sub_1831325C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_quic_connection_option_compare(uint64_t a1, uint64_t a2, uint64_t a3, int a4)
{
  if (a4 == 1) {
    return 1;
  }
  else {
    return nw_protocol_option_is_equal(*(void **)(a2 + 96), *(void **)(a3 + 96));
  }
}

void nw_synchronize(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_synchronize";
    uint64_t v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v4, &type, &v12)) {
      goto LABEL_34;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_synchronize";
      int v7 = "%{public}s called with null lock";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v15 = "nw_synchronize";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null lock, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_34:
        if (!v4) {
          return;
        }
        goto LABEL_35;
      }
      if (!v9) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_synchronize";
      int v7 = "%{public}s called with null lock, no backtrace";
    }
    else
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_34;
      }
      *(_DWORD *)buf = 136446210;
      char v15 = "nw_synchronize";
      int v7 = "%{public}s called with null lock, backtrace limit exceeded";
    }
LABEL_33:
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    goto LABEL_34;
  }
  if (a2)
  {
    os_unfair_lock_lock(a1);
    (*(void (**)(uint64_t))(a2 + 16))(a2);
    os_unfair_lock_unlock(a1);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_synchronize";
  uint64_t v4 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v4, &type, &v12)) {
    goto LABEL_34;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_synchronize";
    int v7 = "%{public}s called with null block";
    goto LABEL_33;
  }
  if (!v12)
  {
    uint64_t v5 = __nwlog_obj();
    os_log_type_t v6 = type;
    if (!os_log_type_enabled(v5, type)) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_synchronize";
    int v7 = "%{public}s called with null block, backtrace limit exceeded";
    goto LABEL_33;
  }
  int v10 = (char *)__nw_create_backtrace_string();
  uint64_t v5 = __nwlog_obj();
  os_log_type_t v6 = type;
  BOOL v11 = os_log_type_enabled(v5, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_34;
    }
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_synchronize";
    int v7 = "%{public}s called with null block, no backtrace";
    goto LABEL_33;
  }
  if (v11)
  {
    *(_DWORD *)buf = 136446466;
    char v15 = "nw_synchronize";
    __int16 v16 = 2082;
    uint64_t v17 = v10;
    _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v4) {
LABEL_35:
  }
    free(v4);
}

uint64_t in_finalize_cksum(uint64_t a1, unsigned int a2, __int16 a3)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "__nw_frame_unclaimed_length";
    char v12 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v12, type, &v26)) {
      goto LABEL_30;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (!os_log_type_enabled(v13, type[0])) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "__nw_frame_unclaimed_length";
      char v15 = "%{public}s called with null frame";
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      BOOL v17 = os_log_type_enabled(v13, type[0]);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v28 = "__nw_frame_unclaimed_length";
          __int16 v29 = 2082;
          os_log_type_t v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_30:
        if (v12) {
          free(v12);
        }
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        uint64_t v28 = "__nw_frame_unclaimed_bytes";
        uint64_t v18 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        char v26 = 0;
        if (!__nwlog_fault(v18, type, &v26)) {
          goto LABEL_46;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          __int16 v19 = __nwlog_obj();
          os_log_type_t v20 = type[0];
          if (!os_log_type_enabled(v19, type[0])) {
            goto LABEL_46;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "__nw_frame_unclaimed_bytes";
          uint64_t v21 = "%{public}s called with null frame";
        }
        else if (v26)
        {
          BOOL v22 = (char *)__nw_create_backtrace_string();
          __int16 v19 = __nwlog_obj();
          os_log_type_t v20 = type[0];
          BOOL v23 = os_log_type_enabled(v19, type[0]);
          if (v22)
          {
            if (v23)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v28 = "__nw_frame_unclaimed_bytes";
              __int16 v29 = 2082;
              os_log_type_t v30 = v22;
              _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v22);
            goto LABEL_46;
          }
          if (!v23)
          {
LABEL_46:
            if (v18) {
              free(v18);
            }
            goto LABEL_48;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "__nw_frame_unclaimed_bytes";
          uint64_t v21 = "%{public}s called with null frame, no backtrace";
        }
        else
        {
          __int16 v19 = __nwlog_obj();
          os_log_type_t v20 = type[0];
          if (!os_log_type_enabled(v19, type[0])) {
            goto LABEL_46;
          }
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "__nw_frame_unclaimed_bytes";
          uint64_t v21 = "%{public}s called with null frame, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
        goto LABEL_46;
      }
      if (!v17) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "__nw_frame_unclaimed_length";
      char v15 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      os_log_type_t v13 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      if (!os_log_type_enabled(v13, type[0])) {
        goto LABEL_30;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "__nw_frame_unclaimed_length";
      char v15 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0xCu);
    goto LABEL_30;
  }
  int v6 = *(_DWORD *)(a1 + 52);
  if (v6)
  {
    uint64_t v7 = (v6 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60)));
    uint64_t v8 = *(void *)(a1 + 112);
    if (!v8) {
      goto LABEL_48;
    }
  }
  else
  {
    uint64_t v7 = 0;
    uint64_t v8 = *(void *)(a1 + 112);
    if (!v8) {
      goto LABEL_48;
    }
  }
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0 && g_channel_check_validity)
  {
    if (!g_channel_check_validity(a1, *(void *)(a1 + 88))) {
      goto LABEL_48;
    }
    uint64_t v8 = *(void *)(a1 + 112);
  }
  uint64_t v9 = *(unsigned int *)(a1 + 56);
  *(_DWORD *)os_log_type_t type = 0;
  if (!v7 || !v8)
  {
LABEL_48:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v24 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v28 = "in_finalize_cksum";
      _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_INFO, "%{public}s frame is no longer valid", buf, 0xCu);
    }
    return 6;
  }
  int v10 = inet_cksum(a1, 0, v7, (int *)type);
  uint64_t result = *(unsigned int *)type;
  if (!*(_DWORD *)type)
  {
    if (!v10) {
      LOWORD(v10) = (__int16)(a3 << 15) >> 15;
    }
    *(_WORD *)(v8 + v9 + a2) = v10;
  }
  return result;
}

uint64_t inet_cksum(uint64_t a1, unsigned int a2, uint64_t a3, int *a4)
{
  *(void *)&v54[7] = *MEMORY[0x1E4F143B8];
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "m_sum16";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v13, &type, &v47)) {
      goto LABEL_60;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "m_sum16";
      __int16 v16 = "%{public}s called with null error";
    }
    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v30 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v50 = "m_sum16";
          __int16 v51 = 2082;
          *(void *)__int16 v52 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null error, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_60;
      }
      if (!v30)
      {
LABEL_60:
        if (v13) {
          free(v13);
        }
        return 1;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "m_sum16";
      __int16 v16 = "%{public}s called with null error, no backtrace";
    }
    else
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (!os_log_type_enabled(v14, type)) {
        goto LABEL_60;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "m_sum16";
      __int16 v16 = "%{public}s called with null error, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v14, v15, v16, buf, 0xCu);
    goto LABEL_60;
  }
  *a4 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "__nw_frame_unclaimed_length";
    BOOL v17 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v17, &type, &v47)) {
      goto LABEL_65;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "__nw_frame_unclaimed_length";
      os_log_type_t v20 = "%{public}s called with null frame";
    }
    else if (v47)
    {
      uint64_t v31 = (char *)__nw_create_backtrace_string();
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v32 = os_log_type_enabled(v18, type);
      if (v31)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v50 = "__nw_frame_unclaimed_length";
          __int16 v51 = 2082;
          *(void *)__int16 v52 = v31;
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v31);
        goto LABEL_65;
      }
      if (!v32)
      {
LABEL_65:
        if (v17) {
          free(v17);
        }
        goto LABEL_67;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "__nw_frame_unclaimed_length";
      os_log_type_t v20 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (!os_log_type_enabled(v18, type)) {
        goto LABEL_65;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "__nw_frame_unclaimed_length";
      os_log_type_t v20 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v18, v19, v20, buf, 0xCu);
    goto LABEL_65;
  }
  int v8 = *(_DWORD *)(a1 + 52);
  if (v8)
  {
    unsigned int v9 = v8 - (*(_DWORD *)(a1 + 56) + *(_DWORD *)(a1 + 60));
    unsigned int v10 = v9 - a2;
    if (v9 >= a2) {
      goto LABEL_5;
    }
LABEL_68:
    __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    os_log_type_t v50 = "m_sum16";
    __int16 v51 = 1024;
    *(_DWORD *)__int16 v52 = a2;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = v9;
    __int16 v37 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v37, &type, &v47)) {
      goto LABEL_98;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v50 = "m_sum16";
      __int16 v51 = 1024;
      *(_DWORD *)__int16 v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      __int16 v40 = "%{public}s off %u > mlen %u in m_sum16";
    }
    else if (v47)
    {
      char v41 = (char *)__nw_create_backtrace_string();
      BOOL v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      BOOL v42 = os_log_type_enabled(v38, type);
      if (v41)
      {
        if (v42)
        {
          *(_DWORD *)buf = 136446978;
          os_log_type_t v50 = "m_sum16";
          __int16 v51 = 1024;
          *(_DWORD *)__int16 v52 = a2;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = v9;
          __int16 v53 = 2082;
          *(void *)__int16 v54 = v41;
          _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s off %u > mlen %u in m_sum16, dumping backtrace:%{public}s", buf, 0x22u);
        }
        free(v41);
LABEL_98:
        if (v37)
        {
          os_log_type_t v43 = (char *)v37;
          goto LABEL_100;
        }
LABEL_101:
        int v45 = 22;
LABEL_92:
        *a4 = v45;
        return 1;
      }
      if (!v42) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v50 = "m_sum16";
      __int16 v51 = 1024;
      *(_DWORD *)__int16 v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      __int16 v40 = "%{public}s off %u > mlen %u in m_sum16, no backtrace";
    }
    else
    {
      BOOL v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (!os_log_type_enabled(v38, type)) {
        goto LABEL_98;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v50 = "m_sum16";
      __int16 v51 = 1024;
      *(_DWORD *)__int16 v52 = a2;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = v9;
      __int16 v40 = "%{public}s off %u > mlen %u in m_sum16, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v38, v39, v40, buf, 0x18u);
    goto LABEL_98;
  }
LABEL_67:
  unsigned int v9 = 0;
  unsigned int v10 = -a2;
  if (a2) {
    goto LABEL_68;
  }
LABEL_5:
  if (v10 < a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446978;
    os_log_type_t v50 = "m_sum16";
    __int16 v51 = 1024;
    *(_DWORD *)__int16 v52 = v10;
    *(_WORD *)&v52[4] = 1024;
    *(_DWORD *)&v52[6] = a3;
    __int16 v53 = 1024;
    *(_DWORD *)__int16 v54 = a2;
    uint64_t v21 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v21, &type, &v47)) {
      goto LABEL_82;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446978;
      os_log_type_t v50 = "m_sum16";
      __int16 v51 = 1024;
      *(_DWORD *)__int16 v52 = v10;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = a3;
      __int16 v53 = 1024;
      *(_DWORD *)__int16 v54 = a2;
      BOOL v24 = "%{public}s mlen %u < len %u (off %u) in m_sum16";
    }
    else if (v47)
    {
      os_log_type_t v33 = (char *)__nw_create_backtrace_string();
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v34 = os_log_type_enabled(v22, type);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136447234;
          os_log_type_t v50 = "m_sum16";
          __int16 v51 = 1024;
          *(_DWORD *)__int16 v52 = v10;
          *(_WORD *)&v52[4] = 1024;
          *(_DWORD *)&v52[6] = a3;
          __int16 v53 = 1024;
          *(_DWORD *)__int16 v54 = a2;
          v54[2] = 2082;
          *(void *)&v54[3] = v33;
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s mlen %u < len %u (off %u) in m_sum16, dumping backtrace:%{public}s", buf, 0x28u);
        }
        free(v33);
LABEL_82:
        if (v21)
        {
          os_log_type_t v43 = (char *)v21;
LABEL_100:
          free(v43);
          goto LABEL_101;
        }
        goto LABEL_101;
      }
      if (!v34) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446978;
      os_log_type_t v50 = "m_sum16";
      __int16 v51 = 1024;
      *(_DWORD *)__int16 v52 = v10;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = a3;
      __int16 v53 = 1024;
      *(_DWORD *)__int16 v54 = a2;
      BOOL v24 = "%{public}s mlen %u < len %u (off %u) in m_sum16, no backtrace";
    }
    else
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_82;
      }
      *(_DWORD *)buf = 136446978;
      os_log_type_t v50 = "m_sum16";
      __int16 v51 = 1024;
      *(_DWORD *)__int16 v52 = v10;
      *(_WORD *)&v52[4] = 1024;
      *(_DWORD *)&v52[6] = a3;
      __int16 v53 = 1024;
      *(_DWORD *)__int16 v54 = a2;
      BOOL v24 = "%{public}s mlen %u < len %u (off %u) in m_sum16, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0x1Eu);
    goto LABEL_82;
  }
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v50 = "__nw_frame_unclaimed_bytes";
    BOOL v25 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v47 = 0;
    if (!__nwlog_fault(v25, &type, &v47)) {
      goto LABEL_87;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "__nw_frame_unclaimed_bytes";
      uint64_t v28 = "%{public}s called with null frame";
    }
    else if (v47)
    {
      __int16 v35 = (char *)__nw_create_backtrace_string();
      char v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v36 = os_log_type_enabled(v26, type);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v50 = "__nw_frame_unclaimed_bytes";
          __int16 v51 = 2082;
          *(void *)__int16 v52 = v35;
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v35);
        goto LABEL_87;
      }
      if (!v36)
      {
LABEL_87:
        if (v25) {
          free(v25);
        }
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "__nw_frame_unclaimed_bytes";
      uint64_t v28 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      char v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (!os_log_type_enabled(v26, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "__nw_frame_unclaimed_bytes";
      uint64_t v28 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v26, v27, v28, buf, 0xCu);
    goto LABEL_87;
  }
  uint64_t v11 = *(void *)(a1 + 112);
  if (!v11
    || (*(_WORD *)(a1 + 204) & 0x100) != 0
    && g_channel_check_validity
    && (!g_channel_check_validity(a1, *(void *)(a1 + 88)) || (uint64_t v11 = *(void *)(a1 + 112)) == 0))
  {
LABEL_89:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v44 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v50 = "m_sum16";
      _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_INFO, "%{public}s frame is no longer valid", buf, 0xCu);
    }
    int v45 = 6;
    goto LABEL_92;
  }
  return (unsigned __int16)~(unsigned __int16)MEMORY[0x185317EE0](v11 + *(unsigned int *)(a1 + 56) + a2, a3, 0);
}

void nw_protocol_data_access_buffer(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = (void (**)(void, void, void))v4;
  if (!v3)
  {
    unsigned int v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_protocol_data_access_buffer";
    unsigned int v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_47;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null data", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_protocol_data_access_buffer";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_47:
        if (!v10) {
          goto LABEL_34;
        }
LABEL_48:
        free(v10);
        goto LABEL_34;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_protocol_data_access_buffer";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_46:

    goto LABEL_47;
  }
  if (v4)
  {
    uint64_t v6 = v3[14];
    if (v6)
    {
      if ((*((_WORD *)v3 + 102) & 0x100) == 0
        || !g_channel_check_validity
        || g_channel_check_validity(v3, v3[11]))
      {
        LODWORD(v6) = *((_DWORD *)v3 + 13);
        uint64_t v7 = *((unsigned int *)v3 + 14);
        if (v6) {
          LODWORD(v6) = v6 - (v7 + *((_DWORD *)v3 + 15));
        }
        uint64_t v8 = v3[14] + v7;
        goto LABEL_33;
      }
      LODWORD(v6) = 0;
    }
    uint64_t v8 = 0;
LABEL_33:
    v5[2](v5, v8, v6);
    goto LABEL_34;
  }
  os_log_type_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_protocol_data_access_buffer";
  unsigned int v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23)) {
    goto LABEL_47;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_data_access_buffer";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null access_block", buf, 0xCu);
    }
    goto LABEL_46;
  }
  if (!v23)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_data_access_buffer";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_46;
  }
  uint64_t v18 = (char *)__nw_create_backtrace_string();
  uint64_t v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_protocol_data_access_buffer";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_46;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    char v26 = "nw_protocol_data_access_buffer";
    __int16 v27 = 2082;
    uint64_t v28 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_48;
  }
LABEL_34:
}

void sub_18313462C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t udp_validate_cksum_internal(uint64_t a1, uint64_t a2, unsigned __int16 *a3, unsigned __int16 *a4, int a5, uint64_t a6)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  char v51 = 0;
  int v50 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v55 = "__nw_frame_get_internet_checksum";
    BOOL v36 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v53 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v36, type, &v53)) {
      goto LABEL_90;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      __int16 v37 = __nwlog_obj();
      os_log_type_t v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "__nw_frame_get_internet_checksum";
      os_log_type_t v39 = "%{public}s called with null frame";
    }
    else if (v53)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      __int16 v37 = __nwlog_obj();
      os_log_type_t v38 = type[0];
      BOOL v45 = os_log_type_enabled(v37, type[0]);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "__nw_frame_get_internet_checksum";
          __int16 v56 = 2082;
          os_log_type_t v57 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v37, v38, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_90;
      }
      if (!v45)
      {
LABEL_90:
        if (v36) {
          free(v36);
        }
        goto LABEL_5;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "__nw_frame_get_internet_checksum";
      os_log_type_t v39 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      __int16 v37 = __nwlog_obj();
      os_log_type_t v38 = type[0];
      if (!os_log_type_enabled(v37, type[0])) {
        goto LABEL_90;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v55 = "__nw_frame_get_internet_checksum";
      os_log_type_t v39 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v37, v38, v39, buf, 0xCu);
    goto LABEL_90;
  }
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0
    || !g_channel_get_internet_checksum_handler
    || g_channel_get_internet_checksum_handler(a1, &v51, (char *)&v50 + 2, &v50))
  {
    goto LABEL_5;
  }
  int v16 = *(unsigned __int16 *)(a1 + 204);
  if ((~v16 & 0x1800) == 0)
  {
    int v13 = (unsigned __int16)v50;
    goto LABEL_44;
  }
  if (!v51)
  {
LABEL_5:
    *(_DWORD *)os_log_type_t type = 0;
    LOWORD(v50) = ~(unsigned __int16)inet_cksum(a1, 0, a2, (int *)type);
    if (!*(_DWORD *)type)
    {
LABEL_10:
      unsigned int v12 = a2;
      goto LABEL_11;
    }
    if (a1)
    {
      if ((*(_WORD *)(a1 + 204) & 0x100) == 0
        || !g_channel_check_validity
        || (g_channel_check_validity(a1, *(void *)(a1 + 88)) & 1) != 0)
      {
        goto LABEL_10;
      }
LABEL_99:
      if (a6)
      {
        *(void *)(a6 + 64) = 0;
        *(void *)(a6 + 72) = 0;
      }
      return 0;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v55 = "__nw_frame_check_validity";
    __int16 v40 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v53 = OS_LOG_TYPE_ERROR;
    char v52 = 0;
    if (__nwlog_fault(v40, &v53, &v52))
    {
      if (v53 == OS_LOG_TYPE_FAULT)
      {
        char v41 = __nwlog_obj();
        os_log_type_t v42 = v53;
        if (!os_log_type_enabled(v41, v53)) {
          goto LABEL_97;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v55 = "__nw_frame_check_validity";
        os_log_type_t v43 = "%{public}s called with null frame";
        goto LABEL_96;
      }
      if (!v52)
      {
        char v41 = __nwlog_obj();
        os_log_type_t v42 = v53;
        if (!os_log_type_enabled(v41, v53)) {
          goto LABEL_97;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v55 = "__nw_frame_check_validity";
        os_log_type_t v43 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_96;
      }
      char v46 = (char *)__nw_create_backtrace_string();
      char v41 = __nwlog_obj();
      os_log_type_t v42 = v53;
      BOOL v47 = os_log_type_enabled(v41, v53);
      if (v46)
      {
        if (v47)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v55 = "__nw_frame_check_validity";
          __int16 v56 = 2082;
          os_log_type_t v57 = v46;
          _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v46);
        goto LABEL_97;
      }
      if (v47)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v55 = "__nw_frame_check_validity";
        os_log_type_t v43 = "%{public}s called with null frame, no backtrace";
LABEL_96:
        _os_log_impl(&dword_1830D4000, v41, v42, v43, buf, 0xCu);
      }
    }
LABEL_97:
    if (v40) {
      free(v40);
    }
    goto LABEL_99;
  }
  if ((v16 & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a1, *(void *)(a1 + 88))
    || (uint64_t v17 = *(void *)(a1 + 112)) == 0
    || (int v18 = *(_DWORD *)(a1 + 48)) == 0)
  {
    BOOL v32 = __nwlog_obj();
    if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO)) {
      goto LABEL_62;
    }
    os_log_type_t v48 = "";
    if (a6) {
      os_log_type_t v48 = (const char *)(a6 + 96);
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v55 = "udp_validate_cksum_internal";
    __int16 v56 = 2082;
    os_log_type_t v57 = (void *)v48;
    BOOL v34 = "%{public}s %{public}s Frame buffer no longer valid";
    goto LABEL_61;
  }
  uint64_t v19 = *(void *)(a1 + 112);
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0
    || (uint64_t v19 = *(void *)(a1 + 112), !g_channel_check_validity)
    || g_channel_check_validity(a1, *(void *)(a1 + 88)) && (uint64_t v19 = *(void *)(a1 + 112)) != 0)
  {
    unsigned int v20 = (unsigned __int16)(v19 + *(_DWORD *)(a1 + 56) - v17);
    int v21 = v20 + a2;
    if ((a5 & 1) != 0 || !HIWORD(v50) || HIWORD(v50) == v20)
    {
      if (a5)
      {
        if (HIWORD(v50) == v20 && v18 == v21)
        {
          unsigned int v12 = 0;
          goto LABEL_12;
        }
      }
      else if (v18 == v21)
      {
        unsigned int v12 = 0;
        goto LABEL_40;
      }
    }
    int v22 = v18 - v21;
    LOWORD(v50) = in_adjust_cksum(v17, v18, HIWORD(v50), v20, a2, (unsigned __int16)v50);
    if (v20 <= HIWORD(v50)) {
      unsigned int v12 = v22 - v20 + HIWORD(v50);
    }
    else {
      unsigned int v12 = v22 + v20 - HIWORD(v50);
    }
LABEL_11:
    if (a5)
    {
LABEL_12:
      int v13 = in6_pseudo(a3, a4, bswap32(a2 + 17) + (unsigned __int16)v50);
      if (a6)
      {
        if (v12)
        {
          uint64_t v14 = *(void *)(a6 + 64);
          if (v14)
          {
            uint64_t v15 = *(void *)(v14 + 64) + v12;
            ++*(void *)(v14 + 56);
            *(void *)(v14 + 64) = v15;
          }
        }
      }
      goto LABEL_44;
    }
LABEL_40:
    unint64_t v23 = *(unsigned int *)a4 + (unint64_t)*(unsigned int *)a3 + bswap32(a2 + 17) + (unsigned __int16)v50;
    LODWORD(v23) = ((WORD1(v23) + (unsigned __int16)v23 + HIDWORD(v23)) >> 16)
                 + (unsigned __int16)(WORD1(v23) + v23 + WORD2(v23));
    int v13 = (unsigned __int16)(((WORD1(v23) + (unsigned __int16)v23) >> 16)
                           + WORD1(v23)
                           + v23
                           + ((((WORD1(v23) + (unsigned __int16)v23) >> 16)
                             + (unsigned __int16)(WORD1(v23) + v23)) >> 16));
    if (a6)
    {
      if (v12)
      {
        uint64_t v24 = *(void *)(a6 + 64);
        if (v24)
        {
          uint64_t v25 = *(void *)(v24 + 48) + v12;
          ++*(void *)(v24 + 40);
          *(void *)(v24 + 48) = v25;
        }
      }
    }
LABEL_44:
    LOWORD(v50) = ~(_WORD)v13;
    if (v13 == 0xFFFF) {
      return 1;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v27 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      uint64_t v28 = (const char *)(a6 + 96);
      if (!a6) {
        uint64_t v28 = "";
      }
      *(_DWORD *)buf = 136447490;
      uint64_t v55 = "udp_validate_cksum_internal";
      __int16 v56 = 2082;
      os_log_type_t v57 = (void *)v28;
      uint64_t v29 = "IPv6";
      if (!a5) {
        uint64_t v29 = "IPv4";
      }
      __int16 v58 = 2082;
      os_log_type_t v59 = v29;
      BOOL v30 = "non-offload";
      __int16 v60 = 2082;
      if (v51) {
        BOOL v30 = "offload";
      }
      BOOL v61 = v30;
      __int16 v62 = 1024;
      int v63 = (unsigned __int16)v50;
      __int16 v64 = 1024;
      int v65 = a2;
      _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp incorrect %{public}s-UDP %{public}s checksum 0x%x ulen %u", buf, 0x36u);
    }
    if (a6)
    {
      uint64_t v31 = *(void *)(a6 + 64);
      if (v31)
      {
        uint64_t result = 0;
        ++*(void *)(v31 + 16);
        return result;
      }
    }
    return 0;
  }
  BOOL v32 = __nwlog_obj();
  if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
  {
    os_log_type_t v33 = "";
    if (a6) {
      os_log_type_t v33 = (const char *)(a6 + 96);
    }
    *(_DWORD *)buf = 136446466;
    uint64_t v55 = "udp_validate_cksum_internal";
    __int16 v56 = 2082;
    os_log_type_t v57 = (void *)v33;
    BOOL v34 = "%{public}s %{public}s Frame buffer no longer valid for UDP";
LABEL_61:
    _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_INFO, v34, buf, 0x16u);
  }
LABEL_62:
  uint64_t result = 0;
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0)
  {
    if (g_channel_check_validity)
    {
      char v35 = g_channel_check_validity(a1, *(void *)(a1 + 88));
      uint64_t result = 0;
      if (a6)
      {
        if ((v35 & 1) == 0)
        {
          uint64_t result = 0;
          *(void *)(a6 + 64) = 0;
          *(void *)(a6 + 72) = 0;
        }
      }
    }
  }
  return result;
}

BOOL nw_protocol_ipv4_process_input_frame(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, _DWORD *a5, _DWORD *a6)
{
  uint64_t v158 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    char v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (!__nwlog_fault(v89, type, &v147)) {
      goto LABEL_252;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v147)
      {
        char v90 = __nwlog_obj();
        os_log_type_t v91 = type[0];
        if (os_log_type_enabled(v90, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          char v92 = "%{public}s called with null ipv4, backtrace limit exceeded";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v90 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v112 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (v112)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          char v92 = "%{public}s called with null ipv4, no backtrace";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      if (!v112) {
        goto LABEL_215;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v113 = "%{public}s called with null ipv4, dumping backtrace:%{public}s";
      goto LABEL_214;
    }
    char v90 = __nwlog_obj();
    os_log_type_t v91 = type[0];
    if (!os_log_type_enabled(v90, type[0])) {
      goto LABEL_252;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    char v92 = "%{public}s called with null ipv4";
LABEL_251:
    _os_log_impl(&dword_1830D4000, v90, v91, v92, buf, 0xCu);
    goto LABEL_252;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    char v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (!__nwlog_fault(v89, type, &v147)) {
      goto LABEL_252;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!v147)
      {
        char v90 = __nwlog_obj();
        os_log_type_t v91 = type[0];
        if (os_log_type_enabled(v90, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          char v92 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v90 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v114 = os_log_type_enabled(v90, type[0]);
      if (!backtrace_string)
      {
        if (v114)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          char v92 = "%{public}s called with null frame, no backtrace";
          goto LABEL_251;
        }
        goto LABEL_252;
      }
      if (!v114) {
        goto LABEL_215;
      }
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v113 = "%{public}s called with null frame, dumping backtrace:%{public}s";
      goto LABEL_214;
    }
    char v90 = __nwlog_obj();
    os_log_type_t v91 = type[0];
    if (!os_log_type_enabled(v90, type[0])) {
      goto LABEL_252;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    char v92 = "%{public}s called with null frame";
    goto LABEL_251;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    char v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (!__nwlog_fault(v89, type, &v147)) {
      goto LABEL_252;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v90 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      if (!os_log_type_enabled(v90, type[0])) {
        goto LABEL_252;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      char v92 = "%{public}s called with null count";
      goto LABEL_251;
    }
    if (!v147)
    {
      char v90 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        char v92 = "%{public}s called with null count, backtrace limit exceeded";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v90 = __nwlog_obj();
    os_log_type_t v91 = type[0];
    BOOL v115 = os_log_type_enabled(v90, type[0]);
    if (!backtrace_string)
    {
      if (v115)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        char v92 = "%{public}s called with null count, no backtrace";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    if (!v115) {
      goto LABEL_215;
    }
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    uint64_t v113 = "%{public}s called with null count, dumping backtrace:%{public}s";
LABEL_214:
    _os_log_impl(&dword_1830D4000, v90, v91, v113, buf, 0x16u);
    goto LABEL_215;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    char v89 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v147 = 0;
    if (!__nwlog_fault(v89, type, &v147)) {
      goto LABEL_252;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v90 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        char v92 = "%{public}s called with null reassembly_count";
        goto LABEL_251;
      }
LABEL_252:
      if (!v89) {
        return 0;
      }
      os_log_type_t v68 = (char *)v89;
      goto LABEL_107;
    }
    if (!v147)
    {
      char v90 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      if (os_log_type_enabled(v90, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        char v92 = "%{public}s called with null reassembly_count, backtrace limit exceeded";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v90 = __nwlog_obj();
    os_log_type_t v91 = type[0];
    BOOL v116 = os_log_type_enabled(v90, type[0]);
    if (!backtrace_string)
    {
      if (v116)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        char v92 = "%{public}s called with null reassembly_count, no backtrace";
        goto LABEL_251;
      }
      goto LABEL_252;
    }
    if (v116)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      uint64_t v113 = "%{public}s called with null reassembly_count, dumping backtrace:%{public}s";
      goto LABEL_214;
    }
LABEL_215:
    free(backtrace_string);
    goto LABEL_252;
  }
  if (!*(void *)(a2 + 112)
    || (*(_WORD *)(a2 + 204) & 0x100) != 0
    && g_channel_check_validity
    && !g_channel_check_validity(a2, *(void *)(a2 + 88)))
  {
    unsigned int v14 = 0;
    uint64_t v15 = 0;
  }
  else
  {
    int v13 = *(_DWORD *)(a2 + 52);
    uint64_t v12 = *(unsigned int *)(a2 + 56);
    if (v13) {
      unsigned int v14 = v13 - (v12 + *(_DWORD *)(a2 + 60));
    }
    else {
      unsigned int v14 = 0;
    }
    uint64_t v15 = (uint32x4_t *)(*(void *)(a2 + 112) + v12);
  }
  if ((*(_WORD *)(a2 + 204) & 0x80) != 0) {
    unsigned int v14 = *(unsigned __int16 *)(a2 + 196);
  }
  if (!v15)
  {
    if (*(unsigned char *)(a1 + 136)) {
      goto LABEL_227;
    }
    os_log_type_t v93 = __nwlog_obj();
    if (!os_log_type_enabled(v93, OS_LOG_TYPE_INFO)) {
      goto LABEL_227;
    }
    goto LABEL_226;
  }
  if (v14 <= 0x13)
  {
    if ((*(unsigned char *)(a1 + 136) & 1) == 0)
    {
      uint64_t v94 = __nwlog_obj();
      if (os_log_type_enabled(v94, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&unsigned char buf[22] = 2080;
        os_log_type_t v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v14;
        _os_log_impl(&dword_1830D4000, v94, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Received IPv4 packet with incorrect length %u", buf, 0x30u);
      }
    }
    uint64_t v95 = *(void *)(a1 + 48);
    if (v95)
    {
      BOOL result = 0;
      ++*(void *)(v95 + 40);
      return result;
    }
    return 0;
  }
  if ((v15->i8[0] & 0xF0) != 0x40)
  {
    if ((*(unsigned char *)(a1 + 136) & 1) == 0)
    {
      size_t v96 = __nwlog_obj();
      if (os_log_type_enabled(v96, OS_LOG_TYPE_ERROR))
      {
        int v97 = v15->u8[0] >> 4;
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&unsigned char buf[22] = 2080;
        os_log_type_t v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v97;
        _os_log_impl(&dword_1830D4000, v96, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Invalid IPv4 version: %u", buf, 0x30u);
      }
    }
    uint64_t v98 = *(void *)(a1 + 48);
    if (v98)
    {
      BOOL result = 0;
      ++*(void *)(v98 + 96);
      return result;
    }
    return 0;
  }
  unsigned int v16 = 4 * (v15->i8[0] & 0xF);
  if (v16 <= 0x13)
  {
    if ((*(unsigned char *)(a1 + 136) & 1) == 0)
    {
      __int16 v99 = __nwlog_obj();
      if (os_log_type_enabled(v99, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447234;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&unsigned char buf[22] = 2080;
        os_log_type_t v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v16;
        BOOL v100 = "%{public}s %{public}s%s%p Invalid header length: %u";
        uint64_t v101 = v99;
        uint32_t v102 = 48;
LABEL_195:
        _os_log_impl(&dword_1830D4000, v101, OS_LOG_TYPE_ERROR, v100, buf, v102);
        goto LABEL_196;
      }
    }
    goto LABEL_196;
  }
  if (v14 < v16)
  {
    if ((*(unsigned char *)(a1 + 136) & 1) == 0)
    {
      os_log_type_t v103 = __nwlog_obj();
      if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136447490;
        *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = a1 + 137;
        *(_WORD *)&unsigned char buf[22] = 2080;
        os_log_type_t v149 = " ";
        __int16 v150 = 2048;
        uint64_t v151 = a1;
        __int16 v152 = 1024;
        unsigned int v153 = v16;
        __int16 v154 = 1024;
        *(_DWORD *)os_log_type_t v155 = v14;
        BOOL v100 = "%{public}s %{public}s%s%p Invalid header length: %u > %u";
LABEL_194:
        uint64_t v101 = v103;
        uint32_t v102 = 54;
        goto LABEL_195;
      }
    }
LABEL_196:
    uint64_t v110 = *(void *)(a1 + 48);
    if (v110)
    {
      BOOL result = 0;
      ++*(void *)(v110 + 72);
      return result;
    }
    return 0;
  }
  if (v15->i32[3] == *(_DWORD *)(a1 + 60))
  {
    __int32 v17 = v15[1].i32[0];
    if (v17 == *(_DWORD *)(a1 + 56)
      || v17 == -1
      || (v15[1].i32[0] & 0xF0) == 0xE0
      || (int v18 = *(_DWORD *)(a1 + 128)) != 0 && v17 == v18
      || v18 && (int v19 = *(_DWORD *)(a1 + 124)) != 0 && v17 == (v19 & v18))
    {
      unsigned int v20 = bswap32(v15->u16[1]) >> 16;
      int v21 = v14 - v20;
      if (v14 < v20)
      {
        if ((*(unsigned char *)(a1 + 136) & 1) == 0)
        {
          uint64_t v107 = __nwlog_obj();
          if (os_log_type_enabled(v107, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&unsigned char buf[22] = 2080;
            os_log_type_t v149 = " ";
            __int16 v150 = 2048;
            uint64_t v151 = a1;
            __int16 v152 = 1024;
            unsigned int v153 = v20;
            __int16 v154 = 1024;
            *(_DWORD *)os_log_type_t v155 = v14;
            _os_log_impl(&dword_1830D4000, v107, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Received IPv4 packet with incorrect length, expected %u received %u", buf, 0x36u);
          }
        }
        uint64_t v108 = *(void *)(a1 + 48);
        if (v108)
        {
          BOOL result = 0;
          ++*(void *)(v108 + 64);
          return result;
        }
        return 0;
      }
      if (v14 != v20 && (*(unsigned char *)(a1 + 136) & 1) == 0)
      {
        if (gLogDatapath)
        {
          os_log_t loga = __nwlog_obj();
          BOOL v109 = os_log_type_enabled(loga, OS_LOG_TYPE_DEBUG);
          int v21 = v14 - v20;
          if (v109)
          {
            *(_DWORD *)buf = 136447490;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&unsigned char buf[22] = 2080;
            os_log_type_t v149 = " ";
            __int16 v150 = 2048;
            uint64_t v151 = a1;
            __int16 v152 = 1024;
            unsigned int v153 = v20;
            __int16 v154 = 1024;
            *(_DWORD *)os_log_type_t v155 = v14;
            _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Received length mismatch with IP total length %u != %u", buf, 0x36u);
            int v21 = v14 - v20;
          }
        }
      }
      if (v16 <= v20)
      {
        if ((v15->i16[3] & 0xFF3F) != 0)
        {
          if ((*(_WORD *)(a2 + 204) & 0x80) == 0)
          {
            *a6 += nw_protocol_ipv4_process_reassembly(a1, v15->u16[2], a4, 0, 0);
            if ((*(_WORD *)(a2 + 204) & 0x100) == 0
              || !g_channel_check_validity
              || (g_channel_check_validity(a2, *(void *)(a2 + 88)) & 1) != 0)
            {
              unsigned int v22 = (bswap32(v15->u16[3]) >> 13) & 0x7FFF8;
              if ((*(unsigned char *)(a1 + 136) & 1) == 0)
              {
                if (gLogDatapath)
                {
                  __int16 v121 = __nwlog_obj();
                  if (os_log_type_enabled(v121, OS_LOG_TYPE_DEBUG))
                  {
                    unsigned int v122 = v15->u16[2];
                    *(_DWORD *)buf = 136447490;
                    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = a1 + 137;
                    *(_WORD *)&unsigned char buf[22] = 2080;
                    os_log_type_t v149 = " ";
                    __int16 v150 = 2048;
                    uint64_t v151 = a1;
                    __int16 v152 = 1024;
                    unsigned int v153 = v122;
                    __int16 v154 = 1024;
                    *(_DWORD *)os_log_type_t v155 = (unsigned __int16)v22;
                    _os_log_impl(&dword_1830D4000, v121, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%s%p Got fragment for IP ID %u at offset %u", buf, 0x36u);
                  }
                }
              }
              uint64_t v23 = *(void *)(a2 + 32);
              uint64_t v24 = *(void **)(a2 + 40);
              uint64_t v25 = (void *)(a2 + 32);
              if (v23)
              {
                *(void *)(v23 + 40) = v24;
                uint64_t v24 = *(void **)(a2 + 40);
              }
              else
              {
                *(void *)(a3 + 8) = v24;
              }
              *uint64_t v24 = v23;
              *uint64_t v25 = 0;
              *(void *)(a2 + 40) = 0;
              int v45 = v15->u16[3];
              if ((v45 & 0xFFFFFF1F) != 0)
              {
                if ((v45 & 0x20) != 0)
                {
                  *(void *)buf = 0;
                  *(void *)&buf[8] = buf;
                  *(void *)&buf[16] = 0x2000000000;
                  LOBYTE(v149) = 0;
                  v140[0] = MEMORY[0x1E4F143A8];
                  v140[1] = 0x40000000;
                  int v141 = ___ZL36nw_protocol_ipv4_process_input_frameP16nw_protocol_ipv4P8nw_frameP16nw_frame_array_sS4_PjS5__block_invoke;
                  id v142 = &unk_1E524B148;
                  __int16 v146 = v22;
                  uint64_t v144 = a1;
                  uint64_t v145 = a2;
                  v143 = buf;
                  uint64_t v51 = *(void *)(a1 + 64);
                  do
                  {
                    if (!v51) {
                      break;
                    }
                    uint64_t v52 = *(void *)(v51 + 32);
                    char v53 = ((uint64_t (*)(void *))v141)(v140);
                    uint64_t v51 = v52;
                  }
                  while ((v53 & 1) != 0);
                  if (!*(unsigned char *)(*(void *)&buf[8] + 24))
                  {
                    *(void *)(a2 + 32) = 0;
                    __int16 v54 = *(uint64_t **)(a1 + 72);
                    *(void *)(a2 + 40) = v54;
                    uint64_t *v54 = a2;
                    *(void *)(a1 + 72) = v25;
                  }
                  _Block_object_dispose(buf, 8);
                }
                else
                {
                  char v46 = *(uint64_t **)(a1 + 72);
                  *(void *)(a2 + 40) = v46;
                  uint64_t *v46 = a2;
                  *(void *)(a1 + 72) = v25;
                }
              }
              else
              {
                uint64_t v48 = *(void *)(a1 + 64);
                BOOL v47 = (uint64_t *)(a1 + 64);
                *(void *)(a2 + 32) = v48;
                char v49 = (void *)(v48 + 40);
                if (v48) {
                  int v50 = v49;
                }
                else {
                  int v50 = v47 + 1;
                }
                void *v50 = v25;
                *BOOL v47 = a2;
                *(void *)(a2 + 40) = v47;
              }
              --*a5;
              return 1;
            }
            if ((*(unsigned char *)(a1 + 136) & 1) != 0
              || (os_log_type_t v93 = __nwlog_obj(), !os_log_type_enabled(v93, OS_LOG_TYPE_INFO)))
            {
LABEL_227:
              BOOL result = 0;
              *(void *)(a1 + 48) = 0;
              return result;
            }
LABEL_226:
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 137;
            *(_WORD *)&unsigned char buf[22] = 2080;
            os_log_type_t v149 = " ";
            __int16 v150 = 2048;
            uint64_t v151 = a1;
            _os_log_impl(&dword_1830D4000, v93, OS_LOG_TYPE_INFO, "%{public}s %{public}s%s%p Frame is no longer valid", buf, 0x2Au);
            goto LABEL_227;
          }
          if (*(unsigned char *)(a1 + 136)) {
            return 0;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)buf = 136447234;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 137;
          *(_WORD *)&unsigned char buf[22] = 2080;
          os_log_type_t v149 = " ";
          __int16 v150 = 2048;
          uint64_t v151 = a1;
          __int16 v152 = 1024;
          unsigned int v153 = v14;
          os_log_type_t v39 = (const char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          char v147 = 0;
          if (__nwlog_fault(v39, type, &v147))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v40 = gLogObj;
              os_log_type_t v41 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 137;
              *(_WORD *)&unsigned char buf[22] = 2080;
              os_log_type_t v149 = " ";
              __int16 v150 = 2048;
              uint64_t v151 = a1;
              __int16 v152 = 1024;
              unsigned int v153 = v14;
              os_log_type_t v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u";
LABEL_104:
              _os_log_impl(&dword_1830D4000, v40, v41, v42, buf, 0x30u);
              goto LABEL_105;
            }
            if (!v147)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v40 = gLogObj;
              os_log_type_t v41 = type[0];
              if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 137;
              *(_WORD *)&unsigned char buf[22] = 2080;
              os_log_type_t v149 = " ";
              __int16 v150 = 2048;
              uint64_t v151 = a1;
              __int16 v152 = 1024;
              unsigned int v153 = v14;
              os_log_type_t v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, backtrace limit exceeded";
              goto LABEL_104;
            }
            os_log_type_t v43 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v40 = gLogObj;
            os_log_type_t v41 = type[0];
            BOOL v44 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
            if (!v43)
            {
              if (!v44) {
                goto LABEL_105;
              }
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 137;
              *(_WORD *)&unsigned char buf[22] = 2080;
              os_log_type_t v149 = " ";
              __int16 v150 = 2048;
              uint64_t v151 = a1;
              __int16 v152 = 1024;
              unsigned int v153 = v14;
              os_log_type_t v42 = "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, no backtrace";
              goto LABEL_104;
            }
            if (v44)
            {
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 137;
              *(_WORD *)&unsigned char buf[22] = 2080;
              os_log_type_t v149 = " ";
              __int16 v150 = 2048;
              uint64_t v151 = a1;
              __int16 v152 = 1024;
              unsigned int v153 = v14;
              __int16 v154 = 2082;
              *(void *)os_log_type_t v155 = v43;
              _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s %{public}s%s%p Received fragment on a super-packet with length %u, dumping backtrace:%{public}s", buf, 0x3Au);
            }
            free(v43);
          }
LABEL_105:
          if (v39)
          {
            os_log_type_t v68 = (char *)v39;
LABEL_107:
            free(v68);
          }
          return 0;
        }
        int v26 = v21;
        *a6 += nw_protocol_ipv4_process_reassembly(a1, 0, a4, 0, 0);
        if ((*(_WORD *)(a2 + 204) & 0x100) != 0
          && g_channel_check_validity
          && (g_channel_check_validity(a2, *(void *)(a2 + 88)) & 1) == 0)
        {
          if (*(unsigned char *)(a1 + 136)) {
            goto LABEL_227;
          }
          os_log_type_t v93 = __nwlog_obj();
          if (!os_log_type_enabled(v93, OS_LOG_TYPE_INFO)) {
            goto LABEL_227;
          }
          goto LABEL_226;
        }
        __int8 v28 = v15->i8[1];
        int v29 = v28 & 3;
        *(unsigned char *)(a2 + 186) = *(unsigned char *)(a2 + 186) & 0xFC | v28 & 3;
        switch(v29)
        {
          case 3:
            BOOL v30 = (void *)(a1 + 32);
            break;
          case 2:
            BOOL v30 = (void *)(a1 + 24);
            break;
          case 1:
            BOOL v30 = (void *)(a1 + 16);
            break;
          default:
            char v31 = *(unsigned char *)(a1 + 136);
            if ((v31 & 2) != 0) {
              goto LABEL_92;
            }
            goto LABEL_50;
        }
        ++*v30;
        char v31 = *(unsigned char *)(a1 + 136);
        if ((v31 & 2) != 0)
        {
LABEL_92:
          uint64_t v64 = mach_continuous_time();
          int v65 = *(_WORD *)(a2 + 204) & 0xFFEF | (*(unsigned __int8 *)(a2 + 206) << 16);
          *(_WORD *)(a2 + 204) &= ~0x10u;
          *(unsigned char *)(a2 + 206) = BYTE2(v65);
          *(void *)(a2 + 152) = v64;
          if ((*(unsigned char *)(a1 + 136) & 0x80) == 0) {
            goto LABEL_51;
          }
          goto LABEL_93;
        }
LABEL_50:
        if ((v31 & 0x80) == 0) {
          goto LABEL_51;
        }
LABEL_93:
        *(unsigned char *)(a2 + 185) = v15->i8[8];
LABEL_51:
        if ((*(_WORD *)(a2 + 204) & 8) != 0) {
          goto LABEL_115;
        }
        uint64_t v32 = a2 + 120;
        os_log_type_t v33 = *(void **)(a2 + 168);
        if (v33)
        {
          os_release(v33);
          *(void *)(a2 + 168) = 0;
        }
        uint64_t v34 = *(void *)(a2 + 64);
        *(unsigned char *)(a2 + 186) |= 0x40u;
        if (!v34)
        {
          *(void *)(a2 + 64) = v32;
          *(void *)(a2 + 72) = v32;
          *(void *)(a2 + 120) = 0;
          *(void *)(a2 + 128) = a2 + 64;
          goto LABEL_115;
        }
        if (v34 == v32) {
          goto LABEL_115;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
        *(_WORD *)&unsigned char buf[12] = 2048;
        *(void *)&buf[14] = v34;
        *(_WORD *)&unsigned char buf[22] = 2048;
        os_log_type_t v149 = (const char *)(a2 + 120);
        char v35 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        char v147 = 0;
        if (__nwlog_fault(v35, type, &v147))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v36 = gLogObj;
            os_log_type_t v37 = type[0];
            if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
              goto LABEL_113;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v34;
            *(_WORD *)&unsigned char buf[22] = 2048;
            os_log_type_t v149 = (const char *)(a2 + 120);
            os_log_type_t v38 = "%{public}s Existing metadata %p doesn't match expected %p";
LABEL_111:
            os_log_type_t v69 = v36;
LABEL_112:
            _os_log_impl(&dword_1830D4000, v69, v37, v38, buf, 0x20u);
            goto LABEL_113;
          }
          if (!v147)
          {
            BOOL v36 = __nwlog_obj();
            os_log_type_t v37 = type[0];
            if (!os_log_type_enabled(v36, type[0])) {
              goto LABEL_113;
            }
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v34;
            *(_WORD *)&unsigned char buf[22] = 2048;
            os_log_type_t v149 = (const char *)(a2 + 120);
            os_log_type_t v38 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
            goto LABEL_111;
          }
          uint64_t v66 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v37 = type[0];
          os_log_type_t log = gLogObj;
          BOOL v67 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v66)
          {
            if (v67)
            {
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = v34;
              *(_WORD *)&unsigned char buf[22] = 2048;
              os_log_type_t v149 = (const char *)(a2 + 120);
              __int16 v150 = 2082;
              uint64_t v151 = (uint64_t)v66;
              _os_log_impl(&dword_1830D4000, log, v37, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
            }
            free(v66);
            goto LABEL_113;
          }
          if (v67)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "__nw_frame_set_metadata";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v34;
            *(_WORD *)&unsigned char buf[22] = 2048;
            os_log_type_t v149 = (const char *)(a2 + 120);
            os_log_type_t v38 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
            os_log_type_t v69 = log;
            goto LABEL_112;
          }
        }
LABEL_113:
        if (v35) {
          free(v35);
        }
LABEL_115:
        if (v15->u8[9] != *(unsigned __int8 *)(a1 + 134))
        {
          if ((*(unsigned char *)(a1 + 136) & 1) == 0)
          {
            uint64_t v117 = __nwlog_obj();
            if (os_log_type_enabled(v117, OS_LOG_TYPE_ERROR))
            {
              unsigned int v118 = v15->u8[9];
              int v119 = *(unsigned __int8 *)(a1 + 134);
              *(_DWORD *)buf = 136447490;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 137;
              *(_WORD *)&unsigned char buf[22] = 2080;
              os_log_type_t v149 = " ";
              __int16 v150 = 2048;
              uint64_t v151 = a1;
              __int16 v152 = 1024;
              unsigned int v153 = v118;
              __int16 v154 = 1024;
              *(_DWORD *)os_log_type_t v155 = v119;
              _os_log_impl(&dword_1830D4000, v117, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Invalid IPv4 protocol %u (expected %u)", buf, 0x36u);
            }
          }
          uint64_t v120 = *(void *)(a1 + 48);
          if (v120)
          {
            BOOL result = 0;
            ++*(void *)(v120 + 144);
            return result;
          }
          return 0;
        }
        __int16 v70 = *(_WORD *)(a2 + 204);
        if ((v70 & 0x100) != 0)
        {
          char v147 = 0;
          *(_WORD *)buf = 0;
          *(_WORD *)os_log_type_t type = 0;
          if (g_channel_get_internet_checksum_handler)
          {
            g_channel_get_internet_checksum_handler(a2, &v147, buf, type);
            __int16 v70 = *(_WORD *)(a2 + 204);
          }
        }
        if ((v70 & 0x200) != 0)
        {
          if ((v70 & 0x400) != 0)
          {
LABEL_137:
            uint64_t v88 = *(void *)(a1 + 48);
            if (v88) {
              ++*(void *)(v88 + 136);
            }
            nw_frame_claim(a2, v27, v16, v26);
            ++*(void *)(a1 + 8);
            return 1;
          }
          if ((*(unsigned char *)(a1 + 136) & 1) == 0)
          {
            os_log_type_t v74 = __nwlog_obj();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR)) {
              goto LABEL_240;
            }
          }
          goto LABEL_241;
        }
        if ((v15 & 3) != 0)
        {
          if (v16 - 2 > 0x1D)
          {
            uint64_t v78 = ((v16 - 2) >> 1) + 1;
            int v79 = 2 * (v78 & 0xFFFFFFF0);
            unsigned int v80 = (uint16x8_t *)&v15[1];
            int32x4_t v81 = 0uLL;
            uint64_t v82 = v78 & 0xFFFFFFF0;
            int32x4_t v83 = 0uLL;
            int32x4_t v84 = 0uLL;
            int32x4_t v85 = 0uLL;
            do
            {
              uint16x8_t v86 = v80[-1];
              int32x4_t v83 = (int32x4_t)vaddw_high_u16((uint32x4_t)v83, v86);
              int32x4_t v81 = (int32x4_t)vaddw_u16((uint32x4_t)v81, *(uint16x4_t *)v86.i8);
              int32x4_t v85 = (int32x4_t)vaddw_high_u16((uint32x4_t)v85, *v80);
              int32x4_t v84 = (int32x4_t)vaddw_u16((uint32x4_t)v84, *(uint16x4_t *)v80->i8);
              v80 += 2;
              v82 -= 16;
            }
            while (v82);
            unsigned int v71 = vaddvq_s32(vaddq_s32(vaddq_s32(v84, v81), vaddq_s32(v85, v83)));
            if ((v78 & 0xFFFFFFF0) == v78) {
              goto LABEL_135;
            }
            os_log_type_t v72 = (unsigned __int16 *)v15 + (v78 & 0xFFFFFFF0);
            unsigned int v73 = v16 - v79;
          }
          else
          {
            unsigned int v71 = 0;
            os_log_type_t v72 = (unsigned __int16 *)v15;
            unsigned int v73 = v16;
          }
          do
          {
            int v87 = *v72++;
            v71 += v87;
            v73 -= 2;
          }
          while (v73);
LABEL_135:
          int v77 = HIWORD(v71) + (unsigned __int16)v71;
LABEL_136:
          if ((unsigned __int16)(v77 + HIWORD(v77)) == 0xFFFF) {
            goto LABEL_137;
          }
          if ((*(unsigned char *)(a1 + 136) & 1) == 0)
          {
            os_log_type_t v74 = __nwlog_obj();
            if (os_log_type_enabled(v74, OS_LOG_TYPE_ERROR))
            {
LABEL_240:
              unsigned int v123 = bswap32(v15->u16[5]) >> 16;
              *(_DWORD *)buf = 136447234;
              *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 137;
              *(_WORD *)&unsigned char buf[22] = 2080;
              os_log_type_t v149 = " ";
              __int16 v150 = 2048;
              uint64_t v151 = a1;
              __int16 v152 = 1024;
              unsigned int v153 = v123;
              _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%s%p Invalid checksum 0x%x", buf, 0x30u);
            }
          }
LABEL_241:
          uint64_t v124 = *(void *)(a1 + 48);
          if (v124)
          {
            BOOL result = 0;
            ++*(void *)(v124 + 8);
            return result;
          }
          return 0;
        }
        if (v16 == 20)
        {
          unint64_t v75 = vaddlvq_u32(*v15) + v15[1].u32[0];
        }
        else
        {
          if (v16 - 4 > 0x1B)
          {
            uint64_t v127 = ((v16 - 4) >> 2) + 1;
            int v128 = 4 * (v127 & 0x7FFFFFF8);
            uint64_t v129 = v15 + 1;
            int64x2_t v130 = 0uLL;
            uint64_t v131 = v127 & 0x7FFFFFF8;
            int64x2_t v132 = 0uLL;
            int64x2_t v133 = 0uLL;
            int64x2_t v134 = 0uLL;
            do
            {
              uint32x4_t v135 = v129[-1];
              int64x2_t v132 = (int64x2_t)vaddw_high_u32((uint64x2_t)v132, v135);
              int64x2_t v130 = (int64x2_t)vaddw_u32((uint64x2_t)v130, *(uint32x2_t *)v135.i8);
              int64x2_t v134 = (int64x2_t)vaddw_high_u32((uint64x2_t)v134, *v129);
              int64x2_t v133 = (int64x2_t)vaddw_u32((uint64x2_t)v133, *(uint32x2_t *)v129->i8);
              v129 += 2;
              v131 -= 8;
            }
            while (v131);
            unint64_t v75 = vaddvq_s64(vaddq_s64(vaddq_s64(v133, v130), vaddq_s64(v134, v132)));
            if ((v127 & 0x7FFFFFF8) == v127) {
              goto LABEL_129;
            }
            BOOL v125 = &v15->i32[v127 & 0x7FFFFFF8];
            unsigned int v126 = v16 - v128;
          }
          else
          {
            unint64_t v75 = 0;
            BOOL v125 = (__int32 *)v15;
            unsigned int v126 = v16;
          }
          do
          {
            unsigned int v136 = *v125++;
            v75 += v136;
            v126 -= 4;
          }
          while (v126);
        }
LABEL_129:
        unint64_t v76 = ((HIDWORD(v75) + v75) >> 16) + (unsigned __int16)(WORD2(v75) + v75);
        int v77 = (v76 >> 16) + (unsigned __int16)v76;
        goto LABEL_136;
      }
      if ((*(unsigned char *)(a1 + 136) & 1) == 0)
      {
        os_log_type_t v103 = __nwlog_obj();
        if (os_log_type_enabled(v103, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136447490;
          *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = a1 + 137;
          *(_WORD *)&unsigned char buf[22] = 2080;
          os_log_type_t v149 = " ";
          __int16 v150 = 2048;
          uint64_t v151 = a1;
          __int16 v152 = 1024;
          unsigned int v153 = v16;
          __int16 v154 = 1024;
          *(_DWORD *)os_log_type_t v155 = v20;
          BOOL v100 = "%{public}s %{public}s%s%p Invalid header length (greater than IP length): %u > %u";
          goto LABEL_194;
        }
      }
      goto LABEL_196;
    }
    if (*(unsigned char *)(a1 + 136)) {
      return 0;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v55 = gLogObj;
    BOOL result = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
    if (!result) {
      return result;
    }
    __int32 v57 = v15[1].i32[0];
    int v58 = *(_DWORD *)(a1 + 56);
    int v60 = *(_DWORD *)(a1 + 124);
    int v59 = *(_DWORD *)(a1 + 128);
    *(_DWORD *)buf = 136448002;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = a1 + 137;
    *(_WORD *)&unsigned char buf[22] = 2080;
    os_log_type_t v149 = " ";
    __int16 v150 = 2048;
    uint64_t v151 = a1;
    __int16 v152 = 1024;
    unsigned int v153 = v57;
    __int16 v154 = 1024;
    *(_DWORD *)os_log_type_t v155 = v58;
    *(_WORD *)&v155[4] = 1024;
    *(_DWORD *)&v155[6] = v59;
    __int16 v156 = 1024;
    int v157 = v60;
    BOOL v61 = "%{public}s %{public}s%s%p Received local address 0x%x != 0x%x (broadcast %x, netmask %x)";
    __int16 v62 = v55;
    uint32_t v63 = 66;
LABEL_88:
    _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_ERROR, v61, buf, v63);
    return 0;
  }
  if (*(unsigned char *)(a1 + 136)) {
    return 0;
  }
  int v104 = __nwlog_obj();
  BOOL result = os_log_type_enabled(v104, OS_LOG_TYPE_ERROR);
  if (result)
  {
    __int32 v105 = v15->i32[3];
    int v106 = *(_DWORD *)(a1 + 60);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_protocol_ipv4_process_input_frame";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = a1 + 137;
    *(_WORD *)&unsigned char buf[22] = 2080;
    os_log_type_t v149 = " ";
    __int16 v150 = 2048;
    uint64_t v151 = a1;
    __int16 v152 = 1024;
    unsigned int v153 = v105;
    __int16 v154 = 1024;
    *(_DWORD *)os_log_type_t v155 = v106;
    BOOL v61 = "%{public}s %{public}s%s%p Received remote address 0x%x != 0x%x";
    __int16 v62 = v104;
    uint32_t v63 = 54;
    goto LABEL_88;
  }
  return result;
}

uint64_t nw_channel_frame_check_validity(nw_frame *a1, void *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v13 = "nw_channel_frame_check_validity";
    id v4 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v4, &type, &v10)) {
      goto LABEL_26;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      int v13 = "nw_channel_frame_check_validity";
      uint64_t v7 = "%{public}s called with null context";
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          int v13 = "nw_channel_frame_check_validity";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_26;
      }
      if (!v9)
      {
LABEL_26:
        if (v4) {
          free(v4);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      int v13 = "nw_channel_frame_check_validity";
      uint64_t v7 = "%{public}s called with null context, no backtrace";
    }
    else
    {
      uint64_t v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (!os_log_type_enabled(v5, type)) {
        goto LABEL_26;
      }
      *(_DWORD *)buf = 136446210;
      int v13 = "nw_channel_frame_check_validity";
      uint64_t v7 = "%{public}s called with null context, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v5, v6, v7, buf, 0xCu);
    goto LABEL_26;
  }
  if (a2[17])
  {
    if (((*((unsigned __int16 *)a2 + 222) | (*((unsigned __int8 *)a2 + 446) << 16)) & 0x80000) == 0)
    {
      if (!os_channel_is_defunct()) {
        return 1;
      }
      nw_channel_handle_defunct((uint64_t)a2);
    }
  }
  else
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
    }
    if (_nw_signposts_enabled)
    {
      uint64_t result = kdebug_is_enabled();
      if (!result) {
        return result;
      }
      kdebug_trace();
    }
  }
  return 0;
}

void NWListener.newConnectionHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  os_log_type_t v6 = *(os_unfair_lock_s **)(v2 + 16);
  uint64_t v7 = (uint64_t *)&v6[4];
  uint64_t v8 = v6 + 48;
  os_unfair_lock_lock(v6 + 48);
  sub_1834A519C(v7);
  os_unfair_lock_unlock(v8);
  if (a1)
  {
    BOOL v9 = *(NSObject **)(v2 + 24);
    uint64_t v10 = *(void *)(v3 + 32);
    uint64_t v11 = (void *)swift_allocObject();
    v11[2] = v10;
    v11[3] = a1;
    void v11[4] = a2;
    void aBlock[4] = sub_1832E6DEC;
    aBlock[5] = v11;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = sub_1832E6CC4;
    aBlock[3] = &block_descriptor_3;
    uint64_t v12 = _Block_copy(aBlock);
    sub_18315ED5C(a1);
    sub_18315ED5C(a1);
    swift_unknownObjectRetain();
    swift_retain();
    swift_release();
    nw_listener_set_new_connection_handler(v9, v12);
    sub_18313D870(a1);
    _Block_release(v12);
    swift_unknownObjectRelease();
    sub_18313D870(a1);
  }
  else
  {
    nw_listener_set_new_connection_handler(*(nw_listener_t *)(v2 + 24), 0);
  }
}

void NWListener.start(queue:)(NSObject *a1)
{
  uint64_t v2 = v1;
  id v4 = *(os_unfair_lock_s **)(v1 + 16);
  uint64_t v5 = (uint64_t)&v4[4];
  os_log_type_t v6 = v4 + 48;
  os_unfair_lock_lock(v4 + 48);
  sub_1834A4FC0(v5);
  os_unfair_lock_unlock(v6);
  os_unfair_lock_lock(v6);
  sub_1834A538C(v5, v11);
  os_unfair_lock_unlock(v6);
  if (v11[0])
  {
    long long v10 = *(_OWORD *)v11;
    uint64_t v7 = swift_allocObject();
    *(_OWORD *)(v7 + 16) = v10;
    uint64_t v8 = sub_18313D738;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v7 = 0;
  }
  sub_18315ED5C((uint64_t)v8);
  sub_18315ED5C((uint64_t)v8);
  NWListener.stateUpdateHandler.setter((uint64_t)v8, v7);
  sub_18313D870((uint64_t)v8);
  sub_18313D870((uint64_t)v8);
  BOOL v9 = *(NSObject **)(v1 + 24);
  nw_listener_set_queue(*(nw_listener_t *)(v2 + 24), a1);
  nw_listener_start(v9);
}

uint64_t NWListener.stateUpdateHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  os_log_type_t v6 = *(os_unfair_lock_s **)(v2 + 16);
  uint64_t v7 = (uint64_t)&v6[4];
  uint64_t v8 = v6 + 48;
  os_unfair_lock_lock(v6 + 48);
  sub_1831373D0(v7, aBlock);
  os_unfair_lock_unlock(v8);
  if (LOBYTE(aBlock[0]) != 1) {
    return sub_18313D870(a1);
  }
  BOOL v9 = *(NSObject **)(v2 + 24);
  long long v10 = (void *)swift_allocObject();
  v10[2] = v3;
  v10[3] = a1;
  v10[4] = a2;
  void aBlock[4] = sub_1834A51F8;
  aBlock[5] = v10;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_1834A3A3C;
  aBlock[3] = &block_descriptor_6_1;
  uint64_t v11 = _Block_copy(aBlock);
  swift_unknownObjectRetain();
  swift_retain();
  sub_18315ED5C(a1);
  swift_release();
  nw_listener_set_state_changed_handler(v9, v11);
  sub_18313D870(a1);
  _Block_release(v11);
  return swift_unknownObjectRelease();
}

uint64_t sub_1831373D0@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v6 = *(void *)(v2 + 16);
  uint64_t v5 = *(void *)(v2 + 24);
  uint64_t v7 = *(void *)(a1 + 32);
  sub_18315ED5C(v6);
  uint64_t result = sub_18313D870(v7);
  *(void *)(a1 + 32) = v6;
  *(void *)(a1 + 40) = v5;
  *a2 = *(unsigned char *)(a1 + 173);
  return result;
}

uint64_t sub_183137440(uint64_t a1)
{
  uint64_t v1 = *(void (**)(uint64_t))(a1 + 32);
  uint64_t v2 = swift_retain();
  v1(v2);

  return swift_release();
}

uint64_t sub_183137484()
{
  uint64_t v1 = *(void *)(type metadata accessor for NWPath(0) - 8);
  return (*(uint64_t (**)(unint64_t))(v0 + 16))(v0 + ((*(unsigned __int8 *)(v1 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v1 + 80)));
}

uint64_t NWPathMonitor.pathUpdateHandler.setter(uint64_t a1)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = v3 + *(void *)(*MEMORY[0x1E4FBBAB0] + *(void *)v3 + 16);
  uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_1831375AC(v4);
  os_unfair_lock_unlock(v5);
  return sub_18313D870(a1);
}

uint64_t sub_1831375AC(uint64_t a1)
{
  return sub_1831375C8(a1, *(void *)(v1 + 16), *(void *)(v1 + 24));
}

uint64_t sub_1831375C8(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v5 = (uint64_t *)(a1 + *(int *)(type metadata accessor for NWPathMonitor.LockedState(0) + 20));
  uint64_t v6 = *v5;
  sub_18315ED5C(a2);
  uint64_t result = sub_18313D870(v6);
  uint64_t *v5 = a2;
  v5[1] = a3;
  return result;
}

void NWPathMonitor.start(queue:)()
{
  uint64_t v1 = *(void *)(v0 + 16);
  uint64_t v2 = v1 + *(void *)(*MEMORY[0x1E4FBBAB0] + *(void *)v1 + 16);
  uint64_t v3 = (os_unfair_lock_s *)(v1 + ((*(unsigned int *)(*(void *)v1 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v3);
  sub_1831376D8(v2);
  os_unfair_lock_unlock(v3);
}

int *sub_1831376D8(uint64_t a1)
{
  return sub_183138AC8(a1, *(void *)(v1 + 16), *(void **)(v1 + 24));
}

uint64_t NWPathMonitor.init()()
{
  uint64_t locked = type metadata accessor for NWPathMonitor.LockedState(0);
  uint64_t v2 = (int *)(locked - 8);
  MEMORY[0x1F4188790](locked);
  uint64_t v4 = (char *)&v9 - ((v3 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = type metadata accessor for NWPath(0);
  (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 56))(v4, 1, 1, v5);
  uint64_t v6 = &v4[v2[7]];
  *(void *)uint64_t v6 = 0;
  *((void *)v6 + 1) = 0;
  *(void *)&v4[v2[8]] = 1;
  *(void *)&v4[v2[9]] = 0;
  *(void *)&v4[v2[10]] = MEMORY[0x1E4FBC868];
  v4[v2[11]] = 0;
  v4[v2[12]] = 0;
  *(void *)&v4[v2[13]] = 0;
  __swift_instantiateConcreteTypeFromMangledName(&qword_1EB266A18);
  uint64_t v7 = swift_allocObject();
  *(_DWORD *)(v7 + ((*(unsigned int *)(*(void *)v7 + 48) + 3) & 0x1FFFFFFFCLL)) = 0;
  sub_18313829C((uint64_t)v4, v7 + *(void *)(*MEMORY[0x1E4FBBAB0] + *(void *)v7 + 16), type metadata accessor for NWPathMonitor.LockedState);
  sub_1832FF6F4((uint64_t)v4, type metadata accessor for NWPathMonitor.LockedState);
  *(void *)(v0 + 16) = v7;
  *(void *)(v0 + 24) = nw_path_monitor_create();
  return v0;
}

void NWPathMonitor.currentPath.getter(uint64_t a1@<X8>)
{
  uint64_t v3 = *(void *)(v1 + 16);
  uint64_t v4 = v3 + *(void *)(*MEMORY[0x1E4FBBAB0] + *(void *)v3 + 16);
  uint64_t v5 = (os_unfair_lock_s *)(v3 + ((*(unsigned int *)(*(void *)v3 + 48) + 3) & 0x1FFFFFFFCLL));
  os_unfair_lock_lock(v5);
  sub_183138744(v4, a1);

  os_unfair_lock_unlock(v5);
}

uint64_t sub_183137974(uint64_t a1, uint64_t a2)
{
  uint64_t v68 = __swift_instantiateConcreteTypeFromMangledName(&qword_1EB2669E8);
  int64_t v73 = *(void *)(v68 - 8);
  MEMORY[0x1F4188790](v68);
  BOOL v67 = (char *)v57 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(&qword_1EB266A00);
  uint64_t v64 = *(void *)(v5 - 8);
  MEMORY[0x1F4188790](v5);
  uint64_t v66 = (char *)v57 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = __swift_instantiateConcreteTypeFromMangledName(&qword_1EB2669F8);
  uint64_t v8 = MEMORY[0x1F4188790](v7 - 8);
  unsigned int v71 = (char *)v57 - ((v9 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v8);
  os_log_type_t v72 = (char *)v57 - v10;
  uint64_t v11 = sub_183D449CC();
  uint64_t v12 = *(char **)(v11 - 8);
  MEMORY[0x1F4188790](v11);
  uint32_t v63 = (char *)v57 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  int v65 = (void (**)(char *, uint64_t, uint64_t))sub_183D449EC();
  uint64_t v62 = (uint64_t)*(v65 - 1);
  MEMORY[0x1F4188790](v65);
  BOOL v61 = (char *)v57 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v15 = type metadata accessor for NWPath(0);
  uint64_t v16 = *(void *)(v15 - 8);
  uint64_t v17 = *(void *)(v16 + 64);
  MEMORY[0x1F4188790](v15);
  uint64_t v69 = (uint64_t)v57 - ((v17 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_183138A24(a1, (uint64_t *)&unk_1EB266A38);
  uint64_t v70 = a2;
  sub_18313829C(a2, a1, type metadata accessor for NWPath);
  (*(void (**)(uint64_t, void, uint64_t, uint64_t))(v16 + 56))(a1, 0, 1, v15);
  uint64_t locked = (int *)type metadata accessor for NWPathMonitor.LockedState(0);
  int v19 = (uint64_t *)(a1 + locked[5]);
  uint64_t v20 = *v19;
  if (*v19)
  {
    int v21 = *(void **)(a1 + locked[7]);
    if (v21)
    {
      uint64_t v22 = v19[1];
      int v59 = v12;
      int64_t v60 = (int64_t)locked;
      uint64_t v23 = a1;
      uint64_t v24 = v69;
      sub_18313829C(v70, v69, type metadata accessor for NWPath);
      unint64_t v25 = (*(unsigned __int8 *)(v16 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v16 + 80);
      uint64_t v26 = swift_allocObject();
      *(void *)(v26 + 16) = v20;
      *(void *)(v26 + 24) = v22;
      uint64_t v27 = v24;
      a1 = v23;
      sub_183138878(v27, v26 + v25, type metadata accessor for NWPath);
      void aBlock[4] = sub_1831374EC;
      aBlock[5] = v26;
      aBlock[0] = MEMORY[0x1E4F143A8];
      aBlock[1] = 1107296256;
      aBlock[2] = sub_183137440;
      aBlock[3] = &block_descriptor_114;
      int v58 = _Block_copy(aBlock);
      v57[1] = v22;
      sub_18315ED5C(v20);
      sub_18315ED5C(v20);
      id v28 = v21;
      int v29 = v61;
      sub_183D449DC();
      aBlock[8] = MEMORY[0x1E4FBC860];
      sub_183138A80((unint64_t *)&qword_1EB2669E0, MEMORY[0x1E4FBCB00]);
      __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1EB2669C0);
      sub_1831389C8();
      BOOL v30 = v63;
      sub_183D453FC();
      char v31 = v58;
      MEMORY[0x1853146E0](0, v29, v30, v58);
      _Block_release(v31);

      sub_18313D870(v20);
      (*((void (**)(char *, uint64_t))v59 + 1))(v30, v11);
      (*(void (**)(char *, void (**)(char *, uint64_t, uint64_t)))(v62 + 8))(v29, v65);
      swift_release();
      uint64_t locked = (int *)v60;
    }
  }
  uint64_t v32 = *(char **)(a1 + locked[8]);
  uint64_t v33 = *((void *)v32 + 8);
  int v59 = v32 + 64;
  uint64_t v34 = 1 << v32[32];
  uint64_t v35 = -1;
  if (v34 < 64) {
    uint64_t v35 = ~(-1 << v34);
  }
  unint64_t v36 = v35 & v33;
  int64_t v60 = (unint64_t)(v34 + 63) >> 6;
  BOOL v61 = (char *)(v64 + 16);
  int v65 = (void (**)(char *, uint64_t, uint64_t))(v64 + 32);
  os_log_type_t v37 = (void (**)(char *, uint64_t))(v73 + 8);
  os_log_type_t v38 = (uint64_t (**)(char *, uint64_t))(v64 + 8);
  int v58 = (void *)(v60 - 1);
  uint32_t v63 = v32;
  uint64_t result = swift_bridgeObjectRetain();
  int64_t v73 = 0;
  uint64_t v62 = v5;
  if (!v36) {
    goto LABEL_11;
  }
LABEL_9:
  unint64_t v43 = __clz(__rbit64(v36));
  v36 &= v36 - 1;
  unint64_t v44 = v43 | (v73 << 6);
  int v45 = v71;
  while (2)
  {
    uint64_t v46 = v64;
    uint64_t v47 = *((void *)v63 + 7);
    *(void *)int v45 = *(void *)(*((void *)v63 + 6) + 8 * v44);
    uint64_t v48 = v47 + *(void *)(v46 + 72) * v44;
    uint64_t v49 = __swift_instantiateConcreteTypeFromMangledName(&qword_1EB2669F0);
    int v50 = *(void (**)(char *, uint64_t, uint64_t))(v46 + 16);
    uint64_t v5 = v62;
    v50(&v45[*(int *)(v49 + 48)], v48, v62);
    (*(void (**)(char *, void, uint64_t, uint64_t))(*(void *)(v49 - 8) + 56))(v45, 0, 1, v49);
    uint64_t v51 = (uint64_t)v72;
    while (1)
    {
      sub_183138964((uint64_t)v45, v51, &qword_1EB2669F8);
      uint64_t v56 = __swift_instantiateConcreteTypeFromMangledName(&qword_1EB2669F0);
      if ((*(unsigned int (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v56 - 8) + 48))(v51, 1, v56) == 1) {
        return swift_release();
      }
      uint64_t v40 = v51 + *(int *)(v56 + 48);
      os_log_type_t v41 = v66;
      (*v65)(v66, v40, v5);
      sub_18313829C(v70, v69, type metadata accessor for NWPath);
      os_log_type_t v42 = v67;
      sub_183D44FEC();
      (*v37)(v42, v68);
      uint64_t result = (*v38)(v41, v5);
      if (v36) {
        goto LABEL_9;
      }
LABEL_11:
      int64_t v52 = v73 + 1;
      int v45 = v71;
      if (__OFADD__(v73, 1))
      {
        __break(1u);
        goto LABEL_32;
      }
      uint64_t v51 = (uint64_t)v72;
      if (v52 < v60)
      {
        unint64_t v53 = *(void *)&v59[8 * v52];
        if (v53) {
          goto LABEL_14;
        }
        int64_t v54 = v73 + 2;
        ++v73;
        if (v52 + 1 < v60)
        {
          unint64_t v53 = *(void *)&v59[8 * v54];
          if (v53) {
            goto LABEL_17;
          }
          int64_t v73 = v52 + 1;
          if (v52 + 2 < v60)
          {
            unint64_t v53 = *(void *)&v59[8 * v52 + 16];
            if (v53)
            {
              v52 += 2;
              goto LABEL_14;
            }
            int64_t v54 = v52 + 3;
            int64_t v73 = v52 + 2;
            if (v52 + 3 < v60) {
              break;
            }
          }
        }
      }
LABEL_28:
      uint64_t v55 = __swift_instantiateConcreteTypeFromMangledName(&qword_1EB2669F0);
      (*(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v55 - 8) + 56))(v45, 1, 1, v55);
      unint64_t v36 = 0;
    }
    unint64_t v53 = *(void *)&v59[8 * v54];
    if (v53)
    {
LABEL_17:
      int64_t v52 = v54;
LABEL_14:
      unint64_t v36 = (v53 - 1) & v53;
      unint64_t v44 = __clz(__rbit64(v53)) + (v52 << 6);
      int64_t v73 = v52;
      continue;
    }
    break;
  }
  while (1)
  {
    int64_t v52 = v54 + 1;
    if (__OFADD__(v54, 1)) {
      break;
    }
    if (v52 >= v60)
    {
      int64_t v73 = (int64_t)v58;
      goto LABEL_28;
    }
    unint64_t v53 = *(void *)&v59[8 * v52];
    ++v54;
    if (v53) {
      goto LABEL_14;
    }
  }
LABEL_32:
  __break(1u);
  return result;
}

uint64_t sub_18313829C(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t initializeWithCopy for NWPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  *(unsigned char *)a1 = *(unsigned char *)a2;
  *(void *)(a1 + 8) = *(void *)(a2 + 8);
  *(_DWORD *)(a1 + 16) = *(_DWORD *)(a2 + 16);
  *(void *)(a1 + 24) = *(void *)(a2 + 24);
  uint64_t v5 = *(int *)(a3 + 44);
  uint64_t v6 = (void *)(a1 + v5);
  uint64_t v7 = (char *)(a2 + v5);
  uint64_t v8 = type metadata accessor for NWEndpoint();
  uint64_t v9 = *(void *)(v8 - 8);
  uint64_t v10 = *(unsigned int (**)(char *, uint64_t, uint64_t))(v9 + 48);
  swift_bridgeObjectRetain();
  swift_bridgeObjectRetain();
  if (v10(v7, 1, v8))
  {
    uint64_t v11 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
    memcpy(v6, v7, *(void *)(*(void *)(v11 - 8) + 64));
    uint64_t v12 = a3;
  }
  else
  {
    uint64_t v12 = a3;
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        uint64_t v14 = *((void *)v7 + 1);
        void *v6 = *(void *)v7;
        v6[1] = v14;
        uint64_t v15 = *((void *)v7 + 3);
        v6[2] = *((void *)v7 + 2);
        size_t v6[3] = v15;
        uint64_t v16 = *((void *)v7 + 5);
        v6[4] = *((void *)v7 + 4);
        v6[5] = v16;
        uint64_t v17 = *((void *)v7 + 6);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v17 != 1) {
          swift_unknownObjectRetain();
        }
        v6[6] = v17;
        uint64_t v12 = a3;
        break;
      case 2u:
        uint64_t v18 = *((void *)v7 + 1);
        void *v6 = *(void *)v7;
        v6[1] = v18;
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v19 = sub_183D4447C();
        (*(void (**)(void *, char *, uint64_t))(*(void *)(v19 - 8) + 16))(v6, v7, v19);
        break;
      case 4u:
        void *v6 = *(void *)v7;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v13 = *(void *)v7;
        uint64_t v35 = *((void *)v7 + 2);
        uint64_t v36 = *((void *)v7 + 1);
        char v34 = v7[24];
        sub_18315E9E4(*(void *)v7, v36, v35, v34);
        void *v6 = v13;
        uint64_t v12 = a3;
        v6[1] = v36;
        v6[2] = v35;
        *((unsigned char *)v6 + 24) = v34;
        *((_WORD *)v6 + 13) = *((_WORD *)v7 + 13);
        break;
    }
    swift_storeEnumTagMultiPayload();
    (*(void (**)(void *, void, uint64_t, uint64_t))(v9 + 56))(v6, 0, 1, v8);
  }
  uint64_t v20 = *(int *)(v12 + 48);
  int v21 = (void *)(a1 + v20);
  uint64_t v22 = (char *)(a2 + v20);
  if (v10((char *)(a2 + v20), 1, v8))
  {
    uint64_t v23 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
    memcpy(v21, v22, *(void *)(*(void *)(v23 - 8) + 64));
  }
  else
  {
    switch(swift_getEnumCaseMultiPayload())
    {
      case 1u:
        uint64_t v27 = *((void *)v22 + 1);
        *int v21 = *(void *)v22;
        v21[1] = v27;
        uint64_t v28 = *((void *)v22 + 3);
        void v21[2] = *((void *)v22 + 2);
        v21[3] = v28;
        uint64_t v29 = *((void *)v22 + 5);
        v21[4] = *((void *)v22 + 4);
        v21[5] = v29;
        uint64_t v30 = *((void *)v22 + 6);
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        swift_bridgeObjectRetain();
        if (v30 != 1) {
          swift_unknownObjectRetain();
        }
        v21[6] = v30;
        uint64_t v12 = a3;
        break;
      case 2u:
        uint64_t v31 = *((void *)v22 + 1);
        *int v21 = *(void *)v22;
        v21[1] = v31;
        swift_bridgeObjectRetain();
        break;
      case 3u:
        uint64_t v32 = sub_183D4447C();
        (*(void (**)(void *, char *, uint64_t))(*(void *)(v32 - 8) + 16))(v21, v22, v32);
        break;
      case 4u:
        *int v21 = *(void *)v22;
        swift_unknownObjectRetain();
        break;
      default:
        uint64_t v25 = *(void *)v22;
        uint64_t v24 = *((void *)v22 + 1);
        uint64_t v26 = *((void *)v22 + 2);
        char v37 = v22[24];
        sub_18315E9E4(*(void *)v22, v24, v26, v37);
        *int v21 = v25;
        v21[1] = v24;
        uint64_t v12 = a3;
        void v21[2] = v26;
        *((unsigned char *)v21 + 24) = v37;
        *((_WORD *)v21 + 13) = *((_WORD *)v22 + 13);
        break;
    }
    swift_storeEnumTagMultiPayload();
    (*(void (**)(void *, void, uint64_t, uint64_t))(v9 + 56))(v21, 0, 1, v8);
  }
  *(void *)(a1 + *(int *)(v12 + 52)) = *(void *)(a2 + *(int *)(v12 + 52));
  swift_unknownObjectRetain();
  return a1;
}

uint64_t storeEnumTagSinglePayload for NWPath(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4)
{
  return MEMORY[0x1F41867C0](a1, a2, a3, a4, sub_18351197C);
}

uint64_t sub_183138744@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1EB266A38);
  MEMORY[0x1F4188790](v4 - 8);
  uint64_t v6 = (char *)&v9 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  sub_183138900(a1, (uint64_t)v6, (uint64_t *)&unk_1EB266A38);
  uint64_t v7 = type metadata accessor for NWPath(0);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(*(void *)(v7 - 8) + 48))(v6, 1, v7) != 1) {
    return sub_183138878((uint64_t)v6, a2, type metadata accessor for NWPath);
  }
  sub_1831DF470(0, a2);
  return sub_183138A24((uint64_t)v6, (uint64_t *)&unk_1EB266A38);
}

uint64_t getEnumTagSinglePayload for NWPath(uint64_t a1, uint64_t a2, uint64_t a3)
{
  return MEMORY[0x1F4186578](a1, a2, a3, sub_1835118C8);
}

uint64_t sub_183138878(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t type metadata accessor for NWPath(uint64_t a1)
{
  return sub_18315A7F8(a1, (uint64_t *)&unk_1EB266AC0);
}

uint64_t sub_183138900(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_183138964(uint64_t a1, uint64_t a2, uint64_t *a3)
{
  uint64_t v5 = __swift_instantiateConcreteTypeFromMangledName(a3);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

unint64_t sub_1831389C8()
{
  unint64_t result = qword_1EB2669D0;
  if (!qword_1EB2669D0)
  {
    __swift_instantiateConcreteTypeFromMangledNameAbstract((uint64_t *)&unk_1EB2669C0);
    unint64_t result = swift_getWitnessTable();
    atomic_store(result, (unint64_t *)&qword_1EB2669D0);
  }
  return result;
}

uint64_t sub_183138A24(uint64_t a1, uint64_t *a2)
{
  uint64_t v3 = __swift_instantiateConcreteTypeFromMangledName(a2);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_183138A80(unint64_t *a1, void (*a2)(uint64_t))
{
  uint64_t result = *a1;
  if (!result)
  {
    a2(255);
    uint64_t result = swift_getWitnessTable();
    atomic_store(result, a1);
  }
  return result;
}

int *sub_183138AC8(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t result = (int *)type metadata accessor for NWPathMonitor.LockedState(0);
  uint64_t v7 = result[7];
  if (!*(void *)(a1 + v7))
  {
    uint64_t v8 = result[11];
    swift_retain();
    swift_release();
    *(void *)(a1 + v8) = a2;
    *(void *)(a1 + v7) = a3;
    id v9 = a3;
    return sub_183138B48(a1);
  }
  return result;
}

int *sub_183138B48(uint64_t a1)
{
  uint64_t v3 = sub_183D449CC();
  uint64_t v43 = *(void *)(v3 - 8);
  uint64_t v44 = v3;
  MEMORY[0x1F4188790](v3);
  uint64_t v5 = (char *)&v38 - ((v4 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v6 = sub_183D449EC();
  uint64_t v41 = *(void *)(v6 - 8);
  uint64_t v42 = v6;
  MEMORY[0x1F4188790](v6);
  uint64_t v8 = (char *)&v38 - ((v7 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v9 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1EB266A38);
  MEMORY[0x1F4188790](v9 - 8);
  uint64_t v11 = (char *)&v38 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v12 = type metadata accessor for NWPath(0);
  uint64_t v13 = *(void *)(v12 - 8);
  uint64_t v14 = *(void *)(v13 + 64);
  uint64_t v15 = MEMORY[0x1F4188790](v12);
  uint64_t v16 = (char *)&v38 - ((v14 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v15);
  uint64_t v18 = (char *)&v38 - v17;
  uint64_t result = (int *)type metadata accessor for NWPathMonitor.LockedState(0);
  uint64_t v20 = result[9];
  if (*(unsigned char *)(a1 + v20))
  {
    int v21 = (uint64_t *)(a1 + result[5]);
    uint64_t v22 = *v21;
    if (*v21 && *(void *)(a1 + result[7]))
    {
      uint64_t v23 = v21[1];
      id v39 = *(id *)(a1 + result[7]);
      uint64_t v40 = v23;
      sub_183138900(a1, (uint64_t)v11, (uint64_t *)&unk_1EB266A38);
      if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v13 + 48))(v11, 1, v12) == 1)
      {
        return (int *)sub_183138A24((uint64_t)v11, (uint64_t *)&unk_1EB266A38);
      }
      else
      {
        sub_183138878((uint64_t)v11, (uint64_t)v18, type metadata accessor for NWPath);
        os_log_type_t v38 = type metadata accessor for NWPath;
        sub_18313829C((uint64_t)v18, (uint64_t)v16, type metadata accessor for NWPath);
        unint64_t v31 = (*(unsigned __int8 *)(v13 + 80) + 32) & ~(unint64_t)*(unsigned __int8 *)(v13 + 80);
        uint64_t v32 = v22;
        uint64_t v33 = swift_allocObject();
        uint64_t v34 = v40;
        *(void *)(v33 + 16) = v32;
        *(void *)(v33 + 24) = v34;
        sub_183138878((uint64_t)v16, v33 + v31, type metadata accessor for NWPath);
        int v50 = sub_1831374EC;
        uint64_t v51 = v33;
        uint64_t aBlock = MEMORY[0x1E4F143A8];
        uint64_t v47 = 1107296256;
        uint64_t v48 = sub_183137440;
        uint64_t v49 = &block_descriptor_108;
        uint64_t v35 = _Block_copy(&aBlock);
        sub_18315ED5C(v32);
        sub_18315ED5C(v32);
        id v36 = v39;
        sub_183D449DC();
        uint64_t v45 = MEMORY[0x1E4FBC860];
        sub_183138A80((unint64_t *)&qword_1EB2669E0, MEMORY[0x1E4FBCB00]);
        __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1EB2669C0);
        sub_1831389C8();
        uint64_t v37 = v44;
        sub_183D453FC();
        MEMORY[0x1853146E0](0, v8, v5, v35);

        _Block_release(v35);
        sub_18313D870(v32);
        (*(void (**)(char *, uint64_t))(v43 + 8))(v5, v37);
        (*(void (**)(char *, uint64_t))(v41 + 8))(v8, v42);
        sub_1832FF6F4((uint64_t)v18, v38);
        return (int *)swift_release();
      }
    }
  }
  else
  {
    *(unsigned char *)(a1 + v20) = 1;
    uint64_t v24 = *(NSObject **)(v1 + 24);
    uint64_t v25 = swift_allocObject();
    swift_weakInit();
    int v50 = sub_1832E6DF8;
    uint64_t v51 = v25;
    uint64_t aBlock = MEMORY[0x1E4F143A8];
    uint64_t v47 = 1107296256;
    uint64_t v48 = (uint64_t (*)(uint64_t))sub_1832E6CC4;
    uint64_t v49 = &block_descriptor_98;
    uint64_t v26 = _Block_copy(&aBlock);
    swift_unknownObjectRetain();
    swift_release();
    nw_path_monitor_set_update_handler(v24, v26);
    _Block_release(v26);
    swift_unknownObjectRelease();
    uint64_t v27 = swift_allocObject();
    swift_weakInit();
    int v50 = sub_1835143D4;
    uint64_t v51 = v27;
    uint64_t aBlock = MEMORY[0x1E4F143A8];
    uint64_t v47 = 1107296256;
    uint64_t v48 = sub_183137440;
    uint64_t v49 = &block_descriptor_102;
    uint64_t v28 = _Block_copy(&aBlock);
    swift_unknownObjectRetain();
    swift_release();
    nw_path_monitor_set_cancel_handler(v24, v28);
    _Block_release(v28);
    swift_unknownObjectRelease();
    uint64_t v29 = (void *)nw_path_monitor_copy_parameters(v24);
    swift_unknownObjectRetain();
    uint64_t result = (int *)nw_parameters_copy_context(v29);
    if (result)
    {
      BOOL v30 = nw_context_copy_workloop(result);
      swift_unknownObjectRelease();
      nw_path_monitor_set_queue(v24, (dispatch_queue_t)v30);
      swift_unknownObjectRelease();

      nw_path_monitor_start(v24);
      return (int *)swift_unknownObjectRelease();
    }
    else
    {
      __break(1u);
    }
  }
  return result;
}

void nw_path_snapshot_path(NWConcrete_nw_path *a1)
{
  length[15] = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  direct = v1->direct;
  v1->direct = 0;

  delegate = v1->delegate;
  v1->delegate = 0;

  unsigned int routed_interface_index = v1->policy_result.routed_interface_index;
  if (routed_interface_index
    || (unsigned int routed_interface_index = v1->policy_result.direct_interface_index) != 0
    || (unsigned int routed_interface_index = nw_parameters_get_required_interface_index(v1->parameters)) != 0)
  {
    id v5 = nw_parameters_copy_context(v1->parameters);
    uint64_t v6 = nw_path_copy_interface_with_generation(v5, routed_interface_index, v1->policy_result.direct_interface_generation);
    uint64_t v7 = v1->direct;
    v1->direct = (OS_nw_interface *)v6;

    if (!v1->policy_result.delegate_interface_index) {
      goto LABEL_7;
    }
    id v8 = nw_parameters_copy_context(v1->parameters);
    uint64_t v9 = nw_path_copy_interface_with_generation(v8, v1->policy_result.delegate_interface_index, v1->policy_result.delegate_interface_generation);
    uint64_t v10 = v1->delegate;
    v1->delegate = (OS_nw_interface *)v9;
  }
  else
  {
    endpoint = v1->endpoint;
    if (!endpoint) {
      goto LABEL_7;
    }
    uint64_t v127 = endpoint;
    int v128 = [(OS_nw_endpoint *)v127 type];

    if (v128 != 1 || nw_endpoint_get_address((nw_endpoint_t)v1->endpoint)->sa_family != 1) {
      goto LABEL_7;
    }
    id v8 = nw_parameters_copy_context(v1->parameters);
    if (nw_interface_get_loopback_index::onceToken != -1) {
      dispatch_once(&nw_interface_get_loopback_index::onceToken, &__block_literal_global_89857);
    }
    uint64_t v129 = nw_path_copy_interface_with_generation(v8, nw_interface_get_loopback_index::index, 0);
    uint64_t v10 = v1->direct;
    v1->direct = (OS_nw_interface *)v129;
  }

LABEL_7:
  uint64_t v11 = v1;
  network_agent_dictionary = v11->network_agent_dictionary;
  v11->network_agent_dictionary = 0;

  if (!v11->policy_result.netagents) {
    goto LABEL_231;
  }
  if (!v11->policy_result.num_netagents) {
    goto LABEL_231;
  }
  uint64_t v13 = (OS_xpc_object *)xpc_dictionary_create(0, 0, 0);
  uint64_t v14 = v11->network_agent_dictionary;
  v11->network_agent_dictionary = v13;

  if (!v11->policy_result.num_netagents) {
    goto LABEL_231;
  }
  unint64_t v15 = 0;
  CFAllocatorRef allocator = (const __CFAllocator *)*MEMORY[0x1E4F1CF80];
  do
  {
    if (uuid_is_null(v11->policy_result.netagents[v15].netagent_uuid)) {
      break;
    }
    id v16 = nw_parameters_copy_context(v11->parameters);
    id v244 = 0;
    id v17 = nw_path_copy_dictionary_for_agent_with_generation(v16, v11->policy_result.netagents[v15].netagent_uuid, v11->policy_result.netagents[v15].generation, &v244);
    if (!v17) {
      goto LABEL_193;
    }
    memset(out, 0, sizeof(out));
    uuid_unparse(v11->policy_result.netagents[v15].netagent_uuid, out);
    xpc_dictionary_set_value(v11->network_agent_dictionary, out, v17);
    length[0] = 0;
    dispatch_data_t data = (const char *)xpc_dictionary_get_data(v17, "data", length);
    uint64_t v19 = 0;
    if (data && length[0] >= 0xD8)
    {
      if (length[0] == *((unsigned int *)data + 53) + 216) {
        uint64_t v19 = data;
      }
      else {
        uint64_t v19 = 0;
      }
    }
    if (is_config_agent_type_proxy())
    {
      uint64_t v20 = v11;
      int v21 = config_agent_copy_proxy_information();
      if (v21)
      {
        proxy_settings = v11->proxy_settings;
        if (!proxy_settings)
        {
          uint64_t v23 = (OS_xpc_object *)xpc_array_create(0, 0);
          uint64_t v24 = v11->proxy_settings;
          v11->proxy_settings = v23;

          proxy_settings = v11->proxy_settings;
        }
        xpc_array_append_value(proxy_settings, v21);
        config_agent_free_proxy_information();
      }
    }
    id v25 = v244;
    if (v244)
    {
      uint64_t proxy_configs = (uint64_t)v11->proxy_configs;
      if (!proxy_configs)
      {
        BOOL v27 = nw_array_create();
        uint64_t v28 = v11->proxy_configs;
        v11->uint64_t proxy_configs = (OS_nw_array *)v27;

        uint64_t proxy_configs = (uint64_t)v11->proxy_configs;
        id v25 = v244;
      }
      nw_array_append(proxy_configs, v25);
      length[0] = 0;
      length[1] = 0;
      nw_proxy_config_copy_fallback_proxy_agent(v244, length);
      for (unsigned int i = 0; !uuid_is_null((const unsigned __int8 *)length) && i <= 7; ++i)
      {
        id v30 = nw_path_copy_proxy_config_for_agent_uuid((const unsigned __int8 *)length, v11->policy_result.netagents[v15].generation, v16);
        uuid_clear((unsigned __int8 *)length);
        if (v30)
        {
          unint64_t v31 = v30;
          v31[171] |= 0x20u;

          nw_array_append((uint64_t)v11->proxy_configs, v31);
          uint64_t v32 = v31;
          *(_OWORD *)size_t length = *(_OWORD *)(v32 + 72);
        }
      }
    }
    if (!v19)
    {
      BOOL v100 = __nwlog_obj();
      LODWORD(length[0]) = 136446210;
      *(size_t *)((char *)length + 4) = (size_t)"nw_agent_has_path_override_info";
      os_log_type_t v197 = length;
      uint64_t v101 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(type) = 16;
      LOBYTE(v236) = 0;
      if (__nwlog_fault(v101, &type, &v236))
      {
        if (type == 17)
        {
          uint32_t v102 = __nwlog_obj();
          os_log_type_t v103 = type;
          if (os_log_type_enabled(v102, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_agent_has_path_override_info";
            _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s called with null netagent", (uint8_t *)length, 0xCu);
          }
        }
        else if ((_BYTE)v236)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint32_t v102 = __nwlog_obj();
          os_log_type_t v105 = type;
          BOOL v106 = os_log_type_enabled(v102, (os_log_type_t)type);
          if (backtrace_string)
          {
            if (v106)
            {
              LODWORD(length[0]) = 136446466;
              *(size_t *)((char *)length + 4) = (size_t)"nw_agent_has_path_override_info";
              WORD2(length[1]) = 2082;
              *(size_t *)((char *)&length[1] + 6) = (size_t)backtrace_string;
              _os_log_impl(&dword_1830D4000, v102, v105, "%{public}s called with null netagent, dumping backtrace:%{public}s", (uint8_t *)length, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_216;
          }
          if (v106)
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_agent_has_path_override_info";
            _os_log_impl(&dword_1830D4000, v102, v105, "%{public}s called with null netagent, no backtrace", (uint8_t *)length, 0xCu);
          }
        }
        else
        {
          uint32_t v102 = __nwlog_obj();
          os_log_type_t v107 = type;
          if (os_log_type_enabled(v102, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_agent_has_path_override_info";
            _os_log_impl(&dword_1830D4000, v102, v107, "%{public}s called with null netagent, backtrace limit exceeded", (uint8_t *)length, 0xCu);
          }
        }
      }
LABEL_216:
      if (v101) {
        free(v101);
      }
      goto LABEL_193;
    }
    if (strcmp(v19 + 16, "Network") || strcmp(v19 + 48, "PathOverride")) {
      goto LABEL_193;
    }
    size_t v33 = *((unsigned int *)v19 + 53);
    if (!v33)
    {
      uint64_t v108 = __nwlog_obj();
      LODWORD(length[0]) = 136446210;
      *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
      os_log_type_t v197 = length;
      BOOL v109 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(type) = 16;
      LOBYTE(v236) = 0;
      if (__nwlog_fault(v109, &type, &v236))
      {
        if (type == 17)
        {
          uint64_t v110 = __nwlog_obj();
          os_log_type_t v111 = type;
          if (os_log_type_enabled(v110, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl(&dword_1830D4000, v110, v111, "%{public}s called with null (data_length > 0)", (uint8_t *)length, 0xCu);
          }
        }
        else if ((_BYTE)v236)
        {
          BOOL v112 = (char *)__nw_create_backtrace_string();
          uint64_t v110 = __nwlog_obj();
          os_log_type_t v113 = type;
          BOOL v114 = os_log_type_enabled(v110, (os_log_type_t)type);
          if (v112)
          {
            if (v114)
            {
              LODWORD(length[0]) = 136446466;
              *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
              WORD2(length[1]) = 2082;
              *(size_t *)((char *)&length[1] + 6) = (size_t)v112;
              _os_log_impl(&dword_1830D4000, v110, v113, "%{public}s called with null (data_length > 0), dumping backtrace:%{public}s", (uint8_t *)length, 0x16u);
            }

            free(v112);
            goto LABEL_229;
          }
          if (v114)
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl(&dword_1830D4000, v110, v113, "%{public}s called with null (data_length > 0), no backtrace", (uint8_t *)length, 0xCu);
          }
        }
        else
        {
          uint64_t v110 = __nwlog_obj();
          os_log_type_t v115 = type;
          if (os_log_type_enabled(v110, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl(&dword_1830D4000, v110, v115, "%{public}s called with null (data_length > 0), backtrace limit exceeded", (uint8_t *)length, 0xCu);
          }
        }
      }
LABEL_229:
      if (v109) {
        free(v109);
      }
      goto LABEL_191;
    }
    uint64_t v34 = objc_alloc_init(NWConcrete_nw_path_override_info);
    if (!v34)
    {
      uint64_t v37 = 0;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v38 = (id)gLogObj;
      LODWORD(length[0]) = 136446210;
      *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
      os_log_type_t v197 = length;
      id v39 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(type) = 16;
      LOBYTE(v236) = 0;
      if (!__nwlog_fault(v39, &type, &v236)) {
        goto LABEL_176;
      }
      if (type == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v40 = (id)gLogObj;
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v40, (os_log_type_t)type))
        {
          LODWORD(length[0]) = 136446210;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed", (uint8_t *)length, 0xCu);
        }
      }
      else
      {
        if ((_BYTE)v236)
        {
          int32x4_t v83 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int32x4_t v84 = (id)gLogObj;
          os_log_type_t v85 = type;
          BOOL v86 = os_log_type_enabled(v84, (os_log_type_t)type);
          if (v83)
          {
            if (v86)
            {
              LODWORD(length[0]) = 136446466;
              *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
              WORD2(length[1]) = 2082;
              *(size_t *)((char *)&length[1] + 6) = (size_t)v83;
              _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, dumping backtrace:%{public}s", (uint8_t *)length, 0x16u);
            }

            free(v83);
            if (!v39) {
              goto LABEL_190;
            }
LABEL_177:
            free(v39);
            goto LABEL_190;
          }
          if (v86)
          {
            LODWORD(length[0]) = 136446210;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, no backtrace", (uint8_t *)length, 0xCu);
          }

LABEL_176:
          if (!v39) {
            goto LABEL_190;
          }
          goto LABEL_177;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v40 = (id)gLogObj;
        os_log_type_t v93 = type;
        if (os_log_type_enabled(v40, (os_log_type_t)type))
        {
          LODWORD(length[0]) = 136446210;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
          _os_log_impl(&dword_1830D4000, v40, v93, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) nw_path_override_info] init] failed, backtrace limit exceeded", (uint8_t *)length, 0xCu);
        }
      }

      goto LABEL_176;
    }
    if (v33 < 5)
    {
      uint64_t v35 = v34;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v36 = (id)gLogObj;
      if (os_log_type_enabled(v36, OS_LOG_TYPE_ERROR))
      {
        LODWORD(length[0]) = 136446722;
        *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
        WORD2(length[1]) = 2048;
        *(size_t *)((char *)&length[1] + 6) = v33;
        HIWORD(length[2]) = 2048;
        length[3] = 5;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_ERROR, "%{public}s invalid length for override info %zu != %zu", (uint8_t *)length, 0x20u);
      }

      uint64_t v37 = v35;
      goto LABEL_190;
    }
    __int16 v202 = v34;
    unint64_t v208 = v33;
    unint64_t v42 = v33 - 5;
    if (v33 == 5)
    {
LABEL_139:
      unsigned int v80 = v202;
      unint64_t override_flags = v202->override_flags;
      if (override_flags)
      {
        *((unsigned char *)v11 + 475) |= 0x40u;
        unint64_t override_flags = v202->override_flags;
        if ((override_flags & 2) == 0)
        {
LABEL_141:
          if ((override_flags & 4) == 0) {
            goto LABEL_142;
          }
          goto LABEL_154;
        }
      }
      else if ((override_flags & 2) == 0)
      {
        goto LABEL_141;
      }
      *((unsigned char *)v11 + 475) |= 0x80u;
      unint64_t override_flags = v202->override_flags;
      if ((override_flags & 4) == 0)
      {
LABEL_142:
        if ((override_flags & 0x10) == 0) {
          goto LABEL_143;
        }
        goto LABEL_155;
      }
LABEL_154:
      *((unsigned char *)v11 + 475) |= 8u;
      unint64_t override_flags = v202->override_flags;
      if ((override_flags & 0x10) == 0)
      {
LABEL_143:
        if ((override_flags & 8) == 0) {
          goto LABEL_144;
        }
        goto LABEL_156;
      }
LABEL_155:
      *((unsigned char *)v11 + 475) |= 0x20u;
      if ((v202->override_flags & 8) == 0)
      {
LABEL_144:
        resolver_configs = (atomic_uchar *)v202->resolver_configs;
        if (!resolver_configs) {
          goto LABEL_192;
        }
        goto LABEL_157;
      }
LABEL_156:
      *((unsigned char *)v11 + 475) |= 0x10u;
      resolver_configs = (atomic_uchar *)v202->resolver_configs;
      if (!resolver_configs) {
        goto LABEL_192;
      }
LABEL_157:
      if (!v11->override_resolver_configs)
      {
        BOOL v87 = nw_array_create();
        override_resolver_configs = v11->override_resolver_configs;
        v11->override_resolver_configs = (OS_nw_array *)v87;

        resolver_configs = (atomic_uchar *)v202->resolver_configs;
      }
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = ___ZL23nw_path_snapshot_agentsP18NWConcrete_nw_path_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E524AE18;
      *(void *)&unsigned char buf[32] = v11;
      nw_array_apply(resolver_configs, (uint64_t)buf);

      unsigned int v80 = v202;
      goto LABEL_192;
    }
    unint64_t v43 = 0;
    __int16 v200 = (unsigned int *)(v19 + 216);
    id v199 = (char *)(v19 + 221);
    __int16 v204 = (char *)(v19 + 217);
    unint64_t v205 = v33 - 1;
    *(void *)uint64_t v206 = v33 - 5;
    while (1)
    {
      if (v42 < v43)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v44 = (id)gLogObj;
        LODWORD(length[0]) = 136446722;
        *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
        WORD2(length[1]) = 2048;
        *(size_t *)((char *)&length[1] + 6) = v43;
        HIWORD(length[2]) = 2048;
        length[3] = v208;
        os_log_type_t v197 = length;
        uint64_t v45 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(type) = 16;
        LOBYTE(v236) = 0;
        if (__nwlog_fault(v45, &type, &v236))
        {
          if (type == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v46 = (id)gLogObj;
            os_log_type_t v47 = type;
            if (os_log_type_enabled(v46, (os_log_type_t)type))
            {
              LODWORD(length[0]) = 136446722;
              *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
              WORD2(length[1]) = 2048;
              *(size_t *)((char *)&length[1] + 6) = v43;
              HIWORD(length[2]) = 2048;
              length[3] = v208;
              _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu", (uint8_t *)length, 0x20u);
            }
          }
          else if ((_BYTE)v236)
          {
            unint64_t v53 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v46 = (id)gLogObj;
            os_log_type_t v54 = type;
            BOOL v55 = os_log_type_enabled(v46, (os_log_type_t)type);
            if (v53)
            {
              if (v55)
              {
                LODWORD(length[0]) = 136446978;
                *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
                WORD2(length[1]) = 2048;
                *(size_t *)((char *)&length[1] + 6) = v43;
                HIWORD(length[2]) = 2048;
                length[3] = v208;
                LOWORD(length[4]) = 2082;
                *(size_t *)((char *)&length[4] + 2) = (size_t)v53;
                _os_log_impl(&dword_1830D4000, v46, v54, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, dumping backtrace:%{public}s", (uint8_t *)length, 0x2Au);
              }

              free(v53);
              if (!v45) {
                goto LABEL_84;
              }
              goto LABEL_83;
            }
            if (v55)
            {
              LODWORD(length[0]) = 136446722;
              *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
              WORD2(length[1]) = 2048;
              *(size_t *)((char *)&length[1] + 6) = v43;
              HIWORD(length[2]) = 2048;
              length[3] = v208;
              _os_log_impl(&dword_1830D4000, v46, v54, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, no backtrace", (uint8_t *)length, 0x20u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v46 = (id)gLogObj;
            os_log_type_t v59 = type;
            if (os_log_type_enabled(v46, (os_log_type_t)type))
            {
              LODWORD(length[0]) = 136446722;
              *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
              WORD2(length[1]) = 2048;
              *(size_t *)((char *)&length[1] + 6) = v43;
              HIWORD(length[2]) = 2048;
              length[3] = v208;
              _os_log_impl(&dword_1830D4000, v46, v59, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, backtrace limit exceeded", (uint8_t *)length, 0x20u);
            }
          }
        }
        if (!v45)
        {
LABEL_84:
          int v52 = 0;
LABEL_105:
          unint64_t v61 = 0;
          BOOL v67 = 0;
          goto LABEL_122;
        }
LABEL_83:
        free(v45);
        goto LABEL_84;
      }
      if (v205 >= v43)
      {
        int v52 = *((unsigned __int8 *)v200 + v43);
        goto LABEL_94;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v48 = (id)gLogObj;
      LODWORD(length[0]) = 136446722;
      *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_type";
      WORD2(length[1]) = 2048;
      *(size_t *)((char *)&length[1] + 6) = v43;
      HIWORD(length[2]) = 2048;
      length[3] = v208;
      os_log_type_t v197 = length;
      uint64_t v49 = (void *)_os_log_send_and_compose_impl();

      LOBYTE(type) = 16;
      LOBYTE(v236) = 0;
      if (__nwlog_fault((const char *)v49, &type, &v236))
      {
        if (type == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v50 = (id)gLogObj;
          os_log_type_t v51 = type;
          if (os_log_type_enabled(v50, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446722;
            *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_type";
            WORD2(length[1]) = 2048;
            *(size_t *)((char *)&length[1] + 6) = v43;
            HIWORD(length[2]) = 2048;
            length[3] = v208;
            _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu", (uint8_t *)length, 0x20u);
          }
        }
        else if ((_BYTE)v236)
        {
          uint64_t v56 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v50 = (id)gLogObj;
          os_log_type_t v57 = type;
          BOOL v58 = os_log_type_enabled(v50, (os_log_type_t)type);
          if (v56)
          {
            if (v58)
            {
              LODWORD(length[0]) = 136446978;
              *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_type";
              WORD2(length[1]) = 2048;
              *(size_t *)((char *)&length[1] + 6) = v43;
              HIWORD(length[2]) = 2048;
              length[3] = v208;
              LOWORD(length[4]) = 2082;
              *(size_t *)((char *)&length[4] + 2) = (size_t)v56;
              _os_log_impl(&dword_1830D4000, v50, v57, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, dumping backtrace:%{public}s", (uint8_t *)length, 0x2Au);
            }

            free(v56);
            if (!v49) {
              goto LABEL_93;
            }
LABEL_92:
            free(v49);
            goto LABEL_93;
          }
          if (v58)
          {
            LODWORD(length[0]) = 136446722;
            *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_type";
            WORD2(length[1]) = 2048;
            *(size_t *)((char *)&length[1] + 6) = v43;
            HIWORD(length[2]) = 2048;
            length[3] = v208;
            _os_log_impl(&dword_1830D4000, v50, v57, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, no backtrace", (uint8_t *)length, 0x20u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v50 = (id)gLogObj;
          os_log_type_t v60 = type;
          if (os_log_type_enabled(v50, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446722;
            *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_type";
            WORD2(length[1]) = 2048;
            *(size_t *)((char *)&length[1] + 6) = v43;
            HIWORD(length[2]) = 2048;
            length[3] = v208;
            _os_log_impl(&dword_1830D4000, v50, v60, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu, backtrace limit exceeded", (uint8_t *)length, 0x20u);
          }
        }
      }
      if (v49) {
        goto LABEL_92;
      }
LABEL_93:
      int v52 = 0;
LABEL_94:
      unint64_t v61 = *(unsigned int *)&v204[v43];
      if (!v61) {
        goto LABEL_105;
      }
      if (v61 <= 0xFFFFFFF9 && v208 >= v61 + 5 && v208 - (v61 + 5) >= v43)
      {
        BOOL v67 = (const UInt8 *)&v199[v43];
        goto LABEL_122;
      }
      int v201 = v52;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v63 = (id)gLogObj;
      LODWORD(length[0]) = 136446978;
      *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
      WORD2(length[1]) = 2048;
      *(size_t *)((char *)&length[1] + 6) = v43;
      HIWORD(length[2]) = 2048;
      length[3] = v208;
      LOWORD(length[4]) = 1024;
      *(_DWORD *)((char *)&length[4] + 2) = v61;
      os_log_type_t v197 = length;
      uint64_t v64 = (void *)_os_log_send_and_compose_impl();

      LOBYTE(type) = 16;
      LOBYTE(v236) = 0;
      if (__nwlog_fault((const char *)v64, &type, &v236))
      {
        if (type == 17)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v65 = (id)gLogObj;
          os_log_type_t v66 = type;
          if (os_log_type_enabled(v65, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446978;
            *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
            WORD2(length[1]) = 2048;
            *(size_t *)((char *)&length[1] + 6) = v43;
            HIWORD(length[2]) = 2048;
            length[3] = v208;
            LOWORD(length[4]) = 1024;
            *(_DWORD *)((char *)&length[4] + 2) = v61;
            _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u", (uint8_t *)length, 0x26u);
          }
        }
        else if ((_BYTE)v236)
        {
          uint64_t v68 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v65 = (id)gLogObj;
          os_log_type_t v198 = type;
          BOOL v69 = os_log_type_enabled(v65, (os_log_type_t)type);
          if (v68)
          {
            if (v69)
            {
              LODWORD(length[0]) = 136447234;
              *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
              WORD2(length[1]) = 2048;
              *(size_t *)((char *)&length[1] + 6) = v43;
              HIWORD(length[2]) = 2048;
              length[3] = v208;
              LOWORD(length[4]) = 1024;
              *(_DWORD *)((char *)&length[4] + 2) = v61;
              HIWORD(length[4]) = 2082;
              length[5] = (size_t)v68;
              _os_log_impl(&dword_1830D4000, v65, v198, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, dumping backtrace:%{public}s", (uint8_t *)length, 0x30u);
            }

            free(v68);
            if (!v64) {
              goto LABEL_121;
            }
LABEL_120:
            free(v64);
            goto LABEL_121;
          }
          if (v69)
          {
            LODWORD(length[0]) = 136446978;
            *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
            WORD2(length[1]) = 2048;
            *(size_t *)((char *)&length[1] + 6) = v43;
            HIWORD(length[2]) = 2048;
            length[3] = v208;
            LOWORD(length[4]) = 1024;
            *(_DWORD *)((char *)&length[4] + 2) = v61;
            _os_log_impl(&dword_1830D4000, v65, v198, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, no backtrace", (uint8_t *)length, 0x26u);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v65 = (id)gLogObj;
          os_log_type_t v70 = type;
          if (os_log_type_enabled(v65, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136446978;
            *(size_t *)((char *)length + 4) = (size_t)"nw_necp_buffer_get_tlv_value";
            WORD2(length[1]) = 2048;
            *(size_t *)((char *)&length[1] + 6) = v43;
            HIWORD(length[2]) = 2048;
            length[3] = v208;
            LOWORD(length[4]) = 1024;
            *(_DWORD *)((char *)&length[4] + 2) = v61;
            _os_log_impl(&dword_1830D4000, v65, v70, "%{public}s buffer too short tlv_offset=%zu buffer_length=%zu value_length=%u, backtrace limit exceeded", (uint8_t *)length, 0x26u);
          }
        }
      }
      if (v64) {
        goto LABEL_120;
      }
LABEL_121:
      BOOL v67 = 0;
      int v52 = v201;
LABEL_122:
      v43 += v61 + 5;
      if (v43 > v208) {
        break;
      }
      if (v61 && v67)
      {
        if (v52 == 2)
        {
          CFDataRef v71 = CFDataCreate(allocator, v67, v61);
          if (v71)
          {
            CFPropertyListRef v72 = CFPropertyListCreateWithData(allocator, v71, 0, 0, 0);
            if (v72)
            {
              int64_t v73 = (void *)_CFXPCCreateXPCObjectFromCFObject();
              os_log_type_t v74 = v73;
              if (v73)
              {
                unint64_t v75 = nw_resolver_config_create_with_dictionary(v73);
                uint64_t v76 = (uint64_t)v202->resolver_configs;
                if (!v76)
                {
                  BOOL v77 = nw_array_create();
                  uint64_t v78 = v202->resolver_configs;
                  v202->resolver_configs = (OS_nw_array *)v77;

                  uint64_t v76 = (uint64_t)v202->resolver_configs;
                }
                nw_array_append(v76, v75);
              }
              CFRelease(v72);
            }
            CFRelease(v71);
          }
        }
        else if (v52 == 1)
        {
          if (v61 != 8)
          {
            uint64_t v98 = __nwlog_obj();
            if (os_log_type_enabled(v98, OS_LOG_TYPE_ERROR))
            {
              LODWORD(length[0]) = 136446722;
              *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
              WORD2(length[1]) = 1024;
              *(_DWORD *)((char *)&length[1] + 6) = v61;
              WORD1(length[2]) = 2048;
              *(size_t *)((char *)&length[2] + 4) = 8;
              _os_log_impl(&dword_1830D4000, v98, OS_LOG_TYPE_ERROR, "%{public}s received invalid size for flags (%d != %zu)", (uint8_t *)length, 0x1Cu);
            }

            goto LABEL_189;
          }
          v202->unint64_t override_flags = *(void *)v67;
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v79 = (id)gLogObj;
          if (os_log_type_enabled(v79, OS_LOG_TYPE_ERROR))
          {
            LODWORD(length[0]) = 136446466;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            WORD2(length[1]) = 1024;
            *(_DWORD *)((char *)&length[1] + 6) = v52;
            _os_log_impl(&dword_1830D4000, v79, OS_LOG_TYPE_ERROR, "%{public}s received unknown TLV (type %d)", (uint8_t *)length, 0x12u);
          }
        }
      }
      unint64_t v42 = *(void *)v206;
      if (v43 >= *(void *)v206) {
        goto LABEL_139;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v89 = (id)gLogObj;
    LODWORD(length[0]) = 136446978;
    *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
    WORD2(length[1]) = 1024;
    *(_DWORD *)((char *)&length[1] + 6) = v61;
    WORD1(length[2]) = 2048;
    *(size_t *)((char *)&length[2] + 4) = v43;
    WORD2(length[3]) = 2048;
    *(size_t *)((char *)&length[3] + 6) = v208;
    os_log_type_t v197 = length;
    char v90 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(type) = 16;
    LOBYTE(v236) = 0;
    if (__nwlog_fault(v90, &type, &v236))
    {
      if (type == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v91 = (id)gLogObj;
        os_log_type_t v92 = type;
        if (os_log_type_enabled(v91, (os_log_type_t)type))
        {
          LODWORD(length[0]) = 136446978;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
          WORD2(length[1]) = 1024;
          *(_DWORD *)((char *)&length[1] + 6) = v61;
          WORD1(length[2]) = 2048;
          *(size_t *)((char *)&length[2] + 4) = v43;
          WORD2(length[3]) = 2048;
          *(size_t *)((char *)&length[3] + 6) = v208;
          _os_log_impl(&dword_1830D4000, v91, v92, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu)", (uint8_t *)length, 0x26u);
        }
        goto LABEL_186;
      }
      if ((_BYTE)v236)
      {
        uint64_t v94 = __nw_create_backtrace_string();
        if (v94)
        {
          uint64_t v95 = (char *)v94;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          size_t v96 = (id)gLogObj;
          os_log_type_t v207 = type;
          if (os_log_type_enabled(v96, (os_log_type_t)type))
          {
            LODWORD(length[0]) = 136447234;
            *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
            WORD2(length[1]) = 1024;
            *(_DWORD *)((char *)&length[1] + 6) = v61;
            WORD1(length[2]) = 2048;
            *(size_t *)((char *)&length[2] + 4) = v43;
            WORD2(length[3]) = 2048;
            *(size_t *)((char *)&length[3] + 6) = v208;
            HIWORD(length[4]) = 2082;
            length[5] = (size_t)v95;
            _os_log_impl(&dword_1830D4000, v96, v207, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), dumping backtrace:%{public}s", (uint8_t *)length, 0x30u);
          }

          free(v95);
          goto LABEL_187;
        }
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v99 = type;
        if (os_log_type_enabled(v91, (os_log_type_t)type))
        {
          LODWORD(length[0]) = 136446978;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
          WORD2(length[1]) = 1024;
          *(_DWORD *)((char *)&length[1] + 6) = v61;
          WORD1(length[2]) = 2048;
          *(size_t *)((char *)&length[2] + 4) = v43;
          WORD2(length[3]) = 2048;
          *(size_t *)((char *)&length[3] + 6) = v208;
          _os_log_impl(&dword_1830D4000, v91, v99, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), no backtrace", (uint8_t *)length, 0x26u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v91 = (id)gLogObj;
        os_log_type_t v97 = type;
        if (os_log_type_enabled(v91, (os_log_type_t)type))
        {
          LODWORD(length[0]) = 136446978;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_override_info_create_from_data";
          WORD2(length[1]) = 1024;
          *(_DWORD *)((char *)&length[1] + 6) = v61;
          WORD1(length[2]) = 2048;
          *(size_t *)((char *)&length[2] + 4) = v43;
          WORD2(length[3]) = 2048;
          *(size_t *)((char *)&length[3] + 6) = v208;
          _os_log_impl(&dword_1830D4000, v91, v97, "%{public}s TLV length (%u) at offset %zu goes beyond total length (%zu), backtrace limit exceeded", (uint8_t *)length, 0x26u);
        }
      }
LABEL_186:
    }
LABEL_187:
    if (v90) {
      free(v90);
    }
LABEL_189:
    uint64_t v37 = v202;
LABEL_190:

LABEL_191:
    unsigned int v80 = 0;
LABEL_192:

LABEL_193:
    ++v15;
  }
  while (v15 < v11->policy_result.num_netagents);
LABEL_231:

  BOOL v116 = v11;
  flows = (atomic_uchar *)v116->flows;
  length[0] = MEMORY[0x1E4F143A8];
  length[1] = 3221225472;
  size_t length[2] = (size_t)___ZL22nw_path_snapshot_flowsP18NWConcrete_nw_path_block_invoke;
  length[3] = (size_t)&unk_1E524AE18;
  unsigned int v118 = v116;
  length[4] = (size_t)v118;
  nw_array_apply(flows, (uint64_t)length);

  int v119 = v118;
  uint64_t v120 = v119;
  if ((*((unsigned char *)v119 + 473) & 0x30) != 0
    || nw_parameters_get_required_interface_index(v119[2])
    || nw_parameters_get_multipath(v120[2]) && nw_parameters_multipath_fallback_allowed(v120[2]))
  {
    goto LABEL_351;
  }
  __int16 v121 = v11->network_agent_dictionary;
  if (!v121) {
    goto LABEL_351;
  }
  *(void *)uuid_string_t out = 0;
  *(void *)&out[8] = out;
  *(_DWORD *)&out[24] = 0;
  *(void *)&out[16] = 0x2020000000;
  id v244 = 0;
  int v245 = &v244;
  uint64_t v246 = 0x2020000000;
  char v247 = 0;
  uint64_t type = 0;
  p_uint64_t type = &type;
  uint64_t v242 = 0x2020000000;
  char v243 = 0;
  uint64_t v236 = 0;
  __int16 v237 = &v236;
  uint64_t v238 = 0x2020000000;
  char v239 = 0;
  uint64_t v232 = 0;
  BOOL v233 = &v232;
  uint64_t v234 = 0x2020000000;
  char v235 = 0;
  uint64_t v228 = 0;
  uint64_t v229 = &v228;
  uint64_t v230 = 0x2020000000;
  char v231 = 0;
  uint64_t v224 = 0;
  id v225 = &v224;
  uint64_t v226 = 0x2020000000;
  uint64_t v227 = 0;
  uint64_t v220 = 0;
  id v221 = &v220;
  uint64_t v222 = 0x2020000000;
  uint64_t v223 = 0;
  uint64_t v216 = 0;
  v217 = &v216;
  uint64_t v218 = 0x2020000000;
  uint64_t v219 = 0;
  uint64_t v212 = 0;
  id v213 = &v212;
  int v215 = 0;
  uint64_t v214 = 0x2020000000;
  length[0] = MEMORY[0x1E4F143A8];
  length[1] = 3221225472;
  size_t length[2] = (size_t)___ZL25nw_path_snapshot_fallbackP18NWConcrete_nw_path_block_invoke;
  length[3] = (size_t)&unk_1E52482D0;
  length[5] = (size_t)&v228;
  nw_endpoint_t v209 = v120;
  length[4] = (size_t)v209;
  length[6] = (size_t)&v244;
  length[7] = (size_t)&type;
  length[8] = (size_t)&v236;
  length[9] = (size_t)&v232;
  length[10] = (size_t)out;
  length[11] = (size_t)&v224;
  length[12] = (size_t)&v220;
  length[13] = (size_t)&v216;
  length[14] = (size_t)&v212;
  xpc_dictionary_apply(v121, length);
  if (!*((unsigned char *)v229 + 24)) {
    goto LABEL_348;
  }
  *((_DWORD *)v209 + 93) = *((_DWORD *)v213 + 6);
  unsigned int v122 = *(_DWORD *)(*(void *)&out[8] + 24);
  if (!v122)
  {
    int64x2_t v130 = v209[14];
    v209[14] = 0;
    goto LABEL_275;
  }
  unsigned int v123 = nw_interface_create_with_index(v122);
  p_super = &v123->super;
  if (!v123)
  {
    BOOL v125 = __nwlog_obj();
    if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
    {
      int v131 = *(_DWORD *)(*(void *)&out[8] + 24);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v131;
      _os_log_impl(&dword_1830D4000, v125, OS_LOG_TYPE_INFO, "%{public}s Unable to create fallback interface using index %d", buf, 0x12u);
    }
    goto LABEL_258;
  }
  if (nw_interface_is_expensive(v123) && nw_parameters_get_prohibit_expensive((nw_parameters_t)v120[2]))
  {
    BOOL v125 = __nwlog_obj();
    if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = p_super;
      _os_log_impl(&dword_1830D4000, v125, OS_LOG_TYPE_INFO, "%{public}s Fallback to expensive interface %{public}@ prohibited by parameters", buf, 0x16u);
    }
    goto LABEL_258;
  }
  if (nw_interface_is_constrained(p_super)
    && nw_parameters_get_prohibit_constrained((nw_parameters_t)v120[2]))
  {
    BOOL v125 = __nwlog_obj();
    if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = p_super;
      _os_log_impl(&dword_1830D4000, v125, OS_LOG_TYPE_INFO, "%{public}s Fallback to constrained interface %{public}@ prohibited by parameters", buf, 0x16u);
    }
    goto LABEL_258;
  }
  if (nw_interface_is_ultra_constrained(p_super)
    && (nw_parameters_get_allow_ultra_constrained(v120[2]) & 1) == 0)
  {
    if (nw_path_is_ultra_constrained_allowed(void)::onceToken != -1) {
      dispatch_once(&nw_path_is_ultra_constrained_allowed(void)::onceToken, &__block_literal_global_491);
    }
    if ((nw_path_is_ultra_constrained_allowed(void)::is_allowed & 1) == 0)
    {
      BOOL v125 = __nwlog_obj();
      if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
        *(_WORD *)&unsigned char buf[12] = 2114;
        *(void *)&buf[14] = p_super;
        _os_log_impl(&dword_1830D4000, v125, OS_LOG_TYPE_INFO, "%{public}s Fallback to ultra constrained interface %{public}@ not allowed by parameters", buf, 0x16u);
      }
      goto LABEL_258;
    }
  }
  if (nw_interface_get_type(p_super) == nw_interface_type_cellular
    && (nw_parameters_get_prohibit_cellular(v120[2])
     || !*((unsigned char *)v233 + 24)
     && !*((unsigned char *)v237 + 24)
     && nw_parameters_get_no_cellular_fallback(v120[2])))
  {
    BOOL v125 = __nwlog_obj();
    if (os_log_type_enabled(v125, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = p_super;
      _os_log_impl(&dword_1830D4000, v125, OS_LOG_TYPE_INFO, "%{public}s Fallback to cellular interface %{public}@ prohibited by parameters", buf, 0x16u);
    }
LABEL_258:

    int64x2_t v132 = (void *)v217[3];
    if (v132)
    {
      free(v132);
      v217[3] = 0;
    }

    goto LABEL_350;
  }
  int64x2_t v130 = v209[14];
  v209[14] = p_super;
LABEL_275:

  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int64x2_t v133 = (id)gLogObj;
  if (os_log_type_enabled(v133, OS_LOG_TYPE_DEBUG))
  {
    int v134 = *((_DWORD *)v209 + 93);
    uint32x4_t v135 = v209[14];
    unsigned int v136 = "";
    if (*((unsigned char *)v245 + 24)) {
      BOOL v137 = ", weak";
    }
    else {
      BOOL v137 = "";
    }
    if (*((unsigned char *)v237 + 24)) {
      nw_endpoint_t v138 = ", forced";
    }
    else {
      nw_endpoint_t v138 = "";
    }
    if (*((unsigned char *)v233 + 24)) {
      unsigned int v136 = ", preferred";
    }
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v134;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = v135;
    *(_WORD *)&unsigned char buf[28] = 2082;
    *(void *)&buf[30] = v137;
    *(_WORD *)&buf[38] = 2082;
    *(void *)&buf[40] = v138;
    __int16 v250 = 2082;
    nw_endpoint_t v251 = v136;
    _os_log_impl(&dword_1830D4000, v133, OS_LOG_TYPE_DEBUG, "%{public}s Fallback generation %u index %@%{public}s%{public}s%{public}s", buf, 0x3Au);
  }

  __int16 v139 = (const unsigned __int8 *)v217[3];
  if (v139 && !uuid_is_null(v139)) {
    *(_OWORD *)(v209 + 19) = *(_OWORD *)v217[3];
  }
  v140 = (const char *)v225[3];
  if (v140 && v221[3])
  {
    int v141 = v209[21];
    id v142 = v209[22];
    if (!v141)
    {
      if (v142) {
        goto LABEL_294;
      }
      goto LABEL_345;
    }
    if (!v142)
    {
LABEL_294:
      v143 = __nwlog_obj();
      uint64_t v144 = v209[22];
      if (v209[21]) {
        uint64_t v145 = "non";
      }
      else {
        uint64_t v145 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
      *(_WORD *)&unsigned char buf[12] = 2082;
      if (v144) {
        __int16 v146 = "non";
      }
      else {
        __int16 v146 = "";
      }
      *(void *)&buf[14] = v145;
      *(_WORD *)&unsigned char buf[22] = 2082;
      *(void *)&unsigned char buf[24] = v146;
      os_log_type_t v197 = (size_t *)buf;
      char v147 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t v211 = OS_LOG_TYPE_ERROR;
      char v210 = 0;
      if (!__nwlog_fault(v147, &v211, &v210)) {
        goto LABEL_343;
      }
      if (v211 == OS_LOG_TYPE_FAULT)
      {
        unsigned int v148 = __nwlog_obj();
        os_log_type_t v149 = v211;
        if (os_log_type_enabled(v148, v211))
        {
          if (v209[21]) {
            __int16 v150 = "non";
          }
          else {
            __int16 v150 = "";
          }
          if (v209[22]) {
            uint64_t v151 = "non";
          }
          else {
            uint64_t v151 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v150;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)&unsigned char buf[24] = v151;
          _os_log_impl(&dword_1830D4000, v148, v149, "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull)", buf, 0x20u);
        }
        goto LABEL_342;
      }
      if (v210)
      {
        __int16 v152 = (char *)__nw_create_backtrace_string();
        unsigned int v148 = __nwlog_obj();
        os_log_type_t v153 = v211;
        BOOL v154 = os_log_type_enabled(v148, v211);
        if (v152)
        {
          if (v154)
          {
            if (v209[21]) {
              os_log_type_t v155 = "non";
            }
            else {
              os_log_type_t v155 = "";
            }
            if (v209[22]) {
              __int16 v156 = "non";
            }
            else {
              __int16 v156 = "";
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v155;
            *(_WORD *)&unsigned char buf[22] = 2082;
            *(void *)&unsigned char buf[24] = v156;
            *(_WORD *)&unsigned char buf[32] = 2082;
            *(void *)&buf[34] = v152;
            _os_log_impl(&dword_1830D4000, v148, v153, "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull), dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v152);
LABEL_343:
          if (v147) {
            free(v147);
          }
LABEL_345:
          xpc_object_t v162 = xpc_array_create(0, 0);
          v163 = v209[21];
          v209[21] = v162;

          xpc_object_t v164 = xpc_array_create(0, 0);
          v165 = v209[22];
          v209[22] = v164;

          int v141 = v209[21];
          v140 = (const char *)v225[3];
          goto LABEL_346;
        }
        if (v154)
        {
          if (v209[21]) {
            nw_endpoint_t v160 = "non";
          }
          else {
            nw_endpoint_t v160 = "";
          }
          if (v209[22]) {
            v161 = "non";
          }
          else {
            v161 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v160;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)&unsigned char buf[24] = v161;
          _os_log_impl(&dword_1830D4000, v148, v153, "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull), no backtrace", buf, 0x20u);
        }
      }
      else
      {
        unsigned int v148 = __nwlog_obj();
        os_log_type_t v157 = v211;
        if (os_log_type_enabled(v148, v211))
        {
          if (v209[21]) {
            uint64_t v158 = "non";
          }
          else {
            uint64_t v158 = "";
          }
          if (v209[22]) {
            v159 = "non";
          }
          else {
            v159 = "";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_path_snapshot_fallback";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v158;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)&unsigned char buf[24] = v159;
          _os_log_impl(&dword_1830D4000, v148, v157, "%{public}s Fallback agents are in unexpected state (domains %{public}snull, types %{public}snull), backtrace limit exceeded", buf, 0x20u);
        }
      }
LABEL_342:

      goto LABEL_343;
    }
LABEL_346:
    xpc_array_set_string(v141, 0xFFFFFFFFFFFFFFFFLL, v140);
    xpc_array_set_string(v209[22], 0xFFFFFFFFFFFFFFFFLL, (const char *)v221[3]);
  }
  char v166 = *((unsigned char *)v120 + 473) & 0xFE | *((unsigned char *)v245 + 24);
  *((unsigned char *)v120 + 473) = v166;
  char v167 = v166 & 0xFD | (2 * *((unsigned char *)p_type + 24));
  *((unsigned char *)v120 + 473) = v167;
  char v168 = v167 & 0xFB | (4 * *((unsigned char *)v237 + 24));
  *((unsigned char *)v120 + 473) = v168;
  *((unsigned char *)v120 + 473) = v168 & 0xF7 | (8 * *((unsigned char *)v233 + 24));
LABEL_348:
  int v169 = (void *)v217[3];
  if (v169)
  {
    free(v169);
    v217[3] = 0;
  }
LABEL_350:

  _Block_object_dispose(&v212, 8);
  _Block_object_dispose(&v216, 8);
  _Block_object_dispose(&v220, 8);
  _Block_object_dispose(&v224, 8);
  _Block_object_dispose(&v228, 8);
  _Block_object_dispose(&v232, 8);
  _Block_object_dispose(&v236, 8);
  _Block_object_dispose(&type, 8);
  _Block_object_dispose(&v244, 8);
  _Block_object_dispose(out, 8);
LABEL_351:

  char v170 = v120;
  if (nw_path_endpoint_is_always_satisfied(v170->endpoint))
  {
    int v176 = 0;
    os_log_type_t v177 = "Endpoint is always satisfied";
    int v178 = 1;
    goto LABEL_358;
  }
  if (nw_parameters_are_valid(v170->parameters))
  {
    if (nw_path_network_is_satisfied_update_reason(v170, 1))
    {
      LOBYTE(length[0]) = 0;
      if (nw_path_agents_are_satisfied_update_reason(v170, 1, 0, 0, (BOOL *)length))
      {
        v170->status = 1;
        nw_path_set_reason(v170, 0, "Path is satisfied", v179, v180, v181, v182, v183, (char)v197);
        goto LABEL_359;
      }
      BOOL v196 = LOBYTE(length[0]) == 0;
LABEL_381:
      if (v196) {
        int v195 = 2;
      }
      else {
        int v195 = 3;
      }
    }
    else
    {
      LOBYTE(length[0]) = 0;
      if (v170->reason == 3)
      {
        BOOL updated = nw_path_agents_are_satisfied_update_reason(v170, 1, 1, 1, (BOOL *)length);
        int v195 = 2;
        if (!updated)
        {
          BOOL v196 = LOBYTE(length[0]) == 0;
          goto LABEL_381;
        }
      }
      else
      {
        int v195 = 2;
      }
    }
    v170->status = v195;
  }
  else
  {
    int v178 = 0;
    os_log_type_t v177 = "Parameters are invalid";
    int v176 = 14;
LABEL_358:
    v170->status = v178;
    nw_path_set_reason(v170, v176, v177, v171, v172, v173, v174, v175, (char)v197);
  }
LABEL_359:

  uint64_t v184 = v170;
  int v185 = v184;
  if (v184->policy_result.routing_result == 4)
  {
    BOOL v186 = v184->policy_result.routing_result_parameter.tunnel_interface_index == 0xFFFFFFF;

    if (v186)
    {
      buf[0] = 0;
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
      }
      id v187 = (id)nw_context_copy_implicit_context::implicit_context;
      int bridged_flow_director = nw_path_create_bridged_flow_director(v187, buf);

      if (buf[0]) {
        int v189 = bridged_flow_director;
      }
      else {
        int v189 = 0;
      }
      if (v189 == 1)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v190 = (id)gLogObj;
        if (os_log_type_enabled(v190, OS_LOG_TYPE_DEFAULT))
        {
          LODWORD(length[0]) = 136446210;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_snapshot_path";
          int v191 = "%{public}s In-process flow divert director created due to path result";
          uint64_t v192 = v190;
          os_log_type_t v193 = OS_LOG_TYPE_DEFAULT;
          goto LABEL_376;
        }
        goto LABEL_377;
      }
      if ((bridged_flow_director & 1) == 0)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v190 = (id)gLogObj;
        if (os_log_type_enabled(v190, OS_LOG_TYPE_ERROR))
        {
          LODWORD(length[0]) = 136446210;
          *(size_t *)((char *)length + 4) = (size_t)"nw_path_snapshot_path";
          int v191 = "%{public}s Failed to create in-process flow divert director due to path result";
          uint64_t v192 = v190;
          os_log_type_t v193 = OS_LOG_TYPE_ERROR;
LABEL_376:
          _os_log_impl(&dword_1830D4000, v192, v193, v191, (uint8_t *)length, 0xCu);
        }
LABEL_377:
      }
    }
  }
  else
  {
  }
}

void sub_18313BCE0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,void *a29,uint64_t a30,uint64_t a31,uint64_t a32,void *a33,uint64_t a34,char a35,uint64_t a36,uint64_t a37,uint64_t a38,char a39,uint64_t a40,uint64_t a41,uint64_t a42,char a43,uint64_t a44,uint64_t a45,uint64_t a46,char a47,uint64_t a48,uint64_t a49,uint64_t a50,char a51,uint64_t a52,uint64_t a53,uint64_t a54,char a55,uint64_t a56,uint64_t a57,uint64_t a58,char a59,uint64_t a60,uint64_t a61,uint64_t a62,char a63)
{
  _Block_object_dispose(&a35, 8);
  _Block_object_dispose(&a39, 8);
  _Block_object_dispose(&a43, 8);
  _Block_object_dispose(&a47, 8);
  _Block_object_dispose(&a51, 8);
  _Block_object_dispose(&a55, 8);
  _Block_object_dispose(&a59, 8);
  _Block_object_dispose(&a63, 8);
  _Block_object_dispose(&a67, 8);
  _Block_object_dispose(&a71, 8);

  _Unwind_Resume(a1);
}

id nw_parameters_copy_context(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = *(id *)(*((void *)v1 + 13) + 136);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v16 = "nw_parameters_copy_context";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v16 = "nw_parameters_copy_context";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_parameters_copy_context";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_required_interface_index(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_get_required_interface_index";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_get_required_interface_index";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_get_required_interface_index";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 168);
  if (!v3)
  {
LABEL_22:
    uint64_t v4 = 0;
    goto LABEL_23;
  }
  uint64_t v4 = *(unsigned int *)(v3 + 8);
LABEL_23:

  return v4;
}

BOOL nw_path_endpoint_is_always_satisfied(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    goto LABEL_29;
  }
  uint64_t v3 = v1;
  int v4 = [v3 type];

  if (v4 != 1) {
    goto LABEL_29;
  }
  address = nw_endpoint_get_address(v3);
  if (!address)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_path_endpoint_is_always_satisfied";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v10, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_path_endpoint_is_always_satisfied";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s nw_endpoint_get_address failed", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          char v14 = (char *)backtrace_string;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unint64_t v15 = (id)gLogObj;
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v23 = "nw_path_endpoint_is_always_satisfied";
            __int16 v24 = 2082;
            id v25 = v14;
            _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s nw_endpoint_get_address failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v14);
          if (!v10) {
            goto LABEL_29;
          }
          goto LABEL_28;
        }
        BOOL v11 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_path_endpoint_is_always_satisfied";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s nw_endpoint_get_address failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v11 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_path_endpoint_is_always_satisfied";
          _os_log_impl(&dword_1830D4000, v11, v17, "%{public}s nw_endpoint_get_address failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v10)
    {
LABEL_29:
      BOOL v8 = 0;
      goto LABEL_30;
    }
LABEL_28:
    free(v10);
    goto LABEL_29;
  }
  int sa_family = address->sa_family;
  BOOL v8 = sa_family != 2 && sa_family != 30;
LABEL_30:

  return v8;
}

void sub_18313C71C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_are_valid(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1) {
    goto LABEL_2;
  }
  uint64_t v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v14 = "nw_parameters_are_valid";
  int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          char v14 = "nw_parameters_are_valid";
          __int16 v15 = 2082;
          os_log_type_t v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        char v14 = "nw_parameters_are_valid";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_19:
  if (v4) {
    free(v4);
  }
LABEL_2:

  return v1 != 0;
}

void nw_path_set_reason(void *a1, int a2, const char *a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, char a9)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  char v11 = a1;
  os_log_type_t v12 = v11;
  if (!v11)
  {
    uint64_t v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v40 = "nw_path_set_reason";
    BOOL v27 = (char *)_os_log_send_and_compose_impl();

    v35[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v27, v35, &type))
    {
      if (v35[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = v35[0];
        if (os_log_type_enabled(v28, v35[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v40 = "nw_path_set_reason";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v31 = v35[0];
        BOOL v32 = os_log_type_enabled(v28, v35[0]);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v40 = "nw_path_set_reason";
            __int16 v41 = 2082;
            unint64_t v42 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_51;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v40 = "nw_path_set_reason";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v33 = v35[0];
        if (os_log_type_enabled(v28, v35[0]))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v40 = "nw_path_set_reason";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_51:
    if (v27) {
      free(v27);
    }
    goto LABEL_22;
  }
  if (!a2 || (int v13 = *((_DWORD *)v11 + 95), (v13 - 27) >= 4) && (!v13 || (a2 - 27) <= 3))
  {
    __int16 v15 = v11 + 31;
    char v14 = v11[31];
    *((_DWORD *)v12 + 95) = a2;
    if (v14)
    {
      free(v14);
      NSObject *v15 = 0;
    }
    v36[0] = MEMORY[0x1E4F143A8];
    v36[1] = 3221225472;
    v36[2] = __nw_path_set_reason_block_invoke;
    v36[3] = &unk_1E524BAA8;
    uint64_t v37 = v12;
    os_unfair_lock_lock((os_unfair_lock_t)v12 + 3);
    __nw_path_set_reason_block_invoke((uint64_t)v36);
    os_unfair_lock_unlock((os_unfair_lock_t)v12 + 3);
    if (!a3) {
      goto LABEL_21;
    }
    *(void *)uint64_t v35 = &a9;
    int v16 = vasprintf((char **)v12 + 31, a3, &a9);
    uint64_t v17 = *v15;
    if (v16 < 0)
    {
      if (v17)
      {
        free(v17);
        NSObject *v15 = 0;
      }
    }
    else if (v17)
    {
      goto LABEL_21;
    }
    NSObject *v15 = 0;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446722;
    uint64_t v40 = "nw_path_set_reason";
    __int16 v41 = 2082;
    unint64_t v42 = (void *)a3;
    __int16 v43 = 1024;
    int v44 = v16;
    uint64_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (__nwlog_fault(v19, &type, &v34))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v20 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v40 = "nw_path_set_reason";
          __int16 v41 = 2082;
          unint64_t v42 = (void *)a3;
          __int16 v43 = 1024;
          int v44 = v16;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s vasprintf(\"%{public}s\") returned %d failed", buf, 0x1Cu);
        }
      }
      else if (v34)
      {
        uint64_t v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v20 = (id)gLogObj;
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v20, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)buf = 136446978;
            uint64_t v40 = "nw_path_set_reason";
            __int16 v41 = 2082;
            unint64_t v42 = (void *)a3;
            __int16 v43 = 1024;
            int v44 = v16;
            __int16 v45 = 2082;
            uint64_t v46 = v22;
            _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s vasprintf(\"%{public}s\") returned %d failed, dumping backtrace:%{public}s", buf, 0x26u);
          }

          free(v22);
          if (!v19) {
            goto LABEL_21;
          }
          goto LABEL_20;
        }
        if (v24)
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v40 = "nw_path_set_reason";
          __int16 v41 = 2082;
          unint64_t v42 = (void *)a3;
          __int16 v43 = 1024;
          int v44 = v16;
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s vasprintf(\"%{public}s\") returned %d failed, no backtrace", buf, 0x1Cu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v20 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446722;
          uint64_t v40 = "nw_path_set_reason";
          __int16 v41 = 2082;
          unint64_t v42 = (void *)a3;
          __int16 v43 = 1024;
          int v44 = v16;
          _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s vasprintf(\"%{public}s\") returned %d failed, backtrace limit exceeded", buf, 0x1Cu);
        }
      }
    }
    if (v19) {
LABEL_20:
    }
      free(v19);
LABEL_21:
  }
LABEL_22:
}

void sub_18313D050(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

void __nw_path_set_reason_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  uint64_t v2 = *(void **)(v1 + 256);
  *(void *)(v1 + 256) = 0;
}

uint64_t type metadata accessor for NWPathMonitor.LockedState(uint64_t a1)
{
  return sub_18315A7F8(a1, (uint64_t *)&unk_1EB266A08);
}

unsigned char *sub_18313D0A4(unsigned char *a1, unsigned char *a2, int *a3)
{
  os_log_type_t v6 = (int *)type metadata accessor for NWPath(0);
  uint64_t v7 = *((void *)v6 - 1);
  if ((*(unsigned int (**)(unsigned char *, uint64_t, int *))(v7 + 48))(a2, 1, v6))
  {
    uint64_t v8 = __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1EB266A38);
    memcpy(a1, a2, *(void *)(*(void *)(v8 - 8) + 64));
  }
  else
  {
    uint64_t v53 = v7;
    *a1 = *a2;
    *((void *)a1 + 1) = *((void *)a2 + 1);
    *((_DWORD *)a1 + 4) = *((_DWORD *)a2 + 4);
    *((void *)a1 + 3) = *((void *)a2 + 3);
    uint64_t v9 = v6[11];
    __dst = &a1[v9];
    os_log_type_t v10 = &a2[v9];
    uint64_t v11 = type metadata accessor for NWEndpoint();
    uint64_t v50 = *(void *)(v11 - 8);
    os_log_type_t v12 = *(unsigned int (**)(void, void, void))(v50 + 48);
    swift_bridgeObjectRetain();
    swift_bridgeObjectRetain();
    if (v12(v10, 1, v11))
    {
      uint64_t v13 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
      memcpy(__dst, v10, *(void *)(*(void *)(v13 - 8) + 64));
    }
    else
    {
      switch(swift_getEnumCaseMultiPayload())
      {
        case 1u:
          id v48 = v12;
          uint64_t v15 = *((void *)v10 + 1);
          void *__dst = *(void *)v10;
          __dst[1] = v15;
          uint64_t v16 = *((void *)v10 + 3);
          __dst[2] = *((void *)v10 + 2);
          __dst[3] = v16;
          uint64_t v17 = *((void *)v10 + 5);
          __dst[4] = *((void *)v10 + 4);
          __dst[5] = v17;
          uint64_t v18 = *((void *)v10 + 6);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v18 != 1) {
            swift_unknownObjectRetain();
          }
          __dst[6] = v18;
          os_log_type_t v12 = v48;
          break;
        case 2u:
          uint64_t v19 = *((void *)v10 + 1);
          void *__dst = *(void *)v10;
          __dst[1] = v19;
          swift_bridgeObjectRetain();
          break;
        case 3u:
          uint64_t v20 = sub_183D4447C();
          (*(void (**)(void *, char *, uint64_t))(*(void *)(v20 - 8) + 16))(__dst, v10, v20);
          break;
        case 4u:
          void *__dst = *(void *)v10;
          swift_unknownObjectRetain();
          break;
        default:
          uint64_t v47 = v12;
          uint64_t v14 = *(void *)v10;
          uint64_t v45 = *((void *)v10 + 2);
          uint64_t v46 = *((void *)v10 + 1);
          char v44 = v10[24];
          sub_18315E9E4(*(void *)v10, v46, v45, v44);
          void *__dst = v14;
          os_log_type_t v12 = v47;
          __dst[1] = v46;
          __dst[2] = v45;
          *((unsigned char *)__dst + 24) = v44;
          *((_WORD *)__dst + 13) = *((_WORD *)v10 + 13);
          break;
      }
      swift_storeEnumTagMultiPayload();
      (*(void (**)(void *, void, uint64_t, uint64_t))(v50 + 56))(__dst, 0, 1, v11);
    }
    uint64_t v21 = v6[12];
    uint64_t v22 = &a1[v21];
    os_log_type_t v23 = &a2[v21];
    if (v12(&a2[v21], 1, v11))
    {
      uint64_t v24 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
      memcpy(v22, v23, *(void *)(*(void *)(v24 - 8) + 64));
    }
    else
    {
      switch(swift_getEnumCaseMultiPayload())
      {
        case 1u:
          uint64_t v27 = *((void *)v23 + 1);
          *uint64_t v22 = *(void *)v23;
          v22[1] = v27;
          uint64_t v28 = *((void *)v23 + 3);
          v22[2] = *((void *)v23 + 2);
          v22[3] = v28;
          uint64_t v29 = *((void *)v23 + 5);
          void v22[4] = *((void *)v23 + 4);
          v22[5] = v29;
          uint64_t v30 = *((void *)v23 + 6);
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          swift_bridgeObjectRetain();
          if (v30 != 1) {
            swift_unknownObjectRetain();
          }
          v22[6] = v30;
          break;
        case 2u:
          uint64_t v31 = *((void *)v23 + 1);
          *uint64_t v22 = *(void *)v23;
          v22[1] = v31;
          swift_bridgeObjectRetain();
          break;
        case 3u:
          uint64_t v32 = sub_183D4447C();
          (*(void (**)(void *, char *, uint64_t))(*(void *)(v32 - 8) + 16))(v22, v23, v32);
          break;
        case 4u:
          *uint64_t v22 = *(void *)v23;
          swift_unknownObjectRetain();
          break;
        default:
          uint64_t v25 = *(void *)v23;
          uint64_t v26 = *((void *)v23 + 1);
          __dsta = (void *)*((void *)v23 + 2);
          char v49 = v23[24];
          sub_18315E9E4(*(void *)v23, v26, (uint64_t)__dsta, v49);
          *uint64_t v22 = v25;
          v22[1] = v26;
          v22[2] = __dsta;
          *((unsigned char *)v22 + 24) = v49;
          *((_WORD *)v22 + 13) = *((_WORD *)v23 + 13);
          break;
      }
      swift_storeEnumTagMultiPayload();
      (*(void (**)(void *, void, uint64_t, uint64_t))(v50 + 56))(v22, 0, 1, v11);
    }
    *(void *)&a1[v6[13]] = *(void *)&a2[v6[13]];
    os_log_type_t v33 = *(void (**)(unsigned char *, void, uint64_t, int *))(v53 + 56);
    swift_unknownObjectRetain();
    v33(a1, 0, 1, v6);
  }
  uint64_t v34 = a3[5];
  uint64_t v35 = &a1[v34];
  id v36 = &a2[v34];
  if (*v36)
  {
    uint64_t v37 = v36[1];
    void *v35 = *v36;
    v35[1] = v37;
    swift_retain();
  }
  else
  {
    *(_OWORD *)uint64_t v35 = *(_OWORD *)v36;
  }
  uint64_t v38 = a3[7];
  *(void *)&a1[a3[6]] = *(void *)&a2[a3[6]];
  id v39 = *(void **)&a2[v38];
  *(void *)&a1[v38] = v39;
  uint64_t v40 = a3[9];
  *(void *)&a1[a3[8]] = *(void *)&a2[a3[8]];
  a1[v40] = a2[v40];
  uint64_t v41 = a3[11];
  a1[a3[10]] = a2[a3[10]];
  *(void *)&a1[v41] = *(void *)&a2[v41];
  id v42 = v39;
  swift_bridgeObjectRetain();
  swift_retain();
  return a1;
}

uint64_t sub_18313D61C(uint64_t a1, uint64_t a2, uint64_t a3)
{
  id v5 = *(void (**)(uint64_t, uint64_t))(a1 + 32);
  swift_retain();
  swift_unknownObjectRetain();
  v5(a2, a3);
  swift_release();

  return swift_unknownObjectRelease();
}

void sub_18313D68C(uint64_t a1, uint64_t a2)
{
  sub_18313D698(a1, a2, *(void *)(v2 + 16), *(void (**)(int *))(v2 + 24));
}

void sub_18313D698(uint64_t a1, uint64_t a2, uint64_t a3, void (*a4)(int *))
{
  id v5 = *(os_unfair_lock_s **)(a3 + 24);
  uint64_t v6 = (uint64_t)&v5[4];
  uint64_t v7 = v5 + 24;
  os_unfair_lock_lock(v5 + 24);
  sub_18313D788(v6, (uint64_t)&v8);
  os_unfair_lock_unlock(v7);
  if (a4) {
    a4(&v8);
  }
}

uint64_t sub_18313D738()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_18313D760()
{
  return (*(uint64_t (**)(void))(v0 + 16))();
}

uint64_t sub_18313D788@<X0>(uint64_t a1@<X0>, uint64_t a2@<X8>)
{
  return sub_18313D7A8(a1, *(unsigned int *)(v2 + 16), *(NSObject **)(v2 + 24), a2);
}

uint64_t sub_18313D7A8@<X0>(uint64_t a1@<X0>, uint64_t a2@<X1>, NSObject *a3@<X2>, uint64_t a4@<X8>)
{
  swift_unknownObjectRetain();
  uint64_t result = sub_18313D880(a3, a2, (uint64_t)&v11);
  unsigned int v9 = v11;
  unint64_t v10 = v11 | ((unint64_t)v12 << 32);
  *(unsigned char *)(a1 + 76) = v12;
  *(_DWORD *)(a1 + 72) = v9;
  if (v10 >= 0x8000000003)
  {
    uint64_t result = nw_utilities_minos_atleast(1);
    if (result)
    {
      sub_18313D870(*(void *)a1);
      *(void *)a1 = 0;
      *(void *)(a1 + 8) = 0;
      sub_18313D870(*(void *)(a1 + 16));
      *(void *)(a1 + 16) = 0;
      *(void *)(a1 + 24) = 0;
      sub_18313D870(*(void *)(a1 + 32));
      *(void *)(a1 + 32) = 0;
      *(void *)(a1 + 40) = 0;
      uint64_t result = sub_18313D870(*(void *)(a1 + 48));
      *(void *)(a1 + 48) = 0;
      *(void *)(a1 + 56) = 0;
    }
  }
  *(_DWORD *)a4 = v10;
  *(unsigned char *)(a4 + 4) = BYTE4(v10);
  return result;
}

uint64_t sub_18313D870(uint64_t result)
{
  if (result) {
    return swift_release();
  }
  return result;
}

uint64_t sub_18313D880@<X0>(nw_error_t error@<X1>, uint64_t result@<X0>, uint64_t a3@<X8>)
{
  switch((int)result)
  {
    case 0:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000000;
      break;
    case 1:
      if (error)
      {
        nw_error_domain_t error_domain = nw_error_get_error_domain(error);
        switch(error_domain)
        {
          case nw_error_domain_tls:
            unsigned int error_code = nw_error_get_error_code(error);
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = error_code | 0x200000000;
            break;
          case nw_error_domain_dns:
            unsigned int v9 = nw_error_get_error_code(error);
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = v9 | 0x100000000;
            break;
          case nw_error_domain_posix:
            nw_error_get_error_code(error);
            uint64_t v7 = sub_183D449AC();
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = 22;
            if ((v7 & 0x100000000) == 0) {
              unint64_t v5 = v7;
            }
            break;
          default:
            uint64_t result = swift_unknownObjectRelease();
            unint64_t v5 = 22;
            break;
        }
      }
      else
      {
        unint64_t v5 = 50;
      }
      break;
    case 2:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000001;
      break;
    case 3:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000002;
      break;
    case 4:
      uint64_t result = (uint64_t)sub_1832E6D08(error, (uint64_t)&v10);
      unint64_t v5 = 0x4000000016;
      if (v11 != 255) {
        unint64_t v5 = v10 | ((unint64_t)v11 << 32) | 0x4000000000;
      }
      break;
    default:
      uint64_t result = swift_unknownObjectRelease();
      unint64_t v5 = 0x8000000003;
      break;
  }
  *(_DWORD *)a3 = v5;
  *(unsigned char *)(a3 + 4) = BYTE4(v5);
  return result;
}

uint64_t nw_ip_options_get_fragmentation_value(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_fragmentation_value_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  int v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
  unint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_fragmentation_value";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_18313DD5C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void __nw_resolver_set_update_handler_block_invoke(uint64_t a1)
{
  uint64_t v101 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 347) & 0x10) != 0 && (*(unsigned char *)(v2 + 346) & 0x20) == 0)
  {
    if (*(unsigned char *)(v2 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v3 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_11;
      }
      uint64_t v4 = *(void *)(a1 + 32) + 256;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_resolver_set_update_handler_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v4;
      unint64_t v5 = "%{public}s [C%{public}s] started";
      uint64_t v6 = v3;
      uint32_t v7 = 22;
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v3 = (id)gLogObj;
      if (!os_log_type_enabled(v3, OS_LOG_TYPE_DEFAULT))
      {
LABEL_11:

        uint64_t v2 = *(void *)(a1 + 32);
        goto LABEL_12;
      }
      int v8 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_resolver_set_update_handler_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v8;
      unint64_t v5 = "%{public}s [R%u] started";
      uint64_t v6 = v3;
      uint32_t v7 = 18;
    }
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, v5, buf, v7);
    goto LABEL_11;
  }
LABEL_12:
  if (!*(void *)(v2 + 96)) {
    goto LABEL_124;
  }
  if (*(unsigned char *)(v2 + 346))
  {
    os_log_type_t v23 = (void **)(id)v2;
    nw_context_assert_queue(v23[4]);
    uint64_t v24 = (void (**)(void *, void *, BOOL, unsigned char *))nw_endpoint_copy_custom_resolver_block(v23[3]);
    if (v24)
    {
      uint64_t v25 = v23[3];
      BOOL v26 = nw_context_copy_workloop(v23[4]);
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = ___ZL40nw_resolver_start_custom_resolver_lockedP22NWConcrete_nw_resolver_block_invoke;
      uint64_t v95 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E523B240;
      uint64_t v27 = v23;
      size_t v96 = (void (*)(uint64_t))v27;
      v24[2](v24, v25, v26, buf);

      goto LABEL_124;
    }
    BOOL v69 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v99 = 136446210;
    *(void *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
    os_log_type_t v70 = (char *)_os_log_send_and_compose_impl();

    v98[0] = 16;
    v90[0] = 0;
    if (__nwlog_fault(v70, v98, v90))
    {
      if (v98[0] == 17)
      {
        CFDataRef v71 = __nwlog_obj();
        os_log_type_t v72 = v98[0];
        if (os_log_type_enabled(v71, (os_log_type_t)v98[0]))
        {
          *(_DWORD *)os_log_type_t v99 = 136446210;
          *(void *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
          _os_log_impl(&dword_1830D4000, v71, v72, "%{public}s called with null resolver_block", v99, 0xCu);
        }
      }
      else if (v90[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        CFDataRef v71 = __nwlog_obj();
        os_log_type_t v74 = v98[0];
        BOOL v75 = os_log_type_enabled(v71, (os_log_type_t)v98[0]);
        if (backtrace_string)
        {
          if (v75)
          {
            *(_DWORD *)os_log_type_t v99 = 136446466;
            *(void *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
            *(_WORD *)&v99[12] = 2082;
            *(void *)&v99[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v71, v74, "%{public}s called with null resolver_block, dumping backtrace:%{public}s", v99, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_141;
        }
        if (v75)
        {
          *(_DWORD *)os_log_type_t v99 = 136446210;
          *(void *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
          _os_log_impl(&dword_1830D4000, v71, v74, "%{public}s called with null resolver_block, no backtrace", v99, 0xCu);
        }
      }
      else
      {
        CFDataRef v71 = __nwlog_obj();
        os_log_type_t v76 = v98[0];
        if (os_log_type_enabled(v71, (os_log_type_t)v98[0]))
        {
          *(_DWORD *)os_log_type_t v99 = 136446210;
          *(void *)&v99[4] = "nw_resolver_start_custom_resolver_locked";
          _os_log_impl(&dword_1830D4000, v71, v76, "%{public}s called with null resolver_block, backtrace limit exceeded", v99, 0xCu);
        }
      }
    }
LABEL_141:
    if (v70) {
      free(v70);
    }

    goto LABEL_123;
  }
  nw_endpoint_type_t type = nw_endpoint_get_type(*(nw_endpoint_t *)(v2 + 24));
  uint64_t v10 = *(void *)(a1 + 32);
  if (type != nw_endpoint_type_host)
  {
    if (nw_resolver_create_dns_service_locked((NWConcrete_nw_resolver *)v10)) {
      goto LABEL_124;
    }
    goto LABEL_123;
  }
  int required_address_family = nw_parameters_get_required_address_family(*(void **)(v10 + 16));
  if (required_address_family == 2
    || (nw_parameters_get_desperate_ivan(*(void **)(*(void *)(a1 + 32) + 16)) & 1) != 0)
  {
    int v12 = 1;
LABEL_18:
    uint64_t v13 = *(void *)(a1 + 32);
LABEL_19:
    *(_DWORD *)(v13 + 80) = v12;
    goto LABEL_20;
  }
  uint64_t v13 = *(void *)(a1 + 32);
  if (required_address_family == 30)
  {
    int v12 = 2;
    goto LABEL_19;
  }
  if (nw_parameters_get_allow_unusable_addresses(*(void **)(v13 + 16)))
  {
    int v12 = 3;
    goto LABEL_18;
  }
LABEL_20:
  uint64_t v14 = *(void **)(*(void *)(a1 + 32) + 16);
  if (!v14)
  {
    uint64_t v28 = 0;
    int v29 = 0;
    goto LABEL_113;
  }
  uint64_t v15 = v14;
  id v16 = v15[23];

  if (!v16)
  {
    int v29 = 0;
    goto LABEL_72;
  }
  uint64_t v17 = (id *)v16;
  id v18 = v17[5];

  if (v18)
  {
    id v19 = v18;
    int v20 = [v19 type];

    if (v20 == 2 && (nw_endpoint_is_equal(v19, *(void **)(*(void *)(a1 + 32) + 24), 0) & 1) != 0) {
      goto LABEL_39;
    }
  }
  uint64_t v21 = v17;
  int v22 = *((_DWORD *)v21 + 38);
  if (v22 == 1)
  {
    int v30 = *((_DWORD *)v21 + 39);

    if (v30 != 1) {
      goto LABEL_43;
    }
LABEL_39:
    *(void *)os_log_type_t v99 = 0;
    *(void *)&v99[8] = v99;
    *(void *)&v99[16] = 0x2020000000;
    char v100 = 0;
    *(void *)uint64_t v98 = 0;
    *(void *)&v98[8] = v98;
    *(void *)&v98[16] = 0x2020000000;
    v98[24] = 0;
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v95 = __Block_byref_object_copy__5653;
    size_t v96 = __Block_byref_object_dispose__5654;
    id v97 = 0;
    v84[0] = MEMORY[0x1E4F143A8];
    v84[1] = 3221225472;
    v84[2] = __nw_resolver_set_update_handler_block_invoke_77;
    void v84[3] = &unk_1E523B1D0;
    char v89 = required_address_family;
    BOOL v86 = v99;
    BOOL v87 = buf;
    id v85 = *(id *)(a1 + 32);
    uint64_t v88 = v98;
    nw_proxy_config_enumerate_resolved_endpoints(v17, v84);
    unsigned int v83 = 0;
    int scoped_interface_index = nw_resolver_get_scoped_interface_index(*(NWConcrete_nw_resolver **)(a1 + 32), &v83);
    uint64_t v32 = *(void **)(*(void *)(a1 + 32) + 200);
    if (v32)
    {
      os_log_type_t v33 = nw_path_copy_interface(v32);
      uint64_t v34 = v33;
      if (v33) {
        LODWORD(v32) = nw_interface_get_type(v33);
      }
      else {
        LODWORD(v32) = 0;
      }
    }
    else
    {
      uint64_t v34 = 0;
    }
    uint64_t v35 = *(void **)(*(void *)&buf[8] + 40);
    if (v35 && v35[3] != v35[2])
    {
      uint64_t v36 = *(void *)(a1 + 32);
      if (scoped_interface_index == -1 || v32 == 4)
      {
        if (!v36)
        {
          uint64_t v38 = __nwlog_obj();
          if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
          {
            uint64_t v39 = *(void *)(*(void *)&buf[8] + 40);
            *(_DWORD *)char v90 = 136446466;
            os_log_type_t v91 = "nw_resolver_set_update_handler_block_invoke_2";
            __int16 v92 = 2112;
            *(void *)os_log_type_t v93 = v39;
            uint64_t v40 = "%{public}s found proxy resolved endpoints %@";
            uint64_t v41 = v38;
            uint32_t v42 = 22;
LABEL_67:
            _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_INFO, v40, v90, v42);
          }
LABEL_68:

          uint64_t v35 = *(void **)(*(void *)&buf[8] + 40);
          uint64_t v36 = *(void *)(a1 + 32);
          goto LABEL_69;
        }
        char v37 = *(unsigned char *)(v36 + 346);
LABEL_59:
        if ((v37 & 0x20) != 0)
        {
LABEL_69:
          objc_storeStrong((id *)(v36 + 144), v35);
          *(unsigned char *)(*(void *)(a1 + 32) + 346) |= 2u;
          nw_resolver_update_status_locked(*(void **)(a1 + 32), 0);
          int v29 = 1;
          goto LABEL_70;
        }
        if (*(unsigned char *)(v36 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v38 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v38, OS_LOG_TYPE_INFO)) {
            goto LABEL_68;
          }
          uint64_t v43 = *(void *)(a1 + 32) + 256;
          uint64_t v44 = *(void *)(*(void *)&buf[8] + 40);
          *(_DWORD *)char v90 = 136446722;
          os_log_type_t v91 = "nw_resolver_set_update_handler_block_invoke";
          __int16 v92 = 2082;
          *(void *)os_log_type_t v93 = v43;
          *(_WORD *)&v93[8] = 2112;
          *(void *)&v93[10] = v44;
          uint64_t v40 = "%{public}s [C%{public}s] found proxy resolved endpoints %@";
          uint64_t v41 = v38;
          uint32_t v42 = 32;
          goto LABEL_67;
        }
        uint64_t v38 = __nwlog_obj();
        if (os_log_type_enabled(v38, OS_LOG_TYPE_INFO))
        {
          int v45 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
          uint64_t v46 = *(void *)(*(void *)&buf[8] + 40);
          *(_DWORD *)char v90 = 136446722;
          os_log_type_t v91 = "nw_resolver_set_update_handler_block_invoke";
          __int16 v92 = 1024;
          *(_DWORD *)os_log_type_t v93 = v45;
          *(_WORD *)&v93[4] = 2112;
          *(void *)&v93[6] = v46;
          uint64_t v40 = "%{public}s [R%u] found proxy resolved endpoints %@";
          uint64_t v41 = v38;
          uint32_t v42 = 28;
          goto LABEL_67;
        }
        goto LABEL_68;
      }
      char v37 = *(unsigned char *)(v36 + 346);
      if ((v37 & 0x40) != 0 && *(unsigned char *)(*(void *)&v99[8] + 24)
        || (*(unsigned char *)(v36 + 346) & 0x80) != 0 && *(unsigned char *)(*(void *)&v98[8] + 24))
      {
        goto LABEL_59;
      }
    }
    int v29 = 0;
LABEL_70:

    _Block_object_dispose(buf, 8);
    _Block_object_dispose(v98, 8);
    _Block_object_dispose(v99, 8);
    goto LABEL_71;
  }
  if (v22 == 4)
  {

    goto LABEL_39;
  }

LABEL_43:
  int v29 = 0;
LABEL_71:

LABEL_72:
  uint64_t v28 = nw_endpoint_copy_association_with_evaluator(*(void **)(*(void *)(a1 + 32) + 24), *(void **)(*(void *)(a1 + 32) + 16), 0);

  if (v28 && (*(unsigned char *)(*(void *)(a1 + 32) + 346) & 2) == 0)
  {
    if (nw_protocol_copy_resolver_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_resolver_definition(void)::onceToken, &__block_literal_global_187);
    }
    cached_content_for_uint64_t protocol = nw_association_get_cached_content_for_protocol(v28, (void *)nw_protocol_copy_resolver_definition(void)::resolver_definition);
    id v48 = (id *)cached_content_for_protocol;
    if (cached_content_for_protocol)
    {
      if (*(unsigned char *)(cached_content_for_protocol + 24)) {
        *(unsigned char *)(*(void *)(a1 + 32) + 347) |= 0x80u;
      }
      if (*(void *)cached_content_for_protocol)
      {
        uint64_t v49 = *(void *)(cached_content_for_protocol + 8);
        if (v49)
        {
          uint64_t v50 = *(void *)(cached_content_for_protocol + 16);
          if (v50)
          {
            if (*(void *)(v49 + 24) - *(void *)(v49 + 16) == *(void *)(v50 + 24) - *(void *)(v50 + 16))
            {
              v80[0] = MEMORY[0x1E4F143A8];
              v80[1] = 3221225472;
              v80[2] = __nw_resolver_set_update_handler_block_invoke_80;
              v80[3] = &unk_1E5243340;
              uint64_t v82 = cached_content_for_protocol;
              id v81 = *(id *)(a1 + 32);
              nw_array_apply((atomic_uchar *)v49, (uint64_t)v80);
            }
          }
        }
        *(void *)buf = 0;
        *(void *)&buf[8] = buf;
        *(void *)&buf[16] = 0x2020000000;
        LOBYTE(v95) = 0;
        *(void *)os_log_type_t v99 = 0;
        *(void *)&v99[8] = v99;
        *(void *)&v99[16] = 0x2020000000;
        char v100 = 0;
        os_log_type_t v51 = (atomic_uchar *)*v48;
        v79[0] = MEMORY[0x1E4F143A8];
        v79[1] = 3221225472;
        v79[2] = __nw_resolver_set_update_handler_block_invoke_82;
        v79[3] = &unk_1E5248260;
        uint8_t v79[4] = buf;
        v79[5] = v99;
        nw_array_apply(v51, (uint64_t)v79);
        *(_DWORD *)char v90 = 0;
        int v52 = nw_resolver_get_scoped_interface_index(*(NWConcrete_nw_resolver **)(a1 + 32), (unsigned int *)v90);
        uint64_t v53 = *(void *)(a1 + 32);
        os_log_type_t v54 = *(void **)(v53 + 200);
        if (v54)
        {
          BOOL v55 = nw_path_copy_interface(v54);
          uint64_t v56 = v55;
          if (v55) {
            LODWORD(v54) = nw_interface_get_type(v55);
          }
          else {
            LODWORD(v54) = 0;
          }
          uint64_t v53 = *(void *)(a1 + 32);
        }
        else
        {
          uint64_t v56 = 0;
        }
        if (v52 == -1 || v54 == 4)
        {
          if (!v53)
          {
            BOOL v58 = __nwlog_obj();
            if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
            {
              id v66 = *v48;
              *(_DWORD *)uint64_t v98 = 136446466;
              *(void *)&v98[4] = "nw_resolver_set_update_handler_block_invoke_2";
              *(_WORD *)&v98[12] = 2112;
              *(void *)&v98[14] = v66;
              unint64_t v61 = "%{public}s found cached endpoints %@";
              uint64_t v62 = v58;
              uint32_t v63 = 22;
              goto LABEL_109;
            }
LABEL_110:

            uint64_t v53 = *(void *)(a1 + 32);
            goto LABEL_111;
          }
          char v57 = *(unsigned char *)(v53 + 346);
        }
        else
        {
          char v57 = *(unsigned char *)(v53 + 346);
          if (((v57 & 0x40) == 0 || !*(unsigned char *)(*(void *)&buf[8] + 24))
            && ((*(unsigned char *)(v53 + 346) & 0x80) == 0 || !*(unsigned char *)(*(void *)&v99[8] + 24)))
          {
            goto LABEL_112;
          }
        }
        if ((v57 & 0x20) != 0)
        {
LABEL_111:
          objc_storeStrong((id *)(v53 + 144), *v48);
          *(unsigned char *)(*(void *)(a1 + 32) + 346) |= 2u;
          nw_resolver_update_status_locked(*(void **)(a1 + 32), 0);
          int v29 = 1;
LABEL_112:

          _Block_object_dispose(v99, 8);
          _Block_object_dispose(buf, 8);
          goto LABEL_113;
        }
        if (*(unsigned char *)(v53 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v58 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v58, OS_LOG_TYPE_INFO)) {
            goto LABEL_110;
          }
          uint64_t v59 = *(void *)(a1 + 32) + 256;
          id v60 = *v48;
          *(_DWORD *)uint64_t v98 = 136446722;
          *(void *)&v98[4] = "nw_resolver_set_update_handler_block_invoke";
          *(_WORD *)&v98[12] = 2082;
          *(void *)&v98[14] = v59;
          *(_WORD *)&v98[22] = 2112;
          *(void *)&v98[24] = v60;
          unint64_t v61 = "%{public}s [C%{public}s] found cached endpoints %@";
          uint64_t v62 = v58;
          uint32_t v63 = 32;
          goto LABEL_109;
        }
        BOOL v58 = __nwlog_obj();
        if (os_log_type_enabled(v58, OS_LOG_TYPE_INFO))
        {
          int v64 = *(_DWORD *)(*(void *)(a1 + 32) + 340);
          id v65 = *v48;
          *(_DWORD *)uint64_t v98 = 136446722;
          *(void *)&v98[4] = "nw_resolver_set_update_handler_block_invoke";
          *(_WORD *)&v98[12] = 1024;
          *(_DWORD *)&v98[14] = v64;
          *(_WORD *)&v98[18] = 2112;
          *(void *)&v98[20] = v65;
          unint64_t v61 = "%{public}s [R%u] found cached endpoints %@";
          uint64_t v62 = v58;
          uint32_t v63 = 28;
LABEL_109:
          _os_log_impl(&dword_1830D4000, v62, OS_LOG_TYPE_INFO, v61, v98, v63);
          goto LABEL_110;
        }
        goto LABEL_110;
      }
    }
  }
LABEL_113:
  if ((*(unsigned char *)(*(void *)(a1 + 32) + 346) & 2) == 0)
  {
    if (networkd_settings_get_BOOL((const char *)nw_setting_disable_dns_xpc)) {
      goto LABEL_120;
    }
    if (nw_resolver_can_use_dns_xpc::onceToken != -1) {
      dispatch_once(&nw_resolver_can_use_dns_xpc::onceToken, &__block_literal_global_5681);
    }
    if (nw_resolver_can_use_dns_xpc::can_use_dns_xpc == 1 && MEMORY[0x1E4FBA5C0]) {
      dns_getaddrinfo_uint64_t locked = nw_resolver_create_dns_getaddrinfo_locked(*(NWConcrete_nw_resolver **)(a1 + 32), 0);
    }
    else {
LABEL_120:
    }
      dns_getaddrinfo_uint64_t locked = nw_resolver_create_dns_service_locked(*(NWConcrete_nw_resolver **)(a1 + 32));
    int v29 = dns_getaddrinfo_locked;
  }

  if (!v29)
  {
LABEL_123:
    uint64_t v68 = *(void **)(a1 + 32);
    v77[0] = MEMORY[0x1E4F143A8];
    v77[1] = 3221225472;
    void v77[2] = __nw_resolver_set_update_handler_block_invoke_83;
    v77[3] = &unk_1E524BAA8;
    id v78 = v68;
    nw_resolver_update_status_locked(v78, v77);
  }
LABEL_124:
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
}

void sub_18313EBC8(_Unwind_Exception *a1)
{
  _Block_object_dispose((const void *)(v2 - 128), 8);
  _Block_object_dispose((const void *)(v2 - 208), 8);

  _Unwind_Resume(a1);
}

uint64_t nw_association_get_cached_content_for_protocol(void *a1, void *a2)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  unint64_t v5 = v4;
  if (!v3)
  {
    uint64_t v41 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v66 = "nw_association_get_cached_content_for_protocol";
    uint32_t v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (!__nwlog_fault(v42, &type, &v63)) {
      goto LABEL_97;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        id v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v48 = type;
      BOOL v49 = os_log_type_enabled(v43, type);
      if (backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          id v66 = "nw_association_get_cached_content_for_protocol";
          __int16 v67 = 2082;
          uint64_t v68 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v43, v48, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v42) {
          goto LABEL_99;
        }
        goto LABEL_98;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        id v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_1830D4000, v43, v48, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        id v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_1830D4000, v43, v57, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_96;
  }
  if (!v4)
  {
    int v45 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v66 = "nw_association_get_cached_content_for_protocol";
    uint32_t v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (!__nwlog_fault(v42, &type, &v63)) {
      goto LABEL_97;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        id v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_1830D4000, v43, v46, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v63)
    {
      uint64_t v50 = (char *)__nw_create_backtrace_string();
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v51 = type;
      BOOL v52 = os_log_type_enabled(v43, type);
      if (v50)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446466;
          id v66 = "nw_association_get_cached_content_for_protocol";
          __int16 v67 = 2082;
          uint64_t v68 = v50;
          _os_log_impl(&dword_1830D4000, v43, v51, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v50);
LABEL_97:
        if (!v42)
        {
LABEL_99:
          uint64_t v12 = 0;
          goto LABEL_58;
        }
LABEL_98:
        free(v42);
        goto LABEL_99;
      }
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        id v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_1830D4000, v43, v51, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v43 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v43, type))
      {
        *(_DWORD *)buf = 136446210;
        id v66 = "nw_association_get_cached_content_for_protocol";
        _os_log_impl(&dword_1830D4000, v43, v58, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_96:

    goto LABEL_97;
  }
  id v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
  nw_context_assert_queue(v6);
  uint64_t v7 = *((void *)v3 + 7);
  if (!v7) {
    goto LABEL_56;
  }
  BOOL node = nw_hash_table_get_node(v7, (uint64_t)v5, 0);
  if (!node) {
    goto LABEL_56;
  }
  os_log_type_t v9 = (uint64_t *)node;
  time_t v10 = time(0);
  os_log_type_t v11 = v9 + 4;
  uint64_t v12 = v9[9];
  if (v10 <= v9[8])
  {
    id v19 = v6;
    if (v19)
    {
      int v20 = (dispatch_queue_t *)v19;
      uint64_t v21 = v20;
      if (((_BYTE)v20[17] & 8) == 0) {
        dispatch_assert_queue_V2(v20[1]);
      }

      BOOL v22 = nw_context_copy_cache_context(v21);
      uint64_t v23 = v9[6];
      if (v23 || v9[7])
      {
        uint64_t v24 = *(void *)(v22 + 24);
        int v25 = *(_DWORD *)(v24 + 64);
        if (v25) {
          *(_DWORD *)(v24 + 64) = v25 - 1;
        }
        BOOL v26 = (uint64_t *)v9[7];
        if (v23)
        {
          *(void *)(v23 + 24) = v26;
          BOOL v26 = (uint64_t *)v9[7];
        }
        else
        {
          *(void *)(v24 + 24) = v26;
        }
        *BOOL v26 = v23;
        v9[6] = 0;
        v9[7] = 0;
      }
      uint64_t v27 = v9[4];
      uint64_t v28 = (uint64_t *)v9[5];
      if (v27)
      {
        *(void *)(v27 + 8) = v28;
        uint64_t v28 = (uint64_t *)v9[5];
      }
      else
      {
        *(void *)(*(void *)(v22 + 24) + 8) = v28;
      }
      uint64_t *v28 = v27;
      uint64_t v29 = **(void **)(v22 + 24);
      *os_log_type_t v11 = v29;
      int v30 = *(void **)(v22 + 24);
      if (v29) {
        int v30 = (void *)*v30;
      }
      v30[1] = v11;
      **(void **)(v22 + 24) = v11;
      v9[5] = *(void *)(v22 + 24);

      goto LABEL_57;
    }
    uint64_t v53 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v66 = "nw_context_touch_cache_entry";
    os_log_type_t v54 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault(v54, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v55 = __nwlog_obj();
        os_log_type_t v56 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          id v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v63)
      {
        uint64_t v59 = (char *)__nw_create_backtrace_string();
        BOOL v55 = __nwlog_obj();
        os_log_type_t v60 = type;
        BOOL v61 = os_log_type_enabled(v55, type);
        if (v59)
        {
          if (v61)
          {
            *(_DWORD *)buf = 136446466;
            id v66 = "nw_context_touch_cache_entry";
            __int16 v67 = 2082;
            uint64_t v68 = v59;
            _os_log_impl(&dword_1830D4000, v55, v60, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v59);
          goto LABEL_111;
        }
        if (v61)
        {
          *(_DWORD *)buf = 136446210;
          id v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_1830D4000, v55, v60, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v55 = __nwlog_obj();
        os_log_type_t v62 = type;
        if (os_log_type_enabled(v55, type))
        {
          *(_DWORD *)buf = 136446210;
          id v66 = "nw_context_touch_cache_entry";
          _os_log_impl(&dword_1830D4000, v55, v62, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_111:
    if (v54) {
      free(v54);
    }
    goto LABEL_57;
  }
  if (v12) {
    nw_protocol_definition_deallocate_cache_entry(v5, v9[9]);
  }
  nw_context_remove_cache_entry(v6, v9 + 4);
  if (nw_hash_table_remove_node(*((void *)v3 + 7), (uint64_t)v9)
    || nw_path_parameters_get_logging_disabled(*((void *)v3 + 2)))
  {
    goto LABEL_56;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  id v13 = (id)gconnectionLogObj;
  logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 1));
  *(_DWORD *)buf = 136446722;
  id v66 = "nw_association_get_cached_content_for_protocol";
  __int16 v67 = 2082;
  uint64_t v68 = (void *)logging_description;
  __int16 v69 = 2048;
  os_log_type_t v70 = v9;
  uint64_t v15 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v63 = 0;
  if (__nwlog_fault(v15, &type, &v63))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v16 = (id)gconnectionLogObj;
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v16, type))
      {
        id v18 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        id v66 = "nw_association_get_cached_content_for_protocol";
        __int16 v67 = 2082;
        uint64_t v68 = (void *)v18;
        __int16 v69 = 2048;
        os_log_type_t v70 = v9;
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p", buf, 0x20u);
      }
    }
    else if (v63)
    {
      uint64_t v31 = __nw_create_backtrace_string();
      if (v31)
      {
        uint64_t v32 = (char *)v31;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v33 = (id)gconnectionLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          uint64_t v35 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
          *(_DWORD *)buf = 136446978;
          id v66 = "nw_association_get_cached_content_for_protocol";
          __int16 v67 = 2082;
          uint64_t v68 = (void *)v35;
          __int16 v69 = 2048;
          os_log_type_t v70 = v9;
          __int16 v71 = 2082;
          os_log_type_t v72 = v32;
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v32);
        if (!v15) {
          goto LABEL_56;
        }
        goto LABEL_55;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v16 = (id)gconnectionLogObj;
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v16, type))
      {
        uint64_t v39 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        id v66 = "nw_association_get_cached_content_for_protocol";
        __int16 v67 = 2082;
        uint64_t v68 = (void *)v39;
        __int16 v69 = 2048;
        os_log_type_t v70 = v9;
        _os_log_impl(&dword_1830D4000, v16, v38, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v16 = (id)gconnectionLogObj;
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v16, type))
      {
        char v37 = nw_endpoint_get_logging_description(*((void **)v3 + 1));
        *(_DWORD *)buf = 136446722;
        id v66 = "nw_association_get_cached_content_for_protocol";
        __int16 v67 = 2082;
        uint64_t v68 = (void *)v37;
        __int16 v69 = 2048;
        os_log_type_t v70 = v9;
        _os_log_impl(&dword_1830D4000, v16, v36, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
  if (v15) {
LABEL_55:
  }
    free(v15);
LABEL_56:
  uint64_t v12 = 0;
LABEL_57:

LABEL_58:
  return v12;
}

void sub_18313F830(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_required_address_family(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_parameters_get_required_address_family";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_parameters_get_required_address_family";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v22 = "nw_parameters_get_required_address_family";
            __int16 v23 = 2082;
            uint64_t v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_parameters_get_required_address_family";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_parameters_get_required_address_family";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_30:
    if (v12) {
      free(v12);
    }
    goto LABEL_10;
  }
  id v3 = *(void **)(v1[19] + 48);
  if (v3)
  {
    id v4 = v3;
    id v5 = v4[1];

    if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
    }
    id v6 = (id)g_ip_definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6);

    if (is_equal_unsafe)
    {
      int version = nw_ip_options_get_version(*(void **)(v2[19] + 48));
      if (version == 4)
      {
        uint64_t v9 = 2;
        goto LABEL_12;
      }
      if (version == 6)
      {
        uint64_t v9 = 30;
LABEL_12:

        goto LABEL_13;
      }
    }
  }
LABEL_10:
  uint64_t v9 = 0;
LABEL_13:

  return v9;
}

void sub_18313FBCC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_ip_options_get_version(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_version_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_version";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_18313FF04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_ip_options_get_local_address_preference(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_ip(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_ip_options_get_local_address_preference_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_ip_options_get_local_address_preference";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_local_address_preference";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_ip(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_ip_options_get_local_address_preference";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_local_address_preference";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_ip(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_ip_options_get_local_address_preference";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_ip(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_183140244(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_ip(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
    }
    BOOL v2 = nw_protocol_options_matches_definition(v1, (void *)g_ip_definition);
    goto LABEL_5;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "nw_protocol_options_is_ip";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_protocol_options_is_ip";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v15 = "nw_protocol_options_is_ip";
          __int16 v16 = 2082;
          uint64_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_protocol_options_is_ip";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "nw_protocol_options_is_ip";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_5:

  return v2;
}

void sub_18314053C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_desperate_ivan(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[98] >> 2) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_parameters_get_desperate_ivan";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_desperate_ivan";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_parameters_get_desperate_ivan";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_desperate_ivan";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_desperate_ivan";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_allow_unusable_addresses(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[98] >> 3) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_parameters_get_allow_unusable_addresses";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_allow_unusable_addresses";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_parameters_get_allow_unusable_addresses";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_allow_unusable_addresses";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_get_allow_unusable_addresses";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_tcp_options_get_no_options(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_no_options_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_no_options";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_183140DA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_tcp_options_get_retransmit_connection_drop_time(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v16 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_retransmit_connection_drop_time_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    uint64_t v2 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_retransmit_connection_drop_time";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831410E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_access_handle(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    os_log_type_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_options_access_handle";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v21)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "nw_protocol_options_access_handle";
      __int16 v25 = 2082;
      BOOL v26 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  if (!v4)
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v24 = "nw_protocol_options_access_handle";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null access_block", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v8) {
        free(v8);
      }
      goto LABEL_39;
    }
    if (!v21)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v24 = "nw_protocol_options_access_handle";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v24 = "nw_protocol_options_access_handle";
      __int16 v25 = 2082;
      BOOL v26 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  if (!v3[18])
  {
LABEL_39:
    uint64_t v6 = 0;
    goto LABEL_40;
  }
  uint64_t v6 = (*((uint64_t (**)(id))v4 + 2))(v4);
LABEL_40:

  return v6;
}

void sub_1831415D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_ip_options_get_local_address_preference_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 4);
  return 1;
}

uint64_t __nw_ip_options_get_version_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_fast_open_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x800) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_retransmit_fin_drop_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x400) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_retransmit_connection_drop_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 12);
  return 1;
}

uint64_t __nw_tcp_options_get_reduce_buffering_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 36) & 1;
  return 1;
}

uint64_t __nw_tcp_options_get_persist_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 8);
  return 1;
}

uint64_t __nw_tcp_options_get_no_timewait_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 36) & 4) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_no_push_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 36) & 8) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_no_options_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 36) & 0x10) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_no_delay_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 36) & 2) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_maximum_segment_size_block_invoke(uint64_t a1, _DWORD *a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_keepalive_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 36) & 0x20) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_background_traffic_management_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x200) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_disable_ack_stretching_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x80) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_reset_local_port_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 38) & 1;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_keepalive_offload_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 36) & 0x40) != 0;
  return 1;
}

uint64_t __nw_tcp_options_set_no_delay_block_invoke(uint64_t a1, uint64_t a2)
{
  int v3 = *(unsigned __int16 *)(a2 + 36);
  uint64_t v2 = a2 + 36;
  unsigned int v4 = v3 & 0xFFFFFFFD | (*(unsigned __int8 *)(v2 + 2) << 16);
  *(_WORD *)uint64_t v2 = v3 & 0xFFFD | (2 * (*(unsigned char *)(a1 + 32) & 0x7F));
  *(unsigned char *)(v2 + 2) = BYTE2(v4);
  return 1;
}

uint64_t __nw_proxy_options_set_authentication_challenge_handler_block_invoke(uint64_t a1, void **a2)
{
  int v3 = _Block_copy(*(const void **)(a1 + 32));
  unsigned int v4 = *a2;
  *a2 = v3;

  return 1;
}

uint64_t __nw_ip_options_get_receive_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 13) & 0x10) != 0;
  return 1;
}

uint64_t __nw_ip_options_get_hop_limit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 12);
  return 1;
}

uint64_t __nw_ip_options_get_fragmentation_value_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 8);
  return 1;
}

uint64_t __nw_ip_options_get_calculate_receive_time_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 13) & 2) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_fast_open_force_enable_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 36) & 0x4000) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 32);
  return 1;
}

uint64_t __nw_tcp_options_get_connection_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 4);
  return 1;
}

uint64_t __nw_tcp_options_get_disable_ecn_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned __int16 *)(a2 + 36) >> 15;
  return 1;
}

uint64_t __nw_ip_options_get_use_minimum_mtu_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 13) & 1;
  return 1;
}

uint64_t __nw_quic_connection_set_sec_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t __nw_quic_connection_set_max_streams_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v4 = _Block_copy(*(const void **)(a1 + 40));
  id v5 = *(void **)(a2 + 176);
  *(void *)(a2 + 176) = v4;

  objc_storeStrong((id *)(a2 + 184), *(id *)(a1 + 32));
  return 1;
}

uint64_t __nw_quic_connection_set_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(a2 + 210) = *(_WORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_connection_set_initial_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 40) = *(void *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_connection_set_initial_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 32) = *(void *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_connection_set_idle_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(a2 + 192) = *(_DWORD *)(a1 + 32);
  return 1;
}

uint64_t __nw_ip_options_get_corrupt_checksums_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 13) & 8) != 0;
  return 1;
}

uint64_t __nw_tcp_options_get_disable_blackhole_detection_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 37) & 1;
  return 1;
}

uint64_t __nw_quic_stream_get_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 24) & 1;
  return 1;
}

uint64_t __nw_quic_stream_get_is_datagram_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 24) & 2) != 0;
  return 1;
}

uint64_t __nw_quic_stream_get_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 8);
  return 1;
}

uint64_t __nw_quic_stream_get_associated_stream_id_block_invoke(uint64_t a1, void *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_quic_connection_get_enable_l4s_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 200);
  return 1;
}

uint64_t __nw_quic_connection_copy_sec_protocol_options_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t __nw_quic_stream_set_is_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 24) = *(unsigned char *)(a2 + 24) & 0xFE | *(unsigned char *)(a1 + 32);
  return 1;
}

BOOL __nw_quic_connection_execute_session_state_update_block_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(a2 + 168);
  if (v2)
  {
    id v5 = _Block_copy(*(const void **)(a2 + 160));
    uint64_t v6 = *(NSObject **)(a2 + 168);
    block[0] = MEMORY[0x1E4F143A8];
    block[1] = 3221225472;
    block[2] = __nw_quic_connection_execute_session_state_update_block_block_invoke_2;
    block[3] = &unk_1E5248030;
    id v12 = v5;
    id v10 = *(id *)(a1 + 32);
    id v11 = *(id *)(a1 + 40);
    id v7 = v5;
    dispatch_async(v6, block);
  }
  return v2 != 0;
}

uint64_t __nw_udp_options_get_no_metadata_block_invoke(uint64_t a1, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*a2 & 2) != 0;
  return 1;
}

uint64_t __nw_udp_options_set_no_metadata_block_invoke(uint64_t a1, unsigned char *a2)
{
  *a2 = *a2 & 0xFD | (2 * *(unsigned char *)(a1 + 32));
  return 1;
}

uint64_t __nw_udp_options_get_prefer_no_checksum_block_invoke(uint64_t a1, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2 & 1;
  return 1;
}

uint64_t __nw_udp_options_get_ignore_inbound_checksum_block_invoke(uint64_t a1, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*a2 & 4) != 0;
  return 1;
}

uint64_t __nw_quic_get_remote_transport_parameters_block_invoke(uint64_t a1, uint64_t a2)
{
  unsigned int v2 = *(unsigned __int16 *)(a2 + 215) | (*(unsigned __int8 *)(a2 + 217) << 16);
  if ((v2 & 0x80000) != 0)
  {
    int v3 = *(void **)(a1 + 40);
    **(void **)(a1 + 32) = *(void *)(a2 + 48);
    *int v3 = *(void *)(a2 + 56);
    unsigned int v4 = *(void **)(a1 + 56);
    **(void **)(a1 + 48) = *(void *)(a2 + 64);
    void *v4 = *(void *)(a2 + 72);
    id v5 = *(void **)(a1 + 72);
    **(void **)(a1 + 64) = *(void *)(a2 + 80);
    void *v5 = *(void *)(a2 + 88);
  }
  return (v2 >> 19) & 1;
}

uint64_t __nw_quic_connection_get_use_swift_tls_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x1000) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_tls_state_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t __nw_quic_connection_get_stream_path_affinity_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 196);
  return 1;
}

uint64_t __nw_quic_connection_get_source_connection_id_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t __nw_quic_connection_get_quic_state_block_invoke(uint64_t a1, uint64_t a2)
{
  return 1;
}

uint64_t __nw_quic_connection_get_probe_simultaneously_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 217) & 0x20) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_max_udp_payload_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 204);
  return 1;
}

uint64_t __nw_quic_connection_get_max_paths_per_interface_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 213);
  return 1;
}

uint64_t __nw_quic_connection_get_max_datagram_frame_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 206);
  return 1;
}

uint64_t __nw_quic_connection_get_keepalive_count_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 210);
  return 1;
}

uint64_t __nw_quic_connection_get_is_speculative_attempt_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 217) & 1;
  return 1;
}

uint64_t __nw_quic_connection_get_initial_packet_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_WORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_WORD *)(a2 + 208);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_streams_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 40);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_streams_bidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 32);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_stream_data_unidirectional_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 24);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_stream_data_bidirectional_remote_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 16);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_stream_data_bidirectional_local_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 8);
  return 1;
}

uint64_t __nw_quic_connection_get_initial_max_data_block_invoke(uint64_t a1, void *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

uint64_t __nw_quic_connection_get_idle_timeout_block_invoke(uint64_t a1, uint64_t a2)
{
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(_DWORD *)(a2 + 192);
  return 1;
}

uint64_t __nw_quic_connection_get_force_version_negotiation_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 215) & 0x10) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_enable_multipath_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 217) & 0x10) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_disable_spin_bit_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 217) & 2) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_disable_ecn_echo_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 216) & 1;
  return 1;
}

uint64_t __nw_quic_connection_get_disable_ecn_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x200) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_datagram_variant_flow_id_enabled_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 215) & 0x20) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_datagram_quarter_stream_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 215) & 0x40) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_datagram_context_id_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(_WORD *)(a2 + 215) & 0x80) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_ack_delay_size_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 212);
  return 1;
}

uint64_t __nw_quic_connection_get_pmtud_ignore_cost_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*(unsigned char *)(a2 + 215) & 2) != 0;
  return 1;
}

uint64_t __nw_quic_connection_get_pmtud_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(unsigned char *)(a2 + 215) & 1;
  return 1;
}

uint64_t __nw_udp_options_get_use_quic_stats_block_invoke(uint64_t a1, unsigned char *a2)
{
  *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = (*a2 & 8) != 0;
  return 1;
}

uint64_t __nw_path_enumerate_resolve_options_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  id v5 = v4;
  size_t length = 0;
  if (v4)
  {
    dispatch_data_t data = xpc_dictionary_get_data(v4, "data", &length);
    if (data)
    {
      if (length >= 0xD8)
      {
        uint64_t v7 = data[53];
        if (length == v7 + 216 && (data[52] & 0x10000) != 0 && v7 >= 0xCC)
        {
          int v8 = *(_DWORD *)(a1 + 40);
          if ((data[72] == v8
             || data[74] == v8
             || data[76] == v8
             || data[78] == v8
             || data[80] == v8
             || data[82] == v8
             || data[84] == v8
             || data[86] == v8)
            && (data[52] & 0x13) != 1)
          {
            (*(void (**)(void))(*(void *)(a1 + 32) + 16))();
          }
        }
      }
    }
  }

  return 1;
}

void sub_1831420C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_get_quic_l4s_enabled()
{
  uint64_t v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_l4s, 0);
  id v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1E4F14570])
  {
    BOOL value = xpc_BOOL_get_value(v1);

    if (value) {
      return 1;
    }
  }
  else
  {
  }
  if (nw_settings_get_l4s_enabled_internal::onceToken != -1) {
    dispatch_once(&nw_settings_get_l4s_enabled_internal::onceToken, &__block_literal_global_64948);
  }
  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_18314217C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_get_tcp_accurate_ecn_enabled()
{
  uint64_t v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_accurate_ecn, 0);
  id v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1E4F14570])
  {
    BOOL value = xpc_BOOL_get_value(v1);

    if (value) {
      return 1;
    }
  }
  else
  {
  }
  if (nw_settings_get_l4s_enabled_internal::onceToken != -1) {
    dispatch_once(&nw_settings_get_l4s_enabled_internal::onceToken, &__block_literal_global_64948);
  }
  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_183142230(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_get_tcp_l4s_enabled()
{
  uint64_t v0 = networkd_settings_copy_value_of_type((const char *)nw_setting_enable_tcp_l4s, 0);
  id v1 = v0;
  if (v0 && object_getClass(v0) == (Class)MEMORY[0x1E4F14570])
  {
    BOOL value = xpc_BOOL_get_value(v1);

    if (value) {
      return 1;
    }
  }
  else
  {
  }
  if (nw_settings_get_l4s_enabled_internal::onceToken != -1) {
    dispatch_once(&nw_settings_get_l4s_enabled_internal::onceToken, &__block_literal_global_64948);
  }
  return nw_settings_get_l4s_enabled_internal::l4s_enabled != 0;
}

void sub_1831422E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL network_config_setting_exists(const char *a1)
{
  id v1 = networkd_settings_copy_value_of_type(a1, 0);
  BOOL v2 = v1 != 0;

  return v2;
}

void *networkd_settings_copy_value_of_type(const char *a1, objc_class *a2)
{
  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    id v4 = (void *)sCachedSettings;
    if (sCachedSettings)
    {
      Class Class = object_getClass((id)sCachedSettings);
      uint64_t v6 = 0;
      if (!a1 || Class != (Class)MEMORY[0x1E4F14590]) {
        goto LABEL_12;
      }
      xpc_object_t value = xpc_dictionary_get_value(v4, a1);
      uint64_t v6 = value;
      if (a2 && value)
      {
        if (object_getClass(value) != a2) {
          goto LABEL_8;
        }
      }
      else if (!value)
      {
        goto LABEL_12;
      }
      xpc_retain(v6);
      goto LABEL_12;
    }
LABEL_8:
    uint64_t v6 = 0;
LABEL_12:
    pthread_mutex_unlock(&sSettingsMutex);
    return v6;
  }
  return 0;
}

uint64_t __nw_content_context_copy_first_repliable_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  int v6 = nw_protocol_metadata_supports_replies(v5);
  if (v6) {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 32) + 8) + 40), a3);
  }

  return v6 ^ 1u;
}

uint64_t __nw_content_context_foreach_protocol_metadata_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  uint64_t v5 = *(void *)(a1 + 32);
  nw_protocol_definition_t v6 = nw_protocol_metadata_copy_definition(v4);
  (*(void (**)(uint64_t, nw_protocol_definition_t, NSObject *))(v5 + 16))(v5, v6, v4);

  return 1;
}

void sub_183142538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_tcp_set_no_wake_from_sleep(void *a1, int a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  int v3 = a1;
  if (nw_protocol_metadata_is_tcp(v3))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_tcp_set_no_wake_from_sleep";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = a2;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_INFO, "%{public}s nw_tcp_set_no_wake_from_sleep do_not_wake %d", buf, 0x12u);
    }

    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    int v20 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = __nw_tcp_set_no_wake_from_sleep_block_invoke;
    v15[3] = &unk_1E5247BA8;
    v15[4] = buf;
    char v16 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v15);
    uint64_t v5 = *(unsigned int *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_5;
  }
  uint64_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_set_no_wake_from_sleep";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v8, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_set_no_wake_from_sleep";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_set_no_wake_from_sleep";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  uint64_t v5 = 22;
LABEL_5:

  return v5;
}

void sub_1831428F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL32nw_protocol_udp_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(void *a1, uint64_t a2)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  unsigned int v56 = 0;
  uint64_t v4 = nw_frame_unclaimed_bytes(a2, &v56);
  if (!v4) {
    goto LABEL_89;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "__nw_frame_check_validity";
    os_log_type_t v46 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (!__nwlog_fault(v46, &type, &v57)) {
      goto LABEL_87;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v47 = __nwlog_obj();
      os_log_type_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v60 = "__nw_frame_check_validity";
      BOOL v49 = "%{public}s called with null frame";
    }
    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v47 = __nwlog_obj();
      os_log_type_t v48 = type;
      BOOL v51 = os_log_type_enabled(v47, type);
      if (backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v60 = "__nw_frame_check_validity";
          __int16 v61 = 2082;
          os_log_type_t v62 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_87;
      }
      if (!v51)
      {
LABEL_87:
        if (v46) {
          free(v46);
        }
        goto LABEL_89;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v60 = "__nw_frame_check_validity";
      BOOL v49 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      uint64_t v47 = __nwlog_obj();
      os_log_type_t v48 = type;
      if (!os_log_type_enabled(v47, type)) {
        goto LABEL_87;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v60 = "__nw_frame_check_validity";
      BOOL v49 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v47, v48, v49, buf, 0xCu);
    goto LABEL_87;
  }
  uint64_t v5 = (unsigned __int16 *)v4;
  if ((*(_WORD *)(a2 + 204) & 0x100) == 0
    || !g_channel_check_validity
    || (g_channel_check_validity(a2, *(void *)(a2 + 88)) & 1) != 0)
  {
    uint64_t v6 = a1[5];
    uint64_t v7 = *(void **)(v6 + 64);
    if (v7) {
      ++*v7;
    }
    BOOL v8 = v56 < 8;
    if (v56 <= 7)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v10 = a1[5];
        id v11 = (const char *)(v10 + 96);
        if (!v10) {
          id v11 = "";
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        __int16 v61 = 2082;
        os_log_type_t v62 = (void *)v11;
        __int16 v63 = 1024;
        unsigned int v64 = v56;
        _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received UDP packet shorter than header %u", buf, 0x1Cu);
      }
      uint64_t v6 = a1[5];
      uint64_t v12 = *(void *)(v6 + 64);
      if (v12) {
        ++*(void *)(v12 + 8);
      }
    }
    unsigned int v13 = *v5;
    unsigned int v14 = *(unsigned __int16 *)(v6 + 90);
    if (v13 != v14)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v15 = gLogObj;
      BOOL v16 = os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
      uint64_t v6 = a1[5];
      if (v16)
      {
        os_log_type_t v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        __int16 v61 = 2082;
        *(_DWORD *)buf = 136446978;
        if (v6) {
          char v17 = (const char *)(v6 + 96);
        }
        else {
          char v17 = "";
        }
        os_log_type_t v62 = (void *)v17;
        __int16 v63 = 1024;
        unsigned int v64 = __rev16(v13);
        __int16 v65 = 1024;
        unsigned int v66 = __rev16(v14);
        _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received remote port %u != %u", buf, 0x22u);
        uint64_t v6 = a1[5];
      }
      BOOL v8 = 1;
    }
    unsigned int v18 = v5[1];
    unsigned int v19 = *(unsigned __int16 *)(v6 + 88);
    if (v18 != v19)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v20 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        unsigned int v21 = __rev16(v19);
        unsigned int v22 = __rev16(v18);
        uint64_t v23 = a1[5];
        os_log_type_t v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        __int16 v61 = 2082;
        *(_DWORD *)buf = 136446978;
        if (v23) {
          uint64_t v24 = (const char *)(v23 + 96);
        }
        else {
          uint64_t v24 = "";
        }
        os_log_type_t v62 = (void *)v24;
        __int16 v63 = 1024;
        unsigned int v64 = v22;
        __int16 v65 = 1024;
        unsigned int v66 = v21;
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received local port %u != %u", buf, 0x22u);
      }
      BOOL v8 = 1;
    }
    unsigned int v25 = bswap32(v5[2]) >> 16;
    if (v56 >= v25)
    {
      uint64_t v29 = a1[5];
      if ((*(_WORD *)(v29 + 94) & 4) != 0) {
        goto LABEL_48;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v26 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v27 = a1[5];
        uint64_t v28 = "";
        if (v27) {
          uint64_t v28 = (const char *)(v27 + 96);
        }
        *(_DWORD *)buf = 136446978;
        os_log_type_t v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        __int16 v61 = 2082;
        os_log_type_t v62 = (void *)v28;
        __int16 v63 = 1024;
        unsigned int v64 = v25;
        __int16 v65 = 1024;
        unsigned int v66 = v56;
        _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received length %u > %u", buf, 0x22u);
      }
      uint64_t v29 = a1[5];
      uint64_t v30 = *(void *)(v29 + 64);
      if (v30) {
        ++*(void *)(v30 + 24);
      }
      BOOL v8 = 1;
      if ((*(_WORD *)(v29 + 94) & 4) != 0)
      {
LABEL_48:
        __int16 v35 = *(_WORD *)(v29 + 94);
        if ((v35 & 0x40) != 0 || !v5[3])
        {
          if (!v8) {
            goto LABEL_54;
          }
        }
        else if (((v8 | udp_validate_cksum_internal(a2, v56, (unsigned __int16 *)(v29 + 48), (unsigned __int16 *)(v29 + 32), (v35 & 4) == 0, v29) ^ 1) & 1) == 0)
        {
          __int16 v35 = *(_WORD *)(a1[5] + 94);
LABEL_54:
          if ((v35 & 0x20) != 0)
          {
            nw_frame_set_metadata(a2, 0, 1, 1);
          }
          else
          {
            if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
              dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
            }
            singleton = nw_protocol_metadata_create_singleton((void *)g_udp_definition);
            if (singleton)
            {
              os_log_type_t v38 = singleton;
              nw_frame_set_metadata(a2, singleton, 1, 1);
              os_release(v38);
            }
          }
          nw_frame_claim(a2, v37, 8, v56 - v25);
          uint64_t v39 = a1[7];
          *(void *)(a2 + 32) = 0;
          uint64_t v40 = *(uint64_t **)(v39 + 8);
          *(void *)(a2 + 40) = v40;
          uint64_t *v40 = a2;
          *(void *)(v39 + 8) = a2 + 32;
          ++*(_DWORD *)(*(void *)(a1[4] + 8) + 24);
          uint64_t v41 = a1[5];
          if (v41)
          {
            uint64_t v42 = *(void *)(v41 + 72);
            if (v42)
            {
              ++*(void *)(v42 + 16);
              uint64_t v43 = a1[5];
              if (v43)
              {
                uint64_t v44 = *(void *)(v43 + 72);
                if (v44) {
                  *(void *)(v44 + 24) += *(unsigned int *)(a2 + 52);
                }
              }
            }
          }
          if (_nw_signposts_once != -1) {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_17);
          }
          if (_nw_signposts_enabled && kdebug_is_enabled()) {
            kdebug_trace();
          }
          if (v56 >= 9) {
            *(void *)(a1[5] + 8) = v56 + *(void *)(a1[5] + 8) - 8;
          }
          return 1;
        }
        nw_frame_finalize(a2);
        return 1;
      }
    }
    if (!v5[3])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v31 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v32 = a1[5];
        if (v32) {
          os_log_type_t v33 = (const char *)(v32 + 96);
        }
        else {
          os_log_type_t v33 = "";
        }
        *(_DWORD *)buf = 136446466;
        os_log_type_t v60 = "nw_protocol_udp_get_input_frames_block_invoke";
        __int16 v61 = 2082;
        os_log_type_t v62 = (void *)v33;
        _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received an IPv6 packet with zero checksum", buf, 0x16u);
      }
      uint64_t v29 = a1[5];
      uint64_t v34 = *(void *)(v29 + 64);
      if (v34) {
        ++*(void *)(v34 + 16);
      }
      BOOL v8 = 1;
    }
    goto LABEL_48;
  }
LABEL_89:
  BOOL v52 = __nwlog_obj();
  if (os_log_type_enabled(v52, OS_LOG_TYPE_INFO))
  {
    uint64_t v53 = a1[5];
    if (v53) {
      os_log_type_t v54 = (const char *)(v53 + 96);
    }
    else {
      os_log_type_t v54 = "";
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v60 = "nw_protocol_udp_get_input_frames_block_invoke";
    __int16 v61 = 2082;
    os_log_type_t v62 = (void *)v54;
    _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_INFO, "%{public}s %{public}s UDP frame is no longer valid", buf, 0x16u);
  }
  uint64_t v55 = a1[5];
  if (v55)
  {
    *(void *)(v55 + 64) = 0;
    *(void *)(v55 + 72) = 0;
  }
  return 1;
}

void nw_tcp_set_callbacks(void *a1, uint64_t a2, uint64_t a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  if (nw_protocol_metadata_is_tcp(v5))
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_tcp_set_callbacks_block_invoke;
    v14[3] = &__block_descriptor_48_e9_B16__0_v8l;
    void v14[4] = a2;
    v14[5] = a3;
    nw_protocol_metadata_access_handle((uint64_t)v5, (uint64_t)v14);
    goto LABEL_3;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v18 = "nw_tcp_set_callbacks";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v16 = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &v16, &v15))
  {
    if (v16 == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_tcp_set_callbacks";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v11 = v16;
      BOOL v12 = os_log_type_enabled(v8, v16);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v18 = "nw_tcp_set_callbacks";
          __int16 v19 = 2082;
          int v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_tcp_set_callbacks";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v13 = v16;
      if (os_log_type_enabled(v8, v16))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_tcp_set_callbacks";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null nw_protocol_metadata_is_tcp(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_183143508(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_metadata_access_handle(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v18 = "nw_protocol_metadata_access_handle";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_protocol_metadata_access_handle";
        os_log_type_t v9 = "%{public}s called with null metadata";
LABEL_34:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v18 = "nw_protocol_metadata_access_handle";
          __int16 v19 = 2082;
          int v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v6) {
          return 0;
        }
LABEL_37:
        free(v6);
        return 0;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_protocol_metadata_access_handle";
        os_log_type_t v9 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_34;
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_protocol_metadata_access_handle";
        os_log_type_t v9 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!a2)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    unsigned int v18 = "nw_protocol_metadata_access_handle";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_protocol_metadata_access_handle";
        os_log_type_t v9 = "%{public}s called with null access_block";
        goto LABEL_34;
      }
    }
    else
    {
      if (v15)
      {
        os_log_type_t v13 = (char *)__nw_create_backtrace_string();
        uint64_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v14 = os_log_type_enabled(v7, type);
        if (v13)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            unsigned int v18 = "nw_protocol_metadata_access_handle";
            __int16 v19 = 2082;
            int v20 = v13;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v13);
          if (!v6) {
            return 0;
          }
          goto LABEL_37;
        }
        if (!v14) {
          goto LABEL_35;
        }
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_protocol_metadata_access_handle";
        os_log_type_t v9 = "%{public}s called with null access_block, no backtrace";
        goto LABEL_34;
      }
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_protocol_metadata_access_handle";
        os_log_type_t v9 = "%{public}s called with null access_block, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
    goto LABEL_35;
  }
  uint64_t v2 = *(void *)(a1 + 32);
  if (!v2) {
    return 0;
  }
  int v3 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);

  return v3(a2, v2);
}

BOOL nw_protocol_metadata_is_tcp(nw_protocol_metadata_t metadata)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = metadata;
  if (v1)
  {
    if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
    }
    BOOL v2 = nw_protocol_metadata_matches_definition((uint64_t)v1, g_tcp_definition);
    goto LABEL_5;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_protocol_metadata_is_tcp";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_metadata_is_tcp";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          char v15 = "nw_protocol_metadata_is_tcp";
          __int16 v16 = 2082;
          char v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_metadata_is_tcp";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_metadata_is_tcp";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_5:

  return v2;
}

void sub_183143C50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_frame_foreach_protocol_metadata(uint64_t a1, int a2, uint64_t a3)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v46 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v21, type, &v46)) {
      goto LABEL_80;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v22 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (!os_log_type_enabled(v22, type[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      uint64_t v24 = "%{public}s called with null frame";
      goto LABEL_79;
    }
    if (v46 == OS_LOG_TYPE_DEFAULT)
    {
      unsigned int v22 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (!os_log_type_enabled(v22, type[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      uint64_t v24 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_79;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    unsigned int v22 = __nwlog_obj();
    os_log_type_t v23 = type[0];
    BOOL v26 = os_log_type_enabled(v22, type[0]);
    if (!backtrace_string)
    {
      if (!v26) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      uint64_t v24 = "%{public}s called with null frame, no backtrace";
      goto LABEL_79;
    }
    if (v26)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_80:
    if (!v21) {
      return;
    }
    goto LABEL_81;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v46 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v21, type, &v46)) {
      goto LABEL_80;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v22 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (!os_log_type_enabled(v22, type[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      uint64_t v24 = "%{public}s called with null block";
      goto LABEL_79;
    }
    if (v46 == OS_LOG_TYPE_DEFAULT)
    {
      unsigned int v22 = __nwlog_obj();
      os_log_type_t v23 = type[0];
      if (!os_log_type_enabled(v22, type[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      uint64_t v24 = "%{public}s called with null block, backtrace limit exceeded";
      goto LABEL_79;
    }
    uint64_t v27 = (char *)__nw_create_backtrace_string();
    unsigned int v22 = __nwlog_obj();
    os_log_type_t v23 = type[0];
    BOOL v28 = os_log_type_enabled(v22, type[0]);
    if (v27)
    {
      if (v28)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v27;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null block, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v27);
      if (!v21) {
        return;
      }
LABEL_81:
      free(v21);
      return;
    }
    if (v28)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "__nw_frame_foreach_protocol_metadata";
      uint64_t v24 = "%{public}s called with null block, no backtrace";
LABEL_79:
      _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0xCu);
      goto LABEL_80;
    }
    goto LABEL_80;
  }
  uint64_t v6 = *(void **)(a1 + 64);
  if (v6)
  {
    char v7 = 0;
    while (1)
    {
      os_log_type_t v8 = (void *)*v6;
      uint64_t v9 = v6[6];
      if (v9)
      {
        if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
          dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
        }
        BOOL v10 = nw_protocol_metadata_matches_definition(v9, g_ip_definition);
        if (!(*(unsigned int (**)(uint64_t, void))(a3 + 16))(a3, v6[6])) {
          return;
        }
        v7 |= v10;
      }
      uint64_t v6 = v8;
      if (!v8) {
        goto LABEL_13;
      }
    }
  }
  char v7 = 0;
LABEL_13:
  if ((v7 & 1) != 0 || !a2) {
    return;
  }
  if ((*(_WORD *)(a1 + 204) & 0x10) != 0) {
    uint64_t v11 = 0;
  }
  else {
    uint64_t v11 = *(void *)(a1 + 152);
  }
  int v12 = *(unsigned __int8 *)(a1 + 185);
  uint64_t v13 = *(unsigned char *)(a1 + 186) & 3;
  if (v11 || v12)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
    }
    singleton = nw_protocol_metadata_create_singleton((void *)g_ip_definition);
    nw_ip_metadata_set_ecn_flag(singleton, (nw_ip_ecn_flag_t)v13);
    __int16 v16 = singleton;
    char v17 = v16;
    if (v16)
    {
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = __nw_ip_metadata_set_receive_time_block_invoke;
      os_log_type_t v48 = &__block_descriptor_40_e9_B16__0_v8l;
      uint64_t v49 = v11;
      Class isa = v16[4].isa;
      if (isa) {
        __nw_ip_metadata_set_receive_time_block_invoke((uint64_t)buf, isa);
      }

      __int16 v19 = v17;
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&buf[8] = 3221225472;
      *(void *)&buf[16] = __nw_ip_metadata_set_hop_limit_block_invoke;
      os_log_type_t v48 = &__block_descriptor_33_e9_B16__0_v8l;
      LOBYTE(v49) = v12;
      uint64_t v20 = (uint64_t)v17[4].isa;
      if (v20) {
        __nw_ip_metadata_set_hop_limit_block_invoke((uint64_t)buf, v20);
      }
      goto LABEL_32;
    }
    uint64_t v29 = __nwlog_obj();
    *(_DWORD *)os_log_type_t type = 136446210;
    BOOL v51 = "nw_ip_metadata_set_receive_time";
    uint64_t v30 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (__nwlog_fault(v30, &v46, &v45))
    {
      if (v46 == OS_LOG_TYPE_FAULT)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v32 = v46;
        if (os_log_type_enabled(v31, v46))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          BOOL v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null metadata", (uint8_t *)type, 0xCu);
        }
LABEL_93:

        goto LABEL_94;
      }
      if (!v45)
      {
        uint64_t v31 = __nwlog_obj();
        os_log_type_t v36 = v46;
        if (os_log_type_enabled(v31, v46))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          BOOL v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl(&dword_1830D4000, v31, v36, "%{public}s called with null metadata, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
        goto LABEL_93;
      }
      os_log_type_t v33 = (char *)__nw_create_backtrace_string();
      uint64_t v31 = __nwlog_obj();
      os_log_type_t v34 = v46;
      BOOL v35 = os_log_type_enabled(v31, v46);
      if (!v33)
      {
        if (v35)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          BOOL v51 = "nw_ip_metadata_set_receive_time";
          _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null metadata, no backtrace", (uint8_t *)type, 0xCu);
        }
        goto LABEL_93;
      }
      if (v35)
      {
        *(_DWORD *)os_log_type_t type = 136446466;
        BOOL v51 = "nw_ip_metadata_set_receive_time";
        __int16 v52 = 2082;
        uint64_t v53 = v33;
        _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null metadata, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
      }

      free(v33);
    }
LABEL_94:
    if (v30) {
      free(v30);
    }
    uint64_t v37 = __nwlog_obj();
    *(_DWORD *)os_log_type_t type = 136446210;
    BOOL v51 = "nw_ip_metadata_set_hop_limit";
    os_log_type_t v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v46 = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault(v38, &v46, &v45)) {
      goto LABEL_112;
    }
    if (v46 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v39 = __nwlog_obj();
      os_log_type_t v40 = v46;
      if (os_log_type_enabled(v39, v46))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        BOOL v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s called with null metadata", (uint8_t *)type, 0xCu);
      }
    }
    else if (v45)
    {
      uint64_t v41 = (char *)__nw_create_backtrace_string();
      uint64_t v39 = __nwlog_obj();
      os_log_type_t v42 = v46;
      BOOL v43 = os_log_type_enabled(v39, v46);
      if (v41)
      {
        if (v43)
        {
          *(_DWORD *)os_log_type_t type = 136446466;
          BOOL v51 = "nw_ip_metadata_set_hop_limit";
          __int16 v52 = 2082;
          uint64_t v53 = v41;
          _os_log_impl(&dword_1830D4000, v39, v42, "%{public}s called with null metadata, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
        }

        free(v41);
        goto LABEL_112;
      }
      if (v43)
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        BOOL v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_1830D4000, v39, v42, "%{public}s called with null metadata, no backtrace", (uint8_t *)type, 0xCu);
      }
    }
    else
    {
      uint64_t v39 = __nwlog_obj();
      os_log_type_t v44 = v46;
      if (os_log_type_enabled(v39, v46))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        BOOL v51 = "nw_ip_metadata_set_hop_limit";
        _os_log_impl(&dword_1830D4000, v39, v44, "%{public}s called with null metadata, backtrace limit exceeded", (uint8_t *)type, 0xCu);
      }
    }

LABEL_112:
    if (v38) {
      free(v38);
    }
LABEL_32:

    (*(void (**)(uint64_t, NSObject *))(a3 + 16))(a3, v17);
    if (!v17) {
      return;
    }
    goto LABEL_44;
  }
  if (v13)
  {
    switch(v13)
    {
      case 1:
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_3;
        os_log_type_t v48 = &__block_descriptor_36_e5_v8__0l;
        LODWORD(v49) = 1;
        if (nw_ip_copy_metadata_for_ecn_flag::onceToken != -1) {
          dispatch_once(&nw_ip_copy_metadata_for_ecn_flag::onceToken, buf);
        }
        BOOL v14 = &nw_ip_copy_metadata_for_ecn_flag::ect_1_metadata;
        break;
      case 2:
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_5;
        os_log_type_t v48 = &__block_descriptor_36_e5_v8__0l;
        LODWORD(v49) = 2;
        if (nw_ip_copy_metadata_for_ecn_flag::onceToken != -1) {
          dispatch_once(&nw_ip_copy_metadata_for_ecn_flag::onceToken, buf);
        }
        BOOL v14 = &nw_ip_copy_metadata_for_ecn_flag::ect_0_metadata;
        break;
      case 3:
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke_7;
        os_log_type_t v48 = &__block_descriptor_36_e5_v8__0l;
        LODWORD(v49) = 3;
        if (nw_ip_copy_metadata_for_ecn_flag::onceToken != -1) {
          dispatch_once(&nw_ip_copy_metadata_for_ecn_flag::onceToken, buf);
        }
        BOOL v14 = &nw_ip_copy_metadata_for_ecn_flag::ce_metadata;
        break;
      default:
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_ip_copy_metadata_for_ecn_flag_block_invoke;
        os_log_type_t v48 = &__block_descriptor_36_e5_v8__0l;
        LODWORD(v49) = 0;
        if (nw_ip_copy_metadata_for_ecn_flag::onceToken != -1) {
          dispatch_once(&nw_ip_copy_metadata_for_ecn_flag::onceToken, buf);
        }
        BOOL v14 = &nw_ip_copy_metadata_for_ecn_flag::non_ect_metadata;
        break;
    }
    char v17 = (id)*v14;
    (*(void (**)(uint64_t, NSObject *))(a3 + 16))(a3, v17);
    if (v17)
    {
LABEL_44:
      os_release(v17);
    }
  }
}

void nw_frame_set_metadata(uint64_t a1, NSObject *object, int a3, int a4)
{
  uint64_t v67 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "__nw_frame_set_metadata";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (!__nwlog_fault(v19, type, &v57)) {
      goto LABEL_70;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v43 = __nwlog_obj();
      os_log_type_t v44 = type[0];
      if (!os_log_type_enabled(v43, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v60 = "__nw_frame_set_metadata";
      unsigned int v22 = "%{public}s called with null frame";
    }
    else if (v57)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v43 = __nwlog_obj();
      os_log_type_t v44 = type[0];
      BOOL v46 = os_log_type_enabled(v43, type[0]);
      if (backtrace_string)
      {
        if (v46)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v60 = "__nw_frame_set_metadata";
          __int16 v61 = 2082;
          uint64_t v62 = (uint64_t)backtrace_string;
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_70;
      }
      if (!v46) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v60 = "__nw_frame_set_metadata";
      unsigned int v22 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      BOOL v43 = __nwlog_obj();
      os_log_type_t v44 = type[0];
      if (!os_log_type_enabled(v43, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v60 = "__nw_frame_set_metadata";
      unsigned int v22 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    os_log_type_t v40 = v43;
    os_log_type_t v41 = v44;
    uint32_t v42 = 12;
    goto LABEL_69;
  }
  if (object)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
    }
    if (!nw_protocol_metadata_matches_definition((uint64_t)object, g_ip_definition)) {
      goto LABEL_14;
    }
    *(unsigned char *)(a1 + 186) = *(unsigned char *)(a1 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(object) & 3;
    dscp_xpc_object_t value = nw_ip_metadata_get_dscp_value(object);
    if (dscp_value < 0x40)
    {
      *(unsigned char *)(a1 + 184) = dscp_value;
LABEL_8:
      nw_service_class_t service_class = nw_ip_metadata_get_service_class(object);
      if (service_class > nw_service_class_signaling) {
        int v10 = 0;
      }
      else {
        int v10 = dword_183D5D290[service_class];
      }
      *(_DWORD *)(a1 + 176) = v10;
      *(_DWORD *)(a1 + 180) = nw_ip_metadata_get_fragmentation_value(object);
LABEL_14:
      uint64_t v11 = a1 + 204;
      if ((*(_WORD *)(a1 + 204) & 8) == 0) {
        goto LABEL_15;
      }
      int v56 = a4;
      os_log_type_t v23 = object;
      *(_OWORD *)os_log_type_t type = *(_OWORD *)&v23[2].isa;

      uint64_t v24 = *(uint64_t **)(a1 + 64);
      if (!v24) {
        goto LABEL_47;
      }
      char v25 = 0;
      if (a4) {
        char v26 = 64;
      }
      else {
        char v26 = 0;
      }
      while (1)
      {
        uint64_t v27 = v23;
        BOOL v28 = v23[1].isa;

        uint64_t v29 = (void *)v24[6];
        if (v29)
        {
          uint64_t v30 = v29;
          id v31 = v30[1];

          if (nw_protocol_definition_is_equal_unsafe((uint64_t)v28, (uint64_t)v31)
            && !uuid_compare((const unsigned __int8 *)type, (const unsigned __int8 *)v24 + 16))
          {
            os_retain(v27);
            os_log_type_t v32 = (void *)v24[6];
            if (v32) {
              os_release(v32);
            }
            v24[6] = (uint64_t)v27;
            *((unsigned char *)v24 + 66) = *((unsigned char *)v24 + 66) & 0xBF | v26;
            char v25 = 1;
            if (!v31) {
              goto LABEL_40;
            }
LABEL_39:
            os_release(v31);
            goto LABEL_40;
          }
          if (v31) {
            goto LABEL_39;
          }
        }
LABEL_40:
        if (v28) {
          os_release(v28);
        }
        uint64_t v24 = (uint64_t *)*v24;
        if (!v24)
        {
          if ((v25 & 1) == 0)
          {
LABEL_47:
            os_log_type_t v33 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
            if (v33) {
              goto LABEL_48;
            }
            BOOL v51 = __nwlog_obj();
            os_log_type_enabled(v51, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446722;
            os_log_type_t v60 = "strict_calloc";
            __int16 v61 = 2048;
            uint64_t v62 = 1;
            __int16 v63 = 2048;
            uint64_t v64 = 72;
            __int16 v52 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort((uint64_t)v52))
            {
              __break(1u);
            }
            else
            {
              free(v52);
LABEL_48:
              v33[6] = os_retain(v23);
              *((_OWORD *)v33 + 1) = *(_OWORD *)type;
              if (v56) {
                char v34 = 64;
              }
              else {
                char v34 = 0;
              }
              *((unsigned char *)v33 + 66) = *((unsigned char *)v33 + 66) & 0xBF | v34;
              if (a3)
              {
                uint64_t v35 = *(void *)(a1 + 64);
                void *v33 = v35;
                if (v35) {
                  os_log_type_t v36 = (void *)(v35 + 8);
                }
                else {
                  os_log_type_t v36 = (void *)(a1 + 72);
                }
                void *v36 = v33;
                *(void *)(a1 + 64) = v33;
                v33[1] = a1 + 64;
              }
              else
              {
                void *v33 = 0;
                uint64_t v37 = *(void **)(a1 + 72);
                v33[1] = v37;
                void *v37 = v33;
                *(void *)(a1 + 72) = v33;
              }
            }
          }
          return;
        }
      }
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v60 = "__nw_frame_set_dscp_value";
    uint64_t v47 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (__nwlog_fault(v47, type, &v57))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v48 = __nwlog_obj();
        os_log_type_t v49 = type[0];
        if (!os_log_type_enabled(v48, type[0])) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "__nw_frame_set_dscp_value";
        uint64_t v50 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
        goto LABEL_102;
      }
      int v53 = a4;
      if (!v57)
      {
        os_log_type_t v48 = __nwlog_obj();
        os_log_type_t v49 = type[0];
        if (!os_log_type_enabled(v48, type[0])) {
          goto LABEL_103;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "__nw_frame_set_dscp_value";
        uint64_t v50 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
        goto LABEL_102;
      }
      uint64_t v54 = (char *)__nw_create_backtrace_string();
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v49 = type[0];
      BOOL v55 = os_log_type_enabled(v48, type[0]);
      if (v54)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v60 = "__nw_frame_set_dscp_value";
          __int16 v61 = 2082;
          uint64_t v62 = (uint64_t)v54;
          _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v54);
        a4 = v53;
        goto LABEL_103;
      }
      a4 = v53;
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v60 = "__nw_frame_set_dscp_value";
        uint64_t v50 = "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace";
LABEL_102:
        _os_log_impl(&dword_1830D4000, v48, v49, v50, buf, 0xCu);
      }
    }
LABEL_103:
    if (v47) {
      free(v47);
    }
    goto LABEL_8;
  }
  uint64_t v11 = a1 + 204;
  if ((*(_WORD *)(a1 + 204) & 8) != 0) {
    return;
  }
LABEL_15:
  int v12 = *(void **)(a1 + 168);
  if (v12)
  {
    os_release(v12);
    *(void *)(a1 + 168) = 0;
  }
  if (object)
  {
    *(void *)(a1 + 168) = os_retain(object);
    int v13 = *(unsigned __int16 *)(a1 + 204);
    int v14 = v13 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v13 & 0x20) == 0)
    {
      char v15 = object;
      *(_OWORD *)(a1 + 136) = *(_OWORD *)&v15[2].isa;

      int v14 = *(unsigned __int16 *)(a1 + 204) | (*(unsigned __int8 *)(a1 + 206) << 16);
    }
    *(unsigned char *)(v11 + 2) = BYTE2(v14);
    *(_WORD *)uint64_t v11 = v14 | 8;
  }
  uint64_t v16 = a1 + 120;
  uint64_t v17 = *(void *)(a1 + 64);
  if (a4) {
    char v18 = 64;
  }
  else {
    char v18 = 0;
  }
  *(unsigned char *)(a1 + 186) = *(unsigned char *)(a1 + 186) & 0xBF | v18;
  if (!v17)
  {
    *(void *)(a1 + 64) = v16;
    *(void *)(a1 + 72) = v16;
    *(void *)(a1 + 120) = 0;
    *(void *)(a1 + 128) = a1 + 64;
    return;
  }
  if (v17 != v16)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446722;
    os_log_type_t v60 = "__nw_frame_set_metadata";
    __int16 v61 = 2048;
    uint64_t v62 = v17;
    __int16 v63 = 2048;
    uint64_t v64 = a1 + 120;
    __int16 v19 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v57 = 0;
    if (!__nwlog_fault(v19, type, &v57)) {
      goto LABEL_70;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = gLogObj;
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v60 = "__nw_frame_set_metadata";
      __int16 v61 = 2048;
      uint64_t v62 = v17;
      __int16 v63 = 2048;
      uint64_t v64 = v16;
      unsigned int v22 = "%{public}s Existing metadata %p doesn't match expected %p";
      goto LABEL_68;
    }
    if (!v57)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v20 = gLogObj;
      os_log_type_t v21 = type[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
        goto LABEL_70;
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v60 = "__nw_frame_set_metadata";
      __int16 v61 = 2048;
      uint64_t v62 = v17;
      __int16 v63 = 2048;
      uint64_t v64 = v16;
      unsigned int v22 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
      goto LABEL_68;
    }
    os_log_type_t v38 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = gLogObj;
    os_log_type_t v21 = type[0];
    BOOL v39 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
    if (v38)
    {
      if (v39)
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v60 = "__nw_frame_set_metadata";
        __int16 v61 = 2048;
        uint64_t v62 = v17;
        __int16 v63 = 2048;
        uint64_t v64 = v16;
        __int16 v65 = 2082;
        unsigned int v66 = v38;
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v38);
      if (!v19) {
        return;
      }
LABEL_71:
      free(v19);
      return;
    }
    if (v39)
    {
      *(_DWORD *)buf = 136446722;
      os_log_type_t v60 = "__nw_frame_set_metadata";
      __int16 v61 = 2048;
      uint64_t v62 = v17;
      __int16 v63 = 2048;
      uint64_t v64 = v16;
      unsigned int v22 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
LABEL_68:
      os_log_type_t v40 = v20;
      os_log_type_t v41 = v21;
      uint32_t v42 = 32;
LABEL_69:
      _os_log_impl(&dword_1830D4000, v40, v41, v22, buf, v42);
    }
LABEL_70:
    if (!v19) {
      return;
    }
    goto LABEL_71;
  }
}

BOOL nw_protocol_metadata_matches_definition(uint64_t a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_metadata_matches_definition";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_metadata_matches_definition";
        os_log_type_t v8 = "%{public}s called with null metadata";
LABEL_33:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_protocol_metadata_matches_definition";
          __int16 v18 = 2082;
          __int16 v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v5) {
          return 0;
        }
LABEL_36:
        free(v5);
        return 0;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_metadata_matches_definition";
        os_log_type_t v8 = "%{public}s called with null metadata, no backtrace";
        goto LABEL_33;
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_metadata_matches_definition";
        os_log_type_t v8 = "%{public}s called with null metadata, backtrace limit exceeded";
        goto LABEL_33;
      }
    }
LABEL_34:

    goto LABEL_35;
  }
  if (!a2)
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_protocol_metadata_matches_definition";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_metadata_matches_definition";
        os_log_type_t v8 = "%{public}s called with null definition";
        goto LABEL_33;
      }
    }
    else
    {
      if (v14)
      {
        int v12 = (char *)__nw_create_backtrace_string();
        uint64_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v13 = os_log_type_enabled(v6, type);
        if (v12)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v17 = "nw_protocol_metadata_matches_definition";
            __int16 v18 = 2082;
            __int16 v19 = v12;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v12);
          if (!v5) {
            return 0;
          }
          goto LABEL_36;
        }
        if (!v13) {
          goto LABEL_34;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_metadata_matches_definition";
        os_log_type_t v8 = "%{public}s called with null definition, no backtrace";
        goto LABEL_33;
      }
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_protocol_metadata_matches_definition";
        os_log_type_t v8 = "%{public}s called with null definition, backtrace limit exceeded";
        goto LABEL_33;
      }
    }
    goto LABEL_34;
  }
  uint64_t v2 = *(void *)(a1 + 8);

  return nw_protocol_definition_is_equal_unsafe(v2, a2);
}

uint64_t ___ZL28nw_flow_process_input_framesP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sbbb_block_invoke_82(uint64_t a1, void *a2)
{
  int v3 = a2;
  uint64_t v4 = v3;
  if (*(void *)(*(void *)(a1 + 48) + 232))
  {
    if (*(void *)(*(void *)(a1 + 32) + 768))
    {
      nw_protocol_definition_t v5 = nw_protocol_metadata_copy_definition(v3);
      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, *(void *)(*(void *)(a1 + 32) + 768));

      if (is_equal_unsafe) {
        nw_protocol_metadata_set_original(v4, *(void **)(*(void *)(a1 + 48) + 232));
      }
    }
  }
  nw_content_context_set_metadata_for_protocol(*(nw_content_context_t *)(a1 + 40), v4);

  return 1;
}

void sub_18314579C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_content_context_set_metadata_for_protocol(nw_content_context_t context, nw_protocol_metadata_t protocol_metadata)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  uint64_t v4 = protocol_metadata;
  nw_protocol_definition_t v5 = v4;
  if (!v3)
  {
    int v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v37) = 0;
    if (!__nwlog_fault(v13, type, &v37)) {
      goto LABEL_53;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v14 = __nwlog_obj();
      os_log_type_t v15 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if ((_BYTE)v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v14 = __nwlog_obj();
      os_log_type_t v19 = type[0];
      BOOL v20 = os_log_type_enabled(v14, type[0]);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_53:
        if (!v13) {
          goto LABEL_19;
        }
LABEL_54:
        free(v13);
        goto LABEL_19;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v14 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v14, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
        _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  if (v4)
  {
    if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
      && v3 != (nw_content_context_t)&__block_literal_global_8_42267
      && v3 != (nw_content_context_t)&__block_literal_global_6_42258
      && v3 != (nw_content_context_t)&__block_literal_global_42249)
    {
      os_unfair_lock_lock((os_unfair_lock_t)&v3[14]);
      uint64_t v37 = 0;
      os_log_type_t v38 = &v37;
      uint64_t v39 = 0x2020000000;
      char v40 = 0;
      *(void *)buf = 0;
      *(void *)&buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      uint32_t v42 = __Block_byref_object_copy__42473;
      BOOL v43 = __Block_byref_object_dispose__42474;
      id v44 = 0;
      *(void *)os_log_type_t type = 0;
      os_log_type_t v32 = type;
      uint64_t v33 = 0x3032000000;
      char v34 = __Block_byref_object_copy__42473;
      uint64_t v35 = __Block_byref_object_dispose__42474;
      id v36 = 0;
      Class isa = (atomic_uchar *)v3[11].isa;
      v26[0] = MEMORY[0x1E4F143A8];
      v26[1] = 3221225472;
      v26[2] = __nw_content_context_set_metadata_for_protocol_block_invoke;
      v26[3] = &unk_1E5241BB8;
      os_log_type_t v7 = v5;
      uint64_t v27 = v7;
      BOOL v28 = &v37;
      uint64_t v29 = type;
      uint64_t v30 = buf;
      nw_array_apply(isa, (uint64_t)v26);
      if (*((unsigned char *)v38 + 24))
      {
        os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
      }
      else
      {
        os_log_type_t v8 = (void ***)v3[11].isa;
        uint64_t v9 = (void ***)nw_array_create();
        int v10 = v9;
        if (v8)
        {
          if (v9 == v8) {
            int v10 = v8;
          }
          else {
            std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>((uint64_t)(v9 + 2), v8[2], v8[3], v8[3] - v8[2]);
          }
          uint64_t v11 = *(void *)(*(void *)&buf[8] + 40);
          if (v11) {
            nw_array_remove_object((uint64_t)v10, v11);
          }
        }
        nw_array_append((uint64_t)v10, v7);
        objc_storeStrong((id *)&v3[11].isa, v10);
        if (nw_protocol_metadata_supports_replies(v7)) {
          BYTE6(v3[14].isa) |= 0x40u;
        }
        os_unfair_lock_unlock((os_unfair_lock_t)&v3[14]);
      }
      _Block_object_dispose(type, 8);

      _Block_object_dispose(buf, 8);
      _Block_object_dispose(&v37, 8);
    }
    goto LABEL_19;
  }
  uint64_t v16 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
  BOOL v13 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v37) = 0;
  if (!__nwlog_fault(v13, type, &v37)) {
    goto LABEL_53;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    char v14 = __nwlog_obj();
    os_log_type_t v17 = type[0];
    if (os_log_type_enabled(v14, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null protocol_metadata", buf, 0xCu);
    }
    goto LABEL_52;
  }
  if (!(_BYTE)v37)
  {
    char v14 = __nwlog_obj();
    os_log_type_t v25 = type[0];
    if (os_log_type_enabled(v14, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
      _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null protocol_metadata, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_52;
  }
  os_log_type_t v21 = (char *)__nw_create_backtrace_string();
  char v14 = __nwlog_obj();
  os_log_type_t v22 = type[0];
  BOOL v23 = os_log_type_enabled(v14, type[0]);
  if (!v21)
  {
    if (v23)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
      _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s called with null protocol_metadata, no backtrace", buf, 0xCu);
    }
    goto LABEL_52;
  }
  if (v23)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_content_context_set_metadata_for_protocol";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v21;
    _os_log_impl(&dword_1830D4000, v14, v22, "%{public}s called with null protocol_metadata, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v21);
  if (v13) {
    goto LABEL_54;
  }
LABEL_19:
}

uint64_t nw_protocol_metadata_supports_replies(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 1);
    if (v3)
    {
      uint64_t v4 = (*(unsigned __int8 *)(v3 + 184) >> 1) & 1;
      goto LABEL_4;
    }
    int v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null metadata->definition", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v19)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null metadata->definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null metadata->definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
        __int16 v23 = 2082;
        os_log_type_t v24 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v15, "%{public}s called with null metadata->definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
    os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v7, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v19)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (!backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v22 = "nw_protocol_metadata_supports_replies";
        __int16 v23 = 2082;
        os_log_type_t v24 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v7) {
    free(v7);
  }
  uint64_t v4 = 0;
LABEL_4:

  return v4;
}

uint64_t __nw_tcp_set_callbacks_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  *(void *)(a2 + 48) = *(void *)(a1 + 32);
  nw_protocol_definition_t v5 = *(long long **)(a1 + 40);
  if (v5)
  {
    long long v6 = *v5;
    long long v7 = v5[2];
    *(_OWORD *)(a2 + 16) = v5[1];
    *(_OWORD *)(a2 + 32) = v7;
  }
  else
  {
    long long v6 = 0uLL;
    *(_OWORD *)(a2 + 16) = 0u;
    *(_OWORD *)(a2 + 32) = 0u;
  }
  *(_OWORD *)a2 = v6;
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_tcp_set_no_wake_from_sleep_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 56);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 56));
  nw_protocol_definition_t v5 = *(uint64_t (**)(void, void))(a2 + 40);
  if (v5) {
    *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = v5(*(void *)(a2 + 48), *(unsigned __int8 *)(a1 + 40));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

void ___ZL29nw_flow_prepare_output_framesP27NWConcrete_nw_endpoint_flowP11nw_protocolP16nw_frame_array_sjP30nw_protocol_message_properties_block_invoke_88(uint64_t a1, int a2, NSObject *object)
{
}

BOOL nw_array_remove_object(uint64_t a1, uint64_t a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_array_remove_object";
    long long v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_51;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v23)
      {
        BOOL v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (!os_log_type_enabled(v16, type)) {
          goto LABEL_51;
        }
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_array_remove_object";
        os_log_type_t v18 = "%{public}s called with null array, backtrace limit exceeded";
        goto LABEL_50;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v20 = os_log_type_enabled(v16, type);
      if (!backtrace_string)
      {
        if (!v20) {
          goto LABEL_51;
        }
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_array_remove_object";
        os_log_type_t v18 = "%{public}s called with null array, no backtrace";
        goto LABEL_50;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        char v26 = "nw_array_remove_object";
        __int16 v27 = 2082;
        BOOL v28 = backtrace_string;
        os_log_type_t v21 = "%{public}s called with null array, dumping backtrace:%{public}s";
LABEL_40:
        _os_log_impl(&dword_1830D4000, v16, v17, v21, buf, 0x16u);
      }
LABEL_41:
      free(backtrace_string);
      goto LABEL_51;
    }
    BOOL v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    if (!os_log_type_enabled(v16, type)) {
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_array_remove_object";
    os_log_type_t v18 = "%{public}s called with null array";
LABEL_50:
    _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0xCu);
LABEL_51:
    if (!v7) {
      return 0;
    }
    goto LABEL_10;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_array_remove_object";
    long long v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &type, &v23)) {
      goto LABEL_51;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_array_remove_object";
      os_log_type_t v18 = "%{public}s called with null object";
      goto LABEL_50;
    }
    if (!v23)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      char v26 = "nw_array_remove_object";
      os_log_type_t v18 = "%{public}s called with null object, backtrace limit exceeded";
      goto LABEL_50;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v22 = os_log_type_enabled(v16, type);
    if (backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        char v26 = "nw_array_remove_object";
        __int16 v27 = 2082;
        BOOL v28 = backtrace_string;
        os_log_type_t v21 = "%{public}s called with null object, dumping backtrace:%{public}s";
        goto LABEL_40;
      }
      goto LABEL_41;
    }
    if (!v22) {
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_array_remove_object";
    os_log_type_t v18 = "%{public}s called with null object, no backtrace";
    goto LABEL_50;
  }
  uint64_t v4 = *(void *)(a1 + 16);
  uint64_t v3 = *(void *)(a1 + 24);
  if (v4 != v3)
  {
    while (*(void *)v4 != a2)
    {
      v4 += 8;
      if (v4 == v3)
      {
        uint64_t v4 = *(void *)(a1 + 24);
        break;
      }
    }
  }
  if (v4 == v3) {
    return 0;
  }
  int v5 = a1 + 40;
  LOBYTE(v5) = atomic_load_explicit((atomic_uchar *volatile)(a1 + 40), memory_order_acquire);
  if (!v5)
  {
    uint64_t v9 = v4 + 8;
    uint64_t v10 = *(void *)(a1 + 24);
    if (v4 + 8 == v10)
    {
      if (v9 == v4)
      {
LABEL_23:
        *(void *)(a1 + 24) = v4;
        return 1;
      }
    }
    else
    {
      do
      {
        if (*(void *)v4) {
          os_release(*(void **)v4);
        }
        uint64_t v11 = v4 + 8;
        *(void *)uint64_t v4 = *(void *)(v4 + 8);
        *(void *)(v4 + 8) = 0;
        uint64_t v12 = v4 + 16;
        v4 += 8;
      }
      while (v12 != v10);
      uint64_t v9 = *(void *)(a1 + 24);
      uint64_t v4 = v11;
      if (v9 == v11) {
        goto LABEL_23;
      }
    }
    uint64_t v13 = v9;
    do
    {
      os_log_type_t v15 = *(void **)(v13 - 8);
      v13 -= 8;
      BOOL v14 = v15;
      if (v15) {
        os_release(v14);
      }
      *(void *)(v9 - 8) = 0;
      uint64_t v9 = v13;
    }
    while (v13 != v4);
    goto LABEL_23;
  }
  uint64_t v6 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v6);
  os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  char v26 = "nw_array_remove_object";
  long long v7 = (char *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
LABEL_10:
    free(v7);
    return 0;
  }
  __break(1u);
  return result;
}

void nw_path_enumerate_interface_options(void *a1, void *a2)
{
  id v3 = a2;
  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = __nw_path_enumerate_interface_options_block_invoke;
  v5[3] = &unk_1E5248238;
  id v6 = v3;
  id v4 = v3;
  nw_path_enumerate_interface_options_with_details(a1, v5);
}

void sub_183146A14(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_path_enumerate_interface_options_with_details(void *a1, void *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  int v5 = (void (**)(void, void))v4;
  if (!v3)
  {
    BOOL v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
    os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v39) = 16;
    char v30 = 0;
    if (!__nwlog_fault(v15, &v39, &v30)) {
      goto LABEL_53;
    }
    if (v39 == 17)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = v39;
      if (os_log_type_enabled(v16, (os_log_type_t)v39))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v16 = __nwlog_obj();
      os_log_type_t v21 = v39;
      BOOL v22 = os_log_type_enabled(v16, (os_log_type_t)v39);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
          __int16 v33 = 2082;
          char v34 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_53:
        if (!v15) {
          goto LABEL_19;
        }
LABEL_54:
        free(v15);
        goto LABEL_19;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
        _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v26 = v39;
      if (os_log_type_enabled(v16, (os_log_type_t)v39))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
        _os_log_impl(&dword_1830D4000, v16, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_52:

    goto LABEL_53;
  }
  if (v4)
  {
    if (v3[86])
    {
      uint64_t v6 = 0;
      unint64_t v7 = 0;
      do
      {
        uint64_t v8 = *((void *)v3 + 38);
        long long v39 = 0uLL;
        if (nw_path_can_use_channel_syscalls(void)::onceToken != -1) {
          dispatch_once(&nw_path_can_use_channel_syscalls(void)::onceToken, &__block_literal_global_494);
        }
        if (nw_path_can_use_channel_syscalls(void)::can_use_channel_syscalls == 1) {
          long long v39 = *(_OWORD *)(v8 + v6 + 8);
        }
        id v9 = nw_parameters_copy_context(*((void **)v3 + 2));
        uint64_t v10 = nw_path_copy_interface_with_generation(v9, *(_DWORD *)(v8 + v6), *(_DWORD *)(v8 + v6 + 4));

        if (!v10 || (nw_path_interface_prohibited_by_parameters(v3, v10) & 1) == 0)
        {
          uint64_t v11 = nw_interface_option_details_create(v10, &v39, 0, 0, 0, -1);
          if (v11)
          {
            ((void (**)(void, NWConcrete_nw_interface_option_details *))v5)[2](v5, v11);
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v12 = (id)gLogObj;
            if (os_log_type_enabled(v12, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
              __int16 v33 = 2112;
              char v34 = v10;
              __int16 v35 = 1042;
              int v36 = 16;
              __int16 v37 = 2098;
              os_log_type_t v38 = &v39;
              _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, "%{public}s Unable to create interface option details with %@ [%{public,uuid_t}.16P]", buf, 0x26u);
            }
          }
        }

        ++v7;
        v6 += 24;
      }
      while (v7 < v3[86]);
    }
    uint64_t v13 = (atomic_uchar *)*((void *)v3 + 25);
    v28[0] = MEMORY[0x1E4F143A8];
    v28[1] = 3221225472;
    void v28[2] = __nw_path_enumerate_interface_options_with_details_block_invoke;
    v28[3] = &unk_1E524AE90;
    uint64_t v29 = v5;
    nw_array_apply(v13, (uint64_t)v28);

    goto LABEL_19;
  }
  os_log_type_t v18 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
  os_log_type_t v15 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v39) = 16;
  char v30 = 0;
  if (!__nwlog_fault(v15, &v39, &v30)) {
    goto LABEL_53;
  }
  if (v39 == 17)
  {
    BOOL v16 = __nwlog_obj();
    os_log_type_t v19 = v39;
    if (os_log_type_enabled(v16, (os_log_type_t)v39))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
      _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null enumerate_block", buf, 0xCu);
    }
    goto LABEL_52;
  }
  if (!v30)
  {
    BOOL v16 = __nwlog_obj();
    os_log_type_t v27 = v39;
    if (os_log_type_enabled(v16, (os_log_type_t)v39))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
      _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s called with null enumerate_block, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_52;
  }
  char v23 = (char *)__nw_create_backtrace_string();
  BOOL v16 = __nwlog_obj();
  os_log_type_t v24 = v39;
  BOOL v25 = os_log_type_enabled(v16, (os_log_type_t)v39);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
      _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s called with null enumerate_block, no backtrace", buf, 0xCu);
    }
    goto LABEL_52;
  }
  if (v25)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v32 = "nw_path_enumerate_interface_options_with_details";
    __int16 v33 = 2082;
    char v34 = v23;
    _os_log_impl(&dword_1830D4000, v16, v24, "%{public}s called with null enumerate_block, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v15) {
    goto LABEL_54;
  }
LABEL_19:
}

void sub_1831470C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_interface_prohibited_by_parameters(void *a1, void *a2)
{
  uint64_t v85 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (v3)
  {
    if (v4)
    {
      id v6 = v3[2];
      unint64_t v7 = v6;
      if (v6)
      {
        uint64_t v8 = v6;
        __int16 v9 = *(_WORD *)(v8[13] + 100);

        if (v9 & 1) != 0 && (v10 = v5, __int16 v11 = *(_WORD *)(v10 + 85), v10, (v11))
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v28 = (id)gLogObj;
          if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            *(_WORD *)&unsigned char buf[12] = 2112;
            *(void *)&buf[14] = v10;
            _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, "%{public}s Expensive prohibited, cannot use interface option %@", buf, 0x16u);
          }
        }
        else
        {
          uint64_t v12 = v8;
          __int16 v13 = *(_WORD *)(v8[13] + 100);

          if ((v13 & 2) != 0 && (BOOL v14 = v5, v15 = *(_WORD *)(v14 + 85), v14, (v15 & 2) != 0))
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v28 = (id)gLogObj;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
              *(_WORD *)&unsigned char buf[12] = 2112;
              *(void *)&buf[14] = v14;
              _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, "%{public}s Constrained prohibited, cannot use interface option %@", buf, 0x16u);
            }
          }
          else
          {
            BOOL v16 = v12;
            __int16 v17 = *(_WORD *)(v8[13] + 100);

            if ((v17 & 4) != 0) {
              goto LABEL_13;
            }
            os_log_type_t v18 = v5;
            __int16 v19 = *(_WORD *)(v18 + 85);

            if ((v19 & 4) == 0) {
              goto LABEL_13;
            }
            if (nw_path_is_ultra_constrained_allowed(void)::onceToken != -1) {
              dispatch_once(&nw_path_is_ultra_constrained_allowed(void)::onceToken, &__block_literal_global_491);
            }
            if (nw_path_is_ultra_constrained_allowed(void)::is_allowed)
            {
LABEL_13:
              *(void *)buf = 0;
              *(void *)&buf[8] = buf;
              *(void *)&buf[16] = 0x2020000000;
              char v84 = 0;
              BOOL v20 = v16;
              os_log_type_t v21 = *(xpc_object_t **)(v8[13] + 176);
              id v22 = v20;
              if (!v21) {
                goto LABEL_30;
              }
              id v22 = v20;
              if (!*v21) {
                goto LABEL_30;
              }
              BOOL v23 = xpc_array_get_count(*v21) == 0;

              if (v23) {
                goto LABEL_31;
              }
              os_log_type_t v24 = v20;
              BOOL v25 = *(id **)(v8[13] + 176);
              if (v25)
              {
                id v22 = *v25;

                if (!v22)
                {
LABEL_30:

LABEL_31:
                  if (*(unsigned char *)(*(void *)&buf[8] + 24)) {
                    goto LABEL_50;
                  }
                  if (!nw_parameters_has_prohibited_interface_subtypes(v20))
                  {
LABEL_39:
                    if (*(unsigned char *)(*(void *)&buf[8] + 24)) {
                      goto LABEL_50;
                    }
                    __int16 v35 = v20;
                    uint64_t v36 = *(void *)(v8[13] + 176);
                    id v37 = v35;
                    if (!v36) {
                      goto LABEL_48;
                    }
                    os_log_type_t v38 = *(void **)(v36 + 24);
                    id v37 = v35;
                    if (!v38) {
                      goto LABEL_48;
                    }
                    BOOL v39 = xpc_array_get_count(v38) == 0;

                    if (v39) {
                      goto LABEL_49;
                    }
                    uint64_t v40 = v35;
                    uint64_t v41 = *(void *)(v8[13] + 176);
                    if (v41)
                    {
                      id v37 = *(id *)(v41 + 24);

                      if (!v37)
                      {
LABEL_48:

LABEL_49:
                        if (!*(unsigned char *)(*(void *)&buf[8] + 24))
                        {
                          BOOL v43 = v5;
                          int v44 = v43[25];

                          if (v44 == 1002 && (nw_parameters_get_use_awdl(v35) & 1) == 0)
                          {
                            uint64_t v45 = __nwlog_obj();
                            if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
                            {
                              *(_DWORD *)int v79 = 136446466;
                              unsigned int v80 = "nw_path_interface_prohibited_by_parameters";
                              __int16 v81 = 2112;
                              uint64_t v82 = v43;
                              _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_DEBUG, "%{public}s Interface %@ prohibited, cannot use interface option", v79, 0x16u);
                            }
                          }
                          uint64_t v29 = 0;
                          goto LABEL_51;
                        }
LABEL_50:
                        uint64_t v29 = 1;
LABEL_51:
                        _Block_object_dispose(buf, 8);
                        goto LABEL_52;
                      }
                      v67[0] = MEMORY[0x1E4F143A8];
                      v67[1] = 3221225472;
                      v67[2] = __nw_path_interface_prohibited_by_parameters_block_invoke_398;
                      v67[3] = &unk_1E5248210;
                      uint64_t v68 = v5;
                      __int16 v69 = buf;
                      xpc_array_apply(v37, v67);
                      uint64_t v40 = v68;
                    }
                    else
                    {
                      id v37 = 0;
                    }

                    goto LABEL_48;
                  }
                  char v30 = v20;
                  uint64_t v31 = *(void *)(v8[13] + 176);
                  if (v31)
                  {
                    id v32 = *(id *)(v31 + 8);

                    if (!v32)
                    {
LABEL_38:

                      goto LABEL_39;
                    }
                    __int16 v33 = v5;
                    int v34 = v33[25];

                    v70[0] = MEMORY[0x1E4F143A8];
                    v70[1] = 3221225472;
                    v70[2] = __nw_path_interface_prohibited_by_parameters_block_invoke_397;
                    v70[3] = &unk_1E52481E8;
                    int v73 = v34;
                    __int16 v71 = v33;
                    os_log_type_t v72 = buf;
                    xpc_array_apply(v32, v70);
                    char v30 = v71;
                  }
                  else
                  {
                    id v32 = 0;
                  }

                  goto LABEL_38;
                }
                os_log_type_t v26 = v5;
                int v27 = v26[24];

                applier[0] = MEMORY[0x1E4F143A8];
                applier[1] = 3221225472;
                applier[2] = __nw_path_interface_prohibited_by_parameters_block_invoke;
                applier[3] = &unk_1E52481E8;
                int v77 = v27;
                BOOL v75 = v26;
                os_log_type_t v76 = buf;
                xpc_array_apply(v22, applier);
                os_log_type_t v24 = v75;
              }
              else
              {
                id v22 = 0;
              }

              goto LABEL_30;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v28 = (id)gLogObj;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
              *(_WORD *)&unsigned char buf[12] = 2112;
              *(void *)&buf[14] = v18;
              _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEBUG, "%{public}s Ultra constrained not allowed, cannot use interface option %@", buf, 0x16u);
            }
          }
        }

        uint64_t v29 = 1;
LABEL_52:

        goto LABEL_53;
      }
      __int16 v52 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
      int v53 = (char *)_os_log_send_and_compose_impl();

      v79[0] = 16;
      char v78 = 0;
      if (__nwlog_fault(v53, v79, &v78))
      {
        if (v79[0] == 17)
        {
          uint64_t v54 = __nwlog_obj();
          os_log_type_t v55 = v79[0];
          if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s called with null parameters", buf, 0xCu);
          }
        }
        else if (v78)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v54 = __nwlog_obj();
          os_log_type_t v62 = v79[0];
          BOOL v63 = os_log_type_enabled(v54, (os_log_type_t)v79[0]);
          if (backtrace_string)
          {
            if (v63)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v54, v62, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_111;
          }
          if (v63)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_1830D4000, v54, v62, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v54 = __nwlog_obj();
          os_log_type_t v66 = v79[0];
          if (os_log_type_enabled(v54, (os_log_type_t)v79[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
            _os_log_impl(&dword_1830D4000, v54, v66, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_111:
      if (v53) {
        free(v53);
      }
      uint64_t v29 = 0;
      goto LABEL_52;
    }
    uint64_t v50 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
    uint64_t v47 = (char *)_os_log_send_and_compose_impl();

    v79[0] = 16;
    char v78 = 0;
    if (__nwlog_fault(v47, v79, &v78))
    {
      if (v79[0] == 17)
      {
        os_log_type_t v48 = __nwlog_obj();
        os_log_type_t v51 = v79[0];
        if (os_log_type_enabled(v48, (os_log_type_t)v79[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_1830D4000, v48, v51, "%{public}s called with null interface", buf, 0xCu);
        }
LABEL_104:

        goto LABEL_105;
      }
      if (!v78)
      {
        os_log_type_t v48 = __nwlog_obj();
        os_log_type_t v65 = v79[0];
        if (os_log_type_enabled(v48, (os_log_type_t)v79[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_1830D4000, v48, v65, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_104;
      }
      int v56 = (char *)__nw_create_backtrace_string();
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v59 = v79[0];
      BOOL v60 = os_log_type_enabled(v48, (os_log_type_t)v79[0]);
      if (!v56)
      {
        if (v60)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_1830D4000, v48, v59, "%{public}s called with null interface, no backtrace", buf, 0xCu);
        }
        goto LABEL_104;
      }
      if (v60)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v56;
        _os_log_impl(&dword_1830D4000, v48, v59, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_84;
    }
  }
  else
  {
    BOOL v46 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
    uint64_t v47 = (char *)_os_log_send_and_compose_impl();

    v79[0] = 16;
    char v78 = 0;
    if (__nwlog_fault(v47, v79, &v78))
    {
      if (v79[0] == 17)
      {
        os_log_type_t v48 = __nwlog_obj();
        os_log_type_t v49 = v79[0];
        if (os_log_type_enabled(v48, (os_log_type_t)v79[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null path", buf, 0xCu);
        }
        goto LABEL_104;
      }
      if (!v78)
      {
        os_log_type_t v48 = __nwlog_obj();
        os_log_type_t v64 = v79[0];
        if (os_log_type_enabled(v48, (os_log_type_t)v79[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_1830D4000, v48, v64, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_104;
      }
      int v56 = (char *)__nw_create_backtrace_string();
      os_log_type_t v48 = __nwlog_obj();
      os_log_type_t v57 = v79[0];
      BOOL v58 = os_log_type_enabled(v48, (os_log_type_t)v79[0]);
      if (!v56)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
          _os_log_impl(&dword_1830D4000, v48, v57, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
        goto LABEL_104;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_path_interface_prohibited_by_parameters";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v56;
        _os_log_impl(&dword_1830D4000, v48, v57, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_84:

      free(v56);
    }
  }
LABEL_105:
  if (v47) {
    free(v47);
  }
  uint64_t v29 = 0;
LABEL_53:

  return v29;
}

void sub_183147D6C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Block_object_dispose((const void *)(v21 - 128), 8);
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_prohibited_interface_subtypes(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v20 = "nw_parameters_has_prohibited_interface_subtypes";
    __int16 v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v20 = "nw_parameters_has_prohibited_interface_subtypes";
            __int16 v21 = 2082;
            id v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v20 = "nw_parameters_has_prohibited_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_28:
    if (v9) {
      free(v9);
    }
    goto LABEL_30;
  }
  uint64_t v3 = *(void *)(v1[13] + 176);
  if (!v3)
  {
LABEL_30:
    BOOL v5 = 0;
    goto LABEL_31;
  }
  id v4 = *(void **)(v3 + 8);
  if (v4 && xpc_array_get_count(v4))
  {
    BOOL v5 = 1;
  }
  else
  {
    id v6 = v2;
    uint64_t v7 = v2[13];
    BOOL v5 = (*(_WORD *)(v7 + 108) & 8) == 0 && !*(_DWORD *)(v7 + 80) && !*(void *)(v7 + 168) && (v6[97] & 0x80) == 0;
  }
LABEL_31:

  return v5;
}

void sub_1831480E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_interface_option_details *nw_interface_option_details_create(void *a1, _OWORD *a2, void *a3, char a4, void *a5, int a6)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  id v12 = a1;
  id v13 = a3;
  id v14 = a5;
  if (a2)
  {
    os_log_type_t v15 = objc_alloc_init(NWConcrete_nw_interface_option_details);
    BOOL v16 = v15;
    if (v15)
    {
      objc_storeStrong((id *)&v15->interface, a1);
      *(_OWORD *)v16->uint64_t nexus_agent = *a2;
      objc_storeStrong((id *)&v16->remote, a3);
      v16->priority = a4;
      objc_storeStrong((id *)&v16->initial_data, a5);
      v16->sockfd = a6;
      char v17 = v16;
LABEL_11:

      goto LABEL_12;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v38 = "nw_interface_option_details_create";
    __int16 v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v19, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (id)gLogObj;
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_interface_option_details_create";
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s [[NW_CONCRETE_CLASS_NAME(interface_option_details) alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (id)gLogObj;
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v38 = "nw_interface_option_details_create";
            __int16 v39 = 2082;
            uint64_t v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v24, "%{public}s [[NW_CONCRETE_CLASS_NAME(interface_option_details) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v19) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }
        if (v25)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_interface_option_details_create";
          _os_log_impl(&dword_1830D4000, v20, v24, "%{public}s [[NW_CONCRETE_CLASS_NAME(interface_option_details) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v20 = (id)gLogObj;
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v20, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v38 = "nw_interface_option_details_create";
          _os_log_impl(&dword_1830D4000, v20, v26, "%{public}s [[NW_CONCRETE_CLASS_NAME(interface_option_details) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v19) {
      goto LABEL_11;
    }
LABEL_10:
    free(v19);
    goto LABEL_11;
  }
  int v27 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v38 = "nw_interface_option_details_create";
  BOOL v28 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v35 = 0;
  if (__nwlog_fault(v28, &type, &v35))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_interface_option_details_create";
        _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null nexus_agent", buf, 0xCu);
      }
    }
    else if (v35)
    {
      uint64_t v31 = (char *)__nw_create_backtrace_string();
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v29, type);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v38 = "nw_interface_option_details_create";
          __int16 v39 = 2082;
          uint64_t v40 = v31;
          _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null nexus_agent, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v31);
        goto LABEL_41;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_interface_option_details_create";
        _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null nexus_agent, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v38 = "nw_interface_option_details_create";
        _os_log_impl(&dword_1830D4000, v29, v34, "%{public}s called with null nexus_agent, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_41:
  if (v28) {
    free(v28);
  }
  BOOL v16 = 0;
LABEL_12:

  return v16;
}

void sub_183148694(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_path_enumerate_interface_options_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v8 = *MEMORY[0x1E4F143B8];
  id v3 = a2;
  long long v7 = 0uLL;
  nw_interface_option_details_get_nexus_agent(v3, &v7);
  uint64_t v4 = *(void *)(a1 + 32);
  id v5 = nw_interface_option_details_copy_interface(v3);
  id v6 = nw_interface_option_details_copy_remote_endpoint(v3);
  (*(void (**)(uint64_t, id, long long *, id))(v4 + 16))(v4, v5, &v7, v6);
}

void sub_183148764(_Unwind_Exception *a1)
{
  uint64_t v4 = v3;

  _Unwind_Resume(a1);
}

void nw_interface_option_details_get_nexus_agent(void *a1, _OWORD *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    id v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v22 = "nw_interface_option_details_get_nexus_agent";
    id v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_interface_option_details_get_nexus_agent";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v22 = "nw_interface_option_details_get_nexus_agent";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_interface_option_details_get_nexus_agent";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v22 = "nw_interface_option_details_get_nexus_agent";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (a2)
  {
    *a2 = *((_OWORD *)v3 + 2);
    goto LABEL_4;
  }
  __int16 v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v22 = "nw_interface_option_details_get_nexus_agent";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_interface_option_details_get_nexus_agent";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null out_nexus_agent", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    long long v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_interface_option_details_get_nexus_agent";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s called with null out_nexus_agent, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  id v14 = (char *)__nw_create_backtrace_string();
  long long v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      id v22 = "nw_interface_option_details_get_nexus_agent";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null out_nexus_agent, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    id v22 = "nw_interface_option_details_get_nexus_agent";
    __int16 v23 = 2082;
    os_log_type_t v24 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s called with null out_nexus_agent, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

id nw_interface_option_details_copy_remote_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[3];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_interface_option_details_copy_remote_endpoint";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_option_details_copy_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_interface_option_details_copy_remote_endpoint";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_option_details_copy_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_option_details_copy_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

id nw_interface_option_details_copy_interface(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = v1[1];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_interface_option_details_copy_interface";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_option_details_copy_interface";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null interface_option_details", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_interface_option_details_copy_interface";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null interface_option_details, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_option_details_copy_interface";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null interface_option_details, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_option_details_copy_interface";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null interface_option_details, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

BOOL ___ZL38nw_listener_reconcile_inboxes_on_queueP22NWConcrete_nw_listener_block_invoke_2_212(uint64_t a1, uint64_t a2, const unsigned __int8 *a3)
{
  BOOL result = nw_path_flow_registration_uses_nexus(*(void **)(a1 + 32), a3);
  if (result) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  return result;
}

BOOL nw_path_flow_registration_uses_nexus(void *a1, const unsigned __int8 *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = (unsigned __int8 *)v3;
  if (!v3)
  {
    long long v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v18 = "nw_path_flow_registration_uses_nexus";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_path_flow_registration_uses_nexus";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null flow_registration", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v18 = "nw_path_flow_registration_uses_nexus";
            __int16 v19 = 2082;
            BOOL v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_path_flow_registration_uses_nexus";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v18 = "nw_path_flow_registration_uses_nexus";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (v8) {
      free(v8);
    }
    goto LABEL_3;
  }
  if ((v3[148] & 4) != 0)
  {
    BOOL v5 = uuid_compare(v3 + 48, a2) == 0;
    goto LABEL_5;
  }
LABEL_3:
  BOOL v5 = 0;
LABEL_5:

  return v5;
}

void sub_18314974C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_derive_service_flags(void *a1, void *a2, void *a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  BOOL v5 = a1;
  id v6 = a2;
  long long v7 = a3;
  if (v5)
  {
    int v8 = 1073762304;
    unsigned int v9 = 1073758208;
    if (v6)
    {
      id v10 = v6;
      int v11 = [v10 type];

      if (v11 != 3)
      {
        if ((nw_parameters_get_desperate_ivan(v7) & 1) == 0
          && (nw_parameters_get_allow_unusable_addresses(v7) & 1) == 0
          && ((v5[347] & 1) == 0 || (v5[346] & 0x40) != 0))
        {
          int v8 = 1073795072;
        }
        if (nw_parameters_get_expired_dns_behavior(v7) == nw_parameters_expired_dns_behavior_prohibit)
        {
          unsigned int v9 = v8;
        }
        else
        {
          id v12 = v10;
          int v13 = [v12 type];

          if (v13 == 2) {
            unsigned int v9 = v8 | 0x80000000;
          }
          else {
            unsigned int v9 = v8;
          }
        }
      }
    }
    BOOL v14 = nw_parameters_requires_dnssec_validation(v7);
    int traffic_class = nw_parameters_get_traffic_class(v7);
    BOOL prohibit_cellular = nw_parameters_get_prohibit_cellular(v7);
    BOOL prohibit_expensive = nw_parameters_get_prohibit_expensive(v7);
    BOOL prohibit_constrained = nw_parameters_get_prohibit_constrained(v7);
    int use_awdl = nw_parameters_get_use_awdl(v7);
    int use_p2p = nw_parameters_get_use_p2p(v7);
    unsigned int v21 = v9 | 0x200000;
    if (!v14) {
      unsigned int v21 = v9;
    }
    if (traffic_class == 100) {
      v21 |= 0x80000u;
    }
    if (prohibit_cellular) {
      v21 |= 0x8000000u;
    }
    if (prohibit_expensive) {
      v21 |= 0x20000000u;
    }
    if (prohibit_constrained) {
      v21 |= 0x2000u;
    }
    if (use_awdl) {
      v21 |= 0x100000u;
    }
    if (use_p2p) {
      uint64_t v22 = v21 | 0x20000;
    }
    else {
      uint64_t v22 = v21;
    }
    goto LABEL_29;
  }
  os_log_type_t v24 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v35 = "nw_resolver_derive_service_flags";
  uint64_t v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v32 = 0;
  if (__nwlog_fault(v25, &type, &v32))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        char v35 = "nw_resolver_derive_service_flags";
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v32)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          char v35 = "nw_resolver_derive_service_flags";
          __int16 v36 = 2082;
          id v37 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_46;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        char v35 = "nw_resolver_derive_service_flags";
        _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v26 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        char v35 = "nw_resolver_derive_service_flags";
        _os_log_impl(&dword_1830D4000, v26, v31, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_46:
  if (v25) {
    free(v25);
  }
  uint64_t v22 = 0;
LABEL_29:

  return v22;
}

void sub_183149B44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_get_prohibit_constrained(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (*((unsigned __int16 *)v1[13].isa + 50) >> 1) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_prohibit_constrained";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_constrained";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_prohibit_constrained";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_constrained";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_constrained";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_get_prohibit_expensive(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    __int16 v3 = *((_WORD *)v1[13].isa + 50) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_prohibit_expensive";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_expensive";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_prohibit_expensive";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_expensive";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_prohibit_expensive";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_use_awdl(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 108) >> 3) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_use_awdl";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_use_awdl";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_use_awdl";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_use_awdl";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_use_awdl";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_use_p2p(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (*(unsigned __int16 *)(*((void *)v1 + 13) + 108) >> 4) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_use_p2p";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_use_p2p";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_use_p2p";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_use_p2p";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_use_p2p";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_requires_dnssec_validation(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (BYTE3(v1[12].isa) >> 6) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_requires_dnssec_validation";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_requires_dnssec_validation";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      long long v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_requires_dnssec_validation";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_requires_dnssec_validation";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      long long v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_requires_dnssec_validation";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  LOBYTE(v3) = 0;
LABEL_3:

  return v3;
}

uint64_t objectdestroy_324Tm(uint64_t *a1)
{
  uint64_t v2 = __swift_instantiateConcreteTypeFromMangledName(a1);
  uint64_t v3 = *(void *)(v2 - 8);
  unint64_t v4 = (*(unsigned __int8 *)(v3 + 80) + 64) & ~(unint64_t)*(unsigned __int8 *)(v3 + 80);
  swift_release();
  (*(void (**)(unint64_t, uint64_t))(v3 + 8))(v1 + v4, v2);

  return swift_deallocObject();
}

uint64_t ___ZL38nw_connection_add_activity_on_nw_queueP24NWConcrete_nw_connectionPU25objcproto14OS_nw_activity8NSObjectb_block_invoke(uint64_t a1, __int16 a2, void *a3)
{
  int is_equal = nw_activity_is_equal(*(void **)(a1 + 32), a3);
  if (is_equal) {
    *(_WORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = a2;
  }
  return is_equal ^ 1u;
}

uint64_t _nw_http_parsed_fields_create()
{
  type metadata accessor for __NWHTTPParsedFields();
  uint64_t result = swift_allocObject();
  *(void *)(result + 16) = MEMORY[0x1E4FBC860];
  return result;
}

uint64_t __swift_instantiateConcreteTypeFromMangledName(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContext2();
    *a1 = result;
  }
  return result;
}

void sub_18314AB5C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *__p, uint64_t a15, int a16, __int16 a17, char a18, char a19)
{
  if (a19 < 0) {
    operator delete(__p);
  }
  os_unfair_lock_unlock(v20);

  _Unwind_Resume(a1);
}

void nw_connection_receive(nw_connection_t connection, uint32_t minimum_incomplete_length, uint32_t maximum_length, nw_connection_receive_completion_t completion)
{
}

void sub_18314B14C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  std::ostringstream::~ostringstream((uint64_t)va);
  _Unwind_Resume(a1);
}

void *std::__put_character_sequence[abi:nn180100]<char,std::char_traits<char>>(void *a1, uint64_t a2, uint64_t a3)
{
  MEMORY[0x1853160E0](v23, a1);
  if (!v23[0]) {
    goto LABEL_32;
  }
  id v6 = (char *)a1 + *(void *)(*a1 - 24);
  uint64_t v7 = *((void *)v6 + 5);
  uint64_t v8 = a2 + a3;
  if ((*((_DWORD *)v6 + 2) & 0xB0) == 0x20) {
    uint64_t v9 = a2 + a3;
  }
  else {
    uint64_t v9 = a2;
  }
  int v10 = *((_DWORD *)v6 + 36);
  if (v10 == -1)
  {
    std::ios_base::getloc((const std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)));
    BOOL v11 = std::locale::use_facet(&__b, MEMORY[0x1E4FBA258]);
    int v10 = ((uint64_t (*)(const std::locale::facet *, uint64_t))v11->__vftable[2].~facet_0)(v11, 32);
    std::locale::~locale(&__b);
    *((_DWORD *)v6 + 36) = v10;
    if (!v7) {
      goto LABEL_31;
    }
  }
  else if (!v7)
  {
    goto LABEL_31;
  }
  uint64_t v12 = *((void *)v6 + 3);
  BOOL v13 = v12 <= a3;
  size_t v14 = v12 - a3;
  if (v13) {
    size_t v15 = 0;
  }
  else {
    size_t v15 = v14;
  }
  if (v9 - a2 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, a2, v9 - a2) != v9 - a2)
  {
    goto LABEL_31;
  }
  if ((uint64_t)v15 >= 1)
  {
    if (v15 >= 0x7FFFFFFFFFFFFFF8) {
      abort();
    }
    if (v15 >= 0x17)
    {
      uint64_t v17 = (v15 & 0xFFFFFFFFFFFFFFF8) + 8;
      if ((v15 | 7) != 0x17) {
        uint64_t v17 = v15 | 7;
      }
      uint64_t v18 = v17 + 1;
      p_b = (std::locale::__imp *)operator new(v17 + 1);
      size_t v25 = v15;
      int64_t v26 = v18 | 0x8000000000000000;
      __b.__locale_ = p_b;
    }
    else
    {
      HIBYTE(v26) = v15;
      p_b = (std::locale::__imp *)&__b;
    }
    memset(p_b, v10, v15);
    *((unsigned char *)p_b + v15) = 0;
    if (v26 >= 0) {
      locale = &__b;
    }
    else {
      locale = __b.__locale_;
    }
    uint64_t v20 = (*(uint64_t (**)(uint64_t, void *, size_t))(*(void *)v7 + 96))(v7, locale, v15);
    uint64_t v21 = v20;
    if ((SHIBYTE(v26) & 0x80000000) == 0)
    {
      if (v20 != v15) {
        goto LABEL_31;
      }
      goto LABEL_28;
    }
    operator delete(__b.__locale_);
    if (v21 != v15)
    {
LABEL_31:
      std::ios_base::clear((std::ios_base *)((char *)a1 + *(void *)(*a1 - 24)), *(_DWORD *)((char *)a1 + *(void *)(*a1 - 24) + 32) | 5);
      goto LABEL_32;
    }
  }
LABEL_28:
  if (v8 - v9 >= 1
    && (*(uint64_t (**)(uint64_t, uint64_t, uint64_t))(*(void *)v7 + 96))(v7, v9, v8 - v9) != v8 - v9)
  {
    goto LABEL_31;
  }
  *((void *)v6 + 3) = 0;
LABEL_32:
  MEMORY[0x1853160F0](v23);
  return a1;
}

uint64_t nw_activity_is_selected_for_reporting(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((unsigned char *)v1 + 17) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_activity_is_selected_for_reporting";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_activity_is_selected_for_reporting";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_activity_is_selected_for_reporting";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_activity_is_selected_for_reporting";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_activity_is_selected_for_reporting";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_activity_is_global_parent(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v21 = 0;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_activity_is_global_parent_block_invoke;
    aBlock[3] = &unk_1E524B978;
    BOOL v16 = buf;
    id v15 = v1;
    uint64_t v3 = _Block_copy(aBlock);
    __int16 v17 = v3;
    nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>((os_unfair_lock_s *)&global_parent_lock, (uint64_t)&v17);

    BOOL v4 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_activity_is_global_parent";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v7, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_activity_is_global_parent";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_activity_is_global_parent";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_activity_is_global_parent";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_activity_is_global_parent";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
  BOOL v4 = 0;
LABEL_3:

  return v4;
}

void sub_18314BA04(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_activity_is_equal(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (v3 && v4 && !uuid_is_null((const unsigned __int8 *)v3 + 8) && !uuid_is_null((const unsigned __int8 *)v5 + 8))
  {
    if (*((void *)v3 + 1) != *((void *)v5 + 1))
    {
      uint64_t v7 = 0;
      goto LABEL_9;
    }
    BOOL v6 = *((void *)v3 + 2) == *((void *)v5 + 2);
  }
  else
  {
    BOOL v6 = v3 == v5;
  }
  uint64_t v7 = v6;
LABEL_9:

  return v7;
}

void sub_18314BAD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t std::ostringstream::basic_ostringstream[abi:nn180100](uint64_t a1)
{
  uint64_t v2 = MEMORY[0x1E4FBA498] + 64;
  *(void *)(a1 + 112) = MEMORY[0x1E4FBA498] + 64;
  uint64_t v3 = *(void *)(MEMORY[0x1E4FBA418] + 16);
  uint64_t v4 = *(void *)(MEMORY[0x1E4FBA418] + 8);
  *(void *)a1 = v4;
  *(void *)(a1 + *(void *)(v4 - 24)) = v3;
  id v5 = (std::ios_base *)(a1 + *(void *)(*(void *)a1 - 24));
  std::ios_base::init(v5, (void *)(a1 + 8));
  uint64_t v6 = MEMORY[0x1E4FBA498] + 24;
  v5[1].__vftable = 0;
  v5[1].__fmtflags_ = -1;
  *(void *)a1 = v6;
  *(void *)(a1 + 112) = v2;
  std::streambuf::basic_streambuf();
  *(void *)(a1 + 8) = MEMORY[0x1E4FBA470] + 16;
  *(_OWORD *)(a1 + 72) = 0u;
  *(_OWORD *)(a1 + 88) = 0u;
  *(_DWORD *)(a1 + 104) = 16;
  return a1;
}

void sub_18314BC54(_Unwind_Exception *a1)
{
  std::ostream::~ostream();
  MEMORY[0x185316200](v1);
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_default_waiting_for_output(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v15 = "nw_protocol_default_waiting_for_output";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v6, &type, &v12)) {
      goto LABEL_22;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      id v15 = "nw_protocol_default_waiting_for_output";
      os_log_type_t v9 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v15 = "nw_protocol_default_waiting_for_output";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_22;
      }
      if (!v11)
      {
LABEL_22:
        if (v6) {
          free(v6);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      id v15 = "nw_protocol_default_waiting_for_output";
      os_log_type_t v9 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (!os_log_type_enabled(v7, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      id v15 = "nw_protocol_default_waiting_for_output";
      os_log_type_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
    goto LABEL_22;
  }
  output_handler = a1->output_handler;
  if (!output_handler) {
    return 0;
  }
  callbacks = output_handler->callbacks;
  if (!callbacks) {
    return 0;
  }
  waiting_for_output = (uint64_t (*)(void))callbacks->waiting_for_output;
  if (!waiting_for_output) {
    return 0;
  }

  return waiting_for_output();
}

void nw_endpoint_flow_add_initial_write_request(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    id v37 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v66 = "nw_endpoint_handler_get_mode";
    uint64_t v38 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault(v38, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v39 = __nwlog_obj();
        os_log_type_t v40 = type;
        if (os_log_type_enabled(v39, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v66 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v39, v40, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v63)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v39 = __nwlog_obj();
        os_log_type_t v42 = type;
        BOOL v43 = os_log_type_enabled(v39, type);
        if (backtrace_string)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v66 = "nw_endpoint_handler_get_mode";
            __int16 v67 = 2082;
            uint64_t v68 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v39, v42, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v66 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v39, v42, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v39 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v39, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v66 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v39, v44, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_60:
    if (v38) {
      free(v38);
    }
    unsigned int mode = 0;
LABEL_63:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v45 = (id)gLogObj;
    if (mode > 5) {
      BOOL v46 = "unknown-mode";
    }
    else {
      BOOL v46 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
    __int16 v67 = 2082;
    uint64_t v68 = (void *)v46;
    __int16 v69 = 2082;
    os_log_type_t v70 = "flow";
    uint64_t v47 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault((const char *)v47, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v48 = (id)gLogObj;
        os_log_type_t v49 = type;
        if (os_log_type_enabled(v48, type))
        {
          if (mode > 5) {
            uint64_t v50 = "unknown-mode";
          }
          else {
            uint64_t v50 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
          __int16 v67 = 2082;
          uint64_t v68 = (void *)v50;
          __int16 v69 = 2082;
          os_log_type_t v70 = "flow";
          _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v63)
      {
        os_log_type_t v51 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v48 = (id)gLogObj;
        os_log_type_t v52 = type;
        BOOL v53 = os_log_type_enabled(v48, type);
        if (v51)
        {
          if (v53)
          {
            if (mode > 5) {
              uint64_t v54 = "unknown-mode";
            }
            else {
              uint64_t v54 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
            __int16 v67 = 2082;
            uint64_t v68 = (void *)v54;
            __int16 v69 = 2082;
            os_log_type_t v70 = "flow";
            __int16 v71 = 2082;
            os_log_type_t v72 = v51;
            _os_log_impl(&dword_1830D4000, v48, v52, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v51);
          if (!v47) {
            goto LABEL_84;
          }
LABEL_83:
          free(v47);
          goto LABEL_84;
        }
        if (v53)
        {
          if (mode > 5) {
            os_log_type_t v57 = "unknown-mode";
          }
          else {
            os_log_type_t v57 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
          __int16 v67 = 2082;
          uint64_t v68 = (void *)v57;
          __int16 v69 = 2082;
          os_log_type_t v70 = "flow";
          _os_log_impl(&dword_1830D4000, v48, v52, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v48 = (id)gLogObj;
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v48, type))
        {
          if (mode > 5) {
            int v56 = "unknown-mode";
          }
          else {
            int v56 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
          __int16 v67 = 2082;
          uint64_t v68 = (void *)v56;
          __int16 v69 = 2082;
          os_log_type_t v70 = "flow";
          _os_log_impl(&dword_1830D4000, v48, v55, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v47) {
      goto LABEL_84;
    }
    goto LABEL_83;
  }
  unsigned int mode = v1->mode;

  if (mode != 2) {
    goto LABEL_63;
  }
  uint64_t v4 = v2;
  int state = v4->state;

  if ((state & 0xFFFFFFFE) != 4)
  {
    uint64_t v6 = nw_endpoint_handler_copy_flow(v4);
    if ((*((unsigned char *)v6 + 33) & 0x10) != 0)
    {
LABEL_43:

      goto LABEL_84;
    }
    uint64_t v7 = v4;
    id v8 = v7[4];

    if (!nw_parameters_has_initial_data_payload(v8))
    {
LABEL_42:

      goto LABEL_43;
    }
    os_log_type_t v9 = nw_parameters_copy_initial_data_payload(v8);
    size_t size = dispatch_data_get_size(v9);
    __int16 v61 = v9;
    BOOL v11 = nw_write_request_create_idempotent(v9, &__block_literal_global_42249, 0, 1);
    os_log_type_t v62 = v11;
    if (v11)
    {
      char v12 = v7;
      char v13 = *((unsigned char *)v12 + 268);

      if ((v13 & 0x20) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        size_t v14 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v14, OS_LOG_TYPE_DEBUG))
        {
          size_t v60 = size;
          id_string = nw_endpoint_handler_get_id_string(v12);
          BOOL v58 = nw_endpoint_handler_dry_run_string(v12);
          nw_endpoint_t v59 = nw_endpoint_handler_copy_endpoint(v12);
          logging_description = nw_endpoint_get_logging_description(v59);
          __int16 v17 = nw_endpoint_handler_state_string(v12);
          uint64_t v18 = nw_endpoint_handler_mode_string(v12);
          id v19 = nw_endpoint_handler_copy_current_path(v12);
          *(_DWORD *)buf = 136448002;
          os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
          __int16 v67 = 2082;
          uint64_t v68 = (void *)id_string;
          __int16 v69 = 2082;
          os_log_type_t v70 = v58;
          __int16 v71 = 2082;
          os_log_type_t v72 = (void *)logging_description;
          __int16 v73 = 2082;
          os_log_type_t v74 = v17;
          __int16 v75 = 2082;
          os_log_type_t v76 = v18;
          __int16 v77 = 2114;
          id v78 = v19;
          __int16 v79 = 2048;
          size_t v80 = v60;
          _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Writing initial payload of size %zu", buf, 0x52u);
        }
        BOOL v11 = v62;
      }
      *((unsigned char *)v6 + 33) |= 0x10u;
      BOOL v20 = nw_write_request_list_append(*((void **)v6 + 71), v11);
      char v21 = (void *)*((void *)v6 + 71);
      *((void *)v6 + 71) = v20;

      os_unfair_lock_lock((os_unfair_lock_t)v6 + 220);
      uint64_t v22 = v62;
      dispatch_data_t data = v22->data;
      fd = v22->fd;
      if (data)
      {
        if (!fd)
        {
          size_t num_bytes = dispatch_data_get_size(data);
LABEL_23:
          size_t consumed_bytes = v22->consumed_bytes;
          if (num_bytes <= consumed_bytes) {
            LODWORD(consumed_bytes) = 0;
          }
          int v31 = num_bytes - consumed_bytes;
          goto LABEL_26;
        }
      }
      else if (!fd)
      {
        int v31 = 0;
LABEL_26:

        *((_DWORD *)v6 + 224) += v31;
        os_unfair_lock_unlock((os_unfair_lock_t)v6 + 220);
LABEL_41:

        goto LABEL_42;
      }
      size_t num_bytes = v22->num_bytes;
      goto LABEL_23;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v26 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
    os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault(v27, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s network_write_request_create failed", buf, 0xCu);
        }
      }
      else
      {
        if (v63)
        {
          char v32 = (char *)__nw_create_backtrace_string();
          BOOL v33 = __nwlog_obj();
          os_log_type_t v34 = type;
          BOOL v35 = os_log_type_enabled(v33, type);
          if (v32)
          {
            if (v35)
            {
              *(_DWORD *)buf = 136446466;
              os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
              __int16 v67 = 2082;
              uint64_t v68 = v32;
              _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s network_write_request_create failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v32);
          }
          else
          {
            if (v35)
            {
              *(_DWORD *)buf = 136446210;
              os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
              _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s network_write_request_create failed, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_39;
        }
        BOOL v28 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v66 = "nw_endpoint_flow_add_initial_write_request";
          _os_log_impl(&dword_1830D4000, v28, v36, "%{public}s network_write_request_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_39:
    if (v27) {
      free(v27);
    }
    goto LABEL_41;
  }
LABEL_84:
}

void sub_18314CA28(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_initial_data_payload(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((void *)v1 + 18) != 0;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_parameters_has_initial_data_payload";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_has_initial_data_payload";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_parameters_has_initial_data_payload";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_has_initial_data_payload";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_parameters_has_initial_data_payload";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

nw_content_context_t nw_content_context_create(const char *context_identifier)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = [NWConcrete_nw_content_context alloc];
  if (!v2) {
    return 0;
  }
  v48.os_log_type_t receiver = v2;
  v48.super_class = (Class)NWConcrete_nw_content_context;
  BOOL v3 = objc_msgSendSuper2(&v48, sel_init);
  if (!v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v36 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
    id v37 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v37, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v38 = (id)gLogObj;
        os_log_type_t v39 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
          _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v38 = (id)gLogObj;
        os_log_type_t v43 = type;
        BOOL v44 = os_log_type_enabled(v38, type);
        if (backtrace_string)
        {
          if (v44)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
            __int16 v51 = 2082;
            os_log_type_t v52 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v38, v43, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v44)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
          _os_log_impl(&dword_1830D4000, v38, v43, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v38 = (id)gLogObj;
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v38, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v50 = "-[NWConcrete_nw_content_context initWithIdentifier:]";
          _os_log_impl(&dword_1830D4000, v38, v45, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_56:
    if (v37) {
      free(v37);
    }
    return 0;
  }
  if (context_identifier) {
    goto LABEL_4;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v40 = (id)gLogObj;
  os_log_type_enabled(v40, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  uint64_t v50 = "_strict_strlcpy";
  uint64_t v41 = (void *)_os_log_send_and_compose_impl();

  nw_content_context_t result = (nw_content_context_t)__nwlog_abort((uint64_t)v41);
  if (!result)
  {
    free(v41);
LABEL_4:
    int v4 = *(unsigned __int8 *)context_identifier;
    *((unsigned char *)v3 + 24) = v4;
    if (v4)
    {
      int v5 = *((unsigned __int8 *)context_identifier + 1);
      *((unsigned char *)v3 + 25) = v5;
      if (v5)
      {
        int v6 = *((unsigned __int8 *)context_identifier + 2);
        *((unsigned char *)v3 + 26) = v6;
        if (v6)
        {
          int v7 = *((unsigned __int8 *)context_identifier + 3);
          *((unsigned char *)v3 + 27) = v7;
          if (v7)
          {
            int v8 = *((unsigned __int8 *)context_identifier + 4);
            *((unsigned char *)v3 + 28) = v8;
            if (v8)
            {
              int v9 = *((unsigned __int8 *)context_identifier + 5);
              *((unsigned char *)v3 + 29) = v9;
              if (v9)
              {
                int v10 = *((unsigned __int8 *)context_identifier + 6);
                *((unsigned char *)v3 + 30) = v10;
                if (v10)
                {
                  int v11 = *((unsigned __int8 *)context_identifier + 7);
                  *((unsigned char *)v3 + 31) = v11;
                  if (v11)
                  {
                    int v12 = *((unsigned __int8 *)context_identifier + 8);
                    *((unsigned char *)v3 + 32) = v12;
                    if (v12)
                    {
                      int v13 = *((unsigned __int8 *)context_identifier + 9);
                      *((unsigned char *)v3 + 33) = v13;
                      if (v13)
                      {
                        int v14 = *((unsigned __int8 *)context_identifier + 10);
                        *((unsigned char *)v3 + 34) = v14;
                        if (v14)
                        {
                          int v15 = *((unsigned __int8 *)context_identifier + 11);
                          *((unsigned char *)v3 + 35) = v15;
                          if (v15)
                          {
                            int v16 = *((unsigned __int8 *)context_identifier + 12);
                            *((unsigned char *)v3 + 36) = v16;
                            if (v16)
                            {
                              int v17 = *((unsigned __int8 *)context_identifier + 13);
                              *((unsigned char *)v3 + 37) = v17;
                              if (v17)
                              {
                                int v18 = *((unsigned __int8 *)context_identifier + 14);
                                *((unsigned char *)v3 + 38) = v18;
                                if (v18)
                                {
                                  int v19 = *((unsigned __int8 *)context_identifier + 15);
                                  *((unsigned char *)v3 + 39) = v19;
                                  if (v19)
                                  {
                                    int v20 = *((unsigned __int8 *)context_identifier + 16);
                                    *((unsigned char *)v3 + 40) = v20;
                                    if (v20)
                                    {
                                      int v21 = *((unsigned __int8 *)context_identifier + 17);
                                      *((unsigned char *)v3 + 41) = v21;
                                      if (v21)
                                      {
                                        int v22 = *((unsigned __int8 *)context_identifier + 18);
                                        *((unsigned char *)v3 + 42) = v22;
                                        if (v22)
                                        {
                                          int v23 = *((unsigned __int8 *)context_identifier + 19);
                                          *((unsigned char *)v3 + 43) = v23;
                                          if (v23)
                                          {
                                            int v24 = *((unsigned __int8 *)context_identifier + 20);
                                            *((unsigned char *)v3 + 44) = v24;
                                            if (v24)
                                            {
                                              int v25 = *((unsigned __int8 *)context_identifier + 21);
                                              *((unsigned char *)v3 + 45) = v25;
                                              if (v25)
                                              {
                                                int v26 = *((unsigned __int8 *)context_identifier + 22);
                                                *((unsigned char *)v3 + 46) = v26;
                                                if (v26)
                                                {
                                                  int v27 = *((unsigned __int8 *)context_identifier + 23);
                                                  *((unsigned char *)v3 + 47) = v27;
                                                  if (v27)
                                                  {
                                                    int v28 = *((unsigned __int8 *)context_identifier + 24);
                                                    *((unsigned char *)v3 + 48) = v28;
                                                    if (v28)
                                                    {
                                                      int v29 = *((unsigned __int8 *)context_identifier + 25);
                                                      *((unsigned char *)v3 + 49) = v29;
                                                      if (v29)
                                                      {
                                                        int v30 = *((unsigned __int8 *)context_identifier + 26);
                                                        *((unsigned char *)v3 + 50) = v30;
                                                        if (v30)
                                                        {
                                                          int v31 = *((unsigned __int8 *)context_identifier + 27);
                                                          *((unsigned char *)v3 + 51) = v31;
                                                          if (v31)
                                                          {
                                                            int v32 = *((unsigned __int8 *)context_identifier + 28);
                                                            *((unsigned char *)v3 + 52) = v32;
                                                            if (v32)
                                                            {
                                                              int v33 = *((unsigned __int8 *)context_identifier + 29);
                                                              *((unsigned char *)v3 + 53) = v33;
                                                              if (v33)
                                                              {
                                                                int v34 = *((unsigned __int8 *)context_identifier + 30);
                                                                *((unsigned char *)v3 + 54) = v34;
                                                                if (v34) {
                                                                  *((unsigned char *)v3 + 55) = 0;
                                                                }
                                                              }
                                                            }
                                                          }
                                                        }
                                                      }
                                                    }
                                                  }
                                                }
                                              }
                                            }
                                          }
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    *((void *)v3 + 10) = 0x3FE0000000000000;
    return (nw_content_context_t)v3;
  }
  __break(1u);
  return result;
}

void sub_18314D2A0(_Unwind_Exception *exception_object)
{
}

void nw_content_context_set_is_final(nw_content_context_t context, BOOL is_final)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  nw_content_context_t v4 = v3;
  if (v3)
  {
    if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
      && v3 != (nw_content_context_t)&__block_literal_global_8_42267
      && v3 != (nw_content_context_t)&__block_literal_global_6_42258
      && v3 != (nw_content_context_t)&__block_literal_global_42249)
    {
      BYTE6(v3[14].isa) = BYTE6(v3[14].isa) & 0xFE | is_final;
    }
    goto LABEL_7;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_content_context_set_is_final";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_content_context_set_is_final";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_content_context_set_is_final";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_content_context_set_is_final";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_content_context_set_is_final";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v6) {
    free(v6);
  }
LABEL_7:
}

void nw_connection_set_state_changed_handler(nw_connection_t connection, nw_connection_state_changed_handler_t handler)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_connection_t v3 = connection;
  nw_connection_state_changed_handler_t v4 = handler;
  if (v3)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_set_state_changed_handler_block_invoke;
    v13[3] = &unk_1E524B950;
    int v14 = v3;
    id v15 = v4;
    os_unfair_lock_lock((os_unfair_lock_t)&v3[17]);
    __nw_connection_set_state_changed_handler_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[17]);

    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_connection_set_state_changed_handler";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v17 = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &v17, &v16))
  {
    if (v17 == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_connection_set_state_changed_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = v17;
      BOOL v11 = os_log_type_enabled(v7, v17);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_connection_set_state_changed_handler";
          __int16 v20 = 2082;
          int v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_connection_set_state_changed_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = v17;
      if (os_log_type_enabled(v7, v17))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_connection_set_state_changed_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void __nw_connection_set_state_changed_handler_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 80) == 5)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      nw_connection_state_changed_handler_t v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        int v9 = 136446466;
        os_log_type_t v10 = "nw_connection_set_state_changed_handler_block_invoke";
        __int16 v11 = 1024;
        int v12 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot set state changed handler after cancel", (uint8_t *)&v9, 0x12u);
      }
    }
  }
  else
  {
    int v6 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v7 = *(void *)(a1 + 32);
    os_log_type_t v8 = *(void **)(v7 + 208);
    *(void *)(v7 + 208) = v6;
  }
}

void nw_connection_set_queue(nw_connection_t connection, dispatch_queue_t queue)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_connection_t v3 = connection;
  nw_connection_state_changed_handler_t v4 = queue;
  int v5 = v4;
  if (!v3)
  {
    int v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v26 = "nw_connection_set_queue";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v24 = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v7, &v24, &v23)) {
      goto LABEL_38;
    }
    if (v24 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_connection_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = v24;
      BOOL v14 = os_log_type_enabled(v8, v24);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          int v26 = "nw_connection_set_queue";
          __int16 v27 = 2082;
          int v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_connection_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v18 = v24;
      if (os_log_type_enabled(v8, v24))
      {
        *(_DWORD *)buf = 136446210;
        int v26 = "nw_connection_set_queue";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    v20[0] = MEMORY[0x1E4F143A8];
    v20[1] = 3221225472;
    void v20[2] = __nw_connection_set_queue_block_invoke;
    v20[3] = &unk_1E524B9A0;
    int v21 = v3;
    uint64_t v22 = v5;
    os_unfair_lock_lock((os_unfair_lock_t)&v3[17]);
    __nw_connection_set_queue_block_invoke((uint64_t)v20);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[17]);

    goto LABEL_4;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v26 = "nw_connection_set_queue";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v24 = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v7, &v24, &v23)) {
    goto LABEL_38;
  }
  if (v24 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v11 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      int v26 = "nw_connection_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    os_log_type_t v8 = __nwlog_obj();
    os_log_type_t v19 = v24;
    if (os_log_type_enabled(v8, v24))
    {
      *(_DWORD *)buf = 136446210;
      int v26 = "nw_connection_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  id v15 = (char *)__nw_create_backtrace_string();
  os_log_type_t v8 = __nwlog_obj();
  os_log_type_t v16 = v24;
  BOOL v17 = os_log_type_enabled(v8, v24);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      int v26 = "nw_connection_set_queue";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    int v26 = "nw_connection_set_queue";
    __int16 v27 = 2082;
    int v28 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

void __nw_connection_set_queue_block_invoke(uint64_t a1)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x10) != 0)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3)
    {
      if (!nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v4 = (id)gconnectionLogObj;
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        *(_DWORD *)buf = 136446466;
        int v26 = "nw_connection_set_queue_block_invoke";
        __int16 v27 = 1024;
        int v28 = v5;
        int v6 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v23 = 0;
        if (!__nwlog_fault(v6, &type, &v23))
        {
LABEL_13:
          if (!v6) {
            goto LABEL_15;
          }
          goto LABEL_14;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v7 = (id)gconnectionLogObj;
          os_log_type_t v8 = type;
          if (os_log_type_enabled(v7, type))
          {
            int v9 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
            *(_DWORD *)buf = 136446466;
            int v26 = "nw_connection_set_queue_block_invoke";
            __int16 v27 = 1024;
            int v28 = v9;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s [C%u] Error in client: nw_connection_set_queue called after nw_connection_start", buf, 0x12u);
          }
LABEL_12:

          goto LABEL_13;
        }
        if (!v23)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v7 = (id)gconnectionLogObj;
          os_log_type_t v20 = type;
          if (os_log_type_enabled(v7, type))
          {
            int v21 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
            *(_DWORD *)buf = 136446466;
            int v26 = "nw_connection_set_queue_block_invoke";
            __int16 v27 = 1024;
            int v28 = v21;
            _os_log_impl(&dword_1830D4000, v7, v20, "%{public}s [C%u] Error in client: nw_connection_set_queue called after nw_connection_start, backtrace limit exceeded", buf, 0x12u);
          }
          goto LABEL_12;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v7 = (id)gconnectionLogObj;
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v7, type);
        if (!backtrace_string)
        {
          if (v18)
          {
            int v22 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
            *(_DWORD *)buf = 136446466;
            int v26 = "nw_connection_set_queue_block_invoke";
            __int16 v27 = 1024;
            int v28 = v22;
            _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s [C%u] Error in client: nw_connection_set_queue called after nw_connection_start, no backtrace", buf, 0x12u);
          }
          goto LABEL_12;
        }
        if (v18)
        {
          int v19 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
          *(_DWORD *)buf = 136446722;
          int v26 = "nw_connection_set_queue_block_invoke";
          __int16 v27 = 1024;
          int v28 = v19;
          __int16 v29 = 2082;
          int v30 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s [C%u] Error in client: nw_connection_set_queue called after nw_connection_start, dumping backtrace:%{public}s", buf, 0x1Cu);
        }

        free(backtrace_string);
        if (v6) {
LABEL_14:
        }
          free(v6);
      }
    }
  }
LABEL_15:
  if (!nw_context_is_inline(*(void **)(*(void *)(a1 + 32) + 24)))
  {
    uint64_t v14 = a1 + 32;
    uint64_t v13 = *(void *)(a1 + 32);
    id v15 = *(id *)(v14 + 8);
    os_log_type_t v11 = *(NSObject **)(v13 + 200);
    *(void *)(v13 + 200) = v15;
LABEL_23:

    return;
  }
  uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16);
  if (v10 && !nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v11 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
    {
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      *(_DWORD *)buf = 136446466;
      int v26 = "nw_connection_set_queue_block_invoke";
      __int16 v27 = 1024;
      int v28 = v12;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Connection client queue will be ignored for inline contexts", buf, 0x12u);
    }
    goto LABEL_23;
  }
}

uint64_t nw_utilities_minos_atleast(int a1)
{
  if (a1 == 1) {
    return MEMORY[0x1F40CBEC0](0x7E60901FFFFFFFFLL);
  }
  else {
    return MEMORY[0x1F40CBEC0](0);
  }
}

nw_data_transfer_report_t nw_connection_create_new_data_transfer_report(nw_connection_t connection)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = connection;
  uint64_t v3 = objc_alloc_init(NWConcrete_nw_data_transfer_report);
  objc_storeStrong((id *)v3 + 3, connection);
  id v4 = v2;
  int v5 = v3;
  if (v4)
  {
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&buf[8] = 3221225472;
    *(void *)&buf[16] = __nw_connection_add_data_transfer_report_block_invoke;
    BOOL v18 = &unk_1E524B9A0;
    int v19 = v4;
    os_log_type_t v20 = v5;
    nw_connection_async_if_needed(v19, buf);

    goto LABEL_3;
  }
  uint64_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_add_data_transfer_report";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_add_data_transfer_report";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_add_data_transfer_report";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_add_data_transfer_report";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_add_data_transfer_report";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
LABEL_3:

  return v5;
}

void sub_18314E708(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

void nw_activity_get_token(void *a1, _OWORD *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v22 = "nw_activity_get_token";
    int v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (!__nwlog_fault(v6, &type, &v19)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_activity_get_token";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          int v22 = "nw_activity_get_token";
          __int16 v23 = 2082;
          os_log_type_t v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v6) {
          goto LABEL_4;
        }
LABEL_39:
        free(v6);
        goto LABEL_4;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_activity_get_token";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v22 = "nw_activity_get_token";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if ((v3[140] & 4) != 0)
  {
    *a2 = *(_OWORD *)(v3 + 8);
    goto LABEL_4;
  }
  int v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  int v22 = "nw_activity_get_token";
  __int16 v23 = 2082;
  os_log_type_t v24 = "Cannot get token before activation";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (!__nwlog_fault(v6, &type, &v19)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v10 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446466;
      int v22 = "nw_activity_get_token";
      __int16 v23 = 2082;
      os_log_type_t v24 = "Cannot get token before activation";
      _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
    }
    goto LABEL_37;
  }
  if (!v19)
  {
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v18 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446466;
      int v22 = "nw_activity_get_token";
      __int16 v23 = 2082;
      os_log_type_t v24 = "Cannot get token before activation";
      _os_log_impl(&dword_1830D4000, v7, v18, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
    }
    goto LABEL_37;
  }
  os_log_type_t v14 = (char *)__nw_create_backtrace_string();
  uint64_t v7 = __nwlog_obj();
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v7, type);
  if (!v14)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446466;
      int v22 = "nw_activity_get_token";
      __int16 v23 = 2082;
      os_log_type_t v24 = "Cannot get token before activation";
      _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
    }
    goto LABEL_37;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446722;
    int v22 = "nw_activity_get_token";
    __int16 v23 = 2082;
    os_log_type_t v24 = "Cannot get token before activation";
    __int16 v25 = 2082;
    int v26 = v14;
    _os_log_impl(&dword_1830D4000, v7, v15, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
  }

  free(v14);
  if (v6) {
    goto LABEL_39;
  }
LABEL_4:
}

uint64_t nw_array_get_count(uint64_t result)
{
  if (result) {
    return (uint64_t)(*(void *)(result + 24) - *(void *)(result + 16)) >> 3;
  }
  return result;
}

void nw_proxy_hop_set_client_identity_is_raw_public_key(void *a1, int a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    if (a2) {
      char v5 = 4;
    }
    else {
      char v5 = 0;
    }
    *((unsigned char *)v3 + 81) = *((unsigned char *)v3 + 81) & 0xFB | v5;
    goto LABEL_6;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_proxy_hop_set_client_identity_is_raw_public_key";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v7) {
    free(v7);
  }
LABEL_6:
}

uint64_t __swift_instantiateConcreteTypeFromMangledNameAbstract(uint64_t *a1)
{
  uint64_t result = *a1;
  if (result < 0)
  {
    uint64_t result = swift_getTypeByMangledNameInContextInMetadataState2();
    *a1 = result;
  }
  return result;
}

void sub_18314F39C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)NWConcrete_nw_path_evaluator;
  [(_Unwind_Exception *)&a14 dealloc];
  _Unwind_Resume(a1);
}

void nw_protocol_transform_add_match_url_scheme(void *a1, const char *a2)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
    os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (!__nwlog_fault(v9, &type, &v22)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
          __int16 v26 = 2082;
          uint64_t v27 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v9) {
          goto LABEL_6;
        }
LABEL_41:
        free(v9);
        goto LABEL_6;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (a2)
  {
    char v5 = (void *)v3[6];
    if (!v5)
    {
      xpc_object_t v6 = xpc_array_create(0, 0);
      uint64_t v7 = (void *)v4[6];
      v4[6] = v6;

      char v5 = (void *)v4[6];
    }
    xpc_array_set_string(v5, 0xFFFFFFFFFFFFFFFFLL, a2);
    goto LABEL_6;
  }
  BOOL v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (!__nwlog_fault(v9, &type, &v22)) {
    goto LABEL_40;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
      _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null scheme", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v22)
  {
    os_log_type_t v10 = __nwlog_obj();
    os_log_type_t v21 = type;
    if (os_log_type_enabled(v10, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
      _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s called with null scheme, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  os_log_type_t v17 = (char *)__nw_create_backtrace_string();
  os_log_type_t v10 = __nwlog_obj();
  os_log_type_t v18 = type;
  BOOL v19 = os_log_type_enabled(v10, type);
  if (!v17)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
      _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s called with null scheme, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v25 = "nw_protocol_transform_add_match_url_scheme";
    __int16 v26 = 2082;
    uint64_t v27 = v17;
    _os_log_impl(&dword_1830D4000, v10, v18, "%{public}s called with null scheme, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v17);
  if (v9) {
    goto LABEL_41;
  }
LABEL_6:
}

void sub_18314F8BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_stack_clear_application_protocols(nw_protocol_stack_t stack)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_stack_t v1 = stack;
  p_Class isa = &v1->isa;
  if (v1)
  {
    Class isa = v1[1].isa;
    v1[1].Class isa = 0;

    id v4 = (void *)p_isa[2];
    p_isa[2] = 0;

    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_stack_clear_application_protocols";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_stack_clear_application_protocols";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_stack_clear_application_protocols";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_stack_clear_application_protocols";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_stack_clear_application_protocols";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

nw_framer_message_t nw_framer_protocol_create_message(nw_protocol_definition_t definition)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_stack_t v1 = definition;
  uint64_t v2 = v1;
  if (v1)
  {
    singleton = nw_protocol_metadata_create_singleton(v1);
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_framer_protocol_create_message";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_framer_protocol_create_message";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_framer_protocol_create_message";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_framer_protocol_create_message";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_framer_protocol_create_message";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  singleton = 0;
LABEL_3:

  return singleton;
}

void sub_18314FE0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_content_context_set_relative_priority(nw_content_context_t context, double relative_priority)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  nw_content_context_t v4 = v3;
  if (v3)
  {
    if (relative_priority >= 0.0 && relative_priority <= 1.0)
    {
      if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
        && v3 != (nw_content_context_t)&__block_literal_global_8_42267
        && v3 != (nw_content_context_t)&__block_literal_global_6_42258
        && v3 != (nw_content_context_t)&__block_literal_global_42249)
      {
        *(double *)&v3[10].Class isa = relative_priority;
      }
      goto LABEL_12;
    }
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v24 = "nw_content_context_set_relative_priority";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v10, &type, &v21)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_content_context_set_relative_priority";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null (relative_priority >= 0.0 && relative_priority <= 1.0)", buf, 0xCu);
      }
    }
    else if (v21)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v24 = "nw_content_context_set_relative_priority";
          __int16 v25 = 2082;
          __int16 v26 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null (relative_priority >= 0.0 && relative_priority <= 1.0), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (v10) {
          goto LABEL_47;
        }
        goto LABEL_12;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_content_context_set_relative_priority";
        _os_log_impl(&dword_1830D4000, v7, v17, "%{public}s called with null (relative_priority >= 0.0 && relative_priority <= 1.0), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v24 = "nw_content_context_set_relative_priority";
        _os_log_impl(&dword_1830D4000, v7, v20, "%{public}s called with null (relative_priority >= 0.0 && relative_priority <= 1.0), backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_45;
  }
  xpc_object_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v24 = "nw_content_context_set_relative_priority";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (!__nwlog_fault(v10, &type, &v21)) {
    goto LABEL_46;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_content_context_set_relative_priority";
      _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
    }
LABEL_45:

    goto LABEL_46;
  }
  if (!v21)
  {
    uint64_t v7 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_content_context_set_relative_priority";
      _os_log_impl(&dword_1830D4000, v7, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_45;
  }
  char v13 = (char *)__nw_create_backtrace_string();
  uint64_t v7 = __nwlog_obj();
  os_log_type_t v14 = type;
  BOOL v15 = os_log_type_enabled(v7, type);
  if (!v13)
  {
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v24 = "nw_content_context_set_relative_priority";
      _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }
    goto LABEL_45;
  }
  if (v15)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v24 = "nw_content_context_set_relative_priority";
    __int16 v25 = 2082;
    __int16 v26 = v13;
    _os_log_impl(&dword_1830D4000, v7, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v13);
LABEL_46:
  if (v10) {
LABEL_47:
  }
    free(v10);
LABEL_12:
}

void nw_content_context_set_expiration_milliseconds(nw_content_context_t context, uint64_t expiration_milliseconds)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_content_context_t v3 = context;
  nw_content_context_t v4 = v3;
  if (v3)
  {
    if (v3 != (nw_content_context_t)&__block_literal_global_10_42276
      && v3 != (nw_content_context_t)&__block_literal_global_8_42267
      && v3 != (nw_content_context_t)&__block_literal_global_6_42258
      && v3 != (nw_content_context_t)&__block_literal_global_42249)
    {
      v3[8].Class isa = (Class)expiration_milliseconds;
    }
    goto LABEL_7;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_content_context_set_expiration_milliseconds";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_content_context_set_expiration_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_content_context_set_expiration_milliseconds";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_content_context_set_expiration_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_content_context_set_expiration_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v6) {
    free(v6);
  }
LABEL_7:
}

nw_group_descriptor_t nw_connection_group_copy_descriptor(nw_connection_group_t group)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_group_t v1 = group;
  nw_connection_group_t v2 = v1;
  if (v1)
  {
    nw_content_context_t v3 = v1[8].isa;
    goto LABEL_3;
  }
  char v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_connection_group_copy_descriptor";
  xpc_object_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_connection_group_copy_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null group", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_connection_group_copy_descriptor";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null group, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_connection_group_copy_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null group, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_connection_group_copy_descriptor";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null group, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_content_context_t v3 = 0;
LABEL_3:

  return v3;
}

char *nw_activity_create_from_token(_OWORD *a1)
{
  nw_connection_group_t v2 = [NWConcrete_nw_activity alloc];

  return -[NWConcrete_nw_activity initWithToken:](v2, a1);
}

void sub_183150C2C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_proxy_config_t nw_proxy_config_create_socksv5(nw_endpoint_t proxy_endpoint)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_connection_group_t v1 = proxy_endpoint;
  if (v1)
  {
    if (nw_protocol_socksv5_copy_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_socksv5_copy_definition::onceToken, &__block_literal_global_85297);
    }
    if (nw_protocol_socksv5_copy_definition::definition) {
      nw_connection_group_t v2 = os_retain((void *)nw_protocol_socksv5_copy_definition::definition);
    }
    else {
      nw_connection_group_t v2 = 0;
    }
    nw_protocol_options_t options = nw_framer_create_options(v2);
    nw_content_context_t v4 = nw_proxy_config_create(v1, options);

    if (v4)
    {
      v4->os_log_type_t type = 3002;
      *((unsigned char *)v4 + 170) |= 8u;
      char v5 = v4;
LABEL_9:

      goto LABEL_10;
    }
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v26 = "nw_proxy_config_create_socksv5";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v12, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v26 = "nw_proxy_config_create_socksv5";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null config", buf, 0xCu);
        }
      }
      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v26 = "nw_proxy_config_create_socksv5";
            __int16 v27 = 2082;
            uint64_t v28 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v19, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_46;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v26 = "nw_proxy_config_create_socksv5";
          _os_log_impl(&dword_1830D4000, v13, v19, "%{public}s called with null config, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v13 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v26 = "nw_proxy_config_create_socksv5";
          _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_46:
    if (v12) {
      free(v12);
    }
    goto LABEL_9;
  }
  uint64_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v26 = "nw_proxy_config_create_socksv5";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_proxy_config_create_socksv5";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null proxy_endpoint", buf, 0xCu);
      }
    }
    else if (v23)
    {
      BOOL v15 = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v26 = "nw_proxy_config_create_socksv5";
          __int16 v27 = 2082;
          uint64_t v28 = v15;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null proxy_endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_40;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_proxy_config_create_socksv5";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null proxy_endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v26 = "nw_proxy_config_create_socksv5";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null proxy_endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_40:
  if (v8) {
    free(v8);
  }
  nw_content_context_t v4 = 0;
LABEL_10:

  return &v4->super;
}

void sub_183151164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_path_unsatisfied_reason_t nw_path_get_unsatisfied_reason(nw_path_t path)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  nw_path_t v2 = v1;
  if (v1)
  {
    int isa_high = HIDWORD(v1[47].isa);
    unsigned int v4 = isa_high - 27;
    nw_path_unsatisfied_reason_t v5 = isa_high - 26;
    if (v4 >= 4) {
      nw_path_unsatisfied_reason_t v6 = nw_path_unsatisfied_reason_not_available;
    }
    else {
      nw_path_unsatisfied_reason_t v6 = v5;
    }
    goto LABEL_5;
  }
  os_log_type_t v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v19 = "nw_path_get_unsatisfied_reason";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_path_get_unsatisfied_reason";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v19 = "nw_path_get_unsatisfied_reason";
          __int16 v20 = 2082;
          os_log_type_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_path_get_unsatisfied_reason";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v19 = "nw_path_get_unsatisfied_reason";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v9) {
    free(v9);
  }
  nw_path_unsatisfied_reason_t v6 = nw_path_unsatisfied_reason_not_available;
LABEL_5:

  return v6;
}

void nw_listener_start(nw_listener_t listener)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = listener;
  nw_path_t v2 = (os_unfair_lock_s *)v1;
  if (v1)
  {
    *(void *)uint64_t v41 = 0;
    *(void *)&v41[8] = v41;
    *(void *)&v41[16] = 0x2020000000;
    char v42 = 0;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_start_block_invoke;
    aBlock[3] = &unk_1E524B978;
    int v33 = v41;
    nw_content_context_t v3 = v1;
    int v32 = v3;
    unsigned int v4 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock(v2 + 2);
    v4[2](v4);
    os_unfair_lock_unlock(v2 + 2);

    if (*(unsigned char *)(*(void *)&v41[8] + 24))
    {
      qos_class_t v5 = qos_class_self();
      id v6 = nw_parameters_copy_context(v3[2]);
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      v27[2] = __nw_listener_start_block_invoke_56;
      v27[3] = &unk_1E524A070;
      uint64_t v28 = v3;
      qos_class_t v29 = v5;
      nw_queue_context_async_if_needed(v6, v27);

LABEL_17:
      _Block_object_dispose(v41, 8);
      goto LABEL_18;
    }
    uint64_t v7 = v3[2];
    if (!v7 || nw_path_parameters_get_logging_disabled(v7[13])) {
      goto LABEL_17;
    }
    if (__nwlog_listener_log::onceToken != -1) {
      dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
    }
    id v8 = (id)glistenerLogObj;
    os_log_type_t v9 = (char *)v3 + 42;
    *(_DWORD *)buf = 136446466;
    id v36 = "nw_listener_start";
    __int16 v37 = 2082;
    uint64_t v38 = (char *)v3 + 42;
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v10, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        os_log_type_t v11 = (id)glistenerLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_listener_start";
          __int16 v37 = 2082;
          uint64_t v38 = v9;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s [%{public}s] In wrong state for start", buf, 0x16u);
        }
      }
      else if (v30)
      {
        backtrace_string = __nw_create_backtrace_string();
        if (backtrace_string)
        {
          BOOL v14 = (char *)backtrace_string;
          if (__nwlog_listener_log::onceToken != -1) {
            dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
          }
          os_log_type_t v15 = (id)glistenerLogObj;
          os_log_type_t v16 = type;
          if (os_log_type_enabled(v15, type))
          {
            *(_DWORD *)buf = 136446722;
            id v36 = "nw_listener_start";
            __int16 v37 = 2082;
            uint64_t v38 = v9;
            __int16 v39 = 2082;
            os_log_type_t v40 = v14;
            _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s [%{public}s] In wrong state for start, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v14);
          if (!v10) {
            goto LABEL_17;
          }
          goto LABEL_16;
        }
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        os_log_type_t v11 = (id)glistenerLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_listener_start";
          __int16 v37 = 2082;
          uint64_t v38 = v9;
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s [%{public}s] In wrong state for start, no backtrace", buf, 0x16u);
        }
      }
      else
      {
        if (__nwlog_listener_log::onceToken != -1) {
          dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
        }
        os_log_type_t v11 = (id)glistenerLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446466;
          id v36 = "nw_listener_start";
          __int16 v37 = 2082;
          uint64_t v38 = v9;
          _os_log_impl(&dword_1830D4000, v11, v17, "%{public}s [%{public}s] In wrong state for start, backtrace limit exceeded", buf, 0x16u);
        }
      }
    }
    if (!v10) {
      goto LABEL_17;
    }
LABEL_16:
    free(v10);
    goto LABEL_17;
  }
  os_log_type_t v19 = __nwlog_obj();
  *(_DWORD *)uint64_t v41 = 136446210;
  *(void *)&v41[4] = "nw_listener_start";
  __int16 v20 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v20, buf, &type))
  {
    if (buf[0] == 17)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v41 = 136446210;
        *(void *)&v41[4] = "nw_listener_start";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null listener", v41, 0xCu);
      }
    }
    else if (type)
    {
      char v23 = (char *)__nw_create_backtrace_string();
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v24 = buf[0];
      BOOL v25 = os_log_type_enabled(v21, (os_log_type_t)buf[0]);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)uint64_t v41 = 136446466;
          *(void *)&v41[4] = "nw_listener_start";
          *(_WORD *)&v41[12] = 2082;
          *(void *)&v41[14] = v23;
          _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null listener, dumping backtrace:%{public}s", v41, 0x16u);
        }

        free(v23);
        goto LABEL_53;
      }
      if (v25)
      {
        *(_DWORD *)uint64_t v41 = 136446210;
        *(void *)&v41[4] = "nw_listener_start";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null listener, no backtrace", v41, 0xCu);
      }
    }
    else
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v26 = buf[0];
      if (os_log_type_enabled(v21, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v41 = 136446210;
        *(void *)&v41[4] = "nw_listener_start";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null listener, backtrace limit exceeded", v41, 0xCu);
      }
    }
  }
LABEL_53:
  if (v20) {
    free(v20);
  }
LABEL_18:
}

void sub_183151B1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24)
{
  _Block_object_dispose((const void *)(v26 - 144), 8);
  _Unwind_Resume(a1);
}

void nw_listener_set_state_changed_handler(nw_listener_t listener, nw_listener_state_changed_handler_t handler)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  nw_listener_t v3 = listener;
  nw_listener_state_changed_handler_t v4 = handler;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_set_state_changed_handler_block_invoke;
    aBlock[3] = &unk_1E524B950;
    os_log_type_t v15 = v3;
    id v16 = v4;
    qos_class_t v5 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v5[2](v5);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);

    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v20 = "nw_listener_set_state_changed_handler";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "nw_listener_set_state_changed_handler";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = v18;
      BOOL v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v20 = "nw_listener_set_state_changed_handler";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "nw_listener_set_state_changed_handler";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v20 = "nw_listener_set_state_changed_handler";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_183151EA0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_listener_set_queue(nw_listener_t listener, dispatch_queue_t queue)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  nw_listener_t v3 = listener;
  nw_listener_state_changed_handler_t v4 = queue;
  qos_class_t v5 = v4;
  if (!v3)
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v27 = "nw_listener_set_queue";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v25 = OS_LOG_TYPE_ERROR;
    char v24 = 0;
    if (!__nwlog_fault(v8, &v25, &v24)) {
      goto LABEL_38;
    }
    if (v25 == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_listener_set_queue";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v24)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = v25;
      BOOL v15 = os_log_type_enabled(v9, v25);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v27 = "nw_listener_set_queue";
          __int16 v28 = 2082;
          qos_class_t v29 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v8) {
          goto LABEL_4;
        }
LABEL_39:
        free(v8);
        goto LABEL_4;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_listener_set_queue";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v19 = v25;
      if (os_log_type_enabled(v9, v25))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v27 = "nw_listener_set_queue";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_set_queue_block_invoke;
    aBlock[3] = &unk_1E524B9A0;
    os_log_type_t v22 = v3;
    uint64_t v23 = v5;
    id v6 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v6[2](v6);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);

    goto LABEL_4;
  }
  os_log_type_t v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v27 = "nw_listener_set_queue";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v25 = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (!__nwlog_fault(v8, &v25, &v24)) {
    goto LABEL_38;
  }
  if (v25 == OS_LOG_TYPE_FAULT)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v12 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_listener_set_queue";
      _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null queue", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v24)
  {
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v20 = v25;
    if (os_log_type_enabled(v9, v25))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_listener_set_queue";
      _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null queue, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  id v16 = (char *)__nw_create_backtrace_string();
  os_log_type_t v9 = __nwlog_obj();
  os_log_type_t v17 = v25;
  BOOL v18 = os_log_type_enabled(v9, v25);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v27 = "nw_listener_set_queue";
      _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null queue, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v27 = "nw_listener_set_queue";
    __int16 v28 = 2082;
    qos_class_t v29 = v16;
    _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s called with null queue, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v8) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_18315241C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_listener_set_new_connection_handler(nw_listener_t listener, nw_listener_new_connection_handler_t handler)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  nw_listener_t v3 = listener;
  nw_listener_new_connection_handler_t v4 = handler;
  if (v3)
  {
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_listener_set_new_connection_handler_block_invoke;
    aBlock[3] = &unk_1E524B950;
    BOOL v15 = v3;
    id v16 = v4;
    qos_class_t v5 = (void (**)(void))_Block_copy(aBlock);
    os_unfair_lock_lock((os_unfair_lock_t)&v3[1]);
    v5[2](v5);
    os_unfair_lock_unlock((os_unfair_lock_t)&v3[1]);

    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_listener_set_new_connection_handler";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_listener_set_new_connection_handler";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null listener", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = v18;
      BOOL v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_listener_set_new_connection_handler";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null listener, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_listener_set_new_connection_handler";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null listener, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_listener_set_new_connection_handler";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null listener, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_183152784(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

nw_listener_t nw_listener_create_with_port(const char *port, nw_parameters_t parameters)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  nw_listener_t v3 = parameters;
  nw_allow_use_of_dispatch_internal();
  if (port)
  {
    if (v3)
    {
      id v4 = nw_listener_copy_parameters_with_port(v3, port, 1);
      if (v4) {
        qos_class_t v5 = -[NWConcrete_nw_listener initWithParameters:multicastDescriptor:]([NWConcrete_nw_listener alloc], v4, 0);
      }
      else {
        qos_class_t v5 = 0;
      }

      goto LABEL_7;
    }
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_listener_create_with_port";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_listener_create_with_port";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v20)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_listener_create_with_port";
          _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_listener_create_with_port";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_listener_create_with_port";
        __int16 v24 = 2082;
        os_log_type_t v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_listener_create_with_port";
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_listener_create_with_port";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null port", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v20)
      {
        os_log_type_t v9 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_listener_create_with_port";
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null port, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v23 = "nw_listener_create_with_port";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null port, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v23 = "nw_listener_create_with_port";
        __int16 v24 = 2082;
        os_log_type_t v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null port, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v8) {
    free(v8);
  }
  qos_class_t v5 = 0;
LABEL_7:

  return (nw_listener_t)v5;
}

void sub_183152C98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_listener_start_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(_DWORD *)(*(void *)(result + 32) + 128) == 0;
  return result;
}

void __nw_listener_set_state_changed_handler_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 128) == 4)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      id v4 = (id)glistenerLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
        int v9 = 136446466;
        os_log_type_t v10 = "nw_listener_set_state_changed_handler_block_invoke";
        __int16 v11 = 2082;
        os_log_type_t v12 = id_string;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Cannot set state changed handler after cancel", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  else
  {
    id v6 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = *(void **)(v7 + 80);
    *(void *)(v7 + 80) = v6;
  }
}

void __nw_listener_set_queue_block_invoke(uint64_t a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 128))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v3 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_listener_set_queue_block_invoke";
    id v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v4, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        qos_class_t v5 = (id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_listener_set_queue_block_invoke";
        uint64_t v7 = "%{public}s Error in client: nw_listener_set_queue called after nw_listener_start";
LABEL_17:
        __int16 v11 = v5;
        os_log_type_t v12 = v6;
        goto LABEL_18;
      }
      if (!v13)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        qos_class_t v5 = (id)gLogObj;
        os_log_type_t v6 = type;
        if (!os_log_type_enabled(v5, type)) {
          goto LABEL_19;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_listener_set_queue_block_invoke";
        uint64_t v7 = "%{public}s Error in client: nw_listener_set_queue called after nw_listener_start, backtrace limit exceeded";
        goto LABEL_17;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      qos_class_t v5 = (id)gLogObj;
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v5, type);
      if (!backtrace_string)
      {
        if (!v10)
        {
LABEL_19:

          if (!v4) {
            goto LABEL_13;
          }
          goto LABEL_12;
        }
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_listener_set_queue_block_invoke";
        uint64_t v7 = "%{public}s Error in client: nw_listener_set_queue called after nw_listener_start, no backtrace";
        __int16 v11 = v5;
        os_log_type_t v12 = v9;
LABEL_18:
        _os_log_impl(&dword_1830D4000, v11, v12, v7, buf, 0xCu);
        goto LABEL_19;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v16 = "nw_listener_set_queue_block_invoke";
        __int16 v17 = 2082;
        os_log_type_t v18 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v5, v9, "%{public}s Error in client: nw_listener_set_queue called after nw_listener_start, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
    if (!v4)
    {
LABEL_13:
      uint64_t v2 = *(void *)(a1 + 32);
      goto LABEL_14;
    }
LABEL_12:
    free(v4);
    goto LABEL_13;
  }
LABEL_14:
  objc_storeStrong((id *)(v2 + 64), *(id *)(a1 + 40));
}

void __nw_listener_set_new_connection_handler_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(_DWORD *)(v2 + 128) == 4)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_listener_log::onceToken != -1) {
        dispatch_once(&__nwlog_listener_log::onceToken, &__block_literal_global_40_44887);
      }
      id v4 = (id)glistenerLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        id_string = nw_listener_get_id_string(*(void **)(a1 + 32));
        int v9 = 136446466;
        BOOL v10 = "nw_listener_set_new_connection_handler_block_invoke";
        __int16 v11 = 2082;
        os_log_type_t v12 = id_string;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [%{public}s] Cannot set new connection handler after cancel", (uint8_t *)&v9, 0x16u);
      }
    }
  }
  else
  {
    os_log_type_t v6 = _Block_copy(*(const void **)(a1 + 40));
    uint64_t v7 = *(void *)(a1 + 32);
    id v8 = *(void **)(v7 + 88);
    *(void *)(v7 + 88) = v6;
  }
}

void nw_endpoint_handler_register_metadata_changed_handler(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v62 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    char v63 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (__nwlog_fault(v63, type, &v88))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v64 = __nwlog_obj();
        os_log_type_t v65 = type[0];
        if (os_log_type_enabled(v64, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v88)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v64 = __nwlog_obj();
        os_log_type_t v67 = type[0];
        BOOL v68 = os_log_type_enabled(v64, type[0]);
        if (backtrace_string)
        {
          if (v68)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            __int16 v90 = 2082;
            id_str = backtrace_string;
            _os_log_impl(&dword_1830D4000, v64, v67, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_96;
        }
        if (v68)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v64, v67, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v64 = __nwlog_obj();
        os_log_type_t v69 = type[0];
        if (os_log_type_enabled(v64, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v64, v69, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_96:
    if (v63) {
      free(v63);
    }
    unsigned int mode = 0;
    goto LABEL_99;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    id v4 = nw_endpoint_handler_copy_flow(v2);
    qos_class_t v5 = (void *)*((void *)v4 + 51);
    if (*((void *)v4 + 130))
    {
      if (!v5) {
        goto LABEL_28;
      }
      uint64_t v6 = v5[3];
      if (!v6) {
        goto LABEL_28;
      }
      uint64_t v7 = *(uint64_t (**)(void))(v6 + 144);
      if (!v7) {
        goto LABEL_28;
      }
      id v8 = (void *)v5[5];
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = v5[11];
        if (v14) {
          v5[11] = v14 + 1;
        }
        char v9 = -1;
      }
      else
      {
        char v9 = 0;
      }
      *(void *)buf = v5;
      buf[8] = v9;
      BOOL v15 = (void *)*((void *)v4 + 52);
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v17 = *((void *)v4 + 58);
        if (v17) {
          *((void *)v4 + 58) = v17 + 1;
        }
        char v16 = -1;
      }
      else
      {
        char v16 = 0;
      }
      *(void *)os_log_type_t type = (char *)v4 + 376;
      char v87 = v16;
      char v18 = v7();
      if (v15 == &nw_protocol_ref_counted_handle)
      {
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        if (v8 != &nw_protocol_ref_counted_handle)
        {
LABEL_24:
          if (v18) {
            goto LABEL_79;
          }
LABEL_28:
          uint64_t v19 = v2;
          BOOL v20 = (*((unsigned char *)v19 + 268) & 0x20) == 0;

          if (v20)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v21 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v22 = v19;

              uint64_t v23 = v22;
              BOOL v24 = (*((unsigned char *)v19 + 268) & 1) == 0;

              if (v24) {
                os_log_type_t v25 = "";
              }
              else {
                os_log_type_t v25 = "dry-run ";
              }
              nw_endpoint_t v26 = nw_endpoint_handler_copy_endpoint(v23);
              logging_description = nw_endpoint_get_logging_description(v26);
              __int16 v28 = v23;
              qos_class_t v29 = v28;
              uint64_t v30 = v28[30];
              if (v30 > 5) {
                uint64_t v31 = "unknown-state";
              }
              else {
                uint64_t v31 = off_1E523FB38[v30];
              }
              char v84 = v31;

              int v32 = v29;
              int v33 = "path";
              switch(v2->mode)
              {
                case 0:
                  break;
                case 1:
                  int v33 = "resolver";
                  break;
                case 2:
                  int v33 = nw_endpoint_flow_mode_string(v32[31]);
                  break;
                case 3:
                  int v33 = "proxy";
                  break;
                case 4:
                  int v33 = "fallback";
                  break;
                case 5:
                  int v33 = "transform";
                  break;
                default:
                  int v33 = "unknown-mode";
                  break;
              }
              unsigned int v83 = v33;

              uint64_t v54 = v32;
              os_log_type_t v55 = v22;
              os_unfair_lock_lock((os_unfair_lock_t)v54 + 28);
              id v56 = v54[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v54 + 28);

              id v57 = v56;
              *(_DWORD *)buf = 136448002;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
              __int16 v90 = 2082;
              id_str = v55->id_str;
              __int16 v92 = 2082;
              os_log_type_t v93 = v25;
              __int16 v94 = 2082;
              uint64_t v95 = (void *)logging_description;
              __int16 v96 = 2082;
              id v97 = v84;
              __int16 v98 = 2082;
              os_log_type_t v99 = v83;
              __int16 v100 = 2114;
              id v101 = v57;
              __int16 v102 = 2082;
              os_log_type_t v103 = "metadata_changed";
              _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] register notification for %{public}s failed", buf, 0x52u);
            }
LABEL_78:

            goto LABEL_79;
          }
          goto LABEL_79;
        }
      }
      else if (v8 != &nw_protocol_ref_counted_handle)
      {
        goto LABEL_24;
      }
      nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      if (v18) {
        goto LABEL_79;
      }
      goto LABEL_28;
    }
    if (!v5 || (v10 = v5[3]) == 0 || (__int16 v11 = *(uint64_t (**)(void))(v10 + 152)) == 0)
    {
LABEL_54:
      __int16 v39 = v2;
      BOOL v40 = (*((unsigned char *)v39 + 268) & 0x20) == 0;

      if (v40)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        __int16 v21 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v41 = v39;

          char v42 = v41;
          BOOL v43 = (*((unsigned char *)v39 + 268) & 1) == 0;

          if (v43) {
            BOOL v44 = "";
          }
          else {
            BOOL v44 = "dry-run ";
          }
          nw_endpoint_t v45 = nw_endpoint_handler_copy_endpoint(v42);
          char v46 = nw_endpoint_get_logging_description(v45);
          uint64_t v47 = v42;
          objc_super v48 = v47;
          uint64_t v49 = v47[30];
          if (v49 > 5) {
            uint64_t v50 = "unknown-state";
          }
          else {
            uint64_t v50 = off_1E523FB38[v49];
          }
          uint64_t v85 = v50;

          __int16 v51 = v48;
          os_log_type_t v52 = v51;
          uint64_t v53 = "path";
          switch(v2->mode)
          {
            case 0:
              break;
            case 1:
              uint64_t v53 = "resolver";
              break;
            case 2:
              uint64_t v53 = nw_endpoint_flow_mode_string(v51[31]);
              break;
            case 3:
              uint64_t v53 = "proxy";
              break;
            case 4:
              uint64_t v53 = "fallback";
              break;
            case 5:
              uint64_t v53 = "transform";
              break;
            default:
              uint64_t v53 = "unknown-mode";
              break;
          }

          BOOL v58 = v52;
          os_unfair_lock_lock((os_unfair_lock_t)v58 + 28);
          id v59 = v58[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v58 + 28);

          size_t v60 = v41->id_str;
          id v61 = v59;
          *(_DWORD *)buf = 136448002;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
          __int16 v90 = 2082;
          id_str = v60;
          __int16 v92 = 2082;
          os_log_type_t v93 = v44;
          __int16 v94 = 2082;
          uint64_t v95 = (void *)v46;
          __int16 v96 = 2082;
          id v97 = v85;
          __int16 v98 = 2082;
          os_log_type_t v99 = v53;
          __int16 v100 = 2114;
          id v101 = v61;
          __int16 v102 = 2082;
          os_log_type_t v103 = "metadata_changed";
          _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] unregister notification for %{public}s failed", buf, 0x52u);
        }
        goto LABEL_78;
      }
LABEL_79:

      goto LABEL_120;
    }
    os_log_type_t v12 = (void *)v5[5];
    if (v12 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v34 = v5[11];
      if (v34) {
        v5[11] = v34 + 1;
      }
      char v13 = -1;
    }
    else
    {
      char v13 = 0;
    }
    *(void *)buf = v5;
    buf[8] = v13;
    BOOL v35 = (void *)*((void *)v4 + 52);
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v37 = *((void *)v4 + 58);
      if (v37) {
        *((void *)v4 + 58) = v37 + 1;
      }
      char v36 = -1;
    }
    else
    {
      char v36 = 0;
    }
    *(void *)os_log_type_t type = (char *)v4 + 376;
    char v87 = v36;
    char v38 = v11();
    if (v35 == &nw_protocol_ref_counted_handle)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)type);
      if (v12 != &nw_protocol_ref_counted_handle)
      {
LABEL_50:
        if (v38) {
          goto LABEL_79;
        }
        goto LABEL_54;
      }
    }
    else if (v12 != &nw_protocol_ref_counted_handle)
    {
      goto LABEL_50;
    }
    nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
    if (v38) {
      goto LABEL_79;
    }
    goto LABEL_54;
  }
LABEL_99:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v70 = (id)gLogObj;
  if (mode > 5) {
    __int16 v71 = "unknown-mode";
  }
  else {
    __int16 v71 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
  __int16 v90 = 2082;
  id_str = (void *)v71;
  __int16 v92 = 2082;
  os_log_type_t v93 = "flow";
  os_log_type_t v72 = (void *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v88 = 0;
  if (!__nwlog_fault((const char *)v72, type, &v88))
  {
LABEL_118:
    if (!v72) {
      goto LABEL_120;
    }
LABEL_119:
    free(v72);
    goto LABEL_120;
  }
  if (type[0] == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v73 = (id)gLogObj;
    os_log_type_t v74 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        __int16 v75 = "unknown-mode";
      }
      else {
        __int16 v75 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
      __int16 v90 = 2082;
      id_str = (void *)v75;
      __int16 v92 = 2082;
      os_log_type_t v93 = "flow";
      _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_117:

    goto LABEL_118;
  }
  if (!v88)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v73 = (id)gLogObj;
    os_log_type_t v80 = type[0];
    if (os_log_type_enabled(v73, type[0]))
    {
      if (mode > 5) {
        uint64_t v81 = "unknown-mode";
      }
      else {
        uint64_t v81 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
      __int16 v90 = 2082;
      id_str = (void *)v81;
      __int16 v92 = 2082;
      os_log_type_t v93 = "flow";
      _os_log_impl(&dword_1830D4000, v73, v80, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_117;
  }
  os_log_type_t v76 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  __int16 v73 = (id)gLogObj;
  os_log_type_t v77 = type[0];
  BOOL v78 = os_log_type_enabled(v73, type[0]);
  if (!v76)
  {
    if (v78)
    {
      if (mode > 5) {
        uint64_t v82 = "unknown-mode";
      }
      else {
        uint64_t v82 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
      __int16 v90 = 2082;
      id_str = (void *)v82;
      __int16 v92 = 2082;
      os_log_type_t v93 = "flow";
      _os_log_impl(&dword_1830D4000, v73, v77, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_117;
  }
  if (v78)
  {
    if (mode > 5) {
      __int16 v79 = "unknown-mode";
    }
    else {
      __int16 v79 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_register_metadata_changed_handler";
    __int16 v90 = 2082;
    id_str = (void *)v79;
    __int16 v92 = 2082;
    os_log_type_t v93 = "flow";
    __int16 v94 = 2082;
    uint64_t v95 = v76;
    _os_log_impl(&dword_1830D4000, v73, v77, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v76);
  if (v72) {
    goto LABEL_119;
  }
LABEL_120:
}

void sub_183153EFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183154A44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_association_update_paths(void *a1, void *a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  qos_class_t v5 = v4;
  if (!v3)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v39 = "nw_association_update_paths";
    uint64_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v37 = OS_LOG_TYPE_ERROR;
    char v36 = 0;
    if (!__nwlog_fault(v14, &v37, &v36)) {
      goto LABEL_45;
    }
    if (v37 == OS_LOG_TYPE_FAULT)
    {
      BOOL v15 = __nwlog_obj();
      os_log_type_t v16 = v37;
      if (os_log_type_enabled(v15, v37))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "nw_association_update_paths";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null association", buf, 0xCu);
      }
    }
    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v15 = __nwlog_obj();
      os_log_type_t v20 = v37;
      BOOL v21 = os_log_type_enabled(v15, v37);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v39 = "nw_association_update_paths";
          __int16 v40 = 2082;
          uint64_t v41 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v14) {
          goto LABEL_11;
        }
LABEL_46:
        free(v14);
        goto LABEL_11;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "nw_association_update_paths";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null association, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v15 = __nwlog_obj();
      os_log_type_t v25 = v37;
      if (os_log_type_enabled(v15, v37))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v39 = "nw_association_update_paths";
        _os_log_impl(&dword_1830D4000, v15, v25, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_44:

    goto LABEL_45;
  }
  if (v4)
  {
    id v6 = nw_path_parameters_copy_context(*((void **)v3 + 2));
    nw_context_assert_queue(v6);
    if (*((void *)v3 + 4))
    {
      uint64_t v7 = (char *)*((void *)v3 + 7);
      if (v7)
      {
        v32[0] = MEMORY[0x1E4F143A8];
        v32[1] = 3221225472;
        v32[2] = ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke;
        v32[3] = &unk_1E524AF30;
        id v33 = v3;
        id v34 = v5;
        id v35 = v6;
        nw_hash_table_apply(v7, (uint64_t)v32);
      }
    }
    id v8 = nw_path_copy_without_parameters(v5);
    char v9 = (void *)*((void *)v3 + 4);
    *((void *)v3 + 4) = v8;

    uint64_t v10 = (char *)*((void *)v3 + 5);
    if (v10)
    {
      int v11 = *((_DWORD *)v3 + 18);
      BOOL v12 = v11 != 0;
      if (v11)
      {
        v30[0] = MEMORY[0x1E4F143A8];
        v30[1] = 3221225472;
        v30[2] = ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_85;
        v30[3] = &unk_1E524AF58;
        id v31 = v5;
        nw_hash_table_apply(v10, (uint64_t)v30);

        uint64_t v10 = (char *)*((void *)v3 + 5);
      }
      v27[0] = MEMORY[0x1E4F143A8];
      v27[1] = 3221225472;
      v27[2] = ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_2;
      v27[3] = &unk_1E524AF80;
      BOOL v29 = v12;
      id v28 = v5;
      nw_hash_table_apply(v10, (uint64_t)v27);
    }
    goto LABEL_11;
  }
  uint64_t v17 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v39 = "nw_association_update_paths";
  uint64_t v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v37 = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (!__nwlog_fault(v14, &v37, &v36)) {
    goto LABEL_45;
  }
  if (v37 == OS_LOG_TYPE_FAULT)
  {
    BOOL v15 = __nwlog_obj();
    os_log_type_t v18 = v37;
    if (os_log_type_enabled(v15, v37))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_association_update_paths";
      _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null path", buf, 0xCu);
    }
    goto LABEL_44;
  }
  if (!v36)
  {
    BOOL v15 = __nwlog_obj();
    os_log_type_t v26 = v37;
    if (os_log_type_enabled(v15, v37))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_association_update_paths";
      _os_log_impl(&dword_1830D4000, v15, v26, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_44;
  }
  os_log_type_t v22 = (char *)__nw_create_backtrace_string();
  BOOL v15 = __nwlog_obj();
  os_log_type_t v23 = v37;
  BOOL v24 = os_log_type_enabled(v15, v37);
  if (!v22)
  {
    if (v24)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_association_update_paths";
      _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s called with null path, no backtrace", buf, 0xCu);
    }
    goto LABEL_44;
  }
  if (v24)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v39 = "nw_association_update_paths";
    __int16 v40 = 2082;
    uint64_t v41 = v22;
    _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v22);
  if (v14) {
    goto LABEL_46;
  }
LABEL_11:
}

void sub_183155164(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_path_necp_update_evaluator(NWConcrete_nw_path_evaluator *a1, const unsigned __int8 *a2, unint64_t a3, int a4)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  id v8 = nw_parameters_copy_context(*((void **)v7 + 1));
  nw_context_assert_queue(v8);
  char v9 = nw_path_create(*((void **)v7 + 2), *((void **)v7 + 1));
  uint64_t v10 = v9;
  if (v9)
  {
    if (a4)
    {
      if (v8) {
        BOOL v11 = v8[31] == 4;
      }
      else {
        BOOL v11 = 0;
      }
      int v16 = !v11;
    }
    else
    {
      int v16 = 0;
    }
    objc_storeStrong((id *)&v9->group_descriptor, *((id *)v7 + 3));
    objc_storeStrong((id *)&v10->browse_descriptor, *((id *)v7 + 4));
    objc_storeStrong((id *)&v10->advertise_descriptor, *((id *)v7 + 5));
    int v20 = *((unsigned char *)v10 + 475) & 0xFE | (*((unsigned __int8 *)v7 + 107) >> 1) & 1;
    *((unsigned char *)v10 + 475) = v20;
    v10->custom_etheros_log_type_t type = *((_WORD *)v7 + 52);
    v10->custom_ip_uint64_t protocol = *((unsigned char *)v7 + 106);
    *((unsigned char *)v10 + 475) = (*((unsigned char *)v7 + 107) >> 1) & 2 | v20 & 0xFD;
    *(_OWORD *)v10->client_id = *((_OWORD *)v7 + 5);
    if (a2 && a3 && nw_path_parse_necp_result(v10, (uint64_t)a2, a3))
    {
      nw_path_snapshot_path(v10);
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 24);
      id v21 = *((id *)v7 + 6);
      objc_storeStrong((id *)v7 + 6, v10);
      *((unsigned char *)v10 + 474) = *((unsigned char *)v10 + 474) & 0xF7 | *((unsigned char *)v21 + 474) & 8;
      objc_storeStrong((id *)&v10->override_local_endpoint, *((id *)v21 + 10));
      objc_storeStrong((id *)&v10->override_interface, *((id *)v21 + 11));
      if (!nw_path_is_equal_inner(v10, v21, 0)) {
        *((unsigned char *)v10 + 474) |= 0x10u;
      }
      os_log_type_t v22 = _Block_copy(*((const void **)v7 + 8));
      os_log_type_t v23 = *((id *)v7 + 7);
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 24);
      if (v23)
      {
        block[0] = MEMORY[0x1E4F143A8];
        block[1] = 3221225472;
        block[2] = ___ZL29nw_path_necp_update_evaluatorP28NWConcrete_nw_path_evaluatorPKhmb_block_invoke;
        block[3] = &unk_1E52484D8;
        int v32 = v7;
        char v35 = v16;
        id v33 = v10;
        id v34 = v22;
        dispatch_async(v23, block);
      }
      else
      {
        os_log_type_t v26 = v7;
        os_unfair_lock_lock((os_unfair_lock_t)v7 + 24);
        char v27 = *((unsigned char *)v7 + 107);
        os_unfair_lock_unlock((os_unfair_lock_t)v7 + 24);

        if ((v27 & 0x20) == 0)
        {
          if ((*((unsigned char *)v7 + 107) & 0x40) != 0 && v16)
          {
            if (__nwlog_path_log::onceToken != -1) {
              dispatch_once(&__nwlog_path_log::onceToken, &__block_literal_global_48_44893);
            }
            id v28 = (id)gpathLogObj;
            if (os_log_type_enabled(v28, OS_LOG_TYPE_INFO))
            {
              logging_description = nw_endpoint_get_logging_description(*((void **)v7 + 2));
              uint64_t v30 = *((void *)v7 + 1);
              *(_DWORD *)buf = 136447490;
              __int16 v39 = "nw_path_necp_update_evaluator";
              __int16 v40 = 1042;
              *(_DWORD *)uint64_t v41 = 16;
              *(_WORD *)&v41[4] = 2098;
              *(void *)&v41[6] = (char *)v7 + 80;
              __int16 v42 = 2082;
              BOOL v43 = logging_description;
              __int16 v44 = 2112;
              uint64_t v45 = v30;
              __int16 v46 = 2112;
              uint64_t v47 = v10;
              _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_INFO, "%{public}s [%{public,uuid_t}.16P %{public}s %@]\n\tpath: %@", buf, 0x3Au);
            }
          }
          (*((void (**)(void *, NWConcrete_nw_path *))v22 + 2))(v22, v10);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v24 = (id)gLogObj;
      if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446466;
        __int16 v39 = "nw_path_necp_update_evaluator";
        __int16 v40 = 2048;
        *(void *)uint64_t v41 = a3;
        _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s Path failed to parse %zu bytes from NECP", buf, 0x16u);
      }
    }
    goto LABEL_47;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v12 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  __int16 v39 = "nw_path_necp_update_evaluator";
  char v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (!__nwlog_fault(v13, &type, &v36)) {
    goto LABEL_45;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_path_necp_update_evaluator";
      _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s nw_path_create failed", buf, 0xCu);
    }
LABEL_44:

LABEL_45:
    if (!v13) {
      goto LABEL_47;
    }
LABEL_46:
    free(v13);
    goto LABEL_47;
  }
  if (!v36)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    os_log_type_t v25 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_path_necp_update_evaluator";
      _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s nw_path_create failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_44;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v14 = (id)gLogObj;
  os_log_type_t v18 = type;
  BOOL v19 = os_log_type_enabled(v14, type);
  if (!backtrace_string)
  {
    if (v19)
    {
      *(_DWORD *)buf = 136446210;
      __int16 v39 = "nw_path_necp_update_evaluator";
      _os_log_impl(&dword_1830D4000, v14, v18, "%{public}s nw_path_create failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_44;
  }
  if (v19)
  {
    *(_DWORD *)buf = 136446466;
    __int16 v39 = "nw_path_necp_update_evaluator";
    __int16 v40 = 2082;
    *(void *)uint64_t v41 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v14, v18, "%{public}s nw_path_create failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v13) {
    goto LABEL_46;
  }
LABEL_47:
}

void sub_1831558C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *nw_path_copy_without_parameters(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = (void *)[a1 copy];
  if (v1)
  {
    nw_parameters_t v2 = nw_parameters_create();
    id v3 = (void *)v1[2];
    v1[2] = v2;

    id v4 = v1;
    goto LABEL_10;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v5 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_path_copy_without_parameters";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (!__nwlog_fault(v6, &type, &v14)) {
    goto LABEL_8;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    os_log_type_t v8 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_path_copy_without_parameters";
      _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s [path copy] failed", buf, 0xCu);
    }
LABEL_7:

LABEL_8:
    if (!v6) {
      goto LABEL_10;
    }
LABEL_9:
    free(v6);
    goto LABEL_10;
  }
  if (!v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v7, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_path_copy_without_parameters";
      _os_log_impl(&dword_1830D4000, v7, v13, "%{public}s [path copy] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_7;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v7 = (id)gLogObj;
  os_log_type_t v11 = type;
  BOOL v12 = os_log_type_enabled(v7, type);
  if (!backtrace_string)
  {
    if (v12)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v17 = "nw_path_copy_without_parameters";
      _os_log_impl(&dword_1830D4000, v7, v11, "%{public}s [path copy] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_7;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v17 = "nw_path_copy_without_parameters";
    __int16 v18 = 2082;
    BOOL v19 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v7, v11, "%{public}s [path copy] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v6) {
    goto LABEL_9;
  }
LABEL_10:

  return v1;
}

void sub_183155C28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_parameters_t nw_parameters_create(void)
{
  uint64_t v0 = [NWConcrete_nw_parameters alloc];
  nw_path_t v1 = objc_alloc_init(NWConcrete_nw_protocol_stack);
  if (v1)
  {
    if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
      dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
    }
    nw_protocol_options_t options = nw_protocol_create_options((void *)g_ip_definition);
    internet_uint64_t protocol = v1->internet_protocol;
    v1->internet_uint64_t protocol = (OS_nw_protocol_options *)options;
  }
  id v4 = -[NWConcrete_nw_parameters initWithStack:]((id *)&v0->super.isa, v1);

  return v4;
}

void sub_183155CD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_protocol_options *nw_protocol_create_options(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v2 = a1;
  id v3 = [NWConcrete_nw_protocol_options alloc];
  id v4 = v2;
  id v5 = v4;
  if (!v3) {
    goto LABEL_6;
  }
  if (!v4)
  {
    char v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v26.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v10, &v26, &type))
    {
      if (LOBYTE(v26.receiver) == 17)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t receiver = (os_log_type_t)v26.receiver;
        if (os_log_type_enabled(v11, (os_log_type_t)v26.receiver))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
          _os_log_impl(&dword_1830D4000, v11, receiver, "%{public}s called with null _definition", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v18 = (os_log_type_t)v26.receiver;
        BOOL v19 = os_log_type_enabled(v11, (os_log_type_t)v26.receiver);
        if (backtrace_string)
        {
          if (v19)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
            __int16 v30 = 2082;
            id v31 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null _definition, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null _definition, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v23 = (os_log_type_t)v26.receiver;
        if (os_log_type_enabled(v11, (os_log_type_t)v26.receiver))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
          _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null _definition, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_36:
    if (v10) {
      free(v10);
    }

    goto LABEL_44;
  }
  v26.os_log_type_t receiver = v3;
  v26.super_class = (Class)NWConcrete_nw_protocol_options;
  id v6 = (NWConcrete_nw_protocol_options *)objc_msgSendSuper2(&v26, sel_init);
  id v3 = v6;
  if (!v6)
  {
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
    char v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v14, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v25)
      {
        uint64_t v20 = (char *)__nw_create_backtrace_string();
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v22 = os_log_type_enabled(v15, type);
        if (v20)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
            __int16 v30 = 2082;
            id v31 = v20;
            _os_log_impl(&dword_1830D4000, v15, v21, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v20);
          goto LABEL_42;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
          _os_log_impl(&dword_1830D4000, v15, v21, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v15 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v15, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v29 = "-[NWConcrete_nw_protocol_options initWithDefinition:]";
          _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (v14) {
      free(v14);
    }
LABEL_44:
    id v3 = 0;
    goto LABEL_6;
  }
  objc_storeStrong((id *)&v6->definition, a1);
  uint64_t v7 = (uint64_t (*)(void *))v5[11];
  if (v7) {
    v3->handle = (void *)v7(v5);
  }
LABEL_6:

  return v3;
}

void sub_1831561F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_ip_allocate_options(void *a1)
{
  id v1 = a1;
  id v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  id v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    void *v2 = 0;
    v2[1] = 0;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183156350(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_183156434(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_flow_registration_copy_path(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v21 = "nw_path_flow_registration_copy_path";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_path_flow_registration_copy_path";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null flow_registration", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v21 = "nw_path_flow_registration_copy_path";
            __int16 v22 = 2082;
            os_log_type_t v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null flow_registration, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_path_flow_registration_copy_path";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null flow_registration, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v21 = "nw_path_flow_registration_copy_path";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null flow_registration, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v11) {
      free(v11);
    }
    goto LABEL_25;
  }
  override_evaluator = v1->override_evaluator;
  if (!override_evaluator)
  {
    id v4 = nw_path_flow_registration_copy_parent_evaluator(v1);
    if (v4) {
      goto LABEL_5;
    }
LABEL_25:
    BOOL v8 = 0;
    goto LABEL_6;
  }
  id v4 = override_evaluator;
LABEL_5:
  id v5 = (os_unfair_lock_s *)((char *)v4 + 96);
  id v6 = v4;
  os_unfair_lock_lock(v5);
  id v7 = v6[6];
  os_unfair_lock_unlock(v5);

  BOOL v8 = nw_path_copy_for_flow_registration(v7, v2);
LABEL_6:

  return v8;
}

void sub_183156740(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_copy_for_flow_registration(void *a1, void *a2)
{
  uint64_t v83 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    id v57 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v80 = "nw_path_copy_for_flow_registration";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v78 = OS_LOG_TYPE_ERROR;
    char v77 = 0;
    if (__nwlog_fault(v58, &v78, &v77))
    {
      if (v78 == OS_LOG_TYPE_FAULT)
      {
        id v59 = __nwlog_obj();
        os_log_type_t v60 = v78;
        if (os_log_type_enabled(v59, v78))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v80 = "nw_path_copy_for_flow_registration";
          _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v77)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v59 = __nwlog_obj();
        os_log_type_t v62 = v78;
        BOOL v63 = os_log_type_enabled(v59, v78);
        if (backtrace_string)
        {
          if (v63)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v80 = "nw_path_copy_for_flow_registration";
            __int16 v81 = 2082;
            uint64_t v82 = (uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_60;
        }
        if (v63)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v80 = "nw_path_copy_for_flow_registration";
          _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v59 = __nwlog_obj();
        os_log_type_t v68 = v78;
        if (os_log_type_enabled(v59, v78))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v80 = "nw_path_copy_for_flow_registration";
          _os_log_impl(&dword_1830D4000, v59, v68, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_60:
    if (v58) {
      free(v58);
    }
    id v6 = 0;
    goto LABEL_35;
  }
  if (!v4)
  {
    id v6 = v3;
LABEL_35:

    return (BOOL)v6;
  }
  id v6 = nw_path_create(*((void **)v3 + 3), *((void **)v3 + 2));
  if (!v6)
  {
LABEL_34:

    goto LABEL_35;
  }
  if (*((void *)v3 + 9))
  {
    BOOL v7 = nw_array_create();
    flows = v6->flows;
    v6->flows = (OS_nw_array *)v7;

    char v9 = (atomic_uchar *)*((void *)v3 + 9);
    v74[0] = MEMORY[0x1E4F143A8];
    v74[1] = 3221225472;
    v74[2] = __nw_path_copy_for_flow_registration_block_invoke;
    void v74[3] = &unk_1E5247FB8;
    __int16 v75 = v5;
    os_log_type_t v76 = v6;
    nw_array_apply(v9, (uint64_t)v74);
  }
  *(_OWORD *)v6->flow_registration_id = *((_OWORD *)v5 + 2);
  *(_OWORD *)v6->client_id = *(_OWORD *)(v3 + 120);
  *(_OWORD *)v6->fallback_agent = *(_OWORD *)(v3 + 152);
  uint64_t v10 = (const char *)*((void *)v3 + 31);
  if (!v10)
  {
    os_log_type_t v64 = __nwlog_obj();
    os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v80 = "strict_strdup";
    __int16 v73 = buf;
    os_log_type_t v65 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v65);
    if (result) {
      goto LABEL_63;
    }
    free(v65);
  }
  os_log_type_t v11 = strdup(v10);
  if (!v11)
  {
    os_log_type_t v66 = __nwlog_obj();
    os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v80 = "strict_strdup";
    __int16 v73 = buf;
    os_log_type_t v67 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v67);
    if (result) {
      goto LABEL_63;
    }
    free(v67);
  }
  v6->reason_description = v11;
  long long v12 = *(_OWORD *)(v3 + 280);
  *(_OWORD *)&v6->policy_result.routing_BOOL result = *(_OWORD *)(v3 + 264);
  *(_OWORD *)v6->policy_result.service_uuid = v12;
  long long v13 = *(_OWORD *)(v3 + 296);
  long long v14 = *(_OWORD *)(v3 + 312);
  long long v15 = *(_OWORD *)(v3 + 344);
  *(_OWORD *)&v6->policy_result.direct_interface_generation = *(_OWORD *)(v3 + 328);
  *(_OWORD *)&v6->policy_result.num_interface_nw_protocol_options_t options = v15;
  *(_OWORD *)&v6->policy_result.netagents = v13;
  *(_OWORD *)&v6->policy_result.service_flags = v14;
  uint64_t v16 = *((unsigned int *)v3 + 87);
  if (v16 && *((void *)v3 + 37))
  {
    uint64_t v17 = 20 * v16;
    char v18 = (necp_client_result_netagent *)malloc_type_malloc(20 * v16, 0xF2B69DE5uLL);
    if (!v18)
    {
      os_log_type_t v69 = __nwlog_obj();
      os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446466;
      os_log_type_t v80 = "strict_malloc";
      __int16 v81 = 2048;
      uint64_t v82 = v17;
      __int16 v73 = buf;
      id v70 = (void *)_os_log_send_and_compose_impl();

      BOOL result = __nwlog_abort((uint64_t)v70);
      if (result) {
        goto LABEL_63;
      }
      free(v70);
      char v18 = 0;
    }
    v6->policy_result.netagents = v18;
    memcpy(v18, *((const void **)v3 + 37), 20 * *((unsigned int *)v3 + 87));
  }
  uint64_t v19 = *((unsigned int *)v3 + 86);
  if (!v19 || !*((void *)v3 + 38))
  {
LABEL_16:
    objc_storeStrong((id *)&v6->group_descriptor, *((id *)v3 + 4));
    objc_storeStrong((id *)&v6->browse_descriptor, *((id *)v3 + 5));
    objc_storeStrong((id *)&v6->discovered_endpoints, *((id *)v3 + 7));
    objc_storeStrong((id *)&v6->resolved_endpoints, *((id *)v3 + 8));
    objc_storeStrong((id *)&v6->direct, *((id *)v3 + 12));
    objc_storeStrong((id *)&v6->delegate, *((id *)v3 + 13));
    objc_storeStrong((id *)&v6->fallback_interface, *((id *)v3 + 14));
    objc_storeStrong((id *)&v6->fallback_agent_domains, *((id *)v3 + 21));
    objc_storeStrong((id *)&v6->fallback_agent_types, *((id *)v3 + 22));
    objc_storeStrong((id *)&v6->resolver_configs, *((id *)v3 + 23));
    objc_storeStrong((id *)&v6->network_agent_dictionary, *((id *)v3 + 28));
    objc_storeStrong((id *)&v6->proxy_settings, *((id *)v3 + 30));
    objc_storeStrong((id *)&v6->proxy_configs, *((id *)v3 + 29));
    int v22 = *((unsigned char *)v6 + 476) & 0xFB | (4 * ((v3[476] >> 2) & 1));
    *((unsigned char *)v6 + 476) = v22;
    v6->effective_mtu = *((_DWORD *)v3 + 90);
    v6->effective_int traffic_class = *((_DWORD *)v3 + 91);
    *(void *)&v6->status = *((void *)v3 + 47);
    v6->recommended_mss = v3[472];
    int v23 = *((unsigned char *)v6 + 473) & 0xFE | v3[473] & 1;
    *((unsigned char *)v6 + 473) = v23;
    unsigned int v24 = v23 & 0xFFFFFFFD | (2 * ((v3[473] >> 1) & 1));
    *((unsigned char *)v6 + 473) = v24;
    unsigned int v25 = v24 & 0xFFFFFFEF | (16 * ((v3[473] >> 4) & 1));
    *((unsigned char *)v6 + 473) = v25;
    unsigned int v26 = v25 & 0xFFFFFFDF | (32 * ((v3[473] >> 5) & 1));
    *((unsigned char *)v6 + 473) = v26;
    LOBYTE(v26) = v26 & 0xBF | (((v3[473] & 0x40) != 0) << 6);
    *((unsigned char *)v6 + 473) = v26;
    *((unsigned char *)v6 + 473) = v3[473] & 0x80 | v26 & 0x7F;
    int v27 = *((unsigned char *)v6 + 474) & 0xFE | v3[474] & 1;
    *((unsigned char *)v6 + 474) = v27;
    unsigned int v28 = v27 & 0xFFFFFFFD | (2 * ((v3[474] >> 1) & 1));
    *((unsigned char *)v6 + 474) = v28;
    unsigned int v29 = v28 & 0xFFFFFFFB | (4 * ((v3[474] >> 2) & 1));
    *((unsigned char *)v6 + 474) = v29;
    unsigned int v30 = v29 & 0xFFFFFFF7 | (8 * ((v3[474] >> 3) & 1));
    *((unsigned char *)v6 + 474) = v30;
    unsigned int v31 = v30 & 0xFFFFFFEF | (16 * ((v3[474] >> 4) & 1));
    *((unsigned char *)v6 + 474) = v31;
    unsigned int v32 = v31 & 0xFFFFFFDF | (32 * ((v3[474] >> 5) & 1));
    *((unsigned char *)v6 + 474) = v32;
    unsigned int v33 = v32 & 0xFFFFFFBF | (((v3[474] >> 6) & 1) << 6);
    *((unsigned char *)v6 + 474) = v33;
    *((unsigned char *)v6 + 474) = v3[474] & 0x80 | v33 & 0x7F;
    unsigned int v34 = v22 & 0xFFFFFFF7 | (8 * ((v3[476] >> 3) & 1));
    *((unsigned char *)v6 + 476) = v34;
    unsigned int v35 = v34 & 0xFFFFFFEF | (16 * ((v3[476] >> 4) & 1));
    *((unsigned char *)v6 + 476) = v35;
    unsigned int v36 = v35 & 0xFFFFFFDF | (32 * ((v3[476] >> 5) & 1));
    *((unsigned char *)v6 + 476) = v36;
    *((unsigned char *)v6 + 476) = v36 & 0xBF | v3[476] & 0x40;
    objc_storeStrong((id *)&v6->gateways, *((id *)v3 + 26));
    v6->nat64_prefixes[0].ipv6_prefix = *(in6_addr *)(v3 + 392);
    long long v42 = *(_OWORD *)(v3 + 408);
    in6_addr v43 = *(in6_addr *)(v3 + 424);
    in6_addr v44 = *(in6_addr *)(v3 + 456);
    *(in6_addr *)((char *)&v6->nat64_prefixes[2].ipv6_prefix + 8) = *(in6_addr *)(v3 + 440);
    *(in6_addr *)((char *)&v6->nat64_prefixes[3].ipv6_prefix + 4) = v44;
    *(_OWORD *)&v6->nat64_prefixes[0].prefix_len = v42;
    *(in6_addr *)((char *)&v6->nat64_prefixes[1].ipv6_prefix + 12) = v43;
    unsigned int v45 = v5[36];
    if (v45 && !*((_DWORD *)v3 + 91))
    {
      v6->effective_int traffic_class = v45;
      uint64_t v46 = *((void *)v5 + 3);
      if (!v46) {
        goto LABEL_22;
      }
    }
    else
    {
      uint64_t v46 = *((void *)v5 + 3);
      if (!v46) {
        goto LABEL_22;
      }
    }
    uint64_t v47 = nw_array_create();
    if (v47 != v46)
    {
      uint64_t v48 = v47;
      std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>(v47 + 16, *(void ***)(v46 + 16), *(void ***)(v46 + 24), (uint64_t)(*(void *)(v46 + 24) - *(void *)(v46 + 16)) >> 3);
      uint64_t v46 = v48;
    }
    override_extra_interface_nw_protocol_options_t options = v6->override_extra_interface_options;
    v6->override_extra_interface_nw_protocol_options_t options = (OS_nw_array *)v46;

LABEL_22:
    int v50 = *((unsigned char *)v6 + 475) & 0xF7 | (8 * ((*((unsigned __int8 *)v5 + 148) >> 3) & 1));
    *((unsigned char *)v6 + 475) = v50;
    unsigned int v51 = v50 & 0xFFFFFFEF | (16 * ((*((unsigned __int8 *)v5 + 148) >> 4) & 1));
    *((unsigned char *)v6 + 475) = v51;
    LOBYTE(v51) = v51 & 0xBF | (((v5[37] & 0x20) != 0) << 6);
    *((unsigned char *)v6 + 475) = v51;
    *((unsigned char *)v6 + 475) = (2 * *((unsigned char *)v5 + 148)) & 0x80 | v51 & 0x7F;
    *((unsigned char *)v6 + 476) = *((unsigned char *)v6 + 476) & 0xFD | (*((unsigned char *)v5 + 148) >> 6) & 2;
    int v52 = *((char *)v5 + 148);
    if (v52 < 0)
    {
      if ((v52 & 0x60) != 0)
      {
        uint64_t v53 = "Proxy used prohibited interface type";
        int v54 = 6;
LABEL_32:
        nw_path_set_reason(v6, v54, v53, v37, v38, v39, v40, v41, (char)v73);
        goto LABEL_33;
      }
      if ((v52 & 8) != 0)
      {
        uint64_t v53 = "Proxy used prohibited expensive path";
        int v54 = 5;
        goto LABEL_32;
      }
      if ((v52 & 0x10) != 0)
      {
        uint64_t v53 = "Proxy used prohibited constrained path";
        int v54 = 26;
        goto LABEL_32;
      }
    }
LABEL_33:
    os_log_type_t v55 = v6;
    goto LABEL_34;
  }
  uint64_t v20 = 24 * v19;
  os_log_type_t v21 = (necp_client_interface_option *)malloc_type_malloc(24 * v19, 0xF2B69DE5uLL);
  if (v21)
  {
LABEL_15:
    v6->policy_result.interface_nw_protocol_options_t options = v21;
    memcpy(v21, *((const void **)v3 + 38), 24 * *((unsigned int *)v3 + 86));
    goto LABEL_16;
  }
  __int16 v71 = __nwlog_obj();
  os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  os_log_type_t v80 = "strict_malloc";
  __int16 v81 = 2048;
  uint64_t v82 = v20;
  __int16 v73 = buf;
  os_log_type_t v72 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v72);
  if (!result)
  {
    free(v72);
    os_log_type_t v21 = 0;
    goto LABEL_15;
  }
LABEL_63:
  __break(1u);
  return result;
}

void sub_183157120(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path *nw_path_create(void *a1, void *a2)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  id v6 = objc_alloc_init(NWConcrete_nw_path);
  BOOL v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unsigned int v28 = "nw_path_create";
    char v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v28 = "nw_path_create";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (!v25)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v28 = "nw_path_create";
        _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v10 = (id)gLogObj;
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v28 = "nw_path_create";
        _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      unsigned int v28 = "nw_path_create";
      __int16 v29 = 2082;
      unsigned int v30 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v16, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_path) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_17;
  }
  if (!v5)
  {
    nw_parameters_t v12 = nw_parameters_create();
    parameters = v7->parameters;
    v7->parameters = (OS_nw_parameters *)v12;

    if (v7->parameters) {
      goto LABEL_10;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    unsigned int v28 = "nw_path_create";
    char v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (!__nwlog_fault(v9, &type, &v25))
    {
LABEL_41:
      if (!v9)
      {
LABEL_43:
        long long v14 = 0;
        goto LABEL_44;
      }
LABEL_42:
      free(v9);
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v10 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v28 = "nw_path_create";
        _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s nw_parameters_create failed", buf, 0xCu);
      }
LABEL_40:

      goto LABEL_41;
    }
    if (!v25)
    {
      uint64_t v10 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v28 = "nw_path_create";
        _os_log_impl(&dword_1830D4000, v10, v23, "%{public}s nw_parameters_create failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_40;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v10 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v10, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v28 = "nw_path_create";
        _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s nw_parameters_create failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_40;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      unsigned int v28 = "nw_path_create";
      __int16 v29 = 2082;
      unsigned int v30 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s nw_parameters_create failed, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_17:

    free(backtrace_string);
    if (!v9) {
      goto LABEL_43;
    }
    goto LABEL_42;
  }
  objc_storeStrong((id *)&v6->parameters, a2);
LABEL_10:
  if (v4) {
    objc_storeStrong((id *)&v7->endpoint, a1);
  }
  long long v14 = v7;
LABEL_44:

  return v14;
}

void sub_1831576FC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_path_evaluator *nw_path_flow_registration_copy_parent_evaluator(NWConcrete_nw_path_flow_registration *a1)
{
  id v1 = a1;
  id v2 = v1;
  parent_evaluator = v1->parent_evaluator;
  if (parent_evaluator)
  {
    id v4 = parent_evaluator;
  }
  else
  {
    subflow_registrations = (atomic_uchar *)v1->subflow_registrations;
    if (subflow_registrations)
    {
      uint64_t v8 = 0;
      char v9 = &v8;
      uint64_t v10 = 0x3032000000;
      os_log_type_t v11 = __Block_byref_object_copy__68682;
      nw_parameters_t v12 = __Block_byref_object_dispose__68683;
      id v13 = 0;
      v7[0] = MEMORY[0x1E4F143A8];
      v7[1] = 3221225472;
      v7[2] = ___ZL47nw_path_flow_registration_copy_parent_evaluatorP36NWConcrete_nw_path_flow_registration_block_invoke;
      v7[3] = &unk_1E5248058;
      v7[4] = &v8;
      nw_array_apply(subflow_registrations, (uint64_t)v7);
      id v4 = (NWConcrete_nw_path_evaluator *)(id)v9[5];
      _Block_object_dispose(&v8, 8);
    }
    else
    {
      id v4 = 0;
    }
  }

  return v4;
}

BOOL nw_path_is_equal_inner(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  BOOL v7 = v5 == v6;
  if (v5 != v6 && v5 && v6)
  {
    if (*(void *)v5->flow_registration_id != *(void *)v6->flow_registration_id
      || *(void *)&v5->flow_registration_id[8] != *(void *)&v6->flow_registration_id[8])
    {
      goto LABEL_50;
    }
    routing_BOOL result = v5->policy_result.routing_result;
    unsigned int v9 = v6->policy_result.routing_result;
    if (routing_result == 3 && v9 == 3)
    {
      BOOL v7 = 1;
      goto LABEL_51;
    }
    if (routing_result != v9
      || v5->policy_result.routing_result_parameter.tunnel_interface_index != v6->policy_result.routing_result_parameter.tunnel_interface_index
      || v5->policy_result.filter_control_unit != v6->policy_result.filter_control_unit
      || v5->policy_result.flow_divert_aggregate_unit != v6->policy_result.flow_divert_aggregate_unit
      || v5->policy_result.service_action != v6->policy_result.service_action
      || (*(void *)v5->policy_result.service_uuid == *(void *)v6->policy_result.service_uuid
        ? (BOOL v10 = *(void *)&v5->policy_result.service_uuid[8] == *(void *)&v6->policy_result.service_uuid[8])
        : (BOOL v10 = 0),
          !v10
       || v5->policy_result.service_flags != v6->policy_result.service_flags
       || v5->policy_result.service_data != v6->policy_result.service_data
       || v5->policy_result.routed_interface_index != v6->policy_result.routed_interface_index
       || v5->policy_result.direct_interface_index != v6->policy_result.direct_interface_index))
    {
LABEL_50:
      BOOL v7 = 0;
      goto LABEL_51;
    }
    unsigned int v36 = v6;
    if (v5->policy_result.direct_interface_generation == v6->policy_result.direct_interface_generation
      && v5->policy_result.delegate_interface_index == v6->policy_result.delegate_interface_index
      && v5->policy_result.delegate_interface_generation == v6->policy_result.delegate_interface_generation
      && v5->policy_result.policy_id == v6->policy_result.policy_id)
    {
      uint64_t num_netagents = v5->policy_result.num_netagents;
      if (num_netagents == v6->policy_result.num_netagents)
      {
        num_interface_nw_protocol_options_t options = v5->policy_result.num_interface_options;
        if (num_interface_options == v6->policy_result.num_interface_options
          && (!num_netagents
           || (netagents = v5->policy_result.netagents) != 0
           && (long long v14 = v36->policy_result.netagents) != 0
           && !memcmp(netagents, v14, 20 * num_netagents))
          && (!num_interface_options
           || (interface_nw_protocol_options_t options = v5->policy_result.interface_options) != 0
           && (os_log_type_t v16 = v36->policy_result.interface_options) != 0
           && !memcmp(interface_options, v16, 24 * num_interface_options))
          && v5->status == v36->status
          && v5->reason == v36->reason)
        {
          if (!nw_path_network_is_satisfied(v5) && !nw_path_network_is_satisfied(v36))
          {
            BOOL v7 = 1;
            id v6 = v36;
            goto LABEL_51;
          }
          if (a3)
          {
            flows = v5->flows;
            id v18 = v36->flows;
            if (flows)
            {
              if (!v18) {
                goto LABEL_82;
              }
              os_log_type_t v21 = flows + 2;
              Class isa = flows[2].super.super.isa;
              os_log_type_t v20 = v21[1].super.super.isa;
              uint64_t v22 = (v20 - isa) >> 3;
              if (v22 != (v18[3].super.super.isa - v18[2].super.super.isa) >> 3) {
                goto LABEL_82;
              }
              if (v20 != isa)
              {
                unint64_t v23 = 0;
                do
                {
                  unsigned int v24 = nw_array_get_object_at_index((uint64_t)v5->flows, v23);
                  char v25 = nw_array_get_object_at_index((uint64_t)v36->flows, v23);
                  BOOL is_equal = nw_path_flow_is_equal(v24, v25);

                  if (!is_equal) {
                    goto LABEL_82;
                  }
                }
                while (v22 != ++v23);
              }
            }
            else if (v18)
            {
              goto LABEL_82;
            }
          }
          if (((*((unsigned char *)v36 + 473) ^ *((unsigned char *)v5 + 473)) & 0xF3) == 0)
          {
            fallback_agent_domains = v5->fallback_agent_domains;
            __int16 v29 = v36->fallback_agent_domains;
            if (fallback_agent_domains && v29 && fallback_agent_domains != v29)
            {
              if (!xpc_equal(fallback_agent_domains, v29)) {
                goto LABEL_82;
              }
            }
            else if (fallback_agent_domains != v29)
            {
              goto LABEL_82;
            }
            fallback_agent_types = v5->fallback_agent_types;
            uint64_t v31 = v36->fallback_agent_types;
            if (fallback_agent_types && v31 && fallback_agent_types != v31)
            {
              if (!xpc_equal(fallback_agent_types, v31)) {
                goto LABEL_82;
              }
            }
            else if (fallback_agent_types != v31)
            {
              goto LABEL_82;
            }
            network_agent_dictionary = v5->network_agent_dictionary;
            unsigned int v33 = v36->network_agent_dictionary;
            if (network_agent_dictionary && v33 && network_agent_dictionary != v33)
            {
              if (!xpc_equal(network_agent_dictionary, v33)) {
                goto LABEL_82;
              }
            }
            else if (network_agent_dictionary != v33)
            {
              goto LABEL_82;
            }
            proxy_settings = v5->proxy_settings;
            unsigned int v35 = v36->proxy_settings;
            if (proxy_settings && v35 && proxy_settings != v35)
            {
              if (!xpc_equal(proxy_settings, v35)) {
                goto LABEL_82;
              }
            }
            else if (proxy_settings != v35)
            {
              goto LABEL_82;
            }
            if (nw_interface_deep_compare(v5->fallback_interface, v36->fallback_interface)
              && nw_interface_deep_compare(v5->direct, v36->direct))
            {
              BOOL v7 = nw_interface_deep_compare(v5->delegate, v36->delegate);
              id v6 = v36;
              goto LABEL_51;
            }
          }
        }
      }
    }
LABEL_82:
    BOOL v7 = 0;
    id v6 = v36;
  }
LABEL_51:

  return v7;
}

void sub_1831587A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

BOOL nw_interface_deep_compare(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (v3 == v4) {
    BOOL v7 = 1;
  }
  else {
    BOOL v7 = nw_interface_shallow_compare(v3, v4)
  }
      && *((_DWORD *)v3 + 22) == *((_DWORD *)v4 + 22)
      && ((*(_WORD *)(v4 + 85) ^ *(_WORD *)(v3 + 85)) & 0x3F) == 0
      && *((_DWORD *)v3 + 15) == *((_DWORD *)v4 + 15)
      && (size_t v5 = v3[32], v5 == v4[32])
      && !memcmp(v3 + 12, v4 + 12, v5)
      && (size_t v6 = v3[56], v6 == v4[56])
      && !memcmp(v3 + 36, v4 + 36, v6)
      && v3[84] == v4[84];

  return v7;
}

BOOL nw_path_network_is_satisfied(NWConcrete_nw_path *a1)
{
  id v1 = a1;
  BOOL is_satisfied_update_reason = nw_path_network_is_satisfied_update_reason(v1, 0);

  return is_satisfied_update_reason;
}

void sub_1831588F8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL23nw_association_activateP25NWConcrete_nw_associationPU27objcproto16OS_nw_parameters8NSObjectbb_block_invoke(uint64_t a1, void *a2)
{
}

BOOL nw_tcp_allocate_options(void *a1)
{
  id v1 = a1;
  id v2 = malloc_type_calloc(1uLL, 0x28uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  id v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  size_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    v2[4] = 0;
    *(_OWORD *)id v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    *((unsigned char *)v2 + 38) = 0;
    *((_WORD *)v2 + 18) = 1;
    *(void *)((char *)v2 + 28) = 0x2FFFFFFFFLL;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183158A68(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_proxy_allocate_options(void *a1)
{
  id v1 = a1;
  id v2 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  id v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  size_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183158BB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_quic_connection_allocate_options(void *a1)
{
  id v1 = a1;
  id v2 = (char *)malloc_type_calloc(1uLL, 0xE0uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  os_log_type_t v16 = __nwlog_obj();
  os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
  BOOL v17 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v17);
  if (!result)
  {
    free(v17);
LABEL_2:
    *((_OWORD *)v2 + 12) = 0u;
    *((_OWORD *)v2 + 13) = 0u;
    *((_OWORD *)v2 + 10) = 0u;
    *((_OWORD *)v2 + 11) = 0u;
    *((_OWORD *)v2 + 8) = 0u;
    *((_OWORD *)v2 + 9) = 0u;
    *((_OWORD *)v2 + 6) = 0u;
    *((_OWORD *)v2 + 7) = 0u;
    *((_OWORD *)v2 + 4) = 0u;
    *((_OWORD *)v2 + 5) = 0u;
    *((_OWORD *)v2 + 2) = 0u;
    *((_OWORD *)v2 + 3) = 0u;
    *(_OWORD *)id v2 = 0u;
    *((_OWORD *)v2 + 1) = 0u;
    id v3 = (void *)nw_protocol_boringssl_copy_definition();
    nw_protocol_options_t options = nw_protocol_create_options(v3);

    objc_storeStrong((id *)v2 + 12, options);
    *((_DWORD *)v2 + 48) = -1;
    *((_WORD *)v2 + 102) = -1;
    *(void *)&long long v5 = -1;
    *((void *)&v5 + 1) = -1;
    *(_OWORD *)id v2 = v5;
    *((_OWORD *)v2 + 1) = v5;
    int v6 = *(unsigned __int16 *)(v2 + 215);
    *((_OWORD *)v2 + 2) = v5;
    int v7 = v6 | (v2[217] << 16);
    *(_DWORD *)(v2 + 206) = 0;
    *(_DWORD *)(v2 + 209) = 0;
    *((_DWORD *)v2 + 50) = 2;
    v7 &= 0xF86000u;
    *(_WORD *)(v2 + 215) = v7 | 1;
    v2[217] = BYTE2(v7);
    *((void *)v2 + 14) = 0;
    *((void *)v2 + 15) = 0;
    *((void *)v2 + 13) = 0;
    uint64_t v8 = (void *)*((void *)v2 + 17);
    *((void *)v2 + 17) = 0;

    unsigned int v9 = (void *)*((void *)v2 + 18);
    *((void *)v2 + 18) = 0;

    BOOL v10 = (void *)*((void *)v2 + 20);
    *((void *)v2 + 20) = 0;

    os_log_type_t v11 = (void *)*((void *)v2 + 21);
    *((void *)v2 + 21) = 0;

    nw_parameters_t v12 = (void *)*((void *)v2 + 22);
    *((void *)v2 + 22) = 0;

    id v13 = (void *)*((void *)v2 + 23);
    *((void *)v2 + 23) = 0;

    long long v14 = (void *)*((void *)v2 + 19);
    *((void *)v2 + 19) = 0;

    v2[214] = -1;
    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_183158DF4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_quic_stream_allocate_options(void *a1)
{
  id v1 = a1;
  id v2 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (!v2)
  {
    int v6 = __nwlog_obj();
    os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
    int v7 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v7);
    if (result)
    {
      __break(1u);
      return result;
    }
    free(v7);
  }
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55981);
  }
  nw_protocol_options_t options = nw_protocol_create_options((void *)nw_protocol_copy_quic_connection_definition::quic_definition);
  id v4 = (void *)v2[2];
  v2[2] = options;

  return (BOOL)v2;
}

void sub_183158F8C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_udp_allocate_options(void *a1)
{
  id v1 = a1;
  id v2 = malloc_type_calloc(1uLL, 4uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  id v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  long long v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_1831590D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_uses_multipath(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v19 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_uses_multipath_block_invoke;
    v13[3] = &unk_1E524B978;
    long long v14 = v1;
    long long v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_uses_multipath_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  long long v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_uses_multipath";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_uses_multipath_block_invoke(uint64_t a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = nw_endpoint_handler_uses_multipath(*(void **)(v2 + 144));
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_INFO))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        int v6 = 136446466;
        int v7 = "nw_connection_uses_multipath_block_invoke";
        __int16 v8 = 1024;
        int v9 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_INFO, "%{public}s [C%u]  has no connected handler", (uint8_t *)&v6, 0x12u);
      }
    }
  }
}

BOOL nw_endpoint_handler_uses_multipath(void *a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 28);
    if (v2[29]._os_unfair_lock_opaque != 2)
    {
      BOOL v10 = 0;
LABEL_30:
      os_unfair_lock_unlock(v2 + 28);
      goto LABEL_31;
    }
    uint64_t v3 = *(id *)&v2[62]._os_unfair_lock_opaque;
    id v4 = v3;
    if (v3)
    {
      *(void *)os_log_type_t type = 0;
      uint64_t v37 = type;
      uint64_t v38 = 0x2020000000;
      char v39 = 0;
      if (!nw_endpoint_flow_is_multipath(v3))
      {
LABEL_28:
        BOOL v10 = *((unsigned char *)v37 + 24) != 0;
        _Block_object_dispose(type, 8);
LABEL_29:

        goto LABEL_30;
      }
      id v5 = nw_endpoint_flow_copy_connected_socket_wrapper(v4);
      int v6 = (void *)v4[117];
      if (v6)
      {
        int v7 = v6;
        id v8 = v7[4];

        if (v8 && nw_parameters_get_upper_transport_protocol(v8) == 253) {
          goto LABEL_16;
        }
        uint64_t v9 = v4[90];
        if (!v9) {
          goto LABEL_14;
        }
      }
      else
      {
        id v8 = 0;
        uint64_t v9 = v4[90];
        if (!v9) {
          goto LABEL_14;
        }
      }
      BOOL v11 = *(const char **)(v9 + 16);
      if (!v11 || strcmp(v11, "quic"))
      {
LABEL_14:
        if (v5)
        {
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&buf[8] = 3221225472;
          *(void *)&buf[16] = __nw_endpoint_flow_uses_multipath_block_invoke;
          long long v42 = &unk_1E524A270;
          in6_addr v43 = type;
          nw_fd_wrapper_get_fd(v5, buf);
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v17 = (id)gLogObj;
          if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
            _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s Protocol not supported", buf, 0xCu);
          }
        }
LABEL_27:

        goto LABEL_28;
      }
LABEL_16:
      if (gLogDatapath)
      {
        unsigned int v35 = __nwlog_obj();
        if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "%{public}s Querying QUIC for migration status", buf, 0xCu);
        }
      }
      uint64_t v12 = v4[51];
      if (v12)
      {
        uint64_t v13 = *(void *)(v12 + 24);
        if (v13)
        {
          long long v14 = *(uint64_t (**)(void))(v13 + 224);
          if (v14)
          {
            uint64_t v15 = v14();
            char v16 = (void **)v15;
            if (v15)
            {
              *((unsigned char *)v37 + 24) = (*(unsigned char *)(v15 + 12) & 2) != 0;
              nw_array_remove_all_objects(*(void *)v15);
              if (*v16) {
                os_release(*v16);
              }
              free(v16);
            }
          }
        }
      }
      goto LABEL_27;
    }
    unint64_t v23 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
    unsigned int v24 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v40 = 0;
    if (__nwlog_fault(v24, type, &v40))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        char v25 = __nwlog_obj();
        os_log_type_t v26 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v40)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v25 = __nwlog_obj();
        os_log_type_t v31 = type[0];
        BOOL v32 = os_log_type_enabled(v25, type[0]);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v25, v31, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_70;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_1830D4000, v25, v31, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v25 = __nwlog_obj();
        os_log_type_t v34 = type[0];
        if (os_log_type_enabled(v25, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_uses_multipath";
          _os_log_impl(&dword_1830D4000, v25, v34, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_70:
    if (v24) {
      free(v24);
    }
    BOOL v10 = 0;
    goto LABEL_29;
  }
  char v19 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
  uint64_t v20 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v40 = 0;
  if (__nwlog_fault(v20, type, &v40))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v40)
    {
      int v27 = (char *)__nw_create_backtrace_string();
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v28 = type[0];
      BOOL v29 = os_log_type_enabled(v21, type[0]);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v27;
          _os_log_impl(&dword_1830D4000, v21, v28, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v27);
        goto LABEL_58;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_1830D4000, v21, v28, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v21 = __nwlog_obj();
      os_log_type_t v33 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_uses_multipath";
        _os_log_impl(&dword_1830D4000, v21, v33, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_58:
  if (v20) {
    free(v20);
  }
  BOOL v10 = 0;
LABEL_31:

  return v10;
}

void sub_183159C98(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_is_multipath(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0)
    {
      uint64_t is_multipath = (v2[8]._os_unfair_lock_opaque & 0x8000) != 0;
    }
    else
    {
      uint64_t v3 = *(NWConcrete_nw_endpoint_handler **)&v2[234]._os_unfair_lock_opaque;
      if (v3)
      {
        id v4 = nw_endpoint_handler_copy_flow(v3);
        uint64_t is_multipath = nw_endpoint_flow_is_multipath();
      }
      else
      {
        uint64_t is_multipath = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_8;
  }
  int v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v18 = "nw_endpoint_flow_is_multipath";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          id v18 = "nw_endpoint_flow_is_multipath";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_endpoint_flow_is_multipath";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v8) {
    free(v8);
  }
  uint64_t is_multipath = 0;
LABEL_8:

  return is_multipath;
}

void sub_183159FB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_enable_tls_keylog()
{
  uint64_t result = os_variant_allows_internal_security_policies();
  if (result)
  {
    id v1 = (const char *)nw_setting_tcpconn_enable_tls_keylog;
    return networkd_settings_get_BOOL(v1);
  }
  return result;
}

void NWConnection.send(content:contentContext:isComplete:completion:)(uint64_t a1, unint64_t a2, uint64_t a3, char a4, uint64_t *a5)
{
  uint64_t v9 = *a5;
  if (*a5)
  {
    uint64_t v10 = a5[1];
    BOOL v11 = *(NSObject **)(v5 + 16);
    sub_18315ED5C(*a5);
    swift_unknownObjectRetain();
    if (a2 >> 60 == 15) {
      BOOL v13 = 0;
    }
    else {
      BOOL v13 = (void *)sub_183D4452C();
    }
    BOOL v17 = NWCreateDispatchDataFromNSData(v13, v12);

    id v18 = *(NSObject **)(a3 + 16);
    uint64_t v19 = swift_allocObject();
    *(void *)(v19 + 16) = v9;
    *(void *)(v19 + 24) = v10;
    void aBlock[4] = sub_1832E6DE8;
    aBlock[5] = v19;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 1107296256;
    aBlock[2] = sub_1832E6C64;
    aBlock[3] = &block_descriptor_9_0;
    uint64_t v20 = _Block_copy(aBlock);
    sub_18315ED5C(v9);
    swift_unknownObjectRetain();
    swift_release();
    nw_connection_send(v11, v17, v18, a4 & 1, v20);
    _Block_release(v20);
    swift_unknownObjectRelease();

    swift_unknownObjectRelease();
    sub_18313D870(v9);
  }
  else
  {
    os_log_type_t v14 = *(NSObject **)(v5 + 16);
    swift_unknownObjectRetain();
    if (a2 >> 60 == 15) {
      char v16 = 0;
    }
    else {
      char v16 = (void *)sub_183D4452C();
    }
    uint64_t v21 = NWCreateDispatchDataFromNSData(v16, v15);

    nw_connection_send_idempotent(v14, v21, *(NSObject **)(a3 + 16), a4 & 1);
    swift_unknownObjectRelease();
  }
}

void *NWCreateDispatchDataFromNSData(void *a1, const char *a2)
{
  if (a1) {
    return (void *)[a1 _createDispatchData];
  }
  return a1;
}

uint64_t sub_18315A2BC(NSObject *a1, uint64_t a2, void (*a3)(void))
{
  swift_retain();
  swift_unknownObjectRetain();
  uint64_t result = sub_18315A340(a2, a1);
  if (result)
  {
    a3();
    return swift_release();
  }
  return result;
}

uint64_t sub_18315A340(uint64_t a1, NSObject *a2)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  MEMORY[0x1F4188790](v4 - 8);
  int v6 = (char *)&v17 - ((v5 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = type metadata accessor for NWEndpoint();
  uint64_t v8 = *(void *)(v7 - 8);
  uint64_t v9 = MEMORY[0x1F4188790](v7);
  BOOL v11 = (char *)&v17 - ((v10 + 15) & 0xFFFFFFFFFFFFFFF0);
  MEMORY[0x1F4188790](v9);
  BOOL v13 = (char *)&v17 - v12;
  os_log_type_t v14 = nw_connection_copy_endpoint(a2);
  sub_18315A830(v14, (uint64_t)v6);
  if ((*(unsigned int (**)(char *, uint64_t, uint64_t))(v8 + 48))(v6, 1, v7) == 1)
  {
    swift_release();
    swift_unknownObjectRelease();
    sub_183138A24((uint64_t)v6, qword_1EB266A50);
    return 0;
  }
  else
  {
    sub_18315EE34((uint64_t)v6, (uint64_t)v13, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    sub_18315E728((uint64_t)v13, (uint64_t)v11, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
    type metadata accessor for NWConnection(0);
    swift_allocObject();
    uint64_t v15 = sub_18315E310((uint64_t)v11, a1, (uint64_t)a2);
    swift_release();
    swift_unknownObjectRelease();
    sub_18315E45C((uint64_t)v13, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
  }
  return v15;
}

nw_endpoint_t nw_connection_copy_endpoint(nw_connection_t connection)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = connection;
  nw_connection_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[1].isa;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_connection_copy_endpoint";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_connection_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_connection_copy_endpoint";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_connection_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_connection_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t sub_18315A7F8(uint64_t a1, uint64_t *a2)
{
  uint64_t result = *a2;
  if (!*a2) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t sub_18315A830@<X0>(NSObject *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  MEMORY[0x1F4188790]();
  uint64_t v7 = (char *)&v38 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  if (a1)
  {
    uint64_t v39 = v5;
    os_log_type_t v8 = (void *)swift_unknownObjectRetain();
    id v9 = nw_endpoint_copy_interface(v8);
    uint64_t v10 = (uint64_t)v9;
    if (v9) {
      uint64_t v11 = (uint64_t)v9;
    }
    else {
      uint64_t v11 = 1;
    }
    nw_txt_record_t v12 = nw_endpoint_copy_txt_record(a1);
    swift_unknownObjectRelease();
    if (v12 || nw_endpoint_has_signature(a1)) {
      goto LABEL_7;
    }
    if (nw_endpoint_get_type(a1) == nw_endpoint_type_host)
    {
      nw_endpoint_get_hostname(a1);
      uint64_t v14 = sub_183D44C9C();
      uint64_t v16 = v15;
      swift_unknownObjectRetain();
      uint16_t port = nw_endpoint_get_port(a1);
      swift_unknownObjectRelease();
      swift_unknownObjectRelease_n();
      *(void *)uint64_t v7 = v14;
      *((void *)v7 + 1) = v16;
      *((void *)v7 + 2) = v11;
      v7[24] = 0;
      *((_WORD *)v7 + 13) = port;
      goto LABEL_8;
    }
    if (nw_endpoint_get_type(a1) != nw_endpoint_type_address)
    {
      if (nw_endpoint_get_type(a1) == nw_endpoint_type_bonjour_service)
      {
        nw_endpoint_get_bonjour_service_name(a1);
        uint64_t v38 = sub_183D44C9C();
        uint64_t v24 = v23;
        nw_endpoint_get_bonjour_service_type(a1);
        uint64_t v25 = sub_183D44C9C();
        uint64_t v27 = v26;
        nw_endpoint_get_bonjour_service_domain(a1);
        uint64_t v28 = sub_183D44C9C();
        uint64_t v30 = v29;
        swift_unknownObjectRelease_n();
        *(void *)uint64_t v7 = v38;
        *((void *)v7 + 1) = v24;
        *((void *)v7 + 2) = v25;
        *((void *)v7 + 3) = v27;
        *((void *)v7 + 4) = v28;
        *((void *)v7 + 5) = v30;
        *((void *)v7 + 6) = v11;
        goto LABEL_8;
      }
      if (nw_endpoint_get_type(a1) == nw_endpoint_type_url)
      {
        os_log_type_t v31 = (void *)nw_endpoint_copy_cfurl(a1);
        sub_183D4443C();

        swift_unknownObjectRelease();
        swift_unknownObjectRelease_n();
        goto LABEL_8;
      }
LABEL_7:
      swift_unknownObjectRelease();
      swift_unknownObjectRelease();
      *(void *)uint64_t v7 = a1;
LABEL_8:
      swift_storeEnumTagMultiPayload();
LABEL_9:
      sub_18315E28C((uint64_t)v7, a2);
      return (*(uint64_t (**)(uint64_t, void, uint64_t, uint64_t))(v39 + 56))(a2, 0, 1, v4);
    }
    uint16_t v18 = nw_endpoint_get_port(a1);
    address = nw_endpoint_get_address(a1);
    int sa_family = address->sa_family;
    if (sa_family == 1)
    {
      BOOL v32 = nw_endpoint_copy_address_string(a1);
      *(void *)uint64_t v7 = sub_183D44C9C();
      *((void *)v7 + 1) = v33;
      swift_storeEnumTagMultiPayload();
      MEMORY[0x185318E50](v32, -1, -1);
      swift_unknownObjectRelease();
      swift_unknownObjectRelease_n();
      goto LABEL_9;
    }
    if (sa_family != 30)
    {
      if (sa_family == 2 && address->sa_len == 16)
      {
        uint64_t v21 = *(unsigned int *)&address->sa_data[2];
        swift_unknownObjectRelease_n();
        *(void *)uint64_t v7 = v21;
        *((void *)v7 + 1) = v11;
        *((void *)v7 + 2) = 0;
        char v22 = 1;
LABEL_37:
        v7[24] = v22;
        *((_WORD *)v7 + 13) = v18;
        goto LABEL_8;
      }
      goto LABEL_30;
    }
    if (address->sa_len != 28)
    {
LABEL_30:
      swift_unknownObjectRelease();
      swift_unknownObjectRelease_n();
      uint64_t v5 = v39;
      goto LABEL_31;
    }
    uint64_t v35 = *(void *)&address->sa_data[6];
    uint64_t v34 = *(void *)&address[1].sa_len;
    if (v11 == 1)
    {
      unsigned int v36 = *(_DWORD *)&address[1].sa_data[6];
      if (v36)
      {
        uint64_t v10 = (uint64_t)nw_interface_create_with_index(v36);
        swift_unknownObjectRelease_n();
        if (!v10) {
          uint64_t v10 = 1;
        }
        goto LABEL_36;
      }
      uint64_t v10 = 1;
    }
    swift_unknownObjectRelease_n();
LABEL_36:
    *(void *)uint64_t v7 = v35;
    *((void *)v7 + 1) = v34;
    *((void *)v7 + 2) = v10;
    char v22 = 2;
    goto LABEL_37;
  }
LABEL_31:
  uint64_t v37 = *(uint64_t (**)(uint64_t, uint64_t, uint64_t, uint64_t))(v5 + 56);

  return v37(a2, 1, 1, v4);
}

void nw_resolver_insert_address(void *a1, void *a2, const sockaddr *a3, uint64_t a4, void *a5)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  id v9 = a1;
  id v10 = a2;
  id v11 = a5;
  nw_endpoint_t address = nw_endpoint_create_address(a3);
  char v40 = a3;
  nw_endpoint_set_parent_endpoint(address, v9[3], 0);
  nw_endpoint_set_priority(address, a4);
  if (v11) {
    nw_endpoint_set_ech_config(address, v11);
  }
  if (!v10) {
    goto LABEL_29;
  }
  uint64_t v43 = 0;
  dnssd_getaddrinfo_result_get_validation_data();
  char v13 = dnssd_getaddrinfo_result_get_cnames();
  if (v13)
  {
    uint64_t v14 = address;
    uint64_t v39 = v13;
    id v15 = v13;
    if (v14)
    {
      uint64_t v16 = (void *)v14[15];
      v14[15] = 0;

      uint64_t count = dnssd_cname_array_get_count();
      if (count)
      {
        BOOL v18 = nw_array_create();
        uint64_t v19 = (void *)v14[15];
        v14[15] = v18;

        unsigned int v20 = [v14 type];
        unsigned int v21 = 0;
        if (v20 <= 4 && ((1 << v20) & 0x16) != 0) {
          unsigned int v21 = __rev16([v14 port]);
        }
        for (uint64_t i = 0; i != count; ++i)
        {
          cname = (const char *)dnssd_cname_array_get_cname();
          host_with_numeric_uint16_t port = nw_endpoint_create_host_with_numeric_port(cname, v21);
          if (host_with_numeric_port) {
            nw_array_append(v14[15], (void *)host_with_numeric_port);
          }
        }
      }
LABEL_14:

      char v13 = v39;
      goto LABEL_15;
    }
    os_log_type_t v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_set_dnssd_cname_array";
    BOOL v32 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    unsigned __int8 v44 = 0;
    if (__nwlog_fault(v32, type, &v44))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v34 = type[0];
        if (os_log_type_enabled(v33, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_dnssd_cname_array";
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v44)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v38 = type[0];
        BOOL v36 = os_log_type_enabled(v33, type[0]);
        if (backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_set_dnssd_cname_array";
            __int16 v46 = 2082;
            uint64_t v47 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v33, v38, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_dnssd_cname_array";
          _os_log_impl(&dword_1830D4000, v33, v38, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v33 = __nwlog_obj();
        os_log_type_t v37 = type[0];
        if (os_log_type_enabled(v33, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_set_dnssd_cname_array";
          _os_log_impl(&dword_1830D4000, v33, v37, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_47:
    if (v32) {
      free(v32);
    }
    goto LABEL_14;
  }
LABEL_15:
  *(void *)buf = 0;
  *(void *)buf = dnssd_getaddrinfo_result_get_tracker_hostname();
  *(void *)os_log_type_t type = 0;
  *(void *)os_log_type_t type = dnssd_getaddrinfo_result_get_tracker_owner();
  uint64_t v25 = *(const char **)buf;
  if (*(void *)buf) {
    goto LABEL_19;
  }
  uint64_t v26 = nw_context_copy_tracker_lookup_callback(v9[4]);
  uint64_t v27 = v26;
  if (v26)
  {
    unsigned __int8 v44 = 0;
    (*((void (**)(void *, nw_endpoint_t, unsigned char *, os_log_type_t *, unsigned __int8 *))v26 + 2))(v26, address, buf, type, &v44);
    nw_endpoint_set_can_block_request(address, v44);
    nw_endpoint_set_can_block_request(v9[3], v44);
  }

  uint64_t v25 = *(const char **)buf;
  if (*(void *)buf | *(void *)type)
  {
LABEL_19:
    nw_endpoint_set_known_tracker_name(address, v25);
    nw_endpoint_set_known_tracker_name(v9[3], *(const char **)buf);
    nw_endpoint_set_tracker_owner(address, *(const char **)type);
    nw_endpoint_set_tracker_owner(v9[3], *(const char **)type);
  }
  if (dnssd_getaddrinfo_result_get_tracker_is_approved()) {
    nw_endpoint_set_is_approved_app_domain(address, 1);
  }
  if (dnssd_getaddrinfo_result_get_tracker_can_block_request()) {
    nw_endpoint_set_can_block_request(address, 1);
  }
  unsigned int interface_index = dnssd_getaddrinfo_result_get_interface_index();
  if (interface_index && (uint64_t v29 = nw_endpoint_get_address(address), nw_resolver_should_scope_address(v29)))
  {
    BOOL v30 = nw_resolver_set_interface_on_endpoint(v9, interface_index, address);

    if (!v30) {
      goto LABEL_30;
    }
  }
  else
  {
  }
LABEL_29:
  v41[0] = MEMORY[0x1E4F143A8];
  v41[1] = 3221225472;
  v41[2] = ___ZL26nw_resolver_insert_addressP22NWConcrete_nw_resolverPU38objcproto27OS_dnssd_getaddrinfo_result8NSObjectPK8sockaddrtPU27objcproto16OS_dispatch_dataS1__block_invoke;
  v41[3] = &__block_descriptor_40_e63_B24__0__NSObject_OS_nw_endpoint__8__NSObject_OS_nw_endpoint__16l;
  v41[4] = v40;
  nw_resolver_insert_endpoint_locked(v9, address, v41);
LABEL_30:
}

void sub_18315B218(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_create_host_with_numeric_port(const char *a1, unsigned int a2)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    os_log_type_t v37 = __nwlog_obj();
    buf.ai_flags = 136446210;
    *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62.receiver) = 0;
    if (!__nwlog_fault(v7, type, &v62)) {
      goto LABEL_60;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v38 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446210;
        *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_1830D4000, v8, v38, "%{public}s called with null hostname", (uint8_t *)&buf, 0xCu);
      }
    }
    else if (LOBYTE(v62.receiver))
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v40 = type[0];
      BOOL v41 = os_log_type_enabled(v8, type[0]);
      if (backtrace_string)
      {
        if (v41)
        {
          buf.ai_flags = 136446466;
          *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
          LOWORD(buf.ai_protocol) = 2082;
          *(void *)((char *)&buf.ai_protocol + 2) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v40, "%{public}s called with null hostname, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x16u);
        }

        free(backtrace_string);
LABEL_60:
        if (!v7) {
          return 0;
        }
LABEL_61:
        free(v7);
        return 0;
      }
      if (v41)
      {
        buf.ai_flags = 136446210;
        *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_1830D4000, v8, v40, "%{public}s called with null hostname, no backtrace", (uint8_t *)&buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v48 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446210;
        *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_1830D4000, v8, v48, "%{public}s called with null hostname, backtrace limit exceeded", (uint8_t *)&buf, 0xCu);
      }
    }
    goto LABEL_59;
  }
  size_t v4 = strlen(a1);
  if (!v4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    buf.ai_flags = 136446466;
    *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
    LOWORD(buf.ai_protocol) = 2082;
    *(void *)((char *)&buf.ai_protocol + 2) = "hostname";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v62.receiver) = 0;
    if (!__nwlog_fault(v7, type, &v62)) {
      goto LABEL_60;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v9 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446466;
        *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        LOWORD(buf.ai_protocol) = 2082;
        *(void *)((char *)&buf.ai_protocol + 2) = "hostname";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s invalid empty string %{public}s", (uint8_t *)&buf, 0x16u);
      }
    }
    else if (LOBYTE(v62.receiver))
    {
      uint64_t v16 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v17 = type[0];
      BOOL v18 = os_log_type_enabled(v8, type[0]);
      if (v16)
      {
        if (v18)
        {
          buf.ai_flags = 136446722;
          *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
          LOWORD(buf.ai_protocol) = 2082;
          *(void *)((char *)&buf.ai_protocol + 2) = "hostname";
          *((_WORD *)&buf.ai_addrlen + 3) = 2082;
          buf.ai_canonname = v16;
          _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s invalid empty string %{public}s, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
        }

        goto LABEL_26;
      }
      if (v18)
      {
        buf.ai_flags = 136446466;
        *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        LOWORD(buf.ai_protocol) = 2082;
        *(void *)((char *)&buf.ai_protocol + 2) = "hostname";
        _os_log_impl(&dword_1830D4000, v8, v17, "%{public}s invalid empty string %{public}s, no backtrace", (uint8_t *)&buf, 0x16u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v8 = (id)gLogObj;
      os_log_type_t v29 = type[0];
      if (os_log_type_enabled(v8, type[0]))
      {
        buf.ai_flags = 136446466;
        *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
        LOWORD(buf.ai_protocol) = 2082;
        *(void *)((char *)&buf.ai_protocol + 2) = "hostname";
        _os_log_impl(&dword_1830D4000, v8, v29, "%{public}s invalid empty string %{public}s, backtrace limit exceeded", (uint8_t *)&buf, 0x16u);
      }
    }
LABEL_59:

    goto LABEL_60;
  }
  if (v4 >= 0x400)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v5 = (id)gLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
    {
      buf.ai_flags = 136446722;
      *(void *)&buf.ai_family = "nw_endpoint_create_host_with_numeric_port";
      LOWORD(buf.ai_protocol) = 2082;
      *(void *)((char *)&buf.ai_protocol + 2) = "hostname";
      *((_WORD *)&buf.ai_addrlen + 3) = 1024;
      LODWORD(buf.ai_canonname) = 1024;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s %{public}s is longer than %d", (uint8_t *)&buf, 0x1Cu);
    }

    return 0;
  }
  memset(&buf, 0, sizeof(buf));
  buf.ai_flags = 4;
  buf.ai_sockos_log_type_t type = 1;
  id v59 = 0;
  if (!getaddrinfo(a1, 0, &buf, &v59))
  {
    if (v59)
    {
      ai_addr = v59->ai_addr;
      if (ai_addr)
      {
        socklen_t ai_addrlen = v59->ai_addrlen;
        if (ai_addrlen <= 0x1C)
        {
          unsigned int sa_len = ai_addr->sa_len;
          if (ai_addrlen == sa_len)
          {
            int sa_family = ai_addr->sa_family;
            BOOL v23 = sa_len >= 0x10 && sa_family == 2;
            if (v23 || (sa_len >= 0x1C ? (BOOL v24 = sa_family == 30) : (BOOL v24 = 0), v24)) {
              *(_WORD *)ai_addr->sa_dispatch_data_t data = __rev16(a2);
            }
            nw_endpoint_t address = nw_endpoint_create_address(v59->ai_addr);
LABEL_73:
            if (v59)
            {
              freeaddrinfo(v59);
              id v59 = 0;
            }
            if (address) {
              return (BOOL)address;
            }
            goto LABEL_13;
          }
        }
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446467;
    os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
    __int16 v65 = 2085;
    os_log_type_t v66 = (void *)a1;
    uint64_t v26 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v62.receiver) = 16;
    os_log_type_t v61 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v26, &v62, &v61))
    {
      if (LOBYTE(v62.receiver) == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v27 = (id)gLogObj;
        os_log_type_t receiver = (os_log_type_t)v62.receiver;
        if (os_log_type_enabled(v27, (os_log_type_t)v62.receiver))
        {
          *(_DWORD *)os_log_type_t type = 136446467;
          os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
          __int16 v65 = 2085;
          os_log_type_t v66 = (void *)a1;
          _os_log_impl(&dword_1830D4000, v27, receiver, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed", (uint8_t *)type, 0x16u);
        }
      }
      else if (v61)
      {
        BOOL v30 = __nw_create_backtrace_string();
        if (v30)
        {
          os_log_type_t v31 = (char *)v30;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v32 = (id)gLogObj;
          os_log_type_t v33 = (os_log_type_t)v62.receiver;
          if (os_log_type_enabled(v32, (os_log_type_t)v62.receiver))
          {
            *(_DWORD *)os_log_type_t type = 136446723;
            os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
            __int16 v65 = 2085;
            os_log_type_t v66 = (void *)a1;
            __int16 v67 = 2082;
            os_log_type_t v68 = v31;
            _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x20u);
          }

          free(v31);
          if (!v26) {
            goto LABEL_72;
          }
          goto LABEL_71;
        }
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v36 = (os_log_type_t)v62.receiver;
        if (os_log_type_enabled(v27, (os_log_type_t)v62.receiver))
        {
          *(_DWORD *)os_log_type_t type = 136446467;
          os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
          __int16 v65 = 2085;
          os_log_type_t v66 = (void *)a1;
          _os_log_impl(&dword_1830D4000, v27, v36, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed, no backtrace", (uint8_t *)type, 0x16u);
        }
      }
      else
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v35 = (os_log_type_t)v62.receiver;
        if (os_log_type_enabled(v27, (os_log_type_t)v62.receiver))
        {
          *(_DWORD *)os_log_type_t type = 136446467;
          os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
          __int16 v65 = 2085;
          os_log_type_t v66 = (void *)a1;
          _os_log_impl(&dword_1830D4000, v27, v35, "%{public}s getaddrinfo(\"%{sensitive}s\"...) failed, backtrace limit exceeded", (uint8_t *)type, 0x16u);
        }
      }
    }
    if (!v26)
    {
LABEL_72:
      nw_endpoint_t address = 0;
      goto LABEL_73;
    }
LABEL_71:
    free(v26);
    goto LABEL_72;
  }
LABEL_13:
  id v10 = [NWConcrete_nw_host_endpoint alloc];
  if (!v10)
  {
LABEL_113:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v53 = (id)gLogObj;
    *(_DWORD *)os_log_type_t type = 136446210;
    os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v62.receiver) = 16;
    os_log_type_t v61 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v7, &v62, &v61)) {
      goto LABEL_60;
    }
    if (LOBYTE(v62.receiver) == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      int v54 = (id)gLogObj;
      os_log_type_t v55 = (os_log_type_t)v62.receiver;
      if (os_log_type_enabled(v54, (os_log_type_t)v62.receiver))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s NWOSHostEndpoint alloc/init failed", (uint8_t *)type, 0xCu);
      }
LABEL_128:

      goto LABEL_60;
    }
    if (v61 == OS_LOG_TYPE_DEFAULT)
    {
      int v54 = __nwlog_obj();
      os_log_type_t v58 = (os_log_type_t)v62.receiver;
      if (os_log_type_enabled(v54, (os_log_type_t)v62.receiver))
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_1830D4000, v54, v58, "%{public}s NWOSHostEndpoint alloc/init failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
      }
      goto LABEL_128;
    }
    uint64_t v16 = (char *)__nw_create_backtrace_string();
    int v54 = __nwlog_obj();
    os_log_type_t v56 = (os_log_type_t)v62.receiver;
    BOOL v57 = os_log_type_enabled(v54, (os_log_type_t)v62.receiver);
    if (!v16)
    {
      if (v57)
      {
        *(_DWORD *)os_log_type_t type = 136446210;
        os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
        _os_log_impl(&dword_1830D4000, v54, v56, "%{public}s NWOSHostEndpoint alloc/init failed, no backtrace", (uint8_t *)type, 0xCu);
      }
      goto LABEL_128;
    }
    if (v57)
    {
      *(_DWORD *)os_log_type_t type = 136446466;
      os_log_type_t v64 = "nw_endpoint_create_host_with_numeric_port";
      __int16 v65 = 2082;
      os_log_type_t v66 = v16;
      _os_log_impl(&dword_1830D4000, v54, v56, "%{public}s NWOSHostEndpoint alloc/init failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
    }

LABEL_26:
    free(v16);
    if (!v7) {
      return 0;
    }
    goto LABEL_61;
  }
  v62.os_log_type_t receiver = v10;
  v62.super_class = (Class)NWConcrete_nw_host_endpoint;
  nw_endpoint_t address = objc_msgSendSuper2(&v62, sel_init);
  if (!address)
  {
    long long v42 = __nwlog_obj();
    *(_DWORD *)os_log_type_t type = 136446210;
    os_log_type_t v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
    uint64_t v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v61 = OS_LOG_TYPE_ERROR;
    char v60 = 0;
    if (__nwlog_fault(v43, &v61, &v60))
    {
      if (v61 == OS_LOG_TYPE_FAULT)
      {
        unsigned __int8 v44 = __nwlog_obj();
        os_log_type_t v45 = v61;
        if (os_log_type_enabled(v44, v61))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
          _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s [super init] failed", (uint8_t *)type, 0xCu);
        }
      }
      else if (v60)
      {
        uint64_t v49 = (char *)__nw_create_backtrace_string();
        unsigned __int8 v44 = __nwlog_obj();
        os_log_type_t v50 = v61;
        BOOL v51 = os_log_type_enabled(v44, v61);
        if (v49)
        {
          if (v51)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            os_log_type_t v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
            __int16 v65 = 2082;
            os_log_type_t v66 = v49;
            _os_log_impl(&dword_1830D4000, v44, v50, "%{public}s [super init] failed, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }

          free(v49);
          goto LABEL_111;
        }
        if (v51)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
          _os_log_impl(&dword_1830D4000, v44, v50, "%{public}s [super init] failed, no backtrace", (uint8_t *)type, 0xCu);
        }
      }
      else
      {
        unsigned __int8 v44 = __nwlog_obj();
        os_log_type_t v52 = v61;
        if (os_log_type_enabled(v44, v61))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          os_log_type_t v64 = "-[NWConcrete_nw_host_endpoint initWithHostname:port:]";
          _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s [super init] failed, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
      }
    }
LABEL_111:
    if (v43) {
      free(v43);
    }
    goto LABEL_113;
  }
  nw_txt_record_t v12 = strdup(a1);
  if (v12)
  {
LABEL_16:
    *((void *)address + 29) = v12;
    *((_WORD *)address + 120) = __rev16(a2);
    char v13 = (const char *)*((void *)address + 29);
    size_t v14 = strlen(v13);
    if (v14 >= 7)
    {
      unint64_t v15 = v14;
      if (!strcmp(&v13[v14 - 6], ".local") || v15 >= 8 && !strcmp(&v13[v15 - 7], ".local.")) {
        *((unsigned char *)address + 231) |= 1u;
      }
    }
    return (BOOL)address;
  }
  __int16 v46 = __nwlog_obj();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *(_DWORD *)os_log_type_t type = 136446210;
  os_log_type_t v64 = "strict_strdup";
  uint64_t v47 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v47);
  if (!result)
  {
    free(v47);
    goto LABEL_16;
  }
  __break(1u);
  return result;
}

void sub_18315C19C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18315C304(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18315CA9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_copy_interface(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  nw_connection_t v2 = v1;
  if (v1)
  {
    id v3 = v1[2];
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  uint64_t v16 = "nw_endpoint_copy_interface";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_copy_interface";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          uint64_t v16 = "nw_endpoint_copy_interface";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_copy_interface";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_copy_interface";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

uint16_t nw_endpoint_get_port(nw_endpoint_t endpoint)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = endpoint;
  nw_connection_t v2 = v1;
  if (v1)
  {
    uint16_t v3 = __rev16([v1 port]);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  uint64_t v16 = "nw_endpoint_get_port";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_get_port";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          uint64_t v16 = "nw_endpoint_get_port";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_get_port";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_get_port";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint16_t v3 = 0;
LABEL_3:

  return v3;
}

void sub_18315D100(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_alternate_port(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  nw_connection_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[114];
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  uint64_t v16 = "nw_endpoint_get_alternate_port";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_get_alternate_port";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          uint64_t v16 = "nw_endpoint_get_alternate_port";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_get_alternate_port";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "nw_endpoint_get_alternate_port";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

const char *__nwlog_salted_hostname_hash(const char *a1, char *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    size_t v4 = strlen(a1);
    uint64_t v5 = v4;
    if (v4 >= 2 && a1[v4 - 1] == 46) {
      uint64_t v5 = v4 - 1;
    }
    __nwlog_salted_hash(a1, v5, a2);
    return a2;
  }
  __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  uint64_t v16 = "__nwlog_salted_hostname_hash";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v7, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "__nwlog_salted_hostname_hash";
        os_log_type_t v10 = "%{public}s called with null hostname";
LABEL_20:
        _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          uint64_t v16 = "__nwlog_salted_hostname_hash";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hostname, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "__nwlog_salted_hostname_hash";
        os_log_type_t v10 = "%{public}s called with null hostname, no backtrace";
        goto LABEL_20;
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v16 = "__nwlog_salted_hostname_hash";
        os_log_type_t v10 = "%{public}s called with null hostname, backtrace limit exceeded";
        goto LABEL_20;
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
  return "???";
}

BOOL __nwlog_salted_hash(const void *a1, uint64_t a2, char *a3)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    CC_LONG v4 = a2;
    if (a2)
    {
      if (__nwlog_salted_hash::onceToken != -1) {
        dispatch_once(&__nwlog_salted_hash::onceToken, &__block_literal_global_84);
      }
      memset(&c, 0, sizeof(c));
      CC_SHA256_Init(&c);
      CC_SHA256_Update(&c, &__nwlog_salted_hash::salt, 0x40u);
      CC_SHA256_Update(&c, a1, v4);
      CC_SHA256_Final(&md, &c);
      unsigned __int8 v6 = md;
      int v7 = md >> 4;
      char v8 = v7 + 87;
      char v9 = v7 | 0x30;
      if (md > 0x9Fu) {
        char v9 = v8;
      }
      *a3 = v9;
      if ((v6 & 0xFu) <= 9) {
        char v10 = v6 & 0xF | 0x30;
      }
      else {
        char v10 = (v6 & 0xF) + 87;
      }
      a3[1] = v10;
      unsigned __int8 v11 = v30;
      int v12 = v30 >> 4;
      char v13 = v12 + 87;
      char v14 = v12 | 0x30;
      if (v30 > 0x9Fu) {
        char v14 = v13;
      }
      a3[2] = v14;
      if ((v11 & 0xFu) <= 9) {
        char v15 = v11 & 0xF | 0x30;
      }
      else {
        char v15 = (v11 & 0xF) + 87;
      }
      a3[3] = v15;
      unsigned __int8 v16 = v31;
      int v17 = v31 >> 4;
      char v18 = v17 + 87;
      char v19 = v17 | 0x30;
      if (v31 > 0x9Fu) {
        char v19 = v18;
      }
      a3[4] = v19;
      if ((v16 & 0xFu) <= 9) {
        char v20 = v16 & 0xF | 0x30;
      }
      else {
        char v20 = (v16 & 0xF) + 87;
      }
      a3[5] = v20;
      unsigned __int8 v21 = v32;
      int v22 = v32 >> 4;
      char v23 = v22 + 87;
      char v24 = v22 | 0x30;
      if (v32 > 0x9Fu) {
        char v24 = v23;
      }
      a3[6] = v24;
      if ((v21 & 0xFu) <= 9) {
        char v25 = v21 & 0xF | 0x30;
      }
      else {
        char v25 = (v21 & 0xF) + 87;
      }
      a3[7] = v25;
      a3[8] = 0;
      return (BOOL)a3;
    }
  }
  if (a3)
  {
LABEL_27:
    strcpy(a3, "<null>");
    return (BOOL)a3;
  }
  uint64_t v27 = __nwlog_obj();
  os_log_type_enabled(v27, OS_LOG_TYPE_ERROR);
  c.count[0] = 136446210;
  *(void *)&c.count[1] = "_strict_strlcpy";
  uint64_t v28 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v28);
  if (!result)
  {
    free(v28);
    goto LABEL_27;
  }
  __break(1u);
  return result;
}

void nw_endpoint_set_priority(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  CC_LONG v4 = v3;
  if (v3)
  {
    [v3 setPriority:a2];
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  unsigned __int8 v16 = "nw_endpoint_set_priority";
  unsigned __int8 v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        unsigned __int8 v16 = "nw_endpoint_set_priority";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          unsigned __int8 v16 = "nw_endpoint_set_priority";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        unsigned __int8 v16 = "nw_endpoint_set_priority";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        unsigned __int8 v16 = "nw_endpoint_set_priority";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18315DB28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_set_parent_endpoint(void *a1, void *a2, int a3)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  unsigned __int8 v6 = a2;
  int v7 = v6;
  if (v5)
  {
    if (v6 != v5)
    {
      objc_storeStrong(v5 + 14, a2);
      if (a3) {
        char v8 = 2;
      }
      else {
        char v8 = 0;
      }
      char v9 = *((unsigned char *)v5 + 231) & 0xFD | v8;
      *((unsigned char *)v5 + 231) = v9;
      if (v7)
      {
        *((unsigned char *)v5 + 231) = *((unsigned char *)v7 + 231) & 0x20 | v9 & 0xDF;
        *((_WORD *)v5 + 114) = *((_WORD *)v7 + 114);
      }
    }
    goto LABEL_8;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  unsigned __int8 v21 = "nw_endpoint_set_parent_endpoint";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        unsigned __int8 v21 = "nw_endpoint_set_parent_endpoint";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          unsigned __int8 v21 = "nw_endpoint_set_parent_endpoint";
          __int16 v22 = 2082;
          char v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v16)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        unsigned __int8 v21 = "nw_endpoint_set_parent_endpoint";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        unsigned __int8 v21 = "nw_endpoint_set_parent_endpoint";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v11) {
    free(v11);
  }
LABEL_8:
}

void *nw_context_copy_tracker_lookup_callback(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  nw_connection_t v2 = v1;
  if (!v1)
  {
    int v7 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    char v18 = "nw_context_copy_tracker_lookup_callback";
    char v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v8, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          char v18 = "nw_context_copy_tracker_lookup_callback";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            char v18 = "nw_context_copy_tracker_lookup_callback";
            __int16 v19 = 2082;
            char v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (v13)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          char v18 = "nw_context_copy_tracker_lookup_callback";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          char v18 = "nw_context_copy_tracker_lookup_callback";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_23:
    if (v8) {
      free(v8);
    }
    goto LABEL_25;
  }
  id v3 = (const void *)v1[16];
  if (!v3)
  {
    uint64_t v4 = v2[5];
    if (v4)
    {
      id v3 = *(const void **)(v4 + 128);
      goto LABEL_5;
    }
LABEL_25:
    uint64_t v5 = 0;
    goto LABEL_6;
  }
LABEL_5:
  uint64_t v5 = _Block_copy(v3);
LABEL_6:

  return v5;
}

BOOL nw_resolver_insert_endpoint_locked(void *a1, void *a2, void *a3)
{
  uint64_t v5 = a1;
  id v6 = a2;
  id v7 = a3;
  uint64_t v28 = 0;
  os_log_type_t v29 = &v28;
  uint64_t v30 = 0x2020000000;
  char v31 = 1;
  uint64_t v24 = 0;
  char v25 = &v24;
  uint64_t v26 = 0x2020000000;
  char v27 = 0;
  BOOL v8 = nw_array_create();
  char v9 = v5 + 18;
  os_log_type_t v10 = (atomic_uchar *)v5[18];
  v17[0] = MEMORY[0x1E4F143A8];
  v17[1] = 3221225472;
  v17[2] = ___ZL34nw_resolver_insert_endpoint_lockedP22NWConcrete_nw_resolverPU25objcproto14OS_nw_endpoint8NSObjectU13block_pointerFbS3_S3_E_block_invoke;
  v17[3] = &unk_1E523B268;
  id v11 = v7;
  id v21 = v11;
  id v12 = v6;
  id v18 = v12;
  __int16 v22 = &v24;
  char v23 = &v28;
  BOOL v13 = v5;
  __int16 v19 = v13;
  id v14 = (id)v8;
  id v20 = v14;
  nw_array_apply(v10, (uint64_t)v17);
  int v15 = *((unsigned __int8 *)v29 + 24);
  if (*((unsigned char *)v29 + 24))
  {
    if (!*((unsigned char *)v25 + 24)) {
      nw_array_append((uint64_t)v14, v12);
    }
    objc_storeStrong(v9, (id)v8);
  }

  _Block_object_dispose(&v24, 8);
  _Block_object_dispose(&v28, 8);

  return v15 != 0;
}

uint64_t sub_18315E28C(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = type metadata accessor for NWEndpoint();
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v4 - 8) + 32))(a2, a1, v4);
  return a2;
}

uint64_t type metadata accessor for NWConnection(uint64_t a1)
{
  return sub_18315A7F8(a1, (uint64_t *)&unk_1E8F61EC0);
}

uint64_t sub_18315E310(uint64_t a1, uint64_t a2, uint64_t a3)
{
  __swift_instantiateConcreteTypeFromMangledName((uint64_t *)&unk_1E8F61E68);
  uint64_t v7 = swift_allocObject();
  *(_DWORD *)(v7 + 96) = 0;
  *(_OWORD *)(v7 + 16) = 0u;
  *(_OWORD *)(v7 + 32) = 0u;
  *(_OWORD *)(v7 + 48) = 0u;
  *(_OWORD *)(v7 + 64) = 0u;
  *(void *)(v7 + 80) = 0;
  *(_DWORD *)(v7 + 88) = 0;
  *(_WORD *)(v7 + 92) = 128;
  *(void *)(v3 + 24) = v7;
  sub_18315E728(a1, v3 + OBJC_IVAR____TtC7Network13_NWConnection_endpoint, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
  *(void *)(v3 + OBJC_IVAR____TtC7Network13_NWConnection_parameters) = a2;
  *(void *)(v3 + 16) = a3;
  swift_retain();
  swift_unknownObjectRetain();
  sub_18315ED5C(0);
  NWConnection.stateUpdateHandler.setter(0, 0);
  sub_18315E45C(a1, (uint64_t (*)(void))type metadata accessor for NWEndpoint);
  return v3;
}

uint64_t sub_18315E3FC(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_18315E45C(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_18315E4BC(uint64_t a1, uint64_t (*a2)(void))
{
  uint64_t v3 = a2(0);
  (*(void (**)(uint64_t, uint64_t))(*(void *)(v3 - 8) + 8))(a1, v3);
  return a1;
}

uint64_t sub_18315E51C(uint64_t result)
{
  if (result != 1) {
    return swift_unknownObjectRelease();
  }
  return result;
}

void destroy for NWEndpoint(uint64_t a1)
{
  switch(swift_getEnumCaseMultiPayload())
  {
    case 0u:
      uint64_t v2 = *(void *)a1;
      uint64_t v3 = *(void *)(a1 + 8);
      uint64_t v4 = *(void *)(a1 + 16);
      char v5 = *(unsigned char *)(a1 + 24);
      sub_18315E658(v2, v3, v4, v5);
      break;
    case 1u:
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      swift_bridgeObjectRelease();
      if (*(void *)(a1 + 48) != 1) {
        goto LABEL_13;
      }
      break;
    case 2u:
      swift_bridgeObjectRelease();
      break;
    case 3u:
      uint64_t v6 = sub_183D4447C();
      uint64_t v7 = *(void (**)(uint64_t, uint64_t))(*(void *)(v6 - 8) + 8);
      v7(a1, v6);
      break;
    case 4u:
LABEL_13:
      swift_unknownObjectRelease();
      break;
    default:
      return;
  }
}

void sub_18315E658(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (a4 != 2)
  {
    if (a4 == 1)
    {
      a3 = a2;
    }
    else
    {
      if (a4) {
        return;
      }
      swift_bridgeObjectRelease();
    }
  }

  sub_18315E51C(a3);
}

uint64_t sub_18315E6C0(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_18315E728(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t sub_18315E790(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 16))(a2, a1, v5);
  return a2;
}

uint64_t type metadata accessor for NWEndpoint()
{
  uint64_t result = qword_1EB266B78;
  if (!qword_1EB266B78) {
    return swift_getSingletonMetadata();
  }
  return result;
}

uint64_t initializeWithCopy for NWEndpoint(uint64_t a1, uint64_t *a2)
{
  switch(swift_getEnumCaseMultiPayload())
  {
    case 1u:
      uint64_t v8 = a2[1];
      *(void *)a1 = *a2;
      *(void *)(a1 + 8) = v8;
      uint64_t v9 = a2[3];
      *(void *)(a1 + 16) = a2[2];
      *(void *)(a1 + 24) = v9;
      uint64_t v10 = a2[5];
      *(void *)(a1 + 32) = a2[4];
      *(void *)(a1 + 40) = v10;
      uint64_t v11 = a2[6];
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      swift_bridgeObjectRetain();
      if (v11 != 1) {
        swift_unknownObjectRetain();
      }
      *(void *)(a1 + 48) = v11;
      break;
    case 2u:
      uint64_t v12 = a2[1];
      *(void *)a1 = *a2;
      *(void *)(a1 + 8) = v12;
      swift_bridgeObjectRetain();
      break;
    case 3u:
      uint64_t v13 = sub_183D4447C();
      (*(void (**)(uint64_t, uint64_t *, uint64_t))(*(void *)(v13 - 8) + 16))(a1, a2, v13);
      break;
    case 4u:
      *(void *)a1 = *a2;
      swift_unknownObjectRetain();
      break;
    default:
      uint64_t v4 = *a2;
      uint64_t v5 = a2[1];
      uint64_t v6 = a2[2];
      char v7 = *((unsigned char *)a2 + 24);
      sub_18315E9E4(*a2, v5, v6, v7);
      *(void *)a1 = v4;
      *(void *)(a1 + 8) = v5;
      *(void *)(a1 + 16) = v6;
      *(unsigned char *)(a1 + 24) = v7;
      *(_WORD *)(a1 + 26) = *((_WORD *)a2 + 13);
      break;
  }
  swift_storeEnumTagMultiPayload();
  return a1;
}

uint64_t sub_18315E9D4(uint64_t result)
{
  if (result != 1) {
    return swift_unknownObjectRetain();
  }
  return result;
}

void sub_18315E9E4(uint64_t a1, uint64_t a2, uint64_t a3, char a4)
{
  if (a4 != 2)
  {
    if (a4 == 1)
    {
      a3 = a2;
    }
    else
    {
      if (a4) {
        return;
      }
      swift_bridgeObjectRetain();
    }
  }

  sub_18315E9D4(a3);
}

void NWConnection.start(queue:)(NSObject *a1)
{
  uint64_t v2 = v1;
  uint64_t v4 = *(os_unfair_lock_s **)(v1 + 24);
  uint64_t v5 = (uint64_t *)&v4[4];
  uint64_t v6 = v4 + 24;
  os_unfair_lock_lock(v4 + 24);
  sub_18315ED6C((uint64_t)v5);
  os_unfair_lock_unlock(v6);
  os_unfair_lock_lock(v6);
  sub_18315EDB8(v5, v11);
  os_unfair_lock_unlock(v6);
  if (v11[0])
  {
    long long v10 = *(_OWORD *)v11;
    uint64_t v7 = swift_allocObject();
    *(_OWORD *)(v7 + 16) = v10;
    uint64_t v8 = sub_18313D738;
  }
  else
  {
    uint64_t v8 = 0;
    uint64_t v7 = 0;
  }
  sub_18315ED5C((uint64_t)v8);
  sub_18315ED5C((uint64_t)v8);
  NWConnection.stateUpdateHandler.setter((uint64_t)v8, v7);
  sub_18313D870((uint64_t)v8);
  sub_18313D870((uint64_t)v8);
  uint64_t v9 = *(NSObject **)(v1 + 16);
  nw_connection_set_queue(*(nw_connection_t *)(v2 + 16), a1);
  nw_connection_start(v9);
}

uint64_t NWConnection.stateUpdateHandler.setter(uint64_t a1, uint64_t a2)
{
  uint64_t v3 = v2;
  uint64_t v6 = *(os_unfair_lock_s **)(v2 + 24);
  uint64_t v7 = (uint64_t)&v6[4];
  uint64_t v8 = v6 + 24;
  os_unfair_lock_lock(v6 + 24);
  sub_18315ECEC(v7, aBlock);
  os_unfair_lock_unlock(v8);
  if (LOBYTE(aBlock[0]) != 1) {
    return sub_18313D870(a1);
  }
  uint64_t v9 = *(NSObject **)(v2 + 16);
  long long v10 = (void *)swift_allocObject();
  v10[2] = v3;
  v10[3] = a1;
  v10[4] = a2;
  void aBlock[4] = sub_18313D68C;
  aBlock[5] = v10;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 1107296256;
  aBlock[2] = sub_18313D61C;
  aBlock[3] = &block_descriptor_15;
  uint64_t v11 = _Block_copy(aBlock);
  swift_unknownObjectRetain();
  swift_retain();
  sub_18315ED5C(a1);
  swift_release();
  nw_connection_set_state_changed_handler(v9, v11);
  sub_18313D870(a1);
  _Block_release(v11);
  return swift_unknownObjectRelease();
}

uint64_t sub_18315ECEC@<X0>(uint64_t a1@<X0>, unsigned char *a2@<X8>)
{
  uint64_t v6 = *(void *)(v2 + 16);
  uint64_t v5 = *(void *)(v2 + 24);
  uint64_t v7 = *(void *)a1;
  sub_18315ED5C(v6);
  uint64_t result = sub_18313D870(v7);
  *(void *)a1 = v6;
  *(void *)(a1 + 8) = v5;
  *a2 = *(unsigned char *)(a1 + 77);
  return result;
}

uint64_t sub_18315ED5C(uint64_t result)
{
  if (result) {
    return swift_retain();
  }
  return result;
}

void sub_18315ED6C(uint64_t a1)
{
  uint64_t v3 = *(void **)(v1 + 16);
  *(unsigned char *)(a1 + 77) = 1;
  uint64_t v4 = *(void **)(a1 + 64);
  id v5 = v3;

  *(void *)(a1 + 64) = v3;
}

uint64_t sub_18315EDB8@<X0>(uint64_t *a1@<X0>, uint64_t (**a2)()@<X8>)
{
  uint64_t v3 = *a1;
  uint64_t v4 = a1[1];
  if (*a1)
  {
    uint64_t v5 = swift_allocObject();
    *(void *)(v5 + 16) = v3;
    *(void *)(v5 + 24) = v4;
    uint64_t v6 = sub_18313D760;
  }
  else
  {
    uint64_t v6 = 0;
    uint64_t v5 = 0;
  }
  *a2 = v6;
  a2[1] = (uint64_t (*)())v5;
  return sub_18315ED5C(v3);
}

uint64_t sub_18315EE34(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

uint64_t sub_18315EE9C(uint64_t a1, uint64_t a2, uint64_t (*a3)(void))
{
  uint64_t v5 = a3(0);
  (*(void (**)(uint64_t, uint64_t, uint64_t))(*(void *)(v5 - 8) + 32))(a2, a1, v5);
  return a2;
}

BOOL nw_resolver_set_interface_on_endpoint(void *a1, unsigned int a2, void *a3)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = a1;
  id v6 = a3;
  if (a2 - 1 <= 0xFFFFFFFD)
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    id v7 = (id)nw_context_copy_implicit_context::implicit_context;
    uint64_t v8 = nw_path_copy_interface_with_generation(v7, a2, 0);

    BOOL v9 = v8 != 0;
    if (v8)
    {
      nw_endpoint_set_interface(v6, v8);
LABEL_20:

      goto LABEL_21;
    }
    if (v5)
    {
      if ((v5[346] & 0x20) != 0) {
        goto LABEL_20;
      }
      if (v5[256])
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        long long v10 = (id)gconnectionLogObj;
        if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
          goto LABEL_19;
        }
        int v16 = 136446978;
        os_log_type_t v17 = "nw_resolver_set_interface_on_endpoint";
        __int16 v18 = 2082;
        *(void *)__int16 v19 = v5 + 256;
        *(_WORD *)&v19[8] = 2082;
        *(void *)&v19[10] = nw_endpoint_get_logging_description(v6);
        *(_WORD *)&v19[18] = 1024;
        unsigned int v20 = a2;
        uint64_t v11 = "%{public}s [C%{public}s] Not adding the endpoint %{public}s on interface %u to array due to invalid interface";
        uint64_t v12 = v10;
        uint32_t v13 = 38;
        goto LABEL_18;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v14 = *((_DWORD *)v5 + 85);
        int v16 = 136446978;
        os_log_type_t v17 = "nw_resolver_set_interface_on_endpoint";
        __int16 v18 = 1024;
        *(_DWORD *)__int16 v19 = v14;
        *(_WORD *)&v19[4] = 2082;
        *(void *)&v19[6] = nw_endpoint_get_logging_description(v6);
        *(_WORD *)&v19[14] = 1024;
        *(_DWORD *)&v19[16] = a2;
        uint64_t v11 = "%{public}s [R%u] Not adding the endpoint %{public}s on interface %u to array due to invalid interface";
        uint64_t v12 = v10;
        uint32_t v13 = 34;
        goto LABEL_18;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      long long v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
      {
        int v16 = 136446722;
        os_log_type_t v17 = "nw_resolver_set_interface_on_endpoint";
        __int16 v18 = 2082;
        *(void *)__int16 v19 = nw_endpoint_get_logging_description(v6);
        *(_WORD *)&v19[8] = 1024;
        *(_DWORD *)&v19[10] = a2;
        uint64_t v11 = "%{public}s Not adding the endpoint %{public}s on interface %u to array due to invalid interface";
        uint64_t v12 = v10;
        uint32_t v13 = 28;
LABEL_18:
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_ERROR, v11, (uint8_t *)&v16, v13);
      }
    }
LABEL_19:

    goto LABEL_20;
  }
  BOOL v9 = 1;
LABEL_21:

  return v9;
}

void sub_18315F210(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_resolver_should_scope_address(const sockaddr *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v2 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    uint64_t v12 = "nw_resolver_should_scope_address";
    uint64_t v3 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v3, &type, &v9)) {
      goto LABEL_23;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v12 = "nw_resolver_should_scope_address";
        id v6 = "%{public}s called with null addr";
LABEL_21:
        _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
      }
    }
    else
    {
      if (v9)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v4 = __nwlog_obj();
        os_log_type_t v5 = type;
        BOOL v8 = os_log_type_enabled(v4, type);
        if (backtrace_string)
        {
          if (v8)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            uint64_t v12 = "nw_resolver_should_scope_address";
            __int16 v13 = 2082;
            int v14 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null addr, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (!v8) {
          goto LABEL_22;
        }
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v12 = "nw_resolver_should_scope_address";
        id v6 = "%{public}s called with null addr, no backtrace";
        goto LABEL_21;
      }
      uint64_t v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        uint64_t v12 = "nw_resolver_should_scope_address";
        id v6 = "%{public}s called with null addr, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_22:

LABEL_23:
    if (v3) {
      free(v3);
    }
    return 0;
  }
  return a1->sa_family != 30 || a1->sa_len < 0x18u || (a1->sa_data[6] & 0xFE) != 0xFC;
}

uint64_t nw_connection_get_privacy_stance(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)addrinfo buf = 0;
    *(void *)&buf[8] = buf;
    int v19 = 0;
    *(void *)&buf[16] = 0x2020000000;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_get_privacy_stance_block_invoke;
    v13[3] = &unk_1E524B978;
    uint64_t v15 = buf;
    int v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_get_privacy_stance_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    uint64_t v3 = *(unsigned int *)(*(void *)&buf[8] + 24);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  os_log_type_t v5 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_get_privacy_stance";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_connection_get_privacy_stance_block_invoke(uint64_t result)
{
  *(_DWORD *)(*(void *)(*(void *)(result + 40) + 8) + 24) = *(_DWORD *)(*(void *)(result + 32) + 504);
  return result;
}

uint64_t nw_activity_duration_exceeds_threshold(void *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = (int *)v1;
  if (!v1)
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    char v31 = "nw_activity_duration_exceeds_threshold";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v11, &type, &v28)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null activity", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v28)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v25, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v19 = type;
    BOOL v20 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v20)
    {
      *(_DWORD *)addrinfo buf = 136446466;
      char v31 = "nw_activity_duration_exceeds_threshold";
      __int16 v32 = 2082;
      unint64_t v33 = (unint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_53;
  }
  if ((v1[140] & 4) == 0)
  {
    int v14 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    char v31 = "nw_activity_duration_exceeds_threshold";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v11, &type, &v28)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s Activity not activated, cannot check duration threshold", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (!v28)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v26, "%{public}s Activity not activated, cannot check duration threshold, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s Activity not activated, cannot check duration threshold, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v22)
    {
      *(_DWORD *)addrinfo buf = 136446466;
      char v31 = "nw_activity_duration_exceeds_threshold";
      __int16 v32 = 2082;
      unint64_t v33 = (unint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s Activity not activated, cannot check duration threshold, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_53;
  }
  if ((v1[140] & 8) == 0)
  {
    char v16 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    char v31 = "nw_activity_duration_exceeds_threshold";
    BOOL v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v11, &type, &v28)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s Activity not completed, cannot check duration threshold", buf, 0xCu);
      }
LABEL_71:

LABEL_72:
      if (v11) {
        free(v11);
      }
      goto LABEL_17;
    }
    if (!v28)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s Activity not completed, cannot check duration threshold, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_71;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v12 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v12, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v31 = "nw_activity_duration_exceeds_threshold";
        _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s Activity not completed, cannot check duration threshold, no backtrace", buf, 0xCu);
      }
      goto LABEL_71;
    }
    if (v24)
    {
      *(_DWORD *)addrinfo buf = 136446466;
      char v31 = "nw_activity_duration_exceeds_threshold";
      __int16 v32 = 2082;
      unint64_t v33 = (unint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s Activity not completed, cannot check duration threshold, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_53:

    free(backtrace_string);
    goto LABEL_72;
  }
  if ((v1[140] & 2) != 0)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    os_log_type_t v8 = (id)gactivityLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)addrinfo buf = 138543362;
      char v31 = (const char *)v2;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "Not checking duration threshold for lightweight activity %{public}@", buf, 0xCu);
    }
    goto LABEL_16;
  }
  unint64_t duration = nw_activity_get_duration(v1);
  unint64_t v4 = nw_activity_duration_threshold_for_label(v2[29], v2[28]);
  if (v4 == -1)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    os_log_type_t v8 = (id)gactivityLogObj;
    if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)addrinfo buf = 138543362;
      char v31 = (const char *)v2;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "No threshold for activity %{public}@", buf, 0xCu);
    }
LABEL_16:

    goto LABEL_17;
  }
  unint64_t v5 = v4;
  if (duration <= v4)
  {
LABEL_17:
    uint64_t v7 = 0;
    goto LABEL_18;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  id v6 = (id)gactivityLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
  {
    *(_DWORD *)addrinfo buf = 138543874;
    char v31 = (const char *)v2;
    __int16 v32 = 2048;
    unint64_t v33 = duration;
    __int16 v34 = 2048;
    unint64_t v35 = v5;
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_INFO, "%{public}@ over threshold (duration %llums exceeds threshold %llums)", buf, 0x20u);
  }

  uint64_t v7 = 1;
LABEL_18:

  return v7;
}

void sub_183160088(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_activity_get_duration(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    __int16 v18 = "nw_activity_get_duration";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          __int16 v18 = "nw_activity_get_duration";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            __int16 v18 = "nw_activity_get_duration";
            __int16 v19 = 2082;
            BOOL v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_34;
        }
        if (v13)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          __int16 v18 = "nw_activity_get_duration";
          _os_log_impl(&dword_1830D4000, v8, v12, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          __int16 v18 = "nw_activity_get_duration";
          _os_log_impl(&dword_1830D4000, v8, v14, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_34:
    if (v7) {
      free(v7);
    }
    goto LABEL_36;
  }
  if ((*((unsigned char *)v1 + 140) & 8) == 0)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    os_log_type_t v10 = (id)gactivityLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)addrinfo buf = 0;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "Activity not yet complete, returning duration 0", buf, 2u);
    }
    goto LABEL_17;
  }
  if ((*((unsigned char *)v1 + 140) & 2) != 0)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    os_log_type_t v10 = (id)gactivityLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)addrinfo buf = 0;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "Activity is lightweight, returning duration 0", buf, 2u);
    }
LABEL_17:

LABEL_36:
    uint64_t v4 = 0;
    goto LABEL_7;
  }
  unint64_t v3 = nw_delta_nanos(v1[4], v1[5]);
  if (v3 <= 0xF423FFFFFFFFFLL) {
    uint64_t v4 = (v3 / 0xF4240);
  }
  else {
    uint64_t v4 = 0xFFFFFFFFLL;
  }
LABEL_7:

  return v4;
}

uint64_t nw_activity_duration_threshold_for_label(int a1, int a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!nw_activity_label_is_valid(a1, a2))
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    uint64_t v4 = (id)gactivityLogObj;
    if (!os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG)) {
      goto LABEL_27;
    }
    LOWORD(v13) = 0;
    id v6 = "Returning NW_ACTIVITY_DURATION_INVALID for invalid label";
    uint64_t v7 = v4;
    uint32_t v8 = 2;
    goto LABEL_26;
  }
  if (a1 == 11 && a2 == 5)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    uint64_t v4 = (id)gactivityLogObj;
    uint64_t v5 = 2;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
    {
      int v13 = 134218242;
      uint64_t v5 = 2;
      uint64_t v14 = 2;
      __int16 v15 = 2082;
      char v16 = "libnetcore:test_activity_five";
LABEL_23:
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "Returning threshold %llu for activity %{public}s", (uint8_t *)&v13, 0x16u);
      goto LABEL_28;
    }
    goto LABEL_28;
  }
  BOOL v10 = a1 == 11 && a2 == 6;
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  uint64_t v4 = (id)gactivityLogObj;
  BOOL v11 = os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG);
  if (!v10)
  {
    if (!v11)
    {
LABEL_27:
      uint64_t v5 = -1;
      goto LABEL_28;
    }
    int v13 = 136446210;
    uint64_t v14 = (uint64_t)nw_activity_domain_and_label_to_string(a1, a2);
    id v6 = "No threshold for %{public}s, returning NW_ACTIVITY_DURATION_INVALID";
    uint64_t v7 = v4;
    uint32_t v8 = 12;
LABEL_26:
    _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, v6, (uint8_t *)&v13, v8);
    goto LABEL_27;
  }
  uint64_t v5 = 200000;
  if (v11)
  {
    int v13 = 134218242;
    uint64_t v14 = 200000;
    __int16 v15 = 2082;
    char v16 = "libnetcore:test_activity_six";
    goto LABEL_23;
  }
LABEL_28:

  return v5;
}

void nw_connection_fillout_establishment_report_on_nw_queue(void *a1, int a2)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  unint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    __int16 v73 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
    os_log_type_t v74 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v106) = 16;
    LOBYTE(v105) = 0;
    if (__nwlog_fault(v74, &v106, &v105))
    {
      if (v106 == 17)
      {
        __int16 v75 = __nwlog_obj();
        os_log_type_t v76 = v106;
        if (os_log_type_enabled(v75, (os_log_type_t)v106))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if ((_BYTE)v105)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v75 = __nwlog_obj();
        os_log_type_t v78 = v106;
        BOOL v79 = os_log_type_enabled(v75, (os_log_type_t)v106);
        if (backtrace_string)
        {
          if (v79)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
            __int16 v108 = 2082;
            BOOL v109 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v75, v78, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_116;
        }
        if (v79)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v75, v78, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v75 = __nwlog_obj();
        os_log_type_t v84 = v106;
        if (os_log_type_enabled(v75, (os_log_type_t)v106))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v75, v84, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_116:
    if (v74) {
      free(v74);
    }
    goto LABEL_89;
  }
  nw_context_assert_queue(v3[3]);
  if ((*((unsigned char *)v4 + 109) & 0x40) != 0)
  {
    uint64_t v5 = nw_endpoint_handler_copy_connected_flow_handler(v4[18]);
    id v6 = v5;
    if (!v5)
    {
LABEL_88:

      goto LABEL_89;
    }
    os_log_type_t v91 = v5;
    uint64_t v7 = objc_alloc_init(NWConcrete_nw_establishment_report);
    if (v7)
    {
      int v89 = a2;
      uint32_t v8 = v6;
      os_log_type_t v93 = v8->parameters;

      unint64_t v9 = v4[18];
      int v10 = (v9 >> 16) ^ HIDWORD(v9) ^ HIWORD(v9) ^ v9;
      id v90 = (id)v9;
      if (!v9) {
        LOWORD(v10) = 0;
      }
      __int16 v106 = v10;
      __int16 v105 = WORD2(v8) ^ WORD1(v8) ^ HIWORD(v8) ^ (unsigned __int16)v8;
      unsigned int event_milliseconds = nw_connection_get_event_milliseconds(v4, 1, 1, &v106, 0xFFFFFFFFLL);
      unsigned int v12 = nw_connection_get_event_milliseconds(v4, 3, 6, &v106, 0);
      unsigned int v13 = nw_connection_get_event_milliseconds(v4, 1, 3, &v106, 0xFFFFFFFFLL);
      if (v13 >= v12 || v13 == -1) {
        unint64_t v15 = event_milliseconds;
      }
      else {
        unint64_t v15 = v13;
      }
      v7->attempt_started_after_milliseconds = v15;
      v7->duration_milliseconds = v12 - v15;
      unsigned int v94 = v15;
      unsigned int v16 = nw_connection_get_event_milliseconds(v4, 3, 3, &v105, 0);
      if (v16 != -1 && v16 > v94) {
        v7->flow_started_after_milliseconds = v16 - v94;
      }
      uint64_t v17 = nw_endpoint_flow_copy_protocol_establishment_reports(v4[18]);
      protocol_reports = v7->protocol_reports;
      v7->protocol_reports = (OS_nw_array *)v17;

      __int16 v19 = v8;
      unsigned int v20 = 0;
      __int16 v92 = v19;
      do
      {
        uint64_t v21 = v19;
        int v22 = *((_DWORD *)v21 + 29);

        os_log_type_t v23 = v21;
        __int16 v19 = (id *)v23[9];

        if (v22 == 1) {
          ++v20;
        }
      }
      while (v19);
      if (v20)
      {
        BOOL v24 = nw_array_create();
        resolution_reports = v7->resolution_reports;
        v7->resolution_reports = (OS_nw_array *)v24;

        os_log_type_t v26 = v92;
        nw_endpoint_t v27 = nw_endpoint_handler_copy_endpoint(v26);
        unsigned int v28 = 0;
        while (1)
        {
          os_log_type_t v29 = v26;
          uint64_t v30 = v29;
          if (!v29) {
            break;
          }
          int v31 = *((_DWORD *)v29 + 29);

          if (v31 != 1) {
            goto LABEL_33;
          }
          __int16 v32 = objc_alloc_init(NWConcrete_nw_resolution_report);
          __int16 v104 = WORD2(v30) ^ WORD1(v30) ^ HIWORD(v30) ^ (unsigned __int16)v30;
          nw_endpoint_t v33 = nw_endpoint_handler_copy_endpoint(v30);
          nw_endpoint_t v34 = v33;
          if (v33 && (v35 = v33, int v36 = [v35 type], v35, v36 == 3))
          {
            int v37 = 4;
            int v38 = 3;
          }
          else
          {
            int v37 = 2;
            int v38 = 1;
          }
          unsigned int v39 = nw_connection_get_event_milliseconds(v4, 2, v38, &v104, 0);
          v32->milliseconds = nw_connection_get_event_milliseconds(v4, 2, v37, &v104, 0) - v39;
          if (!v28 && v39 > v94) {
            v7->resolution_started_after_milliseconds = v39 - v94;
          }
          objc_storeStrong((id *)&v32->successful_endpoint, v27);
          v32->endpoint_uint64_t count = nw_endpoint_handler_get_resolved_endpoint_count(v30);
          v32->uint64_t source = nw_endpoint_handler_get_resolution_source(v30);
          v32->uint64_t protocol = nw_endpoint_handler_get_resolution_protocol(v30);
          nw_endpoint_t v40 = nw_endpoint_handler_copy_preferred_resolved_endpoint(v30);
          preferred_endpoint = v32->preferred_endpoint;
          v32->preferred_endpoint = (OS_nw_endpoint *)v40;

          long long v42 = (OS_nw_array *)nw_endpoint_handler_copy_resolved_endpoints(v30);
          resolved_endpoints = v32->resolved_endpoints;
          v32->resolved_endpoints = v42;

          BOOL v103 = 0;
          nw_endpoint_handler_get_svcb_report(v30, 0, &v103, 0);
          *((unsigned char *)v32 + 70) = *((unsigned char *)v32 + 70) & 0xFE | v103;
          unsigned __int16 v102 = 0;
          *(void *)addrinfo buf = 0;
          nw_endpoint_handler_get_extended_dns_error(v30, &v102, (char **)buf);
          v32->extended_dns_unsigned int error_code = v102;
          v32->extended_dns_error_extra_text = *(char **)buf;
          nw_array_prepend((uint64_t)v7->resolution_reports, v32);

          ++v28;
LABEL_32:

LABEL_33:
          nw_endpoint_t v44 = nw_endpoint_handler_copy_endpoint(v30);

          os_log_type_t v45 = v30;
          __int16 v46 = v45;
          if (!v30)
          {
            BOOL v51 = __nwlog_obj();
            *(_DWORD *)addrinfo buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_parent";
            os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

            LOBYTE(v104) = 16;
            LOBYTE(v102) = 0;
            if (__nwlog_fault(v52, &v104, &v102))
            {
              if (v104 == 17)
              {
                id v53 = __nwlog_obj();
                os_log_type_t v54 = v104;
                if (os_log_type_enabled(v53, (os_log_type_t)v104))
                {
                  *(_DWORD *)addrinfo buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_parent";
                  _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null handler", buf, 0xCu);
                }
                goto LABEL_47;
              }
              if ((_BYTE)v102)
              {
                id v59 = (char *)__nw_create_backtrace_string();
                char v60 = __nwlog_obj();
                os_log_type_t v61 = v104;
                BOOL v62 = os_log_type_enabled(v60, (os_log_type_t)v104);
                if (v59)
                {
                  if (v62)
                  {
                    *(_DWORD *)addrinfo buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_parent";
                    __int16 v108 = 2082;
                    BOOL v109 = v59;
                    _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v59);
                }
                else
                {
                  if (v62)
                  {
                    *(_DWORD *)addrinfo buf = 136446210;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_parent";
                    _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null handler, no backtrace", buf, 0xCu);
                  }
                }
              }
              else
              {
                id v53 = __nwlog_obj();
                os_log_type_t v64 = v104;
                if (os_log_type_enabled(v53, (os_log_type_t)v104))
                {
                  *(_DWORD *)addrinfo buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_parent";
                  _os_log_impl(&dword_1830D4000, v53, v64, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
                }
LABEL_47:
              }
            }
            if (v52) {
              free(v52);
            }
            os_log_type_t v26 = 0;
            goto LABEL_35;
          }
          os_log_type_t v26 = (id *)v45[9];
LABEL_35:

          if (v26)
          {
            nw_endpoint_t v27 = v44;
            if (v28 < v20) {
              continue;
            }
          }

          goto LABEL_78;
        }
        uint64_t v47 = __nwlog_obj();
        *(_DWORD *)addrinfo buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
        os_log_type_t v48 = (char *)_os_log_send_and_compose_impl();

        LOBYTE(v104) = 16;
        LOBYTE(v102) = 0;
        if (__nwlog_fault(v48, &v104, &v102))
        {
          if (v104 == 17)
          {
            uint64_t v49 = __nwlog_obj();
            os_log_type_t v50 = v104;
            if (os_log_type_enabled(v49, (os_log_type_t)v104))
            {
              *(_DWORD *)addrinfo buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
              _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null handler", buf, 0xCu);
            }
          }
          else
          {
            if ((_BYTE)v102)
            {
              os_log_type_t v55 = (char *)__nw_create_backtrace_string();
              os_log_type_t v56 = __nwlog_obj();
              os_log_type_t v57 = v104;
              BOOL v58 = os_log_type_enabled(v56, (os_log_type_t)v104);
              if (v55)
              {
                if (v58)
                {
                  *(_DWORD *)addrinfo buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
                  __int16 v108 = 2082;
                  BOOL v109 = v55;
                  _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v55);
              }
              else
              {
                if (v58)
                {
                  *(_DWORD *)addrinfo buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
                  _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null handler, no backtrace", buf, 0xCu);
                }
              }
              goto LABEL_67;
            }
            uint64_t v49 = __nwlog_obj();
            os_log_type_t v63 = v104;
            if (os_log_type_enabled(v49, (os_log_type_t)v104))
            {
              *(_DWORD *)addrinfo buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
              _os_log_impl(&dword_1830D4000, v49, v63, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_67:
        if (v48) {
          free(v48);
        }
        __int16 v32 = 0;
        goto LABEL_32;
      }
      os_log_type_t v26 = 0;
LABEL_78:
      *(_WORD *)addrinfo buf = 0;
      if (nw_connection_get_event_milliseconds(v4, 4, 1, buf, 0) != -1)
      {
        *((unsigned char *)v7 + 84) |= 1u;
        id v65 = nw_parameters_copy_effective_proxy_config(v93);
        os_log_type_t v66 = v65;
        if (v65)
        {
          __int16 v67 = v65;
          int v68 = v67[38];

          if (v68 != 4)
          {
            *((unsigned char *)v7 + 84) |= 2u;
            BOOL v69 = nw_array_create();
            proxy_endpoints = v7->proxy_endpoints;
            v7->proxy_endpoints = (OS_nw_array *)v69;

            v100[0] = MEMORY[0x1E4F143A8];
            v100[1] = 3221225472;
            v100[2] = __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke;
            v100[3] = &unk_1E523B7E0;
            id v101 = v7;
            nw_proxy_config_enumerate_endpoints(v67, v100);
          }
        }
        v98[0] = MEMORY[0x1E4F143A8];
        v98[1] = 3221225472;
        v98[2] = __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke_2;
        v98[3] = &unk_1E523DD88;
        os_log_type_t v99 = v7;
        nw_endpoint_handler_access_proxy_handler(v92, v98);
      }
      if (v89)
      {
        v7->privacy_stance = *((_DWORD *)v4 + 126);
        __int16 v71 = v7;
        os_log_type_t v72 = (NWConcrete_nw_establishment_report *)v4[52];
        v4[52] = v71;
      }
      else
      {
        v95[0] = MEMORY[0x1E4F143A8];
        v95[1] = 3221225472;
        v95[2] = __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke_157;
        v95[3] = &unk_1E524B9A0;
        __int16 v96 = v7;
        id v97 = v4;
        os_unfair_lock_lock((os_unfair_lock_t)v4 + 34);
        __nw_connection_fillout_establishment_report_on_nw_queue_block_invoke_157((uint64_t)v95);
        os_unfair_lock_unlock((os_unfair_lock_t)v4 + 34);

        os_log_type_t v72 = v96;
      }

      goto LABEL_87;
    }
    os_log_type_t v80 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
    __int16 v81 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v106) = 16;
    LOBYTE(v105) = 0;
    if (__nwlog_fault(v81, &v106, &v105))
    {
      if (v106 == 17)
      {
        uint64_t v82 = __nwlog_obj();
        os_log_type_t v83 = v106;
        if (os_log_type_enabled(v82, (os_log_type_t)v106))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null report", buf, 0xCu);
        }
      }
      else if ((_BYTE)v105)
      {
        uint64_t v85 = (char *)__nw_create_backtrace_string();
        uint64_t v82 = __nwlog_obj();
        os_log_type_t v86 = v106;
        BOOL v87 = os_log_type_enabled(v82, (os_log_type_t)v106);
        if (v85)
        {
          if (v87)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
            __int16 v108 = 2082;
            BOOL v109 = v85;
            _os_log_impl(&dword_1830D4000, v82, v86, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v85);
          goto LABEL_124;
        }
        if (v87)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v82, v86, "%{public}s called with null report, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v82 = __nwlog_obj();
        os_log_type_t v88 = v106;
        if (os_log_type_enabled(v82, (os_log_type_t)v106))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_fillout_establishment_report_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v82, v88, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_124:
    if (v81) {
      free(v81);
    }
LABEL_87:

    id v6 = v91;
    goto LABEL_88;
  }
LABEL_89:
}

void sub_183161588(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17, void *a18, uint64_t a19, void *a20)
{
  _Unwind_Resume(a1);
}

unint64_t nw_connection_get_event_milliseconds(void *a1, int a2, int a3, _WORD *a4, uint64_t a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  unint64_t v9 = a1;
  int v10 = v9;
  if (!v9)
  {
    __int16 v19 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    int v31 = "nw_connection_get_event_milliseconds";
    unsigned int v20 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v20, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          int v31 = "nw_connection_get_event_milliseconds";
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v24 = type;
        BOOL v25 = os_log_type_enabled(v21, type);
        if (backtrace_string)
        {
          if (v25)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            int v31 = "nw_connection_get_event_milliseconds";
            __int16 v32 = 2082;
            nw_endpoint_t v33 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }
        if (v25)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          int v31 = "nw_connection_get_event_milliseconds";
          _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v21, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          int v31 = "nw_connection_get_event_milliseconds";
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_38:
    if (v20) {
      free(v20);
    }
    goto LABEL_40;
  }
  unsigned int v11 = (unsigned __int16)v9[161];
  if (v9[161])
  {
    unint64_t v12 = 0;
    if (a4)
    {
      unint64_t v13 = 0;
      unint64_t v14 = 0xFFFFFFFFLL;
      while (1)
      {
        uint64_t v16 = v10[39];
        if (*(unsigned __int16 *)(v16 + v12 + 10) == a3
          && *(unsigned __int16 *)(v16 + v12 + 8) == a2
          && (!*a4 || *(unsigned __int16 *)(v16 + v12 + 12) == (unsigned __int16)*a4))
        {
          uint64_t v15 = (a5 - 1);
          if (v15 >= 0xFFFFFFFE)
          {
            *a4 = *(_WORD *)(v16 + v12 + 12);
            unint64_t v14 = nw_delta_nanos(v10[9], *(void *)(v16 + v12)) / 0xF4240uLL;
            if (a5 != -1) {
              goto LABEL_41;
            }
            unsigned int v11 = *((unsigned __int16 *)v10 + 161);
            uint64_t v15 = 0xFFFFFFFFLL;
          }
        }
        else
        {
          uint64_t v15 = a5;
        }
        ++v13;
        v12 += 16;
        a5 = v15;
        if (v13 >= v11) {
          goto LABEL_41;
        }
      }
    }
    unint64_t v14 = 0xFFFFFFFFLL;
    while (1)
    {
      uint64_t v18 = v10[39];
      if (*(unsigned __int16 *)((char *)a4 + v18 + 10) == a3 && *(unsigned __int16 *)((char *)a4 + v18 + 8) == a2)
      {
        uint64_t v17 = (a5 - 1);
        if (v17 >= 0xFFFFFFFE)
        {
          unint64_t v14 = nw_delta_nanos(v10[9], *(void *)((char *)a4 + v18)) / 0xF4240uLL;
          if (a5 != -1) {
            goto LABEL_41;
          }
          unsigned int v11 = *((unsigned __int16 *)v10 + 161);
          uint64_t v17 = 0xFFFFFFFFLL;
        }
      }
      else
      {
        uint64_t v17 = a5;
      }
      ++v12;
      a4 += 8;
      a5 = v17;
      if (v12 >= v11) {
        goto LABEL_41;
      }
    }
  }
LABEL_40:
  unint64_t v14 = 0xFFFFFFFFLL;
LABEL_41:

  return v14;
}

uint64_t nw_delta_nanos(uint64_t a1, uint64_t a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = dword_1EB267624;
  if (dword_1EB267624) {
    return (a2 - a1) * (unint64_t)time_base / v4;
  }
  mach_timebase_info((mach_timebase_info_t)&time_base);
  unsigned int v4 = dword_1EB267624;
  if (dword_1EB267624) {
    return (a2 - a1) * (unint64_t)time_base / v4;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)addrinfo buf = 136446210;
  __int16 v19 = "nw_delta_nanos";
  id v6 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = gLogObj;
      os_log_type_t v8 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        __int16 v19 = "nw_delta_nanos";
        unint64_t v9 = "%{public}s nw_init_timebase failed";
LABEL_16:
        unint64_t v14 = v7;
        os_log_type_t v15 = v8;
LABEL_17:
        _os_log_impl(&dword_1830D4000, v14, v15, v9, buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v11 = gLogObj;
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          __int16 v19 = "nw_delta_nanos";
          __int16 v20 = 2082;
          uint64_t v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s nw_init_timebase failed, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v13)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        __int16 v19 = "nw_delta_nanos";
        unint64_t v9 = "%{public}s nw_init_timebase failed, no backtrace";
        unint64_t v14 = v11;
        os_log_type_t v15 = v12;
        goto LABEL_17;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v7 = gLogObj;
      os_log_type_t v8 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        __int16 v19 = "nw_delta_nanos";
        unint64_t v9 = "%{public}s nw_init_timebase failed, backtrace limit exceeded";
        goto LABEL_16;
      }
    }
  }
LABEL_18:
  if (v6) {
    free(v6);
  }
  return 1;
}

uint64_t nw_endpoint_flow_copy_protocol_establishment_reports(void *a1)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    nw_endpoint_t v40 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
    BOOL v41 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v71 = 0;
    if (__nwlog_fault(v41, &type, &v71))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        long long v42 = __nwlog_obj();
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v71)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        long long v42 = __nwlog_obj();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v42, type);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            __int16 v74 = 2082;
            __int16 v75 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v42, v49, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_84;
        }
        if (v50)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_1830D4000, v42, v49, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        long long v42 = __nwlog_obj();
        os_log_type_t v63 = type;
        if (os_log_type_enabled(v42, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_1830D4000, v42, v63, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_84:
    if (v41) {
      free(v41);
    }
    goto LABEL_26;
  }
  unint64_t v3 = (unsigned int *)v1;
  uint64_t v4 = v3[29];

  if (v4 == 2)
  {
    uint64_t v5 = v3;
    id v6 = v5->parameters;

    if (v6)
    {
      uint64_t v7 = v6;
      id v8 = *(id *)(*((void *)v7 + 13) + 136);

      if (v8)
      {
        unint64_t v9 = (dispatch_queue_t *)v8;
        int v10 = v9;
        if (((_BYTE)v9[17] & 8) == 0) {
          dispatch_assert_queue_V2(v9[1]);
        }

        unsigned int v11 = nw_endpoint_handler_copy_flow(v5);
        os_log_type_t v12 = (void *)*((void *)v11 + 51);
        if (v12)
        {
          uint64_t v13 = v12[3];
          if (v13)
          {
            unint64_t v14 = *(uint64_t (**)(void))(v13 + 224);
            if (v14)
            {
              os_log_type_t v15 = (void *)v12[5];
              if (v15 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v33 = v12[11];
                if (v33) {
                  v12[11] = v33 + 1;
                }
                char v16 = -1;
              }
              else
              {
                char v16 = 0;
              }
              *(void *)addrinfo buf = v12;
              buf[8] = v16;
              uint64_t v32 = v14();
              if (v15 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              }
              goto LABEL_43;
            }
          }
        }
        else
        {
          uint64_t v70 = v6;
          __int16 v19 = v5;
          char v20 = *((unsigned char *)v19 + 268);

          if ((v20 & 0x20) != 0)
          {
            uint64_t v32 = 0;
            id v6 = v70;
            goto LABEL_43;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v21 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
          {
            BOOL v69 = v21;
            uint64_t v22 = v19;

            os_log_type_t v23 = v22;
            char v24 = *((unsigned char *)v19 + 268);

            BOOL v25 = "dry-run ";
            if ((v24 & 1) == 0) {
              BOOL v25 = "";
            }
            int v68 = v25;
            nw_endpoint_t v26 = nw_endpoint_handler_copy_endpoint(v23);
            logging_description = nw_endpoint_get_logging_description(v26);
            id_str = v22->id_str;
            char v28 = v23;
            os_log_type_t v29 = v28;
            uint64_t v30 = v28[30];
            if (v30 > 5) {
              int v31 = "unknown-state";
            }
            else {
              int v31 = off_1E523FB38[v30];
            }
            os_log_type_t v66 = v31;

            uint64_t v34 = v29;
            unint64_t v35 = v34;
            int v36 = "path";
            switch(v3[29])
            {
              case 0u:
                break;
              case 1u:
                int v36 = "resolver";
                break;
              case 2u:
                int v36 = nw_endpoint_flow_mode_string(v34[31]);
                break;
              case 3u:
                int v36 = "proxy";
                break;
              case 4u:
                int v36 = "fallback";
                break;
              case 5u:
                int v36 = "transform";
                break;
              default:
                int v36 = "unknown-mode";
                break;
            }

            int v37 = v35;
            os_unfair_lock_lock((os_unfair_lock_t)v37 + 28);
            id v38 = v37[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v37 + 28);

            *(_DWORD *)addrinfo buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            __int16 v74 = 2082;
            __int16 v75 = id_str;
            __int16 v76 = 2082;
            uint64_t v21 = v69;
            char v77 = v68;
            __int16 v78 = 2082;
            BOOL v79 = logging_description;
            __int16 v80 = 2082;
            __int16 v81 = v66;
            __int16 v82 = 2082;
            os_log_type_t v83 = v36;
            __int16 v84 = 2114;
            id v85 = v38;
            _os_log_impl(&dword_1830D4000, v69, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] could not find valid output protocol", buf, 0x48u);
          }
          id v6 = v70;
        }
        uint64_t v32 = 0;
LABEL_43:

LABEL_44:
LABEL_45:

        goto LABEL_46;
      }
      BOOL v51 = __nwlog_obj();
      *(_DWORD *)addrinfo buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
      os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v71 = 0;
      if (__nwlog_fault(v52, &type, &v71))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          id v53 = __nwlog_obj();
          os_log_type_t v54 = type;
          if (os_log_type_enabled(v53, type))
          {
            *(_DWORD *)addrinfo buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null context", buf, 0xCu);
          }
        }
        else
        {
          if (v71)
          {
            id v59 = (char *)__nw_create_backtrace_string();
            char v60 = __nwlog_obj();
            os_log_type_t v61 = type;
            BOOL v62 = os_log_type_enabled(v60, type);
            if (v59)
            {
              if (v62)
              {
                *(_DWORD *)addrinfo buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
                __int16 v74 = 2082;
                __int16 v75 = v59;
                _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v59);
            }
            else
            {
              if (v62)
              {
                *(_DWORD *)addrinfo buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
                _os_log_impl(&dword_1830D4000, v60, v61, "%{public}s called with null context, no backtrace", buf, 0xCu);
              }
            }
            goto LABEL_101;
          }
          id v53 = __nwlog_obj();
          os_log_type_t v65 = type;
          if (os_log_type_enabled(v53, type))
          {
            *(_DWORD *)addrinfo buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
            _os_log_impl(&dword_1830D4000, v53, v65, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_101:
      if (v52) {
        free(v52);
      }
      uint64_t v32 = 0;
      goto LABEL_44;
    }
    nw_endpoint_t v44 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
    os_log_type_t v45 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v71 = 0;
    if (__nwlog_fault(v45, &type, &v71))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v46 = __nwlog_obj();
        os_log_type_t v47 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else
      {
        if (v71)
        {
          os_log_type_t v55 = (char *)__nw_create_backtrace_string();
          os_log_type_t v56 = __nwlog_obj();
          os_log_type_t v57 = type;
          BOOL v58 = os_log_type_enabled(v56, type);
          if (v55)
          {
            if (v58)
            {
              *(_DWORD *)addrinfo buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
              __int16 v74 = 2082;
              __int16 v75 = v55;
              _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v55);
          }
          else
          {
            if (v58)
            {
              *(_DWORD *)addrinfo buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
              _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_95;
        }
        __int16 v46 = __nwlog_obj();
        os_log_type_t v64 = type;
        if (os_log_type_enabled(v46, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
          _os_log_impl(&dword_1830D4000, v46, v64, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_95:
    if (v45) {
      free(v45);
    }
    uint64_t v32 = 0;
    goto LABEL_45;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v17 = (id)gLogObj;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
  {
    if (v4 > 5) {
      uint64_t v18 = "unknown-mode";
    }
    else {
      uint64_t v18 = off_1E523FB08[v4];
    }
    *(_DWORD *)addrinfo buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_establishment_reports";
    __int16 v74 = 2082;
    __int16 v75 = (void *)v18;
    __int16 v76 = 2082;
    char v77 = "flow";
    _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_26:
  uint64_t v32 = 0;
LABEL_46:

  return v32;
}

void sub_183162A2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_get_svcb_report(void *a1, BOOL *a2, BOOL *a3, BOOL *a4)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  id v8 = v7;
  if (!v7)
  {
    unsigned int v11 = __nwlog_obj();
    *(_DWORD *)addrinfo buf = 136446210;
    uint64_t v30 = "nw_endpoint_handler_get_mode";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          uint64_t v30 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            uint64_t v30 = "nw_endpoint_handler_get_mode";
            __int16 v31 = 2082;
            uint64_t v32 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v17)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          uint64_t v30 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          uint64_t v30 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v12) {
      free(v12);
    }
    goto LABEL_22;
  }
  int mode = v7->mode;

  if (mode == 1)
  {
    int v10 = (void **)nw_endpoint_handler_copy_resolver(v8);
    nw_resolver_get_svcb_report(v10[1], a2, a3, a4);

    goto LABEL_29;
  }
LABEL_22:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v19 = (id)gLogObj;
  *(_DWORD *)addrinfo buf = 136446210;
  uint64_t v30 = "nw_endpoint_handler_get_svcb_report";
  char v20 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (!__nwlog_fault(v20, &type, &v27)) {
    goto LABEL_27;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v21 = (id)gLogObj;
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v21, type))
    {
      *(_DWORD *)addrinfo buf = 136446210;
      uint64_t v30 = "nw_endpoint_handler_get_svcb_report";
      _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s Endpoint handler is not a resolver", buf, 0xCu);
    }
LABEL_26:

LABEL_27:
    if (!v20) {
      goto LABEL_29;
    }
LABEL_28:
    free(v20);
    goto LABEL_29;
  }
  if (!v27)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v21 = (id)gLogObj;
    os_log_type_t v26 = type;
    if (os_log_type_enabled(v21, type))
    {
      *(_DWORD *)addrinfo buf = 136446210;
      uint64_t v30 = "nw_endpoint_handler_get_svcb_report";
      _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s Endpoint handler is not a resolver, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_26;
  }
  os_log_type_t v23 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v21 = (id)gLogObj;
  os_log_type_t v24 = type;
  BOOL v25 = os_log_type_enabled(v21, type);
  if (!v23)
  {
    if (v25)
    {
      *(_DWORD *)addrinfo buf = 136446210;
      uint64_t v30 = "nw_endpoint_handler_get_svcb_report";
      _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s Endpoint handler is not a resolver, no backtrace", buf, 0xCu);
    }
    goto LABEL_26;
  }
  if (v25)
  {
    *(_DWORD *)addrinfo buf = 136446466;
    uint64_t v30 = "nw_endpoint_handler_get_svcb_report";
    __int16 v31 = 2082;
    uint64_t v32 = v23;
    _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s Endpoint handler is not a resolver, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v23);
  if (v20) {
    goto LABEL_28;
  }
LABEL_29:
}

void sub_183163284(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_get_svcb_report(void *a1, BOOL *a2, BOOL *a3, BOOL *a4)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = v7;
  if (v7)
  {
    if (a2) {
      *a2 = (*((unsigned char *)v7 + 347) & 2) != 0;
    }
    if (a3) {
      *a3 = (*((unsigned char *)v7 + 347) & 4) != 0;
    }
    if (a4) {
      *a4 = (*((unsigned char *)v7 + 347) & 8) != 0;
    }
    goto LABEL_8;
  }
  unint64_t v9 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446210;
  char v20 = "nw_resolver_get_svcb_report";
  int v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v20 = "nw_resolver_get_svcb_report";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)addrinfo buf = 136446466;
          char v20 = "nw_resolver_get_svcb_report";
          __int16 v21 = 2082;
          os_log_type_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v15)
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v20 = "nw_resolver_get_svcb_report";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)addrinfo buf = 136446210;
        char v20 = "nw_resolver_get_svcb_report";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v10) {
    free(v10);
  }
LABEL_8:
}

_DWORD *nw_activity_create(int a1, int a2)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = [NWConcrete_nw_activity alloc];
  if (!v4) {
    return 0;
  }
  v29.os_log_type_t receiver = v4;
  v29.super_class = (Class)NWConcrete_nw_activity;
  uint64_t v5 = objc_msgSendSuper2(&v29, sel_init);
  id v6 = v5;
  if (!v5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v11 = (id)gLogObj;
    *(_DWORD *)addrinfo buf = 136446210;
    *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v12, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (id)gLogObj;
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (id)gLogObj;
        os_log_type_t v20 = type;
        BOOL v21 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v21)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
            *(_WORD *)&v31[8] = 2082;
            uint64_t v32 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }
        if (v21)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
          _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v13 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
          _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_40:
    if (v12) {
      free(v12);
    }
    return 0;
  }
  v5[28] = a2;
  v5[29] = a1;
  *((unsigned char *)v5 + 140) &= ~2u;
  if (nw_activity_should_log(v5))
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    id v7 = (id)gactivityLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      int v9 = v6[28];
      int v8 = v6[29];
      *(_DWORD *)addrinfo buf = 67109376;
      *(_DWORD *)__int16 v31 = v8;
      *(_WORD *)&void v31[4] = 1024;
      *(_DWORD *)&v31[6] = v9;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "Create activity <nw_activity %u:%u>", buf, 0xEu);
    }
  }
  if (!nw_activity_label_is_valid(a1, a2))
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    *(_DWORD *)addrinfo buf = 136446210;
    *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
    os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v16, &type, &v27))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v17 = (id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Invalid domain or label specified", buf, 0xCu);
        }
      }
      else if (v27)
      {
        os_log_type_t v22 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v17 = (id)gLogObj;
        os_log_type_t v23 = type;
        BOOL v24 = os_log_type_enabled(v17, type);
        if (v22)
        {
          if (v24)
          {
            *(_DWORD *)addrinfo buf = 136446466;
            *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
            *(_WORD *)&v31[8] = 2082;
            uint64_t v32 = v22;
            _os_log_impl(&dword_1830D4000, v17, v23, "%{public}s Invalid domain or label specified, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v22);
          goto LABEL_46;
        }
        if (v24)
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
          _os_log_impl(&dword_1830D4000, v17, v23, "%{public}s Invalid domain or label specified, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v17 = (id)gLogObj;
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v17, type))
        {
          *(_DWORD *)addrinfo buf = 136446210;
          *(void *)__int16 v31 = "-[NWConcrete_nw_activity initWithDomain:label:]";
          _os_log_impl(&dword_1830D4000, v17, v26, "%{public}s Invalid domain or label specified, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_46:
    if (v16) {
      free(v16);
    }
  }
  return v6;
}

void sub_183163C5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_activity_complete_with_reason_and_underlying_error_string_internal(void *a1, uint32_t a2, uint64_t a3, int a4, int a5)
{
  uint64_t v129 = *MEMORY[0x1E4F143B8];
  int v9 = a1;
  uint64_t v106 = 0;
  os_log_type_t v107 = &v106;
  uint64_t v108 = 0x2020000000;
  char v109 = 1;
  aBlock[0] = MEMORY[0x1E4F143A8];
  aBlock[1] = 3221225472;
  aBlock[2] = ___ZL69nw_activity_complete_with_reason_and_underlying_error_string_internalP22NWConcrete_nw_activity31nw_activity_completion_reason_tPKcii_block_invoke;
  aBlock[3] = &unk_1E52449C8;
  int v10 = v9;
  __int16 v100 = v10;
  id v101 = &v106;
  uint64_t v102 = a3;
  int v103 = a4;
  int v104 = a5;
  id v11 = _Block_copy(aBlock);
  __int16 v105 = v11;
  nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v9 + 20, (uint64_t)&v105);

  if (!*((unsigned char *)v107 + 24)) {
    goto LABEL_102;
  }
  os_log_type_t v12 = v10;
  uint64_t v13 = v12;
  if ((~LOBYTE(v12[35]._os_unfair_lock_opaque) & 0xC) == 0)
  {
    os_log_type_t v14 = v12 + 2;
    if (!uuid_is_null((const unsigned __int8 *)&v12[2]))
    {
      if (nw_activity_should_log(v13))
      {
        id v15 = v13;
        if (uuid_is_null((const unsigned __int8 *)&v13[2])) {
          os_signpost_id_t v16 = nw_activity_signpost_id_fallback();
        }
        else {
          os_signpost_id_t v16 = *((void *)v15 + 2) ^ *(void *)&v14->_os_unfair_lock_opaque;
        }

        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        char v17 = (id)gactivityLogObj;
        os_log_type_t v18 = v17;
        if (v16 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v17))
        {
          int v20 = *((_DWORD *)v15 + 28);
          int v19 = *((_DWORD *)v15 + 29);
          *(_DWORD *)addrinfo buf = 67109890;
          *(_DWORD *)&uint8_t buf[4] = v19;
          *(_WORD *)&buf[8] = 1024;
          *(_DWORD *)&buf[10] = v20;
          *(_WORD *)int v119 = 1040;
          *(_DWORD *)&v119[2] = 16;
          *(_WORD *)&v119[6] = 2096;
          *(void *)&v119[8] = v14;
          _os_signpost_emit_with_name_impl(&dword_1830D4000, v18, OS_SIGNPOST_INTERVAL_END, v16, "nw_activity", "<%u:%u [%{uuid_t}.16P]>", buf, 0x1Eu);
        }
      }
    }
  }

  if (a2 <= 4u)
  {
    os_unfair_lock_lock(v13 + 26);
    BOOL v21 = *(void **)&v13[22]._os_unfair_lock_opaque;
    if ((v13[24]._os_unfair_lock_opaque & 1) != 0 && v21)
    {
      *(void *)&v13[22]._uint32_t os_unfair_lock_opaque = 0;

      BOOL v21 = *(void **)&v13[22]._os_unfair_lock_opaque;
    }
    *(void *)&v13[22]._uint32_t os_unfair_lock_opaque = 0;

    os_unfair_lock_unlock(v13 + 26);
    uint64_t v22 = mach_continuous_time();
    if (v22 <= 1) {
      uint64_t v23 = 1;
    }
    else {
      uint64_t v23 = v22;
    }
    *(void *)&v13[10]._uint32_t os_unfair_lock_opaque = v23;
    v13[34]._uint32_t os_unfair_lock_opaque = a2;
    if (!nw_activity_should_log(v13))
    {
LABEL_38:
      uint64_t v34 = v13;
      if (nw_activity_duration_exceeds_threshold(v34))
      {
        *(void *)unsigned int v126 = 0;
        int domain = nw_activity_get_domain(v34);
        asprintf((char **)v126, "%u", domain);
        BOOL v116 = 0;
        int label = nw_activity_get_label(v34);
        asprintf(&v116, "%u", label);
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        int v37 = (id)gactivityLogObj;
        if (os_log_type_enabled(v37, OS_LOG_TYPE_DEFAULT))
        {
          *(_DWORD *)addrinfo buf = 138543362;
          *(void *)&uint8_t buf[4] = v34;
          _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEFAULT, "%{public}@ over threshold, emitting signpost event", buf, 0xCu);
        }

        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        id v38 = (id)gactivityLogObj;
        os_signpost_id_t v39 = os_signpost_id_generate(v38);

        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        nw_endpoint_t v40 = (id)gactivityLogObj;
        BOOL v41 = v40;
        if (v39 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v40))
        {
          uint64_t v42 = *(void *)v126;
          os_log_type_t v43 = v116;
          uint64_t duration = nw_activity_get_duration(v34);
          uint64_t v45 = nw_activity_duration_threshold_for_label(v34[29], v34[28]);
          *(_DWORD *)addrinfo buf = 136446978;
          *(void *)&uint8_t buf[4] = v42;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)int v119 = v43;
          *(_WORD *)&v119[8] = 2050;
          *(void *)&v119[10] = duration;
          *(_WORD *)&v119[18] = 2050;
          *(void *)&v119[20] = v45;
          _os_signpost_emit_with_name_impl(&dword_1830D4000, v41, OS_SIGNPOST_EVENT, v39, "nw_activity over threshold", " enableTelemetry=YES Activity <nw_activity %{public, signpost.telemetry:string1, name=ActivityDomain}s:%{public, signpost.telemetry:string2, name=ActivityLabel}s> over threshold (duration %{public, signpost.telemetry:number1, name=Duration}llums exceeds threshold %{public, signpost.telemetry:number2, name=Threshold}llums)", buf, 0x2Au);
        }

        if (*(void *)v126)
        {
          free(*(void **)v126);
          *(void *)unsigned int v126 = 0;
        }
        if (v116) {
          free(v116);
        }
      }

      __int16 v46 = v34;
      os_log_type_t v47 = v46;
      if ((~LOBYTE(v13[35]._os_unfair_lock_opaque) & 0xC) == 0)
      {
        if ((*((unsigned char *)v46 + 17) & 1) == 0)
        {
LABEL_101:

          goto LABEL_102;
        }
        bzero(buf, 0x250uLL);
        os_log_type_t v48 = v47;
        nw_activity_fill_out_activity_report(v48, (nw_activity_report_s *)&buf[8]);
        *(void *)addrinfo buf = nw_activity_get_duration(v48);
        unsigned int value = nw_activity_get_fragments_quenched(v48);
        int value_4 = nw_activity_get_underlying_error_domain(v48);
        underlying_unsigned int error_code = nw_activity_get_underlying_error_code(v48);
        int completion_reason = nw_activity_get_completion_reason(v48);
        uint64_t underlying_error_domain_string = nw_activity_get_underlying_error_domain_string(v48);
        if (underlying_error_domain_string)
        {
          uint64_t v50 = 0;
          while (1)
          {
            int v51 = *(unsigned __int8 *)(underlying_error_domain_string + v50);
            v125[v50] = v51;
            if (!v51) {
              break;
            }
            if (++v50 == 255)
            {
              v125[255] = 0;
              break;
            }
          }
        }

        if (!os_variant_has_internal_diagnostics()
          || !networkd_settings_get_BOOL((const char *)nw_setting_activity_write_metric_stream_to_log))
        {
          if (nw_connection_get_symptom_reporter_handle::once[0] != -1) {
            dispatch_once(nw_connection_get_symptom_reporter_handle::once, &__block_literal_global_79705);
          }
          symptom_new();
          symptom_set_qualifier();
          symptom_set_additional_qualifier();
          symptom_send();
          goto LABEL_101;
        }
        os_log_type_t v52 = v48;
        id v53 = (char *)xpc_dictionary_create(0, 0, 0);
        BOOL v116 = v53;
        char v117 = -1;
        if (v53)
        {
          activity_dictionary = nw_activity_create_activity_dictionary(v52, (nw_activity_report_s *)&buf[8]);
          *(void *)os_log_type_t type = activity_dictionary;
          char v114 = -1;
          if (activity_dictionary)
          {
            xpc_dictionary_set_value(v53, "activity", activity_dictionary);
            xpc_dictionary_set_uint64(v53, "durationMsecs", *(uint64_t *)buf);
            xpc_dictionary_set_uint64(v53, "fragmentsQuenched", value);
            os_log_type_t v55 = v53;
            os_log_type_t v56 = v55;
            if ((completion_reason - 1) > 3) {
              os_log_type_t v57 = "invalid";
            }
            else {
              os_log_type_t v57 = off_1E5246030[completion_reason - 1];
            }
            xpc_dictionary_set_string(v55, "completionReason", v57);

            xpc_dictionary_set_string(v56, "underlyingErrorDomainString", v125);
            xpc_dictionary_set_int64(v56, "underlyingErrorDomain", value_4);
            xpc_dictionary_set_int64(v56, "underlyingErrorCode", underlying_error_code);

LABEL_72:
            uint64_t v110 = v56;
            char v111 = -1;
            BOOL v116 = 0;
            if (nw_activity_metric_object_is_valid(v56, 0, (const char **)&v116))
            {
              if (__nwlog_metricstream_log::onceToken != -1) {
                dispatch_once(&__nwlog_metricstream_log::onceToken, &__block_literal_global_64);
              }
              BOOL v58 = (id)gmetricstreamLogObj;
              if (os_log_type_enabled(v58, OS_LOG_TYPE_DEFAULT))
              {
                *(_DWORD *)unsigned int v126 = 136446210;
                *(void *)&v126[4] = v116;
                _os_log_impl(&dword_1830D4000, v58, OS_LOG_TYPE_DEFAULT, "%{public}s", v126, 0xCu);
              }

LABEL_96:
              if (v116) {
                free(v116);
              }
              if (v56) {

              }
              goto LABEL_101;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v59 = (id)gLogObj;
            *(_DWORD *)unsigned int v126 = 136446210;
            *(void *)&v126[4] = "nw_activity_write_epilogue_report_to_log";
            char v60 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v115 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v60, type, &v115))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v61 = __nwlog_obj();
                os_log_type_t v62 = type[0];
                if (os_log_type_enabled(v61, type[0]))
                {
                  *(_DWORD *)unsigned int v126 = 136446210;
                  *(void *)&v126[4] = "nw_activity_write_epilogue_report_to_log";
                  _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s generated activity epilogue dictionary is not valid", v126, 0xCu);
                }
              }
              else if (v115)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                os_log_type_t v61 = __nwlog_obj();
                os_log_type_t v64 = type[0];
                BOOL v65 = os_log_type_enabled(v61, type[0]);
                if (backtrace_string)
                {
                  if (v65)
                  {
                    *(_DWORD *)unsigned int v126 = 136446466;
                    *(void *)&v126[4] = "nw_activity_write_epilogue_report_to_log";
                    __int16 v127 = 2082;
                    int v128 = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v61, v64, "%{public}s generated activity epilogue dictionary is not valid, dumping backtrace:%{public}s", v126, 0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_94;
                }
                if (v65)
                {
                  *(_DWORD *)unsigned int v126 = 136446210;
                  *(void *)&v126[4] = "nw_activity_write_epilogue_report_to_log";
                  _os_log_impl(&dword_1830D4000, v61, v64, "%{public}s generated activity epilogue dictionary is not valid, no backtrace", v126, 0xCu);
                }
              }
              else
              {
                os_log_type_t v61 = __nwlog_obj();
                os_log_type_t v66 = type[0];
                if (os_log_type_enabled(v61, type[0]))
                {
                  *(_DWORD *)unsigned int v126 = 136446210;
                  *(void *)&v126[4] = "nw_activity_write_epilogue_report_to_log";
                  _os_log_impl(&dword_1830D4000, v61, v66, "%{public}s generated activity epilogue dictionary is not valid, backtrace limit exceeded", v126, 0xCu);
                }
              }
            }
LABEL_94:
            if (v60) {
              free(v60);
            }
            goto LABEL_96;
          }
          BOOL v87 = __nwlog_obj();
          *(_DWORD *)unsigned int v126 = 136446210;
          *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
          os_log_type_t v88 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t v115 = OS_LOG_TYPE_ERROR;
          char v112 = 0;
          if (!__nwlog_fault(v88, &v115, &v112)) {
            goto LABEL_174;
          }
          if (v115 == OS_LOG_TYPE_FAULT)
          {
            int v89 = __nwlog_obj();
            os_log_type_t v90 = v115;
            if (os_log_type_enabled(v89, v115))
            {
              *(_DWORD *)unsigned int v126 = 136446210;
              *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
              _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s failed to get activity dictionary", v126, 0xCu);
            }
          }
          else if (v112)
          {
            unsigned int v94 = (char *)__nw_create_backtrace_string();
            int v89 = __nwlog_obj();
            os_log_type_t v95 = v115;
            BOOL v96 = os_log_type_enabled(v89, v115);
            if (v94)
            {
              if (v96)
              {
                *(_DWORD *)unsigned int v126 = 136446466;
                *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
                __int16 v127 = 2082;
                int v128 = v94;
                _os_log_impl(&dword_1830D4000, v89, v95, "%{public}s failed to get activity dictionary, dumping backtrace:%{public}s", v126, 0x16u);
              }

              free(v94);
              goto LABEL_174;
            }
            if (v96)
            {
              *(_DWORD *)unsigned int v126 = 136446210;
              *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
              _os_log_impl(&dword_1830D4000, v89, v95, "%{public}s failed to get activity dictionary, no backtrace", v126, 0xCu);
            }
          }
          else
          {
            int v89 = __nwlog_obj();
            os_log_type_t v98 = v115;
            if (os_log_type_enabled(v89, v115))
            {
              *(_DWORD *)unsigned int v126 = 136446210;
              *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
              _os_log_impl(&dword_1830D4000, v89, v98, "%{public}s failed to get activity dictionary, backtrace limit exceeded", v126, 0xCu);
            }
          }

LABEL_174:
          if (v88) {
            free(v88);
          }

LABEL_177:
          os_log_type_t v56 = 0;
          goto LABEL_72;
        }
        os_log_type_t v83 = __nwlog_obj();
        *(_DWORD *)unsigned int v126 = 136446210;
        *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
        __int16 v84 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v115 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v84, type, &v115))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v85 = __nwlog_obj();
            os_log_type_t v86 = type[0];
            if (os_log_type_enabled(v85, type[0]))
            {
              *(_DWORD *)unsigned int v126 = 136446210;
              *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
              _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s failed to allocate dictionary", v126, 0xCu);
            }
          }
          else if (v115)
          {
            os_log_type_t v91 = (char *)__nw_create_backtrace_string();
            id v85 = __nwlog_obj();
            os_log_type_t v92 = type[0];
            BOOL v93 = os_log_type_enabled(v85, type[0]);
            if (v91)
            {
              if (v93)
              {
                *(_DWORD *)unsigned int v126 = 136446466;
                *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
                __int16 v127 = 2082;
                int v128 = v91;
                _os_log_impl(&dword_1830D4000, v85, v92, "%{public}s failed to allocate dictionary, dumping backtrace:%{public}s", v126, 0x16u);
              }

              free(v91);
              goto LABEL_169;
            }
            if (v93)
            {
              *(_DWORD *)unsigned int v126 = 136446210;
              *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
              _os_log_impl(&dword_1830D4000, v85, v92, "%{public}s failed to allocate dictionary, no backtrace", v126, 0xCu);
            }
          }
          else
          {
            id v85 = __nwlog_obj();
            os_log_type_t v97 = type[0];
            if (os_log_type_enabled(v85, type[0]))
            {
              *(_DWORD *)unsigned int v126 = 136446210;
              *(void *)&v126[4] = "nw_activity_create_epilogue_dictionary";
              _os_log_impl(&dword_1830D4000, v85, v97, "%{public}s failed to allocate dictionary, backtrace limit exceeded", v126, 0xCu);
            }
          }
        }
LABEL_169:
        if (v84) {
          free(v84);
        }
        goto LABEL_177;
      }
      char v71 = __nwlog_obj();
      *(_DWORD *)addrinfo buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_activity_epilogue_report_if_selected";
      os_log_type_t v72 = (char *)_os_log_send_and_compose_impl();

      v126[0] = 16;
      LOBYTE(v116) = 0;
      if (__nwlog_fault(v72, v126, &v116))
      {
        if (v126[0] == 17)
        {
          __int16 v73 = __nwlog_obj();
          os_log_type_t v74 = v126[0];
          if (os_log_type_enabled(v73, (os_log_type_t)v126[0]))
          {
            *(_DWORD *)addrinfo buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_activity_epilogue_report_if_selected";
            _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s Cannot report activity before activation", buf, 0xCu);
          }
        }
        else if ((_BYTE)v116)
        {
          __int16 v78 = (char *)__nw_create_backtrace_string();
          __int16 v73 = __nwlog_obj();
          os_log_type_t v79 = v126[0];
          BOOL v80 = os_log_type_enabled(v73, (os_log_type_t)v126[0]);
          if (v78)
          {
            if (v80)
            {
              *(_DWORD *)addrinfo buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_activity_epilogue_report_if_selected";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)int v119 = v78;
              _os_log_impl(&dword_1830D4000, v73, v79, "%{public}s Cannot report activity before activation, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v78);
            goto LABEL_148;
          }
          if (v80)
          {
            *(_DWORD *)addrinfo buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_activity_epilogue_report_if_selected";
            _os_log_impl(&dword_1830D4000, v73, v79, "%{public}s Cannot report activity before activation, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          __int16 v73 = __nwlog_obj();
          os_log_type_t v82 = v126[0];
          if (os_log_type_enabled(v73, (os_log_type_t)v126[0]))
          {
            *(_DWORD *)addrinfo buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_activity_epilogue_report_if_selected";
            _os_log_impl(&dword_1830D4000, v73, v82, "%{public}s Cannot report activity before activation, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_148:
      if (v72) {
        free(v72);
      }
      goto LABEL_101;
    }
    if (a5 | a4)
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
      }
      BOOL v24 = (id)gactivityLogObj;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
      if (a2 - 1 > 3) {
        os_log_type_t v25 = "invalid";
      }
      else {
        os_log_type_t v25 = off_1E5246030[a2 - 1];
      }
      uint32_t os_unfair_lock_opaque = v13[31]._os_unfair_lock_opaque;
      uint32_t v27 = v13[32]._os_unfair_lock_opaque;
      uint64_t v29 = nw_activity_get_duration(v13);
      *(_DWORD *)addrinfo buf = 138544642;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)int v119 = a2;
      *(_WORD *)&v119[4] = 2082;
      *(void *)&v119[6] = v25;
      *(_WORD *)&v119[14] = 1024;
      *(_DWORD *)&v119[16] = os_unfair_lock_opaque;
      *(_WORD *)&v119[20] = 1024;
      *(_DWORD *)&v119[22] = v27;
      *(_WORD *)&v119[26] = 2048;
      uint64_t v120 = v29;
      uint64_t v30 = "%{public}@ complete with reason %u (%{public}s), underlying error %d:%d, duration %llums";
      __int16 v31 = v24;
      uint32_t v32 = 50;
    }
    else
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
      }
      BOOL v24 = (id)gactivityLogObj;
      if (!os_log_type_enabled(v24, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_37;
      }
      if (a2 - 1 > 3) {
        os_log_type_t v26 = "invalid";
      }
      else {
        os_log_type_t v26 = off_1E5246030[a2 - 1];
      }
      uint64_t v33 = nw_activity_get_duration(v13);
      *(_DWORD *)addrinfo buf = 138544130;
      *(void *)&uint8_t buf[4] = v13;
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)int v119 = a2;
      *(_WORD *)&v119[4] = 2082;
      *(void *)&v119[6] = v26;
      *(_WORD *)&v119[14] = 2048;
      *(void *)&v119[16] = v33;
      uint64_t v30 = "%{public}@ complete with reason %u (%{public}s), duration %llums";
      __int16 v31 = v24;
      uint32_t v32 = 38;
    }
    _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_DEFAULT, v30, buf, v32);
LABEL_37:

    goto LABEL_38;
  }
  __int16 v67 = __nwlog_obj();
  *(_DWORD *)addrinfo buf = 136446466;
  *(void *)&uint8_t buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
  *(_WORD *)&unsigned char buf[12] = 2082;
  *(void *)int v119 = "Invalid completion reason";
  int v68 = (char *)_os_log_send_and_compose_impl();

  v126[0] = 16;
  LOBYTE(v116) = 0;
  if (__nwlog_fault(v68, v126, &v116))
  {
    if (v126[0] == 17)
    {
      BOOL v69 = __nwlog_obj();
      os_log_type_t v70 = v126[0];
      if (os_log_type_enabled(v69, (os_log_type_t)v126[0]))
      {
        *(_DWORD *)addrinfo buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)int v119 = "Invalid completion reason";
        _os_log_impl(&dword_1830D4000, v69, v70, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }
    else if ((_BYTE)v116)
    {
      __int16 v75 = (char *)__nw_create_backtrace_string();
      BOOL v69 = __nwlog_obj();
      os_log_type_t v76 = v126[0];
      BOOL v77 = os_log_type_enabled(v69, (os_log_type_t)v126[0]);
      if (v75)
      {
        if (v77)
        {
          *(_DWORD *)addrinfo buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)int v119 = "Invalid completion reason";
          *(_WORD *)&v119[8] = 2082;
          *(void *)&v119[10] = v75;
          _os_log_impl(&dword_1830D4000, v69, v76, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v75);
        goto LABEL_143;
      }
      if (v77)
      {
        *(_DWORD *)addrinfo buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)int v119 = "Invalid completion reason";
        _os_log_impl(&dword_1830D4000, v69, v76, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }
    else
    {
      BOOL v69 = __nwlog_obj();
      os_log_type_t v81 = v126[0];
      if (os_log_type_enabled(v69, (os_log_type_t)v126[0]))
      {
        *(_DWORD *)addrinfo buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_activity_complete_with_reason_and_underlying_error_string_internal";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)int v119 = "Invalid completion reason";
        _os_log_impl(&dword_1830D4000, v69, v81, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }
  }
LABEL_143:
  if (v68) {
    free(v68);
  }
LABEL_102:

  _Block_object_dispose(&v106, 8);
}