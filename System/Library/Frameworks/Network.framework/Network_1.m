void sub_1831650AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, ...)
{
  void *v15;
  void *v16;
  va_list va;

  va_start(va, a15);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_activity_should_log(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  v2 = v1;
  if (!v1)
  {
    v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)v25 = "nw_activity_should_log";
    v15 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v15, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        v16 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)v25 = "nw_activity_should_log";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v16 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v16, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)v25 = "nw_activity_should_log";
            *(_WORD *)&v25[8] = 2082;
            *(void *)&v25[10] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_66;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)v25 = "nw_activity_should_log";
          _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v16 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v16, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)v25 = "nw_activity_should_log";
          _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_66:
    if (v15) {
      free(v15);
    }
    goto LABEL_44;
  }
  if ((v1[35] & 2) != 0)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    v5 = (id)gactivityLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138543362;
      *(void *)v25 = v2;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "Not checking if we should log for lightweight activity %{public}@", buf, 0xCu);
    }
    goto LABEL_19;
  }
  if (!nw_activity_label_is_valid(v1[29], v1[28]))
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    v5 = (id)gactivityLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_WORD *)buf = 0;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "Returning true for logging about invalid label", buf, 2u);
    }
    goto LABEL_19;
  }
  if (v2[35] & 4) != 0 && (*((unsigned char *)v2 + 17))
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    v5 = (id)gactivityLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 138543362;
      *(void *)v25 = v2;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "Returning true for logging about activity that is selected for reporting %{public}@", buf, 0xCu);
    }
    goto LABEL_19;
  }
  int v3 = v2[29];
  if (v3 == 12)
  {
    int v9 = v2[28];
    if (v9 == 3)
    {
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
      }
      v10 = (id)gactivityLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v13 = nw_activity_domain_and_label_to_string(v2[29], v2[28]);
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)v25 = 0;
        *(_WORD *)&v25[4] = 2082;
        *(void *)&v25[6] = v13;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "Returning should log: %u for activity %{public}s", buf, 0x12u);
      }
    }
    else
    {
      if (v9 != 2) {
        goto LABEL_20;
      }
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
      }
      v10 = (id)gactivityLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        v11 = nw_activity_domain_and_label_to_string(v2[29], v2[28]);
        *(_DWORD *)buf = 67109378;
        *(_DWORD *)v25 = 0;
        *(_WORD *)&v25[4] = 2082;
        *(void *)&v25[6] = v11;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "Returning should log: %u for activity %{public}s", buf, 0x12u);
      }
    }
    goto LABEL_43;
  }
  if (v3 != 11) {
    goto LABEL_20;
  }
  int v4 = v2[28];
  if (v4 == 8)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    v10 = (id)gactivityLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      v12 = nw_activity_domain_and_label_to_string(v2[29], v2[28]);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)v25 = 0;
      *(_WORD *)&v25[4] = 2082;
      *(void *)&v25[6] = v12;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "Returning should log: %u for activity %{public}s", buf, 0x12u);
    }
LABEL_43:

LABEL_44:
    uint64_t v7 = 0;
    goto LABEL_21;
  }
  if (v4 == 7)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    v5 = (id)gactivityLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      v6 = nw_activity_domain_and_label_to_string(v2[29], v2[28]);
      *(_DWORD *)buf = 67109378;
      *(_DWORD *)v25 = 1;
      *(_WORD *)&v25[4] = 2082;
      *(void *)&v25[6] = v6;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "Returning should log: %u for activity %{public}s", buf, 0x12u);
    }
LABEL_19:
  }
LABEL_20:
  uint64_t v7 = 1;
LABEL_21:

  return v7;
}

BOOL nw_activity_label_is_valid(int a1, int a2)
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = a1 - 900;
  unsigned int v5 = a1 - 11;
  BOOL result = (a1 - 900) < 0x64;
  if (v4 < 0x64 || v5 < 0x33)
  {
    switch(v5)
    {
      case 0u:
        if ((a2 - 1) < 8) {
          goto LABEL_10;
        }
        break;
      case 1u:
      case 0x16u:
      case 0x1Bu:
      case 0x1Fu:
      case 0x25u:
      case 0x32u:
        if ((a2 - 1) < 3) {
          goto LABEL_10;
        }
        break;
      case 2u:
      case 5u:
      case 0xDu:
      case 0xEu:
      case 0xFu:
      case 0x18u:
      case 0x27u:
      case 0x28u:
      case 0x2Eu:
        if ((a2 - 1) < 2) {
          goto LABEL_10;
        }
        break;
      case 3u:
      case 0x15u:
        if ((a2 - 1) < 0xC) {
          goto LABEL_10;
        }
        break;
      case 4u:
      case 0x22u:
        if ((a2 - 1) < 9) {
          goto LABEL_10;
        }
        break;
      case 6u:
      case 0x13u:
      case 0x2Bu:
      case 0x2Cu:
      case 0x30u:
        if ((a2 - 1) < 4) {
          goto LABEL_10;
        }
        break;
      case 7u:
        if ((a2 - 1) < 0x11) {
          goto LABEL_10;
        }
        break;
      case 0xAu:
        if ((a2 - 1) < 0x17) {
          goto LABEL_10;
        }
        break;
      case 0xBu:
      case 0x1Eu:
        if ((a2 - 1) < 6) {
          goto LABEL_10;
        }
        break;
      case 0xCu:
        if ((a2 - 1) < 0x18) {
          goto LABEL_10;
        }
        break;
      case 0x10u:
      case 0x11u:
      case 0x12u:
        if ((a2 - 1) < 0x42) {
          goto LABEL_10;
        }
        break;
      case 0x14u:
      case 0x1Cu:
      case 0x23u:
        if (a2 == 1) {
          goto LABEL_10;
        }
        break;
      case 0x17u:
      case 0x31u:
        if ((a2 - 1) < 0xB) {
          goto LABEL_10;
        }
        break;
      case 0x19u:
      case 0x26u:
        if ((a2 - 1) < 0xA) {
          goto LABEL_10;
        }
        break;
      case 0x1Au:
      case 0x24u:
        if ((a2 - 1) < 0xD) {
          goto LABEL_10;
        }
        break;
      case 0x1Du:
      case 0x21u:
      case 0x29u:
        if ((a2 - 1) < 7) {
          goto LABEL_10;
        }
        break;
      case 0x20u:
        if ((a2 - 1) < 0x10) {
          goto LABEL_10;
        }
        break;
      case 0x2Au:
        if ((a2 - 1) < 5) {
          goto LABEL_10;
        }
        break;
      case 0x2Fu:
        if ((a2 - 1) < 0x15) {
LABEL_10:
        }
          BOOL result = 1;
        break;
      default:
        return result;
    }
  }
  else
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    uint64_t v7 = (id)gactivityLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      v8[0] = 67109376;
      v8[1] = a2;
      __int16 v9 = 1024;
      int v10 = a1;
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "Label %u is not valid because domain %u is not valid", (uint8_t *)v8, 0xEu);
    }

    return 0;
  }
  return result;
}

void nw_activity_activate(void *a1)
{
  uint64_t v39 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  v2 = v1;
  if (v1)
  {
    *(void *)v30 = 0;
    *(void *)&v30[8] = v30;
    *(void *)&v30[16] = 0x2020000000;
    char v31 = 0;
    aBlock[0] = MEMORY[0x1E4F143A8];
    aBlock[1] = 3221225472;
    aBlock[2] = __nw_activity_activate_block_invoke;
    aBlock[3] = &unk_1E524B978;
    v27 = v30;
    int v3 = v1;
    uint64_t v26 = v3;
    unsigned int v4 = _Block_copy(aBlock);
    v28 = v4;
    nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(v2 + 20, (uint64_t)&v28);

    if (*(unsigned char *)(*(void *)&v30[8] + 24))
    {
      unsigned int v5 = v3;
      v6 = (unsigned __int8 *)v5;
      if ((v5[35]._os_unfair_lock_opaque & 4) != 0)
      {
        uint64_t v7 = v5 + 2;
        if (!uuid_is_null((const unsigned __int8 *)&v5[2]))
        {
          if (nw_activity_should_log(v6))
          {
            v8 = v6;
            if (uuid_is_null(v6 + 8)) {
              os_signpost_id_t v9 = nw_activity_signpost_id_fallback();
            }
            else {
              os_signpost_id_t v9 = *((void *)v8 + 2) ^ *(void *)&v7->_os_unfair_lock_opaque;
            }

            if (__nwlog_activity_log::onceToken != -1) {
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
            }
            int v10 = (id)gactivityLogObj;
            uint64_t v11 = v10;
            if (v9 - 1 <= 0xFFFFFFFFFFFFFFFDLL && os_signpost_enabled(v10))
            {
              int v13 = *((_DWORD *)v8 + 28);
              int v12 = *((_DWORD *)v8 + 29);
              *(_DWORD *)buf = 67109890;
              *(_DWORD *)&uint8_t buf[4] = v12;
              __int16 v33 = 1024;
              int v34 = v13;
              __int16 v35 = 1040;
              int v36 = 16;
              __int16 v37 = 2096;
              v38 = v7;
              _os_signpost_emit_with_name_impl(&dword_1830D4000, v11, OS_SIGNPOST_INTERVAL_BEGIN, v9, "nw_activity", "<%u:%u [%{uuid_t}.16P]>", buf, 0x1Eu);
            }
          }
        }
      }

      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
      }
      *(void *)buf = (id)nw_context_copy_implicit_context::implicit_context;
      LOBYTE(v33) = -1;
      id v14 = *(id *)buf;
      v23[0] = MEMORY[0x1E4F143A8];
      v23[1] = 3221225472;
      v23[2] = __nw_activity_activate_block_invoke_54;
      v23[3] = &unk_1E524BAA8;
      v24 = v6;
      nw_queue_context_async_if_needed(v14, v23);

      if (v14) {
    }
      }

    _Block_object_dispose(v30, 8);
    goto LABEL_20;
  }
  v15 = __nwlog_obj();
  *(_DWORD *)v30 = 136446210;
  *(void *)&v30[4] = "nw_activity_activate";
  v16 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  char v29 = 0;
  if (__nwlog_fault(v16, buf, &v29))
  {
    if (buf[0] == 17)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = buf[0];
      if (os_log_type_enabled(v17, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v30 = 136446210;
        *(void *)&v30[4] = "nw_activity_activate";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null activity", v30, 0xCu);
      }
    }
    else if (v29)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v20 = buf[0];
      BOOL v21 = os_log_type_enabled(v17, (os_log_type_t)buf[0]);
      if (backtrace_string)
      {
        if (v21)
        {
          *(_DWORD *)v30 = 136446466;
          *(void *)&v30[4] = "nw_activity_activate";
          *(_WORD *)&v30[12] = 2082;
          *(void *)&v30[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null activity, dumping backtrace:%{public}s", v30, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_38;
      }
      if (v21)
      {
        *(_DWORD *)v30 = 136446210;
        *(void *)&v30[4] = "nw_activity_activate";
        _os_log_impl(&dword_1830D4000, v17, v20, "%{public}s called with null activity, no backtrace", v30, 0xCu);
      }
    }
    else
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v22 = buf[0];
      if (os_log_type_enabled(v17, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)v30 = 136446210;
        *(void *)&v30[4] = "nw_activity_activate";
        _os_log_impl(&dword_1830D4000, v17, v22, "%{public}s called with null activity, backtrace limit exceeded", v30, 0xCu);
      }
    }
  }
LABEL_38:
  if (v16) {
    free(v16);
  }
LABEL_20:
}

void sub_183165FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,uint64_t a25,uint64_t a26,char a27)
{
  _Block_object_dispose(&a27, 8);
  _Unwind_Resume(a1);
}

void nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>(os_unfair_lock_s *a1, uint64_t a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    unsigned int v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_synchronize";
    unsigned int v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (!__nwlog_fault(v5, &type, &v14)) {
      goto LABEL_35;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_synchronize";
        v8 = "%{public}s called with null lock";
LABEL_33:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v11 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v17 = "nw_synchronize";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null lock, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_35:
        if (!v5) {
          return;
        }
        goto LABEL_36;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_synchronize";
        v8 = "%{public}s called with null lock, no backtrace";
        goto LABEL_33;
      }
    }
    else
    {
      v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v17 = "nw_synchronize";
        v8 = "%{public}s called with null lock, backtrace limit exceeded";
        goto LABEL_33;
      }
    }
LABEL_34:

    goto LABEL_35;
  }
  if (*(void *)a2)
  {
    os_unfair_lock_lock(a1);
    (*(void (**)(void))(*(void *)a2 + 16))();
    os_unfair_lock_unlock(a1);
    return;
  }
  os_signpost_id_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v17 = "nw_synchronize";
  unsigned int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (!__nwlog_fault(v5, &type, &v14)) {
    goto LABEL_35;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_synchronize";
      v8 = "%{public}s called with null func";
      goto LABEL_33;
    }
    goto LABEL_34;
  }
  if (!v14)
  {
    v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (os_log_type_enabled(v6, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_synchronize";
      v8 = "%{public}s called with null func, backtrace limit exceeded";
      goto LABEL_33;
    }
    goto LABEL_34;
  }
  int v12 = (char *)__nw_create_backtrace_string();
  v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v13 = os_log_type_enabled(v6, type);
  if (!v12)
  {
    if (v13)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v17 = "nw_synchronize";
      v8 = "%{public}s called with null func, no backtrace";
      goto LABEL_33;
    }
    goto LABEL_34;
  }
  if (v13)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v17 = "nw_synchronize";
    __int16 v18 = 2082;
    os_log_type_t v19 = v12;
    _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null func, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v12);
  if (v5) {
LABEL_36:
  }
    free(v5);
}

void __nw_activity_activate_block_invoke(uint64_t a1)
{
  uint64_t v70 = *MEMORY[0x1E4F143B8];
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = (*(unsigned char *)(*(void *)(a1 + 32) + 140) & 4) == 0;
  if (!*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24)) {
    return;
  }
  uint64_t v2 = mach_continuous_time();
  if (v2 <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = v2;
  }
  *(void *)(*(void *)(a1 + 32) + 32) = v3;
  if (!nw_activity_is_lightweight_representation(*(void **)(a1 + 32)))
  {
    if (!*(void *)(*(void *)(a1 + 32) + 24))
    {
      *(void *)(*(void *)(a1 + 32) + 24) = nw_activity_get_investigation_id_from_defaults();
      unsigned int v4 = *(void **)(a1 + 32);
      if (!v4[3])
      {
        os_log_type_t v7 = v4;
LABEL_13:
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&buf[16] = ___ZL51nw_activity_inherit_from_global_parent_if_necessaryP22NWConcrete_nw_activity_block_invoke;
        v64 = (char *)&unk_1E524BAA8;
        id v65 = v7;
        v8 = v7;
        os_signpost_id_t v9 = _Block_copy(buf);
        *(void *)__upper_bound = v9;
        nw_synchronize<nw::unfair_mutex,void({block_pointer} {__strong})(void)>((os_unfair_lock_s *)&global_parent_lock, (uint64_t)__upper_bound);

        goto LABEL_14;
      }
    }
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    unsigned int v5 = (id)gactivityLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      *(_DWORD *)buf = 138412290;
      *(void *)&uint8_t buf[4] = v6;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEBUG, "%@ overriding reporting strategy to always due to investigation identifier", buf, 0xCu);
    }

    *(_DWORD *)(*(void *)(a1 + 32) + 132) = 3;
    os_log_type_t v7 = *(id *)(a1 + 32);
    if (v7) {
      goto LABEL_13;
    }
    v38 = __nwlog_obj();
    *(_DWORD *)os_log_type_t type = 136446210;
    v67 = "nw_activity_inherit_from_global_parent_if_necessary";
    uint64_t v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v62 = OS_LOG_TYPE_ERROR;
    char v61 = 0;
    if (__nwlog_fault(v39, &v62, &v61))
    {
      if (v62 == OS_LOG_TYPE_FAULT)
      {
        v40 = __nwlog_obj();
        os_log_type_t v41 = v62;
        if (os_log_type_enabled(v40, v62))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          v67 = "nw_activity_inherit_from_global_parent_if_necessary";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null activity", (uint8_t *)type, 0xCu);
        }
      }
      else if (v61)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        v40 = __nwlog_obj();
        os_log_type_t v49 = v62;
        BOOL v50 = os_log_type_enabled(v40, v62);
        if (backtrace_string)
        {
          if (v50)
          {
            *(_DWORD *)os_log_type_t type = 136446466;
            v67 = "nw_activity_inherit_from_global_parent_if_necessary";
            __int16 v68 = 2082;
            v69 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v40, v49, "%{public}s called with null activity, dumping backtrace:%{public}s", (uint8_t *)type, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_133;
        }
        if (v50)
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          v67 = "nw_activity_inherit_from_global_parent_if_necessary";
          _os_log_impl(&dword_1830D4000, v40, v49, "%{public}s called with null activity, no backtrace", (uint8_t *)type, 0xCu);
        }
      }
      else
      {
        v40 = __nwlog_obj();
        os_log_type_t v57 = v62;
        if (os_log_type_enabled(v40, v62))
        {
          *(_DWORD *)os_log_type_t type = 136446210;
          v67 = "nw_activity_inherit_from_global_parent_if_necessary";
          _os_log_impl(&dword_1830D4000, v40, v57, "%{public}s called with null activity, backtrace limit exceeded", (uint8_t *)type, 0xCu);
        }
      }
    }
LABEL_133:
    if (v39) {
      free(v39);
    }
LABEL_14:
    int v10 = *(id *)(a1 + 32);
    id v11 = v10;
    if (v10)
    {
      int v12 = (unsigned char *)v10[7];
      if (v12)
      {
        if ((v12[140] & 4) != 0)
        {
          if (nw_activity_is_lightweight_representation(v12))
          {
            BOOL v13 = (_DWORD *)*((void *)v11 + 7);
          }
          else
          {
            if (__nwlog_activity_log::onceToken != -1) {
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
            }
            os_log_type_t v17 = (id)gactivityLogObj;
            if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
            {
              id v18 = *((id *)v11 + 7);
              *(_DWORD *)buf = 138543618;
              *(void *)&uint8_t buf[4] = v11;
              *(_WORD *)&buf[12] = 2114;
              *(void *)&buf[14] = v18;
              _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "Activity %{public}@ inheriting reporting strategy from parent %{public}@", buf, 0x16u);
            }
            BOOL v13 = (_DWORD *)*((void *)v11 + 7);
            *((_DWORD *)v11 + 33) = v13[33];
          }
          int is_selected_for_reporting = nw_activity_is_selected_for_reporting(v13);
          goto LABEL_58;
        }
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        v25 = (id)gactivityLogObj;
        if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
        {
          *(_WORD *)buf = 0;
          _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "Cannot activate activity if parent is not yet activated (log only)", buf, 2u);
        }
        goto LABEL_56;
      }
      unsigned int v14 = *((_DWORD *)v11 + 33);
      if (v14 < 2)
      {
        *(_DWORD *)os_log_type_t type = 0;
        __upper_bound[0] = 0;
        nw_activity_get_sampling_rate_for_domain(*((_DWORD *)v11 + 29), (int *)type, __upper_bound);
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        os_log_type_t v19 = (id)gactivityLogObj;
        if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543874;
          *(void *)&uint8_t buf[4] = v11;
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = *(_DWORD *)type;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = __upper_bound[0];
          _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}@ sampled at %u / %u", buf, 0x18u);
        }

        int is_selected_for_reporting = arc4random_uniform(__upper_bound[0]) < *(_DWORD *)type;
      }
      else
      {
        if (v14 != 2)
        {
          if (v14 == 3)
          {
            if (__nwlog_activity_log::onceToken != -1) {
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
            }
            v15 = (id)gactivityLogObj;
            if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 138543362;
              *(void *)&uint8_t buf[4] = v11;
              _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_INFO, "Always reporting activity %{public}@", buf, 0xCu);
            }

            int is_selected_for_reporting = 1;
            goto LABEL_44;
          }
          if (!nw_activity_label_is_valid(*((_DWORD *)v11 + 29), *((_DWORD *)v11 + 28)))
          {
LABEL_52:
            if (__nwlog_activity_log::onceToken != -1) {
              dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
            }
            v25 = (id)gactivityLogObj;
            if (os_log_type_enabled(v25, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 138739971;
              *(void *)&uint8_t buf[4] = v11;
              _os_log_impl(&dword_1830D4000, v25, OS_LOG_TYPE_ERROR, "Never reporting invalid activity %{sensitive}@", buf, 0xCu);
            }
LABEL_56:

LABEL_57:
            int is_selected_for_reporting = 0;
LABEL_58:

            id v26 = *(id *)(a1 + 32);
            uuid_generate_random((unsigned __int8 *)v26 + 8);
            *((unsigned char *)v26 + 17) = *((unsigned char *)v26 + 17) & 0xFE | is_selected_for_reporting;
            os_unfair_lock_lock((os_unfair_lock_t)v26 + 26);
            v27 = (void *)*((void *)v26 + 11);
            if ((*((unsigned char *)v26 + 96) & 1) != 0 && v27)
            {
              *((void *)v26 + 11) = 0;

              v27 = (void *)*((void *)v26 + 11);
            }
            *((void *)v26 + 11) = 0;

            os_unfair_lock_unlock((os_unfair_lock_t)v26 + 26);
            if ((is_selected_for_reporting | nw_activity_should_log(*(void **)(a1 + 32))) == 1)
            {
              uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 56);
              if (__nwlog_activity_log::onceToken != -1) {
                dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
              }
              char v29 = (id)gactivityLogObj;
              BOOL v30 = os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT);
              if (v28)
              {
                if (v30)
                {
                  uint64_t v31 = *(void *)(a1 + 32);
                  id v32 = *(id *)(v31 + 56);
                  *(_DWORD *)buf = 138543618;
                  *(void *)&uint8_t buf[4] = v31;
                  *(_WORD *)&buf[12] = 2114;
                  *(void *)&buf[14] = v32;
                  _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEFAULT, "Activated %{public}@ with parent %{public}@", buf, 0x16u);
                }
              }
              else if (v30)
              {
                uint64_t v33 = *(void *)(a1 + 32);
                *(_DWORD *)buf = 138543362;
                *(void *)&uint8_t buf[4] = v33;
                _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEFAULT, "Activated %{public}@", buf, 0xCu);
              }
            }
            *(unsigned char *)(*(void *)(a1 + 32) + 140) |= 4u;
            return;
          }
          BOOL v21 = __nwlog_obj();
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "Unknown reporting strategy";
          os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          LOBYTE(__upper_bound[0]) = 0;
          if (!__nwlog_fault(v22, type, __upper_bound)) {
            goto LABEL_83;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            v23 = __nwlog_obj();
            os_log_type_t v24 = type[0];
            if (os_log_type_enabled(v23, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "Unknown reporting strategy";
              _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
            }
LABEL_82:

            goto LABEL_83;
          }
          if (!LOBYTE(__upper_bound[0]))
          {
            v23 = __nwlog_obj();
            os_log_type_t v37 = type[0];
            if (os_log_type_enabled(v23, type[0]))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "Unknown reporting strategy";
              _os_log_impl(&dword_1830D4000, v23, v37, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
            }
            goto LABEL_82;
          }
          int v34 = (char *)__nw_create_backtrace_string();
          v23 = __nwlog_obj();
          os_log_type_t v35 = type[0];
          BOOL v36 = os_log_type_enabled(v23, type[0]);
          if (!v34)
          {
            if (v36)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = "Unknown reporting strategy";
              _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
            }
            goto LABEL_82;
          }
          if (v36)
          {
            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = "Unknown reporting strategy";
            *(_WORD *)&buf[22] = 2082;
            v64 = v34;
            _os_log_impl(&dword_1830D4000, v23, v35, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v34);
LABEL_83:
          if (!v22) {
            goto LABEL_57;
          }
LABEL_84:
          free(v22);
          goto LABEL_57;
        }
        if (__nwlog_activity_log::onceToken != -1) {
          dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
        }
        uint64_t v20 = (id)gactivityLogObj;
        if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 138543362;
          *(void *)&uint8_t buf[4] = v11;
          _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "Suppressing reports for activity %{public}@", buf, 0xCu);
        }

        int is_selected_for_reporting = 0;
      }
LABEL_44:
      if (nw_activity_label_is_valid(*((_DWORD *)v11 + 29), *((_DWORD *)v11 + 28))) {
        goto LABEL_58;
      }
      goto LABEL_52;
    }
    v46 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(__upper_bound[0]) = 0;
    if (__nwlog_fault(v22, type, __upper_bound))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        v23 = __nwlog_obj();
        os_log_type_t v47 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
          _os_log_impl(&dword_1830D4000, v23, v47, "%{public}s called with null activity", buf, 0xCu);
        }
      }
      else if (LOBYTE(__upper_bound[0]))
      {
        v54 = (char *)__nw_create_backtrace_string();
        v23 = __nwlog_obj();
        os_log_type_t v55 = type[0];
        BOOL v56 = os_log_type_enabled(v23, type[0]);
        if (v54)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v54;
            _os_log_impl(&dword_1830D4000, v23, v55, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v54);
          if (!v22) {
            goto LABEL_57;
          }
          goto LABEL_84;
        }
        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
          _os_log_impl(&dword_1830D4000, v23, v55, "%{public}s called with null activity, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        v23 = __nwlog_obj();
        os_log_type_t v59 = type[0];
        if (os_log_type_enabled(v23, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_activity_make_reporting_decision";
          _os_log_impl(&dword_1830D4000, v23, v59, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_82;
    }
    goto LABEL_83;
  }
  v42 = __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  *(void *)&uint8_t buf[4] = "nw_activity_activate_block_invoke";
  *(_WORD *)&buf[12] = 2082;
  *(void *)&buf[14] = "Cannot activate lightweight representation of an activity";
  v43 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(__upper_bound[0]) = 0;
  if (__nwlog_fault(v43, type, __upper_bound))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      v44 = __nwlog_obj();
      os_log_type_t v45 = type[0];
      if (os_log_type_enabled(v44, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_activity_activate_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "Cannot activate lightweight representation of an activity";
        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s", buf, 0x16u);
      }
    }
    else if (LOBYTE(__upper_bound[0]))
    {
      v51 = (char *)__nw_create_backtrace_string();
      v44 = __nwlog_obj();
      os_log_type_t v52 = type[0];
      BOOL v53 = os_log_type_enabled(v44, type[0]);
      if (v51)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_activity_activate_block_invoke";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = "Cannot activate lightweight representation of an activity";
          *(_WORD *)&buf[22] = 2082;
          v64 = v51;
          _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(v51);
        goto LABEL_138;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_activity_activate_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "Cannot activate lightweight representation of an activity";
        _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace", buf, 0x16u);
      }
    }
    else
    {
      v44 = __nwlog_obj();
      os_log_type_t v58 = type[0];
      if (os_log_type_enabled(v44, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_activity_activate_block_invoke";
        *(_WORD *)&buf[12] = 2082;
        *(void *)&buf[14] = "Cannot activate lightweight representation of an activity";
        _os_log_impl(&dword_1830D4000, v44, v58, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded", buf, 0x16u);
      }
    }
  }
LABEL_138:
  if (v43) {
    free(v43);
  }
}

void sub_18316744C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_activity_is_lightweight_representation(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[140] >> 1) & 1;
    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v16 = "nw_activity_is_lightweight_representation";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_lightweight_representation";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          v16 = "nw_activity_is_lightweight_representation";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_lightweight_representation";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        v16 = "nw_activity_is_lightweight_representation";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void ___ZL69nw_activity_complete_with_reason_and_underlying_error_string_internalP22NWConcrete_nw_activity31nw_activity_completion_reason_tPKcii_block_invoke(uint64_t a1)
{
  v30[2] = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 140) & 4) == 0)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
    __int16 v27 = 2082;
    uint64_t v28 = "Cannot complete activity before activation";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v12, &type, &v23)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = "Cannot complete activity before activation";
        v15 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
LABEL_43:
        _os_log_impl(&dword_1830D4000, v13, v14, v15, buf, 0x16u);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v20 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446722;
          id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
          __int16 v27 = 2082;
          uint64_t v28 = "Cannot complete activity before activation";
          __int16 v29 = 2082;
          v30[0] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
        }

        free(backtrace_string);
LABEL_45:
        if (!v12)
        {
LABEL_47:
          *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 0;
          return;
        }
LABEL_46:
        free(v12);
        goto LABEL_47;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = "Cannot complete activity before activation";
        v15 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_43;
      }
    }
    else
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = "Cannot complete activity before activation";
        v15 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_43;
      }
    }
LABEL_44:

    goto LABEL_45;
  }
  if ((*(unsigned char *)(v2 + 140) & 8) != 0)
  {
    v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
    __int16 v27 = 2082;
    uint64_t v28 = "Cannot complete activity more than once";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v12, &type, &v23)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = "Cannot complete activity more than once";
        v15 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s";
        goto LABEL_43;
      }
    }
    else
    {
      if (v23)
      {
        BOOL v21 = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v22 = os_log_type_enabled(v13, type);
        if (v21)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446722;
            id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
            __int16 v27 = 2082;
            uint64_t v28 = "Cannot complete activity more than once";
            __int16 v29 = 2082;
            v30[0] = v21;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, dumping backtrace:%{public}s", buf, 0x20u);
          }

          free(v21);
          if (!v12) {
            goto LABEL_47;
          }
          goto LABEL_46;
        }
        if (!v22) {
          goto LABEL_44;
        }
        *(_DWORD *)buf = 136446466;
        id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = "Cannot complete activity more than once";
        v15 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, no backtrace";
        goto LABEL_43;
      }
      char v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446466;
        id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
        __int16 v27 = 2082;
        uint64_t v28 = "Cannot complete activity more than once";
        v15 = "%{public}s BUG IN CLIENT OF LIBNETWORK: %{public}s, backtrace limit exceeded";
        goto LABEL_43;
      }
    }
    goto LABEL_44;
  }
  *(unsigned char *)(v2 + 140) |= 8u;
  uint64_t v3 = *(const char **)(a1 + 48);
  if (!v3)
  {
    *(_DWORD *)(*(void *)(a1 + 32) + 124) = *(_DWORD *)(a1 + 56);
LABEL_12:
    *(_DWORD *)(*(void *)(a1 + 32) + 128) = *(_DWORD *)(a1 + 60);
    return;
  }
  uint64_t v4 = *(void *)(a1 + 32);
  unsigned int v5 = *(void **)(v4 + 72);
  uint64_t v6 = strndup(v3, 0x100uLL);
  if (v6)
  {
    *(void *)(v4 + 72) = v6;
    if (!v5) {
      goto LABEL_7;
    }
    goto LABEL_6;
  }
  __int16 v17 = __nwlog_obj();
  os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  id v26 = "strict_strndup";
  id v18 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v18))
  {
    free(v18);
    *(void *)(*(void *)(a1 + 32) + 72) = 0;
    if (!v5)
    {
LABEL_7:
      if (*(_DWORD *)(a1 + 56))
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v7 = (id)gLogObj;
        if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v8 = *(const char **)(a1 + 32);
          int v9 = *(_DWORD *)(a1 + 56);
          uint64_t v10 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136446978;
          id v26 = "nw_activity_complete_with_reason_and_underlying_error_string_internal_block_invoke";
          __int16 v27 = 2112;
          uint64_t v28 = v8;
          __int16 v29 = 1024;
          LODWORD(v30[0]) = v9;
          WORD2(v30[0]) = 2080;
          *(void *)((char *)v30 + 6) = v10;
          _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %@ ignoring error domain %d because error domain string \"%s\" is set", buf, 0x26u);
        }
      }
      goto LABEL_12;
    }
LABEL_6:
    free(v5);
    goto LABEL_7;
  }
  __break(1u);
}

int64_t nw_activity_get_investigation_id_from_defaults(void)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int64_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_activity_investigation_id, 0);
  if (!int64_with_default) {
    return int64_with_default;
  }
  v1 = (const char *)nw_setting_activity_investigation_id_start_time;
  networkd_settings_init();
  if (!sCachedSettings)
  {
LABEL_11:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
    {
      int v12 = 136446210;
      char v13 = "nw_activity_get_investigation_id_from_defaults";
      os_log_type_t v8 = "%{public}s Investigation ID missing start time, allowing use";
      int v9 = v7;
      uint32_t v10 = 12;
LABEL_13:
      _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, v8, (uint8_t *)&v12, v10);
    }
LABEL_14:

    return int64_with_default;
  }
  pthread_mutex_lock(&sSettingsMutex);
  if (!sCachedSettings)
  {
    pthread_mutex_unlock(&sSettingsMutex);
    goto LABEL_11;
  }
  unint64_t int64 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v1);
  pthread_mutex_unlock(&sSettingsMutex);
  if (!int64) {
    goto LABEL_11;
  }
  __uint64_t v3 = clock_gettime_nsec_np(_CLOCK_REALTIME);
  unint64_t v4 = v3 - int64;
  if (v3 >= int64)
  {
    __uint64_t v5 = v3;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    os_log_type_t v7 = v6;
    if (v4 >= 0x2261034C3CA00)
    {
      if (os_log_type_enabled(v6, OS_LOG_TYPE_INFO))
      {
        int v12 = 136446978;
        char v13 = "nw_activity_get_investigation_id_from_defaults";
        __int16 v14 = 2048;
        unint64_t v15 = int64;
        __int16 v16 = 2048;
        __uint64_t v17 = v5;
        __int16 v18 = 2048;
        unint64_t v19 = v4 / 0x3B9ACA00;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "%{public}s Ignoring investigation ID that has expired (start: %llu, now: %llu, delta_sec: %llu)", (uint8_t *)&v12, 0x2Au);
      }
      int64_t int64_with_default = 0;
      goto LABEL_14;
    }
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      int v12 = 136446978;
      char v13 = "nw_activity_get_investigation_id_from_defaults";
      __int16 v14 = 2048;
      unint64_t v15 = int64;
      __int16 v16 = 2048;
      __uint64_t v17 = v5;
      __int16 v18 = 2048;
      unint64_t v19 = v4 / 0x3B9ACA00;
      os_log_type_t v8 = "%{public}s Investigation ID has not expired (start: %llu, now: %llu, delta_sec: %llu)";
      int v9 = v7;
      uint32_t v10 = 42;
      goto LABEL_13;
    }
    goto LABEL_14;
  }
  return int64_with_default;
}

void nw_activity_get_sampling_rate_for_domain(unsigned int a1, int *a2, unsigned int *a3)
{
  uint64_t v66 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v39 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v61 = "nw_activity_get_sampling_rate_for_domain";
    v40 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (!__nwlog_fault(v40, &type, &v58)) {
      goto LABEL_151;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s called with null domain", buf, 0xCu);
      }
    }
    else if (v58)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v48 = type;
      BOOL v49 = os_log_type_enabled(v41, type);
      if (backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446466;
          char v61 = "nw_activity_get_sampling_rate_for_domain";
          __int16 v62 = 2082;
          *(void *)v63 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v41, v48, "%{public}s called with null domain, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_151:
        if (!v40) {
          return;
        }
        goto LABEL_152;
      }
      if (v49)
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v48, "%{public}s called with null domain, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v55 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v55, "%{public}s called with null domain, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_150:

    goto LABEL_151;
  }
  if (!a2)
  {
    v43 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v61 = "nw_activity_get_sampling_rate_for_domain";
    v40 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (!__nwlog_fault(v40, &type, &v58)) {
      goto LABEL_151;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v44, "%{public}s called with null out_sampling_rate_numerator", buf, 0xCu);
      }
      goto LABEL_150;
    }
    if (!v58)
    {
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v56 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v56, "%{public}s called with null out_sampling_rate_numerator, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_150;
    }
    BOOL v50 = (char *)__nw_create_backtrace_string();
    os_log_type_t v41 = __nwlog_obj();
    os_log_type_t v51 = type;
    BOOL v52 = os_log_type_enabled(v41, type);
    if (!v50)
    {
      if (v52)
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v51, "%{public}s called with null out_sampling_rate_numerator, no backtrace", buf, 0xCu);
      }
      goto LABEL_150;
    }
    if (v52)
    {
      *(_DWORD *)buf = 136446466;
      char v61 = "nw_activity_get_sampling_rate_for_domain";
      __int16 v62 = 2082;
      *(void *)v63 = v50;
      _os_log_impl(&dword_1830D4000, v41, v51, "%{public}s called with null out_sampling_rate_numerator, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_131;
  }
  if (!a3)
  {
    os_log_type_t v45 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v61 = "nw_activity_get_sampling_rate_for_domain";
    v40 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v58 = 0;
    if (!__nwlog_fault(v40, &type, &v58)) {
      goto LABEL_151;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v46, "%{public}s called with null out_sampling_rate_denominator", buf, 0xCu);
      }
      goto LABEL_150;
    }
    if (!v58)
    {
      os_log_type_t v41 = __nwlog_obj();
      os_log_type_t v57 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v57, "%{public}s called with null out_sampling_rate_denominator, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_150;
    }
    BOOL v50 = (char *)__nw_create_backtrace_string();
    os_log_type_t v41 = __nwlog_obj();
    os_log_type_t v53 = type;
    BOOL v54 = os_log_type_enabled(v41, type);
    if (!v50)
    {
      if (v54)
      {
        *(_DWORD *)buf = 136446210;
        char v61 = "nw_activity_get_sampling_rate_for_domain";
        _os_log_impl(&dword_1830D4000, v41, v53, "%{public}s called with null out_sampling_rate_denominator, no backtrace", buf, 0xCu);
      }
      goto LABEL_150;
    }
    if (v54)
    {
      *(_DWORD *)buf = 136446466;
      char v61 = "nw_activity_get_sampling_rate_for_domain";
      __int16 v62 = 2082;
      *(void *)v63 = v50;
      _os_log_impl(&dword_1830D4000, v41, v53, "%{public}s called with null out_sampling_rate_denominator, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_131:

    free(v50);
    if (!v40) {
      return;
    }
LABEL_152:
    free(v40);
    return;
  }
  unsigned int v6 = a1 - 11;
  if (a1 - 11 > 0x32)
  {
    unsigned int v8 = 0;
    unsigned int v7 = 0;
  }
  else
  {
    unsigned int v7 = dword_183E22518[v6];
    unsigned int v8 = 1;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  int v9 = (id)gactivityLogObj;
  if (os_log_type_enabled(v9, OS_LOG_TYPE_DEBUG))
  {
    if (v6 >= 0x33)
    {
      if (a1 - 900 >= 0x64)
      {
        uint32_t v10 = "invalid";
        if (a1 < 0xB) {
          uint32_t v10 = "reserved";
        }
      }
      else
      {
        uint32_t v10 = "experimental";
      }
    }
    else
    {
      uint32_t v10 = off_1E5244D38[v6];
    }
    *(_DWORD *)buf = 136315650;
    char v61 = v10;
    __int16 v62 = 1024;
    *(_DWORD *)v63 = v8;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = v7;
    _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_DEBUG, "Domain %s rate configured in registry as %u / %u", buf, 0x18u);
  }

  unsigned int int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_activity_default_numerator, v8);
  unsigned int v12 = networkd_settings_get_int64_with_default((const char *)nw_setting_activity_default_denominator, v7);
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  char v13 = (id)gactivityLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
  {
    if (v6 >= 0x33)
    {
      if (a1 - 900 >= 0x64)
      {
        __int16 v14 = "invalid";
        if (a1 < 0xB) {
          __int16 v14 = "reserved";
        }
      }
      else
      {
        __int16 v14 = "experimental";
      }
    }
    else
    {
      __int16 v14 = off_1E5244D38[v6];
    }
    *(_DWORD *)buf = 136315650;
    char v61 = v14;
    __int16 v62 = 1024;
    *(_DWORD *)v63 = int64_with_default;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = v12;
    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "Domain %s rate configured after remote default override as %u / %u", buf, 0x18u);
  }

  if (v6 < 0x33)
  {
    uint64_t v15 = v6;
    __int16 v16 = (const char **)off_1E5244BA0[v15];
    unsigned int int64_with_default = networkd_settings_get_int64_with_default(*(const char **)off_1E5244A08[v15], int64_with_default);
    unsigned int v12 = networkd_settings_get_int64_with_default(*v16, v12);
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  __uint64_t v17 = (id)gactivityLogObj;
  if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
  {
    if (v6 >= 0x33)
    {
      if (a1 - 900 >= 0x64)
      {
        __int16 v18 = "invalid";
        if (a1 < 0xB) {
          __int16 v18 = "reserved";
        }
      }
      else
      {
        __int16 v18 = "experimental";
      }
    }
    else
    {
      __int16 v18 = off_1E5244D38[v6];
    }
    *(_DWORD *)buf = 136315650;
    char v61 = v18;
    __int16 v62 = 1024;
    *(_DWORD *)v63 = int64_with_default;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = v12;
    _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "After reading settings plist, domain %s rate configured as %u / %u", buf, 0x18u);
  }

  unsigned int v19 = a1 - 900;
  if (a1 - 900 >= 0x64 && v6 >= 0x33)
  {
    if (__nwlog_activity_log::onceToken != -1) {
      dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
    }
    BOOL v21 = (id)gactivityLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
    {
      BOOL v22 = "invalid";
      *(_DWORD *)buf = 136315906;
      if (a1 < 0xB) {
        BOOL v22 = "reserved";
      }
      char v61 = v22;
      __int16 v62 = 1024;
      *(_DWORD *)v63 = a1;
      *(_WORD *)&v63[4] = 1024;
      *(_DWORD *)&v63[6] = 0;
      __int16 v64 = 1024;
      int v65 = 0;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_INFO, "Invalid domain (%s: %u) sampled at %u / %u", buf, 0x1Eu);
    }

    unsigned int int64_with_default = 0;
    unsigned int v12 = 0;
  }
  char v23 = (const char *)nw_setting_activity_report_numerator;
  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    os_log_type_t v24 = a2;
    if (sCachedSettings) {
      unsigned int int64 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v23);
    }
    else {
      unsigned int int64 = 0;
    }
    id v26 = a3;
    pthread_mutex_unlock(&sSettingsMutex);
  }
  else
  {
    os_log_type_t v24 = a2;
    id v26 = a3;
    unsigned int int64 = 0;
  }
  __int16 v27 = (const char *)nw_setting_activity_report_denominator;
  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    if (sCachedSettings) {
      int v28 = xpc_dictionary_get_int64((xpc_object_t)sCachedSettings, v27);
    }
    else {
      int v28 = 0;
    }
    pthread_mutex_unlock(&sSettingsMutex);
  }
  else
  {
    int v28 = 0;
  }
  if (int64 <= 1) {
    int v29 = 1;
  }
  else {
    int v29 = int64;
  }
  if (v19 >= 0x64) {
    int v29 = int64;
  }
  if (v28) {
    BOOL v30 = 1;
  }
  else {
    BOOL v30 = v19 >= 0x64;
  }
  if (v30) {
    int v31 = v28;
  }
  else {
    int v31 = 20000;
  }
  BOOL v32 = v29 != 0;
  BOOL v33 = v31 != 0;
  if (v32 && v33) {
    int v34 = v29;
  }
  else {
    int v34 = int64_with_default;
  }
  if (v32 && v33) {
    unsigned int v12 = v31;
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  os_log_type_t v35 = (id)gactivityLogObj;
  if (os_log_type_enabled(v35, OS_LOG_TYPE_DEBUG))
  {
    if (v6 >= 0x33)
    {
      if (v19 >= 0x64)
      {
        BOOL v36 = "invalid";
        if (a1 < 0xB) {
          BOOL v36 = "reserved";
        }
      }
      else
      {
        BOOL v36 = "experimental";
      }
    }
    else
    {
      BOOL v36 = off_1E5244D38[v6];
    }
    *(_DWORD *)buf = 136315650;
    char v61 = v36;
    __int16 v62 = 1024;
    *(_DWORD *)v63 = v34;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = v12;
    _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_DEBUG, "After settings override, domain %s rate configured as %u / %u", buf, 0x18u);
  }

  if (nw_activity_should_use_elevated_sampling_rate(void)::onceToken != -1) {
    dispatch_once(&nw_activity_should_use_elevated_sampling_rate(void)::onceToken, &__block_literal_global_1209);
  }
  if (__nwlog_activity_log::onceToken != -1) {
    dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
  }
  os_log_type_t v37 = (id)gactivityLogObj;
  if (os_log_type_enabled(v37, OS_LOG_TYPE_DEBUG))
  {
    if (v6 >= 0x33)
    {
      if (v19 >= 0x64)
      {
        v38 = "invalid";
        if (a1 < 0xB) {
          v38 = "reserved";
        }
      }
      else
      {
        v38 = "experimental";
      }
    }
    else
    {
      v38 = off_1E5244D38[v6];
    }
    *(_DWORD *)buf = 136315650;
    char v61 = v38;
    __int16 v62 = 1024;
    *(_DWORD *)v63 = v34;
    *(_WORD *)&v63[4] = 1024;
    *(_DWORD *)&v63[6] = v12;
    _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_DEBUG, "Final domain %s rate configured as %u / %u", buf, 0x18u);
  }

  int *v24 = v34;
  *id v26 = v12;
}

void __nw_activity_set_global_parent_block_invoke()
{
  v0 = (void *)global_parent;
  global_parent = 0;
}

void __nw_queue_context_create_source_block_invoke(uint64_t a1)
{
  uint64_t v2 = *(void *)(a1 + 32);
  if (v2) {
    (*(void (**)(void))(v2 + 16))();
  }
  __uint64_t v3 = *(void ***)(a1 + 40);
  unint64_t v4 = *v3;
  *__uint64_t v3 = 0;

  free(v3);
}

void ___ZL34nw_socket_init_socket_event_sourceP9nw_socketj_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  char v3 = *(unsigned char *)(v2 + 48);
  if (v3)
  {
    unint64_t v4 = *(void **)(v2 + 40);
    if (v4)
    {
      os_release(v4);
      char v3 = *(unsigned char *)(v2 + 48);
    }
  }
  *(void *)(v2 + 40) = 0;
  *(unsigned char *)(v2 + 48) = v3 | 1;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v5)
  {
    if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(v5 + 88);
      if (v6)
      {
        uint64_t v7 = v6 - 1;
        *(void *)(v5 + 88) = v7;
        if (!v7)
        {
          unsigned int v8 = *(void (***)(void))(v5 + 64);
          if (v8)
          {
            *(void *)(v5 + 64) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if (*(unsigned char *)(v5 + 72))
          {
            int v9 = *(const void **)(v5 + 64);
            if (v9) {
              _Block_release(v9);
            }
          }
          free((void *)v5);
        }
      }
    }
  }
}

id *nw_flow_copy_write_request(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v3 = a1;
  uint64_t v102 = *MEMORY[0x1E4F143B8];
  id v4 = *(id *)(a1 + 160);
  v78 = v4;
  uint64_t v79 = v3;
  uint64_t v5 = *(void **)(v3 + 192);
  uint64_t v6 = *(void **)(v3 + 200);
  if (!v5) {
    goto LABEL_4;
  }
LABEL_2:
  if (!v6) {
    goto LABEL_7;
  }
  while (1)
  {
    uint64_t v7 = nw_write_request_copy_next_incomplete_request(v6, (*(_DWORD *)(a2 + 4) & 2) != 0, (*(unsigned __int16 *)(v3 + 332) >> 1) & 1, *(void **)(v3 + 224));
    if (!v7) {
      break;
    }
LABEL_8:
    unsigned int v8 = v7;
    id v82 = v8[8];
    v83 = v8;

    if (v82)
    {
      int v9 = (os_unfair_lock_s *)v82;
      uint32_t v10 = v9;
      if (a3)
      {
        if (v9 != (os_unfair_lock_s *)&__block_literal_global_10_42276
          && v9 != (os_unfair_lock_s *)&__block_literal_global_8_42267
          && v9 != (os_unfair_lock_s *)&__block_literal_global_6_42258
          && v9 != (os_unfair_lock_s *)&__block_literal_global_42249)
        {
          *a3 = 0;
          if ((v9[29]._os_unfair_lock_opaque & 0x10000) == 0)
          {
            os_unfair_lock_lock(v9 + 28);
            unint64_t v14 = *(void *)&v10[16]._os_unfair_lock_opaque;
            if (v14)
            {
              if ((v10[29]._os_unfair_lock_opaque & 0x20000) == 0)
              {
                BYTE2(v10[29]._os_unfair_lock_opaque) |= 2u;
                uint64_t v15 = *(void *)&v10[18]._os_unfair_lock_opaque;
                uint64_t v16 = mach_absolute_time();
                unint64_t v17 = nw_delta_nanos(v15, v16);
                unint64_t v18 = (v17 / 0xF4240);
                if (v17 > 0xF423FFFFFFFFFLL) {
                  unint64_t v18 = 0xFFFFFFFFLL;
                }
                unint64_t v14 = *(void *)&v10[16]._os_unfair_lock_opaque;
                if (v14 < v18)
                {
                  os_unfair_lock_unlock(v10 + 28);

                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v4);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v4);
                  if (minimize_logging)
                  {
                    if (logging_disabled)
                    {
LABEL_87:
                      int v28 = 60;
                      goto LABEL_55;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    BOOL v21 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v4);
                      v69 = nw_endpoint_handler_dry_run_string(v4);
                      nw_endpoint_t v70 = nw_endpoint_handler_copy_endpoint(v4);
                      logging_description = nw_endpoint_get_logging_description(v70);
                      v72 = nw_endpoint_handler_state_string(v4);
                      logb = nw_endpoint_handler_mode_string(v4);
                      id v73 = nw_endpoint_handler_copy_current_path(v4);
                      *(_DWORD *)buf = 136448002;
                      v87 = "nw_flow_copy_write_request";
                      __int16 v88 = 2082;
                      v89 = (void *)id_string;
                      __int16 v90 = 2082;
                      v91 = v69;
                      __int16 v92 = 2082;
                      v93 = logging_description;
                      __int16 v94 = 2082;
                      v95 = v72;
                      __int16 v96 = 2082;
                      v97 = logb;
                      __int16 v98 = 2114;
                      id v99 = v73;
                      __int16 v100 = 2112;
                      v101 = v10;
                      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ is expired, failing request", buf, 0x52u);
                    }
                  }
                  else
                  {
                    if (logging_disabled) {
                      goto LABEL_87;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    BOOL v21 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
                    {
                      BOOL v22 = nw_endpoint_handler_get_id_string(v4);
                      char v23 = nw_endpoint_handler_dry_run_string(v4);
                      nw_endpoint_t v24 = nw_endpoint_handler_copy_endpoint(v4);
                      v25 = nw_endpoint_get_logging_description(v24);
                      id v26 = nw_endpoint_handler_state_string(v4);
                      log = nw_endpoint_handler_mode_string(v4);
                      id v27 = nw_endpoint_handler_copy_current_path(v4);
                      *(_DWORD *)buf = 136448002;
                      v87 = "nw_flow_copy_write_request";
                      __int16 v88 = 2082;
                      v89 = (void *)v22;
                      __int16 v90 = 2082;
                      v91 = v23;
                      __int16 v92 = 2082;
                      v93 = v25;
                      __int16 v94 = 2082;
                      v95 = v26;
                      __int16 v96 = 2082;
                      v97 = log;
                      __int16 v98 = 2114;
                      id v99 = v27;
                      __int16 v100 = 2112;
                      v101 = v10;
                      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ is expired, failing request", buf, 0x52u);
                    }
                  }
                  int v28 = 60;
                  goto LABEL_54;
                }
              }
              uint64_t v29 = *(void *)&v10[18]._os_unfair_lock_opaque;
              uint64_t v30 = dword_1EB267624;
              if (!dword_1EB267624)
              {
                mach_timebase_info((mach_timebase_info_t)&time_base);
                uint64_t v30 = dword_1EB267624;
              }
              *a3 = 1000000 * v14 * v30 / time_base + v29;
            }
            os_unfair_lock_unlock(v10 + 28);
          }
        }
        goto LABEL_37;
      }
      BOOL v52 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v87 = "nw_content_context_is_expired";
      os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v84 = 0;
      if (__nwlog_fault(v53, &type, &v84))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v54 = __nwlog_obj();
          os_log_type_t v55 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_content_context_is_expired";
            _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s called with null expire_time", buf, 0xCu);
          }
          goto LABEL_62;
        }
        if (v84)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          __int16 v64 = __nwlog_obj();
          os_log_type_t v65 = type;
          BOOL v66 = os_log_type_enabled(v64, type);
          if (backtrace_string)
          {
            if (v66)
            {
              *(_DWORD *)buf = 136446466;
              v87 = "nw_content_context_is_expired";
              __int16 v88 = 2082;
              v89 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null expire_time, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
          }
          else
          {
            if (v66)
            {
              *(_DWORD *)buf = 136446210;
              v87 = "nw_content_context_is_expired";
              _os_log_impl(&dword_1830D4000, v64, v65, "%{public}s called with null expire_time, no backtrace", buf, 0xCu);
            }
          }
        }
        else
        {
          BOOL v54 = __nwlog_obj();
          os_log_type_t v67 = type;
          if (os_log_type_enabled(v54, type))
          {
            *(_DWORD *)buf = 136446210;
            v87 = "nw_content_context_is_expired";
            _os_log_impl(&dword_1830D4000, v54, v67, "%{public}s called with null expire_time, backtrace limit exceeded", buf, 0xCu);
          }
LABEL_62:
        }
      }
      if (v53) {
        free(v53);
      }
LABEL_37:

      id v31 = nw_content_context_copy_error(v10);
      if (v31)
      {
        int v32 = nw_endpoint_handler_get_minimize_logging(v4);
        char v33 = nw_endpoint_handler_get_logging_disabled(v4);
        if (v32)
        {
          if ((v33 & 1) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            int v34 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
            {
              os_log_type_t v56 = nw_endpoint_handler_get_id_string(v4);
              os_log_type_t v57 = nw_endpoint_handler_dry_run_string(v4);
              loga = v34;
              nw_endpoint_t v58 = nw_endpoint_handler_copy_endpoint(v4);
              os_log_type_t v59 = nw_endpoint_get_logging_description(v58);
              v60 = nw_endpoint_handler_state_string(v4);
              char v61 = nw_endpoint_handler_mode_string(v4);
              id v62 = nw_endpoint_handler_copy_current_path(v4);
              *(_DWORD *)buf = 136448002;
              v87 = "nw_flow_copy_write_request";
              __int16 v88 = 2082;
              v89 = (void *)v56;
              __int16 v90 = 2082;
              v91 = v57;
              __int16 v92 = 2082;
              v93 = v59;
              __int16 v94 = 2082;
              v95 = v60;
              __int16 v96 = 2082;
              v97 = v61;
              __int16 v98 = 2114;
              id v99 = v62;
              __int16 v100 = 2112;
              v101 = v10;
              int v34 = loga;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ has antecedent error, failing request", buf, 0x52u);
            }
LABEL_44:
          }
        }
        else if ((v33 & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          int v34 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v34, OS_LOG_TYPE_INFO))
          {
            os_log_type_t v35 = nw_endpoint_handler_get_id_string(v4);
            BOOL v36 = nw_endpoint_handler_dry_run_string(v4);
            os_log_type_t v37 = v34;
            nw_endpoint_t v38 = nw_endpoint_handler_copy_endpoint(v4);
            uint64_t v39 = nw_endpoint_get_logging_description(v38);
            v40 = nw_endpoint_handler_state_string(v4);
            os_log_type_t v41 = nw_endpoint_handler_mode_string(v4);
            id v42 = nw_endpoint_handler_copy_current_path(v78);
            *(_DWORD *)buf = 136448002;
            v87 = "nw_flow_copy_write_request";
            __int16 v88 = 2082;
            v89 = (void *)v35;
            __int16 v90 = 2082;
            v91 = v36;
            __int16 v92 = 2082;
            v93 = v39;
            __int16 v94 = 2082;
            v95 = v40;
            __int16 v96 = 2082;
            v97 = v41;
            id v4 = v78;
            __int16 v98 = 2114;
            id v99 = v42;
            __int16 v100 = 2112;
            v101 = v10;
            int v34 = v37;
            _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Send context %@ has antecedent error, failing request", buf, 0x52u);
          }
          goto LABEL_44;
        }
        nw_write_request_report_error_with_override(v83, 0, v31);

        goto LABEL_56;
      }
    }
    if ((*(unsigned char *)(a2 + 4) & 1) == 0) {
      goto LABEL_90;
    }
    v43 = v83;
    char v44 = *((unsigned char *)v43 + 128);

    if (v44)
    {
      v83 = v43;
LABEL_90:

      goto LABEL_91;
    }
    if (nw_endpoint_handler_get_logging_disabled(v4))
    {
      int v28 = 45;
      goto LABEL_55;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v21 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      os_log_type_t v45 = nw_endpoint_handler_get_id_string(v4);
      os_log_type_t v46 = nw_endpoint_handler_dry_run_string(v4);
      nw_endpoint_t v47 = nw_endpoint_handler_copy_endpoint(v4);
      os_log_type_t v48 = nw_endpoint_get_logging_description(v47);
      BOOL v49 = nw_endpoint_handler_state_string(v4);
      BOOL v50 = nw_endpoint_handler_mode_string(v4);
      id v51 = nw_endpoint_handler_copy_current_path(v78);
      *(_DWORD *)buf = 136447746;
      v87 = "nw_flow_copy_write_request";
      __int16 v88 = 2082;
      v89 = (void *)v45;
      __int16 v90 = 2082;
      v91 = v46;
      __int16 v92 = 2082;
      v93 = v48;
      __int16 v94 = 2082;
      v95 = v49;
      __int16 v96 = 2082;
      v97 = v50;
      id v4 = v78;
      __int16 v98 = 2114;
      id v99 = v51;
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Protocol does not support sending incomplete send content", buf, 0x48u);
    }
    int v28 = 45;
LABEL_54:

LABEL_55:
    nw_write_request_fail(v83, v28);
LABEL_56:

    uint64_t v3 = v79;
    uint64_t v5 = *(void **)(v79 + 192);
    uint64_t v6 = *(void **)(v79 + 200);
    if (v5) {
      goto LABEL_2;
    }
LABEL_4:
    if (!v6) {
      goto LABEL_88;
    }
  }
  uint64_t v5 = *(void **)(v3 + 192);
  if (!v5) {
    goto LABEL_88;
  }
LABEL_7:
  uint64_t v7 = nw_write_request_copy_next_incomplete_request(v5, (*(_DWORD *)(a2 + 4) & 2) != 0, (*(unsigned __int16 *)(v3 + 332) >> 1) & 1, *(void **)(v3 + 224));
  if (v7) {
    goto LABEL_8;
  }
LABEL_88:
  v83 = 0;
LABEL_91:

  return v83;
}

void sub_1831699C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,void *a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,void *a27)
{
  _Unwind_Resume(a1);
}

id *nw_write_request_copy_next_incomplete_request(void *a1, char a2, int a3, void *a4)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v7 = a1;
  id v8 = a4;
  if (!v7)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v22 = "nw_write_request_copy_next_incomplete_request";
    unsigned int v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null request", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v22 = "nw_write_request_copy_next_incomplete_request";
            __int16 v23 = 2082;
            nw_endpoint_t v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_39;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null request, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v22 = "nw_write_request_copy_next_incomplete_request";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_39:
    if (v12) {
      free(v12);
    }
    int v9 = 0;
    goto LABEL_15;
  }
  if (a3 && (a2 & 1) == 0)
  {
    while (((_BYTE)v7[16] & 2) != 0
         || !v7[7] && !v7[9]
         || nw_content_context_is_blocked_by_antecedents(v7[8])
         || v7[8] != v8)
    {
      int v9 = (id *)v7[1];

      uint64_t v7 = v9;
      if (!v9) {
        goto LABEL_14;
      }
    }
  }
  else
  {
    while (((_BYTE)v7[16] & 2) != 0 || !v7[7] && !v7[9] || nw_content_context_is_blocked_by_antecedents(v7[8]))
    {
      int v9 = (id *)v7[1];

      uint64_t v7 = v9;
      if (!v9) {
        goto LABEL_14;
      }
    }
  }
  if (v7[7] || v7[9])
  {
    uint64_t v7 = v7;
    int v9 = v7;
  }
  else
  {
    int v9 = 0;
  }
LABEL_14:

LABEL_15:
  return v9;
}

BOOL nw_content_context_is_blocked_by_antecedents(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = 0;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_10_42276
      && v1 != (os_unfair_lock_s *)&__block_literal_global_8_42267
      && v1 != (os_unfair_lock_s *)&__block_literal_global_6_42258
      && v1 != (os_unfair_lock_s *)&__block_literal_global_42249)
    {
      os_unfair_lock_lock(v1 + 28);
      uint64_t v4 = *(void *)&v2[14]._os_unfair_lock_opaque;
      if (v4) {
        BOOL v3 = (*(unsigned char *)(v4 + 118) & 4) == 0;
      }
      else {
        BOOL v3 = 0;
      }
      os_unfair_lock_unlock(v2 + 28);
    }
    goto LABEL_10;
  }
  uint64_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
          __int16 v18 = 2082;
          char v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_27;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v17 = "nw_content_context_is_blocked_by_antecedents";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_27:
  if (v7) {
    free(v7);
  }
  BOOL v3 = 0;
LABEL_10:

  return v3;
}

id nw_content_context_copy_error(void *a1)
{
  v1 = a1;
  uint64_t v2 = v1;
  if (v1 == (os_unfair_lock_s *)&__block_literal_global_10_42276
    || v1 == (os_unfair_lock_s *)&__block_literal_global_8_42267
    || v1 == (os_unfair_lock_s *)&__block_literal_global_6_42258
    || v1 == (os_unfair_lock_s *)&__block_literal_global_42249)
  {
    id v6 = 0;
  }
  else
  {
    os_unfair_lock_lock(v1 + 28);
    id v6 = *(id *)&v2[24]._os_unfair_lock_opaque;
    if (!v6)
    {
      if (*(void *)&v2[14]._os_unfair_lock_opaque) {
        id v6 = (id)nw_content_context_copy_error();
      }
      else {
        id v6 = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 28);
  }

  return v6;
}

void sub_18316A1A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nw_socket_setup_output_eventsP9nw_socket_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  char v3 = *(unsigned char *)(v2 + 48);
  if (v3)
  {
    uint64_t v4 = *(void **)(v2 + 40);
    if (v4)
    {
      os_release(v4);
      char v3 = *(unsigned char *)(v2 + 48);
    }
  }
  *(void *)(v2 + 40) = 0;
  *(unsigned char *)(v2 + 48) = v3 | 1;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v5)
  {
    if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(v5 + 88);
      if (v6)
      {
        uint64_t v7 = v6 - 1;
        *(void *)(v5 + 88) = v7;
        if (!v7)
        {
          id v8 = *(void (***)(void))(v5 + 64);
          if (v8)
          {
            *(void *)(v5 + 64) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if (*(unsigned char *)(v5 + 72))
          {
            os_log_type_t v9 = *(const void **)(v5 + 64);
            if (v9) {
              _Block_release(v9);
            }
          }
          free((void *)v5);
        }
      }
    }
  }
}

void ___ZL28nw_socket_setup_input_eventsP9nw_socket_block_invoke_2(uint64_t a1)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  char v3 = *(unsigned char *)(v2 + 48);
  if (v3)
  {
    uint64_t v4 = *(void **)(v2 + 40);
    if (v4)
    {
      os_release(v4);
      char v3 = *(unsigned char *)(v2 + 48);
    }
  }
  *(void *)(v2 + 40) = 0;
  *(unsigned char *)(v2 + 48) = v3 | 1;
  uint64_t v5 = *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24);
  if (v5)
  {
    if (*(_UNKNOWN **)(v5 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *(void *)(v5 + 88);
      if (v6)
      {
        uint64_t v7 = v6 - 1;
        *(void *)(v5 + 88) = v7;
        if (!v7)
        {
          id v8 = *(void (***)(void))(v5 + 64);
          if (v8)
          {
            *(void *)(v5 + 64) = 0;
            v8[2](v8);
            _Block_release(v8);
          }
          if (*(unsigned char *)(v5 + 72))
          {
            os_log_type_t v9 = *(const void **)(v5 + 64);
            if (v9) {
              _Block_release(v9);
            }
          }
          free((void *)v5);
        }
      }
    }
  }
}

void sub_18316A3B4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  uint32_t v10 = v9;
  a9.receiver = v10;
  a9.super_class = (Class)NWConcrete_nw_fd_wrapper;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void nw_fd_wrapper_close(void *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 3);
    int os_unfair_lock_opaque = v2[2]._os_unfair_lock_opaque;
    if ((v2[6]._os_unfair_lock_opaque & 1) == 0)
    {
      if (os_unfair_lock_opaque < 0)
      {
LABEL_20:
        os_unfair_lock_unlock(v2 + 3);
        goto LABEL_21;
      }
      close(os_unfair_lock_opaque);
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v4 = (id)gLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        id v31 = "nw_fd_wrapper_close";
        __int16 v32 = 2114;
        *(void *)char v33 = v2;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_DEBUG, "%{public}s closed %{public}@", buf, 0x16u);
      }

LABEL_19:
      v2[2]._int os_unfair_lock_opaque = -1;
      goto LABEL_20;
    }
    if (!guarded_close_np())
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v12 = (id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446466;
        id v31 = "nw_fd_wrapper_close";
        __int16 v32 = 2114;
        *(void *)char v33 = v2;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s closed %{public}@", buf, 0x16u);
      }

      goto LABEL_18;
    }
    int v5 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    uint32_t v7 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)buf = 136446722;
    id v31 = "nw_fd_wrapper_close";
    __int16 v32 = 1024;
    *(_DWORD *)char v33 = v7;
    *(_WORD *)&v33[4] = 1024;
    *(_DWORD *)&v33[6] = v5;
    id v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v8, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          uint32_t v11 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          id v31 = "nw_fd_wrapper_close";
          __int16 v32 = 1024;
          *(_DWORD *)char v33 = v11;
          *(_WORD *)&v33[4] = 1024;
          *(_DWORD *)&v33[6] = v5;
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s Failed to close guarded fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v15)
          {
            uint32_t v16 = v2[2]._os_unfair_lock_opaque;
            *(_DWORD *)buf = 136446978;
            id v31 = "nw_fd_wrapper_close";
            __int16 v32 = 1024;
            *(_DWORD *)char v33 = v16;
            *(_WORD *)&v33[4] = 1024;
            *(_DWORD *)&v33[6] = v5;
            __int16 v34 = 2082;
            os_log_type_t v35 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s Failed to close guarded fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(backtrace_string);
          if (!v8) {
            goto LABEL_18;
          }
          goto LABEL_14;
        }
        if (v15)
        {
          uint32_t v19 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          id v31 = "nw_fd_wrapper_close";
          __int16 v32 = 1024;
          *(_DWORD *)char v33 = v19;
          *(_WORD *)&v33[4] = 1024;
          *(_DWORD *)&v33[6] = v5;
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s Failed to close guarded fd %d %{darwin.errno}d, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v9 = (id)gLogObj;
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v9, type))
        {
          uint32_t v18 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)buf = 136446722;
          id v31 = "nw_fd_wrapper_close";
          __int16 v32 = 1024;
          *(_DWORD *)char v33 = v18;
          *(_WORD *)&v33[4] = 1024;
          *(_DWORD *)&v33[6] = v5;
          _os_log_impl(&dword_1830D4000, v9, v17, "%{public}s Failed to close guarded fd %d %{darwin.errno}d, backtrace limit exceeded", buf, 0x18u);
        }
      }
    }
    if (!v8)
    {
LABEL_18:
      LOBYTE(v2[6]._os_unfair_lock_opaque) &= ~1u;
      goto LABEL_19;
    }
LABEL_14:
    free(v8);
    goto LABEL_18;
  }
  uint64_t v20 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v31 = "nw_fd_wrapper_close";
  BOOL v21 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v21, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        id v31 = "nw_fd_wrapper_close";
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null wrapper", buf, 0xCu);
      }
    }
    else if (v28)
    {
      nw_endpoint_t v24 = (char *)__nw_create_backtrace_string();
      BOOL v22 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v22, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          id v31 = "nw_fd_wrapper_close";
          __int16 v32 = 2082;
          *(void *)char v33 = v24;
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        goto LABEL_50;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        id v31 = "nw_fd_wrapper_close";
        _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v22, type))
      {
        *(_DWORD *)buf = 136446210;
        id v31 = "nw_fd_wrapper_close";
        _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_50:
  if (v21) {
    free(v21);
  }
LABEL_21:
}

void sub_18316AAD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL29nw_resolver_start_query_timerP22NWConcrete_nw_resolver_block_invoke_180(uint64_t a1)
{
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 12));
  uint64_t v2 = *(void *)(a1 + 32);
  if (!*(void *)(v2 + 96))
  {
    nw_resolver_cancel_query_locked((NWConcrete_nw_resolver *)v2, 0);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  char v3 = (os_unfair_lock_s *)(v2 + 12);

  os_unfair_lock_unlock(v3);
}

uint64_t nw_settings_get_flow_report_numerator()
{
  v0 = (const char *)nw_setting_flow_report_numerator;
  networkd_settings_init();
  if (!sCachedSettings) {
    return 1;
  }
  pthread_mutex_lock(&sSettingsMutex);
  v1 = (void *)sCachedSettings;
  if (!sCachedSettings) {
    goto LABEL_7;
  }
  Class Class = object_getClass((id)sCachedSettings);
  int64_t v3 = 1;
  if (!v0 || Class != (Class)MEMORY[0x1E4F14590]) {
    goto LABEL_8;
  }
  xpc_object_t value = xpc_dictionary_get_value(v1, v0);
  if (value && (int v5 = value, object_getClass(value) == (Class)MEMORY[0x1E4F145C0])) {
    int64_t v3 = xpc_int64_get_value(v5);
  }
  else {
LABEL_7:
  }
    int64_t v3 = 1;
LABEL_8:
  pthread_mutex_unlock(&sSettingsMutex);
  return v3;
}

uint64_t ___ZL18nw_path_update_dnsP18NWConcrete_nw_path_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  int v5 = v4;
  size_t length = 0;
  if (v4)
  {
    data = (unsigned int *)xpc_dictionary_get_data(v4, "data", &length);
    uint32_t v7 = 0;
    if (data && length >= 0xD8)
    {
      if (length == data[53] + 216) {
        uint32_t v7 = data;
      }
      else {
        uint32_t v7 = 0;
      }
    }
  }
  else
  {
    uint32_t v7 = 0;
  }
  if (is_config_agent_type_dns())
  {
    id v8 = config_agent_copy_dns_information();
    os_log_type_t v9 = v8;
    if (v8)
    {
      os_log_type_t v10 = nw_resolver_config_create_with_dictionary(v8);
      if (v10)
      {
        uunsigned int int64 = xpc_dictionary_get_uint64(v5, "generation");
        BOOL v12 = v10;
        v12->generation = uint64;

        os_log_type_t v13 = v12;
        *(_OWORD *)v13->identifier = *v7;

        nw_resolver_config_set_provider_description(v13, (uint64_t)(v7 + 5));
        uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 184);
        if (!v14)
        {
          BOOL v15 = nw_array_create();
          uint64_t v16 = *(void *)(a1 + 32);
          os_log_type_t v17 = *(void **)(v16 + 184);
          *(void *)(v16 + 184) = v15;

          uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 184);
        }
        nw_array_append(v14, v13);
      }
      config_agent_free_dns_information();
    }
  }

  return 1;
}

void sub_18316AD98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_resolver_config_set_provider_description(void *a1, uint64_t a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_resolver_config_set_provider_description_block_invoke;
    v14[3] = &unk_1E52491B0;
    BOOL v15 = (os_unfair_lock_s *)v3;
    uint64_t v16 = a2;
    int v5 = v15 + 22;
    os_unfair_lock_lock(v15 + 22);
    __nw_resolver_config_set_provider_description_block_invoke((uint64_t)v14);
    os_unfair_lock_unlock(v5);

    goto LABEL_3;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v20 = "nw_resolver_config_set_provider_description";
  uint32_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v18 = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v7, &v18, &v17))
  {
    if (v18 == OS_LOG_TYPE_FAULT)
    {
      id v8 = __nwlog_obj();
      os_log_type_t v9 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null config", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v8 = __nwlog_obj();
      os_log_type_t v11 = v18;
      BOOL v12 = os_log_type_enabled(v8, v18);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v20 = "nw_resolver_config_set_provider_description";
          __int16 v21 = 2082;
          BOOL v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null config, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null config, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v8 = __nwlog_obj();
      os_log_type_t v13 = v18;
      if (os_log_type_enabled(v8, v18))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v20 = "nw_resolver_config_set_provider_description";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null config, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:
}

void sub_18316B0CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_resolver_config *nw_resolver_config_create_with_dictionary(void *a1)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    __int16 v21 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_resolver_config_create_with_dictionary";
    BOOL v22 = (char *)_os_log_send_and_compose_impl();

    v36[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, v36, &type)) {
      goto LABEL_62;
    }
    if (v36[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v24 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null dictionary", buf, 0xCu);
      }
    }
    else if (type)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v28 = v36[0];
      BOOL v29 = os_log_type_enabled(v23, v36[0]);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_resolver_config_create_with_dictionary";
          __int16 v41 = 2082;
          id v42 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null dictionary, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v22) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null dictionary, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v33 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_1830D4000, v23, v33, "%{public}s called with null dictionary, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_61;
  }
  if (object_getClass(v1) != (Class)MEMORY[0x1E4F14590])
  {
    os_log_type_t v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v40 = "nw_resolver_config_create_with_dictionary";
    BOOL v22 = (char *)_os_log_send_and_compose_impl();

    v36[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v22, v36, &type)) {
      goto LABEL_62;
    }
    if (v36[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v26 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary))", buf, 0xCu);
      }
    }
    else if (type)
    {
      uint64_t v30 = (char *)__nw_create_backtrace_string();
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v31 = v36[0];
      BOOL v32 = os_log_type_enabled(v23, v36[0]);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          v40 = "nw_resolver_config_create_with_dictionary";
          __int16 v41 = 2082;
          id v42 = v30;
          _os_log_impl(&dword_1830D4000, v23, v31, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v30);
LABEL_62:
        if (!v22)
        {
LABEL_64:
          id v3 = 0;
          goto LABEL_28;
        }
LABEL_63:
        free(v22);
        goto LABEL_64;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_1830D4000, v23, v31, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v23 = __nwlog_obj();
      os_log_type_t v34 = v36[0];
      if (os_log_type_enabled(v23, v36[0]))
      {
        *(_DWORD *)buf = 136446210;
        v40 = "nw_resolver_config_create_with_dictionary";
        _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null (xpc_get_type(dictionary) == (&_xpc_type_dictionary)), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_61:

    goto LABEL_62;
  }
  id v3 = objc_alloc_init(NWConcrete_nw_resolver_config);
  *(void *)uint64_t v36 = v3;
  char v37 = -1;
  if (v3)
  {
    id v4 = v2;
    int v5 = v3;
    id v6 = v5;
    m_obj = v5->dictionary.m_obj;
    if ((*((unsigned char *)&v5->dictionary + 8) & 1) != 0 && m_obj)
    {
      v5->dictionary.m_obj = 0;

      m_obj = v6->dictionary.m_obj;
    }
    v6->dictionary.m_obj = 0;

    id v8 = v6->dictionary.m_obj;
    v6->dictionary.m_obj = v4;

    *((unsigned char *)&v6->dictionary + 8) |= 1u;
    os_log_type_t v9 = v6->dictionary.m_obj;
    os_log_type_t v10 = v6;
    string = xpc_dictionary_get_string(v9, "Identifier");

    if (string) {
      uuid_parse(string, v10 + 24);
    }
    goto LABEL_28;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v12 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v40 = "nw_resolver_config_create_with_dictionary";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v35 = 0;
  if (!__nwlog_fault(v13, &type, &v35)) {
    goto LABEL_26;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    os_log_type_t v15 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_resolver_config_create_with_dictionary";
      _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s [nw_resolver_config init] failed", buf, 0xCu);
    }
LABEL_25:

LABEL_26:
    if (!v13) {
      goto LABEL_28;
    }
LABEL_27:
    free(v13);
    goto LABEL_28;
  }
  if (!v35)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v14 = (id)gLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v14, type))
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_resolver_config_create_with_dictionary";
      _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s [nw_resolver_config init] failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_25;
  }
  uint64_t v16 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v14 = (id)gLogObj;
  os_log_type_t v17 = type;
  BOOL v18 = os_log_type_enabled(v14, type);
  if (!v16)
  {
    if (v18)
    {
      *(_DWORD *)buf = 136446210;
      v40 = "nw_resolver_config_create_with_dictionary";
      _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s [nw_resolver_config init] failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_25;
  }
  if (v18)
  {
    *(_DWORD *)buf = 136446466;
    v40 = "nw_resolver_config_create_with_dictionary";
    __int16 v41 = 2082;
    id v42 = v16;
    _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s [nw_resolver_config init] failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v16);
  if (v13) {
    goto LABEL_27;
  }
LABEL_28:

  return v3;
}

void sub_18316B8C0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, ...)
{
  va_start(va, a6);
  nw::retained_ptr<void({block_pointer} {__strong})(void)>::~retained_ptr((uint64_t)va);

  _Unwind_Resume(a1);
}

void __nw_resolver_config_set_provider_description_block_invoke(uint64_t a1)
{
}

void nw_protocol_output_available_quiet(uint64_t a1, uint64_t a2)
{
  if (a1)
  {
    uint64_t v3 = *(void *)(a1 + 24);
    if (v3)
    {
      if (a2)
      {
        int v5 = *(void (**)(uint64_t, uint64_t))(v3 + 72);
        if (v5)
        {
          id v6 = *(void **)(a1 + 40);
          if (v6 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v7 = *(void *)(a1 + 88);
            if (v7) {
              *(void *)(a1 + 88) = v7 + 1;
            }
          }
          if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v8 = *(void *)(a2 + 88);
            if (v8) {
              *(void *)(a2 + 88) = v8 + 1;
            }
            v5(a1, a2);
            if (*(_UNKNOWN **)(a2 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v9 = *(void *)(a2 + 88);
              if (v9)
              {
                uint64_t v10 = v9 - 1;
                *(void *)(a2 + 88) = v10;
                if (!v10)
                {
                  os_log_type_t v11 = *(void (***)(void))(a2 + 64);
                  if (v11)
                  {
                    *(void *)(a2 + 64) = 0;
                    v11[2](v11);
                    _Block_release(v11);
                  }
                  if (*(unsigned char *)(a2 + 72))
                  {
                    id v12 = *(const void **)(a2 + 64);
                    if (v12) {
                      _Block_release(v12);
                    }
                  }
                  free((void *)a2);
                }
              }
            }
          }
          else
          {
            v5(a1, a2);
          }
          if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v13 = *(void *)(a1 + 88);
            if (v13)
            {
              uint64_t v14 = v13 - 1;
              *(void *)(a1 + 88) = v14;
              if (!v14)
              {
                os_log_type_t v15 = *(void (***)(void))(a1 + 64);
                if (v15)
                {
                  *(void *)(a1 + 64) = 0;
                  v15[2](v15);
                  _Block_release(v15);
                }
                if (*(unsigned char *)(a1 + 72))
                {
                  uint64_t v16 = *(const void **)(a1 + 64);
                  if (v16) {
                    _Block_release(v16);
                  }
                }
                free((void *)a1);
              }
            }
          }
        }
      }
    }
  }
}

uint64_t ___ZL37nw_data_transfer_report_collect_innerP34NWConcrete_nw_data_transfer_reportPU28objcproto17OS_dispatch_queue8NSObjectU13block_pointerFvS0_Eb_block_invoke_237(uint64_t a1)
{
  return (*(uint64_t (**)(void, void))(*(void *)(a1 + 40) + 16))(*(void *)(a1 + 40), *(void *)(a1 + 32));
}

void __nw_protocol_transform_contains_protocol_block_invoke(uint64_t a1, void *a2)
{
  uint64_t v3 = a2;
  id v4 = v3;
  if (*(unsigned char *)(a1 + 48))
  {
    if (!nw_protocol_options_is_quic(v3)) {
      goto LABEL_4;
    }
    goto LABEL_3;
  }
  if (nw_protocol_options_matches_definition(v3, *(void **)(a1 + 32))) {
LABEL_3:
  }
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
LABEL_4:
}

void sub_18316BDD4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL34nw_endpoint_transform_add_childrenP30NWConcrete_nw_endpoint_handler_block_invoke_97(uint64_t a1, void *a2, void *a3)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  id v6 = a2;
  id v7 = a3;
  if (v7
    && !*(void *)(*(void *)(*(void *)(a1 + 56) + 8) + 40)
    && nw_protocol_transform_contains_protocol(*(void **)(a1 + 32), v7))
  {
    if (v6 == &__block_literal_global_6268)
    {
      *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24) = 1;
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        BOOL v18 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          uint64_t v20 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          __int16 v21 = id_string;
          nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          logging_description = nw_endpoint_get_logging_description(v32);
          uint64_t v23 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          os_log_type_t v24 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          id v25 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          *(_DWORD *)buf = 136448002;
          os_log_type_t v34 = "nw_endpoint_transform_add_children_block_invoke";
          __int16 v35 = 2082;
          uint64_t v36 = v21;
          __int16 v37 = 2082;
          nw_endpoint_t v38 = v20;
          __int16 v39 = 2082;
          v40 = logging_description;
          __int16 v41 = 2082;
          id v42 = v23;
          __int16 v43 = 2082;
          char v44 = v24;
          __int16 v45 = 2114;
          id v46 = v25;
          __int16 v47 = 2112;
          id v48 = v7;
          _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Transform including protocol %@ cannot be used, unknown endpoint", buf, 0x52u);
        }
      }
      uint64_t v26 = *(void *)(a1 + 48);
      uint64_t v16 = a1 + 48;
      uint64_t v27 = *(void *)(v26 + 32);
      if (!v27)
      {
        BOOL v28 = nw_array_create();
        BOOL v29 = *(void **)(*(void *)v16 + 32);
        *(void *)(*(void *)v16 + 32) = v28;

        uint64_t v27 = *(void *)(*(void *)v16 + 32);
      }
      nw_array_append(v27, v7);
      char v17 = 0;
    }
    else
    {
      objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 56) + 8) + 40), a2);
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v8 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v8, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v9 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          uint64_t v10 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          os_log_type_t v11 = v9;
          nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          id v12 = nw_endpoint_get_logging_description(v31);
          uint64_t v13 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          uint64_t v14 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          id v15 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          *(_DWORD *)buf = 136448258;
          os_log_type_t v34 = "nw_endpoint_transform_add_children_block_invoke";
          __int16 v35 = 2082;
          uint64_t v36 = v11;
          __int16 v37 = 2082;
          nw_endpoint_t v38 = v10;
          __int16 v39 = 2082;
          v40 = v12;
          __int16 v41 = 2082;
          id v42 = v13;
          __int16 v43 = 2082;
          char v44 = v14;
          __int16 v45 = 2114;
          id v46 = v15;
          __int16 v47 = 2112;
          id v48 = v7;
          __int16 v49 = 2112;
          id v50 = v6;
          _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Transform including protocol %@ using endpoint %@", buf, 0x5Cu);
        }
      }
      uint64_t v16 = a1 + 48;
      char v17 = 1;
    }
    *(unsigned char *)(*(void *)v16 + 95) = v17;
  }

  return 1;
}

void sub_18316C190(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_transform_contains_protocol(void *a1, void *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    BOOL v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v19, &type, &v37)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null transform", buf, 0xCu);
      }
    }
    else if (v37)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null transform, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_67:
        if (!v19) {
          goto LABEL_69;
        }
LABEL_68:
        free(v19);
        goto LABEL_69;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null transform, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null transform, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_66:

    goto LABEL_67;
  }
  if (!v4)
  {
    BOOL v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v19, &type, &v37)) {
      goto LABEL_67;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v37)
    {
      uint64_t v27 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v29 = os_log_type_enabled(v20, type);
      if (v27)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v27;
          _os_log_impl(&dword_1830D4000, v20, v28, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v27);
        if (!v19) {
          goto LABEL_69;
        }
        goto LABEL_68;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_1830D4000, v20, v28, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_transform_contains_protocol";
        _os_log_impl(&dword_1830D4000, v20, v31, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_66;
  }
  if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
  }
  id v6 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
  if (nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v6))
  {
    BOOL is_equal_unsafe = 1;
  }
  else
  {
    if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55981);
    }
    id v8 = (id)nw_protocol_copy_quic_connection_definition::quic_definition;
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v8);
  }
  uint64_t v9 = v3[7];
  if (!v9) {
    goto LABEL_69;
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  char v40 = 0;
  iterate_block[0] = MEMORY[0x1E4F143A8];
  iterate_block[1] = 3221225472;
  iterate_block[2] = __nw_protocol_transform_contains_protocol_block_invoke;
  iterate_block[3] = &unk_1E5246EB0;
  BOOL v36 = is_equal_unsafe;
  __int16 v35 = buf;
  id v10 = v5;
  id v34 = v10;
  nw_protocol_stack_iterate_application_protocols(v9, iterate_block);
  if (*(unsigned char *)(*(void *)&buf[8] + 24))
  {
    int v11 = 1;
    goto LABEL_32;
  }
  nw_protocol_options_t v12 = nw_protocol_stack_copy_transport_protocol(v3[7]);
  nw_protocol_options_t v13 = v12;
  if (!v12)
  {
    nw_protocol_options_t v14 = nw_protocol_stack_copy_internet_protocol(v3[7]);
    if (!v14) {
      goto LABEL_29;
    }
    if (is_equal_unsafe) {
      goto LABEL_21;
    }
    goto LABEL_26;
  }
  if (!is_equal_unsafe)
  {
    if (nw_protocol_options_matches_definition(v12, v10)) {
      goto LABEL_24;
    }
    nw_protocol_options_t v14 = nw_protocol_stack_copy_internet_protocol(v3[7]);
    if (!v14) {
      goto LABEL_29;
    }
LABEL_26:
    if (nw_protocol_options_matches_definition(v14, v10)) {
      goto LABEL_27;
    }
    goto LABEL_29;
  }
  nw_protocol_options_t v14 = v12;
  if (nw_protocol_options_is_quic_connection(v14))
  {
LABEL_27:
    int v11 = 1;
LABEL_30:

    goto LABEL_31;
  }
  BOOL is_quic_stream = nw_protocol_options_is_quic_stream(v14);

  if (!is_quic_stream)
  {
    nw_protocol_options_t v14 = nw_protocol_stack_copy_internet_protocol(v3[7]);
    if (!v14) {
      goto LABEL_29;
    }
LABEL_21:
    nw_protocol_options_t v14 = v14;
    if (nw_protocol_options_is_quic_connection(v14))
    {

      goto LABEL_27;
    }
    BOOL v16 = nw_protocol_options_is_quic_stream(v14);

    if (v16) {
      goto LABEL_27;
    }
LABEL_29:
    int v11 = 0;
    goto LABEL_30;
  }
LABEL_24:
  int v11 = 1;
LABEL_31:

LABEL_32:
  _Block_object_dispose(buf, 8);
  if (!v11)
  {
LABEL_69:
    uint64_t v17 = 0;
    goto LABEL_70;
  }
  uint64_t v17 = 1;
LABEL_70:

  return v17;
}

void sub_18316C8B0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, void *a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va, a13);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_quic(nw_protocol_options_t options)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = options;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = nw_protocol_options_is_quic_connection(v1) || nw_protocol_options_is_quic_stream(v2);
    goto LABEL_5;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_protocol_options_is_quic";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_options_is_quic";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_protocol_options_is_quic";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_options_is_quic";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_protocol_options_is_quic";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_5:

  return v3;
}

void sub_18316CBD4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_quic_connection(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (id *)v1;
    id v4 = v3[1];

    if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55981);
    }
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_quic_connection_definition::quic_definition);

    goto LABEL_5;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_protocol_options_is_quic_connection";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_options_is_quic_connection";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_protocol_options_is_quic_connection";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_options_is_quic_connection";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_options_is_quic_connection";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  BOOL is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18316CECC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_options_is_quic_stream(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    BOOL v3 = (id *)v1;
    id v4 = v3[1];

    if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
    }
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_quic_stream_definition::quic_definition);

    goto LABEL_5;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v18 = "nw_protocol_options_is_quic_stream";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_options_is_quic_stream";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v18 = "nw_protocol_options_is_quic_stream";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_options_is_quic_stream";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v18 = "nw_protocol_options_is_quic_stream";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  BOOL is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_18316D1CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_socket_add_input_handler(nw_protocol *a1, nw_protocol_identifier *a2)
{
  uint64_t v72 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_socket_add_input_handler";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (!__nwlog_fault(v57, type, &v66)) {
      goto LABEL_156;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v58 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (!os_log_type_enabled(v58, type[0])) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null protocol";
      goto LABEL_155;
    }
    if (!v66)
    {
      nw_endpoint_t v58 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (!os_log_type_enabled(v58, type[0])) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_155;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v58 = __nwlog_obj();
    os_log_type_t v59 = type[0];
    BOOL v62 = os_log_type_enabled(v58, type[0]);
    if (!backtrace_string)
    {
      if (!v62) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_155;
    }
    if (!v62) {
      goto LABEL_142;
    }
    *(_DWORD *)buf = 136446466;
    v69 = "nw_socket_add_input_handler";
    __int16 v70 = 2082;
    v71 = backtrace_string;
    v63 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_141:
    _os_log_impl(&dword_1830D4000, v58, v59, v63, buf, 0x16u);
    goto LABEL_142;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_socket_add_input_handler";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (!__nwlog_fault(v57, type, &v66)) {
      goto LABEL_156;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v58 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (!os_log_type_enabled(v58, type[0])) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null socket_handler";
      goto LABEL_155;
    }
    if (!v66)
    {
      nw_endpoint_t v58 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (!os_log_type_enabled(v58, type[0])) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      goto LABEL_155;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v58 = __nwlog_obj();
    os_log_type_t v59 = type[0];
    BOOL v64 = os_log_type_enabled(v58, type[0]);
    if (!backtrace_string)
    {
      if (!v64) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null socket_handler, no backtrace";
      goto LABEL_155;
    }
    if (!v64) {
      goto LABEL_142;
    }
    *(_DWORD *)buf = 136446466;
    v69 = "nw_socket_add_input_handler";
    __int16 v70 = 2082;
    v71 = backtrace_string;
    v63 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
    goto LABEL_141;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v69 = "nw_socket_add_input_handler";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (!__nwlog_fault(v57, type, &v66)) {
      goto LABEL_156;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v58 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (!os_log_type_enabled(v58, type[0])) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null input_protocol";
      goto LABEL_155;
    }
    if (!v66)
    {
      nw_endpoint_t v58 = __nwlog_obj();
      os_log_type_t v59 = type[0];
      if (!os_log_type_enabled(v58, type[0])) {
        goto LABEL_156;
      }
      *(_DWORD *)buf = 136446210;
      v69 = "nw_socket_add_input_handler";
      v60 = "%{public}s called with null input_protocol, backtrace limit exceeded";
      goto LABEL_155;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_endpoint_t v58 = __nwlog_obj();
    os_log_type_t v59 = type[0];
    BOOL v65 = os_log_type_enabled(v58, type[0]);
    if (backtrace_string)
    {
      if (v65)
      {
        *(_DWORD *)buf = 136446466;
        v69 = "nw_socket_add_input_handler";
        __int16 v70 = 2082;
        v71 = backtrace_string;
        v63 = "%{public}s called with null input_protocol, dumping backtrace:%{public}s";
        goto LABEL_141;
      }
LABEL_142:
      free(backtrace_string);
      goto LABEL_156;
    }
    if (!v65) {
      goto LABEL_156;
    }
    *(_DWORD *)buf = 136446210;
    v69 = "nw_socket_add_input_handler";
    v60 = "%{public}s called with null input_protocol, no backtrace";
LABEL_155:
    _os_log_impl(&dword_1830D4000, v58, v59, v60, buf, 0xCu);
LABEL_156:
    if (v57) {
      free(v57);
    }
    return 0;
  }
  id v4 = *(nw_protocol_callbacks **)&a2->name[24];
  if (v4)
  {
    supports_external_data = (uint64_t (*)(nw_protocol_identifier *))v4->supports_external_data;
    if (!supports_external_data) {
      goto LABEL_160;
    }
    if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
    {
      id v7 = *(nw_protocol_callbacks **)&a2[2].name[8];
      if (v7) {
        *(void *)&a2[2].name[8] = (char *)&v7->add_input_handler + 1;
      }
      int v6 = supports_external_data(a2);
      if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
      {
        __int16 v45 = *(nw_protocol_callbacks **)&a2[2].name[8];
        if (v45)
        {
          id v46 = (nw_protocol_callbacks *)((char *)v45 - 1);
          *(void *)&a2[2].name[8] = v46;
          if (!v46)
          {
            __int16 v47 = *(void (***)(void))&a2[1].name[24];
            if (v47)
            {
              *(void *)&a2[1].name[24] = 0;
              v47[2](v47);
              _Block_release(v47);
            }
            if (a2[1].level)
            {
              id v48 = *(const void **)&a2[1].name[24];
              if (v48) {
                _Block_release(v48);
              }
            }
            free(a2);
          }
        }
      }
    }
    else
    {
      int v6 = supports_external_data(a2);
    }
    __int16 v8 = v6 ? 4096 : 0;
    int v9 = *(_WORD *)&a1[6].flow_id[13] & 0xEFFF | (a1[6].flow_id[15] << 16);
    *(_WORD *)&a1[6].flow_id[13] = *(_WORD *)&a1[6].flow_id[13] & 0xEFFF | v8;
    a1[6].flow_id[15] = BYTE2(v9);
    id v4 = *(nw_protocol_callbacks **)&a2->name[24];
    if (v4)
    {
LABEL_160:
      get_parameters = (uint64_t (*)(nw_protocol_identifier *))v4->get_parameters;
      if (get_parameters)
      {
        if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
        {
          os_log_type_t v12 = *(nw_protocol_callbacks **)&a2[2].name[8];
          if (v12) {
            *(void *)&a2[2].name[8] = (char *)&v12->add_input_handler + 1;
          }
          BOOL v11 = (void *)get_parameters(a2);
          if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
          {
            __int16 v49 = *(nw_protocol_callbacks **)&a2[2].name[8];
            if (v49)
            {
              id v50 = (nw_protocol_callbacks *)((char *)v49 - 1);
              *(void *)&a2[2].name[8] = v50;
              if (!v50)
              {
                uint64_t v51 = *(void (***)(void))&a2[1].name[24];
                if (v51)
                {
                  *(void *)&a2[1].name[24] = 0;
                  v51[2](v51);
                  _Block_release(v51);
                }
                if (a2[1].level)
                {
                  BOOL v52 = *(const void **)&a2[1].name[24];
                  if (v52) {
                    _Block_release(v52);
                  }
                }
                free(a2);
              }
            }
          }
        }
        else
        {
          BOOL v11 = (void *)get_parameters(a2);
        }
        if (v11)
        {
          BOOL v13 = v11;
          os_log_type_t v14 = (nw_protocol *)*(id *)(v13[13] + 136);

          char handle = (char)a1[3].handle;
          if (handle)
          {
            output_handler = a1[3].output_handler;
            if (output_handler)
            {
              os_release(output_handler);
              char handle = (char)a1[3].handle;
            }
          }
          a1[3].output_handler = v14;
          LOBYTE(a1[3].handle) = handle | 1;
          __int16 v17 = v13;
          BOOL v18 = v17[19];

          nw_protocol_options_t v19 = nw_protocol_stack_copy_transport_protocol(v18);
          uint64_t v20 = (char *)&a1[6].identifier + 4;
          nw_protocol_options_get_log_id_str(v19, (unsigned char *)&a1[6].identifier + 4, 84);
          *(_DWORD *)&a1[6].flow_id[8] = nw_protocol_options_get_log_id_num(v19);
          if (nw_protocol_options_is_udp(v19))
          {
            if (nw_udp_options_get_no_metadata(v19)) {
              int v21 = 0x100000;
            }
            else {
              int v21 = 0;
            }
            unsigned int v22 = (*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16)) & 0xFFEFFFFF;
            *(_WORD *)&a1[6].flow_id[13] = *(_WORD *)&a1[6].flow_id[13];
            unsigned int v23 = (v22 | v21) >> 16;
          }
          else if (nw_protocol_options_is_quic(v19))
          {
            unsigned int v23 = (*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16) | 0x100000u) >> 16;
          }
          else
          {
            if (!nw_protocol_options_is_tcp(v19)) {
              goto LABEL_43;
            }
            if (nw_tcp_options_get_reset_local_port(v19)) {
              int v28 = -8388608;
            }
            else {
              int v28 = 0;
            }
            unsigned int v23 = (v28 & 0xFF80FFFF | ((a1[6].flow_id[15] & 0x7F) << 16)) >> 16;
          }
          a1[6].flow_id[15] = v23;
LABEL_43:
          if (v19) {
            os_release(v19);
          }
          if (v18) {
            os_release(v18);
          }
          int ip_protocol = nw_parameters_get_ip_protocol(v17);
          int v30 = ip_protocol;
          if (ip_protocol == 17)
          {
            int v31 = 1;
          }
          else if (ip_protocol == 6)
          {
            int v31 = 2;
          }
          else
          {
            nw_endpoint_t v32 = v17;
            int v31 = *((unsigned __int8 *)v32 + 92);
          }
          LODWORD(a1[4].identifier) = v31;
          os_log_type_t v33 = &a1[6].flow_id[13];
          if (nw_path_parameters_get_logging_disabled(v13[13])) {
            int v34 = 128;
          }
          else {
            int v34 = 0;
          }
          int v35 = *(_WORD *)&a1[6].flow_id[13] & 0xFF7F | (a1[6].flow_id[15] << 16);
          *(_WORD *)os_log_type_t v33 = *(_WORD *)&a1[6].flow_id[13] & 0xFF7F | v34;
          a1[6].flow_id[15] = BYTE2(v35);
          *(_DWORD *)a1[4].flow_id = 9216;
          BOOL v36 = *(nw_protocol_callbacks **)&a2->name[24];
          if (v36)
          {
            get_path = (uint64_t (*)(nw_protocol_identifier *))v36->get_path;
            if (get_path)
            {
              if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
              {
                __int16 v39 = *(nw_protocol_callbacks **)&a2[2].name[8];
                if (v39) {
                  *(void *)&a2[2].name[8] = (char *)&v39->add_input_handler + 1;
                }
                nw_endpoint_t v38 = (void *)get_path(a2);
                if (*(_UNKNOWN **)a2[1].name == &nw_protocol_ref_counted_handle)
                {
                  os_log_type_t v53 = *(nw_protocol_callbacks **)&a2[2].name[8];
                  if (v53)
                  {
                    BOOL v54 = (nw_protocol_callbacks *)((char *)v53 - 1);
                    *(void *)&a2[2].name[8] = v54;
                    if (!v54)
                    {
                      os_log_type_t v55 = *(void (***)(void))&a2[1].name[24];
                      if (v55)
                      {
                        *(void *)&a2[1].name[24] = 0;
                        v55[2](v55);
                        _Block_release(v55);
                      }
                      if (a2[1].level)
                      {
                        os_log_type_t v56 = *(const void **)&a2[1].name[24];
                        if (v56) {
                          _Block_release(v56);
                        }
                      }
                      free(a2);
                    }
                  }
                }
              }
              else
              {
                nw_endpoint_t v38 = (void *)get_path(a2);
              }
              if (v38)
              {
                if (nw_path_is_multilayer_packet_logging_enabled(v38))
                {
                  if ((*(_WORD *)v33 & 0x80) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    char v40 = gconnectionLogObj;
                    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
                    {
                      *(_DWORD *)buf = 136446466;
                      v69 = "nw_socket_add_input_handler";
                      __int16 v70 = 2082;
                      v71 = (char *)&a1[6].identifier + 4;
                      _os_log_impl(&dword_1830D4000, v40, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s Multilayer packet logging enabled", buf, 0x16u);
                    }
                  }
                  *(_WORD *)v33 |= 0x100u;
                }
                if (v30 == 17)
                {
                  unsigned int maximum_datagram_size = nw_path_get_maximum_datagram_size(v38);
                  if (maximum_datagram_size >> 10 <= 8) {
                    *(_DWORD *)a1[4].flow_id = maximum_datagram_size;
                  }
                }
                goto LABEL_79;
              }
              int v34 = *(_WORD *)v33 & 0x80;
            }
          }
          if (!v34)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v42 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              v69 = "nw_socket_add_input_handler";
              __int16 v70 = 2082;
              v71 = (char *)&a1[6].identifier + 4;
              _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Failed to copy path, will not use multilayer packet logging", buf, 0x16u);
            }
          }
LABEL_79:
          nw_protocol_set_flow_id_from_protocol(a1, a2);
          a1[2].identifier = a2;
          if (nw_socket_initialize_socket(a1))
          {
            a1[3].output_handler_context = (void *)0x100000001;
            if (!*(void *)&a2->level)
            {
              *(void *)&a2->level = a1;
              if (a1->handle == &nw_protocol_ref_counted_handle)
              {
                callbacks = a1[1].callbacks;
                if (callbacks) {
                  a1[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                }
              }
            }
            return 1;
          }
          if ((*(_WORD *)v33 & 0x80) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v44 = gconnectionLogObj;
            BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
            if (result)
            {
              *(_DWORD *)buf = 136446466;
              v69 = "nw_socket_add_input_handler";
              __int16 v70 = 2082;
              v71 = v20;
              BOOL v26 = "%{public}s %{public}s Failed to initialize socket";
              uint64_t v27 = v44;
              goto LABEL_90;
            }
            return result;
          }
          return 0;
        }
      }
    }
  }
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0) {
    return 0;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  uint64_t v24 = gconnectionLogObj;
  BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
  if (result)
  {
    *(_DWORD *)buf = 136446466;
    v69 = "nw_socket_add_input_handler";
    __int16 v70 = 2082;
    v71 = (char *)&a1[6].identifier + 4;
    BOOL v26 = "%{public}s %{public}s Parameters are NULL when adding input_handler";
    uint64_t v27 = v24;
LABEL_90:
    _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_ERROR, v26, buf, 0x16u);
    return 0;
  }
  return result;
}

id nw_flow_get_parameters(nw_protocol *a1)
{
  return *((id *)a1->handle + 22);
}

BOOL nw_protocol_options_is_udp(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (v1)
  {
    if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
      dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
    }
    BOOL v2 = nw_protocol_options_matches_definition(v1, (void *)g_udp_definition);
    goto LABEL_5;
  }
  id v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v15 = "nw_protocol_options_is_udp";
  int v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v5, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_options_is_udp";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          char v15 = "nw_protocol_options_is_udp";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_options_is_udp";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v15 = "nw_protocol_options_is_udp";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_5:

  return v2;
}

void sub_18316E0D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_flow_get_path(nw_protocol *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = *((id *)a1->handle + 20);
  BOOL v2 = v1;
  if (!v1)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_flow_get_path";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v10, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_flow_get_path";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_flow_get_path";
            __int16 v21 = 2082;
            unsigned int v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_flow_get_path";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_flow_get_path";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_30:
    if (v10) {
      free(v10);
    }
    goto LABEL_10;
  }
  BOOL v3 = (unsigned int *)v1;
  uint64_t v4 = v3[29];

  if (v4 == 2)
  {
    id v5 = nw_endpoint_flow_copy_path(v3);
    goto LABEL_11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v6 = (id)gLogObj;
  if (os_log_type_enabled(v6, OS_LOG_TYPE_DEFAULT))
  {
    if (v4 > 5) {
      os_log_type_t v7 = "unknown-mode";
    }
    else {
      os_log_type_t v7 = off_1E523FB08[v4];
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v20 = "nw_flow_get_path";
    __int16 v21 = 2082;
    unsigned int v22 = (void *)v7;
    __int16 v23 = 2082;
    uint64_t v24 = "flow";
    _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_10:
  id v5 = 0;
LABEL_11:

  return v5;
}

void sub_18316E470(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_options_t nw_protocol_stack_copy_transport_protocol(nw_protocol_stack_t stack)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_stack_t v1 = stack;
  nw_protocol_stack_t v2 = v1;
  if (v1)
  {
    BOOL v3 = v1[3].isa;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_stack_copy_transport_protocol";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_stack_copy_transport_protocol";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_stack_copy_transport_protocol";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_stack_copy_transport_protocol";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_stack_copy_transport_protocol";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_protocol_default_get_path(nw_protocol *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_protocol_default_get_path";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_default_get_path";
      BOOL v11 = "%{public}s called with null protocol";
      goto LABEL_39;
    }
    if (!v16)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_default_get_path";
      BOOL v11 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_39;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (!v13) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_default_get_path";
      BOOL v11 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_39;
    }
    if (v13)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_protocol_default_get_path";
      __int16 v20 = 2082;
      __int16 v21 = (nw_protocol_identifier *)backtrace_string;
      _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_40:
    if (!v8) {
      return 0;
    }
LABEL_41:
    free(v8);
    return 0;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v19 = "nw_protocol_default_get_path";
    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (!__nwlog_fault(v8, &type, &v16)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_default_get_path";
      BOOL v11 = "%{public}s called with null protocol->default_input_handler";
      goto LABEL_39;
    }
    if (!v16)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (!os_log_type_enabled(v9, type)) {
        goto LABEL_40;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_default_get_path";
      BOOL v11 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
      goto LABEL_39;
    }
    os_log_type_t v14 = (char *)__nw_create_backtrace_string();
    os_log_type_t v9 = __nwlog_obj();
    os_log_type_t v10 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (v14)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v19 = "nw_protocol_default_get_path";
        __int16 v20 = 2082;
        __int16 v21 = (nw_protocol_identifier *)v14;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v14);
      if (!v8) {
        return 0;
      }
      goto LABEL_41;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v19 = "nw_protocol_default_get_path";
      BOOL v11 = "%{public}s called with null protocol->default_input_handler, no backtrace";
LABEL_39:
      _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0xCu);
      goto LABEL_40;
    }
    goto LABEL_40;
  }
  callbacks = default_input_handler->callbacks;
  if (!callbacks || (get_path = (uint64_t (*)(void))callbacks->get_path) == 0)
  {
    int v6 = __nwlog_obj();
    if (os_log_type_enabled(v6, OS_LOG_TYPE_DEBUG))
    {
      identifier = (nw_protocol_identifier *)"<null>";
      if (a1->identifier) {
        identifier = a1->identifier;
      }
      *(_DWORD *)buf = 136446466;
      uint64_t v19 = "nw_protocol_default_get_path";
      __int16 v20 = 2082;
      __int16 v21 = identifier;
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_DEBUG, "%{public}s Protocol %{public}s does not support get path", buf, 0x16u);
    }
    return 0;
  }

  return get_path();
}

size_t nw_protocol_options_get_log_id_str(void *a1, unsigned char *a2, uint64_t a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  int v6 = (unsigned __int8 *)v5;
  if (!v5)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v13, &type, &v30)) {
      goto LABEL_59;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null options", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (!v30)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_1830D4000, v14, v27, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
      __int16 v34 = 2082;
      int v35 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_40:

    free(backtrace_string);
    goto LABEL_59;
  }
  if (!a2)
  {
    char v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (!__nwlog_fault(v13, &type, &v30)) {
      goto LABEL_59;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null log_id_str", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (!v30)
    {
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_1830D4000, v14, v28, "%{public}s called with null log_id_str, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_58;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v14 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v24 = os_log_type_enabled(v14, type);
    if (!backtrace_string)
    {
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null log_id_str, no backtrace", buf, 0xCu);
      }
      goto LABEL_58;
    }
    if (v24)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
      __int16 v34 = 2082;
      int v35 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null log_id_str, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_40;
  }
  if (!a3)
  {
    uint64_t v18 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
    BOOL v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v30 = 0;
    if (__nwlog_fault(v13, &type, &v30))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null log_id_str_len", buf, 0xCu);
        }
LABEL_58:

        goto LABEL_59;
      }
      if (!v30)
      {
        os_log_type_t v14 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
          _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null log_id_str_len, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_58;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v14 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
          _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null log_id_str_len, no backtrace", buf, 0xCu);
        }
        goto LABEL_58;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v33 = "nw_protocol_options_get_log_id_str";
        __int16 v34 = 2082;
        int v35 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v14, v25, "%{public}s called with null log_id_str_len, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_40;
    }
LABEL_59:
    if (v13) {
      free(v13);
    }
    size_t v10 = 0;
    goto LABEL_10;
  }
  *a2 = 0;
  os_log_type_t v7 = v5 + 48;
  if (a3 == 1)
  {
LABEL_8:
    *a2 = 0;
  }
  else
  {
    os_log_type_t v8 = v6 + 48;
    while (1)
    {
      int v9 = *v8;
      *a2 = v9;
      if (!v9) {
        break;
      }
      ++a2;
      ++v8;
      if ((unint64_t)--a3 <= 1) {
        goto LABEL_8;
      }
    }
  }
  size_t v10 = strlen(v7);
LABEL_10:

  return v10;
}

void nw_protocol_set_flow_id_from_protocol(_OWORD *a1, _OWORD *a2)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      *a1 = *a2;
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
    nw_protocol_stack_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (__nwlog_fault(v2, &type, &v10))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
        id v5 = "%{public}s called with null from_protocol";
        goto LABEL_32;
      }
      if (!v10)
      {
        BOOL v3 = __nwlog_obj();
        os_log_type_t v4 = type;
        if (!os_log_type_enabled(v3, type)) {
          goto LABEL_33;
        }
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
        id v5 = "%{public}s called with null from_protocol, backtrace limit exceeded";
        goto LABEL_32;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v9 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
          __int16 v14 = 2082;
          os_log_type_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null from_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        if (v2) {
          goto LABEL_34;
        }
        return;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
        id v5 = "%{public}s called with null from_protocol, no backtrace";
LABEL_32:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
    nw_protocol_stack_t v2 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v10 = 0;
    if (!__nwlog_fault(v2, &type, &v10)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      id v5 = "%{public}s called with null protocol";
      goto LABEL_32;
    }
    if (!v10)
    {
      BOOL v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (!os_log_type_enabled(v3, type)) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      id v5 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_32;
    }
    int v6 = (char *)__nw_create_backtrace_string();
    BOOL v3 = __nwlog_obj();
    os_log_type_t v4 = type;
    BOOL v7 = os_log_type_enabled(v3, type);
    if (!v6)
    {
      if (!v7) {
        goto LABEL_33;
      }
      *(_DWORD *)buf = 136446210;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      id v5 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_32;
    }
    if (v7)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v13 = "nw_protocol_set_flow_id_from_protocol";
      __int16 v14 = 2082;
      os_log_type_t v15 = v6;
      _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v6);
  }
LABEL_33:
  if (v2) {
LABEL_34:
  }
    free(v2);
}

uint64_t nw_protocol_options_get_log_id_num(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_stack_t v1 = a1;
  nw_protocol_stack_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[68];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_protocol_options_get_log_id_num";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_options_get_log_id_num";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_protocol_options_get_log_id_num";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_options_get_log_id_num";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_protocol_options_get_log_id_num";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_flow_supports_external_data(nw_protocol *a1)
{
  return 1;
}

BOOL nw_tcp_options_get_reset_local_port(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_options_is_tcp(v1))
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_tcp_options_get_reset_local_port_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_options_access_handle(v1, v12);
    BOOL v2 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  os_log_type_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reset_local_port";
  id v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reset_local_port";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_options_is_tcp(options)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reset_local_port";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reset_local_port";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_options_is_tcp(options), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_tcp_options_get_reset_local_port";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_options_is_tcp(options), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  BOOL v2 = 0;
LABEL_3:

  return v2;
}

void sub_18316FC44(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t ___ZL47nw_protocol_implementation_service_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(void *a1, void *a2)
{
  uint64_t v3 = a2;
  os_log_type_t v4 = v3;
  if (*(_DWORD *)(*(void *)(a1[4] + 8) + 24) && !nw_frame_unclaimed_length(v3))
  {
    uint64_t v7 = v4[4];
    os_log_type_t v8 = (void *)v4[5];
    int v6 = v4 + 4;
    if (v7)
    {
      *(void *)(v7 + 40) = v8;
      os_log_type_t v8 = (void *)v4[5];
    }
    else
    {
      *(void *)(a1[6] + 24) = v8;
    }
    void *v8 = v7;
    void *v6 = 0;
    v4[5] = 0;
    --*(_DWORD *)(*(void *)(a1[4] + 8) + 24);
    uint64_t v9 = a1[7];
    --*(_DWORD *)(a1[6] + 32);
    ++*(_DWORD *)(*(void *)(a1[5] + 8) + 24);
    BOOL v10 = *(void **)(v9 + 8);
    v4[4] = 0;
    v4[5] = v10;
    void *v10 = v4;
    *(void *)(v9 + 8) = v6;
    uint64_t v5 = 1;
  }
  else
  {
    uint64_t v5 = 0;
  }

  return v5;
}

uint64_t ___ZL44nw_protocol_http2_transport_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  unsigned int v4 = nw_frame_unclaimed_length((_DWORD *)a2);
  if ((*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) + 1) <= *(_DWORD *)(a1 + 80))
  {
    uint64_t v5 = *(void *)(*(void *)(a1 + 40) + 8);
    unsigned int v6 = *(_DWORD *)(v5 + 24);
    unsigned int v7 = *(_DWORD *)(a1 + 84);
    size_t v8 = v7 - v6;
    if (v7 > v6)
    {
      unsigned int v9 = v4;
      if (v8 >= v4)
      {
        *(_DWORD *)(v5 + 24) = v6 + v4;
        uint64_t v16 = *(void *)(a2 + 16);
        uint64_t v17 = *(void **)(a2 + 24);
        os_log_type_t v15 = (void *)(a2 + 16);
        if (v16)
        {
          *(void *)(v16 + 24) = v17;
          uint64_t v17 = *(void **)(a2 + 24);
        }
        else
        {
          *(void *)(*(void *)(a1 + 64) + 8) = v17;
        }
        *uint64_t v17 = v16;
        void *v15 = 0;
        *(void *)(a2 + 24) = 0;
        uint64_t v22 = *(void *)(*(void *)(a1 + 48) + 8);
        os_log_type_t v23 = *(uint64_t **)(v22 + 48);
        *(void *)(a2 + 24) = v23;
        uint64_t *v23 = a2;
        *(void *)(v22 + 48) = v15;
        if (gLogDatapath)
        {
          BOOL v54 = __nwlog_obj();
          if (os_log_type_enabled(v54, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v55 = *(void *)(a1 + 56);
            *(_DWORD *)buf = 136446722;
            BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            if (v55) {
              os_log_type_t v56 = (const char *)(v55 + 205);
            }
            else {
              os_log_type_t v56 = "";
            }
            __int16 v65 = 2082;
            char v66 = (void *)v56;
            __int16 v67 = 1024;
            int v68 = v9;
            _os_log_impl(&dword_1830D4000, v54, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s delivering entire incoming frame (%u bytes)", buf, 0x1Cu);
          }
        }
        uint64_t v11 = a2;
        goto LABEL_48;
      }
      if (gLogDatapath)
      {
        uint64_t v51 = __nwlog_obj();
        if (os_log_type_enabled(v51, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v52 = *(void *)(a1 + 56);
          *(_DWORD *)buf = 136446978;
          BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          if (v52) {
            os_log_type_t v53 = (const char *)(v52 + 205);
          }
          else {
            os_log_type_t v53 = "";
          }
          __int16 v65 = 2082;
          char v66 = (void *)v53;
          __int16 v67 = 1024;
          int v68 = v8;
          __int16 v69 = 1024;
          int v70 = v9;
          _os_log_impl(&dword_1830D4000, v51, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s remaining space %u less than frame length %u", buf, 0x22u);
        }
      }
      BOOL input_frame = http2_transport_create_input_frame(*(void *)(a1 + 56), *(void *)(a1 + 64), v8);
      if (input_frame)
      {
        uint64_t v11 = input_frame;
        http2_transport_input_frame_context_reset(input_frame, *(void *)(a1 + 56), *(void *)(a1 + 64));
        nw_frame_inherit_metadata(a2, v11, 0);
        if (!*(void *)(v11 + 112)
          || (*(_WORD *)(v11 + 204) & 0x100) != 0
          && g_channel_check_validity
          && !g_channel_check_validity(v11, *(void *)(v11 + 88)))
        {
          int v14 = 0;
          BOOL v24 = 0;
          if (!v8) {
            goto LABEL_47;
          }
        }
        else
        {
          int v13 = *(_DWORD *)(v11 + 52);
          uint64_t v12 = *(unsigned int *)(v11 + 56);
          if (v13) {
            int v14 = v13 - (v12 + *(_DWORD *)(v11 + 60));
          }
          else {
            int v14 = 0;
          }
          BOOL v24 = (void *)(*(void *)(v11 + 112) + v12);
          if (v14 == v8)
          {
LABEL_47:
            __int16 v39 = (const void *)nw_frame_unclaimed_bytes(a2, 0);
            memcpy(v24, v39, v8);
            uint64_t v40 = *(void *)(*(void *)(a1 + 48) + 8);
            *(void *)(v11 + 16) = 0;
            uint64_t v41 = *(uint64_t **)(v40 + 48);
            *(void *)(v11 + 24) = v41;
            *uint64_t v41 = v11;
            *(void *)(v40 + 48) = v11 + 16;
            nw_frame_claim(a2, v42, v8, 0);
            *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += v8;
            if (gLogDatapath)
            {
              os_log_type_t v57 = __nwlog_obj();
              if (os_log_type_enabled(v57, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v58 = *(void *)(a1 + 56);
                if (v58) {
                  os_log_type_t v59 = (const char *)(v58 + 205);
                }
                else {
                  os_log_type_t v59 = "";
                }
                int v60 = nw_frame_unclaimed_length((_DWORD *)a2);
                *(_DWORD *)buf = 136447234;
                BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
                __int16 v65 = 2082;
                char v66 = (void *)v59;
                __int16 v67 = 1024;
                int v68 = v8;
                __int16 v69 = 1024;
                int v70 = v9;
                __int16 v71 = 1024;
                LODWORD(v72) = v60;
                _os_log_impl(&dword_1830D4000, v57, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s delivering partial frame (%u bytes of %u, %u bytes remaining)", buf, 0x28u);
              }
            }
LABEL_48:
            ++*(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24);
            uint64_t v43 = *(void *)(a1 + 72);
            *(void *)(v11 + 32) = 0;
            uint64_t v44 = *(uint64_t **)(v43 + 8);
            *(void *)(v11 + 40) = v44;
            uint64_t *v44 = v11;
            *(void *)(v43 + 8) = v11 + 32;
            return 1;
          }
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = *(void *)(a1 + 56);
        if (v25) {
          BOOL v26 = (const char *)(v25 + 205);
        }
        else {
          BOOL v26 = "";
        }
        *(_DWORD *)buf = 136446978;
        BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
        __int16 v65 = 2082;
        char v66 = (void *)v26;
        __int16 v67 = 1024;
        int v68 = v14;
        __int16 v69 = 1024;
        int v70 = v8;
        os_log_type_t v27 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v61 = 0;
        if (!__nwlog_fault(v27, &type, &v61)) {
          goto LABEL_67;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v28 = __nwlog_obj();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            uint64_t v30 = *(void *)(a1 + 56);
            if (v30) {
              int v31 = (const char *)(v30 + 205);
            }
            else {
              int v31 = "";
            }
            *(_DWORD *)buf = 136446978;
            BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            __int16 v65 = 2082;
            char v66 = (void *)v31;
            __int16 v67 = 1024;
            int v68 = v14;
            __int16 v69 = 1024;
            int v70 = v8;
            nw_endpoint_t v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame";
LABEL_66:
            _os_log_impl(&dword_1830D4000, v28, v29, v32, buf, 0x22u);
          }
        }
        else if (v61)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v28 = __nwlog_obj();
          os_log_type_t v29 = type;
          BOOL v36 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v36)
            {
              uint64_t v37 = *(void *)(a1 + 56);
              if (v37) {
                nw_endpoint_t v38 = (const char *)(v37 + 205);
              }
              else {
                nw_endpoint_t v38 = "";
              }
              *(_DWORD *)buf = 136447234;
              BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
              __int16 v65 = 2082;
              char v66 = (void *)v38;
              __int16 v67 = 1024;
              int v68 = v14;
              __int16 v69 = 1024;
              int v70 = v8;
              __int16 v71 = 2082;
              uint64_t v72 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_create_input_frame, dumping backtrace:%{public}s", buf, 0x2Cu);
            }
            free(backtrace_string);
            goto LABEL_67;
          }
          if (v36)
          {
            uint64_t v48 = *(void *)(a1 + 56);
            if (v48) {
              __int16 v49 = (const char *)(v48 + 205);
            }
            else {
              __int16 v49 = "";
            }
            *(_DWORD *)buf = 136446978;
            BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            __int16 v65 = 2082;
            char v66 = (void *)v49;
            __int16 v67 = 1024;
            int v68 = v14;
            __int16 v69 = 1024;
            int v70 = v8;
            nw_endpoint_t v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame, no backtrace";
            goto LABEL_66;
          }
        }
        else
        {
          os_log_type_t v28 = __nwlog_obj();
          os_log_type_t v29 = type;
          if (os_log_type_enabled(v28, type))
          {
            uint64_t v46 = *(void *)(a1 + 56);
            if (v46) {
              __int16 v47 = (const char *)(v46 + 205);
            }
            else {
              __int16 v47 = "";
            }
            *(_DWORD *)buf = 136446978;
            BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            __int16 v65 = 2082;
            char v66 = (void *)v47;
            __int16 v67 = 1024;
            int v68 = v14;
            __int16 v69 = 1024;
            int v70 = v8;
            nw_endpoint_t v32 = "%{public}s %{public}s got frame with wrong number of bytes (got %u != wanted %u) from http2_transport_"
                  "create_input_frame, backtrace limit exceeded";
            goto LABEL_66;
          }
        }
LABEL_67:
        if (v27) {
          free(v27);
        }
        if ((*(_WORD *)(v11 + 204) & 0x100) == 0
          || !g_channel_check_validity
          || g_channel_check_validity(v11, *(void *)(v11 + 88)))
        {
          id v50 = *(void **)(v11 + 112);
          if (v50) {
            free(v50);
          }
        }
        nw_frame_reset(v11, 0, 0, 0, 0);
        os_release((void *)v11);
        return 0;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446210;
      BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
      uint64_t v18 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v61 = 0;
      if (__nwlog_fault(v18, &type, &v61))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v19 = gLogObj;
          os_log_type_t v20 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_59;
          }
          *(_DWORD *)buf = 136446210;
          BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          os_log_type_t v21 = "%{public}s http2_transport_create_input_frame failed";
          goto LABEL_58;
        }
        if (!v61)
        {
          uint64_t v19 = __nwlog_obj();
          os_log_type_t v20 = type;
          if (!os_log_type_enabled(v19, type)) {
            goto LABEL_59;
          }
          *(_DWORD *)buf = 136446210;
          BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          os_log_type_t v21 = "%{public}s http2_transport_create_input_frame failed, backtrace limit exceeded";
          goto LABEL_58;
        }
        os_log_type_t v33 = (char *)__nw_create_backtrace_string();
        uint64_t v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        BOOL v34 = os_log_type_enabled(v19, type);
        if (v33)
        {
          if (v34)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
            __int16 v65 = 2082;
            char v66 = v33;
            _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s http2_transport_create_input_frame failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v33);
          goto LABEL_59;
        }
        if (v34)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v64 = "nw_protocol_http2_transport_get_input_frames_block_invoke";
          os_log_type_t v21 = "%{public}s http2_transport_create_input_frame failed, no backtrace";
LABEL_58:
          _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
        }
      }
LABEL_59:
      if (v18) {
        free(v18);
      }
    }
  }
  return 0;
}

uint64_t ___ZL27nw_channel_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v2 = *(void *)(*(void *)(a1 + 32) + 8);
  unsigned int v3 = *(_DWORD *)(v2 + 24);
  if (v3 >= *(_DWORD *)(a1 + 64) || *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) >= *(_DWORD *)(a1 + 68)) {
    return 0;
  }
  *(_DWORD *)(v2 + 24) = v3 + 1;
  *(_DWORD *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) += nw_frame_unclaimed_length((_DWORD *)a2);
  uint64_t v7 = *(void *)(a2 + 32);
  size_t v8 = *(void **)(a2 + 40);
  unsigned int v6 = (void *)(a2 + 32);
  if (v7)
  {
    *(void *)(v7 + 40) = v8;
    size_t v8 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 48) + 8) = v8;
  }
  void *v8 = v7;
  void *v6 = 0;
  *(void *)(a2 + 40) = 0;
  uint64_t v10 = *(void *)(a1 + 56);
  uint64_t v11 = *(void **)(v10 + 8);
  *(void *)(a2 + 40) = v11;
  void *v11 = a2;
  *(void *)(v10 + 8) = v6;
  return 1;
}

uint64_t nw_frame_unclaimed_length(_DWORD *a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v12 = "__nw_frame_unclaimed_length";
    unsigned int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v9 = 0;
    if (!__nwlog_fault(v3, &type, &v9)) {
      goto LABEL_18;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "__nw_frame_unclaimed_length";
      unsigned int v6 = "%{public}s called with null frame";
    }
    else if (v9)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v12 = "__nw_frame_unclaimed_length";
          __int16 v13 = 2082;
          int v14 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (!v8)
      {
LABEL_18:
        if (v3) {
          free(v3);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "__nw_frame_unclaimed_length";
      unsigned int v6 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      unsigned int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v12 = "__nw_frame_unclaimed_length";
      unsigned int v6 = "%{public}s called with null frame, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_18;
  }
  int v1 = a1[13];
  if (v1) {
    return (v1 - (a1[14] + a1[15]));
  }
  return 0;
}

void nw_frame_inherit_metadata(uint64_t a1, uint64_t a2, int a3)
{
  uint64_t v77 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v70 = "__nw_frame_inherit_metadata";
    BOOL v54 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (!__nwlog_fault(v54, type, &v67)) {
      goto LABEL_114;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null original_frame";
      goto LABEL_113;
    }
    if (!v67)
    {
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null original_frame, backtrace limit exceeded";
      goto LABEL_113;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v55 = __nwlog_obj();
    os_log_type_t v56 = type[0];
    BOOL v59 = os_log_type_enabled(v55, type[0]);
    if (!backtrace_string)
    {
      if (!v59) {
        goto LABEL_114;
      }
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null original_frame, no backtrace";
      goto LABEL_113;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      int v70 = "__nw_frame_inherit_metadata";
      __int16 v71 = 2082;
      uint64_t v72 = (uint64_t)backtrace_string;
      _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null original_frame, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_114:
    if (!v54) {
      return;
    }
    goto LABEL_115;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v70 = "__nw_frame_inherit_metadata";
    BOOL v54 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (!__nwlog_fault(v54, type, &v67)) {
      goto LABEL_114;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null new_frame";
      goto LABEL_113;
    }
    if (!v67)
    {
      uint64_t v55 = __nwlog_obj();
      os_log_type_t v56 = type[0];
      if (!os_log_type_enabled(v55, type[0])) {
        goto LABEL_114;
      }
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null new_frame, backtrace limit exceeded";
      goto LABEL_113;
    }
    int v60 = (char *)__nw_create_backtrace_string();
    uint64_t v55 = __nwlog_obj();
    os_log_type_t v56 = type[0];
    BOOL v61 = os_log_type_enabled(v55, type[0]);
    if (v60)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446466;
        int v70 = "__nw_frame_inherit_metadata";
        __int16 v71 = 2082;
        uint64_t v72 = (uint64_t)v60;
        _os_log_impl(&dword_1830D4000, v55, v56, "%{public}s called with null new_frame, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v60);
      if (!v54) {
        return;
      }
LABEL_115:
      free(v54);
      return;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_inherit_metadata";
      os_log_type_t v57 = "%{public}s called with null new_frame, no backtrace";
LABEL_113:
      _os_log_impl(&dword_1830D4000, v55, v56, v57, buf, 0xCu);
      goto LABEL_114;
    }
    goto LABEL_114;
  }
  int v4 = a3;
  os_log_type_t v5 = *(uint64_t ***)(a1 + 64);
  if (!v5)
  {
LABEL_82:
    if (v4)
    {
      if (*(char *)(a1 + 186) < 0) {
        *(unsigned char *)(a2 + 186) |= 0x80u;
      }
    }
    return;
  }
  __int16 v65 = (uint64_t **)(a2 + 64);
  uint64_t v66 = a2 + 120;
  v63 = (_OWORD *)(a2 + 136);
  while (v4)
  {
    int v6 = (*((unsigned __int8 *)v5 + 66) >> 6) & 1;
    uint64_t v7 = v5[6];
    if (v7) {
      goto LABEL_9;
    }
LABEL_17:
    if ((*(_WORD *)(a2 + 204) & 8) != 0) {
      goto LABEL_6;
    }
LABEL_22:
    uint64_t v11 = *(void **)(a2 + 168);
    if (v11)
    {
      os_release(v11);
      *(void *)(a2 + 168) = 0;
    }
    if (v7)
    {
      *(void *)(a2 + 168) = os_retain(v7);
      int v12 = *(unsigned __int16 *)(a2 + 204);
      int v13 = v12 | (*(unsigned __int8 *)(a2 + 206) << 16);
      if ((v12 & 0x20) == 0)
      {
        int v14 = v7;
        _OWORD *v63 = *(_OWORD *)&v14[2].isa;

        int v13 = *(unsigned __int16 *)(a2 + 204) | (*(unsigned __int8 *)(a2 + 206) << 16);
        int v4 = a3;
      }
      *(unsigned char *)(a2 + 206) = BYTE2(v13);
      *(_WORD *)(a2 + 204) = v13 | 8;
    }
    *(unsigned char *)(a2 + 186) = *(unsigned char *)(a2 + 186) & 0xBF | ((_BYTE)v6 << 6);
    uint64_t v15 = *(void *)(a2 + 64);
    if (!v15)
    {
      *(void *)(a2 + 64) = v66;
      *(void *)(a2 + 72) = v66;
      *(void *)(a2 + 120) = 0;
      *(void *)(a2 + 128) = v65;
      goto LABEL_6;
    }
    if (v15 != v66)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)buf = 136446722;
      int v70 = "__nw_frame_set_metadata";
      __int16 v71 = 2048;
      uint64_t v72 = v15;
      __int16 v73 = 2048;
      uint64_t v74 = v66;
      uint64_t v16 = (char *)_os_log_send_and_compose_impl();
      type[0] = OS_LOG_TYPE_ERROR;
      char v67 = 0;
      if (!__nwlog_fault(v16, type, &v67)) {
        goto LABEL_62;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v17 = gLogObj;
        os_log_type_t v18 = type[0];
        if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
        {
          *(_DWORD *)buf = 136446722;
          int v70 = "__nw_frame_set_metadata";
          __int16 v71 = 2048;
          uint64_t v72 = v15;
          __int16 v73 = 2048;
          uint64_t v74 = v66;
          uint64_t v19 = v17;
          os_log_type_t v20 = v18;
          os_log_type_t v21 = "%{public}s Existing metadata %p doesn't match expected %p";
          goto LABEL_61;
        }
        goto LABEL_62;
      }
      if (v67)
      {
        BOOL v34 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v35 = gLogObj;
        os_log_type_t v36 = type[0];
        BOOL v37 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v34)
        {
          if (v37)
          {
            *(_DWORD *)buf = 136446978;
            int v70 = "__nw_frame_set_metadata";
            __int16 v71 = 2048;
            uint64_t v72 = v15;
            __int16 v73 = 2048;
            uint64_t v74 = v66;
            __int16 v75 = 2082;
            v76 = v34;
            _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s Existing metadata %p doesn't match expected %p, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(v34);
          goto LABEL_62;
        }
        if (!v37)
        {
LABEL_62:
          if (v16) {
            free(v16);
          }
          goto LABEL_6;
        }
        *(_DWORD *)buf = 136446722;
        int v70 = "__nw_frame_set_metadata";
        __int16 v71 = 2048;
        uint64_t v72 = v15;
        __int16 v73 = 2048;
        uint64_t v74 = v66;
        uint64_t v19 = v35;
        os_log_type_t v20 = v36;
        os_log_type_t v21 = "%{public}s Existing metadata %p doesn't match expected %p, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v38 = gLogObj;
        os_log_type_t v39 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_62;
        }
        *(_DWORD *)buf = 136446722;
        int v70 = "__nw_frame_set_metadata";
        __int16 v71 = 2048;
        uint64_t v72 = v15;
        __int16 v73 = 2048;
        uint64_t v74 = v66;
        uint64_t v19 = v38;
        os_log_type_t v20 = v39;
        os_log_type_t v21 = "%{public}s Existing metadata %p doesn't match expected %p, backtrace limit exceeded";
      }
LABEL_61:
      _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0x20u);
      goto LABEL_62;
    }
LABEL_6:
    os_log_type_t v5 = (uint64_t **)*v5;
    if (!v5) {
      goto LABEL_82;
    }
  }
  LOBYTE(v6) = 0;
  uint64_t v7 = v5[6];
  if (!v7) {
    goto LABEL_17;
  }
LABEL_9:
  if (nw_protocol_setup_ip_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_ip_definition(void)::onceToken, &__block_literal_global_53153);
  }
  if (nw_protocol_metadata_matches_definition((uint64_t)v7, g_ip_definition))
  {
    *(unsigned char *)(a2 + 186) = *(unsigned char *)(a2 + 186) & 0xFC | nw_ip_metadata_get_ecn_flag(v7) & 3;
    dscp_xpc_object_t value = nw_ip_metadata_get_dscp_value(v7);
    if (dscp_value < 0x40)
    {
      *(unsigned char *)(a2 + 184) = dscp_value;
      goto LABEL_14;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v70 = "__nw_frame_set_dscp_value";
    uint64_t v40 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    char v67 = 0;
    if (!__nwlog_fault(v40, type, &v67)) {
      goto LABEL_80;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v41 = __nwlog_obj();
      os_log_type_t v42 = type[0];
      if (os_log_type_enabled(v41, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v70 = "__nw_frame_set_dscp_value";
        uint64_t v43 = v41;
        os_log_type_t v44 = v42;
        __int16 v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP)";
        goto LABEL_79;
      }
      goto LABEL_80;
    }
    if (!v67)
    {
      uint64_t v52 = __nwlog_obj();
      os_log_type_t v53 = type[0];
      if (!os_log_type_enabled(v52, type[0])) {
        goto LABEL_80;
      }
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_set_dscp_value";
      uint64_t v43 = v52;
      os_log_type_t v44 = v53;
      __int16 v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP), backtrace limit exceeded";
      goto LABEL_79;
    }
    uint64_t v48 = (char *)__nw_create_backtrace_string();
    __int16 v49 = __nwlog_obj();
    os_log_type_t v50 = type[0];
    BOOL v51 = os_log_type_enabled(v49, type[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446466;
        int v70 = "__nw_frame_set_dscp_value";
        __int16 v71 = 2082;
        uint64_t v72 = (uint64_t)v48;
        _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null (dscp_value <= _MAX_DSCP), dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v48);
      goto LABEL_80;
    }
    if (v51)
    {
      *(_DWORD *)buf = 136446210;
      int v70 = "__nw_frame_set_dscp_value";
      uint64_t v43 = v49;
      os_log_type_t v44 = v50;
      __int16 v45 = "%{public}s called with null (dscp_value <= _MAX_DSCP), no backtrace";
LABEL_79:
      _os_log_impl(&dword_1830D4000, v43, v44, v45, buf, 0xCu);
    }
LABEL_80:
    if (v40) {
      free(v40);
    }
LABEL_14:
    nw_service_class_t service_class = nw_ip_metadata_get_service_class(v7);
    if (service_class > nw_service_class_signaling) {
      int v10 = 0;
    }
    else {
      int v10 = dword_183D5D290[service_class];
    }
    *(_DWORD *)(a2 + 176) = v10;
    *(_DWORD *)(a2 + 180) = nw_ip_metadata_get_fragmentation_value(v7);
  }
  if ((*(_WORD *)(a2 + 204) & 8) == 0) {
    goto LABEL_22;
  }
  char v22 = v6;
  memset(type, 0, sizeof(type));
  os_log_type_t v23 = v7;
  *(_OWORD *)os_log_type_t type = *(_OWORD *)&v23[2].isa;

  BOOL v24 = *v65;
  if (!*v65) {
    goto LABEL_49;
  }
  char v25 = 0;
  while (2)
  {
    BOOL v26 = v23;
    os_log_type_t v27 = v23[1].isa;

    os_log_type_t v28 = (void *)v24[6];
    if (v28)
    {
      os_log_type_t v29 = v28;
      id v30 = v29[1];

      if (nw_protocol_definition_is_equal_unsafe((uint64_t)v27, (uint64_t)v30)
        && !uuid_compare((const unsigned __int8 *)type, (const unsigned __int8 *)v24 + 16))
      {
        os_retain(v26);
        int v31 = (void *)v24[6];
        if (v31) {
          os_release(v31);
        }
        v24[6] = (uint64_t)v26;
        *((unsigned char *)v24 + 66) = *((unsigned char *)v24 + 66) & 0xBF | (v22 << 6);
        char v25 = 1;
        if (v30) {
LABEL_41:
        }
          os_release(v30);
      }
      else if (v30)
      {
        goto LABEL_41;
      }
    }
    if (v27) {
      os_release(v27);
    }
    BOOL v24 = (uint64_t *)*v24;
    if (v24) {
      continue;
    }
    break;
  }
  if (v25) {
    goto LABEL_51;
  }
LABEL_49:
  nw_endpoint_t v32 = malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
  if (v32) {
    goto LABEL_50;
  }
  uint64_t v46 = __nwlog_obj();
  os_log_type_enabled(v46, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  int v70 = "strict_calloc";
  __int16 v71 = 2048;
  uint64_t v72 = 1;
  __int16 v73 = 2048;
  uint64_t v74 = 72;
  __int16 v47 = (void *)_os_log_send_and_compose_impl();
  if (!__nwlog_abort((uint64_t)v47))
  {
    free(v47);
LABEL_50:
    v32[6] = os_retain(v23);
    *((_OWORD *)v32 + 1) = *(_OWORD *)type;
    *((unsigned char *)v32 + 66) = *((unsigned char *)v32 + 66) & 0xBF | (v22 << 6);
    *nw_endpoint_t v32 = 0;
    os_log_type_t v33 = *(void **)(a2 + 72);
    v32[1] = v33;
    *os_log_type_t v33 = v32;
    *(void *)(a2 + 72) = v32;
LABEL_51:
    int v4 = a3;
    goto LABEL_6;
  }
  __break(1u);
}

BOOL nw_connection_used_fallback(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  int v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v19 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_used_fallback_block_invoke;
    v13[3] = &unk_1E524B978;
    uint64_t v15 = buf;
    int v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_used_fallback_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  os_log_type_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_used_fallback";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_connection_used_fallback_block_invoke(uint64_t a1)
{
  uint64_t result = nw_connection_used_fallback_locked(*(void **)(a1 + 32));
  *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = result;
  return result;
}

void nw_connection_modify_estimated_bytes(void *a1, char a2, char a3, uint64_t a4)
{
  id v7 = a1;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = __nw_connection_modify_estimated_bytes_block_invoke;
  v9[3] = &unk_1E524BB20;
  char v12 = a2;
  id v8 = v7;
  char v13 = a3;
  id v10 = v8;
  uint64_t v11 = a4;
  nw_connection_async_if_needed(v8, v9);
}

void sub_1831719E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_connection_cancel(nw_connection_t connection)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  int v1 = connection;
  if (v1)
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_237);
    }
    if (_nw_signposts_enabled && kdebug_is_enabled()) {
      kdebug_trace();
    }
    nw_connection_cancel_inner(v1, 0);
    goto LABEL_8;
  }
  uint64_t v2 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v13 = "nw_connection_cancel";
  BOOL v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v13 = "nw_connection_cancel";
        _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v4 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          char v13 = "nw_connection_cancel";
          __int16 v14 = 2082;
          uint64_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v7, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_25;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        char v13 = "nw_connection_cancel";
        _os_log_impl(&dword_1830D4000, v4, v7, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v4 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        char v13 = "nw_connection_cancel";
        _os_log_impl(&dword_1830D4000, v4, v9, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_25:
  if (v3) {
    free(v3);
  }
LABEL_8:
}

void sub_183171CF8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_cancel_inner(NWConcrete_nw_connection *a1, char a2)
{
  BOOL v3 = a1;
  v8[0] = MEMORY[0x1E4F143A8];
  v8[1] = 3221225472;
  _DWORD v8[2] = ___ZL27nw_connection_set_cancelledP24NWConcrete_nw_connection_block_invoke;
  v8[3] = &unk_1E524BAA8;
  os_log_type_t v9 = v3;
  os_unfair_lock_lock(&v3->lock);
  ___ZL27nw_connection_set_cancelledP24NWConcrete_nw_connection_block_invoke((uint64_t)v8);
  os_unfair_lock_unlock(&v3->lock);

  v5[0] = MEMORY[0x1E4F143A8];
  v5[1] = 3221225472;
  v5[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke;
  v5[3] = &unk_1E5248D20;
  int v4 = v3;
  int v6 = v4;
  char v7 = a2;
  nw_connection_async_if_needed(v4, v5);
}

void sub_183171E1C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

void nw_connection_start(nw_connection_t connection)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = connection;
  if (v1)
  {
    if (_nw_signposts_once != -1) {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_237);
    }
    if (_nw_signposts_enabled && kdebug_is_enabled()) {
      kdebug_trace();
    }
    if (_os_feature_enabled_impl() && !nw_parameters_get_logging_disabled((uint64_t)v1[2].isa))
    {
      uint64_t v2 = nw_parameters_copy_description_internal((NWConcrete_nw_parameters *)v1[2].isa, 1);
      backtrace_string = (char *)__nw_create_backtrace_string();
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      int v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int isa = (int)v1[56].isa;
        logging_description = nw_endpoint_get_logging_description(v1[1].isa);
        *(_DWORD *)buf = 67110402;
        *(_DWORD *)char v22 = isa;
        *(_WORD *)&v22[4] = 1042;
        *(_DWORD *)&v22[6] = 16;
        *(_WORD *)os_log_type_t v23 = 2098;
        *(void *)&v23[2] = (char *)v1 + 452;
        __int16 v24 = 2082;
        char v25 = logging_description;
        __int16 v26 = 2082;
        os_log_type_t v27 = v2;
        __int16 v28 = 2080;
        os_log_type_t v29 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "[C%u %{public,uuid_t}.16P %{public}s %{public}s] started by:\n%s", buf, 0x36u);
      }

      if (v2) {
        free(v2);
      }
      if (backtrace_string) {
        free(backtrace_string);
      }
    }
    qos_class_t v7 = qos_class_self();
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = __nw_connection_start_block_invoke;
    v16[3] = &unk_1E524A070;
    uint64_t v17 = v1;
    qos_class_t v18 = v7;
    nw_connection_async_if_needed(v17, v16);

    goto LABEL_18;
  }
  BOOL v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)char v22 = "nw_connection_start";
  os_log_type_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v9, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)char v22 = "nw_connection_start";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v19)
    {
      char v12 = (char *)__nw_create_backtrace_string();
      char v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (v12)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)char v22 = "nw_connection_start";
          *(_WORD *)&v22[8] = 2082;
          *(void *)os_log_type_t v23 = v12;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v12);
        goto LABEL_35;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)char v22 = "nw_connection_start";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)char v22 = "nw_connection_start";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_35:
  if (v9) {
    free(v9);
  }
LABEL_18:
}

void sub_1831722A4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_send(nw_connection_t connection, dispatch_data_t content, nw_content_context_t context, BOOL is_complete, nw_connection_send_completion_t completion)
{
  BOOL v6 = is_complete;
  *(void *)&v51[13] = *MEMORY[0x1E4F143B8];
  nw_connection_t v9 = connection;
  char v10 = content;
  os_log_type_t v11 = context;
  nw_connection_send_completion_t v12 = completion;
  os_log_type_t v13 = v12;
  if (!v9)
  {
    uint64_t v30 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v49 = "nw_connection_send";
    int v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v31, &type, &v46)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v32 = __nwlog_obj();
      os_log_type_t v33 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v49 = "nw_connection_send";
        _os_log_impl(&dword_1830D4000, v32, v33, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v46)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v32 = __nwlog_obj();
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v32, type);
      if (backtrace_string)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v49 = "nw_connection_send";
          __int16 v50 = 2082;
          *(void *)BOOL v51 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v32, v37, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_73:
        if (!v31) {
          goto LABEL_39;
        }
        goto LABEL_74;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v49 = "nw_connection_send";
        _os_log_impl(&dword_1830D4000, v32, v37, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v32 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v49 = "nw_connection_send";
        _os_log_impl(&dword_1830D4000, v32, v42, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_72:

    goto LABEL_73;
  }
  if (!v12)
  {
    BOOL v34 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v49 = "nw_connection_send";
    int v31 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (!__nwlog_fault(v31, &type, &v46)) {
      goto LABEL_73;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v32 = __nwlog_obj();
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v49 = "nw_connection_send";
        _os_log_impl(&dword_1830D4000, v32, v35, "%{public}s called with null completion", buf, 0xCu);
      }
    }
    else if (v46)
    {
      os_log_type_t v39 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v32 = __nwlog_obj();
      os_log_type_t v40 = type;
      BOOL v41 = os_log_type_enabled(v32, type);
      if (v39)
      {
        if (v41)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v49 = "nw_connection_send";
          __int16 v50 = 2082;
          *(void *)BOOL v51 = v39;
          _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v39);
        if (!v31) {
          goto LABEL_39;
        }
LABEL_74:
        free(v31);
        goto LABEL_39;
      }
      if (v41)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v49 = "nw_connection_send";
        _os_log_impl(&dword_1830D4000, v32, v40, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v32 = __nwlog_obj();
      os_log_type_t v43 = type;
      if (os_log_type_enabled(v32, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v49 = "nw_connection_send";
        _os_log_impl(&dword_1830D4000, v32, v43, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_72;
  }
  if (v11 != &__block_literal_global_10_42276)
  {
    BOOL v14 = &__block_literal_global_42249;
    if (v11) {
      BOOL v14 = v11;
    }
    os_log_type_t v15 = v14;
    if (v13 == &__block_literal_global_24376) {
      uint64_t v16 = nw_write_request_create_idempotent(v10, v15, 0, v6);
    }
    else {
      uint64_t v16 = nw_write_request_create(v10, v15, 0, v6, v9, v13);
    }
    os_log_type_t v21 = v16;
    if (v16)
    {
      nw_connection_add_write_request(v9, v16);
LABEL_38:

      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    __int16 v49 = "nw_connection_send";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v46 = 0;
    if (__nwlog_fault(v23, &type, &v46))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v24 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v49 = "nw_connection_send";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_write_request_create failed", buf, 0xCu);
        }
      }
      else if (v46)
      {
        __int16 v26 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v24 = (id)gLogObj;
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v49 = "nw_connection_send";
            __int16 v50 = 2082;
            *(void *)BOOL v51 = v26;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s nw_write_request_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v26);
          if (!v23) {
            goto LABEL_38;
          }
          goto LABEL_37;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v49 = "nw_connection_send";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s nw_write_request_create failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v24 = (id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v49 = "nw_connection_send";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s nw_write_request_create failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v23) {
      goto LABEL_38;
    }
LABEL_37:
    free(v23);
    goto LABEL_38;
  }
  Class isa = v9[2].isa;
  if (isa && !nw_path_parameters_get_logging_disabled(*((void *)isa + 13)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    qos_class_t v18 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      int v19 = (int)v9[56].isa;
      *(_DWORD *)buf = 136446722;
      __int16 v49 = "nw_connection_send";
      __int16 v50 = 1024;
      *(_DWORD *)BOOL v51 = v19;
      v51[2] = 2082;
      *(void *)&v51[3] = "Cannot send replies on new inbound message context";
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s [C%u] %{public}s, sending error callback", buf, 0x1Cu);
    }
  }
  dispatch_qos_class_t v20 = (dispatch_qos_class_t)v9[24].isa;
  v44[0] = MEMORY[0x1E4F143A8];
  v44[1] = 3221225472;
  v44[2] = __nw_connection_send_block_invoke;
  v44[3] = &unk_1E524AFA8;
  id v45 = v13;
  nw_connection_async_client_if_needed_with_override(v9, 0, v20, v44);

LABEL_39:
}

void sub_183172C0C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_connection_add_write_request(void *a1, void *a2)
{
  BOOL v3 = a1;
  id v4 = a2;
  uint64_t v15 = 0;
  uint64_t v16 = &v15;
  uint64_t v17 = 0x2020000000;
  char v18 = 1;
  os_log_type_t v5 = v3 + 34;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke;
  v11[3] = &unk_1E5242570;
  BOOL v6 = v3;
  nw_connection_send_completion_t v12 = v6;
  id v7 = v4;
  id v13 = v7;
  BOOL v14 = &v15;
  os_unfair_lock_lock(v5);
  ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke((uint64_t)v11);
  os_unfair_lock_unlock(v5);
  if (*((unsigned char *)v16 + 24))
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    _DWORD v8[2] = ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke_2;
    v8[3] = &unk_1E524B9A0;
    nw_connection_t v9 = v6;
    id v10 = v7;
    nw_connection_async_if_needed(v9, v8);
  }
  _Block_object_dispose(&v15, 8);
}

void sub_183172DD0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  _Block_object_dispose((const void *)(v23 - 96), 8);
  _Unwind_Resume(a1);
}

void nw_connection_receive_internal(void *a1, void *a2, unsigned int a3, unsigned int a4, void *a5)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  nw_connection_t v9 = a1;
  id v10 = a2;
  id v11 = a5;
  nw_connection_send_completion_t v12 = v11;
  if (!v9)
  {
    uint64_t v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v37 = "nw_connection_receive_internal";
    char v18 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v34 = 0;
    if (!__nwlog_fault(v18, &type, &v34)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_connection_receive_internal";
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v19 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v37 = "nw_connection_receive_internal";
          __int16 v38 = 2082;
          os_log_type_t v39 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_41:
        if (!v18) {
          goto LABEL_7;
        }
LABEL_42:
        free(v18);
        goto LABEL_7;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_connection_receive_internal";
        _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v19 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v37 = "nw_connection_receive_internal";
        _os_log_impl(&dword_1830D4000, v19, v29, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  if (v11)
  {
    id v13 = nw_read_request_create(a3, a4, v10, v9, v11);
    if (v13)
    {
      nw_connection_add_read_request(v9, v13);
    }
    else
    {
      BOOL v14 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 22);
      dispatch_qos_class_t v15 = v9[48];
      v31[0] = MEMORY[0x1E4F143A8];
      v31[1] = 3221225472;
      v31[2] = ___ZL30nw_connection_receive_internalP24NWConcrete_nw_connectionPU32objcproto21OS_nw_content_context8NSObjectjjU13block_pointerFvPU27objcproto16OS_dispatch_dataS1_S3_bPU22objcproto11OS_nw_errorS1_E_block_invoke;
      v31[3] = &unk_1E524B950;
      id v32 = v14;
      id v33 = v12;
      uint64_t v16 = v14;
      nw_connection_async_client_if_needed_with_override(v9, 0, v15, v31);
    }
    goto LABEL_7;
  }
  os_log_type_t v21 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v37 = "nw_connection_receive_internal";
  char v18 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (!__nwlog_fault(v18, &type, &v34)) {
    goto LABEL_41;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v19 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v19, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v37 = "nw_connection_receive_internal";
      _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s called with null completion", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (!v34)
  {
    int v19 = __nwlog_obj();
    os_log_type_t v30 = type;
    if (os_log_type_enabled(v19, type))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v37 = "nw_connection_receive_internal";
      _os_log_impl(&dword_1830D4000, v19, v30, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_40;
  }
  __int16 v26 = (char *)__nw_create_backtrace_string();
  int v19 = __nwlog_obj();
  os_log_type_t v27 = type;
  BOOL v28 = os_log_type_enabled(v19, type);
  if (!v26)
  {
    if (v28)
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v37 = "nw_connection_receive_internal";
      _os_log_impl(&dword_1830D4000, v19, v27, "%{public}s called with null completion, no backtrace", buf, 0xCu);
    }
    goto LABEL_40;
  }
  if (v28)
  {
    *(_DWORD *)buf = 136446466;
    os_log_type_t v37 = "nw_connection_receive_internal";
    __int16 v38 = 2082;
    os_log_type_t v39 = v26;
    _os_log_impl(&dword_1830D4000, v19, v27, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v26);
  if (v18) {
    goto LABEL_42;
  }
LABEL_7:
}

void sub_1831733AC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_read_request *nw_read_request_create(unint64_t a1, unint64_t a2, void *a3, void *a4, void *a5)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  id v10 = a3;
  id v11 = a4;
  id v12 = a5;
  id v13 = v12;
  if (a2) {
    BOOL v14 = a1 == 0;
  }
  else {
    BOOL v14 = 0;
  }
  if (v14) {
    unint64_t v15 = 1;
  }
  else {
    unint64_t v15 = a1;
  }
  if (!v12)
  {
    os_log_type_t v43 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_read_request_create";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (!__nwlog_fault(v17, &type, &v50)) {
      goto LABEL_54;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_read_request_create";
        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null completion", buf, 0xCu);
      }
    }
    else if (v50)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v47 = type;
      BOOL v48 = os_log_type_enabled(v44, type);
      if (backtrace_string)
      {
        if (v48)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v53 = "nw_read_request_create";
          __int16 v54 = 2082;
          uint64_t v55 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null completion, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_54;
      }
      if (v48)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_read_request_create";
        _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null completion, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v49 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v53 = "nw_read_request_create";
        _os_log_impl(&dword_1830D4000, v44, v49, "%{public}s called with null completion, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_54;
  }
  if (v15 <= a2)
  {
    if (v10)
    {
      os_log_type_t v20 = (os_unfair_lock_s *)v10;
      if (v20 == (os_unfair_lock_s *)&__block_literal_global_10_42276)
      {
      }
      else
      {
        os_log_type_t v21 = v20;
        if (v20 == (os_unfair_lock_s *)&__block_literal_global_8_42267
          || v20 == (os_unfair_lock_s *)&__block_literal_global_6_42258
          || v20 == (os_unfair_lock_s *)&__block_literal_global_42249)
        {

          goto LABEL_20;
        }
        os_unfair_lock_lock(v20 + 28);
        char v22 = BYTE2(v21[29]._os_unfair_lock_opaque);
        os_unfair_lock_unlock(v21 + 28);

        if ((v22 & 0x40) == 0)
        {
LABEL_20:
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v23 = (id)gLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)buf = 136446210;
            os_log_type_t v53 = "nw_read_request_create";
            _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s Cannot receive a reply for a protocol that does not support replies", buf, 0xCu);
          }

          goto LABEL_56;
        }
      }
    }
    os_log_type_t v27 = objc_alloc_init(NWConcrete_nw_read_request);
    if (v27)
    {
      BOOL v28 = _Block_copy(v13);
      id data_completion = v27->data_completion;
      v27->id data_completion = v28;

      objc_storeStrong((id *)&v27->connection, a4);
      v27->qos_class = qos_class_self();
      v27->min = v15;
      v27->max = a2;
      objc_storeStrong((id *)&v27->repliable_message, a3);
      v27->variant = 1;
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_52704);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
      os_log_type_t v30 = v27;
      goto LABEL_65;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v31 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v53 = "nw_read_request_create";
    id v32 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v50 = 0;
    if (__nwlog_fault(v32, &type, &v50))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v33 = (id)gLogObj;
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_read_request_create";
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed", buf, 0xCu);
        }
      }
      else if (v50)
      {
        os_log_type_t v36 = __nw_create_backtrace_string();
        if (v36)
        {
          os_log_type_t v37 = (char *)v36;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v38 = (id)gLogObj;
          os_log_type_t v39 = type;
          if (os_log_type_enabled(v38, type))
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v53 = "nw_read_request_create";
            __int16 v54 = 2082;
            uint64_t v55 = v37;
            _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v37);
          if (!v32) {
            goto LABEL_65;
          }
          goto LABEL_64;
        }
        id v33 = __nwlog_obj();
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_read_request_create";
          _os_log_impl(&dword_1830D4000, v33, v41, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v33 = (id)gLogObj;
        os_log_type_t v40 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v53 = "nw_read_request_create";
          _os_log_impl(&dword_1830D4000, v33, v40, "%{public}s [[NW_CONCRETE_CLASS_NAME(nw_read_request) alloc] init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v32)
    {
LABEL_65:

      goto LABEL_66;
    }
LABEL_64:
    free(v32);
    goto LABEL_65;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v16 = (id)gLogObj;
  *(_DWORD *)buf = 136446722;
  os_log_type_t v53 = "nw_read_request_create";
  __int16 v54 = 2048;
  uint64_t v55 = (char *)v15;
  __int16 v56 = 2048;
  unint64_t v57 = a2;
  uint64_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v50 = 0;
  if (__nwlog_fault(v17, &type, &v50))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v18 = (id)gLogObj;
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v53 = "nw_read_request_create";
        __int16 v54 = 2048;
        uint64_t v55 = (char *)v15;
        __int16 v56 = 2048;
        unint64_t v57 = a2;
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s minlength (%zu) > maxlength (%zu)", buf, 0x20u);
      }
    }
    else if (v50)
    {
      os_log_type_t v24 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v18 = (id)gLogObj;
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (v24)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446978;
          os_log_type_t v53 = "nw_read_request_create";
          __int16 v54 = 2048;
          uint64_t v55 = (char *)v15;
          __int16 v56 = 2048;
          unint64_t v57 = a2;
          __int16 v58 = 2082;
          BOOL v59 = v24;
          _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s minlength (%zu) > maxlength (%zu), dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v24);
        if (!v17) {
          goto LABEL_56;
        }
        goto LABEL_55;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v53 = "nw_read_request_create";
        __int16 v54 = 2048;
        uint64_t v55 = (char *)v15;
        __int16 v56 = 2048;
        unint64_t v57 = a2;
        _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s minlength (%zu) > maxlength (%zu), no backtrace", buf, 0x20u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      char v18 = (id)gLogObj;
      os_log_type_t v35 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446722;
        os_log_type_t v53 = "nw_read_request_create";
        __int16 v54 = 2048;
        uint64_t v55 = (char *)v15;
        __int16 v56 = 2048;
        unint64_t v57 = a2;
        _os_log_impl(&dword_1830D4000, v18, v35, "%{public}s minlength (%zu) > maxlength (%zu), backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
LABEL_54:
  if (v17) {
LABEL_55:
  }
    free(v17);
LABEL_56:
  os_log_type_t v27 = 0;
LABEL_66:

  return v27;
}

void sub_183173E0C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_add_read_request(void *a1, void *a2)
{
  BOOL v3 = a1;
  id v4 = a2;
  uint64_t v15 = 0;
  id v16 = &v15;
  uint64_t v17 = 0x2020000000;
  char v18 = 1;
  os_log_type_t v5 = v3 + 34;
  v11[0] = MEMORY[0x1E4F143A8];
  v11[1] = 3221225472;
  v11[2] = ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke;
  v11[3] = &unk_1E5242570;
  BOOL v6 = v3;
  id v12 = v6;
  id v7 = v4;
  id v13 = v7;
  BOOL v14 = &v15;
  os_unfair_lock_lock(v5);
  ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke((uint64_t)v11);
  os_unfair_lock_unlock(v5);
  if (*((unsigned char *)v16 + 24))
  {
    v8[0] = MEMORY[0x1E4F143A8];
    v8[1] = 3221225472;
    _DWORD v8[2] = ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke_2;
    v8[3] = &unk_1E524B9A0;
    nw_connection_t v9 = v6;
    id v10 = v7;
    nw_connection_async_if_needed(v9, v8);
  }
  _Block_object_dispose(&v15, 8);
}

void sub_183174268(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, void *a20,void *a21)
{
  _Block_object_dispose((const void *)(v23 - 96), 8);
  _Unwind_Resume(a1);
}

void nw_connection_async_if_needed(void *a1, void *a2)
{
  id v4 = a1;
  BOOL v3 = a2;
  if (v4[5] && !dispatch_workloop_is_current()) {
    dispatch_async(v4[4], v3);
  }
  else {
    v3[2](v3);
  }
}

void sub_183174330(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v1 + 109) & 0x20) != 0)
  {
    BOOL request_list_append = nw_read_request_list_append(*(void **)(v1 + 120), *(void **)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 32);
    os_log_type_t v5 = *(void **)(v4 + 120);
    *(void *)(v4 + 120) = request_list_append;

    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

void ___ZL30nw_connection_add_read_requestP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObject_block_invoke_2(uint64_t a1)
{
}

void nw_connection_add_read_request_on_queue(void *a1, void *a2, int a3)
{
  id v5 = a1;
  id v6 = a2;
  nw_context_assert_queue(*((void **)v5 + 3));
  uint64_t v12 = 0;
  id v13 = &v12;
  uint64_t v14 = 0x2020000000;
  char v15 = 0;
  v9[0] = MEMORY[0x1E4F143A8];
  v9[1] = 3221225472;
  v9[2] = ___ZL39nw_connection_add_read_request_on_queueP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObjectb_block_invoke;
  v9[3] = &unk_1E524B978;
  id v11 = &v12;
  id v7 = (void **)v5;
  id v10 = v7;
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 34);
  ___ZL39nw_connection_add_read_request_on_queueP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObjectb_block_invoke((uint64_t)v9);
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 34);
  if (*((unsigned char *)v13 + 24))
  {
    int v8 = 89;
LABEL_8:
    nw_read_request_fail(v6, v8);
    goto LABEL_9;
  }
  if (!nw_endpoint_handler_add_read_request(v7[18], v6))
  {
    int v8 = 57;
    goto LABEL_8;
  }
  if (a3 && (*((unsigned char *)v7 + 109) & 0x40) != 0) {
    nw_endpoint_handler_service_reads(v7[18]);
  }
LABEL_9:

  _Block_object_dispose(&v12, 8);
}

void sub_1831744F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_add_read_request(void *a1, void *a2)
{
  uint64_t v124 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    id v5 = (NWConcrete_nw_endpoint_handler *)v3;
    uint64_t mode = v5->mode;

    if (mode == 2)
    {
      id v7 = nw_endpoint_handler_copy_flow(v5);
      int v8 = v7;
      if ((*((unsigned char *)v7 + 35) & 2) != 0)
      {
        uint64_t v21 = *((void *)v7 + 117);
        if (!v21)
        {
          os_log_type_t v27 = v5;
          char v28 = *((unsigned char *)v27 + 268);

          if ((v28 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v29 = v27;

              os_log_type_t v30 = v29;
              char v31 = *((unsigned char *)v27 + 268);

              if (v31) {
                id v32 = "dry-run ";
              }
              else {
                id v32 = "";
              }
              nw_endpoint_t v33 = nw_endpoint_handler_copy_endpoint(v30);
              logging_description = nw_endpoint_get_logging_description(v33);
              id_str = v29->id_str;
              os_log_type_t v35 = v30;
              os_log_type_t v36 = v35;
              uint64_t v37 = v35[30];
              if (v37 > 5) {
                __int16 v38 = "unknown-state";
              }
              else {
                __int16 v38 = off_1E523FB38[v37];
              }
              __int16 v90 = v38;

              __int16 v54 = v36;
              uint64_t v55 = v54;
              int v56 = v5->mode;
              unint64_t v57 = "path";
              switch(v56)
              {
                case 0:
                  break;
                case 1:
                  unint64_t v57 = "resolver";
                  break;
                case 2:
                  unint64_t v57 = nw_endpoint_flow_mode_string(v54[31]);
                  break;
                case 3:
                  unint64_t v57 = "proxy";
                  break;
                case 4:
                  unint64_t v57 = "fallback";
                  break;
                case 5:
                  unint64_t v57 = "transform";
                  break;
                default:
                  unint64_t v57 = "unknown-mode";
                  break;
              }

              __int16 v69 = v55;
              os_unfair_lock_lock((os_unfair_lock_t)v69 + 28);
              id v70 = v69[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v69 + 28);

              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = id_str;
              *(_WORD *)&buf[22] = 2082;
              v109 = v32;
              __int16 v110 = 2082;
              v111 = logging_description;
              __int16 v112 = 2082;
              v113 = v90;
              __int16 v114 = 2082;
              v115 = v57;
              __int16 v116 = 2114;
              id v117 = v70;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive, no connected handler", buf, 0x48u);
            }
            goto LABEL_94;
          }
LABEL_112:
          BOOL v14 = 0;
          goto LABEL_96;
        }
        uint64_t request = nw_endpoint_handler_add_read_request(v21, v4);
      }
      else
      {
        if (*((void *)v7 + 96))
        {
          if (*((void *)v7 + 108))
          {
            nw_connection_t v9 = (id *)v4;
            id v10 = v9;
            if (v9)
            {
              id v11 = v9[18];

              if (v11)
              {
                if (v11 == &__block_literal_global_10_42276)
                {
                  *(void *)buf = 0;
                  *(void *)&uint8_t buf[8] = buf;
                  *(void *)&buf[16] = 0x2020000000;
                  LOBYTE(v109) = 0;
                  *(void *)os_log_type_t type = 0;
                  v104 = type;
                  uint64_t v105 = 0x2020000000;
                  char v106 = 0;
                  __int16 v58 = (char *)*((void *)v8 + 108);
                  v97[0] = MEMORY[0x1E4F143A8];
                  v97[1] = 3221225472;
                  v97[2] = __nw_endpoint_handler_add_read_request_block_invoke;
                  v97[3] = &unk_1E523C9C0;
                  __int16 v98 = v5;
                  BOOL v59 = v10;
                  id v99 = v59;
                  v101 = buf;
                  uint64_t v102 = type;
                  uint64_t v60 = v8;
                  __int16 v100 = v60;
                  nw_hash_table_apply(v58, (uint64_t)v97);
                  if (*(unsigned char *)(*(void *)&buf[8] + 24))
                  {
                    BOOL v14 = *((unsigned char *)v104 + 24) != 0;
                  }
                  else
                  {
                    BOOL request_list_append = nw_read_request_list_append(v60[89], v59);
                    int v68 = v60[89];
                    v60[89] = (void *)request_list_append;

                    BOOL v14 = 1;
                  }

                  _Block_object_dispose(type, 8);
                  _Block_object_dispose(buf, 8);
                  id v11 = &__block_literal_global_10_42276;
                  goto LABEL_95;
                }
                uint64_t node = nw_hash_table_get_node(*((void *)v8 + 108), (uint64_t)v11, 0);
                if (node
                  || (id repliable_metadata = nw_content_context_copy_first_repliable_metadata(v11)) != 0
                  && (uint64_t v66 = repliable_metadata,
                      uint64_t node = nw_hash_table_get_node(*((void *)v8 + 108), (uint64_t)repliable_metadata, 1),
                      v66,
                      node))
                {
                  id v13 = *(nw_flow_protocol **)(node + 16);
                  BOOL v14 = nw_flow_add_read_request(v5, (uint64_t)v13, v10);
                  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v5) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    v87 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v87, OS_LOG_TYPE_DEBUG))
                    {
                      id_string = nw_endpoint_handler_get_id_string(v5);
                      __int16 v92 = nw_endpoint_handler_dry_run_string(v5);
                      nw_endpoint_t v96 = nw_endpoint_handler_copy_endpoint(v5);
                      *(_DWORD *)buf = 136448514;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
                      *(_WORD *)&buf[12] = 2082;
                      *(void *)&buf[14] = id_string;
                      *(_WORD *)&buf[22] = 2082;
                      v109 = v92;
                      __int16 v110 = 2082;
                      v111 = nw_endpoint_get_logging_description(v96);
                      __int16 v112 = 2082;
                      v113 = nw_endpoint_handler_state_string(v5);
                      __int16 v114 = 2082;
                      v115 = nw_endpoint_handler_mode_string(v5);
                      __int16 v116 = 2114;
                      id v88 = nw_endpoint_handler_copy_current_path(v5);
                      id v117 = v88;
                      __int16 v118 = 2112;
                      v119 = v10;
                      __int16 v120 = 2048;
                      v121 = v13;
                      __int16 v122 = 1024;
                      BOOL v123 = v14;
                      _os_log_impl(&dword_1830D4000, v87, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Added read request %@ to flow protocol %p: %u", buf, 0x62u);
                    }
                  }
                  nw_flow_service_reads(v5, (NWConcrete_nw_endpoint_flow *)v8, v13, 0);
                  goto LABEL_95;
                }
                nw_read_request_fail(v10, 2);
                goto LABEL_94;
              }
LABEL_140:
              BOOL v14 = nw_flow_add_read_request(v5, (uint64_t)v8 + 376, v10);
              id v11 = 0;
              goto LABEL_95;
            }
            v80 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
            v81 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            char v107 = 0;
            if (__nwlog_fault(v81, type, &v107))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                id v82 = __nwlog_obj();
                os_log_type_t v83 = type[0];
                if (os_log_type_enabled(v82, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_1830D4000, v82, v83, "%{public}s called with null request", buf, 0xCu);
                }
              }
              else if (v107)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                id v82 = __nwlog_obj();
                os_log_type_t v85 = type[0];
                BOOL v86 = os_log_type_enabled(v82, type[0]);
                if (backtrace_string)
                {
                  if (v86)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                    *(_WORD *)&buf[12] = 2082;
                    *(void *)&buf[14] = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v82, v85, "%{public}s called with null request, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(backtrace_string);
                  goto LABEL_138;
                }
                if (v86)
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_1830D4000, v82, v85, "%{public}s called with null request, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                id v82 = __nwlog_obj();
                os_log_type_t v89 = type[0];
                if (os_log_type_enabled(v82, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  *(void *)&uint8_t buf[4] = "nw_read_request_copy_repliable_context";
                  _os_log_impl(&dword_1830D4000, v82, v89, "%{public}s called with null request, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_138:
            if (v81) {
              free(v81);
            }
            goto LABEL_140;
          }
          os_log_type_t v41 = v5;
          char v42 = *((unsigned char *)v41 + 268);

          if ((v42 & 0x20) == 0)
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
            {
              os_log_type_t v43 = v41;

              os_log_type_t v44 = v43;
              char v45 = *((unsigned char *)v41 + 268);

              if (v45) {
                char v46 = "dry-run ";
              }
              else {
                char v46 = "";
              }
              nw_endpoint_t v47 = nw_endpoint_handler_copy_endpoint(v44);
              BOOL v48 = nw_endpoint_get_logging_description(v47);
              __int16 v94 = v43->id_str;
              os_log_type_t v49 = v44;
              char v50 = v49;
              uint64_t v51 = v49[30];
              if (v51 > 5) {
                uint64_t v52 = "unknown-state";
              }
              else {
                uint64_t v52 = off_1E523FB38[v51];
              }
              v91 = v52;

              BOOL v61 = v50;
              BOOL v62 = v61;
              int v63 = v5->mode;
              BOOL v64 = "path";
              switch(v63)
              {
                case 0:
                  break;
                case 1:
                  BOOL v64 = "resolver";
                  break;
                case 2:
                  BOOL v64 = nw_endpoint_flow_mode_string(v61[31]);
                  break;
                case 3:
                  BOOL v64 = "proxy";
                  break;
                case 4:
                  BOOL v64 = "fallback";
                  break;
                case 5:
                  BOOL v64 = "transform";
                  break;
                default:
                  BOOL v64 = "unknown-mode";
                  break;
              }

              __int16 v71 = v62;
              os_unfair_lock_lock((os_unfair_lock_t)v71 + 28);
              id v72 = v71[8];
              os_unfair_lock_unlock((os_unfair_lock_t)v71 + 28);

              *(_DWORD *)buf = 136447746;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v94;
              *(_WORD *)&buf[22] = 2082;
              v109 = v46;
              __int16 v110 = 2082;
              v111 = v48;
              __int16 v112 = 2082;
              v113 = v91;
              __int16 v114 = 2082;
              v115 = v64;
              __int16 v116 = 2114;
              id v117 = v72;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Cannot receive after flow table is released", buf, 0x48u);
            }
LABEL_94:
            BOOL v14 = 0;
LABEL_95:

            goto LABEL_96;
          }
          goto LABEL_112;
        }
        uint64_t request = nw_flow_add_read_request(v5, (uint64_t)v7 + 376, v4);
      }
      BOOL v14 = request;
LABEL_96:

      goto LABEL_97;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = (id)gLogObj;
    if (mode > 5) {
      id v16 = "unknown-mode";
    }
    else {
      id v16 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = v16;
    *(_WORD *)&buf[22] = 2082;
    v109 = "flow";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (__nwlog_fault(v17, type, &v107))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (id)gLogObj;
        os_log_type_t v19 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          if (mode > 5) {
            os_log_type_t v20 = "unknown-mode";
          }
          else {
            os_log_type_t v20 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v20;
          *(_WORD *)&buf[22] = 2082;
          v109 = "flow";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v107)
      {
        uint64_t v23 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (id)gLogObj;
        os_log_type_t v24 = type[0];
        BOOL v25 = os_log_type_enabled(v18, type[0]);
        if (v23)
        {
          if (v25)
          {
            if (mode > 5) {
              BOOL v26 = "unknown-mode";
            }
            else {
              BOOL v26 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v26;
            *(_WORD *)&buf[22] = 2082;
            v109 = "flow";
            __int16 v110 = 2082;
            v111 = v23;
            _os_log_impl(&dword_1830D4000, v18, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v23);
          if (!v17) {
            goto LABEL_73;
          }
          goto LABEL_72;
        }
        if (v25)
        {
          if (mode > 5) {
            os_log_type_t v53 = "unknown-mode";
          }
          else {
            os_log_type_t v53 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v53;
          *(_WORD *)&buf[22] = 2082;
          v109 = "flow";
          _os_log_impl(&dword_1830D4000, v18, v24, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v18 = (id)gLogObj;
        os_log_type_t v39 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          if (mode > 5) {
            os_log_type_t v40 = "unknown-mode";
          }
          else {
            os_log_type_t v40 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v40;
          *(_WORD *)&buf[22] = 2082;
          v109 = "flow";
          _os_log_impl(&dword_1830D4000, v18, v39, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
LABEL_70:
    }
  }
  else
  {
    uint64_t v74 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
    uint64_t v17 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (__nwlog_fault(v17, type, &v107))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        char v18 = __nwlog_obj();
        os_log_type_t v75 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_1830D4000, v18, v75, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v107)
      {
        v76 = (char *)__nw_create_backtrace_string();
        char v18 = __nwlog_obj();
        os_log_type_t v77 = type[0];
        BOOL v78 = os_log_type_enabled(v18, type[0]);
        if (v76)
        {
          if (v78)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v76;
            _os_log_impl(&dword_1830D4000, v18, v77, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v76);
          if (!v17) {
            goto LABEL_73;
          }
          goto LABEL_72;
        }
        if (v78)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_1830D4000, v18, v77, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v18 = __nwlog_obj();
        os_log_type_t v79 = type[0];
        if (os_log_type_enabled(v18, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_add_read_request";
          _os_log_impl(&dword_1830D4000, v18, v79, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
      goto LABEL_70;
    }
  }
  if (v17) {
LABEL_72:
  }
    free(v17);
LABEL_73:
  BOOL v14 = 0;
LABEL_97:

  return v14;
}

void sub_183175564(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL39nw_connection_add_read_request_on_queueP24NWConcrete_nw_connectionPU29objcproto18OS_nw_read_request8NSObjectb_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = (*(unsigned char *)(*(void *)(result + 32) + 109) & 8) != 0;
  return result;
}

void sub_183175658(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_read_request;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

void ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke(uint64_t a1)
{
  uint64_t v1 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v1 + 109) & 0x20) != 0)
  {
    BOOL v3 = nw_write_request_list_append(*(void **)(v1 + 112), *(void **)(a1 + 40));
    uint64_t v4 = *(void *)(a1 + 32);
    id v5 = *(void **)(v4 + 112);
    *(void *)(v4 + 112) = v3;

    *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 0;
  }
}

void ___ZL31nw_connection_add_write_requestP24NWConcrete_nw_connectionPU30objcproto19OS_nw_write_request8NSObject_block_invoke_2(uint64_t a1)
{
}

void sub_18317573C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, objc_super a9)
{
  a9.super_class = (Class)NWConcrete_nw_write_request;
  [(_Unwind_Exception *)&a9 dealloc];
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_connection_set_cancelledP24NWConcrete_nw_connection_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 109) |= 8u;
  return result;
}

void __nw_connection_set_write_close_handler_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void **)(a1 + 40);
  id v2 = *(id *)(*(void *)(a1 + 32) + 144);
  id v3 = v1;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v31 = "nw_endpoint_handler_set_write_close_handler";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (id)gLogObj;
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (id)gLogObj;
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_write_close_handler";
          _os_log_impl(&dword_1830D4000, v12, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        char v31 = "nw_endpoint_handler_set_write_close_handler";
        __int16 v32 = 2082;
        nw_endpoint_t v33 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_36:
    if (!v11) {
      goto LABEL_38;
    }
LABEL_37:
    free(v11);
    goto LABEL_38;
  }
  uint64_t v4 = (NWConcrete_nw_endpoint_handler *)v2;
  uint64_t mode = v4->mode;

  if (mode == 2)
  {
    id v6 = nw_endpoint_handler_copy_flow(v4);
    id v7 = _Block_copy(v3);
    int v8 = (void *)*((void *)v6 + 107);
    *((void *)v6 + 107) = v7;

    goto LABEL_38;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v9 = (id)gLogObj;
  if (mode > 5) {
    id v10 = "unknown-mode";
  }
  else {
    id v10 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  char v31 = "nw_endpoint_handler_set_write_close_handler";
  __int16 v32 = 2082;
  nw_endpoint_t v33 = (void *)v10;
  __int16 v34 = 2082;
  os_log_type_t v35 = "flow";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (!__nwlog_fault(v11, &type, &v28)) {
    goto LABEL_36;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (id)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5) {
        BOOL v14 = "unknown-mode";
      }
      else {
        BOOL v14 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v31 = "nw_endpoint_handler_set_write_close_handler";
      __int16 v32 = 2082;
      nw_endpoint_t v33 = (void *)v14;
      __int16 v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (id)gLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5) {
        os_log_type_t v20 = "unknown-mode";
      }
      else {
        os_log_type_t v20 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v31 = "nw_endpoint_handler_set_write_close_handler";
      __int16 v32 = 2082;
      nw_endpoint_t v33 = (void *)v20;
      __int16 v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_35;
  }
  id v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v12 = (id)gLogObj;
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v12, type);
  if (!v15)
  {
    if (v17)
    {
      if (mode > 5) {
        uint64_t v21 = "unknown-mode";
      }
      else {
        uint64_t v21 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v31 = "nw_endpoint_handler_set_write_close_handler";
      __int16 v32 = 2082;
      nw_endpoint_t v33 = (void *)v21;
      __int16 v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl(&dword_1830D4000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_35;
  }
  if (v17)
  {
    if (mode > 5) {
      char v18 = "unknown-mode";
    }
    else {
      char v18 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    char v31 = "nw_endpoint_handler_set_write_close_handler";
    __int16 v32 = 2082;
    nw_endpoint_t v33 = (void *)v18;
    __int16 v34 = 2082;
    os_log_type_t v35 = "flow";
    __int16 v36 = 2082;
    uint64_t v37 = v15;
    _os_log_impl(&dword_1830D4000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v15);
  if (v11) {
    goto LABEL_37;
  }
LABEL_38:
}

void sub_183175E64(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_viability_changed_handler_block_invoke(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 232);
  *(void *)(v3 + 232) = v2;
}

void __nw_connection_set_read_close_handler_block_invoke(uint64_t a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = *(void **)(a1 + 40);
  id v2 = *(id *)(*(void *)(a1 + 32) + 144);
  id v3 = v1;
  if (!v2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    char v31 = "nw_endpoint_handler_set_read_close_handler";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (!v28)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v12 = (id)gLogObj;
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_1830D4000, v12, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_35;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = (id)gLogObj;
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          char v31 = "nw_endpoint_handler_set_read_close_handler";
          _os_log_impl(&dword_1830D4000, v12, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_35;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        char v31 = "nw_endpoint_handler_set_read_close_handler";
        __int16 v32 = 2082;
        nw_endpoint_t v33 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
    }
LABEL_36:
    if (!v11) {
      goto LABEL_38;
    }
LABEL_37:
    free(v11);
    goto LABEL_38;
  }
  uint64_t v4 = (NWConcrete_nw_endpoint_handler *)v2;
  uint64_t mode = v4->mode;

  if (mode == 2)
  {
    id v6 = nw_endpoint_handler_copy_flow(v4);
    id v7 = _Block_copy(v3);
    int v8 = (void *)*((void *)v6 + 106);
    *((void *)v6 + 106) = v7;

    goto LABEL_38;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v9 = (id)gLogObj;
  if (mode > 5) {
    id v10 = "unknown-mode";
  }
  else {
    id v10 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  char v31 = "nw_endpoint_handler_set_read_close_handler";
  __int16 v32 = 2082;
  nw_endpoint_t v33 = (void *)v10;
  __int16 v34 = 2082;
  os_log_type_t v35 = "flow";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (!__nwlog_fault(v11, &type, &v28)) {
    goto LABEL_36;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (id)gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5) {
        BOOL v14 = "unknown-mode";
      }
      else {
        BOOL v14 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v31 = "nw_endpoint_handler_set_read_close_handler";
      __int16 v32 = 2082;
      nw_endpoint_t v33 = (void *)v14;
      __int16 v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!v28)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = (id)gLogObj;
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v12, type))
    {
      if (mode > 5) {
        os_log_type_t v20 = "unknown-mode";
      }
      else {
        os_log_type_t v20 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v31 = "nw_endpoint_handler_set_read_close_handler";
      __int16 v32 = 2082;
      nw_endpoint_t v33 = (void *)v20;
      __int16 v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_35;
  }
  id v15 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v12 = (id)gLogObj;
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v12, type);
  if (!v15)
  {
    if (v17)
    {
      if (mode > 5) {
        uint64_t v21 = "unknown-mode";
      }
      else {
        uint64_t v21 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      char v31 = "nw_endpoint_handler_set_read_close_handler";
      __int16 v32 = 2082;
      nw_endpoint_t v33 = (void *)v21;
      __int16 v34 = 2082;
      os_log_type_t v35 = "flow";
      _os_log_impl(&dword_1830D4000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_35;
  }
  if (v17)
  {
    if (mode > 5) {
      char v18 = "unknown-mode";
    }
    else {
      char v18 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    char v31 = "nw_endpoint_handler_set_read_close_handler";
    __int16 v32 = 2082;
    nw_endpoint_t v33 = (void *)v18;
    __int16 v34 = 2082;
    os_log_type_t v35 = "flow";
    __int16 v36 = 2082;
    uint64_t v37 = v15;
    _os_log_impl(&dword_1830D4000, v12, v16, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v15);
  if (v11) {
    goto LABEL_37;
  }
LABEL_38:
}

void sub_1831765A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_set_alternate_path_state_handler_block_invoke(uint64_t a1)
{
  id v2 = _Block_copy(*(const void **)(a1 + 40));
  uint64_t v3 = *(void *)(a1 + 32);
  uint64_t v4 = *(void **)(v3 + 248);
  *(void *)(v3 + 248) = v2;
}

void __nw_connection_modify_estimated_bytes_block_invoke(uint64_t a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  unint64_t v3 = *(void *)(a1 + 40);
  if (!*(unsigned char *)(a1 + 48))
  {
    unint64_t v4 = *(void *)(v2 + 304);
    if (*(unsigned char *)(a1 + 49))
    {
      *(void *)(v2 + 304) = v4 + v3;
      if (!__CFADD__(v4, v3)) {
        goto LABEL_22;
      }
      if (!gLogDatapath)
      {
        uint64_t v5 = -1;
LABEL_20:
        id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
        goto LABEL_21;
      }
      uint64_t v38 = __nwlog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v41 = *(void *)(a1 + 40);
        uint64_t v42 = *(void *)(*(void *)(a1 + 32) + 304);
        int v47 = 136446978;
        BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        __int16 v49 = 2082;
        *(void *)char v50 = "connection->estimated_bytes_upload";
        *(_WORD *)&v50[8] = 2048;
        *(void *)&v50[10] = v41;
        *(_WORD *)&v50[18] = 2048;
        *(void *)&v50[20] = v42;
        _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", (uint8_t *)&v47, 0x2Au);
      }
      uint64_t v5 = -1;
    }
    else
    {
      *(void *)(v2 + 304) = v4 - v3;
      if (v4 >= v3)
      {
LABEL_22:
        id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
        goto LABEL_23;
      }
      if (!gLogDatapath)
      {
        uint64_t v5 = 0;
        goto LABEL_20;
      }
      uint64_t v38 = __nwlog_obj();
      if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v45 = *(void *)(a1 + 40);
        uint64_t v46 = *(void *)(*(void *)(a1 + 32) + 304);
        int v47 = 136446978;
        BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        __int16 v49 = 2082;
        *(void *)char v50 = "connection->estimated_bytes_upload";
        *(_WORD *)&v50[8] = 2048;
        *(void *)&v50[10] = v45;
        *(_WORD *)&v50[18] = 2048;
        *(void *)&v50[20] = v46;
        _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)&v47, 0x2Au);
      }
      uint64_t v5 = 0;
    }
    id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
    goto LABEL_87;
  }
  unint64_t v4 = *(void *)(v2 + 296);
  if (*(unsigned char *)(a1 + 49))
  {
    *(void *)(v2 + 296) = v4 + v3;
    if (!__CFADD__(v4, v3)) {
      goto LABEL_16;
    }
    if (!gLogDatapath)
    {
      uint64_t v5 = -1;
LABEL_15:
      id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_21:
      *(void *)(*(void *)(a1 + 32) + *v6) = v5;
      goto LABEL_23;
    }
    uint64_t v38 = __nwlog_obj();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v39 = *(void *)(a1 + 40);
      uint64_t v40 = *(void *)(*(void *)(a1 + 32) + 296);
      int v47 = 136446978;
      BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      __int16 v49 = 2082;
      *(void *)char v50 = "connection->estimated_bytes_download";
      *(_WORD *)&v50[8] = 2048;
      *(void *)&v50[10] = v39;
      *(_WORD *)&v50[18] = 2048;
      *(void *)&v50[20] = v40;
      _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Overflow: %{public}s, increment %llu, result %llu", (uint8_t *)&v47, 0x2Au);
    }
    uint64_t v5 = -1;
LABEL_82:
    id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_87:

    goto LABEL_21;
  }
  *(void *)(v2 + 296) = v4 - v3;
  if (v4 < v3)
  {
    if (!gLogDatapath)
    {
      uint64_t v5 = 0;
      goto LABEL_15;
    }
    uint64_t v38 = __nwlog_obj();
    if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v43 = *(void *)(a1 + 40);
      uint64_t v44 = *(void *)(*(void *)(a1 + 32) + 296);
      int v47 = 136446978;
      BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      __int16 v49 = 2082;
      *(void *)char v50 = "connection->estimated_bytes_download";
      *(_WORD *)&v50[8] = 2048;
      *(void *)&v50[10] = v43;
      *(_WORD *)&v50[18] = 2048;
      *(void *)&v50[20] = v44;
      _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s Underflow: %{public}s, decrement %llu, result %llu", (uint8_t *)&v47, 0x2Au);
    }
    uint64_t v5 = 0;
    goto LABEL_82;
  }
LABEL_16:
  id v6 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
LABEL_23:
  uint64_t v7 = *(void *)(a1 + 32);
  unint64_t v8 = *(void *)(v7 + *v6);
  uint64_t v9 = *(void *)(v7 + 16);
  if (v9 && !nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v10 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      uint64_t v12 = *(void *)(a1 + 40);
      int v13 = *(_DWORD *)(v11 + 448);
      if (*(unsigned char *)(a1 + 49)) {
        BOOL v14 = "Incremented";
      }
      else {
        BOOL v14 = "Decremented";
      }
      BOOL v15 = *(unsigned char *)(a1 + 48) == 0;
      os_log_type_t v16 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_download;
      if (!*(unsigned char *)(a1 + 48)) {
        os_log_type_t v16 = &OBJC_IVAR___NWConcrete_nw_connection_estimated_bytes_upload;
      }
      uint64_t v17 = *(void *)(v11 + *v16);
      char v18 = "receive";
      int v47 = 136447490;
      BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      __int16 v49 = 1024;
      if (v15) {
        char v18 = "send";
      }
      *(_DWORD *)char v50 = v13;
      *(_WORD *)&v50[4] = 2080;
      *(void *)&v50[6] = v14;
      *(_WORD *)&v50[14] = 2080;
      *(void *)&v50[16] = v18;
      *(_WORD *)&v50[24] = 2048;
      *(void *)&v50[26] = v12;
      __int16 v51 = 2048;
      uint64_t v52 = v17;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] %s estimated bytes to %s by %llu, total now %llu", (uint8_t *)&v47, 0x3Au);
    }
  }
  unint64_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_estimated_byte_threshold_lower, 12582912);
  unint64_t v20 = networkd_settings_get_int64_with_default((const char *)nw_setting_estimated_byte_threshold_upper, 31457280);
  uint64_t v21 = *(void *)(*(void *)(a1 + 32) + 16);
  if (v21 && !nw_path_parameters_get_logging_disabled(*(void *)(v21 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v22 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v22, OS_LOG_TYPE_DEBUG))
    {
      int v23 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v47 = 136446978;
      BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
      __int16 v49 = 1024;
      *(_DWORD *)char v50 = v23;
      *(_WORD *)&v50[4] = 2048;
      *(void *)&v50[6] = int64_with_default;
      *(_WORD *)&v50[14] = 2048;
      *(void *)&v50[16] = v20;
      _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Using lower threshold %llu, upper threshold %llu", (uint8_t *)&v47, 0x26u);
    }
  }
  BOOL v24 = v4 < int64_with_default && v8 > int64_with_default;
  if (v24 || (v4 > int64_with_default ? (BOOL v25 = v8 >= int64_with_default) : (BOOL v25 = 1), !v25))
  {
    uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 16);
    if (v26 && !nw_path_parameters_get_logging_disabled(*(void *)(v26 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v27 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v27, OS_LOG_TYPE_INFO))
      {
        uint64_t v28 = *(void *)(a1 + 32);
        int v29 = *(_DWORD *)(v28 + 448);
        uint64_t v31 = *(void *)(v28 + 296);
        uint64_t v30 = *(void *)(v28 + 304);
        int v47 = 136446978;
        BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        __int16 v49 = 1024;
        *(_DWORD *)char v50 = v29;
        *(_WORD *)&v50[4] = 2048;
        *(void *)&v50[6] = v31;
        *(_WORD *)&v50[14] = 2048;
        *(void *)&v50[16] = v30;
        _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_INFO, "%{public}s [C%u] Crossed lower estimated byte threshold, sending notification (down: %llu, up: %llu)", (uint8_t *)&v47, 0x26u);
      }
    }
    nw_connection_report_estimated_byte_threshold_change_on_queue(*(NWConcrete_nw_connection **)(a1 + 32), v8, *(unsigned __int8 *)(a1 + 48), v8 > int64_with_default, 0);
  }
  if (v4 < v20 && v8 > v20 || v4 > v20 && v8 < v20)
  {
    uint64_t v32 = *(void *)(*(void *)(a1 + 32) + 16);
    if (v32 && !nw_path_parameters_get_logging_disabled(*(void *)(v32 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      nw_endpoint_t v33 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v33, OS_LOG_TYPE_INFO))
      {
        uint64_t v34 = *(void *)(a1 + 32);
        int v35 = *(_DWORD *)(v34 + 448);
        uint64_t v37 = *(void *)(v34 + 296);
        uint64_t v36 = *(void *)(v34 + 304);
        int v47 = 136446978;
        BOOL v48 = "nw_connection_modify_estimated_bytes_block_invoke";
        __int16 v49 = 1024;
        *(_DWORD *)char v50 = v35;
        *(_WORD *)&v50[4] = 2048;
        *(void *)&v50[6] = v37;
        *(_WORD *)&v50[14] = 2048;
        *(void *)&v50[16] = v36;
        _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_INFO, "%{public}s [C%u] Crossed upper estimated byte threshold, sending notification (down: %llu, up: %llu)", (uint8_t *)&v47, 0x26u);
      }
    }
    nw_connection_report_estimated_byte_threshold_change_on_queue(*(NWConcrete_nw_connection **)(a1 + 32), v8, *(unsigned __int8 *)(a1 + 48), v8 > v20, 1);
  }
}

id nw_content_context_copy_first_repliable_metadata(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = 0;
    if (v1 != (os_unfair_lock_s *)&__block_literal_global_10_42276
      && v1 != (os_unfair_lock_s *)&__block_literal_global_8_42267
      && v1 != (os_unfair_lock_s *)&__block_literal_global_6_42258
      && v1 != (os_unfair_lock_s *)&__block_literal_global_42249)
    {
      os_unfair_lock_lock(v1 + 28);
      *(void *)buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      char v18 = __Block_byref_object_copy__42473;
      os_log_type_t v19 = __Block_byref_object_dispose__42474;
      id v20 = 0;
      unint64_t v4 = *(atomic_uchar **)&v2[22]._os_unfair_lock_opaque;
      v14[0] = MEMORY[0x1E4F143A8];
      v14[1] = 3221225472;
      v14[2] = __nw_content_context_copy_first_repliable_metadata_block_invoke;
      v14[3] = &unk_1E5248058;
      void v14[4] = buf;
      nw_array_apply(v4, (uint64_t)v14);
      os_unfair_lock_unlock(v2 + 28);
      id v3 = *(id *)(*(void *)&buf[8] + 40);
      _Block_object_dispose(buf, 8);
    }
    goto LABEL_7;
  }
  id v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_content_context_copy_first_repliable_metadata";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v7, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      unint64_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_copy_first_repliable_metadata";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unint64_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_content_context_copy_first_repliable_metadata";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_copy_first_repliable_metadata";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unint64_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_content_context_copy_first_repliable_metadata";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v7) {
    free(v7);
  }
  id v3 = 0;
LABEL_7:

  return v3;
}

void __nw_connection_unregister_context_block_invoke(uint64_t a1)
{
  uint64_t v12 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    id v6 = *(void **)(v2 + 144);
    uint64_t v7 = *(void **)(a1 + 40);
    nw_endpoint_handler_unregister_context(v6, v7);
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unint64_t v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        int v8 = 136446466;
        os_log_type_t v9 = "nw_connection_unregister_context_block_invoke";
        __int16 v10 = 1024;
        int v11 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot unregister a context on a connection that is not ready", (uint8_t *)&v8, 0x12u);
      }
    }
  }
}

void nw_connection_initial_data_transfer_report_snapshot_on_nw_queue(void *a1, void *a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  int v5 = v4;
  if (!v3)
  {
    os_log_type_t v19 = __nwlog_obj();
    LODWORD(aBlock[0]) = 136446210;
    *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
    id v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (!__nwlog_fault(v20, type, &v33)) {
      goto LABEL_61;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s called with null connection", (uint8_t *)aBlock, 0xCu);
      }
    }
    else if ((_BYTE)v33)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v26 = type[0];
      BOOL v27 = os_log_type_enabled(v21, type[0]);
      if (backtrace_string)
      {
        if (v27)
        {
          LODWORD(aBlock[0]) = 136446466;
          *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
          WORD6(aBlock[0]) = 2082;
          *(void *)((char *)aBlock + 14) = backtrace_string;
          _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null connection, dumping backtrace:%{public}s", (uint8_t *)aBlock, 0x16u);
        }

        free(backtrace_string);
LABEL_61:
        if (!v20) {
          goto LABEL_23;
        }
        goto LABEL_62;
      }
      if (v27)
      {
        LODWORD(aBlock[0]) = 136446210;
        *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v21, v26, "%{public}s called with null connection, no backtrace", (uint8_t *)aBlock, 0xCu);
      }
    }
    else
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v31 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v21, v31, "%{public}s called with null connection, backtrace limit exceeded", (uint8_t *)aBlock, 0xCu);
      }
    }
LABEL_60:

    goto LABEL_61;
  }
  if (!v4)
  {
    int v23 = __nwlog_obj();
    LODWORD(aBlock[0]) = 136446210;
    *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
    id v20 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v33) = 0;
    if (!__nwlog_fault(v20, type, &v33)) {
      goto LABEL_61;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v24 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v21, v24, "%{public}s called with null report", (uint8_t *)aBlock, 0xCu);
      }
    }
    else if ((_BYTE)v33)
    {
      uint64_t v28 = (char *)__nw_create_backtrace_string();
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      BOOL v30 = os_log_type_enabled(v21, type[0]);
      if (v28)
      {
        if (v30)
        {
          LODWORD(aBlock[0]) = 136446466;
          *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
          WORD6(aBlock[0]) = 2082;
          *(void *)((char *)aBlock + 14) = v28;
          _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null report, dumping backtrace:%{public}s", (uint8_t *)aBlock, 0x16u);
        }

        free(v28);
        if (!v20) {
          goto LABEL_23;
        }
LABEL_62:
        free(v20);
        goto LABEL_23;
      }
      if (v30)
      {
        LODWORD(aBlock[0]) = 136446210;
        *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v21, v29, "%{public}s called with null report, no backtrace", (uint8_t *)aBlock, 0xCu);
      }
    }
    else
    {
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v32 = type[0];
      if (os_log_type_enabled(v21, type[0]))
      {
        LODWORD(aBlock[0]) = 136446210;
        *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v21, v32, "%{public}s called with null report, backtrace limit exceeded", (uint8_t *)aBlock, 0xCu);
      }
    }
    goto LABEL_60;
  }
  nw_context_assert_queue(v3[3]);
  if ((*((unsigned char *)v3 + 109) & 0x40) != 0)
  {
    id v6 = nw_endpoint_handler_copy_connected_flow_handler(v3[18]);
    if (v6)
    {
      uint64_t v7 = mach_continuous_time();
      if (v7 <= 1) {
        uint64_t v8 = 1;
      }
      else {
        uint64_t v8 = v7;
      }
      os_log_type_t v9 = v5;
      *(void *)&aBlock[0] = MEMORY[0x1E4F143A8];
      *((void *)&aBlock[0] + 1) = 3221225472;
      *(void *)&aBlock[1] = __nw_data_transfer_set_initial_snapshot_time_block_invoke;
      *((void *)&aBlock[1] + 1) = &unk_1E52491B0;
      __int16 v10 = v9;
      *(void *)&long long v37 = v10;
      *((void *)&v37 + 1) = v8;
      int v11 = (void (**)(void))_Block_copy(aBlock);
      v9 += 10;
      os_unfair_lock_lock(v9);
      v11[2](v11);
      os_unfair_lock_unlock(v9);

      char v35 = 0;
      nw_endpoint_t v33 = 0;
      *(void *)os_log_type_t type = 0;
      nw_connection_fillout_data_transfer_snapshot_on_nw_queue(v3, (uint64_t *)&v33, type, &v35, 1);
      uint64_t v12 = v6;
      os_unfair_lock_lock(&v12->lock);
      os_log_type_t v13 = v12->current_path;
      os_unfair_lock_unlock(&v12->lock);

      id v14 = nw_path_copy_interface(v13);
      if (v14)
      {
        if (v33 && __ROR8__(0xD37A6F4DE9BD37A7 * *(void *)type, 3) <= 0x1642C8590B21642uLL)
        {
          if (*(void *)type >= 0xB8uLL)
          {
            uint64_t v17 = 0;
            unint64_t v18 = 0;
            do
            {
              nw_data_transfer_add_initial_snapshot(v10, v14, (NWConcrete_nw_interface **)((char *)v33 + v17));
              ++v18;
              v17 += 184;
            }
            while (v18 < *(void *)type / 0xB8uLL);
          }
        }
        else
        {
          uint64_t v46 = 0;
          long long v44 = 0u;
          long long v45 = 0u;
          long long v42 = 0u;
          long long v43 = 0u;
          long long v40 = 0u;
          long long v41 = 0u;
          long long v38 = 0u;
          long long v39 = 0u;
          long long v37 = 0u;
          memset(aBlock, 0, sizeof(aBlock));
          nw_data_transfer_add_initial_snapshot(v10, v14, (NWConcrete_nw_interface **)aBlock);
        }
      }
      if (v35 && v33)
      {
        free(v33);
        nw_endpoint_t v33 = 0;
      }

LABEL_22:
      goto LABEL_23;
    }
  }
  char v15 = v3[2];
  if (v15 && !nw_path_parameters_get_logging_disabled(v15[13]))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v12 = (NWConcrete_nw_endpoint_handler *)(id)gconnectionLogObj;
    if (os_log_type_enabled(&v12->super, OS_LOG_TYPE_ERROR))
    {
      int v16 = *((_DWORD *)v3 + 112);
      LODWORD(aBlock[0]) = 136446466;
      *(void *)((char *)aBlock + 4) = "nw_connection_initial_data_transfer_report_snapshot_on_nw_queue";
      WORD6(aBlock[0]) = 1024;
      *(_DWORD *)((char *)aBlock + 14) = v16;
      _os_log_impl(&dword_1830D4000, &v12->super, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot snapshot data transfer report without a connected endpoint handler", (uint8_t *)aBlock, 0x12u);
    }
    goto LABEL_22;
  }
LABEL_23:
}

void sub_1831779C8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_data_transfer_set_initial_snapshot_time_block_invoke(uint64_t result)
{
  *(void *)(*(void *)(result + 32) + 8) = *(void *)(result + 40);
  return result;
}

void __nw_connection_add_data_transfer_report_block_invoke(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if (*(int *)(v2 + 80) < 4)
  {
    uint64_t v6 = *(void *)(v2 + 424);
    if (!v6)
    {
      BOOL v7 = nw_array_create();
      uint64_t v8 = *(void *)(a1 + 32);
      os_log_type_t v9 = *(void **)(v8 + 424);
      *(void *)(v8 + 424) = v7;

      uint64_t v6 = *(void *)(*(void *)(a1 + 32) + 424);
    }
    nw_array_append(v6, *(void **)(a1 + 40));
    __int16 v10 = *(_DWORD **)(a1 + 32);
    if (v10[20] == 3)
    {
      int v11 = *(void **)(a1 + 40);
      nw_connection_initial_data_transfer_report_snapshot_on_nw_queue(v10, v11);
    }
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        int v12 = 136446466;
        os_log_type_t v13 = "nw_connection_add_data_transfer_report_block_invoke";
        __int16 v14 = 1024;
        int v15 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Cannot add data transfer report to connection past the ready state", (uint8_t *)&v12, 0x12u);
      }
    }
  }
}

uint64_t nw_libnetwork_library_initializer(void)
{
  si_set_nat64_v4_requires_synthesis();
  si_set_nat64_v4_synthesize();

  return MEMORY[0x1F40CE010](nw_path_libinfo_path_check);
}

const char *nw_endpoint_get_description(void *a1)
{
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v8 = 0;
    os_log_type_t v9 = &v8;
    uint64_t v10 = 0x2020000000;
    uint64_t v11 = 0;
    v5[0] = MEMORY[0x1E4F143A8];
    v5[1] = 3221225472;
    v5[2] = __nw_endpoint_get_description_block_invoke;
    v5[3] = &unk_1E524B978;
    uint64_t v6 = v1;
    BOOL v7 = &v8;
    os_unfair_lock_lock(v2 + 45);
    __nw_endpoint_get_description_block_invoke((uint64_t)v5);
    os_unfair_lock_unlock(v2 + 45);
    uint64_t v3 = (const char *)v9[3];

    _Block_object_dispose(&v8, 8);
  }
  else
  {
    uint64_t v3 = "<NULL>";
  }

  return v3;
}

uint64_t nw_parameters_get_tls(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (void *)*((void *)v1 + 19);
    id v4 = (void *)nw_protocol_boringssl_copy_definition();
    uint64_t v5 = nw_protocol_stack_includes_protocol(v3, v4);

    goto LABEL_3;
  }
  BOOL v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unint64_t v18 = "nw_parameters_get_tls";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          unint64_t v18 = "nw_parameters_get_tls";
          __int16 v19 = 2082;
          id v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        unint64_t v18 = "nw_parameters_get_tls";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0;
LABEL_3:

  return v5;
}

void sub_183177FFC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL33nw_endpoint_flow_expected_to_joinP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flow_block_invoke(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v122 = *MEMORY[0x1E4F143B8];
  id v7 = a3;
  id v8 = a4;
  __int16 v98 = v7;
  id v99 = v8;
  if (nw_protocol_definition_is_proxy(v7))
  {
    if (nw_protocol_options_proxy_endpoint_should_override_stack(v8)) {
      os_log_type_t v9 = nw_protocol_options_copy_proxy_endpoint_for_stack(v8);
    }
    else {
      os_log_type_t v9 = nw_endpoint_copy_without_proxy_parent(*(void **)(a1 + 32));
    }
    uint64_t v10 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v11 = *(void **)(v10 + 40);
    *(void *)(v10 + 40) = v9;

    id v12 = nw_endpoint_handler_copy_context(*(void **)(a1 + 40));
    BOOL v13 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
    if (*(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24)) {
      int v14 = 1;
    }
    else {
      int v14 = nw_parameters_get_use_enhanced_privacy_mode(*(void **)(a1 + 48)) ^ 1;
    }
    id v15 = nw_context_copy_registered_endpoint_internal(v12, v13, v14);
    uint64_t v16 = *(void *)(*(void *)(a1 + 64) + 8);
    uint64_t v17 = *(void **)(v16 + 40);
    *(void *)(v16 + 40) = v15;

    *(unsigned char *)(*(void *)(*(void *)(a1 + 72) + 8) + 24) = 1;
    *(unsigned char *)(*(void *)(a1 + 56) + 35) |= 0x20u;
  }
  identifier = nw_protocol_definition_get_identifier(v7);
  int v19 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 72) + 8) + 24);
  id v20 = *(void **)(a1 + 32);
  uint64_t v21 = *(void **)(*(void *)(*(void *)(a1 + 64) + 8) + 40);
  os_log_type_t v22 = *(void **)(a1 + 48);
  id v23 = *(id *)(a1 + 40);
  id v101 = v20;
  id v24 = v21;
  id v25 = v22;
  __int16 v100 = v24;
  v97 = v23;
  if (!v23)
  {
    uint64_t v60 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
    BOOL v61 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (!__nwlog_fault(v61, &type, &v102)) {
      goto LABEL_155;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v63, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_137;
    }
    if (!v102)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v81 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v81, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_137;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v67 = __nwlog_obj();
    os_log_type_t v68 = type;
    BOOL v69 = os_log_type_enabled(v67, type);
    if (backtrace_string)
    {
      if (v69)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v106 = 2082;
        char v107 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
LABEL_155:
      if (!v61) {
        goto LABEL_80;
      }
      goto LABEL_156;
    }
    if (v69)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
      _os_log_impl(&dword_1830D4000, v67, v68, "%{public}s called with null handler, no backtrace", buf, 0xCu);
    }
    goto LABEL_154;
  }
  os_log_type_t v26 = (unsigned int *)v23;
  uint64_t v27 = v26[29];

  if (v27 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v37 = (id)gLogObj;
    if (v27 > 5) {
      long long v38 = "unknown-mode";
    }
    else {
      long long v38 = off_1E523FB08[v27];
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
    __int16 v106 = 2082;
    char v107 = (void *)v38;
    __int16 v108 = 2082;
    v109 = "flow";
    uint64_t v46 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (__nwlog_fault(v46, &type, &v102))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v47 = (id)gLogObj;
        os_log_type_t v48 = type;
        if (os_log_type_enabled(v47, type))
        {
          if (v27 > 5) {
            __int16 v49 = "unknown-mode";
          }
          else {
            __int16 v49 = off_1E523FB08[v27];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v106 = 2082;
          char v107 = (void *)v49;
          __int16 v108 = 2082;
          v109 = "flow";
          _os_log_impl(&dword_1830D4000, v47, v48, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v102)
      {
        char v50 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v47 = (id)gLogObj;
        os_log_type_t v51 = type;
        BOOL v52 = os_log_type_enabled(v47, type);
        if (v50)
        {
          if (v52)
          {
            if (v27 > 5) {
              uint64_t v53 = "unknown-mode";
            }
            else {
              uint64_t v53 = off_1E523FB08[v27];
            }
            *(_DWORD *)buf = 136446978;
            uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
            __int16 v106 = 2082;
            char v107 = (void *)v53;
            __int16 v108 = 2082;
            v109 = "flow";
            __int16 v110 = 2082;
            v111 = v50;
            _os_log_impl(&dword_1830D4000, v47, v51, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v50);
          if (!v46) {
            goto LABEL_80;
          }
LABEL_78:
          unint64_t v57 = (char *)v46;
LABEL_79:
          free(v57);
          goto LABEL_80;
        }
        if (v52)
        {
          if (v27 > 5) {
            int v56 = "unknown-mode";
          }
          else {
            int v56 = off_1E523FB08[v27];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v106 = 2082;
          char v107 = (void *)v56;
          __int16 v108 = 2082;
          v109 = "flow";
          _os_log_impl(&dword_1830D4000, v47, v51, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v47 = (id)gLogObj;
        os_log_type_t v54 = type;
        if (os_log_type_enabled(v47, type))
        {
          if (v27 > 5) {
            uint64_t v55 = "unknown-mode";
          }
          else {
            uint64_t v55 = off_1E523FB08[v27];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v106 = 2082;
          char v107 = (void *)v55;
          __int16 v108 = 2082;
          v109 = "flow";
          _os_log_impl(&dword_1830D4000, v47, v54, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v46)
    {
LABEL_80:
      uint64_t registered_endpoint = 0;
      goto LABEL_81;
    }
    goto LABEL_78;
  }
  if (!identifier)
  {
    BOOL v64 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
    BOOL v61 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (!__nwlog_fault(v61, &type, &v102)) {
      goto LABEL_155;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v65 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v65, "%{public}s called with null identifier", buf, 0xCu);
      }
      goto LABEL_137;
    }
    if (!v102)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v82 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v82, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_137;
    }
    uint64_t v74 = (char *)__nw_create_backtrace_string();
    char v67 = __nwlog_obj();
    os_log_type_t v75 = type;
    BOOL v76 = os_log_type_enabled(v67, type);
    if (v74)
    {
      if (v76)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v106 = 2082;
        char v107 = v74;
        _os_log_impl(&dword_1830D4000, v67, v75, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_121:

      free(v74);
      if (!v61) {
        goto LABEL_80;
      }
LABEL_156:
      unint64_t v57 = (char *)v61;
      goto LABEL_79;
    }
    if (v76)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
      _os_log_impl(&dword_1830D4000, v67, v75, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
    }
LABEL_154:

    goto LABEL_155;
  }
  if (!v24)
  {
    id v70 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
    BOOL v61 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (!__nwlog_fault(v61, &type, &v102)) {
      goto LABEL_155;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v71, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_137;
    }
    if (!v102)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v83 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v83, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_137;
    }
    uint64_t v74 = (char *)__nw_create_backtrace_string();
    char v67 = __nwlog_obj();
    os_log_type_t v77 = type;
    BOOL v78 = os_log_type_enabled(v67, type);
    if (v74)
    {
      if (v78)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v106 = 2082;
        char v107 = v74;
        _os_log_impl(&dword_1830D4000, v67, v77, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_121;
    }
    if (v78)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
      _os_log_impl(&dword_1830D4000, v67, v77, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
    }
    goto LABEL_154;
  }
  if (!v25)
  {
    id v72 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
    BOOL v61 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v102 = 0;
    if (!__nwlog_fault(v61, &type, &v102)) {
      goto LABEL_155;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v73, "%{public}s called with null parameters", buf, 0xCu);
      }
LABEL_137:

      goto LABEL_155;
    }
    if (!v102)
    {
      BOOL v62 = __nwlog_obj();
      os_log_type_t v84 = type;
      if (os_log_type_enabled(v62, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v62, v84, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_137;
    }
    uint64_t v74 = (char *)__nw_create_backtrace_string();
    char v67 = __nwlog_obj();
    os_log_type_t v79 = type;
    BOOL v80 = os_log_type_enabled(v67, type);
    if (v74)
    {
      if (v80)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v106 = 2082;
        char v107 = v74;
        _os_log_impl(&dword_1830D4000, v67, v79, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_121;
    }
    if (v80)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
      _os_log_impl(&dword_1830D4000, v67, v79, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
    }
    goto LABEL_154;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v28 = &g_registration_list;
  do
  {
    uint64_t v28 = (uint64_t *)*v28;
    if (!v28)
    {
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      goto LABEL_38;
    }
  }
  while (*(void *)identifier != v28[4]
       || *((void *)identifier + 1) != v28[5]
       || *((void *)identifier + 2) != v28[6]
       || *((void *)identifier + 3) != v28[7]
       || *((void *)identifier + 4) != v28[8]);
  uint64_t v33 = v28[13];
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  if (!v33)
  {
LABEL_38:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v26) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      long long v39 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v39, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v26);
        v95 = nw_endpoint_handler_dry_run_string(v26);
        nw_endpoint_t v41 = nw_endpoint_handler_copy_endpoint(v26);
        logging_description = nw_endpoint_get_logging_description(v41);
        long long v43 = nw_endpoint_handler_state_string(v26);
        long long v44 = nw_endpoint_handler_mode_string(v26);
        id v45 = nw_endpoint_handler_copy_current_path(v26);
        *(_DWORD *)buf = 136448258;
        uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v106 = 2082;
        char v107 = (void *)id_string;
        __int16 v108 = 2082;
        v109 = v95;
        __int16 v110 = 2082;
        v111 = (void *)logging_description;
        __int16 v112 = 2082;
        v113 = v43;
        __int16 v114 = 2082;
        v115 = v44;
        __int16 v116 = 2114;
        id v117 = v45;
        __int16 v118 = 2080;
        v119 = identifier;
        __int16 v120 = 2048;
        uint64_t v121 = (uint64_t)identifier;
        _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x5Cu);
      }
    }
    goto LABEL_80;
  }
  id v34 = v24;
  char v35 = v34;
  while (1)
  {
    uint64_t registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join((uint64_t)identifier, a2, v101, v35, v34, v25, v19 != 0);
    if (registered_endpoint) {
      break;
    }
    uint64_t registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v35, v19 != 0);

    char v35 = (void *)registered_endpoint;
    if (!registered_endpoint) {
      goto LABEL_60;
    }
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v26) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v85 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v85, OS_LOG_TYPE_DEBUG))
    {
      BOOL v86 = nw_endpoint_handler_get_id_string(v26);
      v87 = nw_endpoint_handler_dry_run_string(v26);
      nw_endpoint_t v88 = nw_endpoint_handler_copy_endpoint(v26);
      nw_endpoint_t v96 = nw_endpoint_get_logging_description(v88);
      __int16 v94 = nw_endpoint_handler_state_string(v26);
      os_log_type_t v89 = nw_endpoint_handler_mode_string(v26);
      id v90 = nw_endpoint_handler_copy_current_path(v26);
      v91 = v90;
      uint64_t v105 = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v92 = "invalid";
      v93 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v93) {
        __int16 v92 = v93;
      }
      __int16 v106 = 2082;
      char v107 = (void *)v86;
      __int16 v108 = 2082;
      v109 = v87;
      __int16 v110 = 2082;
      v111 = (void *)v96;
      __int16 v112 = 2082;
      v113 = v94;
      __int16 v114 = 2082;
      v115 = v89;
      __int16 v116 = 2114;
      id v117 = v90;
      __int16 v118 = 2080;
      v119 = (void *)v92;
      __int16 v120 = 2048;
      uint64_t v121 = registered_endpoint;
      _os_log_impl(&dword_1830D4000, v85, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)", buf, 0x5Cu);
    }
  }
LABEL_60:

LABEL_81:
  *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) = registered_endpoint;
  BOOL v58 = *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24) == 0;

  return v58;
}

void sub_183179140(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, void *a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

char *nw_parameters_copy_description_internal(NWConcrete_nw_parameters *a1, int a2)
{
  uint64_t v230 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1;
  v200 = v2;
  if (v2)
  {
    uint64_t v3 = v2;
    if (v2->e_bundle_id)
    {
      snprintf(__str, 0x90uLL, ", bundle id: %s", v2->e_bundle_id);
      proxy_bundle_id = v3->proxy_bundle_id;
      if (proxy_bundle_id) {
        goto LABEL_4;
      }
    }
    else
    {
      __str[0] = 0;
      proxy_bundle_id = v2->proxy_bundle_id;
      if (proxy_bundle_id)
      {
LABEL_4:
        snprintf((char *)type, 0x96uLL, ", proxy bundle id: %s", proxy_bundle_id);
        unint64_t expected_workload = v3->value.expected_workload;
        if (expected_workload) {
          goto LABEL_5;
        }
        goto LABEL_14;
      }
    }
    type[0] = OS_LOG_TYPE_DEFAULT;
    unint64_t expected_workload = v3->value.expected_workload;
    if (expected_workload)
    {
LABEL_5:
      snprintf(v223, 0x27uLL, ", expected workload: %llu", expected_workload);
      unint64_t channel_teardown_delay = v3->value.channel_teardown_delay;
      if (channel_teardown_delay)
      {
LABEL_6:
        snprintf(v222, 0x26uLL, ", teardown delay: %llums", channel_teardown_delay);
        goto LABEL_16;
      }
LABEL_15:
      v222[0] = 0;
LABEL_16:
      uint64_t v11 = v3;
      int v12 = *((unsigned __int8 *)&v11->path_parameters->path_value + 30);

      attributed_bundle = v11->path_parameters->attributed_bundle;
      if (v12)
      {
        int v14 = attributed_bundle;
        id v15 = v14;
        if (v14 && (int v16 = *((_DWORD *)v14 + 31), (v16 - 2) >= 2))
        {
          BOOL private_redacted = v16 != 1;
        }
        else
        {
          if (nwlog_get_sensitive_redacted::onceToken != -1) {
            dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
          }
          BOOL private_redacted = nwlog_get_sensitive_redacted::sensitiveRedacted != 0;
        }

        if (!v11->url_endpoint) {
          goto LABEL_28;
        }
      }
      else
      {
        BOOL private_redacted = nw_context_get_private_redacted(attributed_bundle);
        if (!v11->url_endpoint) {
          goto LABEL_28;
        }
      }
      unint64_t v18 = v11;
      __int16 multipath_service = v11->path_parameters->joinable_path_value.multipath_service;

      if ((multipath_service & 0x2000) == 0)
      {
        url_endpoint = v11->url_endpoint;
        if (private_redacted)
        {
          nw_endpoint_get_url_hash(url_endpoint);
          snprintf(v221, 0x80uLL, ", url hash: %s");
        }
        else
        {
          nw_endpoint_get_sanitized_url(url_endpoint);
          snprintf(v221, 0x80uLL, ", url: %s");
        }
        if (!v11->main_document_url_endpoint) {
          goto LABEL_42;
        }
LABEL_39:
        id v24 = v11;
        __int16 v25 = v11->path_parameters->joinable_path_value.multipath_service;

        if ((v25 & 0x2000) == 0)
        {
          main_document_url_endpoint = v11->main_document_url_endpoint;
          if (private_redacted)
          {
            nw_endpoint_get_url_hash(main_document_url_endpoint);
            snprintf(v220, 0x80uLL, ", main document url hash: %s");
          }
          else
          {
            nw_endpoint_get_sanitized_url(main_document_url_endpoint);
            snprintf(v220, 0x80uLL, ", main document url: %s");
          }
          goto LABEL_44;
        }
LABEL_42:
        v220[0] = 0;
LABEL_44:
        if ((*((void *)&v11->value + 11) & 4) != 0) {
          uint64_t v27 = ", fast-open";
        }
        else {
          uint64_t v27 = "";
        }
        default_stack = v11->default_stack;
        os_log_type_t v29 = (void *)nw_protocol_boringssl_copy_definition();
        v197 = v27;
        LODWORD(default_stack) = nw_protocol_stack_includes_protocol(default_stack, v29);

        BOOL v30 = ", tls";
        if (!default_stack) {
          BOOL v30 = "";
        }
        v195 = v30;
        if ((*((void *)&v11->value + 11) & 0x40) != 0) {
          os_log_type_t v31 = "";
        }
        else {
          os_log_type_t v31 = ", definite";
        }
        v194 = v31;
        os_log_type_t v32 = v11;
        uint64_t v33 = *((void *)&v11->value + 11);

        id v34 = ", server";
        if ((v33 & 0x8000) == 0) {
          id v34 = "";
        }
        v193 = v34;
        char v35 = v32;
        uint64_t v36 = *((void *)&v11->value + 11);

        id v37 = ", attach protocol listener";
        if ((v36 & 0x400000) == 0) {
          id v37 = "";
        }
        v192 = v37;
        long long v38 = v35;
        uint64_t v39 = *((void *)&v11->value + 11);

        long long v40 = ", prohibit joining";
        if ((v39 & 0x800000) == 0) {
          long long v40 = "";
        }
        v191 = v40;
        nw_endpoint_t v41 = v38;
        uint64_t v42 = *((void *)&v11->value + 11);

        long long v43 = ", allow joining fd";
        if ((v42 & 0x1000000) == 0) {
          long long v43 = "";
        }
        v190 = v43;
        long long v44 = v41;
        uint64_t v45 = *((void *)&v11->value + 11);

        uint64_t v46 = ", allow duplicate updates";
        if ((v45 & 0x4000000) == 0) {
          uint64_t v46 = "";
        }
        v189 = v46;
        uint64_t v47 = v44;
        uint64_t v48 = *((void *)&v11->value + 11);

        __int16 v49 = ", don't always open listener socket";
        if ((v48 & 0x8000000) != 0) {
          __int16 v49 = "";
        }
        v188 = v49;
        char v50 = v47;
        uint64_t v51 = *((void *)&v11->value + 11);

        BOOL v52 = ", never open listener socket";
        if ((v51 & 0x10000000) == 0) {
          BOOL v52 = "";
        }
        v187 = v52;
        uint64_t v53 = v50;
        uint64_t v54 = *((void *)&v11->value + 11);

        uint64_t v55 = ", disable listener datapath";
        if ((v54 & 0x20000000) == 0) {
          uint64_t v55 = "";
        }
        v186 = v55;
        id v56 = v53;
        uint64_t v57 = *((void *)&v11->value + 11);

        BOOL v58 = ", requires DNSSEC validation";
        if ((v57 & 0x40000000) == 0) {
          BOOL v58 = "";
        }
        v185 = v58;
        id v59 = v56;
        uint64_t v60 = *((void *)&v11->value + 11);

        if ((v60 & 0x100) != 0) {
          BOOL v61 = ", reuse local address";
        }
        else {
          BOOL v61 = "";
        }
        id v62 = v59;
        uint64_t v63 = *((void *)&v11->value + 11);

        if ((v63 & 0x100000000) != 0) {
          BOOL v64 = ", prohibit encrypted DNS";
        }
        else {
          BOOL v64 = "";
        }
        id v65 = v62;
        uint64_t v66 = *((void *)&v11->value + 11);

        if ((v66 & 0x200000000) != 0) {
          char v67 = ", block trackers";
        }
        else {
          char v67 = "";
        }
        id v68 = v65;
        uint64_t v69 = *((void *)&v11->value + 11);

        if ((v69 & 0x400000000) != 0) {
          id v70 = ", fail if SVCB received";
        }
        else {
          id v70 = "";
        }
        id v71 = v68;
        uint64_t v72 = *((void *)&v11->value + 11);

        os_log_type_t v73 = ", include ble";
        if ((v72 & 0x800000000) == 0) {
          os_log_type_t v73 = "";
        }
        v184 = v73;
        id v74 = v71;
        uint64_t v75 = *((void *)&v11->value + 11);

        BOOL v76 = ", screen off";
        if ((v75 & 0x1000000000) == 0) {
          BOOL v76 = "";
        }
        v183 = v76;
        id v77 = v74;
        uint64_t v78 = *((void *)&v11->value + 11);

        os_log_type_t v79 = ", internet fallback";
        if ((v78 & 0x2000000000) == 0) {
          os_log_type_t v79 = "";
        }
        v182 = v79;
        id v80 = v77;
        uint64_t v81 = *((void *)&v11->value + 11);

        os_log_type_t v82 = ", minimize logging";
        if ((v81 & 0x4000000000) == 0) {
          os_log_type_t v82 = "";
        }
        v181 = v82;
        id v83 = v80;
        uint64_t v84 = *((void *)&v11->value + 11);

        os_log_type_t v85 = ", local only";
        if ((v84 & 0x4000) == 0) {
          os_log_type_t v85 = "";
        }
        v179 = v85;
        id v86 = v83;
        uint64_t v87 = *((void *)&v11->value + 11);

        if ((v87 & 0x10000000000) != 0) {
          nw_endpoint_t v88 = ", stricter path scoping";
        }
        else {
          nw_endpoint_t v88 = "";
        }
        id v89 = v86;
        uint64_t v90 = *((void *)&v11->value + 11);

        v91 = ", allow private access tokens for third party";
        if ((v90 & 0x20000000000) == 0) {
          v91 = "";
        }
        v177 = v91;
        id v92 = v89;
        uint64_t v93 = *((void *)&v11->value + 11);

        __int16 v94 = ", using ephemeral configuration";
        if ((v93 & 0x40000000000) == 0) {
          __int16 v94 = "";
        }
        v175 = v94;
        id v95 = v92;
        uint64_t v96 = *((void *)&v11->value + 11);

        if ((v96 & 0x80000000000) != 0) {
          v97 = ", prevents system http proxy authentication";
        }
        else {
          v97 = "";
        }
        unint64_t v98 = *((unsigned __int8 *)&v11->path_parameters->path_value + 30);
        if (v98 > 2)
        {
          id v99 = "unknown";
          if (aUnknown[0])
          {
LABEL_104:
            snprintf(v219, 0x26uLL, ", attribution: %s", v99);
            __int16 v100 = v11->default_stack;
            if (v100)
            {
LABEL_105:
              id v101 = v70;
              transport_protocol = v100->transport_protocol;
              v103 = "generic";
              if (transport_protocol)
              {
                v104 = v88;
                id v105 = v95;
                __int16 v106 = transport_protocol;
                v173 = v67;
                id v107 = v106[1];

                id v95 = v105;
                nw_endpoint_t v88 = v104;
                identifier = nw_protocol_definition_get_identifier(v107);
                if (identifier) {
                  v103 = identifier;
                }
                v196 = v103;

                char v67 = v173;
              }
              else
              {
                v196 = "generic";
              }
              id v70 = v101;
LABEL_114:
              v201 = 0;
              if (a2)
              {
                nw_path_parameters_copy_verbose_description(v11->path_parameters, (char *)buf);
                asprintf(&v201, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s, %s", v196, __str, (const char *)type, v220, v221, v223, v222, v197, v195, v194, v193, v192, v191, v190, v189, v188, v187,
                  v186,
                  v219,
                  v185,
                  v61,
                  v64,
                  v67,
                  v70,
                  v184,
                  v183,
                  v182,
                  v181,
                  v179,
                  v88,
                  v177,
                  v175,
                  v97,
                  (const char *)buf);
LABEL_216:
                id v117 = v201;
                goto LABEL_217;
              }
              if (v11->path_parameters->process_path_value.pid)
              {
                snprintf(v214, 0x10uLL, ", pid: %d", v11->path_parameters->process_path_value.pid);
                int pid = v11->path_parameters->process_path_value.pid;
              }
              else
              {
                int pid = 0;
                v214[0] = 0;
              }
              if (pid == getpid()) {
                v214[0] = 0;
              }
              path_parameters = v11->path_parameters;
              v111 = *(const char **)&path_parameters->joinable_path_value.fallback_mode;
              char v213 = 0;
              uint64_t v212 = 0;
              if (!v111) {
                goto LABEL_143;
              }
              __int16 v112 = path_parameters->attributed_bundle;
              v113 = v112;
              if (v112 && (int v114 = *((_DWORD *)v112 + 31), (v114 - 2) >= 2))
              {
                if (v114 == 1)
                {

                  goto LABEL_141;
                }
              }
              else
              {
                if (nwlog_get_sensitive_redacted::onceToken != -1) {
                  dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
                }
                int v115 = nwlog_get_sensitive_redacted::sensitiveRedacted;

                if (!v115)
                {
LABEL_141:
                  if (*v111)
                  {
                    snprintf((char *)buf, 0x91uLL, ", account id: %s", v111);
                    goto LABEL_144;
                  }
LABEL_143:
                  buf[0] = 0;
LABEL_144:
                  v119 = v11->path_parameters;
                  if (v119->path_value.traffic_class)
                  {
                    snprintf(v211, 0x18uLL, ", traffic class: %u", v119->path_value.traffic_class);
                    v119 = v11->path_parameters;
                  }
                  else
                  {
                    v211[0] = 0;
                  }
                  memset(out, 0, sizeof(out));
                  if (!uuid_is_null(v119->process_path_value.persona_id)) {
                    uuid_unparse(v11->path_parameters->process_path_value.persona_id, out);
                  }
                  if (uuid_is_null(v11->path_parameters->process_path_value.persona_id)
                    || uuid_is_null(v11->path_parameters->process_path_value.persona_id)
                    || !out[0])
                  {
                    v209[0] = 0;
                  }
                  else
                  {
                    int is_null = uuid_is_null(v11->path_parameters->process_path_value.persona_id);
                    v132 = out;
                    if (is_null) {
                      v132 = 0;
                    }
                    snprintf(v209, 0x2EuLL, ", persona: %s", v132);
                  }
                  __int16 v120 = v11->path_parameters;
                  local_address = v120->local_address;
                  if (local_address
                    && (v123 = *((unsigned __int8 *)local_address + 104), uint64_t v122 = (char *)local_address + 104, v123))
                  {
                    snprintf(v208, 0x28uLL, ", interface: %s", v122);
                    internet_options = v11->path_parameters->internet_options;
                    if (!internet_options) {
                      goto LABEL_158;
                    }
                  }
                  else
                  {
                    v208[0] = 0;
                    internet_options = v120->internet_options;
                    if (!internet_options) {
                      goto LABEL_158;
                    }
                  }
                  id v125 = v95;
                  v126 = internet_options;
                  *(void *)v226 = 0;
                  v227 = v226;
                  uint64_t v228 = 0x2020000000;
                  uint64_t v229 = 0;
                  v127 = v126 + 45;
                  *(void *)v202 = MEMORY[0x1E4F143A8];
                  uint64_t v203 = 3221225472;
                  v204 = __nw_endpoint_get_description_block_invoke;
                  v205 = &unk_1E524B978;
                  v128 = v126;
                  v206 = v128;
                  v207 = v226;
                  os_unfair_lock_lock(v127);
                  __nw_endpoint_get_description_block_invoke((uint64_t)v202);
                  os_unfair_lock_unlock(v127);
                  v129 = (const char *)*((void *)v227 + 3);

                  _Block_object_dispose(v226, 8);
                  id v95 = v125;
                  if (v129)
                  {
                    snprintf(v202, 0x8CuLL, ", local: %s", v129);
LABEL_159:
                    v130 = v11->path_parameters;
                    if (*(_DWORD *)((char *)&v130->path_value + 31))
                    {
                      snprintf(v226, 0x19uLL, ", multipath service: %u", *(_DWORD *)((char *)&v130->path_value + 31));
                      v130 = v11->path_parameters;
                    }
                    else
                    {
                      v226[0] = 0;
                    }
                    __int16 v133 = *((_WORD *)&v130->path_value + 14);
                    if ((v133 & 0x10) != 0) {
                      v134 = ", legacy-socket";
                    }
                    else {
                      v134 = "";
                    }
                    v135 = ", no expensive";
                    if ((v133 & 1) == 0) {
                      v135 = "";
                    }
                    v178 = v135;
                    v180 = v134;
                    if ((v133 & 2) != 0) {
                      v136 = ", no constrained";
                    }
                    else {
                      v136 = "";
                    }
                    v137 = ", allow ultra constrained";
                    if ((v133 & 4) == 0) {
                      v137 = "";
                    }
                    v174 = v137;
                    v176 = v136;
                    if ((v133 & 8) != 0) {
                      v138 = ", no roaming";
                    }
                    else {
                      v138 = "";
                    }
                    v172 = v138;
                    BOOL prohibit_cellular = nw_parameters_get_prohibit_cellular(v95);
                    id v139 = v95;
                    __int16 v140 = v11->path_parameters->joinable_path_value.multipath_service;

                    id v141 = v139;
                    __int16 v142 = v11->path_parameters->joinable_path_value.multipath_service;

                    id v143 = v141;
                    __int16 v144 = *((_WORD *)&v11->path_parameters->path_value + 14);

                    id v145 = v143;
                    __int16 v146 = v11->path_parameters->joinable_path_value.multipath_service;

                    int prohibit_privacy_proxy = nw_parameters_get_prohibit_privacy_proxy(v145);
                    if ((v146 & 0x400) != 0) {
                      v148 = ", proxy fail closed for unreachable";
                    }
                    else {
                      v148 = "";
                    }
                    v171 = v148;
                    v149 = ", proxy fail closed";
                    if ((v144 & 0x40) == 0) {
                      v149 = "";
                    }
                    v170 = v149;
                    if ((v142 & 0x200) != 0) {
                      v150 = ", no proxy path selection";
                    }
                    else {
                      v150 = "";
                    }
                    if ((v140 & 0x100) != 0) {
                      v151 = ", prefer no proxy";
                    }
                    else {
                      v151 = "";
                    }
                    if (prohibit_cellular) {
                      v152 = ", no cellular";
                    }
                    else {
                      v152 = "";
                    }
                    if (prohibit_privacy_proxy) {
                      v153 = ", prohibit privacy proxy";
                    }
                    else {
                      v153 = "";
                    }
                    id v154 = v145;
                    p_path_parameters = &v11->path_parameters;
                    BOOL v156 = (v11->path_parameters->joinable_path_value.multipath_service & 0x4000) == 0;

                    if (v156) {
                      v157 = "";
                    }
                    else {
                      v157 = ", known tracker";
                    }
                    id v158 = v154;
                    BOOL v159 = ((*p_path_parameters)->joinable_path_value.multipath_service & 0x8000) == 0;

                    id v160 = v158;
                    if (((LOWORD((*p_path_parameters)->joinable_path_value.multipath_service) | (BYTE2((*p_path_parameters)->joinable_path_value.multipath_service) << 16)) & 0x10000) != 0) {
                      v161 = ", approved app domain";
                    }
                    else {
                      v161 = "";
                    }

                    v162 = ", third party web content";
                    if (v159) {
                      v162 = "";
                    }
                    v163 = ", prefer companion";
                    int companion_preference = (*p_path_parameters)->path_value.companion_preference;
                    int companion_link_upgrade_preference = (*p_path_parameters)->path_value.companion_link_upgrade_preference;
                    if (companion_preference != 1) {
                      v163 = "";
                    }
                    if (companion_preference == 2) {
                      v166 = ", avoid companion";
                    }
                    else {
                      v166 = "";
                    }
                    v167 = ", bluetooth upgrade";
                    if (companion_link_upgrade_preference != 1) {
                      v167 = "";
                    }
                    if (companion_link_upgrade_preference == 2) {
                      v168 = ", wi-fi upgrade";
                    }
                    else {
                      v168 = "";
                    }
                    asprintf(&v201, "%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s%s", v196, __str, (const char *)type, v220, v214, (const char *)buf, v209, v221, v211, v223, v222, v208, v202, v226, v180, v197, v195,
                      v194,
                      v178,
                      v176,
                      v174,
                      v172,
                      v152,
                      v151,
                      v150,
                      v170,
                      v171,
                      v153,
                      v157,
                      v219,
                      v162,
                      v161,
                      v163,
                      v166,
                      v193,
                      v192,
                      v191,
                      v190,
                      v189,
                      v167,
                      v168,
                      v188,
                      v187,
                      v186,
                      v185,
                      v184,
                      v183,
                      v182,
                      v181);
                    goto LABEL_216;
                  }
LABEL_158:
                  v202[0] = 0;
                  goto LABEL_159;
                }
              }
              size_t v118 = strlen(*(const char **)&v11->path_parameters->joinable_path_value.fallback_mode);
              v111 = (const char *)&v212;
              __nwlog_salted_hash(*(const void **)&v11->path_parameters->joinable_path_value.fallback_mode, v118, (char *)&v212);
              goto LABEL_141;
            }
LABEL_111:
            v196 = "generic";
            goto LABEL_114;
          }
        }
        else
        {
          id v99 = off_1E523D470[v98];
          if (*v99) {
            goto LABEL_104;
          }
        }
        v219[0] = 0;
        __int16 v100 = v11->default_stack;
        if (v100) {
          goto LABEL_105;
        }
        goto LABEL_111;
      }
LABEL_28:
      v221[0] = 0;
      if (!v11->main_document_url_endpoint) {
        goto LABEL_42;
      }
      goto LABEL_39;
    }
LABEL_14:
    v223[0] = 0;
    unint64_t channel_teardown_delay = v3->value.channel_teardown_delay;
    if (channel_teardown_delay) {
      goto LABEL_6;
    }
    goto LABEL_15;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v7 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  v216 = "nw_parameters_copy_description_internal";
  id v8 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  __str[0] = 0;
  if (__nwlog_fault(v8, type, __str))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      os_log_type_t v10 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v216 = "nw_parameters_copy_description_internal";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (__str[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      os_log_type_t v22 = type[0];
      BOOL v23 = os_log_type_enabled(v9, type[0]);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          v216 = "nw_parameters_copy_description_internal";
          __int16 v217 = 2082;
          v218 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v22, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v8) {
          goto LABEL_138;
        }
        goto LABEL_137;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        v216 = "nw_parameters_copy_description_internal";
        _os_log_impl(&dword_1830D4000, v9, v22, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v9 = (id)gLogObj;
      os_log_type_t v116 = type[0];
      if (os_log_type_enabled(v9, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v216 = "nw_parameters_copy_description_internal";
        _os_log_impl(&dword_1830D4000, v9, v116, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
  if (v8) {
LABEL_137:
  }
    free(v8);
LABEL_138:
  id v117 = 0;
LABEL_217:

  return v117;
}

void sub_18317A30C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

char *nw_protocol_definition_get_identifier(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1 + 8;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_protocol_definition_get_identifier";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_identifier";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_protocol_definition_get_identifier";
          __int16 v17 = 2082;
          unint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_identifier";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_protocol_definition_get_identifier";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_protocol_stack_includes_protocol(void *a1, void *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    uint64_t v21 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v42 = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v22, &v42, &v41)) {
      goto LABEL_48;
    }
    if (v42 == OS_LOG_TYPE_FAULT)
    {
      BOOL v23 = __nwlog_obj();
      os_log_type_t v24 = v42;
      if (os_log_type_enabled(v23, v42))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null stack", buf, 0xCu);
      }
    }
    else if (v41)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v23 = __nwlog_obj();
      os_log_type_t v28 = v42;
      BOOL v29 = os_log_type_enabled(v23, v42);
      if (backtrace_string)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_48:
        if (!v22)
        {
LABEL_50:
          uint64_t v19 = 0;
          goto LABEL_14;
        }
LABEL_49:
        free(v22);
        goto LABEL_50;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null stack, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v23 = __nwlog_obj();
      os_log_type_t v33 = v42;
      if (os_log_type_enabled(v23, v42))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_1830D4000, v23, v33, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_47:

    goto LABEL_48;
  }
  if (!v4)
  {
    __int16 v25 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
    os_log_type_t v22 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v42 = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (!__nwlog_fault(v22, &v42, &v41)) {
      goto LABEL_48;
    }
    if (v42 == OS_LOG_TYPE_FAULT)
    {
      BOOL v23 = __nwlog_obj();
      os_log_type_t v26 = v42;
      if (os_log_type_enabled(v23, v42))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v41)
    {
      BOOL v30 = (char *)__nw_create_backtrace_string();
      BOOL v23 = __nwlog_obj();
      os_log_type_t v31 = v42;
      BOOL v32 = os_log_type_enabled(v23, v42);
      if (v30)
      {
        if (v32)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v30;
          _os_log_impl(&dword_1830D4000, v23, v31, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v30);
        if (!v22) {
          goto LABEL_50;
        }
        goto LABEL_49;
      }
      if (v32)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_1830D4000, v23, v31, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v23 = __nwlog_obj();
      os_log_type_t v34 = v42;
      if (os_log_type_enabled(v23, v42))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_stack_includes_protocol";
        _os_log_impl(&dword_1830D4000, v23, v34, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_47;
  }
  uint64_t v6 = (atomic_uchar *)v3[1];
  if (!v6) {
    goto LABEL_53;
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  char v44 = 0;
  v38[0] = MEMORY[0x1E4F143A8];
  v38[1] = 3221225472;
  v38[2] = __nw_protocol_stack_includes_protocol_block_invoke;
  v38[3] = &unk_1E524A2E8;
  id v39 = v4;
  long long v40 = buf;
  nw_array_apply(v6, (uint64_t)v38);
  BOOL v7 = *(unsigned char *)(*(void *)&buf[8] + 24) == 0;

  _Block_object_dispose(buf, 8);
  if (v7)
  {
LABEL_53:
    os_log_type_t v8 = (atomic_uchar *)v3[2];
    if (!v8) {
      goto LABEL_54;
    }
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    char v44 = 0;
    v35[0] = MEMORY[0x1E4F143A8];
    v35[1] = 3221225472;
    v35[2] = __nw_protocol_stack_includes_protocol_block_invoke_2;
    v35[3] = &unk_1E524A2E8;
    id v36 = v5;
    id v37 = buf;
    nw_array_apply(v8, (uint64_t)v35);
    BOOL v9 = *(unsigned char *)(*(void *)&buf[8] + 24) == 0;

    _Block_object_dispose(buf, 8);
    if (v9)
    {
LABEL_54:
      os_log_type_t v10 = (void *)v3[3];
      if (!v10
        || (BOOL v11 = v10,
            id v12 = v11[1],
            v11,
            LOBYTE(v11) = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v12),
            v12,
            (v11 & 1) == 0))
      {
        char v13 = (void *)v3[4];
        if (!v13
          || (int v14 = v13,
              id v15 = v14[1],
              v14,
              LOBYTE(v14) = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v15),
              v15,
              (v14 & 1) == 0))
        {
          int v16 = (void *)v3[6];
          if (!v16) {
            goto LABEL_50;
          }
          __int16 v17 = v16;
          id v18 = v17[1];

          LOBYTE(v17) = nw_protocol_definition_is_equal_unsafe((uint64_t)v5, (uint64_t)v18);
          if ((v17 & 1) == 0) {
            goto LABEL_50;
          }
        }
      }
    }
  }
  uint64_t v19 = 1;
LABEL_14:

  return v19;
}

void sub_18317AC88(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_get_private_redacted(void *a1)
{
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1) {
    goto LABEL_5;
  }
  int v3 = *((_DWORD *)v1 + 31);
  if (v3 != 1)
  {
    if (v3 == 3)
    {
      if (nwlog_get_sensitive_redacted::onceToken != -1) {
        dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
      }
      int v4 = nwlog_get_sensitive_redacted::sensitiveRedacted;
      goto LABEL_12;
    }
    if (v3 != 2)
    {
      BOOL v5 = 1;
      goto LABEL_13;
    }
LABEL_5:
    if (nwlog_get_private_redacted::onceToken != -1) {
      dispatch_once(&nwlog_get_private_redacted::onceToken, &__block_literal_global_72);
    }
    int v4 = nwlog_get_private_redacted::privateRedacted;
LABEL_12:
    BOOL v5 = v4 != 0;
    goto LABEL_13;
  }
  BOOL v5 = 0;
LABEL_13:

  return v5;
}

BOOL nw_parameters_get_prohibit_cellular(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    uint64_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_cellular";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v7, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_cellular";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_cellular";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_cellular";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_cellular";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }
  int v3 = *(void ***)(*((void *)v1 + 13) + 176);
  if (!v3 || (int v4 = *v3) == 0)
  {
LABEL_23:
    BOOL v5 = 0;
    goto LABEL_24;
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  char v19 = 0;
  applier[0] = MEMORY[0x1E4F143A8];
  applier[1] = 3221225472;
  applier[2] = __nw_parameters_get_prohibit_cellular_block_invoke;
  applier[3] = &unk_1E52406D0;
  applier[4] = buf;
  xpc_array_apply(v4, applier);
  BOOL v5 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
  _Block_object_dispose(buf, 8);
LABEL_24:

  return v5;
}

void sub_18317B0A0(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_prohibit_privacy_proxy(void *a1)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_parameters_get_prohibit_privacy_proxy";
    BOOL v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_parameters_get_prohibit_privacy_proxy";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v22 = "nw_parameters_get_prohibit_privacy_proxy";
            __int16 v23 = 2082;
            os_log_type_t v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_parameters_get_prohibit_privacy_proxy";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_parameters_get_prohibit_privacy_proxy";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_30:
    if (v12) {
      free(v12);
    }
    goto LABEL_9;
  }
  int v3 = v1;
  if (uuid_is_null((const unsigned __int8 *)(v3[13] + 24)))
  {
  }
  else
  {
    int v9 = uuid_compare((const unsigned __int8 *)(v3[13] + 24), (const unsigned __int8 *)(v3[13] + 8));

    if (v9)
    {
      uint64_t v5 = v3[13];
LABEL_12:
      uint64_t v8 = (*(unsigned __int16 *)(v5 + 100) >> 7) & 1;
      goto LABEL_13;
    }
  }
  pid_t v4 = getpid();
  uint64_t v5 = v3[13];
  int v6 = *(_DWORD *)(v5 + 64);
  if (v6 >= 1 && v6 != v4) {
    goto LABEL_12;
  }
LABEL_9:
  uint64_t v8 = 0;
LABEL_13:

  return v8;
}

void sub_18317B3B4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void *__nw_endpoint_get_description_block_invoke(uint64_t a1)
{
  uint64_t result = *(void **)(a1 + 32);
  uint64_t v3 = result[8];
  if (!v3)
  {
    uint64_t result = (void *)[result createDescription:0];
    *(void *)(*(void *)(a1 + 32) + 64) = result;
    uint64_t v3 = *(void *)(*(void *)(a1 + 32) + 64);
  }
  *(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = v3;
  *(unsigned char *)(*(void *)(a1 + 32) + 231) |= 8u;
  return result;
}

char *nw_endpoint_get_url_hash(void *a1)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    BOOL v29 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
    BOOL v30 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v30, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v31 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          _os_log_impl(&dword_1830D4000, v31, v32, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v31 = __nwlog_obj();
        os_log_type_t v34 = type;
        BOOL v35 = os_log_type_enabled(v31, type);
        if (backtrace_string)
        {
          if (v35)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v35)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          _os_log_impl(&dword_1830D4000, v31, v34, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v31 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v31, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          _os_log_impl(&dword_1830D4000, v31, v36, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_47:
    if (!v30) {
      goto LABEL_14;
    }
    os_log_type_t v16 = (char *)v30;
    goto LABEL_13;
  }
  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    id v9 = v3;
    int v10 = [v9 type];

    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
    *(_WORD *)&buf[12] = 1024;
    *(_DWORD *)&buf[14] = v10;
    LODWORD(v37) = 18;
    os_log_type_t v11 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v11, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          id v14 = v9;
          int v15 = objc_msgSend(v14, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v15;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v41)
      {
        os_log_type_t v18 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (id)gLogObj;
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v12, type);
        if (v18)
        {
          if (v20)
          {
            id v21 = v9;
            int v22 = objc_msgSend(v21, "type", buf, v37);

            *(_DWORD *)buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v22;
            *(_WORD *)&buf[18] = 2082;
            *(void *)&buf[20] = v18;
            _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v18);
          if (!v11) {
            goto LABEL_14;
          }
LABEL_12:
          os_log_type_t v16 = (char *)v11;
LABEL_13:
          free(v16);
          goto LABEL_14;
        }
        if (v20)
        {
          id v27 = v9;
          int v28 = objc_msgSend(v27, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v28;
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v12 = (id)gLogObj;
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v12, type))
        {
          id v24 = v9;
          int v25 = objc_msgSend(v24, "type", buf, v37);

          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_get_url_hash";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v25;
          _os_log_impl(&dword_1830D4000, v12, v23, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v11)
    {
LABEL_14:
      BOOL v17 = 0;
      goto LABEL_27;
    }
    goto LABEL_12;
  }
  uint64_t v5 = (char *)v3;
  int v6 = v5;
  if (!v5[288])
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    *(void *)&unsigned char buf[24] = 0;
    *(void *)&unsigned char buf[24] = nw_endpoint_get_sanitized_url(v5);
    if (*(void *)(*(void *)&buf[8] + 24))
    {
      v38[0] = MEMORY[0x1E4F143A8];
      v38[1] = 3221225472;
      v38[2] = __nw_endpoint_get_url_hash_block_invoke;
      v38[3] = &unk_1E524B978;
      id v39 = v6;
      long long v40 = buf;
      BOOL v7 = v39 + 75;
      os_unfair_lock_lock(v39 + 75);
      __nw_endpoint_get_url_hash_block_invoke((BOOL)v38);
      os_unfair_lock_unlock(v7);
    }
    else
    {
      strcpy(v6 + 288, "<null>");
    }
    _Block_object_dispose(buf, 8);
  }

  BOOL v17 = v6 + 288;
LABEL_27:

  return v17;
}

void sub_18317BB10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_endpoint_get_url_hash_block_invoke(BOOL result)
{
  id v1 = (char *)(*(void *)(result + 32) + 288);
  if (!*v1)
  {
    uint64_t v2 = *(const char **)(*(void *)(*(void *)(result + 40) + 8) + 24);
    size_t v3 = strlen(v2);
    return __nwlog_salted_hash(v2, v3, v1);
  }
  return result;
}

void nw_activity_complete_with_reason(void *a1, uint32_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  int v4 = v3;
  if (v3)
  {
    nw_activity_complete_with_reason_and_underlying_error_string_internal(v3, a2, 0, 0, 0);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_activity_complete_with_reason";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_complete_with_reason";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null activity", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_activity_complete_with_reason";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_complete_with_reason";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null activity, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_activity_complete_with_reason";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_18317BE98(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_ecn_mode(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_parameters_get_ecn_mode";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_parameters_get_ecn_mode";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v6 = (id)gLogObj;
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v16 = "nw_parameters_get_ecn_mode";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v5) {
            goto LABEL_10;
          }
          goto LABEL_9;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_parameters_get_ecn_mode";
          _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v6 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_parameters_get_ecn_mode";
          _os_log_impl(&dword_1830D4000, v6, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v5)
    {
LABEL_10:
      uint64_t v3 = 0;
      goto LABEL_11;
    }
LABEL_9:
    free(v5);
    goto LABEL_10;
  }
  uint64_t v3 = v1[93];
LABEL_11:

  return v3;
}

uint64_t nw_parameters_get_parent_id_count(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = uuid_is_null((const unsigned __int8 *)v1 + 8) == 0;
    id v4 = (void *)v2[17];
    if (v4) {
      uint64_t v3 = xpc_array_get_count(v4) + v3;
    }
    goto LABEL_4;
  }
  int v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v17 = "nw_parameters_get_parent_id_count";
  os_log_type_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_parameters_get_parent_id_count";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v17 = "nw_parameters_get_parent_id_count";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_parameters_get_parent_id_count";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v17 = "nw_parameters_get_parent_id_count";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v7) {
    free(v7);
  }
  uint64_t v3 = 0;
LABEL_4:

  return v3;
}

void sub_18317C470(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_start_block_invoke(uint64_t a1)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = &unk_1EB267000;
  uint64_t v3 = (id *)&unk_1EB267000;
  if (!nw_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 32) + 16)))
  {
    id v4 = nw_parameters_copy_description_internal(*(NWConcrete_nw_parameters **)(*(void *)(a1 + 32) + 16), 1);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v5 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v5, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v6 = *(void *)(a1 + 32);
      int v7 = *(_DWORD *)(v6 + 448);
      logging_description = nw_endpoint_get_logging_description(*(void **)(v6 + 8));
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)&uint8_t buf[4] = v7;
      *(_WORD *)&uint8_t buf[8] = 1042;
      *(_DWORD *)&buf[10] = 16;
      *(_WORD *)&buf[14] = 2098;
      *(void *)&buf[16] = v6 + 452;
      *(_WORD *)&unsigned char buf[24] = 2082;
      *(void *)&buf[26] = logging_description;
      *(_WORD *)&buf[34] = 2082;
      *(void *)&buf[36] = v4;
      _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_DEFAULT, "[C%u %{public,uuid_t}.16P %{public}s %{public}s] start", buf, 0x2Cu);
    }

    if (v4) {
      free(v4);
    }
  }
  os_log_type_t v9 = *(os_unfair_lock_s **)(a1 + 32);
  os_log_type_t v10 = v9 + 34;
  v53[0] = MEMORY[0x1E4F143A8];
  v53[1] = 3221225472;
  v53[2] = __nw_connection_start_block_invoke_17;
  v53[3] = &unk_1E524BAA8;
  uint64_t v54 = v9;
  os_unfair_lock_lock(v10);
  __nw_connection_start_block_invoke_17((uint64_t)v53);
  os_unfair_lock_unlock(v10);
  uint64_t v11 = *(void *)(a1 + 32);
  if (*(void *)(v11 + 72))
  {
    unsigned int v12 = *(_DWORD *)(v11 + 80);
    os_log_type_t v13 = (id)v11;
    nw_context_assert_queue(v13[3].isa);
    nw_connection_report_state_with_handler_on_nw_queue(v13, v12, v13[26].isa, v13[25].isa);
    goto LABEL_42;
  }
  if (*(void *)(v11 + 144))
  {
    if (*(void *)(v11 + 200))
    {
LABEL_14:
      objc_storeStrong((id *)(v11 + 48), (id)v11);
      uint64_t v14 = *(void *)(a1 + 32);
      int v15 = *(_DWORD *)(v14 + 80);
      *(_DWORD *)(v14 + 192) = *(_DWORD *)(a1 + 40);
      os_log_type_t v16 = *(os_unfair_lock_s **)(a1 + 32);
      __int16 v17 = v16 + 34;
      v51[0] = MEMORY[0x1E4F143A8];
      v51[1] = 3221225472;
      v51[2] = __nw_connection_start_block_invoke_18;
      v51[3] = &unk_1E524BAA8;
      BOOL v52 = v16;
      os_unfair_lock_lock(v17);
      __nw_connection_start_block_invoke_18((uint64_t)v51);
      os_unfair_lock_unlock(v17);
      if (nw_parameters_get_attribution(*(nw_parameters_t *)(*(void *)(a1 + 32) + 16)) != nw_parameters_attribution_developer
        || !ne_tracker_should_save_stacktrace())
      {
        goto LABEL_20;
      }
      __int16 v18 = *(id *)(*(void *)(a1 + 32) + 16);
      if (v18)
      {
        BOOL v19 = (v18[12] & 0x8000000000) == 0;

        if (v19)
        {
LABEL_18:
          *(void *)buf = 0;
          uint64_t v20 = (const void *)ne_tracker_copy_current_stacktrace();
          if (v20)
          {
            dispatch_data_t v21 = dispatch_data_create(v20, *(size_t *)buf, 0, (dispatch_block_t)*MEMORY[0x1E4F143F0]);
            uint64_t v22 = *(void *)(a1 + 32);
            os_log_type_t v23 = *(void **)(v22 + 88);
            *(void *)(v22 + 88) = v21;
          }
        }
LABEL_20:
        uint32_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_statistics_report_numerator, 1);
        uint32_t v25 = networkd_settings_get_int64_with_default((const char *)nw_setting_statistics_report_denominator, 200000);
        if (arc4random_uniform(v25) < int64_with_default)
        {
          uint64_t v26 = *(void *)(*(void *)(a1 + 32) + 16);
          if (v26 && !nw_path_parameters_get_logging_disabled(*(void *)(v26 + 104)))
          {
            if (v2[191] != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v27 = v3[192];
            if (os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG))
            {
              int v28 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_start_block_invoke_2";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v28;
              _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] selected for reporting", buf, 0x12u);
            }
          }
          *(unsigned char *)(*(void *)(a1 + 32) + 108) |= 4u;
        }
        if (v15 >= 1)
        {
          BOOL v29 = *(_DWORD **)(a1 + 32);
          unsigned int v30 = v29[20];
          os_log_type_t v31 = v29;
          nw_context_assert_queue(v31[3]);
          nw_connection_report_state_with_handler_on_nw_queue(v31, v30, v31[26], v31[25]);
        }
        nw_endpoint_handler_start(*(void **)(*(void *)(a1 + 32) + 144));
        os_log_type_t v13 = v52;
        goto LABEL_42;
      }
      __nwlog_obj();
      v42 = int v41 = v15;
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
      long long v43 = (char *)_os_log_send_and_compose_impl();

      int v50 = v41;
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v55 = 0;
      if (__nwlog_fault(v43, &type, &v55))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v44 = __nwlog_obj();
          os_log_type_t v45 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null parameters", buf, 0xCu);
          }
        }
        else if (v55)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v44 = __nwlog_obj();
          os_log_type_t v47 = type;
          BOOL v48 = os_log_type_enabled(v44, type);
          if (backtrace_string)
          {
            if (v48)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_59;
          }
          if (v48)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          uint64_t v44 = __nwlog_obj();
          os_log_type_t v49 = type;
          if (os_log_type_enabled(v44, type))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_skip_stack_trace_capture";
            _os_log_impl(&dword_1830D4000, v44, v49, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_59:
      if (v43) {
        free(v43);
      }
      uint64_t v3 = (id *)&unk_1EB267000;
      uint64_t v2 = (void *)&unk_1EB267000;
      int v15 = v50;
      goto LABEL_18;
    }
    if (nw_context_is_inline(*(void **)(v11 + 24)))
    {
      uint64_t v11 = *(void *)(a1 + 32);
      goto LABEL_14;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v13 = (id)gLogObj;
    if (!os_log_type_enabled(v13, OS_LOG_TYPE_ERROR)) {
      goto LABEL_42;
    }
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_start_block_invoke";
    long long v38 = "%{public}s Cannot start nw_connection without first setting the queue.";
    id v39 = v13;
    uint32_t v40 = 12;
LABEL_41:
    _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_ERROR, v38, buf, v40);
    goto LABEL_42;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  os_log_type_t v13 = (id)gconnectionLogObj;
  if (os_log_type_enabled(v13, OS_LOG_TYPE_ERROR))
  {
    uint64_t v32 = *(void *)(a1 + 32);
    int v33 = *(_DWORD *)(v32 + 448);
    uint64_t v35 = *(void *)(v32 + 8);
    uint64_t v34 = *(void *)(v32 + 16);
    uint64_t v36 = *(unsigned int *)(v32 + 80);
    if (v36 > 5) {
      uint64_t v37 = "unknown";
    }
    else {
      uint64_t v37 = off_1E523DF08[v36];
    }
    *(_DWORD *)buf = 67109890;
    *(_DWORD *)&uint8_t buf[4] = v33;
    *(_WORD *)&uint8_t buf[8] = 2112;
    *(void *)&buf[10] = v35;
    *(_WORD *)&buf[18] = 2112;
    *(void *)&buf[20] = v34;
    *(_WORD *)&buf[28] = 2082;
    *(void *)&buf[30] = v37;
    long long v38 = "[C%u %@ %@] cannot start after being torn down, in state %{public}s";
    id v39 = v13;
    uint32_t v40 = 38;
    goto LABEL_41;
  }
LABEL_42:
}

void sub_18317CC2C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23)
{
  _Unwind_Resume(a1);
}

nw_parameters_attribution_t nw_parameters_get_attribution(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    if (*((unsigned __int8 *)v1[13].isa + 102) <= 2u) {
      nw_parameters_attribution_t v3 = (0x20201u >> (8 * *((unsigned char *)v1[13].isa + 102)));
    }
    else {
      nw_parameters_attribution_t v3 = 0;
    }
    goto LABEL_5;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_attribution";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_attribution";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_attribution";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_attribution";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_attribution";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v6) {
    free(v6);
  }
  nw_parameters_attribution_t v3 = 0;
LABEL_5:

  return v3;
}

uint64_t __nw_connection_start_block_invoke_18(uint64_t a1)
{
  uint64_t result = mach_continuous_time();
  if (result <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = result;
  }
  *(void *)(*(void *)(a1 + 32) + 72) = v3;
  *(_DWORD *)(*(void *)(a1 + 32) + 504) = 1;
  return result;
}

uint64_t __nw_connection_start_block_invoke_17(uint64_t result)
{
  *(unsigned char *)(*(void *)(result + 32) + 109) |= 0x10u;
  return result;
}

id nw_connection_create_with_id(void *a1, void *a2, int a3)
{
  *(void *)&v68[13] = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  nw_allow_use_of_dispatch_internal();
  if (!v5)
  {
    os_log_type_t v47 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v66 = "nw_connection_create_with_id";
    BOOL v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (!__nwlog_fault(v48, &type, &v63)) {
      goto LABEL_110;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v49 = __nwlog_obj();
      os_log_type_t v50 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v49 = __nwlog_obj();
      os_log_type_t v54 = type;
      BOOL v55 = os_log_type_enabled(v49, type);
      if (backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v66 = "nw_connection_create_with_id";
          __int16 v67 = 2082;
          *(void *)id v68 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v49, v54, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v48) {
          goto LABEL_112;
        }
        goto LABEL_111;
      }
      if (v55)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v49, v54, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v49 = __nwlog_obj();
      os_log_type_t v59 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v49, v59, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_109;
  }
  if (!v6)
  {
    uint64_t v51 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v66 = "nw_connection_create_with_id";
    BOOL v48 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (!__nwlog_fault(v48, &type, &v63)) {
      goto LABEL_110;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v49 = __nwlog_obj();
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v49, v52, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v63)
    {
      id v56 = (char *)__nw_create_backtrace_string();
      os_log_type_t v49 = __nwlog_obj();
      os_log_type_t v57 = type;
      BOOL v58 = os_log_type_enabled(v49, type);
      if (v56)
      {
        if (v58)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v66 = "nw_connection_create_with_id";
          __int16 v67 = 2082;
          *(void *)id v68 = v56;
          _os_log_impl(&dword_1830D4000, v49, v57, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v56);
LABEL_110:
        if (!v48)
        {
LABEL_112:
          id v27 = 0;
          goto LABEL_76;
        }
LABEL_111:
        free(v48);
        goto LABEL_112;
      }
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v49, v57, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v49 = __nwlog_obj();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v49, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v49, v60, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_109:

    goto LABEL_110;
  }
  id v7 = v6;
  BOOL v8 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v7, 0, 0);

  if (v8)
  {
    os_log_type_t v9 = [NWConcrete_nw_connection alloc];
    id v10 = v5;
    BOOL v11 = (void *)[v10 copyEndpoint];
    nw_endpoint_copy_properties(v10, v11);

    uint64_t v12 = -[NWConcrete_nw_connection initWithEndpoint:parameters:identifier:]((void **)&v9->super.isa, v11, (void *)v8, a3);
    if (v12)
    {
      uint64_t v13 = *(void *)(v12 + 8);
      uint64_t v14 = *(void *)(v12 + 16);
      nw_allow_use_of_dispatch_internal();
      if (has_modifiers == 1)
      {
        os_unfair_lock_lock((os_unfair_lock_t)&nw_protocol_modify_lock);
        int v15 = (void *)g_modifier_list;
        if (g_modifier_list)
        {
          while (1)
          {
            os_log_type_t v16 = (uint64_t (*)(uint64_t, uint64_t))v15[2];
            if (v16)
            {
              if (v16(v13, v14)) {
                break;
              }
            }
            int v15 = (void *)*v15;
            if (!v15) {
              goto LABEL_7;
            }
          }
          os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
          uint64_t v17 = *(void *)(v12 + 16);
          if (v17 && !nw_path_parameters_get_logging_disabled(*(void *)(v17 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v18 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
            {
              int v19 = *(_DWORD *)(v12 + 448);
              *(_DWORD *)buf = 136446466;
              uint64_t v66 = "nw_connection_create_with_id";
              __int16 v67 = 1024;
              *(_DWORD *)id v68 = v19;
              _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Connection parameters were modified", buf, 0x12u);
            }
          }
        }
        else
        {
LABEL_7:
          os_unfair_lock_unlock((os_unfair_lock_t)&nw_protocol_modify_lock);
        }
      }
      inner = nw_endpoint_handler_create_inner(*(void **)(v12 + 8), *(void **)(v12 + 16), nw_connection_endpoint_report_on_nw_queue, (void *)v12, 0, *(_DWORD *)(v12 + 448), 0);
      dispatch_data_t v21 = *(void **)(v12 + 144);
      *(void *)(v12 + 144) = inner;

      uint64_t v22 = *(void *)(v12 + 16);
      if (*(void *)(v12 + 144))
      {
        if (v22 && !nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v23 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
          {
            int v24 = *(_DWORD *)(v12 + 448);
            logging_description = nw_endpoint_get_logging_description(v10);
            *(_DWORD *)buf = 136446722;
            uint64_t v66 = "nw_connection_create_with_id";
            __int16 v67 = 1024;
            *(_DWORD *)id v68 = v24;
            v68[2] = 2082;
            *(void *)&v68[3] = logging_description;
            _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, "%{public}s [C%u] create connection to %{public}s", buf, 0x1Cu);
          }
        }
        v61[0] = MEMORY[0x1E4F143A8];
        v61[1] = 3221225472;
        v61[2] = __nw_connection_create_with_id_block_invoke;
        v61[3] = &unk_1E523DB68;
        id v26 = (id)v12;
        id v62 = v26;
        nw_endpoint_enumerate_alternatives(v10, v61);
        id v27 = v26;

        goto LABEL_74;
      }
      if (v22 && !nw_path_parameters_get_logging_disabled(*(void *)(v22 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v39 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v39, OS_LOG_TYPE_ERROR))
        {
          int v40 = *(_DWORD *)(v12 + 448);
          *(_DWORD *)buf = 136446466;
          uint64_t v66 = "nw_connection_create_with_id";
          __int16 v67 = 1024;
          *(_DWORD *)id v68 = v40;
          _os_log_impl(&dword_1830D4000, v39, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Failed to create parent endpoint handler", buf, 0x12u);
        }
      }
LABEL_73:
      id v27 = 0;
LABEL_74:

      goto LABEL_75;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v32 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    uint64_t v66 = "nw_connection_create_with_id";
    int v33 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (__nwlog_fault(v33, &type, &v63))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v34 = (id)gLogObj;
        os_log_type_t v35 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v66 = "nw_connection_create_with_id";
          _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s [nw_connection initWithEndpoint:parameters:] failed", buf, 0xCu);
        }
      }
      else if (v63)
      {
        int v41 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v34 = (id)gLogObj;
        os_log_type_t v42 = type;
        BOOL v43 = os_log_type_enabled(v34, type);
        if (v41)
        {
          if (v43)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v66 = "nw_connection_create_with_id";
            __int16 v67 = 2082;
            *(void *)id v68 = v41;
            _os_log_impl(&dword_1830D4000, v34, v42, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v41);
          if (!v33) {
            goto LABEL_73;
          }
          goto LABEL_72;
        }
        if (v43)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v66 = "nw_connection_create_with_id";
          _os_log_impl(&dword_1830D4000, v34, v42, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v34 = (id)gLogObj;
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v34, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v66 = "nw_connection_create_with_id";
          _os_log_impl(&dword_1830D4000, v34, v45, "%{public}s [nw_connection initWithEndpoint:parameters:] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v33) {
      goto LABEL_73;
    }
LABEL_72:
    free(v33);
    goto LABEL_73;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v28 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v66 = "nw_connection_create_with_id";
  BOOL v29 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v63 = 0;
  if (__nwlog_fault(v29, &type, &v63))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v30 = (id)gLogObj;
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s nw_parameters_copy failed", buf, 0xCu);
      }
    }
    else if (v63)
    {
      uint64_t v36 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v30 = (id)gLogObj;
      os_log_type_t v37 = type;
      BOOL v38 = os_log_type_enabled(v30, type);
      if (v36)
      {
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v66 = "nw_connection_create_with_id";
          __int16 v67 = 2082;
          *(void *)id v68 = v36;
          _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v36);
        if (!v29) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
      if (v38)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v30, v37, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      unsigned int v30 = (id)gLogObj;
      os_log_type_t v44 = type;
      if (os_log_type_enabled(v30, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v66 = "nw_connection_create_with_id";
        _os_log_impl(&dword_1830D4000, v30, v44, "%{public}s nw_parameters_copy failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
  if (v29) {
LABEL_63:
  }
    free(v29);
LABEL_64:
  id v27 = 0;
LABEL_75:

LABEL_76:
  return v27;
}

void sub_18317DD10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *nw_endpoint_handler_create_inner(void *a1, void *a2, void *a3, void *a4, void *a5, unsigned int a6, int a7)
{
  uint64_t v94 = *MEMORY[0x1E4F143B8];
  id v13 = a1;
  id v14 = a2;
  id v84 = a4;
  os_log_type_t v85 = v13;
  id v86 = a5;
  if (!v13)
  {
    os_log_type_t v57 = __nwlog_obj();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90)) {
      goto LABEL_113;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s called with null endpoint", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (!v90)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v77 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v77, "%{public}s called with null endpoint, backtrace limit exceeded", address, 0xCu);
      }
      goto LABEL_112;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v59 = __nwlog_obj();
    os_log_type_t v66 = type;
    BOOL v67 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v67)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v66, "%{public}s called with null endpoint, no backtrace", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (v67)
    {
      *(_DWORD *)address = 136446466;
      *(void *)&address[4] = "nw_endpoint_handler_create_inner";
      *(_WORD *)&address[12] = 2082;
      *(void *)&address[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v59, v66, "%{public}s called with null endpoint, dumping backtrace:%{public}s", address, 0x16u);
    }
    goto LABEL_78;
  }
  if (!v14)
  {
    BOOL v61 = __nwlog_obj();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90)) {
      goto LABEL_113;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s called with null parameters", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (!v90)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v78 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v78, "%{public}s called with null parameters, backtrace limit exceeded", address, 0xCu);
      }
      goto LABEL_112;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v59 = __nwlog_obj();
    os_log_type_t v68 = type;
    BOOL v69 = os_log_type_enabled(v59, type);
    if (!backtrace_string)
    {
      if (v69)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v68, "%{public}s called with null parameters, no backtrace", address, 0xCu);
      }
      goto LABEL_112;
    }
    if (v69)
    {
      *(_DWORD *)address = 136446466;
      *(void *)&address[4] = "nw_endpoint_handler_create_inner";
      *(_WORD *)&address[12] = 2082;
      *(void *)&address[14] = backtrace_string;
      _os_log_impl(&dword_1830D4000, v59, v68, "%{public}s called with null parameters, dumping backtrace:%{public}s", address, 0x16u);
    }
LABEL_78:

    free(backtrace_string);
    if (!v58) {
      goto LABEL_115;
    }
    goto LABEL_114;
  }
  if (!a3)
  {
    char v63 = __nwlog_obj();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    BOOL v58 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (!__nwlog_fault(v58, &type, &v90)) {
      goto LABEL_113;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v64, "%{public}s called with null report_callback", address, 0xCu);
      }
    }
    else if (v90)
    {
      id v70 = (char *)__nw_create_backtrace_string();
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v71 = type;
      BOOL v72 = os_log_type_enabled(v59, type);
      if (v70)
      {
        if (v72)
        {
          *(_DWORD *)address = 136446466;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          *(_WORD *)&address[12] = 2082;
          *(void *)&address[14] = v70;
          _os_log_impl(&dword_1830D4000, v59, v71, "%{public}s called with null report_callback, dumping backtrace:%{public}s", address, 0x16u);
        }

        free(v70);
LABEL_113:
        if (!v58)
        {
LABEL_115:
          int v33 = 0;
          goto LABEL_53;
        }
LABEL_114:
        free(v58);
        goto LABEL_115;
      }
      if (v72)
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v71, "%{public}s called with null report_callback, no backtrace", address, 0xCu);
      }
    }
    else
    {
      os_log_type_t v59 = __nwlog_obj();
      os_log_type_t v79 = type;
      if (os_log_type_enabled(v59, type))
      {
        *(_DWORD *)address = 136446210;
        *(void *)&address[4] = "nw_endpoint_handler_create_inner";
        _os_log_impl(&dword_1830D4000, v59, v79, "%{public}s called with null report_callback, backtrace limit exceeded", address, 0xCu);
      }
    }
LABEL_112:

    goto LABEL_113;
  }
  id v15 = v13;
  int v16 = [v15 type];

  if (v16 == 1)
  {
    uint64_t v17 = v14;
    id v18 = *((id *)v17[13].isa + 20);

    if (v18)
    {
      int v19 = v18;
      int v20 = [v19 type];

      if (v20 == 1)
      {
        int address_family = nw_endpoint_get_address_family(v15);
        int v22 = nw_endpoint_get_address_family(v19);
        os_log_type_t v23 = nw_endpoint_get_address(v19);
        if (address_family != v22)
        {
          if (v23)
          {
            if (v22 == 30)
            {
              if (!*(_DWORD *)&v23->sa_data[6]
                && !*(_DWORD *)&v23->sa_data[10]
                && !*(_DWORD *)&v23[1].sa_len
                && !*(_DWORD *)&v23[1].sa_data[2])
              {
                *(void *)&address[8] = 0;
                *(void *)address = 528;
                *(_WORD *)&address[2] = *(_WORD *)v23->sa_data;
                *(void *)&address[4] = 0;
                uint32_t v25 = nw_endpoint_create_address((const sockaddr *)address);
                nw_parameters_set_local_endpoint(v17, v25);
              }
            }
            else if (v22 == 2 && !*(_DWORD *)&v23->sa_data[2])
            {
              int v93 = 0;
              *(void *)&address[8] = 0;
              *(void *)&address[16] = 0;
              *(void *)address = 7708;
              *(_WORD *)&address[2] = *(_WORD *)v23->sa_data;
              int v24 = nw_endpoint_create_address((const sockaddr *)address);
              nw_parameters_set_local_endpoint(v17, v24);
            }
          }
        }
      }
    }
  }
  id v26 = v15;
  id v27 = nw_endpoint_copy_public_keys(v26);
  if (v27)
  {
    id v28 = v26;
    BOOL v29 = (void *)[v28 copyEndpoint];
    nw_endpoint_copy_properties(v28, v29);

    nw_endpoint_set_public_keys(v29, 0);
    unsigned int v30 = (id *)v14;
    os_log_type_t v31 = v30[19];

    iterate_block[0] = MEMORY[0x1E4F143A8];
    iterate_block[1] = 3221225472;
    iterate_block[2] = ___ZL32nw_endpoint_handler_create_innerPU25objcproto14OS_nw_endpoint8NSObjectPU27objcproto16OS_nw_parametersS_PFbP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS_ESD_S5_jb_block_invoke;
    iterate_block[3] = &unk_1E5248AC0;
    id v88 = v27;
    id v89 = v30;
    nw_protocol_stack_iterate_application_protocols(v31, iterate_block);

    id v26 = v29;
  }
  id v32 = -[NWConcrete_nw_endpoint_handler initWithEndpoint:parameters:reportCallback:context:parent:identifier:]((id *)[NWConcrete_nw_endpoint_handler alloc], v26, v14, a3, v84, v86, a6);
  int v33 = v32;
  if (!v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v38 = (id)gLogObj;
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_handler_create_inner";
    id v39 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (__nwlog_fault(v39, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v40 = (id)gLogObj;
        os_log_type_t v41 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed", address, 0xCu);
        }
      }
      else if (v90)
      {
        os_log_type_t v52 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v40 = (id)gLogObj;
        os_log_type_t v53 = type;
        BOOL v54 = os_log_type_enabled(v40, type);
        if (v52)
        {
          if (v54)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[4] = "nw_endpoint_handler_create_inner";
            *(_WORD *)&address[12] = 2082;
            *(void *)&address[14] = v52;
            _os_log_impl(&dword_1830D4000, v40, v53, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(v52);
          if (!v39) {
            goto LABEL_52;
          }
          goto LABEL_51;
        }
        if (v54)
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl(&dword_1830D4000, v40, v53, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, no backtrace", address, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v40 = (id)gLogObj;
        os_log_type_t v55 = type;
        if (os_log_type_enabled(v40, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_handler_create_inner";
          _os_log_impl(&dword_1830D4000, v40, v55, "%{public}s [nw_endpoint_handler initWithEndpoint:parameters:] failed, backtrace limit exceeded", address, 0xCu);
        }
      }
    }
    if (!v39) {
      goto LABEL_52;
    }
LABEL_51:
    free(v39);
    goto LABEL_52;
  }
  if (a7) {
    *((unsigned char *)v32 + 268) |= 1u;
  }
  uint64_t v34 = v14;
  BOOL v35 = (v34[12] & 0x800) == 0;

  if (v35)
  {
    if (v86 || (*((unsigned char *)v33 + 268) & 1) != 0)
    {
      *((_DWORD *)v33 + 29) = 0;
    }
    else
    {
      *((_DWORD *)v33 + 29) = 2;
      uint64_t v36 = objc_alloc_init(NWConcrete_nw_endpoint_flow);
      *((unsigned char *)v36 + 32) = *((unsigned char *)v36 + 32) & 0xFC | 1;
      id v37 = v33[31];
      v33[31] = v36;
    }
    goto LABEL_37;
  }
  *((_DWORD *)v33 + 29) = 2;
  id v42 = v33[9];
  BOOL v43 = objc_alloc_init(NWConcrete_nw_endpoint_flow);
  *((unsigned char *)v43 + 32) = *((unsigned char *)v43 + 32) & 0xFC | (v42 == 0) | 2;
  id v44 = v33[31];
  v33[31] = v43;

  id v45 = v33[31];
  uint64_t v46 = v33;
  os_log_type_t v47 = v45;
  BOOL v48 = v47;
  if (!v47)
  {
    os_log_type_t v73 = __nwlog_obj();
    *(_DWORD *)address = 136446210;
    *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
    id v74 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v90 = 0;
    if (__nwlog_fault(v74, &type, &v90))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v75 = __nwlog_obj();
        os_log_type_t v76 = type;
        if (os_log_type_enabled(v75, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s called with null endpoint_flow", address, 0xCu);
        }
      }
      else if (v90)
      {
        id v80 = (char *)__nw_create_backtrace_string();
        uint64_t v75 = __nwlog_obj();
        os_log_type_t v83 = type;
        BOOL v81 = os_log_type_enabled(v75, type);
        if (v80)
        {
          if (v81)
          {
            *(_DWORD *)address = 136446466;
            *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
            *(_WORD *)&address[12] = 2082;
            *(void *)&address[14] = v80;
            _os_log_impl(&dword_1830D4000, v75, v83, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", address, 0x16u);
          }

          free(v80);
          goto LABEL_122;
        }
        if (v81)
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_1830D4000, v75, v83, "%{public}s called with null endpoint_flow, no backtrace", address, 0xCu);
        }
      }
      else
      {
        uint64_t v75 = __nwlog_obj();
        os_log_type_t v82 = type;
        if (os_log_type_enabled(v75, type))
        {
          *(_DWORD *)address = 136446210;
          *(void *)&address[4] = "nw_endpoint_flow_set_custom_protocols_only";
          _os_log_impl(&dword_1830D4000, v75, v82, "%{public}s called with null endpoint_flow, backtrace limit exceeded", address, 0xCu);
        }
      }
    }
LABEL_122:
    if (v74) {
      free(v74);
    }
    goto LABEL_35;
  }
  *((unsigned char *)v47 + 34) |= 2u;
  nw_endpoint_t v49 = nw_endpoint_handler_copy_endpoint(v46);
  os_log_type_t v50 = (void *)v48[121];
  v48[121] = v49;

LABEL_35:
LABEL_37:
  uint64_t v51 = v33;
LABEL_52:

LABEL_53:
  return v33;
}

void sub_18317EC40(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_connection_add_client_event_internal(void *a1, int a2, void *a3, void *a4)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a3;
  id v9 = a4;
  if (v7)
  {
    uint64_t v10 = mach_continuous_time();
    if (v10 <= 1) {
      uint64_t v11 = 1;
    }
    else {
      uint64_t v11 = v10;
    }
    unint64_t v12 = nw_delta_nanos(v7[9], v11);
    if (v12 > 0xF423FFFFFFFFFLL) {
      unsigned int v13 = -1;
    }
    else {
      unsigned int v13 = v12 / 0xF4240;
    }
    if (nw_parameters_get_logging_disabled(v7[2])) {
      goto LABEL_28;
    }
    if ((a2 & 0xFFFFFFFE) == 4)
    {
      if (!v9 || !nw_activity_should_log(v9)) {
        goto LABEL_28;
      }
      if (__nwlog_activity_log::onceToken != -1) {
        dispatch_once(&__nwlog_activity_log::onceToken, &__block_literal_global_16_44861);
      }
      id v14 = (id)gactivityLogObj;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT))
      {
LABEL_27:

LABEL_28:
        v30[0] = MEMORY[0x1E4F143A8];
        v30[1] = 3221225472;
        v30[2] = ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke;
        void v30[3] = &unk_1E5249DE8;
        uint64_t v34 = v11;
        int v35 = a2;
        os_log_type_t v31 = v7;
        id v32 = v8;
        id v33 = v9;
        nw_connection_async_if_needed(v31, v30);

        goto LABEL_29;
      }
      if ((unsigned __int16)(a2 - 1) > 4u) {
        id v15 = "unknown";
      }
      else {
        id v15 = off_1E5240188[(unsigned __int16)(a2 - 1)];
      }
      int v21 = *((_DWORD *)v7 + 112);
      *(_DWORD *)buf = 67110146;
      *(_DWORD *)id v39 = v21;
      *(_WORD *)&v39[4] = 2082;
      *(void *)&v39[6] = v15;
      *(_WORD *)&v39[14] = 1024;
      *(_DWORD *)&v39[16] = v13 / 0x3E8;
      __int16 v40 = 1024;
      unsigned int v41 = v13 % 0x3E8;
      __int16 v42 = 2114;
      id v43 = v9;
      id v18 = "[C%u] event: client:%{public}s @%u.%03us, activity %{public}@";
      int v19 = v14;
      uint32_t v20 = 40;
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v14 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v14, OS_LOG_TYPE_DEFAULT)) {
        goto LABEL_27;
      }
      if ((unsigned __int16)(a2 - 1) > 4u) {
        int v16 = "unknown";
      }
      else {
        int v16 = off_1E5240188[(unsigned __int16)(a2 - 1)];
      }
      int v17 = *((_DWORD *)v7 + 112);
      *(_DWORD *)buf = 67109890;
      *(_DWORD *)id v39 = v17;
      *(_WORD *)&v39[4] = 2082;
      *(void *)&v39[6] = v16;
      *(_WORD *)&v39[14] = 1024;
      *(_DWORD *)&v39[16] = v13 / 0x3E8;
      __int16 v40 = 1024;
      unsigned int v41 = v13 % 0x3E8;
      id v18 = "[C%u] event: client:%{public}s @%u.%03us";
      int v19 = v14;
      uint32_t v20 = 30;
    }
    _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEFAULT, v18, buf, v20);
    goto LABEL_27;
  }
  int v22 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)id v39 = "nw_connection_add_client_event_internal";
  os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v36 = 0;
  if (__nwlog_fault(v23, &type, &v36))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)id v39 = "nw_connection_add_client_event_internal";
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v36)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)id v39 = "nw_connection_add_client_event_internal";
          *(_WORD *)&v39[8] = 2082;
          *(void *)&v39[10] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_46;
      }
      if (v28)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)id v39 = "nw_connection_add_client_event_internal";
        _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v24 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)id v39 = "nw_connection_add_client_event_internal";
        _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_46:
  if (v23) {
    free(v23);
  }
LABEL_29:
}

void sub_18317F544(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18317F8F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_parameters_get_logging_disabled(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    uint64_t v3 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v14 = "nw_path_parameters_get_logging_disabled";
    id v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (__nwlog_fault(v4, &type, &v11))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          id v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null path_parameters", buf, 0xCu);
        }
      }
      else if (v11)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v5 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            id v14 = "nw_path_parameters_get_logging_disabled";
            __int16 v15 = 2082;
            int v16 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null path_parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          id v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null path_parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v5 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          id v14 = "nw_path_parameters_get_logging_disabled";
          _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null path_parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v4) {
      free(v4);
    }
    return 0;
  }
  uint64_t v1 = *(void *)(a1 + 136);
  if (v1) {
    return *(_DWORD *)(v1 + 124) == 4;
  }
  return 0;
}

BOOL nw_parameters_get_logging_disabled(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v1 = *(void *)(a1 + 104);
    return nw_path_parameters_get_logging_disabled(v1);
  }
  uint64_t v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v14 = "nw_parameters_get_logging_disabled";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        id v14 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          id v14 = "nw_parameters_get_logging_disabled";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        id v14 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        id v14 = "nw_parameters_get_logging_disabled";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v4) {
    free(v4);
  }
  return 1;
}

void nw_endpoint_handler_inherit_from_parent(NWConcrete_nw_endpoint_handler *a1, NWConcrete_nw_endpoint_handler *a2, unsigned int next_top_id)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  os_log_type_t v6 = a2;
  if (v6)
  {
    objc_storeStrong((id *)&v5->parent_handler, a2);
    v5->top_id = v6->top_id;
    *((unsigned char *)v5 + 268) = *((unsigned char *)v5 + 268) & 0xFE | *((unsigned char *)v6 + 268) & 1;
    if (v6->id_chain[0])
    {
      if (v6->id_chain[1])
      {
        if (v6->id_chain[2])
        {
          if (v6->id_chain[3])
          {
            if (v6->id_chain[4])
            {
              if (v6->id_chain[5])
              {
                if (v6->id_chain[6])
                {
                  if (v6->id_chain[7])
                  {
                    if (v6->id_chain[8])
                    {
                      if (v6->id_chain[9])
                      {
                        if (v6->id_chain[10])
                        {
                          if (v6->id_chain[11])
                          {
                            if (v6->id_chain[12])
                            {
                              if (v6->id_chain[13])
                              {
                                if (v6->id_chain[14])
                                {
                                  if (v6->id_chain[15])
                                  {
                                    id v7 = __nwlog_obj();
                                    *(_DWORD *)buf = 136446210;
                                    uint32_t v20 = "nw_endpoint_handler_inherit_from_parent";
                                    os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

                                    os_log_type_t type = OS_LOG_TYPE_ERROR;
                                    char v17 = 0;
                                    if (__nwlog_fault(v8, &type, &v17))
                                    {
                                      if (type == OS_LOG_TYPE_FAULT)
                                      {
                                        BOOL v9 = __nwlog_obj();
                                        os_log_type_t v10 = type;
                                        if (os_log_type_enabled(v9, type))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          uint32_t v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s reached maximum endpoint handler depth", buf, 0xCu);
                                        }
                                      }
                                      else if (v17)
                                      {
                                        backtrace_string = (char *)__nw_create_backtrace_string();
                                        BOOL v9 = __nwlog_obj();
                                        os_log_type_t v14 = type;
                                        BOOL v15 = os_log_type_enabled(v9, type);
                                        if (backtrace_string)
                                        {
                                          if (v15)
                                          {
                                            *(_DWORD *)buf = 136446466;
                                            uint32_t v20 = "nw_endpoint_handler_inherit_from_parent";
                                            __int16 v21 = 2082;
                                            int v22 = backtrace_string;
                                            _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s reached maximum endpoint handler depth, dumping backtrace:%{public}s", buf, 0x16u);
                                          }

                                          free(backtrace_string);
                                          goto LABEL_56;
                                        }
                                        if (v15)
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          uint32_t v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s reached maximum endpoint handler depth, no backtrace", buf, 0xCu);
                                        }
                                      }
                                      else
                                      {
                                        BOOL v9 = __nwlog_obj();
                                        os_log_type_t v16 = type;
                                        if (os_log_type_enabled(v9, type))
                                        {
                                          *(_DWORD *)buf = 136446210;
                                          uint32_t v20 = "nw_endpoint_handler_inherit_from_parent";
                                          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s reached maximum endpoint handler depth, backtrace limit exceeded", buf, 0xCu);
                                        }
                                      }
                                    }
LABEL_56:
                                    if (v8) {
                                      free(v8);
                                    }
                                    goto LABEL_44;
                                  }
                                  uint64_t v11 = 15;
                                  size_t v12 = 14;
                                }
                                else
                                {
                                  uint64_t v11 = 14;
                                  size_t v12 = 13;
                                }
                              }
                              else
                              {
                                uint64_t v11 = 13;
                                size_t v12 = 12;
                              }
                            }
                            else
                            {
                              uint64_t v11 = 12;
                              size_t v12 = 11;
                            }
                          }
                          else
                          {
                            uint64_t v11 = 11;
                            size_t v12 = 10;
                          }
                        }
                        else
                        {
                          uint64_t v11 = 10;
                          size_t v12 = 9;
                        }
                      }
                      else
                      {
                        uint64_t v11 = 9;
                        size_t v12 = 8;
                      }
                    }
                    else
                    {
                      uint64_t v11 = 8;
                      size_t v12 = 7;
                    }
                  }
                  else
                  {
                    uint64_t v11 = 7;
                    size_t v12 = 6;
                  }
                }
                else
                {
                  uint64_t v11 = 6;
                  size_t v12 = 5;
                }
              }
              else
              {
                uint64_t v11 = 5;
                size_t v12 = 4;
              }
            }
            else
            {
              uint64_t v11 = 4;
              size_t v12 = 3;
            }
          }
          else
          {
            uint64_t v11 = 3;
            size_t v12 = 2;
          }
        }
        else
        {
          uint64_t v11 = 2;
          size_t v12 = 1;
        }
      }
      else
      {
        size_t v12 = 0;
        uint64_t v11 = 1;
      }
      memcpy(v5->id_chain, v6->id_chain, v12);
    }
    else
    {
      uint64_t v11 = 0;
    }
    v5->id_chain[v11] = nw_endpoint_handler_get_next_id((atomic_uint *)&v6->last_child_id);
    snprintf(v5->id_str, 0x4BuLL, "%s.%u");
    goto LABEL_44;
  }
  if (!next_top_id) {
    next_top_id = nw_endpoint_handler_get_next_top_id();
  }
  v5->top_id = next_top_id;
  snprintf(v5->id_str, 0x4BuLL, "%u");
LABEL_44:
}

uint64_t nw_endpoint_handler_get_next_id(atomic_uint *a1)
{
  uint64_t v9 = *MEMORY[0x1E4F143B8];
  unsigned int v1 = atomic_fetch_add(a1, 1u) + 1;
  if (v1 >= 0x100 && !(_BYTE)v1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v3 = (id)gLogObj;
    if (os_log_type_enabled(v3, OS_LOG_TYPE_ERROR))
    {
      int v5 = 136446466;
      os_log_type_t v6 = "nw_endpoint_handler_get_next_id";
      __int16 v7 = 1024;
      unsigned int v8 = v1;
      _os_log_impl(&dword_1830D4000, v3, OS_LOG_TYPE_ERROR, "%{public}s reached %u child endpoint handlers, wrapping", (uint8_t *)&v5, 0x12u);
    }

    LOBYTE(v1) = nw_endpoint_handler_get_next_id(a1);
  }
  return v1;
}

NWConcrete_nw_proxy_config *nw_proxy_config_create_fallback_privacy_proxy(void *a1)
{
  uint64_t v90 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v68 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
    BOOL v69 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v84 = 0;
    if (!__nwlog_fault(v69, &type, &v84)) {
      goto LABEL_177;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (os_log_type_enabled(v70, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s called with null array", buf, 0xCu);
      }
    }
    else if (v84)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v70 = __nwlog_obj();
      os_log_type_t v75 = type;
      BOOL v76 = os_log_type_enabled(v70, type);
      if (backtrace_string)
      {
        if (v76)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
          __int16 v88 = 2082;
          id v89 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v70, v75, "%{public}s called with null array, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        if (!v69) {
          goto LABEL_179;
        }
        goto LABEL_178;
      }
      if (v76)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_1830D4000, v70, v75, "%{public}s called with null array, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v70 = __nwlog_obj();
      os_log_type_t v80 = type;
      if (os_log_type_enabled(v70, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_1830D4000, v70, v80, "%{public}s called with null array, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_176;
  }
  uint64_t v4 = *((void *)v1 + 2);
  uint64_t v3 = *((void *)v1 + 3);
  uint64_t v5 = v3 - v4;
  if (v3 == v4)
  {
    BOOL v72 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
    BOOL v69 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v84 = 0;
    if (!__nwlog_fault(v69, &type, &v84)) {
      goto LABEL_177;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v70 = __nwlog_obj();
      os_log_type_t v73 = type;
      if (os_log_type_enabled(v70, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_1830D4000, v70, v73, "%{public}s called with null (hop_count > 0)", buf, 0xCu);
      }
    }
    else if (v84)
    {
      os_log_type_t v77 = (char *)__nw_create_backtrace_string();
      id v70 = __nwlog_obj();
      os_log_type_t v78 = type;
      BOOL v79 = os_log_type_enabled(v70, type);
      if (v77)
      {
        if (v79)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
          __int16 v88 = 2082;
          id v89 = v77;
          _os_log_impl(&dword_1830D4000, v70, v78, "%{public}s called with null (hop_count > 0), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v77);
LABEL_177:
        if (!v69)
        {
LABEL_179:
          int v22 = 0;
          goto LABEL_143;
        }
LABEL_178:
        free(v69);
        goto LABEL_179;
      }
      if (v79)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_1830D4000, v70, v78, "%{public}s called with null (hop_count > 0), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v70 = __nwlog_obj();
      os_log_type_t v81 = type;
      if (os_log_type_enabled(v70, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        _os_log_impl(&dword_1830D4000, v70, v81, "%{public}s called with null (hop_count > 0), backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_176:

    goto LABEL_177;
  }
  os_log_type_t v6 = objc_alloc_init(NWConcrete_nw_protocol_stack);
  if (v5 >> 3 == 2)
  {
    uint64_t v7 = nw_array_get_object_at_index((uint64_t)v2, 0);
    uint64_t v9 = nw_array_get_object_at_index((uint64_t)v2, 1uLL);
    if (nw_protocol_options_is_masque(*(void **)(v7 + 40)))
    {
      if (nw_protocol_options_is_masque(*(void **)(v9 + 40)))
      {
        os_log_type_t v14 = nw_protocol_options_copy(*(void **)(v7 + 40));
        uint64_t v11 = v14;
        BOOL v15 = *(void **)(v7 + 32);
        if (!v15) {
          BOOL v15 = *(void **)(v7 + 24);
        }
        nw_protocol_options_set_proxy_endpoint(v14, v15, 0);
        if (nw_protocol_copy_http2_definition_onceToken[0] != -1) {
          dispatch_once(nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_4_73885);
        }
        options = nw_protocol_create_options((void *)nw_protocol_copy_http2_definition_http2_definition);
        nw_http2_set_idle_timeout(options, 60);
        id v16 = *(id *)(v7 + 48);
        if (v16)
        {
          char v17 = (NWConcrete_nw_protocol_options *)v16;
          sec_protocol_options_add_tls_application_protocol(&v17->super, "h2");
          sec_protocol_options_set_min_tls_protocol_version(&v17->super, tls_protocol_version_TLSv13);
        }
        else
        {
          if (nw_protocol_copy_serializable_tls_definition::onceToken != -1) {
            dispatch_once(&nw_protocol_copy_serializable_tls_definition::onceToken, &__block_literal_global_73554);
          }
          char v17 = nw_protocol_create_options((void *)nw_protocol_copy_serializable_tls_definition::tls_definition);
          nw_serializable_tls_set_add_h2_alpn(v17);
          nw_serializable_tls_set_require_tls13(v17);
          uint64_t v28 = *(void *)(v7 + 56);
          if (v28)
          {
            nw_serializable_tls_set_server_raw_public_keys(v17, v28);
          }
          else
          {
            uint64_t v32 = *(void *)(v7 + 64);
            if (v32)
            {
              nw_serializable_tls_set_client_identity_reference(v17, v32, *(void *)(v7 + 72));
            }
            else if ((*(unsigned char *)(v7 + 80) & 0x10) != 0)
            {
              nw_serializable_tls_set_trust_certs(v17);
            }
          }
        }
        os_log_type_t v82 = v17;
        uint64_t v34 = *(void *)(v9 + 32);
        if (!v34) {
          uint64_t v34 = *(void *)(v9 + 24);
        }
        nw_masque_options_set_target_endpoint(v11, v34);
        int v35 = nw_protocol_options_copy(*(void **)(v9 + 40));
        char v36 = v35;
        id v37 = *(void **)(v9 + 32);
        if (!v37) {
          id v37 = *(void **)(v9 + 24);
        }
        nw_protocol_options_set_proxy_endpoint(v35, v37, 1);
        p_super = &v36->super;
        if ((*(unsigned char *)(v7 + 81) & 2) != 0)
        {
          nw_masque_options_set_forced_protocol(v11, 2);
          if (nw_protocol_copy_http3_definition_onceToken != -1) {
            dispatch_once(&nw_protocol_copy_http3_definition_onceToken, &__block_literal_global_13_73886);
          }
          unsigned int v41 = nw_protocol_create_options((void *)nw_protocol_copy_http3_definition_http3_definition);
          id v38 = v41;
          if ((*(unsigned char *)(v9 + 80) & 2) != 0)
          {
            nw_http3_set_0rtt_enabled(v41, 1);
            nw_http3_set_idle_timeout(v38, 30);
            nw_http3_set_keepalive_mode(v38, 2);
            if (!uuid_is_null((const unsigned __int8 *)(v9 + 8))) {
              nw_http3_set_resumable_session_agent(v38, v9 + 8);
            }
          }
          else
          {
            nw_http3_set_idle_timeout(v41, 900);
            nw_http3_set_keepalive_mode(v38, 1);
          }
          if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
            dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
          }
          __int16 v40 = nw_protocol_create_options((void *)nw_protocol_copy_quic_stream_definition::quic_definition);
          __int16 v42 = (NWConcrete_nw_protocol_options *)nw_quic_stream_copy_shared_connection_options(v40);
          id v43 = v42;
          char v44 = *(unsigned char *)(v9 + 80);
          if ((v44 & 4) != 0)
          {
            nw_quic_connection_set_enable_l4s(v42, 1);
            char v44 = *(unsigned char *)(v9 + 80);
          }
          if ((v44 & 8) != 0) {
            nw_quic_connection_set_enable_multipath(v43, 1);
          }
          nw_quic_connection_set_idle_timeout(v43, 0);
          nw_quic_connection_set_max_datagram_frame_size(v43, 0xFFFF);
          nw_quic_connection_set_max_udp_payload_size(v43, 1472);
          nw_quic_connection_set_datagram_variant_flow_id_enabled(v43, 1);
          if (nw_masque_options_get_version(v36) == 2)
          {
            nw_quic_connection_set_datagram_quarter_stream_id(v43, 1);
            nw_quic_connection_set_datagram_context_id(v43, 1);
          }
          nw_quic_connection_set_source_connection_id_length(v43, 8);
          nw_quic_connection_set_initial_packet_size(v43, 1304);
          id v45 = *(void **)(v9 + 48);
          if (v45)
          {
            id v46 = v45;
            nw_quic_connection_set_sec_protocol_options(v43, v46);
          }
          uint64_t v47 = *(void *)(v9 + 56);
          if (v47)
          {
            nw_quic_connection_set_server_raw_public_keys(v43, v47);
          }
          else
          {
            uint64_t v50 = *(void *)(v9 + 64);
            if (v50)
            {
              nw_quic_connection_set_client_identity_reference(v43, v50, *(void *)(v9 + 72));
            }
            else if ((*(unsigned char *)(v9 + 80) & 0x10) != 0)
            {
              nw_quic_connection_set_override_trust_certs_for_tests(v43, 1);
            }
          }
          nw_quic_connection_add_h3_alpn(v43, 1);
          nw_quic_connection_set_keepalive_count(v43, 3);
          nw_protocol_stack_append_application_protocol(v6, p_super);
          nw_protocol_stack_append_application_protocol(v6, v38);
          nw_protocol_stack_append_application_protocol(v6, v40);
          nw_protocol_stack_append_application_protocol(v6, v11);
          nw_protocol_stack_append_application_protocol(v6, options);
          nw_protocol_stack_append_application_protocol(v6, v82);
          if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
            dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
          }
          os_log_type_t v52 = nw_protocol_create_options((void *)g_tcp_definition);
          nw_protocol_stack_set_transport_protocol(&v6->super, &v52->super);
        }
        else
        {
          nw_masque_options_set_forced_protocol(v11, 1);
          if (nw_protocol_copy_http2_definition_onceToken[0] != -1) {
            dispatch_once(nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_4_73885);
          }
          id v38 = nw_protocol_create_options((void *)nw_protocol_copy_http2_definition_http2_definition);
          nw_http2_set_idle_timeout(v38, 900);
          id v39 = *(id *)(v9 + 48);
          if (v39)
          {
            __int16 v40 = (NWConcrete_nw_protocol_options *)v39;
            sec_protocol_options_add_tls_application_protocol(&v40->super, "h2");
            sec_protocol_options_set_min_tls_protocol_version(&v40->super, tls_protocol_version_TLSv13);
          }
          else
          {
            serializable_options = nw_tls_create_serializable_options();
            nw_serializable_tls_set_add_h2_alpn(serializable_options);
            nw_serializable_tls_set_require_tls13(serializable_options);
            uint64_t v49 = *(void *)(v9 + 56);
            if (v49)
            {
              __int16 v40 = serializable_options;
              nw_serializable_tls_set_server_raw_public_keys(serializable_options, v49);
            }
            else
            {
              uint64_t v51 = *(void *)(v9 + 64);
              if (v51)
              {
                __int16 v40 = serializable_options;
                nw_serializable_tls_set_client_identity_reference(serializable_options, v51, *(void *)(v9 + 72));
              }
              else
              {
                __int16 v40 = serializable_options;
                if ((*(unsigned char *)(v9 + 80) & 0x10) != 0) {
                  nw_serializable_tls_set_trust_certs(serializable_options);
                }
              }
            }
          }
          nw_protocol_stack_append_application_protocol(v6, v36);
          nw_protocol_stack_append_application_protocol(v6, v38);
          nw_protocol_stack_append_application_protocol(v6, v40);
          nw_protocol_stack_append_application_protocol(v6, v11);
          nw_protocol_stack_append_application_protocol(v6, options);
          nw_protocol_stack_append_application_protocol(v6, v82);
          if (nw_protocol_demux_copy_definition::onceToken != -1) {
            dispatch_once(&nw_protocol_demux_copy_definition::onceToken, &__block_literal_global_8_26174);
          }
          if (nw_protocol_demux_copy_definition::definition)
          {
            os_log_type_t v62 = os_retain((void *)nw_protocol_demux_copy_definition::definition);
            char v63 = nw_protocol_create_options(v62);
            if (v62) {
              os_release(v62);
            }
          }
          else
          {
            char v63 = nw_protocol_create_options(0);
          }
          nw_protocol_stack_append_application_protocol(v6, v63);

          if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
            dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
          }
          id v43 = nw_protocol_create_options((void *)g_tcp_definition);
          nw_protocol_stack_set_transport_protocol(&v6->super, &v43->super);
        }
        BOOL v61 = v38;

        id v64 = nw_protocol_options_copy_proxy_endpoint_for_stack(v11);
        int v22 = nw_proxy_config_create_with_stack(v64, v6);

        if (nw_masque_options_get_version(p_super) == 2 || (*(unsigned char *)(v7 + 81) & 2) != 0)
        {
          if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
            dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
          }
          id v65 = (id)g_udp_definition;
          nw_proxy_config_set_alternate_protocol_stack(v22, 0, v65, 4u);

          if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
            dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
          }
          id v66 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
          nw_proxy_config_set_alternate_protocol_stack(v22, 0, v66, 3u);

          if (*(unsigned char *)(v9 + 80)) {
            nw_proxy_config_set_alternate_protocol_stack(v22, 0, 0, 2u);
          }
        }
        nw_proxy_config_set_is_privacy_proxy(v22, 1, 0);
LABEL_140:

LABEL_141:
        nw_proxy_config_set_type(v22, 3006);
        goto LABEL_142;
      }
      if (nw_protocol_options_is_oblivious_http(*(void **)(v9 + 40)))
      {
        uint64_t v23 = nw_protocol_options_copy(*(void **)(v7 + 40));
        uint64_t v11 = v23;
        int v24 = *(void **)(v7 + 32);
        if (!v24) {
          int v24 = *(void **)(v7 + 24);
        }
        nw_protocol_options_set_proxy_endpoint(v23, v24, 0);
        options = nw_protocol_options_copy(*(void **)(v9 + 40));
        if (nw_protocol_copy_http2_definition_onceToken[0] != -1) {
          dispatch_once(nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_4_73885);
        }
        os_log_type_t v82 = nw_protocol_create_options((void *)nw_protocol_copy_http2_definition_http2_definition);
        nw_http2_set_idle_timeout(v82, 60);
        id v25 = *(id *)(v7 + 48);
        if (v25)
        {
          p_super = v25;
          sec_protocol_options_add_tls_application_protocol(p_super, "h2");
          sec_protocol_options_set_min_tls_protocol_version(p_super, tls_protocol_version_TLSv13);
        }
        else
        {
          unsigned int v30 = nw_tls_create_serializable_options();
          nw_serializable_tls_set_add_h2_alpn(v30);
          nw_serializable_tls_set_require_tls13(v30);
          uint64_t v31 = *(void *)(v7 + 56);
          if (v31)
          {
            p_super = &v30->super;
            nw_serializable_tls_set_server_raw_public_keys(v30, v31);
          }
          else
          {
            uint64_t v33 = *(void *)(v7 + 64);
            if (v33)
            {
              p_super = &v30->super;
              nw_serializable_tls_set_client_identity_reference(v30, v33, *(void *)(v7 + 72));
            }
            else
            {
              p_super = &v30->super;
              if ((*(unsigned char *)(v7 + 80) & 0x10) != 0) {
                nw_serializable_tls_set_trust_certs(v30);
              }
            }
          }
        }
        nw_protocol_stack_append_application_protocol(v6, options);
        nw_protocol_stack_append_application_protocol(v6, v11);
        nw_protocol_stack_append_application_protocol(v6, v82);
        nw_protocol_stack_append_application_protocol(v6, p_super);
        if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
          dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
        }
        os_log_type_t v57 = nw_protocol_create_options((void *)g_tcp_definition);
        nw_protocol_stack_set_transport_protocol(&v6->super, &v57->super);

        id v58 = nw_protocol_options_copy_proxy_endpoint_for_stack(v11);
        int v22 = nw_proxy_config_create_with_stack(v58, v6);

        nw_proxy_config_set_is_privacy_proxy(v22, 1, 0);
        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
        }
        id v59 = (id)nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_required_protocol(v22, v59);

        if (nw_protocol_copy_http_messaging_definition_onceToken != -1) {
          dispatch_once(&nw_protocol_copy_http_messaging_definition_onceToken, &__block_literal_global_81);
        }
        id v60 = (id)nw_protocol_copy_http_messaging_definition_definition;
        nw_proxy_config_add_protocol_to_remove(v22, v60);

        BOOL v61 = (void *)nw_protocol_boringssl_copy_definition();
        nw_proxy_config_add_protocol_to_remove(v22, v61);
        goto LABEL_140;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v20 = (id)gLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        __int16 v21 = "%{public}s Second hop must be MASQUE or OHTTP";
        goto LABEL_28;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint32_t v20 = (id)gLogObj;
      if (os_log_type_enabled(v20, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
        __int16 v21 = "%{public}s First hop must be MASQUE";
LABEL_28:
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_ERROR, v21, buf, 0xCu);
      }
    }

    goto LABEL_30;
  }
  if (v5 >> 3 == 1)
  {
    uint64_t v7 = nw_array_get_object_at_index((uint64_t)v2, 0);
    if (nw_protocol_options_is_masque(*(void **)(v7 + 40)))
    {
      unsigned int v8 = nw_protocol_options_copy(*(void **)(v7 + 40));
      uint64_t v9 = (uint64_t)v8;
      os_log_type_t v10 = *(void **)(v7 + 32);
      if (!v10) {
        os_log_type_t v10 = *(void **)(v7 + 24);
      }
      nw_protocol_options_set_proxy_endpoint(v8, v10, 0);
      if (nw_protocol_copy_http2_definition_onceToken[0] != -1) {
        dispatch_once(nw_protocol_copy_http2_definition_onceToken, &__block_literal_global_4_73885);
      }
      uint64_t v11 = nw_protocol_create_options((void *)nw_protocol_copy_http2_definition_http2_definition);
      nw_http2_set_idle_timeout(v11, 60);
      id v12 = *(id *)(v7 + 48);
      if (v12)
      {
        options = (NWConcrete_nw_protocol_options *)v12;
        sec_protocol_options_add_tls_application_protocol(&options->super, "h2");
        sec_protocol_options_set_min_tls_protocol_version(&options->super, tls_protocol_version_TLSv13);
      }
      else
      {
        if (nw_protocol_copy_serializable_tls_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_serializable_tls_definition::onceToken, &__block_literal_global_73554);
        }
        id v26 = nw_protocol_create_options((void *)nw_protocol_copy_serializable_tls_definition::tls_definition);
        nw_serializable_tls_set_add_h2_alpn(v26);
        nw_serializable_tls_set_require_tls13(v26);
        uint64_t v27 = *(void *)(v7 + 56);
        if (v27)
        {
          options = v26;
          nw_serializable_tls_set_server_raw_public_keys(v26, v27);
        }
        else
        {
          uint64_t v29 = *(void *)(v7 + 64);
          if (v29)
          {
            options = v26;
            nw_serializable_tls_set_client_identity_reference(v26, v29, *(void *)(v7 + 72));
          }
          else
          {
            options = v26;
            if ((*(unsigned char *)(v7 + 80) & 0x10) != 0) {
              nw_serializable_tls_set_trust_certs(v26);
            }
          }
        }
      }
      nw_protocol_stack_append_application_protocol(v6, (void *)v9);
      nw_protocol_stack_append_application_protocol(v6, v11);
      nw_protocol_stack_append_application_protocol(v6, options);
      if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
      }
      os_log_type_t v53 = nw_protocol_create_options((void *)g_tcp_definition);
      nw_protocol_stack_set_transport_protocol(&v6->super, &v53->super);

      id v54 = nw_protocol_options_copy_proxy_endpoint_for_stack((void *)v9);
      int v22 = nw_proxy_config_create_with_stack(v54, v6);

      if (nw_masque_options_get_version((void *)v9) == 2)
      {
        if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
          dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
        }
        id v55 = (id)g_udp_definition;
        nw_proxy_config_set_alternate_protocol_stack(v22, 0, v55, 4u);

        if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
          dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
        }
        id v56 = (id)nw_protocol_copy_quic_stream_definition::quic_definition;
        nw_proxy_config_set_alternate_protocol_stack(v22, 0, v56, 3u);

        if (*(unsigned char *)(v7 + 80)) {
          nw_proxy_config_set_alternate_protocol_stack(v22, 0, 0, 2u);
        }
      }
      nw_proxy_config_set_is_privacy_proxy(v22, 1, 0);
      goto LABEL_141;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    int v19 = (id)gLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, "%{public}s First hop must be MASQUE", buf, 0xCu);
    }
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    if (os_log_type_enabled(v18, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v87 = "nw_proxy_config_create_fallback_privacy_proxy";
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s No more than two hops are currently supported", buf, 0xCu);
    }
  }
LABEL_30:
  int v22 = 0;
LABEL_142:

LABEL_143:
  return v22;
}

void sub_1831817C8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, _Unwind_Exception *exception_object, void *a12, void *a13)
{
  _Unwind_Resume(a1);
}

void sub_183181960(_Unwind_Exception *a1)
{
}

void nw_proxy_hop_set_client_identity_reference(void *a1, const void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  uint64_t v4 = v3;
  if (!v3)
  {
    os_log_type_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_40;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      unsigned int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null hop", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      unsigned int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
          __int16 v24 = 2082;
          id v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_40:
        if (!v7) {
          goto LABEL_6;
        }
LABEL_41:
        free(v7);
        goto LABEL_6;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null hop, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null hop, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_39:

    goto LABEL_40;
  }
  if (a2)
  {
    uint64_t v5 = (const void *)v3[8];
    if (v5)
    {
      CFRelease(v5);
      v4[8] = 0;
    }
    v4[8] = CFRetain(a2);
    goto LABEL_6;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_40;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    unsigned int v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null persistent_reference", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (!v20)
  {
    unsigned int v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null persistent_reference, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_39;
  }
  BOOL v15 = (char *)__nw_create_backtrace_string();
  unsigned int v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null persistent_reference, no backtrace", buf, 0xCu);
    }
    goto LABEL_39;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v23 = "nw_proxy_hop_set_client_identity_reference";
    __int16 v24 = 2082;
    id v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null persistent_reference, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_41;
  }
LABEL_6:
}

void sub_183181E28(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_input_available(void *a1, uint64_t a2)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = a2;
    uint64_t v3 = (uint64_t)a1;
    uint64_t v4 = (void *)a1[5];
    if (v4 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v5 = a1[11];
      if (v5) {
        a1[11] = v5 + 1;
      }
    }
    if (a2)
    {
      os_log_type_t v6 = *(void **)(a2 + 40);
      if (v6 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v7 = *(void *)(a2 + 88);
        if (v7) {
          *(void *)(a2 + 88) = v7 + 1;
        }
      }
      uint64_t v8 = a1[3];
      if (v8)
      {
        os_log_type_t v9 = *(void (**)(void *, uint64_t))(v8 + 64);
        if (v9)
        {
          v9(a1, a2);
          goto LABEL_12;
        }
      }
      __nwlog_obj();
      os_log_type_t v18 = *(const char **)(v3 + 16);
      *(_DWORD *)buf = 136446722;
      __int16 v42 = "__nw_protocol_input_available";
      if (!v18) {
        os_log_type_t v18 = "invalid";
      }
      __int16 v43 = 2082;
      char v44 = (void *)v18;
      __int16 v45 = 2048;
      uint64_t v46 = v3;
      os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v39 = 0;
      if (__nwlog_fault(v19, &type, &v39))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v20 = __nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          int v22 = *(const char **)(v3 + 16);
          if (!v22) {
            int v22 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          char v44 = (void *)v22;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_available callback";
          goto LABEL_76;
        }
        if (!v39)
        {
          char v20 = __nwlog_obj();
          os_log_type_t v21 = type;
          if (!os_log_type_enabled(v20, type)) {
            goto LABEL_77;
          }
          id v37 = *(const char **)(v3 + 16);
          if (!v37) {
            id v37 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          char v44 = (void *)v37;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded";
          goto LABEL_76;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v20 = __nwlog_obj();
        os_log_type_t v21 = type;
        BOOL v31 = os_log_type_enabled(v20, type);
        if (backtrace_string)
        {
          if (v31)
          {
            uint64_t v32 = *(const char **)(v3 + 16);
            if (!v32) {
              uint64_t v32 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            __int16 v42 = "__nw_protocol_input_available";
            __int16 v43 = 2082;
            char v44 = (void *)v32;
            __int16 v45 = 2048;
            uint64_t v46 = v3;
            __int16 v47 = 2082;
            BOOL v48 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }
          free(backtrace_string);
          goto LABEL_77;
        }
        if (v31)
        {
          id v38 = *(const char **)(v3 + 16);
          if (!v38) {
            id v38 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          char v44 = (void *)v38;
          __int16 v45 = 2048;
          uint64_t v46 = v3;
          uint64_t v23 = "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace";
LABEL_76:
          _os_log_impl(&dword_1830D4000, v20, v21, v23, buf, 0x20u);
        }
      }
LABEL_77:
      if (v19) {
        free(v19);
      }
LABEL_12:
      if (v6 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v2 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v14 = *(void *)(v2 + 88);
        if (v14)
        {
          uint64_t v15 = v14 - 1;
          *(void *)(v2 + 88) = v15;
          if (!v15)
          {
            os_log_type_t v16 = *(void (***)(void))(v2 + 64);
            if (v16)
            {
              *(void *)(v2 + 64) = 0;
              v16[2](v16);
              _Block_release(v16);
            }
            if (*(unsigned char *)(v2 + 72))
            {
              BOOL v17 = *(const void **)(v2 + 64);
              if (v17) {
                _Block_release(v17);
              }
            }
LABEL_32:
            free((void *)v2);
          }
        }
      }
LABEL_14:
      if (v4 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v3 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = *(void *)(v3 + 88);
        if (v10)
        {
          uint64_t v11 = v10 - 1;
          *(void *)(v3 + 88) = v11;
          if (!v11)
          {
            id v12 = *(void (***)(void))(v3 + 64);
            if (v12)
            {
              *(void *)(v3 + 64) = 0;
              v12[2](v12);
              _Block_release(v12);
            }
            if (*(unsigned char *)(v3 + 72))
            {
              os_log_type_t v13 = *(const void **)(v3 + 64);
              if (v13) {
                _Block_release(v13);
              }
            }
            goto LABEL_24;
          }
        }
      }
      return;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v42 = "__nw_protocol_input_available";
    uint64_t v2 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (__nwlog_fault((const char *)v2, &type, &v39))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_91;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v42 = "__nw_protocol_input_available";
        uint64_t v29 = "%{public}s called with null other_protocol";
        goto LABEL_90;
      }
      if (!v39)
      {
        uint64_t v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_91;
        }
        *(_DWORD *)buf = 136446210;
        __int16 v42 = "__nw_protocol_input_available";
        uint64_t v29 = "%{public}s called with null other_protocol, backtrace limit exceeded";
        goto LABEL_90;
      }
      int v35 = (char *)__nw_create_backtrace_string();
      uint64_t v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v36 = os_log_type_enabled(v27, type);
      if (v35)
      {
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          char v44 = v35;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v35);
        if (v2) {
          goto LABEL_32;
        }
        goto LABEL_14;
      }
      if (v36)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v42 = "__nw_protocol_input_available";
        uint64_t v29 = "%{public}s called with null other_protocol, no backtrace";
LABEL_90:
        _os_log_impl(&dword_1830D4000, v27, v28, v29, buf, 0xCu);
      }
    }
LABEL_91:
    if (!v2) {
      goto LABEL_14;
    }
    goto LABEL_32;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v42 = "__nw_protocol_input_available";
  uint64_t v3 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v39 = 0;
  if (__nwlog_fault((const char *)v3, &type, &v39))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v42 = "__nw_protocol_input_available";
      uint64_t v26 = "%{public}s called with null protocol";
    }
    else if (v39)
    {
      uint64_t v33 = (char *)__nw_create_backtrace_string();
      __int16 v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v34 = os_log_type_enabled(v24, type);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v42 = "__nw_protocol_input_available";
          __int16 v43 = 2082;
          char v44 = v33;
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v33);
        if (v3) {
          goto LABEL_24;
        }
        return;
      }
      if (!v34) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v42 = "__nw_protocol_input_available";
      uint64_t v26 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      __int16 v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (!os_log_type_enabled(v24, type)) {
        goto LABEL_86;
      }
      *(_DWORD *)buf = 136446210;
      __int16 v42 = "__nw_protocol_input_available";
      uint64_t v26 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v24, v25, v26, buf, 0xCu);
  }
LABEL_86:
  if (v3) {
LABEL_24:
  }
    free((void *)v3);
}

void nw_connection_async_client(void *a1, dispatch_qos_class_t a2, void *a3)
{
  uint64_t v5 = a1;
  id v6 = a3;
  if (nw_parameters_is_persona_set((uint64_t)v5[2]))
  {
    id v7 = v5[2];
    BOOL v8 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v7, 0, 0);

    v9[0] = MEMORY[0x1E4F143A8];
    v9[1] = 3221225472;
    v9[2] = __nw_connection_async_client_block_invoke;
    v9[3] = &unk_1E524BB48;
    uint64_t v10 = v5;
    dispatch_qos_class_t v12 = a2;
    id v11 = v6;
    nw_utilities_execute_block_as_persona_from_parameters((void *)v8, v9);
  }
  else
  {
    __nw_connection_async_client(v5, a2, v6);
  }
}

void sub_1831826E4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_2(uint64_t a1)
{
  nw_connection_report_state_with_handler_on_nw_queue(*(void **)(a1 + 32), 5u, *(void **)(*(void *)(*(void *)(a1 + 40) + 8) + 40), *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40));
  uint64_t v2 = *(void *)(a1 + 56);
  if (*(void *)(*(void *)(v2 + 8) + 40))
  {
    uint64_t v3 = *(_DWORD **)(a1 + 32);
    uint64_t v4 = *(void **)(*(void *)(*(void *)(a1 + 48) + 8) + 40);
    dispatch_qos_class_t v5 = v3[48];
    v6[0] = MEMORY[0x1E4F143A8];
    v6[1] = 3221225472;
    v6[2] = ___ZL26nw_connection_cancel_innerP24NWConcrete_nw_connectionb_block_invoke_3;
    v6[3] = &unk_1E524B978;
    uint64_t v8 = v2;
    id v7 = v3;
    nw_connection_async_on_queue(v7, v4, v5, v6);
  }
}

void sub_1831827F8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

void nw_write_request_report(void *a1, void *a2, void *a3)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  dispatch_qos_class_t v5 = a1;
  id v6 = a2;
  id v7 = a3;
  if ((v5[128] & 2) != 0) {
    goto LABEL_59;
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_33173);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  if (v7 || (char v8 = v5[128], (v8 & 1) != 0))
  {
    nw_content_context_mark_completed_send(*((void **)v5 + 8), v7);
    char v8 = v5[128];
  }
  v5[128] = v8 | 2;
  if (_nw_signposts_once == -1)
  {
    if (!_nw_signposts_enabled) {
      goto LABEL_13;
    }
  }
  else
  {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_33173);
    if (!_nw_signposts_enabled) {
      goto LABEL_13;
    }
  }
  if (kdebug_is_enabled())
  {
    BOOL v48 = *((void *)v5 + 7);
    if (v48) {
      dispatch_data_get_size(v48);
    }
    uint64_t v49 = *((void *)v5 + 8);
    if (v49) {
      nw_content_context_get_is_final(v49);
    }
    kdebug_trace();
  }
LABEL_13:
  if (!*((void *)v5 + 9))
  {
    uint64_t v10 = (void **)(v5 + 24);
    uint64_t v22 = *((void *)v5 + 3);
    if (!v22) {
      goto LABEL_59;
    }
    if (!*((void *)v5 + 5))
    {
      (*(void (**)(uint64_t, id))(v22 + 16))(v22, v7);
LABEL_58:
      __int16 v47 = *v10;
      id *v10 = 0;

      goto LABEL_59;
    }
    if (!v7)
    {
LABEL_57:
      __int16 v43 = _Block_copy(*((const void **)v5 + 3));
      char v44 = (void *)*((void *)v5 + 5);
      dispatch_qos_class_t v45 = *((_DWORD *)v5 + 12);
      v54[0] = MEMORY[0x1E4F143A8];
      v54[1] = 3221225472;
      v54[2] = ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke;
      v54[3] = &unk_1E524B950;
      id v56 = v43;
      id v55 = v7;
      id v46 = v43;
      nw_connection_async_client_if_needed_with_override(v44, v6, v45, v54);

      goto LABEL_58;
    }
    uint64_t v23 = v7;
    int v24 = v23[2];

    if (v24 == 1 && (v25 = v23, int v26 = v25[3], v25, v26 == 89))
    {
      uint64_t v27 = *(void *)(*((void *)v5 + 5) + 16);
      if (!v27 || nw_path_parameters_get_logging_disabled(*(void *)(v27 + 104))) {
        goto LABEL_57;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v28 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_INFO)) {
        goto LABEL_56;
      }
      int v29 = *(_DWORD *)(*((void *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446466;
      id v58 = "nw_write_request_report";
      __int16 v59 = 1024;
      int v60 = v29;
      unsigned int v30 = "%{public}s [C%u] Send cancelled";
      BOOL v31 = v28;
      os_log_type_t v32 = OS_LOG_TYPE_INFO;
      uint32_t v33 = 18;
    }
    else
    {
      uint64_t v41 = *(void *)(*((void *)v5 + 5) + 16);
      if (!v41 || nw_path_parameters_get_logging_disabled(*(void *)(v41 + 104))) {
        goto LABEL_57;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v28 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v28, OS_LOG_TYPE_ERROR)) {
        goto LABEL_56;
      }
      int v42 = *(_DWORD *)(*((void *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446722;
      id v58 = "nw_write_request_report";
      __int16 v59 = 1024;
      int v60 = v42;
      __int16 v61 = 2114;
      os_log_type_t v62 = v23;
      unsigned int v30 = "%{public}s [C%u] Send failed with error \"%{public}@\"";
      BOOL v31 = v28;
      os_log_type_t v32 = OS_LOG_TYPE_ERROR;
      uint32_t v33 = 28;
    }
    _os_log_impl(&dword_1830D4000, v31, v32, v30, buf, v33);
LABEL_56:

    goto LABEL_57;
  }
  uint64_t v10 = (void **)(v5 + 32);
  uint64_t v9 = *((void *)v5 + 4);
  if (v9)
  {
    if (!*((void *)v5 + 5))
    {
      (*(void (**)(uint64_t, void, BOOL, id))(v9 + 16))(v9, *((void *)v5 + 14), v7 == 0, v7);
      goto LABEL_46;
    }
    if (!v7)
    {
LABEL_45:
      BOOL v36 = _Block_copy(*((const void **)v5 + 4));
      id v37 = (void *)*((void *)v5 + 5);
      dispatch_qos_class_t v38 = *((_DWORD *)v5 + 12);
      v50[0] = MEMORY[0x1E4F143A8];
      v50[1] = 3221225472;
      v50[2] = ___ZL23nw_write_request_reportP27NWConcrete_nw_write_requestPU28objcproto17OS_dispatch_queue8NSObjectPU22objcproto11OS_nw_errorS1__block_invoke_96;
      v50[3] = &unk_1E5248030;
      id v53 = v36;
      uint64_t v51 = v5;
      id v52 = v7;
      id v39 = v36;
      nw_connection_async_client_if_needed_with_override(v37, v6, v38, v50);

LABEL_46:
      uint64_t v40 = *((void *)v5 + 10);
      if (v40)
      {
        nw_queue_cancel_source(v40);
        *((void *)v5 + 10) = 0;
      }
      goto LABEL_58;
    }
    id v11 = v7;
    int v12 = v11[2];

    if (v12 == 1 && (os_log_type_t v13 = v11, v14 = v13[3], v13, v14 == 89))
    {
      uint64_t v15 = *(void *)(*((void *)v5 + 5) + 16);
      if (!v15 || nw_path_parameters_get_logging_disabled(*(void *)(v15 + 104))) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_INFO)) {
        goto LABEL_44;
      }
      int v17 = *(_DWORD *)(*((void *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446466;
      id v58 = "nw_write_request_report";
      __int16 v59 = 1024;
      int v60 = v17;
      os_log_type_t v18 = "%{public}s [C%u] Send cancelled";
      os_log_type_t v19 = v16;
      os_log_type_t v20 = OS_LOG_TYPE_INFO;
      uint32_t v21 = 18;
    }
    else
    {
      uint64_t v34 = *(void *)(*((void *)v5 + 5) + 16);
      if (!v34 || nw_path_parameters_get_logging_disabled(*(void *)(v34 + 104))) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v16 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v16, OS_LOG_TYPE_ERROR)) {
        goto LABEL_44;
      }
      int v35 = *(_DWORD *)(*((void *)v5 + 5) + 448);
      *(_DWORD *)buf = 136446722;
      id v58 = "nw_write_request_report";
      __int16 v59 = 1024;
      int v60 = v35;
      __int16 v61 = 2114;
      os_log_type_t v62 = v11;
      os_log_type_t v18 = "%{public}s [C%u] Send failed with error \"%{public}@\"";
      os_log_type_t v19 = v16;
      os_log_type_t v20 = OS_LOG_TYPE_ERROR;
      uint32_t v21 = 28;
    }
    _os_log_impl(&dword_1830D4000, v19, v20, v18, buf, v21);
LABEL_44:

    goto LABEL_45;
  }
LABEL_59:
}

void sub_183182EB4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,void *a21,void *a22)
{
  _Unwind_Resume(a1);
}

void nw_connection_report_state_with_handler_on_nw_queue(void *a1, unsigned int a2, void *a3, void *a4)
{
  uint64_t v49 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a3;
  id v9 = a4;
  if (!v7)
  {
    uint64_t v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
    uint64_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v41 = 0;
    if (__nwlog_fault(v23, &type, &v41))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v41)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v24 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
            __int16 v45 = 2082;
            *(void *)id v46 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_72;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v24 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_72:
    if (v23) {
      free(v23);
    }
    goto LABEL_67;
  }
  nw_context_assert_queue(*((void **)v7 + 3));
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_237);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  if (v8)
  {
    uint64_t v10 = _Block_copy(v8);
    if (a2 - 4 > 0xFFFFFFFD)
    {
      if (a2 != 3) {
        goto LABEL_55;
      }
      if (_nw_signposts_once == -1)
      {
        if (!_nw_signposts_enabled) {
          goto LABEL_55;
        }
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_237);
        if (!_nw_signposts_enabled) {
          goto LABEL_55;
        }
      }
      if (kdebug_is_enabled()) {
        kdebug_trace();
      }
      goto LABEL_55;
    }
    uint64_t v11 = *((void *)v7 + 55);
    if (v11 && (uint64_t v12 = *(void *)(v11 + 24) - *(void *)(v11 + 16)) != 0)
    {
      os_log_type_t v13 = nw_array_get_object_at_index(v11, (v12 >> 3) - 1);
      if (a2 != 4) {
        goto LABEL_28;
      }
    }
    else
    {
      os_log_type_t v13 = 0;
      if (a2 != 4) {
        goto LABEL_28;
      }
    }
    if (!v13) {
      os_log_type_t v13 = -[NWConcrete_nw_error initWithDomain:code:]([NWConcrete_nw_error alloc], 1, 50);
    }
LABEL_28:
    if (v13)
    {
      uint64_t v18 = *((void *)v7 + 2);
      if (!v18 || nw_path_parameters_get_logging_disabled(*(void *)(v18 + 104))) {
        goto LABEL_66;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v19 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
      {
        int v20 = *((_DWORD *)v7 + 112);
        if (a2 > 5) {
          uint32_t v21 = "unknown";
        }
        else {
          uint32_t v21 = off_1E523DED8[a2];
        }
        *(_DWORD *)buf = 136446978;
        char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
        __int16 v45 = 1024;
        *(_DWORD *)id v46 = v20;
        *(_WORD *)&v46[4] = 2082;
        *(void *)&v46[6] = v21;
        __int16 v47 = 2114;
        BOOL v48 = v13;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s [C%u] reporting state %{public}s error %{public}@", buf, 0x26u);
      }
      goto LABEL_65;
    }
LABEL_55:
    uint64_t v30 = *((void *)v7 + 2);
    if (!v30 || nw_path_parameters_get_logging_disabled(*(void *)(v30 + 104)))
    {
      os_log_type_t v13 = 0;
      goto LABEL_66;
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v19 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v19, OS_LOG_TYPE_DEFAULT))
    {
      int v31 = *((_DWORD *)v7 + 112);
      if (a2 > 5) {
        os_log_type_t v32 = "unknown";
      }
      else {
        os_log_type_t v32 = off_1E523DF08[a2];
      }
      *(_DWORD *)buf = 136446722;
      char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
      __int16 v45 = 1024;
      *(_DWORD *)id v46 = v31;
      *(_WORD *)&v46[4] = 2082;
      *(void *)&v46[6] = v32;
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEFAULT, "%{public}s [C%u] reporting state %{public}s", buf, 0x1Cu);
    }
    os_log_type_t v13 = 0;
LABEL_65:

LABEL_66:
    dispatch_qos_class_t v33 = *((_DWORD *)v7 + 48);
    v36[0] = MEMORY[0x1E4F143A8];
    v36[1] = 3221225472;
    v36[2] = ___ZL51nw_connection_report_state_with_handler_on_nw_queueP24NWConcrete_nw_connection21nw_connection_state_tU13block_pointerFvS1_PU22objcproto11OS_nw_error8NSObjectEPU28objcproto17OS_dispatch_queueS2__block_invoke;
    v36[3] = &unk_1E52449A0;
    id v34 = v10;
    unsigned int v40 = a2;
    id v39 = v34;
    id v37 = v13;
    id v38 = v7;
    id v35 = v13;
    nw_connection_async_on_queue(v38, v9, v33, v36);

    goto LABEL_67;
  }
  uint64_t v14 = *((void *)v7 + 2);
  if (v14 && !nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v15 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_DEFAULT))
    {
      int v16 = *((_DWORD *)v7 + 112);
      if (a2 > 5) {
        int v17 = "unknown";
      }
      else {
        int v17 = off_1E523DF08[a2];
      }
      *(_DWORD *)buf = 136446722;
      char v44 = "nw_connection_report_state_with_handler_on_nw_queue";
      __int16 v45 = 1024;
      *(_DWORD *)id v46 = v16;
      *(_WORD *)&v46[4] = 2082;
      *(void *)&v46[6] = v17;
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEFAULT, "%{public}s [C%u] not reporting state %{public}s", buf, 0x1Cu);
    }
  }
LABEL_67:
}

void sub_183183648(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_async_on_queue(void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (nw_parameters_is_persona_set(v7[2]))
  {
    uint64_t v10 = (void *)v7[2];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = ___ZL28nw_connection_async_on_queueP24NWConcrete_nw_connectionPU28objcproto17OS_dispatch_queue8NSObject11qos_class_tU13block_pointerFvvE_block_invoke;
    v11[3] = &unk_1E52449A0;
    uint64_t v12 = v7;
    id v13 = v8;
    dispatch_qos_class_t v15 = a3;
    id v14 = v9;
    nw_utilities_execute_block_as_persona_from_parameters(v10, v11);
  }
  else
  {
    __nw_connection_async_on_queue(v7, v8, a3, v9);
  }
}

void sub_1831837A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_read_request_report(void *a1, void *a2)
{
  uint64_t v165 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if ((*((unsigned char *)v3 + 176) & 1) == 0)
  {
    *((unsigned char *)v3 + 176) |= 1u;
    switch(*((_DWORD *)v3 + 17))
    {
      case 0:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        dispatch_qos_class_t v5 = (id)gLogObj;
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446210;
          v162 = "nw_read_request_report";
          _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s Invalid request", buf, 0xCu);
        }
        goto LABEL_5;
      case 1:
        id v30 = *((id *)v3 + 16);
        int v31 = (void *)*((void *)v3 + 16);
        *((void *)v3 + 16) = 0;

        if (!*((void *)v3 + 7))
        {
          (*(void (**)(void))(*((void *)v3 + 3) + 16))();
          goto LABEL_111;
        }
        os_log_type_t v32 = (void *)*((void *)v3 + 19);
        if (!v32) {
          goto LABEL_110;
        }
        dispatch_qos_class_t v33 = v32;
        int v34 = v33[2];

        if (v34 == 1 && nw_error_get_error_code(*((nw_error_t *)v3 + 19)) == 89)
        {
          uint64_t v35 = *(void *)(*((void *)v3 + 7) + 16);
          if (v35 && !nw_path_parameters_get_logging_disabled(*(void *)(v35 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v36 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_INFO)) {
              goto LABEL_109;
            }
            int v37 = *(_DWORD *)(*((void *)v3 + 7) + 448);
            *(_DWORD *)buf = 136446466;
            v162 = "nw_read_request_report";
            __int16 v163 = 1024;
            *(_DWORD *)v164 = v37;
            id v38 = "%{public}s [C%u] Receive cancelled";
            id v39 = v36;
            os_log_type_t v40 = OS_LOG_TYPE_INFO;
            uint32_t v41 = 18;
LABEL_108:
            _os_log_impl(&dword_1830D4000, v39, v40, v38, buf, v41);
LABEL_109:
          }
        }
        else
        {
          uint64_t v91 = *(void *)(*((void *)v3 + 7) + 16);
          if (v91 && !nw_path_parameters_get_logging_disabled(*(void *)(v91 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v36 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v36, OS_LOG_TYPE_ERROR)) {
              goto LABEL_109;
            }
            int v92 = *(_DWORD *)(*((void *)v3 + 7) + 448);
            uint64_t v93 = *((void *)v3 + 19);
            *(_DWORD *)buf = 136446722;
            v162 = "nw_read_request_report";
            __int16 v163 = 1024;
            *(_DWORD *)v164 = v92;
            *(_WORD *)&v164[4] = 2114;
            *(void *)&v164[6] = v93;
            id v38 = "%{public}s [C%u] Receive failed with error \"%{public}@\"";
            id v39 = v36;
            os_log_type_t v40 = OS_LOG_TYPE_ERROR;
            uint32_t v41 = 28;
            goto LABEL_108;
          }
        }
LABEL_110:
        id v94 = *((id *)v3 + 17);
        char v95 = *((unsigned char *)v3 + 176);
        id v96 = *((id *)v3 + 19);
        v97 = _Block_copy(*((const void **)v3 + 3));
        unint64_t v98 = (void *)*((void *)v3 + 7);
        dispatch_qos_class_t v99 = *((_DWORD *)v3 + 16);
        v155[0] = MEMORY[0x1E4F143A8];
        v155[1] = 3221225472;
        v155[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke;
        v155[3] = &unk_1E5243F38;
        id v159 = v97;
        id v156 = v30;
        id v157 = v94;
        BOOL v160 = (v95 & 2) != 0;
        id v158 = v96;
        id v100 = v96;
        id v101 = v94;
        id v102 = v97;
        nw_connection_async_client_if_needed_with_override(v98, v4, v99, v155);

LABEL_111:
        break;
      case 2:
        if (*((void *)v3 + 7))
        {
          int v16 = (void *)*((void *)v3 + 19);
          if (!v16) {
            goto LABEL_100;
          }
          int v17 = v16;
          int v18 = v17[2];

          if (v18 == 1 && nw_error_get_error_code(*((nw_error_t *)v3 + 19)) == 89)
          {
            uint64_t v19 = *(void *)(*((void *)v3 + 7) + 16);
            if (v19 && !nw_path_parameters_get_logging_disabled(*(void *)(v19 + 104)))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v20 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v20, OS_LOG_TYPE_INFO)) {
                goto LABEL_97;
              }
              int v21 = *(_DWORD *)(*((void *)v3 + 7) + 448);
              *(_DWORD *)buf = 136446466;
              v162 = "nw_read_request_report";
              __int16 v163 = 1024;
              *(_DWORD *)v164 = v21;
              uint64_t v22 = "%{public}s [C%u] Receive cancelled";
              uint64_t v23 = v20;
              os_log_type_t v24 = OS_LOG_TYPE_INFO;
              uint32_t v25 = 18;
LABEL_96:
              _os_log_impl(&dword_1830D4000, v23, v24, v22, buf, v25);
LABEL_97:
            }
          }
          else
          {
            uint64_t v80 = *(void *)(*((void *)v3 + 7) + 16);
            if (v80 && !nw_path_parameters_get_logging_disabled(*(void *)(v80 + 104)))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              int v20 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v20, OS_LOG_TYPE_ERROR)) {
                goto LABEL_97;
              }
              int v81 = *(_DWORD *)(*((void *)v3 + 7) + 448);
              uint64_t v82 = *((void *)v3 + 19);
              *(_DWORD *)buf = 136446722;
              v162 = "nw_read_request_report";
              __int16 v163 = 1024;
              *(_DWORD *)v164 = v81;
              *(_WORD *)&v164[4] = 2114;
              *(void *)&v164[6] = v82;
              uint64_t v22 = "%{public}s [C%u] Receive failed with error \"%{public}@\"";
              uint64_t v23 = v20;
              os_log_type_t v24 = OS_LOG_TYPE_ERROR;
              uint32_t v25 = 28;
              goto LABEL_96;
            }
          }
          os_log_type_t v83 = (void *)*((void *)v3 + 19);
          if (v83)
          {
            char v84 = v83;
            int v85 = v84[3];

LABEL_101:
            uint64_t v86 = *((void *)v3 + 11);
            uint64_t v87 = _Block_copy(*((const void **)v3 + 6));
            __int16 v88 = (void *)*((void *)v3 + 7);
            dispatch_qos_class_t v89 = *((_DWORD *)v3 + 16);
            v130[0] = MEMORY[0x1E4F143A8];
            v130[1] = 3221225472;
            v130[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_106;
            v130[3] = &unk_1E5244390;
            id v131 = v87;
            uint64_t v132 = v86;
            int v133 = v85;
            id v90 = v87;
            nw_connection_async_client_if_needed_with_override(v88, v4, v89, v130);

            break;
          }
LABEL_100:
          int v85 = 0;
          goto LABEL_101;
        }
        uint64_t v43 = *((void *)v3 + 6);
        uint64_t v44 = *((void *)v3 + 11);
        __int16 v45 = *((void *)v3 + 19);
        if (v45) {
          uint64_t error_code = nw_error_get_error_code(v45);
        }
        else {
          uint64_t error_code = 0;
        }
        (*(void (**)(uint64_t, uint64_t, uint64_t))(v43 + 16))(v43, v44, error_code);
        break;
      case 3:
        uint64_t v26 = *((void *)v3 + 20);
        if (v26)
        {
          size_t v27 = (uint64_t)(*(void *)(v26 + 24) - *(void *)(v26 + 16)) >> 3;
          uint64_t v28 = *((void *)v3 + 21);
          if (v28)
          {
LABEL_28:
            uint64_t v29 = (uint64_t)(*(void *)(v28 + 24) - *(void *)(v28 + 16)) >> 3;
            goto LABEL_47;
          }
        }
        else
        {
          size_t v27 = 0;
          uint64_t v28 = *((void *)v3 + 21);
          if (v28) {
            goto LABEL_28;
          }
        }
        uint64_t v29 = 0;
LABEL_47:
        uint64_t v151 = 0;
        v152 = &v151;
        uint64_t v153 = 0x2020000000;
        uint64_t v154 = 0;
        uint64_t v147 = 0;
        v148 = &v147;
        uint64_t v149 = 0x2020000000;
        uint64_t v150 = 0;
        if (!v27) {
          goto LABEL_53;
        }
        if (!(v27 >> 61)) {
          goto LABEL_49;
        }
        os_log_type_t v116 = __nwlog_obj();
        os_log_type_enabled(v116, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v162 = "strict_calloc";
        id v117 = (void *)_os_log_send_and_compose_impl();

        if (__nwlog_abort((uint64_t)v117)) {
          goto LABEL_138;
        }
        free(v117);
LABEL_49:
        __int16 v47 = malloc_type_calloc(v27, 8uLL, 0xEAFB8F1AuLL);
        if (v47) {
          goto LABEL_50;
        }
        size_t v118 = __nwlog_obj();
        os_log_type_enabled(v118, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        v162 = "strict_calloc";
        __int16 v163 = 2048;
        *(void *)v164 = v27;
        *(_WORD *)&v164[8] = 2048;
        *(void *)&v164[10] = 8;
        v119 = (void *)_os_log_send_and_compose_impl();

        if (__nwlog_abort((uint64_t)v119)) {
          goto LABEL_138;
        }
        free(v119);
LABEL_50:
        v152[3] = (uint64_t)v47;
        if (!(v27 >> 61)) {
          goto LABEL_51;
        }
        __int16 v120 = __nwlog_obj();
        os_log_type_enabled(v120, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446210;
        v162 = "strict_calloc";
        uint64_t v121 = (void *)_os_log_send_and_compose_impl();

        if (__nwlog_abort((uint64_t)v121)) {
          goto LABEL_138;
        }
        free(v121);
LABEL_51:
        BOOL v48 = malloc_type_calloc(v27, 8uLL, 0xEAFB8F1AuLL);
        if (v48) {
          goto LABEL_52;
        }
        uint64_t v122 = __nwlog_obj();
        os_log_type_enabled(v122, OS_LOG_TYPE_ERROR);
        *(_DWORD *)buf = 136446722;
        v162 = "strict_calloc";
        __int16 v163 = 2048;
        *(void *)v164 = v27;
        *(_WORD *)&v164[8] = 2048;
        *(void *)&v164[10] = 8;
        int v123 = (void *)_os_log_send_and_compose_impl();

        if (!__nwlog_abort((uint64_t)v123))
        {
          free(v123);
LABEL_52:
          v148[3] = (uint64_t)v48;
          uint64_t v49 = (atomic_uchar *)*((void *)v3 + 20);
          v141[0] = MEMORY[0x1E4F143A8];
          v141[1] = 3221225472;
          v141[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_2;
          v141[3] = &unk_1E5243F60;
          uint64_t v145 = v29;
          size_t v146 = v27;
          id v143 = &v151;
          __int16 v144 = &v147;
          id v142 = v3;
          nw_array_apply(v49, (uint64_t)v141);

LABEL_53:
          if (!*((void *)v3 + 7))
          {
            (*(void (**)(void, uint64_t))(*((void *)v3 + 5) + 16))(*((void *)v3 + 5), v152[3]);
            int v60 = (void *)v152[3];
            if (v60 || v148[3])
            {
              if (v27)
              {
                for (uint64_t i = 0; i != v27; ++i)
                {
                  uint64_t v62 = v152[3];
                  if (v62)
                  {
                    uint64_t v63 = *(void **)(v62 + 8 * i);
                    if (v63)
                    {
                      *(void *)(v62 + 8 * i) = 0;
                    }
                  }
                  uint64_t v64 = v148[3];
                  if (v64)
                  {
                    id v65 = *(void **)(v64 + 8 * i);
                    if (v65)
                    {
                      *(void *)(v64 + 8 * i) = 0;
                    }
                  }
                }
                int v60 = (void *)v152[3];
              }
              if (v60)
              {
                free(v60);
                v152[3] = 0;
              }
              v113 = (void *)v148[3];
              if (v113)
              {
                free(v113);
                v148[3] = 0;
              }
            }
            goto LABEL_126;
          }
          uint64_t v50 = (void *)*((void *)v3 + 19);
          if (!v50)
          {
LABEL_120:
            id v106 = *((id *)v3 + 19);
            int v107 = *((_DWORD *)v3 + 22);
            __int16 v108 = _Block_copy(*((const void **)v3 + 5));
            v109 = (void *)*((void *)v3 + 7);
            dispatch_qos_class_t v110 = *((_DWORD *)v3 + 16);
            v134[0] = MEMORY[0x1E4F143A8];
            v134[1] = 3221225472;
            v134[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_105;
            v134[3] = &unk_1E5243F88;
            v137 = &v151;
            v138 = &v147;
            int v140 = v107;
            id v135 = v106;
            id v136 = v108;
            size_t v139 = v27;
            id v111 = v106;
            id v112 = v108;
            nw_connection_async_client_if_needed_with_override(v109, v4, v110, v134);

LABEL_126:
            int v114 = (void *)*((void *)v3 + 20);
            *((void *)v3 + 20) = 0;

            int v115 = (void *)*((void *)v3 + 21);
            *((void *)v3 + 21) = 0;

            _Block_object_dispose(&v147, 8);
            _Block_object_dispose(&v151, 8);
            break;
          }
          uint64_t v51 = v50;
          int v52 = v51[2];

          if (v52 == 1 && nw_error_get_error_code(*((nw_error_t *)v3 + 19)) == 89)
          {
            uint64_t v53 = *(void *)(*((void *)v3 + 7) + 16);
            if (!v53 || nw_path_parameters_get_logging_disabled(*(void *)(v53 + 104))) {
              goto LABEL_120;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v54 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v54, OS_LOG_TYPE_INFO)) {
              goto LABEL_119;
            }
            int v55 = *(_DWORD *)(*((void *)v3 + 7) + 448);
            *(_DWORD *)buf = 136446466;
            v162 = "nw_read_request_report";
            __int16 v163 = 1024;
            *(_DWORD *)v164 = v55;
            id v56 = "%{public}s [C%u] Receive cancelled";
            os_log_type_t v57 = v54;
            os_log_type_t v58 = OS_LOG_TYPE_INFO;
            uint32_t v59 = 18;
          }
          else
          {
            uint64_t v103 = *(void *)(*((void *)v3 + 7) + 16);
            if (!v103 || nw_path_parameters_get_logging_disabled(*(void *)(v103 + 104))) {
              goto LABEL_120;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v54 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v54, OS_LOG_TYPE_ERROR)) {
              goto LABEL_119;
            }
            int v104 = *(_DWORD *)(*((void *)v3 + 7) + 448);
            uint64_t v105 = *((void *)v3 + 19);
            *(_DWORD *)buf = 136446722;
            v162 = "nw_read_request_report";
            __int16 v163 = 1024;
            *(_DWORD *)v164 = v104;
            *(_WORD *)&v164[4] = 2114;
            *(void *)&v164[6] = v105;
            id v56 = "%{public}s [C%u] Receive failed with error \"%{public}@\"";
            os_log_type_t v57 = v54;
            os_log_type_t v58 = OS_LOG_TYPE_ERROR;
            uint32_t v59 = 28;
          }
          _os_log_impl(&dword_1830D4000, v57, v58, v56, buf, v59);
LABEL_119:

          goto LABEL_120;
        }
LABEL_138:
        __break(1u);
        return;
      case 4:
        if (!*((void *)v3 + 7))
        {
          (*(void (**)(void))(*((void *)v3 + 4) + 16))();
          goto LABEL_87;
        }
        id v6 = (void *)*((void *)v3 + 19);
        if (!v6) {
          goto LABEL_83;
        }
        id v7 = v6;
        int v8 = v7[2];

        if (v8 == 1 && nw_error_get_error_code(*((nw_error_t *)v3 + 19)) == 89)
        {
          uint64_t v9 = *(void *)(*((void *)v3 + 7) + 16);
          if (v9 && !nw_path_parameters_get_logging_disabled(*(void *)(v9 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v10 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v10, OS_LOG_TYPE_INFO)) {
              goto LABEL_82;
            }
            int v11 = *(_DWORD *)(*((void *)v3 + 7) + 448);
            *(_DWORD *)buf = 136446466;
            v162 = "nw_read_request_report";
            __int16 v163 = 1024;
            *(_DWORD *)v164 = v11;
            uint64_t v12 = "%{public}s [C%u] Receive cancelled";
            id v13 = v10;
            os_log_type_t v14 = OS_LOG_TYPE_INFO;
            uint32_t v15 = 18;
LABEL_81:
            _os_log_impl(&dword_1830D4000, v13, v14, v12, buf, v15);
LABEL_82:
          }
        }
        else
        {
          uint64_t v66 = *(void *)(*((void *)v3 + 7) + 16);
          if (v66 && !nw_path_parameters_get_logging_disabled(*(void *)(v66 + 104)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v10 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v10, OS_LOG_TYPE_ERROR)) {
              goto LABEL_82;
            }
            int v67 = *(_DWORD *)(*((void *)v3 + 7) + 448);
            uint64_t v68 = *((void *)v3 + 19);
            *(_DWORD *)buf = 136446722;
            v162 = "nw_read_request_report";
            __int16 v163 = 1024;
            *(_DWORD *)v164 = v67;
            *(_WORD *)&v164[4] = 2114;
            *(void *)&v164[6] = v68;
            uint64_t v12 = "%{public}s [C%u] Receive failed with error \"%{public}@\"";
            id v13 = v10;
            os_log_type_t v14 = OS_LOG_TYPE_ERROR;
            uint32_t v15 = 28;
            goto LABEL_81;
          }
        }
LABEL_83:
        if ((*((unsigned char *)v3 + 176) & 2) == 0 && !*((void *)v3 + 19)) {
          *((unsigned char *)v3 + 176) |= 2u;
        }
        id v69 = *((id *)v3 + 17);
        char v70 = *((unsigned char *)v3 + 176);
        id v71 = *((id *)v3 + 19);
        BOOL v72 = _Block_copy(*((const void **)v3 + 4));
        os_log_type_t v73 = (void *)*((void *)v3 + 7);
        dispatch_qos_class_t v74 = *((_DWORD *)v3 + 16);
        v124[0] = MEMORY[0x1E4F143A8];
        v124[1] = 3221225472;
        v124[2] = ___ZL22nw_read_request_reportP26NWConcrete_nw_read_requestPU28objcproto17OS_dispatch_queue8NSObject_block_invoke_107;
        v124[3] = &unk_1E5243F38;
        id v128 = v72;
        id v125 = v3;
        id v126 = v69;
        BOOL v129 = (v70 & 2) != 0;
        id v127 = v71;
        id v75 = v71;
        id v76 = v69;
        id v77 = v72;
        nw_connection_async_client_if_needed_with_override(v73, v4, v74, v124);

LABEL_87:
        uint64_t v78 = *((void *)v3 + 13);
        if (v78)
        {
          nw_queue_cancel_source(v78);
          *((void *)v3 + 13) = 0;
        }
        BOOL v79 = (void *)*((void *)v3 + 4);
        *((void *)v3 + 4) = 0;

        break;
      default:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        dispatch_qos_class_t v5 = (id)gLogObj;
        if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
        {
          int v42 = *((_DWORD *)v3 + 17);
          *(_DWORD *)buf = 136446466;
          v162 = "nw_read_request_report";
          __int16 v163 = 1024;
          *(_DWORD *)v164 = v42;
          _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s Unknown request type %d", buf, 0x12u);
        }
LABEL_5:

        break;
    }
  }
}

void sub_1831848E0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_async_client_if_needed_with_override(void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  id v7 = a1;
  id v8 = a2;
  id v9 = a4;
  if (nw_parameters_is_persona_set(v7[2]))
  {
    uint64_t v10 = (void *)v7[2];
    v11[0] = MEMORY[0x1E4F143A8];
    v11[1] = 3221225472;
    v11[2] = __nw_connection_async_client_if_needed_with_override_block_invoke;
    v11[3] = &unk_1E52449A0;
    uint64_t v12 = v7;
    id v13 = v8;
    dispatch_qos_class_t v15 = a3;
    id v14 = v9;
    nw_utilities_execute_block_as_persona_from_parameters(v10, v11);
  }
  else
  {
    __nw_connection_async_client_if_needed_with_override(v7, v8, a3, v9);
  }
}

void sub_183184AD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_is_persona_set(uint64_t a1)
{
  uint64_t v16 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return uuid_is_null((const unsigned __int8 *)(*(void *)(a1 + 104) + 40)) == 0;
  }
  uint64_t v2 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v13 = "nw_parameters_is_persona_set";
  id v3 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v10 = 0;
  if (__nwlog_fault(v3, &type, &v10))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        id v13 = "nw_parameters_is_persona_set";
        _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v10)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v4 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v8 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v8)
        {
          *(_DWORD *)buf = 136446466;
          id v13 = "nw_parameters_is_persona_set";
          __int16 v14 = 2082;
          dispatch_qos_class_t v15 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v7, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_19;
      }
      if (v8)
      {
        *(_DWORD *)buf = 136446210;
        id v13 = "nw_parameters_is_persona_set";
        _os_log_impl(&dword_1830D4000, v4, v7, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v4 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v4, type))
      {
        *(_DWORD *)buf = 136446210;
        id v13 = "nw_parameters_is_persona_set";
        _os_log_impl(&dword_1830D4000, v4, v9, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_19:
  if (v3) {
    free(v3);
  }
  return 0;
}

void __nw_connection_async_client_if_needed_with_override(void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  uint64_t v12 = a1;
  os_log_type_t v7 = a2;
  BOOL v8 = a4;
  if (v7)
  {
    os_log_type_t v9 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, a3, 0, v8);
    dispatch_async(v7, v9);
LABEL_5:

    goto LABEL_6;
  }
  char v10 = (void *)v12[25];
  if (v10)
  {
    os_log_type_t v9 = v10;
    dispatch_block_t v11 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, a3, 0, v8);
    dispatch_async(v9, v11);

    goto LABEL_5;
  }
  if (!v12[5]) {
    v8[2](v8);
  }
LABEL_6:
}

void sub_183184E90(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void __nw_connection_async_on_queue(void *a1, void *a2, dispatch_qos_class_t a3, void *a4)
{
  uint64_t v35 = *MEMORY[0x1E4F143B8];
  os_log_type_t v7 = a1;
  BOOL v8 = a2;
  id v9 = a4;
  if (v8)
  {
    dispatch_block_t v10 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, a3, 0, v9);
    dispatch_async(v8, v10);

    goto LABEL_3;
  }
  if (!v7[5])
  {
    nw_context_queue_block(v7[3], v9);
    goto LABEL_3;
  }
  dispatch_block_t v11 = v7[2];
  if (v11 && !nw_path_parameters_get_logging_disabled(v11[13]))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    id v12 = (id)gconnectionLogObj;
    int v13 = *((_DWORD *)v7 + 112);
    *(_DWORD *)buf = 136446466;
    id v30 = "__nw_connection_async_on_queue";
    __int16 v31 = 1024;
    int v32 = v13;
    __int16 v14 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (!__nwlog_fault((const char *)v14, &type, &v27))
    {
LABEL_16:
      if (!v14) {
        goto LABEL_3;
      }
LABEL_17:
      free(v14);
      goto LABEL_3;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      dispatch_qos_class_t v15 = (id)gconnectionLogObj;
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        int v17 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446466;
        id v30 = "__nw_connection_async_on_queue";
        __int16 v31 = 1024;
        int v32 = v17;
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s [C%u] unable to dispatch block", buf, 0x12u);
      }
LABEL_15:

      goto LABEL_16;
    }
    if (!v27)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      dispatch_qos_class_t v15 = (id)gconnectionLogObj;
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v15, type))
      {
        int v24 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446466;
        id v30 = "__nw_connection_async_on_queue";
        __int16 v31 = 1024;
        int v32 = v24;
        _os_log_impl(&dword_1830D4000, v15, v23, "%{public}s [C%u] unable to dispatch block, backtrace limit exceeded", buf, 0x12u);
      }
      goto LABEL_15;
    }
    backtrace_string = __nw_create_backtrace_string();
    if (!backtrace_string)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      dispatch_qos_class_t v15 = (id)gconnectionLogObj;
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        int v26 = *((_DWORD *)v7 + 112);
        *(_DWORD *)buf = 136446466;
        id v30 = "__nw_connection_async_on_queue";
        __int16 v31 = 1024;
        int v32 = v26;
        _os_log_impl(&dword_1830D4000, v15, v25, "%{public}s [C%u] unable to dispatch block, no backtrace", buf, 0x12u);
      }
      goto LABEL_15;
    }
    uint64_t v19 = (char *)backtrace_string;
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v20 = (id)gconnectionLogObj;
    os_log_type_t v21 = type;
    if (os_log_type_enabled(v20, type))
    {
      int v22 = *((_DWORD *)v7 + 112);
      *(_DWORD *)buf = 136446722;
      id v30 = "__nw_connection_async_on_queue";
      __int16 v31 = 1024;
      int v32 = v22;
      __int16 v33 = 2082;
      int v34 = v19;
      _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s [C%u] unable to dispatch block, dumping backtrace:%{public}s", buf, 0x1Cu);
    }

    free(v19);
    if (v14) {
      goto LABEL_17;
    }
  }
LABEL_3:
}

void sub_1831852CC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_write_request_consume_bytes(void *a1, uint64_t a2)
{
  v48[1] = *(id *)MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_33173);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  id v4 = (void *)*((void *)v3 + 7);
  uint64_t v5 = *((void *)v3 + 9);
  if (v4)
  {
    if (!v5)
    {
      size_t size = dispatch_data_get_size(*((dispatch_data_t *)v3 + 7));
      size_t v7 = *((void *)v3 + 14) + a2;
      if (v7 < size)
      {
        *((void *)v3 + 14) = v7;
        goto LABEL_65;
      }
      *((void *)v3 + 14) = 0;
LABEL_34:
      *((void *)v3 + 7) = 0;

      if (*((unsigned char *)v3 + 128)) {
        nw_content_context_mark_completed_send(*((void **)v3 + 8), 0);
      }
      if (_nw_signposts_once == -1)
      {
        if (_nw_signposts_enabled) {
          goto LABEL_38;
        }
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_33173);
        if (_nw_signposts_enabled)
        {
LABEL_38:
          if (kdebug_is_enabled()) {
            kdebug_trace();
          }
        }
      }
      uint64_t v22 = *((unsigned char *)v3 + 128) & 1;
      goto LABEL_70;
    }
LABEL_11:
    unint64_t v8 = *((void *)v3 + 12);
    unint64_t v9 = *((void *)v3 + 14) + a2;
    *((void *)v3 + 14) = v9;
    if (v9 >= v8)
    {
      *((unsigned char *)v3 + 128) |= 0x10u;
      goto LABEL_34;
    }
    if ((*((unsigned char *)v3 + 128) & 0x20) != 0)
    {
LABEL_65:
      if (_nw_signposts_once == -1)
      {
        if (_nw_signposts_enabled) {
          goto LABEL_67;
        }
      }
      else
      {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_33173);
        if (_nw_signposts_enabled)
        {
LABEL_67:
          if (kdebug_is_enabled()) {
            kdebug_trace();
          }
        }
      }
      uint64_t v22 = 0;
      goto LABEL_70;
    }
    dispatch_block_t v10 = v3;
    uint64_t v11 = v10[5];
    if (v11)
    {
      *((unsigned char *)v3 + 128) |= 0x20u;
      uint64_t v12 = *(void *)(v11 + 16);
      if (v12 && !nw_path_parameters_get_logging_disabled(*(void *)(v12 + 104)))
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        int v13 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
        {
          int v14 = *(_DWORD *)(v10[5] + 448);
          uint64_t v15 = *((void *)v3 + 9);
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v14;
          *(_WORD *)&buf[18] = 2112;
          *(void *)&buf[20] = v15;
          _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Activating progress updates on write request on %@", buf, 0x1Cu);
        }
      }
      uint64_t v16 = v10[10];
      if (v16)
      {
        nw_queue_cancel_source(v16);
        v10[10] = 0;
      }
      objc_initWeak(&location, v10);
      int v17 = *(void **)(v10[5] + 24);
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&buf[16] = ___ZL35nw_write_request_start_file_updatesP27NWConcrete_nw_write_request_block_invoke;
      *(void *)&unsigned char buf[24] = &unk_1E5243FB0;
      objc_copyWeak(v48, &location);
      uint64_t source = nw_queue_context_create_source(v17, 2, 3, 0, buf, 0);
      v10[10] = source;
      if (source)
      {
        dispatch_time_t v19 = dispatch_time(0x8000000000000000, 1000000);
        uint64_t v20 = 1000000 * *((unsigned int *)v10 + 22);
        if (*(void *)source)
        {
          dispatch_source_set_timer(*(dispatch_source_t *)source, v19, v20, 0x3E8uLL);
        }
        else
        {
          *(void *)(source + 32) = v19;
          *(void *)(source + 40) = v20;
          if (*(unsigned char *)(source + 48) && *(unsigned char *)(source + 49)) {
            nw_queue_source_run_timer(source);
          }
        }
        nw_queue_activate_source(v10[10]);
        goto LABEL_63;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v23 = (id)gLogObj;
      *(_DWORD *)uint64_t v43 = 136446210;
      uint64_t v44 = "nw_write_request_start_file_updates";
      int v24 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v40 = 0;
      if (__nwlog_fault(v24, &type, &v40))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v25 = (id)gLogObj;
          os_log_type_t v26 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)uint64_t v43 = 136446210;
            uint64_t v44 = "nw_write_request_start_file_updates";
            _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s call to nw_queue_context_create_source(timer) for write request updates failed", v43, 0xCu);
          }
        }
        else if (v40)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v25 = __nwlog_obj();
          os_log_type_t v28 = type;
          BOOL v29 = os_log_type_enabled(v25, type);
          if (backtrace_string)
          {
            if (v29)
            {
              *(_DWORD *)uint64_t v43 = 136446466;
              uint64_t v44 = "nw_write_request_start_file_updates";
              __int16 v45 = 2082;
              id v46 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v25, v28, "%{public}s call to nw_queue_context_create_source(timer) for write request updates failed, dumping backtrace:%{public}s", v43, 0x16u);
            }

            free(backtrace_string);
            if (!v24) {
              goto LABEL_63;
            }
            goto LABEL_62;
          }
          if (v29)
          {
            *(_DWORD *)uint64_t v43 = 136446210;
            uint64_t v44 = "nw_write_request_start_file_updates";
            _os_log_impl(&dword_1830D4000, v25, v28, "%{public}s call to nw_queue_context_create_source(timer) for write request updates failed, no backtrace", v43, 0xCu);
          }
        }
        else
        {
          os_log_type_t v25 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (os_log_type_enabled(v25, type))
          {
            *(_DWORD *)uint64_t v43 = 136446210;
            uint64_t v44 = "nw_write_request_start_file_updates";
            _os_log_impl(&dword_1830D4000, v25, v30, "%{public}s call to nw_queue_context_create_source(timer) for write request updates failed, backtrace limit exceeded", v43, 0xCu);
          }
        }
      }
      if (!v24)
      {
LABEL_63:
        objc_destroyWeak(v48);
        objc_destroyWeak(&location);
LABEL_64:

        goto LABEL_65;
      }
LABEL_62:
      free(v24);
      goto LABEL_63;
    }
    int v32 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
    __int16 v33 = (char *)_os_log_send_and_compose_impl();

    v43[0] = 16;
    LOBYTE(location) = 0;
    if (__nwlog_fault(v33, v43, &location))
    {
      if (v43[0] == 17)
      {
        int v34 = __nwlog_obj();
        os_log_type_t v35 = v43[0];
        if (os_log_type_enabled(v34, (os_log_type_t)v43[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          _os_log_impl(&dword_1830D4000, v34, v35, "%{public}s called with null request->connection", buf, 0xCu);
        }
      }
      else if ((_BYTE)location)
      {
        BOOL v36 = (char *)__nw_create_backtrace_string();
        int v34 = __nwlog_obj();
        os_log_type_t v37 = v43[0];
        BOOL v38 = os_log_type_enabled(v34, (os_log_type_t)v43[0]);
        if (v36)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v36;
            _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s called with null request->connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v36);
          goto LABEL_91;
        }
        if (v38)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          _os_log_impl(&dword_1830D4000, v34, v37, "%{public}s called with null request->connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v34 = __nwlog_obj();
        os_log_type_t v39 = v43[0];
        if (os_log_type_enabled(v34, (os_log_type_t)v43[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_write_request_start_file_updates";
          _os_log_impl(&dword_1830D4000, v34, v39, "%{public}s called with null request->connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_91:
    if (v33) {
      free(v33);
    }
    goto LABEL_64;
  }
  if (v5) {
    goto LABEL_11;
  }
  if ((*((unsigned char *)v3 + 128) & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v21 = (id)gLogObj;
    if (os_log_type_enabled(v21, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_write_request_consume_bytes";
      _os_log_impl(&dword_1830D4000, v21, OS_LOG_TYPE_ERROR, "%{public}s No data to consume", buf, 0xCu);
    }
  }
  uint64_t v22 = 1;
LABEL_70:

  return v22;
}

void sub_183185BF0(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, id location)
{
  _Unwind_Resume(a1);
}

void nw_content_context_mark_completed_send(void *a1, void *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    if (v3 != &__block_literal_global_10_42276
      && v3 != &__block_literal_global_8_42267
      && v3 != &__block_literal_global_6_42258
      && v3 != &__block_literal_global_42249)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v3 + 28);
      *((unsigned char *)v3 + 118) |= 4u;
      objc_storeStrong((id *)v3 + 12, a2);
      *((void *)v3 + 9) = 0;
      os_unfair_lock_unlock((os_unfair_lock_t)v3 + 28);
    }
    goto LABEL_7;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_content_context_mark_completed_send";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_content_context_mark_completed_send";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      size_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_content_context_mark_completed_send";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_content_context_mark_completed_send";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      size_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_content_context_mark_completed_send";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v6) {
    free(v6);
  }
LABEL_7:
}

void __nw_connection_async_client(void *a1, dispatch_qos_class_t a2, void *a3)
{
  id v9 = a1;
  id v5 = a3;
  id v6 = (void *)*((void *)v9 + 25);
  if (v6)
  {
    size_t v7 = v6;
    dispatch_block_t v8 = dispatch_block_create_with_qos_class((dispatch_block_flags_t)0, a2, 0, v5);
    dispatch_async(v7, v8);
  }
  else if (!*((void *)v9 + 5))
  {
    nw_context_queue_block(*((void **)v9 + 3), v5);
  }
}

void sub_183185FF8(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

void ___ZL21nw_flow_service_readsP30NWConcrete_nw_endpoint_handlerP27NWConcrete_nw_endpoint_flowP16nw_flow_protocolb_block_invoke(uint64_t a1, void *a2, void *a3, BOOL a4, void *a5)
{
  uint64_t v60 = *MEMORY[0x1E4F143B8];
  id v9 = a2;
  id v10 = a3;
  id v11 = a5;
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 32)) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v20 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
    {
      id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 32));
      os_log_type_t v35 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 32));
      BOOL v36 = id_string;
      nw_endpoint_t v37 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 32));
      logging_description = nw_endpoint_get_logging_description(v37);
      id v23 = nw_endpoint_handler_state_string(*(void **)(a1 + 32));
      int v24 = nw_endpoint_handler_mode_string(*(void **)(a1 + 32));
      id v25 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 32));
      if (v9) {
        size_t size = dispatch_data_get_size(v9);
      }
      else {
        size_t size = 0;
      }
      *(_DWORD *)buf = 136448514;
      uint32_t v41 = "nw_flow_service_reads_block_invoke";
      __int16 v42 = 2082;
      uint64_t v43 = (char *)v36;
      __int16 v44 = 2082;
      __int16 v45 = v35;
      __int16 v46 = 2082;
      __int16 v47 = logging_description;
      __int16 v48 = 2082;
      uint64_t v49 = v23;
      __int16 v50 = 2082;
      uint64_t v51 = v24;
      __int16 v52 = 2114;
      id v53 = v25;
      __int16 v54 = 2048;
      size_t v55 = size;
      __int16 v56 = 2048;
      id v57 = v10;
      __int16 v58 = 2114;
      id v59 = v11;
      _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Got final data length %zu, context %p, error %{public}@", buf, 0x66u);
    }
  }
  uint64_t v12 = *(void *)(a1 + 40);
  int v13 = *(unsigned __int8 *)(a1 + 48);
  int v14 = v9;
  id v15 = v10;
  id v16 = v11;
  if (v12)
  {
    if (!*(void *)(v12 + 312))
    {
      BOOL v17 = nw_array_create();
      int v18 = *(void **)(v12 + 312);
      *(void *)(v12 + 312) = v17;
    }
    uint64_t v19 = nw_flow_final_read_create(v14, v15, v13 != 0, a4, v16);
    nw_array_append(*(void *)(v12 + 312), v19);

    goto LABEL_6;
  }
  char v27 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint32_t v41 = "nw_flow_append_final_read";
  os_log_type_t v28 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v38 = 0;
  if (__nwlog_fault(v28, &type, &v38))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v29 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v41 = "nw_flow_append_final_read";
        _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null flow_protocol", buf, 0xCu);
      }
    }
    else if (v38)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v29 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v29, type);
      if (backtrace_string)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          uint32_t v41 = "nw_flow_append_final_read";
          __int16 v42 = 2082;
          uint64_t v43 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null flow_protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v41 = "nw_flow_append_final_read";
        _os_log_impl(&dword_1830D4000, v29, v32, "%{public}s called with null flow_protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v29 = __nwlog_obj();
      os_log_type_t v34 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v41 = "nw_flow_append_final_read";
        _os_log_impl(&dword_1830D4000, v29, v34, "%{public}s called with null flow_protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_32:
  if (v28) {
    free(v28);
  }
LABEL_6:
}

void sub_1831864A8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

NWConcrete_nw_flow_final_read *nw_flow_final_read_create(void *a1, void *a2, BOOL a3, BOOL a4, void *a5)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v10 = a1;
  id v11 = a2;
  id v12 = a5;
  int v13 = [NWConcrete_nw_flow_final_read alloc];
  id v25 = v10;
  id v26 = v11;
  id v14 = v12;
  if (!v13) {
    goto LABEL_4;
  }
  v29.receiver = v13;
  v29.super_class = (Class)NWConcrete_nw_flow_final_read;
  id v15 = (NWConcrete_nw_flow_final_read *)objc_msgSendSuper2(&v29, sel_init);
  int v13 = v15;
  if (v15)
  {
    objc_storeStrong((id *)&v15->content, a1);
    objc_storeStrong((id *)&v13->content_context, a2);
    v13->receive_single_message = a3;
    v13->is_complete = a4;
    objc_storeStrong((id *)&v13->error, a5);
    goto LABEL_4;
  }
  BOOL v17 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v31 = "-[NWConcrete_nw_flow_final_read initWithContent:contentContext:receiveSingleMessage:isComplete:error:]";
  int v18 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v18, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "-[NWConcrete_nw_flow_final_read initWithContent:contentContext:receiveSingleMessage:isComplete:error:]";
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s [super init] failed", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v22 = type;
      BOOL v23 = os_log_type_enabled(v19, type);
      if (backtrace_string)
      {
        if (v23)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v31 = "-[NWConcrete_nw_flow_final_read initWithContent:contentContext:receiveSingleMessage:isComplete:error:]";
          __int16 v32 = 2082;
          BOOL v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "-[NWConcrete_nw_flow_final_read initWithContent:contentContext:receiveSingleMessage:isComplete:error:]";
        _os_log_impl(&dword_1830D4000, v19, v22, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v19 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v19, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v31 = "-[NWConcrete_nw_flow_final_read initWithContent:contentContext:receiveSingleMessage:isComplete:error:]";
        _os_log_impl(&dword_1830D4000, v19, v24, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v18) {
    free(v18);
  }
  int v13 = 0;
LABEL_4:

  return v13;
}

void sub_183186850(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_protocol_udp_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v117 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
    id v26 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (!__nwlog_fault(v26, &type, &v107)) {
      goto LABEL_207;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
      objc_super v29 = "%{public}s called with null protocol";
    }
    else if (v107)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v35 = os_log_type_enabled(v27, type);
      if (backtrace_string)
      {
        if (v35)
        {
          *(_DWORD *)buf = 136446466;
          dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
          __int16 v111 = 2082;
          id v112 = (nw_protocol *)backtrace_string;
          _os_log_impl(&dword_1830D4000, v27, v28, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_207:
        if (!v26) {
          return;
        }
        goto LABEL_208;
      }
      if (!v35) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
      objc_super v29 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
      objc_super v29 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    goto LABEL_206;
  }
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
    id v26 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (!__nwlog_fault(v26, &type, &v107)) {
      goto LABEL_207;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v107)
      {
        char v27 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (!os_log_type_enabled(v27, type)) {
          goto LABEL_207;
        }
        *(_DWORD *)buf = 136446210;
        dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
        objc_super v29 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_206;
      }
      BOOL v36 = (char *)__nw_create_backtrace_string();
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      BOOL v37 = os_log_type_enabled(v27, type);
      if (!v36)
      {
        if (!v37) {
          goto LABEL_207;
        }
        *(_DWORD *)buf = 136446210;
        dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
        objc_super v29 = "%{public}s called with null udp, no backtrace";
        goto LABEL_206;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446466;
        dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
        __int16 v111 = 2082;
        id v112 = (nw_protocol *)v36;
        char v38 = "%{public}s called with null udp, dumping backtrace:%{public}s";
LABEL_140:
        _os_log_impl(&dword_1830D4000, v27, v28, v38, buf, 0x16u);
      }
LABEL_141:
      free(v36);
      if (!v26) {
        return;
      }
LABEL_208:
      id v14 = (nw_protocol *)v26;
LABEL_32:
      free(v14);
      return;
    }
    char v27 = __nwlog_obj();
    os_log_type_t v28 = type;
    if (!os_log_type_enabled(v27, type)) {
      goto LABEL_207;
    }
    *(_DWORD *)buf = 136446210;
    dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
    objc_super v29 = "%{public}s called with null udp";
LABEL_206:
    _os_log_impl(&dword_1830D4000, v27, v28, v29, buf, 0xCu);
    goto LABEL_207;
  }
  if (gLogDatapath)
  {
    os_log_type_t v30 = __nwlog_obj();
    if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446466;
      dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
      __int16 v111 = 2082;
      id v112 = a1 + 3;
      _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Got a connected event from the lower layer", buf, 0x16u);
    }
  }
  if (!a1->default_input_handler)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v15 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
      __int16 v111 = 2082;
      id v112 = a1 + 3;
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s %{public}s No input handler found, ignoring connected call", buf, 0x16u);
    }
    return;
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_17);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled())
  {
    kdebug_trace();
    if (a1[1].default_input_handler) {
      goto LABEL_10;
    }
  }
  else if (a1[1].default_input_handler)
  {
    goto LABEL_10;
  }
  default_input_handler = a1->default_input_handler;
  if (!default_input_handler)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    dispatch_qos_class_t v110 = "__nw_protocol_get_path";
    uint64_t v82 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (!__nwlog_fault(v82, &type, &v107)) {
      goto LABEL_241;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v83 = __nwlog_obj();
      os_log_type_t v84 = type;
      if (!os_log_type_enabled(v83, type)) {
        goto LABEL_241;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      int v85 = "%{public}s called with null protocol";
    }
    else if (v107)
    {
      unint64_t v98 = (char *)__nw_create_backtrace_string();
      os_log_type_t v83 = __nwlog_obj();
      os_log_type_t v84 = type;
      BOOL v99 = os_log_type_enabled(v83, type);
      if (v98)
      {
        if (v99)
        {
          *(_DWORD *)buf = 136446466;
          dispatch_qos_class_t v110 = "__nw_protocol_get_path";
          __int16 v111 = 2082;
          id v112 = (nw_protocol *)v98;
          _os_log_impl(&dword_1830D4000, v83, v84, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v98);
        goto LABEL_241;
      }
      if (!v99)
      {
LABEL_241:
        if (v82) {
          free(v82);
        }
        goto LABEL_243;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      int v85 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      os_log_type_t v83 = __nwlog_obj();
      os_log_type_t v84 = type;
      if (!os_log_type_enabled(v83, type)) {
        goto LABEL_241;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      int v85 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v83, v84, v85, buf, 0xCu);
    goto LABEL_241;
  }
  char handle = default_input_handler->handle;
  if (handle == &nw_protocol_ref_counted_handle)
  {
    callbacks = default_input_handler[1].callbacks;
    if (callbacks) {
      default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
    }
  }
  __int16 v42 = default_input_handler->callbacks;
  if (v42)
  {
    get_path = (uint64_t (*)(nw_protocol *))v42->get_path;
    if (get_path)
    {
      __int16 v44 = (void *)get_path(default_input_handler);
      if (handle != &nw_protocol_ref_counted_handle) {
        goto LABEL_91;
      }
      goto LABEL_90;
    }
  }
  __nwlog_obj();
  name = default_input_handler->identifier->name;
  *(_DWORD *)buf = 136446722;
  dispatch_qos_class_t v110 = "__nw_protocol_get_path";
  if (!name) {
    name = "invalid";
  }
  __int16 v111 = 2082;
  id v112 = (nw_protocol *)name;
  __int16 v113 = 2048;
  int v114 = default_input_handler;
  id v69 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v107 = 0;
  if (__nwlog_fault(v69, &type, &v107))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_219;
      }
      BOOL v72 = default_input_handler->identifier->name;
      if (!v72) {
        BOOL v72 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v72;
      __int16 v113 = 2048;
      int v114 = default_input_handler;
      os_log_type_t v73 = "%{public}s protocol %{public}s (%p) has invalid get_path callback";
LABEL_218:
      _os_log_impl(&dword_1830D4000, v70, v71, v73, buf, 0x20u);
      goto LABEL_219;
    }
    if (!v107)
    {
      char v70 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (!os_log_type_enabled(v70, type)) {
        goto LABEL_219;
      }
      id v100 = default_input_handler->identifier->name;
      if (!v100) {
        id v100 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v100;
      __int16 v113 = 2048;
      int v114 = default_input_handler;
      os_log_type_t v73 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, backtrace limit exceeded";
      goto LABEL_218;
    }
    uint64_t v87 = (char *)__nw_create_backtrace_string();
    char v70 = __nwlog_obj();
    os_log_type_t v71 = type;
    BOOL v88 = os_log_type_enabled(v70, type);
    if (!v87)
    {
      if (!v88) {
        goto LABEL_219;
      }
      uint64_t v103 = default_input_handler->identifier->name;
      if (!v103) {
        uint64_t v103 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v103;
      __int16 v113 = 2048;
      int v114 = default_input_handler;
      os_log_type_t v73 = "%{public}s protocol %{public}s (%p) has invalid get_path callback, no backtrace";
      goto LABEL_218;
    }
    if (v88)
    {
      dispatch_qos_class_t v89 = default_input_handler->identifier->name;
      if (!v89) {
        dispatch_qos_class_t v89 = "invalid";
      }
      *(_DWORD *)buf = 136446978;
      dispatch_qos_class_t v110 = "__nw_protocol_get_path";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v89;
      __int16 v113 = 2048;
      int v114 = default_input_handler;
      __int16 v115 = 2082;
      os_log_type_t v116 = v87;
      _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s protocol %{public}s (%p) has invalid get_path callback, dumping backtrace:%{public}s", buf, 0x2Au);
    }
    free(v87);
  }
LABEL_219:
  if (v69) {
    free(v69);
  }
  __int16 v44 = 0;
  if (handle == &nw_protocol_ref_counted_handle)
  {
LABEL_90:
    if (default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v60 = default_input_handler[1].callbacks;
      if (v60)
      {
        __int16 v61 = (nw_protocol_callbacks *)((char *)v60 - 1);
        default_input_handler[1].callbacks = v61;
        if (!v61)
        {
          uint64_t v62 = *(void (***)(void))default_input_handler[1].flow_id;
          if (v62)
          {
            *(void *)default_input_handler[1].flow_id = 0;
            v62[2](v62);
            _Block_release(v62);
          }
          if (default_input_handler[1].flow_id[8])
          {
            uint64_t v63 = *(const void **)default_input_handler[1].flow_id;
            if (v63) {
              _Block_release(v63);
            }
          }
          free(default_input_handler);
        }
      }
    }
  }
LABEL_91:
  if (v44)
  {
    __int16 v45 = (nw_protocol *)os_retain(v44);
    a1[1].default_input_handler = v45;
    LODWORD(a1[2].default_input_handler) = nw_path_get_effective_traffic_class(v45);
    HIDWORD(a1[2].default_input_handler) = nw_path_get_maximum_datagram_size(a1[1].default_input_handler);
    __int16 v46 = a1->default_input_handler;
    if (v46)
    {
      __int16 v47 = v46->handle;
      if (v47 == &nw_protocol_ref_counted_handle)
      {
        __int16 v48 = v46[1].callbacks;
        if (v48) {
          v46[1].callbacks = (nw_protocol_callbacks *)((char *)&v48->add_input_handler + 1);
        }
      }
      uint64_t v49 = v46->callbacks;
      if (v49)
      {
        get_parameters = (uint64_t (*)(nw_protocol *))v49->get_parameters;
        if (get_parameters)
        {
          uint64_t v51 = (void *)get_parameters(v46);
          if (v47 != &nw_protocol_ref_counted_handle)
          {
LABEL_100:
            id v52 = nw_parameters_copy_context(v51);
            a1[1].output_handler_context = nw_path_copy_flow_registration(v52, (uint64_t)a1);
            if (v52) {
              os_release(v52);
            }
            char csum_flags = nw_path_get_csum_flags(v44);
            __int16 output_handler_context_high = HIWORD(a1[2].output_handler_context);
            if ((output_handler_context_high & 4) != 0 && (csum_flags & 4) != 0
              || (output_handler_context_high & 4) == 0 && (csum_flags & 0x40) != 0)
            {
              HIWORD(a1[2].output_handler_context) = output_handler_context_high & 0xFEF7 | 0x100;
            }
            output_handler_context = a1[1].output_handler_context;
            if (output_handler_context)
            {
              __int16 v56 = output_handler_context;
              __int16 v57 = v56[148];

              HIWORD(a1[2].output_handler_context) = HIWORD(a1[2].output_handler_context) & 0xFFF7 | (4 * v57) & 8;
              a1[2].char handle = nw_path_flow_registration_get_stats_area((NWConcrete_nw_path_flow_registration *)a1[1].output_handler_context, 2);
              stats_region = (nw_protocol *)nw_path_flow_registration_get_stats_region(a1[1].output_handler_context, (uint64_t)a1->identifier->name);
              a1[2].output_handler = stats_region;
              if (!stats_region)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                id v59 = gLogObj;
                if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
                  __int16 v111 = 2082;
                  id v112 = a1 + 3;
                  __int16 v113 = 2048;
                  int v114 = (nw_protocol *)&g_udp_stats;
                  _os_log_impl(&dword_1830D4000, v59, OS_LOG_TYPE_ERROR, "%{public}s %{public}s udp->udp_stats is NULL setting to global %p", buf, 0x20u);
                }
                a1[2].output_handler = (nw_protocol *)&g_udp_stats;
              }
            }
            goto LABEL_10;
          }
LABEL_99:
          if (v46->handle == &nw_protocol_ref_counted_handle)
          {
            uint64_t v64 = v46[1].callbacks;
            if (v64)
            {
              id v65 = (nw_protocol_callbacks *)((char *)v64 - 1);
              v46[1].callbacks = v65;
              if (!v65)
              {
                uint64_t v66 = *(void (***)(void))v46[1].flow_id;
                if (v66)
                {
                  *(void *)v46[1].flow_id = 0;
                  v66[2](v66);
                  _Block_release(v66);
                }
                if (v46[1].flow_id[8])
                {
                  int v67 = *(const void **)v46[1].flow_id;
                  if (v67) {
                    _Block_release(v67);
                  }
                }
                free(v46);
              }
            }
          }
          goto LABEL_100;
        }
      }
      __nwlog_obj();
      id v75 = v46->identifier->name;
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
      if (!v75) {
        id v75 = "invalid";
      }
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v75;
      __int16 v113 = 2048;
      int v114 = v46;
      id v76 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v107 = 0;
      id v77 = (char *)v76;
      if (__nwlog_fault(v76, &type, &v107))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v78 = __nwlog_obj();
          os_log_type_t v79 = type;
          if (!os_log_type_enabled(v78, type)) {
            goto LABEL_234;
          }
          uint64_t v80 = v46->identifier->name;
          if (!v80) {
            uint64_t v80 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          __int16 v111 = 2082;
          id v112 = (nw_protocol *)v80;
          __int16 v113 = 2048;
          int v114 = v46;
          int v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback";
LABEL_233:
          _os_log_impl(&dword_1830D4000, v78, v79, v81, buf, 0x20u);
          goto LABEL_234;
        }
        if (!v107)
        {
          uint64_t v78 = __nwlog_obj();
          os_log_type_t v79 = type;
          if (!os_log_type_enabled(v78, type)) {
            goto LABEL_234;
          }
          int v104 = v46->identifier->name;
          if (!v104) {
            int v104 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          __int16 v111 = 2082;
          id v112 = (nw_protocol *)v104;
          __int16 v113 = 2048;
          int v114 = v46;
          int v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded";
          goto LABEL_233;
        }
        char v95 = (char *)__nw_create_backtrace_string();
        uint64_t v78 = __nwlog_obj();
        os_log_type_t v79 = type;
        BOOL v96 = os_log_type_enabled(v78, type);
        if (!v95)
        {
          if (!v96) {
            goto LABEL_234;
          }
          uint64_t v105 = v46->identifier->name;
          if (!v105) {
            uint64_t v105 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          __int16 v111 = 2082;
          id v112 = (nw_protocol *)v105;
          __int16 v113 = 2048;
          int v114 = v46;
          int v81 = "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace";
          goto LABEL_233;
        }
        if (v96)
        {
          if (v46->identifier) {
            v97 = v46->identifier->name;
          }
          else {
            v97 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          __int16 v111 = 2082;
          id v112 = (nw_protocol *)v97;
          __int16 v113 = 2048;
          int v114 = v46;
          __int16 v115 = 2082;
          os_log_type_t v116 = v95;
          _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v95);
      }
LABEL_234:
      if (v77) {
        free(v77);
      }
      uint64_t v51 = 0;
      if (v47 != &nw_protocol_ref_counted_handle) {
        goto LABEL_100;
      }
      goto LABEL_99;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
    id v90 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (__nwlog_fault(v90, &type, &v107))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v91 = __nwlog_obj();
        os_log_type_t v92 = type;
        if (os_log_type_enabled(v91, type))
        {
          *(_DWORD *)buf = 136446210;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          uint64_t v93 = "%{public}s called with null protocol";
LABEL_249:
          _os_log_impl(&dword_1830D4000, v91, v92, v93, buf, 0xCu);
        }
      }
      else if (v107)
      {
        id v101 = (char *)__nw_create_backtrace_string();
        uint64_t v91 = __nwlog_obj();
        os_log_type_t v92 = type;
        BOOL v102 = os_log_type_enabled(v91, type);
        if (v101)
        {
          if (v102)
          {
            *(_DWORD *)buf = 136446466;
            dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
            __int16 v111 = 2082;
            id v112 = (nw_protocol *)v101;
            _os_log_impl(&dword_1830D4000, v91, v92, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v101);
          goto LABEL_250;
        }
        if (v102)
        {
          *(_DWORD *)buf = 136446210;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          uint64_t v93 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_249;
        }
      }
      else
      {
        uint64_t v91 = __nwlog_obj();
        os_log_type_t v92 = type;
        if (os_log_type_enabled(v91, type))
        {
          *(_DWORD *)buf = 136446210;
          dispatch_qos_class_t v110 = "__nw_protocol_get_parameters";
          uint64_t v93 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_249;
        }
      }
    }
LABEL_250:
    if (v90) {
      free(v90);
    }
    uint64_t v51 = 0;
    goto LABEL_100;
  }
LABEL_243:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v106 = gLogObj;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    dispatch_qos_class_t v110 = "nw_protocol_udp_connected";
    __int16 v111 = 2082;
    id v112 = a1 + 3;
    _os_log_impl(&dword_1830D4000, v106, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Unable to get path from input protocol, cannot publish UDP stats", buf, 0x16u);
  }
LABEL_10:
  id v3 = a1->default_input_handler;
  if (!v3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    dispatch_qos_class_t v110 = "__nw_protocol_connected";
    id v26 = (const char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v107 = 0;
    if (!__nwlog_fault(v26, &type, &v107)) {
      goto LABEL_207;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      objc_super v29 = "%{public}s called with null protocol";
      goto LABEL_206;
    }
    if (!v107)
    {
      char v27 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (!os_log_type_enabled(v27, type)) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      objc_super v29 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_206;
    }
    BOOL v36 = (char *)__nw_create_backtrace_string();
    char v27 = __nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v74 = os_log_type_enabled(v27, type);
    if (!v36)
    {
      if (!v74) {
        goto LABEL_207;
      }
      *(_DWORD *)buf = 136446210;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      objc_super v29 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_206;
    }
    if (v74)
    {
      *(_DWORD *)buf = 136446466;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v36;
      char v38 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
      goto LABEL_140;
    }
    goto LABEL_141;
  }
  id v4 = v3->handle;
  if (v4 == &nw_protocol_ref_counted_handle)
  {
    id v5 = v3[1].callbacks;
    if (v5) {
      v3[1].callbacks = (nw_protocol_callbacks *)((char *)&v5->add_input_handler + 1);
    }
  }
  id v6 = a1->handle;
  if (v6 == &nw_protocol_ref_counted_handle)
  {
    size_t v7 = a1[1].callbacks;
    if (v7) {
      a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v7->add_input_handler + 1);
    }
  }
  dispatch_block_t v8 = v3->callbacks;
  if (v8)
  {
    connected = (void (*)(nw_protocol *, nw_protocol *))v8->connected;
    if (connected)
    {
      connected(v3, a1);
      goto LABEL_20;
    }
  }
  __nwlog_obj();
  os_log_type_t v20 = v3->identifier->name;
  *(_DWORD *)buf = 136446722;
  dispatch_qos_class_t v110 = "__nw_protocol_connected";
  if (!v20) {
    os_log_type_t v20 = "invalid";
  }
  __int16 v111 = 2082;
  id v112 = (nw_protocol *)v20;
  __int16 v113 = 2048;
  int v114 = v3;
  os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v107 = 0;
  if (__nwlog_fault(v21, &type, &v107))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_179;
      }
      os_log_type_t v24 = v3->identifier->name;
      if (!v24) {
        os_log_type_t v24 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v24;
      __int16 v113 = 2048;
      int v114 = v3;
      id v25 = "%{public}s protocol %{public}s (%p) has invalid connected callback";
      goto LABEL_178;
    }
    if (!v107)
    {
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (!os_log_type_enabled(v22, type)) {
        goto LABEL_179;
      }
      uint64_t v86 = v3->identifier->name;
      if (!v86) {
        uint64_t v86 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v86;
      __int16 v113 = 2048;
      int v114 = v3;
      id v25 = "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded";
      goto LABEL_178;
    }
    __int16 v31 = (char *)__nw_create_backtrace_string();
    os_log_type_t v22 = __nwlog_obj();
    os_log_type_t v23 = type;
    BOOL v32 = os_log_type_enabled(v22, type);
    if (v31)
    {
      if (v32)
      {
        BOOL v33 = v3->identifier->name;
        if (!v33) {
          BOOL v33 = "invalid";
        }
        *(_DWORD *)buf = 136446978;
        dispatch_qos_class_t v110 = "__nw_protocol_connected";
        __int16 v111 = 2082;
        id v112 = (nw_protocol *)v33;
        __int16 v113 = 2048;
        int v114 = v3;
        __int16 v115 = 2082;
        os_log_type_t v116 = v31;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
      }
      free(v31);
      goto LABEL_179;
    }
    if (v32)
    {
      id v94 = v3->identifier->name;
      if (!v94) {
        id v94 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      dispatch_qos_class_t v110 = "__nw_protocol_connected";
      __int16 v111 = 2082;
      id v112 = (nw_protocol *)v94;
      __int16 v113 = 2048;
      int v114 = v3;
      id v25 = "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace";
LABEL_178:
      _os_log_impl(&dword_1830D4000, v22, v23, v25, buf, 0x20u);
    }
  }
LABEL_179:
  if (v21) {
    free(v21);
  }
LABEL_20:
  if (v6 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
  {
    id v16 = a1[1].callbacks;
    if (v16)
    {
      BOOL v17 = (nw_protocol_callbacks *)((char *)v16 - 1);
      a1[1].callbacks = v17;
      if (!v17)
      {
        int v18 = *(void (***)(void))a1[1].flow_id;
        if (v18)
        {
          *(void *)a1[1].flow_id = 0;
          v18[2](v18);
          _Block_release(v18);
        }
        if (a1[1].flow_id[8])
        {
          uint64_t v19 = *(const void **)a1[1].flow_id;
          if (v19) {
            _Block_release(v19);
          }
        }
        free(a1);
      }
    }
  }
  if (v4 == &nw_protocol_ref_counted_handle && v3->handle == &nw_protocol_ref_counted_handle)
  {
    id v10 = v3[1].callbacks;
    if (v10)
    {
      id v11 = (nw_protocol_callbacks *)((char *)v10 - 1);
      v3[1].callbacks = v11;
      if (!v11)
      {
        id v12 = *(void (***)(void))v3[1].flow_id;
        if (v12)
        {
          *(void *)v3[1].flow_id = 0;
          v12[2](v12);
          _Block_release(v12);
        }
        if (v3[1].flow_id[8])
        {
          int v13 = *(const void **)v3[1].flow_id;
          if (v13) {
            _Block_release(v13);
          }
        }
        id v14 = v3;
        goto LABEL_32;
      }
    }
  }
}

necp_all_stats *nw_protocol_instance_get_stats(void *a1, int a2, uint64_t a3)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = v5;
  if (!v5)
  {
    id v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_protocol_instance_get_stats";
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v11, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null instance", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v22 = "nw_protocol_instance_get_stats";
            __int16 v23 = 2082;
            os_log_type_t v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_24;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_protocol_instance_get_stats";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_24:
    if (v11) {
      free(v11);
    }
    goto LABEL_26;
  }
  if (a3)
  {
    uint64_t v7 = nw_protocol_implementation_lookup_path(v5, a3, 0);
    if (v7)
    {
      wakeup = *(NWConcrete_nw_path_flow_registration **)(v7 + 24);
      if (wakeup) {
        goto LABEL_7;
      }
    }
LABEL_26:
    stats_area = 0;
    goto LABEL_27;
  }
  wakeup = (NWConcrete_nw_path_flow_registration *)v5->wakeup;
  if (!wakeup) {
    goto LABEL_26;
  }
LABEL_7:
  stats_area = nw_path_flow_registration_get_stats_area(wakeup, a2);
LABEL_27:

  return stats_area;
}

void sub_1831882C0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

necp_all_stats *nw_path_flow_registration_get_stats_area(NWConcrete_nw_path_flow_registration *a1, int a2)
{
  *(void *)&v33[13] = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    os_log_type_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v31 = "nw_path_flow_registration_get_stats_area";
    os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v21, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null registration", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v31 = "nw_path_flow_registration_get_stats_area";
            __int16 v32 = 2082;
            *(void *)BOOL v33 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null registration, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_56;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null registration, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v31 = "nw_path_flow_registration_get_stats_area";
          _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null registration, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_56:
    if (v21) {
      free(v21);
    }
    return 0;
  }
  if ((*((unsigned char *)a1 + 148) & 1) == 0) {
    return 0;
  }
  if ((a2 - 1) >= 3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v10 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    __int16 v31 = "nw_path_flow_registration_get_stats_area";
    __int16 v32 = 1024;
    *(_DWORD *)BOOL v33 = a2;
    id v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v11, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v12 = (id)gLogObj;
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          __int16 v31 = "nw_path_flow_registration_get_stats_area";
          __int16 v32 = 1024;
          *(_DWORD *)BOOL v33 = a2;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s Requested unknown stats type %u", buf, 0x12u);
        }
      }
      else if (v28)
      {
        id v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v12 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (v14)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446722;
            __int16 v31 = "nw_path_flow_registration_get_stats_area";
            __int16 v32 = 1024;
            *(_DWORD *)BOOL v33 = a2;
            v33[2] = 2082;
            *(void *)&v33[3] = v14;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s Requested unknown stats type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v11) {
            return 0;
          }
          goto LABEL_24;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v31 = "nw_path_flow_registration_get_stats_area";
          __int16 v32 = 1024;
          *(_DWORD *)BOOL v33 = a2;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s Requested unknown stats type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v12 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446466;
          __int16 v31 = "nw_path_flow_registration_get_stats_area";
          __int16 v32 = 1024;
          *(_DWORD *)BOOL v33 = a2;
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s Requested unknown stats type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (v11) {
LABEL_24:
    }
      free(v11);
    return 0;
  }
  uint64_t result = a1->flow_stats_area;
  if (!result || (unsigned int var0 = result->var0.var0.var0.var0) == 0)
  {
    os_log_type_t v17 = nw_path_flow_registration_copy_parent_evaluator(a1);
    id v18 = nw_parameters_copy_context(*((void **)v17 + 1));
    nw_context_assert_queue(v18);
    a1->flow_stats_area = 0;

    return 0;
  }
  if ((var0 != 3 || a2 != 2) && var0 != a2)
  {
    dispatch_block_t v8 = __nwlog_obj();
    if (os_log_type_enabled(v8, OS_LOG_TYPE_ERROR))
    {
      flow_stats_area = a1->flow_stats_area;
      if (flow_stats_area) {
        LODWORD(flow_stats_area) = flow_stats_area->var0.var0.var0.var0;
      }
      *(_DWORD *)buf = 136446722;
      __int16 v31 = "nw_path_flow_registration_get_stats_area";
      __int16 v32 = 1024;
      *(_DWORD *)BOOL v33 = flow_stats_area;
      v33[2] = 1024;
      *(_DWORD *)&v33[3] = a2;
      _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s Requested stats type does not match allocated type (%u != %u)", buf, 0x18u);
    }

    return 0;
  }
  return result;
}

void sub_1831888F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_protocol_implementation_get_parameters(nw_protocol *a1)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    char handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    id v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (!v6)
      {
        os_log_type_t v24 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        int v67 = "nw_protocol_implementation_get_parameters";
        os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v21, type, &v65)) {
          goto LABEL_140;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v22 = __nwlog_obj();
          os_log_type_t v25 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_139;
        }
        if (v65 == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v22 = __nwlog_obj();
          os_log_type_t v47 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v47, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_139;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        BOOL v36 = os_log_type_enabled(v22, type[0]);
        if (!backtrace_string)
        {
          if (v36)
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v35, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_139;
        }
        if (v36)
        {
          *(_DWORD *)buf = 136446466;
          int v67 = "nw_protocol_implementation_get_parameters";
          __int16 v68 = 2082;
          id v69 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v35, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_65;
      }
      if (!*(void *)(v6 + 80))
      {
        BOOL v26 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        int v67 = "nw_protocol_implementation_get_parameters";
        os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v21, type, &v65)) {
          goto LABEL_140;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v22 = __nwlog_obj();
          os_log_type_t v27 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
          goto LABEL_139;
        }
        if (v65 == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v22 = __nwlog_obj();
          os_log_type_t v50 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v50, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_139;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v37 = type[0];
        BOOL v38 = os_log_type_enabled(v22, type[0]);
        if (!backtrace_string)
        {
          if (v38)
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "nw_protocol_implementation_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v37, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_139;
        }
        if (v38)
        {
          *(_DWORD *)buf = 136446466;
          int v67 = "nw_protocol_implementation_get_parameters";
          __int16 v68 = 2082;
          id v69 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v37, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
        goto LABEL_65;
      }
      if (*((void *)v4 + 40))
      {
        uint64_t v7 = (void *)*((void *)v4 + 43);
LABEL_11:
        id v8 = v7;
LABEL_12:

        goto LABEL_13;
      }
      if (*(_DWORD *)(v6 + 64) == 3)
      {
        uint64_t v7 = (void *)*((void *)v4 + 6);
        goto LABEL_11;
      }
      default_input_handler = a1->default_input_handler;
      if (default_input_handler)
      {
        id v11 = default_input_handler->handle;
        if (v11 == &nw_protocol_ref_counted_handle)
        {
          callbacks = default_input_handler[1].callbacks;
          if (callbacks) {
            default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
          }
          char v12 = -1;
        }
        else
        {
          char v12 = 0;
        }
        *(void *)os_log_type_t type = default_input_handler;
        char v64 = v12;
        id v14 = default_input_handler->callbacks;
        if (v14)
        {
          get_parameters = (void (*)(nw_protocol *))v14->get_parameters;
          if (get_parameters)
          {
            get_parameters(default_input_handler);
            id v8 = (id)objc_claimAutoreleasedReturnValue();
            if (v11 != &nw_protocol_ref_counted_handle) {
              goto LABEL_12;
            }
LABEL_25:
            nw::release_if_needed<nw_protocol *>((uint64_t *)type);
            goto LABEL_12;
          }
        }
        os_log_type_t v39 = __nwlog_obj();
        name = default_input_handler->identifier->name;
        *(_DWORD *)buf = 136446722;
        int v67 = "__nw_protocol_get_parameters";
        if (!name) {
          name = "invalid";
        }
        __int16 v68 = 2082;
        id v69 = (void *)name;
        __int16 v70 = 2048;
        __int16 v61 = default_input_handler;
        os_log_type_t v71 = default_input_handler;
        uint32_t v41 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t v65 = OS_LOG_TYPE_ERROR;
        char v62 = 0;
        if (__nwlog_fault(v41, &v65, &v62))
        {
          if (v65 == OS_LOG_TYPE_FAULT)
          {
            __int16 v42 = __nwlog_obj();
            os_log_type_t v43 = v65;
            if (os_log_type_enabled(v42, v65))
            {
              __int16 v44 = v61->identifier->name;
              if (!v44) {
                __int16 v44 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              int v67 = "__nw_protocol_get_parameters";
              __int16 v68 = 2082;
              id v69 = (void *)v44;
              __int16 v70 = 2048;
              os_log_type_t v71 = v61;
              _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback", buf, 0x20u);
            }
LABEL_129:

            goto LABEL_130;
          }
          if (!v62)
          {
            __int16 v42 = __nwlog_obj();
            os_log_type_t v57 = v65;
            if (os_log_type_enabled(v42, v65))
            {
              __int16 v58 = v61->identifier->name;
              if (!v58) {
                __int16 v58 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              int v67 = "__nw_protocol_get_parameters";
              __int16 v68 = 2082;
              id v69 = (void *)v58;
              __int16 v70 = 2048;
              os_log_type_t v71 = v61;
              _os_log_impl(&dword_1830D4000, v42, v57, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded", buf, 0x20u);
            }
            goto LABEL_129;
          }
          uint64_t v51 = (char *)__nw_create_backtrace_string();
          __int16 v42 = __nwlog_obj();
          os_log_type_t v52 = v65;
          BOOL v53 = os_log_type_enabled(v42, v65);
          if (!v51)
          {
            if (v53)
            {
              id v59 = v61->identifier->name;
              if (!v59) {
                id v59 = "invalid";
              }
              *(_DWORD *)buf = 136446722;
              int v67 = "__nw_protocol_get_parameters";
              __int16 v68 = 2082;
              id v69 = (void *)v59;
              __int16 v70 = 2048;
              os_log_type_t v71 = v61;
              _os_log_impl(&dword_1830D4000, v42, v52, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace", buf, 0x20u);
            }
            goto LABEL_129;
          }
          if (v53)
          {
            __int16 v54 = v61->identifier->name;
            if (!v54) {
              __int16 v54 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            int v67 = "__nw_protocol_get_parameters";
            __int16 v68 = 2082;
            id v69 = (void *)v54;
            __int16 v70 = 2048;
            os_log_type_t v71 = v61;
            __int16 v72 = 2082;
            os_log_type_t v73 = v51;
            _os_log_impl(&dword_1830D4000, v42, v52, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v51);
        }
LABEL_130:
        if (v41) {
          free(v41);
        }
        id v8 = 0;
        if (v11 != &nw_protocol_ref_counted_handle) {
          goto LABEL_12;
        }
        goto LABEL_25;
      }
      __int16 v48 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v67 = "__nw_protocol_get_parameters";
      os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v21, type, &v65))
      {
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v22 = __nwlog_obj();
          os_log_type_t v49 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "__nw_protocol_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v49, "%{public}s called with null protocol", buf, 0xCu);
          }
LABEL_139:

          goto LABEL_140;
        }
        if (v65 == OS_LOG_TYPE_DEFAULT)
        {
          os_log_type_t v22 = __nwlog_obj();
          os_log_type_t v60 = type[0];
          if (os_log_type_enabled(v22, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "__nw_protocol_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v60, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_139;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v55 = type[0];
        BOOL v56 = os_log_type_enabled(v22, type[0]);
        if (!backtrace_string)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446210;
            int v67 = "__nw_protocol_get_parameters";
            _os_log_impl(&dword_1830D4000, v22, v55, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
          }
          goto LABEL_139;
        }
        if (v56)
        {
          *(_DWORD *)buf = 136446466;
          int v67 = "__nw_protocol_get_parameters";
          __int16 v68 = 2082;
          id v69 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v22, v55, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
LABEL_65:

        free(backtrace_string);
        if (!v21) {
          goto LABEL_142;
        }
        goto LABEL_141;
      }
    }
    else
    {
      os_log_type_t v20 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      int v67 = "nw_protocol_implementation_get_parameters";
      os_log_type_t v21 = (char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v21, type, &v65)) {
        goto LABEL_140;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v23 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          int v67 = "nw_protocol_implementation_get_parameters";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_139;
      }
      if (v65 == OS_LOG_TYPE_DEFAULT)
      {
        os_log_type_t v22 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v22, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          int v67 = "nw_protocol_implementation_get_parameters";
          _os_log_impl(&dword_1830D4000, v22, v46, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_139;
      }
      __int16 v31 = (char *)__nw_create_backtrace_string();
      os_log_type_t v22 = __nwlog_obj();
      os_log_type_t v32 = type[0];
      BOOL v33 = os_log_type_enabled(v22, type[0]);
      if (!v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446210;
          int v67 = "nw_protocol_implementation_get_parameters";
          _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_139;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446466;
        int v67 = "nw_protocol_implementation_get_parameters";
        __int16 v68 = 2082;
        id v69 = v31;
        _os_log_impl(&dword_1830D4000, v22, v32, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(v31);
    }
LABEL_140:
    if (!v21)
    {
LABEL_142:
      id v8 = 0;
      goto LABEL_12;
    }
LABEL_141:
    free(v21);
    goto LABEL_142;
  }
  BOOL v16 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v67 = "nw_protocol_implementation_get_parameters";
  os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v65 = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v17, type, &v65))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v18 = __nwlog_obj();
      os_log_type_t v19 = type[0];
      if (os_log_type_enabled(v18, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v67 = "nw_protocol_implementation_get_parameters";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v65)
    {
      char v28 = (char *)__nw_create_backtrace_string();
      id v18 = __nwlog_obj();
      os_log_type_t v29 = type[0];
      BOOL v30 = os_log_type_enabled(v18, type[0]);
      if (v28)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          int v67 = "nw_protocol_implementation_get_parameters";
          __int16 v68 = 2082;
          id v69 = v28;
          _os_log_impl(&dword_1830D4000, v18, v29, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v28);
        goto LABEL_103;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        int v67 = "nw_protocol_implementation_get_parameters";
        _os_log_impl(&dword_1830D4000, v18, v29, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v18 = __nwlog_obj();
      os_log_type_t v45 = type[0];
      if (os_log_type_enabled(v18, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        int v67 = "nw_protocol_implementation_get_parameters";
        _os_log_impl(&dword_1830D4000, v18, v45, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_103:
  if (v17) {
    free(v17);
  }
  id v8 = 0;
LABEL_13:

  return v8;
}

uint64_t nw_path_get_maximum_datagram_size(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t mtu = nw_path_get_mtu(v1);
    uint64_t v4 = mtu;
    if (mtu) {
      unsigned int v5 = mtu;
    }
    else {
      unsigned int v5 = 1500;
    }
    if (v5 >= 0x3C)
    {
      uint64_t v6 = v2[3];
      if (v6
        && (id v7 = v6, v8 = [v7 type], v7, v8 == 1)
        && nw_endpoint_get_address_family(v2[3]) == 2)
      {
        int v9 = -20;
      }
      else
      {
        int v9 = -40;
      }
      if (nw_parameters_get_ip_protocol(v2[2]) == 17) {
        int v10 = -8;
      }
      else {
        int v10 = -20;
      }
      uint64_t v4 = v10 + v5 + v9;
    }
    goto LABEL_15;
  }
  char v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_path_get_maximum_datagram_size";
  os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_path_get_maximum_datagram_size";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v23 = "nw_path_get_maximum_datagram_size";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_32;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_path_get_maximum_datagram_size";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_path_get_maximum_datagram_size";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_32:
  if (v13) {
    free(v13);
  }
  uint64_t v4 = 0;
LABEL_15:

  return v4;
}

void sub_183189AA8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_maximum_packet_size(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t mtu = nw_path_get_mtu(v1);
    uint64_t v4 = mtu;
    if (mtu) {
      unsigned int v5 = mtu;
    }
    else {
      unsigned int v5 = 1500;
    }
    if (v5 >= 0x28)
    {
      uint64_t v6 = v2[3];
      if (v6
        && (id v7 = v6, v8 = [v7 type], v7, v8 == 1)
        && nw_endpoint_get_address_family(v2[3]) == 2)
      {
        uint64_t v4 = v5 - 20;
      }
      else
      {
        uint64_t v4 = v5 - 40;
      }
    }
    goto LABEL_11;
  }
  int v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v21 = "nw_path_get_maximum_packet_size";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v21 = "nw_path_get_maximum_packet_size";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v21 = "nw_path_get_maximum_packet_size";
          __int16 v22 = 2082;
          os_log_type_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v21 = "nw_path_get_maximum_packet_size";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v21 = "nw_path_get_maximum_packet_size";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_28:
  if (v11) {
    free(v11);
  }
  uint64_t v4 = 0;
LABEL_11:

  return v4;
}

void sub_183189DBC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_mtu(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    int v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v19 = "nw_path_get_mtu";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v9, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_get_mtu";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v19 = "nw_path_get_mtu";
            __int16 v20 = 2082;
            os_log_type_t v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_27;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_get_mtu";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v19 = "nw_path_get_mtu";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_27:
    if (v9) {
      free(v9);
    }
    goto LABEL_9;
  }
  if (!nw_path_network_is_satisfied_update_reason(v1, 0)) {
    goto LABEL_9;
  }
  effective_uint64_t mtu = v2->effective_mtu;
  if (!effective_mtu)
  {
    direct = v2->direct;
    if (direct)
    {
      unsigned int v5 = direct;
      effective_uint64_t mtu = *((unsigned int *)v5 + 15);

      goto LABEL_10;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v6 = (id)gLogObj;
    if (os_log_type_enabled(v6, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v19 = "nw_path_get_mtu";
      _os_log_impl(&dword_1830D4000, v6, OS_LOG_TYPE_ERROR, "%{public}s Unable to determine MTU for path", buf, 0xCu);
    }

LABEL_9:
    effective_uint64_t mtu = 0;
  }
LABEL_10:

  return effective_mtu;
}

void sub_18318A118(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v91 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = nw_frame_copy_metadata_for_protocol(a2, *(void *)(a1 + 48));
  if (v4)
  {
    unsigned int v5 = v4;
    if (nw_http_metadata_is_capsule(v4))
    {
      uint64_t v6 = *(void *)(a1 + 56);
      if (!v6 || (*(unsigned char *)(v6 + 529) & 1) == 0)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
        }
        id v7 = gprivacy_proxyLogObj;
        BOOL v8 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO);
        uint64_t v6 = *(void *)(a1 + 56);
        if (v8)
        {
          int v9 = (const char *)(v6 + 531);
          int v10 = "";
          if (v6) {
            int v10 = " ";
          }
          else {
            int v9 = "";
          }
          *(_DWORD *)buf = 136446466;
          *(void *)uint64_t v86 = v9;
          *(_WORD *)&v86[8] = 2080;
          *(void *)&v86[10] = v10;
          _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_INFO, "%{public}s%sReceived HTTP Capsule for listener", buf, 0x16u);
          uint64_t v6 = *(void *)(a1 + 56);
        }
      }
      nw_masque_handle_capsule(v6, v5);
      uint64_t v11 = *(void *)(a2 + 32);
      char v12 = *(void **)(a2 + 40);
      if (v11)
      {
        *(void *)(v11 + 40) = v12;
        char v12 = *(void **)(a2 + 40);
      }
      else
      {
        *(void *)(*(void *)(a1 + 64) + 8) = v12;
      }
      void *v12 = v11;
      *(void *)(a2 + 32) = 0;
      *(void *)(a2 + 40) = 0;
      nw_frame_finalize(a2);
    }
    os_release(v5);
    return 1;
  }
  unsigned int v84 = 0;
  os_log_type_t v13 = (unsigned __int8 *)nw_frame_unclaimed_bytes(a2, &v84);
  uint64_t v14 = *(void *)(a2 + 32);
  os_log_type_t v15 = *(void **)(a2 + 40);
  if (v14)
  {
    *(void *)(v14 + 40) = v15;
    os_log_type_t v15 = *(void **)(a2 + 40);
  }
  else
  {
    *(void *)(*(void *)(a1 + 64) + 8) = v15;
  }
  void *v15 = v14;
  *(void *)(a2 + 32) = 0;
  *(void *)(a2 + 40) = 0;
  if (!v84)
  {
    uint64_t v21 = *(void *)(a1 + 56);
    if (v21 && (*(unsigned char *)(v21 + 529) & 1) != 0) {
      goto LABEL_79;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
    }
    uint64_t v22 = gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_79;
    }
    uint64_t v23 = *(void *)(a1 + 56);
    uint64_t v24 = "";
    BOOL v25 = v23 == 0;
    if (v23) {
      uint64_t v26 = (const char *)(v23 + 531);
    }
    else {
      uint64_t v26 = "";
    }
    *(_DWORD *)buf = 136446722;
    if (!v25) {
      uint64_t v24 = " ";
    }
    *(void *)uint64_t v86 = v26;
    *(_WORD *)&v86[8] = 2080;
    *(void *)&v86[10] = v24;
    *(_WORD *)&v86[18] = 1024;
    *(_DWORD *)&v86[20] = v84;
    os_log_type_t v27 = "%{public}s%sReceived datagram is too short (length %u)";
LABEL_77:
    os_log_type_t v46 = buf;
LABEL_78:
    _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_INFO, v27, v46, 0x1Cu);
    goto LABEL_79;
  }
  int v16 = *v13;
  if (v16 != 6)
  {
    if (v16 == 4)
    {
      *(void *)&address[8] = 0;
      if (v84 > 6)
      {
        *(_WORD *)address = 528;
        *(_DWORD *)&address[4] = *(_DWORD *)(v13 + 1);
        *(_WORD *)&address[2] = *(_WORD *)(v13 + 5);
        nw_endpoint_t v18 = nw_endpoint_create_address((const sockaddr *)address);
        uint64_t v19 = a2;
        int v20 = 7;
        goto LABEL_38;
      }
      uint64_t v41 = *(void *)(a1 + 56);
      if (v41 && (*(unsigned char *)(v41 + 529) & 1) != 0) {
        goto LABEL_79;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
      }
      uint64_t v22 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO))
      {
LABEL_79:
        nw_frame_finalize(a2);
        return 1;
      }
      uint64_t v42 = *(void *)(a1 + 56);
      os_log_type_t v43 = "";
      BOOL v44 = v42 == 0;
      if (v42) {
        os_log_type_t v45 = (const char *)(v42 + 531);
      }
      else {
        os_log_type_t v45 = "";
      }
      *(_DWORD *)buf = 136446722;
      if (!v44) {
        os_log_type_t v43 = " ";
      }
      *(void *)uint64_t v86 = v45;
      *(_WORD *)&v86[8] = 2080;
      *(void *)&v86[10] = v43;
      *(_WORD *)&v86[18] = 1024;
      *(_DWORD *)&v86[20] = v84;
      os_log_type_t v27 = "%{public}s%sReceived datagram is too short for IPv4 (length %u)";
    }
    else
    {
      uint64_t v36 = *(void *)(a1 + 56);
      if (v36 && (*(unsigned char *)(v36 + 529) & 1) != 0) {
        goto LABEL_79;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
      }
      uint64_t v22 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
        goto LABEL_79;
      }
      uint64_t v37 = *(void *)(a1 + 56);
      BOOL v38 = v37 == 0;
      if (v37) {
        os_log_type_t v39 = (const char *)(v37 + 531);
      }
      else {
        os_log_type_t v39 = "";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)uint64_t v86 = v39;
      char v40 = " ";
      if (v38) {
        char v40 = "";
      }
      *(_WORD *)&v86[8] = 2080;
      *(void *)&v86[10] = v40;
      *(_WORD *)&v86[18] = 1024;
      *(_DWORD *)&v86[20] = v16;
      os_log_type_t v27 = "%{public}s%sReceived datagram with unsupported IP version %u";
    }
    goto LABEL_77;
  }
  memset(v86, 0, 24);
  if (v84 <= 0x12)
  {
    uint64_t v48 = *(void *)(a1 + 56);
    if (v48 && (*(unsigned char *)(v48 + 529) & 1) != 0) {
      goto LABEL_79;
    }
    if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
      dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
    }
    uint64_t v22 = gprivacy_proxyLogObj;
    if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_INFO)) {
      goto LABEL_79;
    }
    uint64_t v49 = *(void *)(a1 + 56);
    os_log_type_t v50 = "";
    BOOL v51 = v49 == 0;
    if (v49) {
      os_log_type_t v52 = (const char *)(v49 + 531);
    }
    else {
      os_log_type_t v52 = "";
    }
    *(_DWORD *)address = 136446722;
    if (!v51) {
      os_log_type_t v50 = " ";
    }
    *(void *)&address[4] = v52;
    *(_WORD *)&address[12] = 2080;
    *(void *)&address[14] = v50;
    *(_WORD *)&address[22] = 1024;
    unsigned int v90 = v84;
    os_log_type_t v27 = "%{public}s%sReceived datagram is too short for IPv6 (length %u)";
    os_log_type_t v46 = address;
    goto LABEL_78;
  }
  *(_WORD *)buf = 7708;
  *(_OWORD *)&v86[4] = *(_OWORD *)(v13 + 1);
  *(_WORD *)&buf[2] = *(_WORD *)(v13 + 17);
  nw_endpoint_t v18 = nw_endpoint_create_address((const sockaddr *)buf);
  uint64_t v19 = a2;
  int v20 = 19;
LABEL_38:
  nw_frame_claim(v19, v17, v20, 0);
  *(void *)address = 0;
  *(void *)&address[8] = address;
  *(void *)&address[16] = 0x2000000000;
  LOBYTE(v90) = 0;
  uint64_t v28 = *(void *)(a1 + 56);
  os_log_type_t v29 = *(char **)(v28 + 480);
  v78[0] = MEMORY[0x1E4F143A8];
  v78[1] = 0x40000000;
  v78[2] = ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_158;
  v78[3] = &unk_1E523EAC0;
  v78[4] = address;
  long long v81 = *(_OWORD *)(a1 + 72);
  nw_endpoint_t v80 = v18;
  uint64_t v82 = a2;
  uint64_t v83 = v28;
  long long v79 = *(_OWORD *)(a1 + 32);
  nw_hash_table_apply(v29, (uint64_t)v78);
  if (!*(unsigned char *)(*(void *)&address[8] + 24))
  {
    uint64_t v53 = *(void *)(a1 + 56);
    __int16 v54 = *(void ***)(v53 + 440);
    if (v54 && (os_log_type_t v55 = *v54) != 0 && *v55)
    {
      if ((*(unsigned char *)(v53 + 529) & 1) == 0 && gLogDatapath)
      {
        if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
          dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
        }
        __int16 v72 = gprivacy_proxyLogObj;
        BOOL v73 = os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_DEBUG);
        uint64_t v53 = *(void *)(a1 + 56);
        if (v73)
        {
          BOOL v74 = v53 == 0;
          if (v53) {
            id v75 = (const char *)(v53 + 531);
          }
          else {
            id v75 = "";
          }
          *(_DWORD *)buf = 136446978;
          *(void *)uint64_t v86 = "nw_protocol_masque_listener_read_input_block_invoke";
          *(_WORD *)&v86[8] = 2082;
          *(void *)&v86[10] = v75;
          id v76 = " ";
          if (v74) {
            id v76 = "";
          }
          *(_WORD *)&v86[18] = 2080;
          *(void *)&v86[20] = v76;
          __int16 v87 = 2112;
          nw_endpoint_t v88 = v18;
          _os_log_impl(&dword_1830D4000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFound new frame for %@, creating a new flow", buf, 0x2Au);
          uint64_t v53 = *(void *)(a1 + 56);
        }
      }
      nw_parameters_t v56 = nw_parameters_copy(*(nw_parameters_t *)(v53 + 320));
      char v57 = (***(uint64_t (****)(void, nw_endpoint_t, nw_parameters_t))(*(void *)(a1 + 56) + 440))(*(void *)(*(void *)(a1 + 56) + 440), v18, v56);
      if (v56) {
        os_release(v56);
      }
      if (v57)
      {
        *(unsigned char *)(*(void *)&address[8] + 24) = 0;
        uint64_t v58 = *(void *)(a1 + 56);
        id v59 = *(char **)(v58 + 480);
        v77[0] = MEMORY[0x1E4F143A8];
        v77[1] = 0x40000000;
        v77[2] = ___ZL38nw_protocol_masque_listener_read_inputP9nw_masqueP12nw_hash_nodeP16nw_frame_array_sjjj_block_invoke_160;
        v77[3] = &unk_1E523EAE8;
        v77[6] = v18;
        v77[7] = a2;
        v77[8] = v58;
        uint64_t v60 = *(void *)(a1 + 40);
        v77[4] = address;
        v77[5] = v60;
        nw_hash_table_apply(v59, (uint64_t)v77);
        goto LABEL_39;
      }
      uint64_t v67 = *(void *)(a1 + 56);
      if (v67 && (*(unsigned char *)(v67 + 529) & 1) != 0) {
        goto LABEL_39;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
      }
      __int16 v61 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
      uint64_t v68 = *(void *)(a1 + 56);
      BOOL v69 = v68 == 0;
      if (v68) {
        __int16 v70 = (const char *)(v68 + 531);
      }
      else {
        __int16 v70 = "";
      }
      os_log_type_t v71 = " ";
      if (v69) {
        os_log_type_t v71 = "";
      }
      *(_DWORD *)buf = 136446466;
      *(void *)uint64_t v86 = v70;
      *(_WORD *)&v86[8] = 2080;
      *(void *)&v86[10] = v71;
      uint64_t v66 = "%{public}s%sFailed to accept new flow";
    }
    else
    {
      if (*(unsigned char *)(v53 + 529)) {
        goto LABEL_39;
      }
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
      }
      __int16 v61 = gprivacy_proxyLogObj;
      if (!os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR)) {
        goto LABEL_39;
      }
      uint64_t v62 = *(void *)(a1 + 56);
      BOOL v63 = v62 == 0;
      if (v62) {
        char v64 = (const char *)(v62 + 531);
      }
      else {
        char v64 = "";
      }
      os_log_type_t v65 = " ";
      if (v63) {
        os_log_type_t v65 = "";
      }
      *(_DWORD *)buf = 136446466;
      *(void *)uint64_t v86 = v64;
      *(_WORD *)&v86[8] = 2080;
      *(void *)&v86[10] = v65;
      uint64_t v66 = "%{public}s%sReceived datagram for new flow, but no listen protocol is able to receive the new flow";
    }
    _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_ERROR, v66, buf, 0x16u);
  }
LABEL_39:
  if (!*(unsigned char *)(*(void *)&address[8] + 24))
  {
    uint64_t v30 = *(void *)(a1 + 56);
    if (!v30 || (*(unsigned char *)(v30 + 529) & 1) == 0)
    {
      if (__nwlog_privacy_proxy_log::onceToken[0] != -1) {
        dispatch_once(__nwlog_privacy_proxy_log::onceToken, &__block_literal_global_56_44901);
      }
      __int16 v31 = gprivacy_proxyLogObj;
      if (os_log_type_enabled((os_log_t)gprivacy_proxyLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v32 = *(void *)(a1 + 56);
        BOOL v33 = v32 == 0;
        if (v32) {
          uint64_t v34 = (const char *)(v32 + 531);
        }
        else {
          uint64_t v34 = "";
        }
        os_log_type_t v35 = " ";
        if (v33) {
          os_log_type_t v35 = "";
        }
        *(_DWORD *)buf = 136446466;
        *(void *)uint64_t v86 = v34;
        *(_WORD *)&v86[8] = 2080;
        *(void *)&v86[10] = v35;
        _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s%sFailed to find a flow to accept inbound packet, dropping", buf, 0x16u);
      }
    }
    nw_frame_finalize(a2);
  }
  if (v18) {
    os_release(v18);
  }
  _Block_object_dispose(address, 8);
  return 1;
}

void nw_protocol_implementation_connected(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v145 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    char handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    uint64_t v6 = p_output_handler;
    id v7 = v6;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v8 = *((void *)v6 + 1);
      if (v8)
      {
        if (*(void *)(v8 + 80))
        {
          if (!*((void *)v6 + 36))
          {
            uint64_t v9 = nw_protocol_instance_copy_path(v6, -1);
            int v10 = (void *)*((void *)v7 + 36);
            *((void *)v7 + 36) = v9;
          }
          if (a1->output_handler != a2)
          {
            *(void *)os_log_type_t type = 0;
            uint64_t v11 = nw_protocol_implementation_lookup_path_by_protocol((NWConcrete_nw_protocol_instance *)v7, a2, (unint64_t *)type);
            if (v11)
            {
              uint64_t v12 = v11;
              if (*(_DWORD *)(v11 + 128) != 3)
              {
                if ((v7[405] & 0x80000000) == 0)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v13 = (id)gLogObj;
                  if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
                  {
                    uint64_t v14 = *(void *)(v12 + 16);
                    uint64_t v15 = *(void *)(v12 + 120);
                    *(_DWORD *)buf = 136447490;
                    v134 = "nw_protocol_implementation_connected";
                    __int16 v135 = 2082;
                    id v136 = v7 + 407;
                    __int16 v137 = 2080;
                    v138 = " ";
                    __int16 v139 = 2048;
                    int v140 = *(char **)type;
                    __int16 v141 = 2112;
                    uint64_t v142 = v14;
                    __int16 v143 = 2112;
                    uint64_t v144 = v15;
                    _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sPath %lx is now established over %@:%@", buf, 0x3Eu);
                  }
                }
                *(_DWORD *)(v12 + 128) = 3;
                int v16 = (char *)*((void *)v7 + 39);
                uint64_t v17 = *(char **)type;
                if (v16 == *(char **)type) {
                  *((void *)v7 + 38) = v16;
                }
                (*(void (**)(char *, char *, uint64_t, BOOL))(*(void *)(*((void *)v7 + 1) + 80) + 208))(v7, v17, 3, v16 == v17);
                nw_protocol_implementation_read((NWConcrete_nw_protocol_instance *)v7, a2);
              }
            }
          }
          if (*(_DWORD *)(*((void *)v7 + 1) + 64) == 3)
          {
            nw_endpoint_t v18 = (char *)*((void *)v7 + 29);
            v126[0] = MEMORY[0x1E4F143A8];
            v126[1] = 3221225472;
            v126[2] = ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke;
            v126[3] = &__block_descriptor_40_e23_B16__0__nw_hash_node__8l;
            v126[4] = a2;
            nw_hash_table_apply(v18, (uint64_t)v126);
            if (a1->output_handler == a2)
            {
              v7[402] |= 0x20u;
              uint64_t v19 = (char *)*((void *)v7 + 29);
              v124[0] = MEMORY[0x1E4F143A8];
              v124[1] = 3221225472;
              v124[2] = ___ZL36nw_protocol_implementation_connectedP11nw_protocolS0__block_invoke_2;
              v124[3] = &unk_1E524AF58;
              int v20 = v7;
              id v125 = v20;
              nw_hash_table_apply(v19, (uint64_t)v124);
              nw_protocol_implementation_read(v20, a1->output_handler);
            }
            goto LABEL_42;
          }
          default_input_handler = a1->default_input_handler;
          if (default_input_handler)
          {
            uint64_t v22 = default_input_handler->handle;
            if (v22 == &nw_protocol_ref_counted_handle)
            {
              callbacks = default_input_handler[1].callbacks;
              if (callbacks) {
                default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
              }
              char v23 = -1;
            }
            else
            {
              char v23 = 0;
            }
            *(void *)os_log_type_t type = default_input_handler;
            char v132 = v23;
            if (a2)
            {
              BOOL v25 = a2->handle;
              if (v25 == &nw_protocol_ref_counted_handle)
              {
                os_log_type_t v27 = a2[1].callbacks;
                if (v27) {
                  a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v27->add_input_handler + 1);
                }
                char v26 = -1;
              }
              else
              {
                char v26 = 0;
              }
              *(void *)id v128 = a2;
              char v129 = v26;
              uint64_t v28 = default_input_handler->callbacks;
              if (v28)
              {
                connected = (void (*)(nw_protocol *, nw_protocol *))v28->connected;
                if (connected)
                {
                  connected(default_input_handler, a2);
LABEL_37:
                  if (v25 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)v128);
                  }
LABEL_39:
                  if (v22 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
LABEL_41:
                  if (a1->output_handler != a2)
                  {
LABEL_42:

                    return;
                  }
                  char v30 = v7[402];
                  v7[402] = v30 | 0x20;
                  uint64_t v31 = *((void *)v7 + 1);
                  if (*(_DWORD *)(v31 + 64) != 1 && (v30 & 8) == 0)
                  {
                    if ((v30 & 4) != 0) {
                      goto LABEL_42;
                    }
                    if (*(void *)(*(void *)(v31 + 80) + 120))
                    {
                      v7[402] = v30 | 0x24;
                      uint64_t v32 = *(void (**)(char *, uint64_t, uint64_t))(*(void *)(v31 + 80) + 120);
                      server_uint64_t mode = nw_parameters_get_server_mode(*((void **)v7 + 6));
                      v32(v7, -1, server_mode);
                      nw_protocol_implementation_read((NWConcrete_nw_protocol_instance *)v7, a1->output_handler);
                      goto LABEL_42;
                    }
                    os_log_type_t v43 = __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    v134 = "nw_protocol_implementation_connected";
                    BOOL v44 = (char *)_os_log_send_and_compose_impl();

                    type[0] = OS_LOG_TYPE_ERROR;
                    v128[0] = OS_LOG_TYPE_DEFAULT;
                    if (!__nwlog_fault(v44, type, v128)) {
                      goto LABEL_85;
                    }
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      os_log_type_t v45 = __nwlog_obj();
                      os_log_type_t v46 = type[0];
                      if (os_log_type_enabled(v45, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        v134 = "nw_protocol_implementation_connected";
                        _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null instance->parent_definition->start", buf, 0xCu);
                      }
LABEL_84:

                      goto LABEL_85;
                    }
                    if (v128[0] == OS_LOG_TYPE_DEFAULT)
                    {
                      os_log_type_t v45 = __nwlog_obj();
                      os_log_type_t v50 = type[0];
                      if (os_log_type_enabled(v45, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        v134 = "nw_protocol_implementation_connected";
                        _os_log_impl(&dword_1830D4000, v45, v50, "%{public}s called with null instance->parent_definition->start, backtrace limit exceeded", buf, 0xCu);
                      }
                      goto LABEL_84;
                    }
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    os_log_type_t v45 = __nwlog_obj();
                    os_log_type_t v48 = type[0];
                    BOOL v49 = os_log_type_enabled(v45, type[0]);
                    if (!backtrace_string)
                    {
                      if (v49)
                      {
                        *(_DWORD *)buf = 136446210;
                        v134 = "nw_protocol_implementation_connected";
                        _os_log_impl(&dword_1830D4000, v45, v48, "%{public}s called with null instance->parent_definition->start, no backtrace", buf, 0xCu);
                      }
                      goto LABEL_84;
                    }
                    if (v49)
                    {
                      *(_DWORD *)buf = 136446466;
                      v134 = "nw_protocol_implementation_connected";
                      __int16 v135 = 2082;
                      id v136 = backtrace_string;
                      _os_log_impl(&dword_1830D4000, v45, v48, "%{public}s called with null instance->parent_definition->start, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    goto LABEL_76;
                  }
                  v7[402] = v30 | 0x28;
                  uint64_t v34 = a1->default_input_handler;
                  if (v34)
                  {
                    os_log_type_t v35 = v34->handle;
                    if (v35 == &nw_protocol_ref_counted_handle)
                    {
                      uint64_t v37 = v34[1].callbacks;
                      if (v37) {
                        v34[1].callbacks = (nw_protocol_callbacks *)((char *)&v37->add_input_handler + 1);
                      }
                      char v36 = -1;
                    }
                    else
                    {
                      char v36 = 0;
                    }
                    *(void *)os_log_type_t type = v34;
                    char v132 = v36;
                    BOOL v38 = a1->handle;
                    if (v38 == &nw_protocol_ref_counted_handle)
                    {
                      char v40 = a1[1].callbacks;
                      if (v40) {
                        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v40->add_input_handler + 1);
                      }
                      char v39 = -1;
                    }
                    else
                    {
                      char v39 = 0;
                    }
                    *(void *)id v128 = a1;
                    char v129 = v39;
                    uint64_t v41 = v34->callbacks;
                    if (v41)
                    {
                      uint64_t v42 = (void (*)(nw_protocol *, nw_protocol *))v41->connected;
                      if (v42)
                      {
                        v42(v34, a1);
LABEL_63:
                        if (v38 == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>((uint64_t *)v128);
                        }
                        if (v35 == &nw_protocol_ref_counted_handle) {
                          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                        }
                        goto LABEL_42;
                      }
                    }
                    BOOL v99 = __nwlog_obj();
                    name = v34->identifier->name;
                    *(_DWORD *)buf = 136446722;
                    v134 = "__nw_protocol_connected";
                    if (!name) {
                      name = "invalid";
                    }
                    __int16 v135 = 2082;
                    id v136 = (void *)name;
                    __int16 v137 = 2048;
                    v138 = (const char *)v34;
                    id v101 = (char *)_os_log_send_and_compose_impl();

                    os_log_type_t v130 = OS_LOG_TYPE_ERROR;
                    char v127 = 0;
                    if (__nwlog_fault(v101, &v130, &v127))
                    {
                      if (v130 == OS_LOG_TYPE_FAULT)
                      {
                        BOOL v102 = __nwlog_obj();
                        os_log_type_t v103 = v130;
                        if (os_log_type_enabled(v102, v130))
                        {
                          int v104 = v34->identifier->name;
                          if (!v104) {
                            int v104 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          v134 = "__nw_protocol_connected";
                          __int16 v135 = 2082;
                          id v136 = (void *)v104;
                          __int16 v137 = 2048;
                          v138 = (const char *)v34;
                          _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s protocol %{public}s (%p) has invalid connected callback", buf, 0x20u);
                        }
                      }
                      else if (v127)
                      {
                        id v112 = (char *)__nw_create_backtrace_string();
                        BOOL v102 = __nwlog_obj();
                        os_log_type_t v113 = v130;
                        BOOL v114 = os_log_type_enabled(v102, v130);
                        if (v112)
                        {
                          if (v114)
                          {
                            __int16 v115 = v34->identifier->name;
                            if (!v115) {
                              __int16 v115 = "invalid";
                            }
                            *(_DWORD *)buf = 136446978;
                            v134 = "__nw_protocol_connected";
                            __int16 v135 = 2082;
                            id v136 = (void *)v115;
                            __int16 v137 = 2048;
                            v138 = (const char *)v34;
                            __int16 v139 = 2082;
                            int v140 = v112;
                            _os_log_impl(&dword_1830D4000, v102, v113, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
                          }

                          free(v112);
                          goto LABEL_254;
                        }
                        if (v114)
                        {
                          __int16 v120 = v34->identifier->name;
                          if (!v120) {
                            __int16 v120 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          v134 = "__nw_protocol_connected";
                          __int16 v135 = 2082;
                          id v136 = (void *)v120;
                          __int16 v137 = 2048;
                          v138 = (const char *)v34;
                          _os_log_impl(&dword_1830D4000, v102, v113, "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace", buf, 0x20u);
                        }
                      }
                      else
                      {
                        BOOL v102 = __nwlog_obj();
                        os_log_type_t v118 = v130;
                        if (os_log_type_enabled(v102, v130))
                        {
                          v119 = v34->identifier->name;
                          if (!v119) {
                            v119 = "invalid";
                          }
                          *(_DWORD *)buf = 136446722;
                          v134 = "__nw_protocol_connected";
                          __int16 v135 = 2082;
                          id v136 = (void *)v119;
                          __int16 v137 = 2048;
                          v138 = (const char *)v34;
                          _os_log_impl(&dword_1830D4000, v102, v118, "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded", buf, 0x20u);
                        }
                      }
                    }
LABEL_254:
                    if (v101) {
                      free(v101);
                    }
                    goto LABEL_63;
                  }
                  __int16 v108 = __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  v134 = "__nw_protocol_connected";
                  BOOL v44 = (char *)_os_log_send_and_compose_impl();

                  type[0] = OS_LOG_TYPE_ERROR;
                  v128[0] = OS_LOG_TYPE_DEFAULT;
                  if (__nwlog_fault(v44, type, v128))
                  {
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      os_log_type_t v45 = __nwlog_obj();
                      os_log_type_t v109 = type[0];
                      if (os_log_type_enabled(v45, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        v134 = "__nw_protocol_connected";
                        _os_log_impl(&dword_1830D4000, v45, v109, "%{public}s called with null protocol", buf, 0xCu);
                      }
                      goto LABEL_84;
                    }
                    if (v128[0] == OS_LOG_TYPE_DEFAULT)
                    {
                      os_log_type_t v45 = __nwlog_obj();
                      os_log_type_t v121 = type[0];
                      if (os_log_type_enabled(v45, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        v134 = "__nw_protocol_connected";
                        _os_log_impl(&dword_1830D4000, v45, v121, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
                      }
                      goto LABEL_84;
                    }
                    backtrace_string = (char *)__nw_create_backtrace_string();
                    os_log_type_t v45 = __nwlog_obj();
                    os_log_type_t v116 = type[0];
                    BOOL v117 = os_log_type_enabled(v45, type[0]);
                    if (!backtrace_string)
                    {
                      if (v117)
                      {
                        *(_DWORD *)buf = 136446210;
                        v134 = "__nw_protocol_connected";
                        _os_log_impl(&dword_1830D4000, v45, v116, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
                      }
                      goto LABEL_84;
                    }
                    if (v117)
                    {
                      *(_DWORD *)buf = 136446466;
                      v134 = "__nw_protocol_connected";
                      __int16 v135 = 2082;
                      id v136 = backtrace_string;
                      _os_log_impl(&dword_1830D4000, v45, v116, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                    }
LABEL_76:

                    goto LABEL_77;
                  }
LABEL_85:
                  if (!v44) {
                    goto LABEL_42;
                  }
LABEL_86:
                  free(v44);
                  goto LABEL_42;
                }
              }
              uint64_t v62 = __nwlog_obj();
              BOOL v63 = default_input_handler->identifier->name;
              *(_DWORD *)buf = 136446722;
              v134 = "__nw_protocol_connected";
              if (!v63) {
                BOOL v63 = "invalid";
              }
              __int16 v135 = 2082;
              id v136 = (void *)v63;
              __int16 v137 = 2048;
              v138 = (const char *)default_input_handler;
              int v123 = (const char *)_os_log_send_and_compose_impl();

              os_log_type_t v130 = OS_LOG_TYPE_ERROR;
              char v127 = 0;
              char v64 = (char *)v123;
              if (!__nwlog_fault(v123, &v130, &v127))
              {
LABEL_209:
                if (v64) {
                  free(v64);
                }
                goto LABEL_37;
              }
              if (v130 == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v65 = __nwlog_obj();
                os_log_type_t v66 = v130;
                if (os_log_type_enabled(v65, v130))
                {
                  uint64_t v67 = default_input_handler->identifier->name;
                  if (!v67) {
                    uint64_t v67 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v134 = "__nw_protocol_connected";
                  __int16 v135 = 2082;
                  id v136 = (void *)v67;
                  __int16 v137 = 2048;
                  v138 = (const char *)default_input_handler;
                  _os_log_impl(&dword_1830D4000, v65, v66, "%{public}s protocol %{public}s (%p) has invalid connected callback", buf, 0x20u);
                }
              }
              else if (v127)
              {
                uint64_t v86 = (char *)__nw_create_backtrace_string();
                os_log_type_t v65 = __nwlog_obj();
                os_log_type_t v122 = v130;
                BOOL v87 = os_log_type_enabled(v65, v130);
                if (v86)
                {
                  if (v87)
                  {
                    nw_endpoint_t v88 = default_input_handler->identifier->name;
                    if (!v88) {
                      nw_endpoint_t v88 = "invalid";
                    }
                    *(_DWORD *)buf = 136446978;
                    v134 = "__nw_protocol_connected";
                    __int16 v135 = 2082;
                    id v136 = (void *)v88;
                    __int16 v137 = 2048;
                    v138 = (const char *)default_input_handler;
                    __int16 v139 = 2082;
                    int v140 = v86;
                    _os_log_impl(&dword_1830D4000, v65, v122, "%{public}s protocol %{public}s (%p) has invalid connected callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }

                  free(v86);
                  goto LABEL_208;
                }
                if (v87)
                {
                  char v107 = default_input_handler->identifier->name;
                  if (!v107) {
                    char v107 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v134 = "__nw_protocol_connected";
                  __int16 v135 = 2082;
                  id v136 = (void *)v107;
                  __int16 v137 = 2048;
                  v138 = (const char *)default_input_handler;
                  _os_log_impl(&dword_1830D4000, v65, v122, "%{public}s protocol %{public}s (%p) has invalid connected callback, no backtrace", buf, 0x20u);
                }
              }
              else
              {
                os_log_type_t v65 = __nwlog_obj();
                os_log_type_t v105 = v130;
                if (os_log_type_enabled(v65, v130))
                {
                  id v106 = default_input_handler->identifier->name;
                  if (!v106) {
                    id v106 = "invalid";
                  }
                  *(_DWORD *)buf = 136446722;
                  v134 = "__nw_protocol_connected";
                  __int16 v135 = 2082;
                  id v136 = (void *)v106;
                  __int16 v137 = 2048;
                  v138 = (const char *)default_input_handler;
                  _os_log_impl(&dword_1830D4000, v65, v105, "%{public}s protocol %{public}s (%p) has invalid connected callback, backtrace limit exceeded", buf, 0x20u);
                }
              }

LABEL_208:
              char v64 = (char *)v123;
              goto LABEL_209;
            }
            uint64_t v82 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            v134 = "__nw_protocol_connected";
            uint64_t v83 = (char *)_os_log_send_and_compose_impl();

            v128[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v130 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v83, v128, &v130))
            {
              if (v128[0] == OS_LOG_TYPE_FAULT)
              {
                unsigned int v84 = __nwlog_obj();
                os_log_type_t v85 = v128[0];
                if (os_log_type_enabled(v84, v128[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v134 = "__nw_protocol_connected";
                  _os_log_impl(&dword_1830D4000, v84, v85, "%{public}s called with null other_protocol", buf, 0xCu);
                }
              }
              else if (v130)
              {
                os_log_type_t v92 = (char *)__nw_create_backtrace_string();
                unsigned int v84 = __nwlog_obj();
                os_log_type_t v93 = v128[0];
                BOOL v94 = os_log_type_enabled(v84, v128[0]);
                if (v92)
                {
                  if (v94)
                  {
                    *(_DWORD *)buf = 136446466;
                    v134 = "__nw_protocol_connected";
                    __int16 v135 = 2082;
                    id v136 = v92;
                    _os_log_impl(&dword_1830D4000, v84, v93, "%{public}s called with null other_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v92);
                  goto LABEL_237;
                }
                if (v94)
                {
                  *(_DWORD *)buf = 136446210;
                  v134 = "__nw_protocol_connected";
                  _os_log_impl(&dword_1830D4000, v84, v93, "%{public}s called with null other_protocol, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                unsigned int v84 = __nwlog_obj();
                os_log_type_t v111 = v128[0];
                if (os_log_type_enabled(v84, v128[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  v134 = "__nw_protocol_connected";
                  _os_log_impl(&dword_1830D4000, v84, v111, "%{public}s called with null other_protocol, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_237:
            if (v83) {
              free(v83);
            }
            goto LABEL_39;
          }
          id v76 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          v134 = "__nw_protocol_connected";
          id v77 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          v128[0] = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v77, type, v128))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              uint64_t v78 = __nwlog_obj();
              os_log_type_t v79 = type[0];
              if (os_log_type_enabled(v78, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v134 = "__nw_protocol_connected";
                _os_log_impl(&dword_1830D4000, v78, v79, "%{public}s called with null protocol", buf, 0xCu);
              }
            }
            else if (v128[0])
            {
              dispatch_qos_class_t v89 = (char *)__nw_create_backtrace_string();
              uint64_t v78 = __nwlog_obj();
              os_log_type_t v90 = type[0];
              BOOL v91 = os_log_type_enabled(v78, type[0]);
              if (v89)
              {
                if (v91)
                {
                  *(_DWORD *)buf = 136446466;
                  v134 = "__nw_protocol_connected";
                  __int16 v135 = 2082;
                  id v136 = v89;
                  _os_log_impl(&dword_1830D4000, v78, v90, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v89);
                goto LABEL_232;
              }
              if (v91)
              {
                *(_DWORD *)buf = 136446210;
                v134 = "__nw_protocol_connected";
                _os_log_impl(&dword_1830D4000, v78, v90, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              uint64_t v78 = __nwlog_obj();
              os_log_type_t v110 = type[0];
              if (os_log_type_enabled(v78, type[0]))
              {
                *(_DWORD *)buf = 136446210;
                v134 = "__nw_protocol_connected";
                _os_log_impl(&dword_1830D4000, v78, v110, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
LABEL_232:
          if (v77) {
            free(v77);
          }
          goto LABEL_41;
        }
        uint64_t v60 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        BOOL v44 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v128[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v44, type, v128)) {
          goto LABEL_85;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          nw_parameters_t v56 = __nwlog_obj();
          os_log_type_t v61 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v134 = "nw_protocol_implementation_connected";
            _os_log_impl(&dword_1830D4000, v56, v61, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
          goto LABEL_202;
        }
        if (v128[0] == OS_LOG_TYPE_DEFAULT)
        {
          nw_parameters_t v56 = __nwlog_obj();
          os_log_type_t v98 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v134 = "nw_protocol_implementation_connected";
            _os_log_impl(&dword_1830D4000, v56, v98, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_202;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        nw_parameters_t v56 = __nwlog_obj();
        os_log_type_t v80 = type[0];
        BOOL v81 = os_log_type_enabled(v56, type[0]);
        if (!backtrace_string)
        {
          if (v81)
          {
            *(_DWORD *)buf = 136446210;
            v134 = "nw_protocol_implementation_connected";
            _os_log_impl(&dword_1830D4000, v56, v80, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_202;
        }
        if (v81)
        {
          *(_DWORD *)buf = 136446466;
          v134 = "nw_protocol_implementation_connected";
          __int16 v135 = 2082;
          id v136 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v56, v80, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v58 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        BOOL v44 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v128[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v44, type, v128)) {
          goto LABEL_85;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          nw_parameters_t v56 = __nwlog_obj();
          os_log_type_t v59 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v134 = "nw_protocol_implementation_connected";
            _os_log_impl(&dword_1830D4000, v56, v59, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_202;
        }
        if (v128[0] == OS_LOG_TYPE_DEFAULT)
        {
          nw_parameters_t v56 = __nwlog_obj();
          os_log_type_t v97 = type[0];
          if (os_log_type_enabled(v56, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v134 = "nw_protocol_implementation_connected";
            _os_log_impl(&dword_1830D4000, v56, v97, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_202;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        nw_parameters_t v56 = __nwlog_obj();
        os_log_type_t v74 = type[0];
        BOOL v75 = os_log_type_enabled(v56, type[0]);
        if (!backtrace_string)
        {
          if (v75)
          {
            *(_DWORD *)buf = 136446210;
            v134 = "nw_protocol_implementation_connected";
            _os_log_impl(&dword_1830D4000, v56, v74, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_202;
        }
        if (v75)
        {
          *(_DWORD *)buf = 136446466;
          v134 = "nw_protocol_implementation_connected";
          __int16 v135 = 2082;
          id v136 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v56, v74, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }

LABEL_77:
      free(backtrace_string);
      if (!v44) {
        goto LABEL_42;
      }
      goto LABEL_86;
    }
    os_log_type_t v55 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v134 = "nw_protocol_implementation_connected";
    BOOL v44 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v128[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v44, type, v128)) {
      goto LABEL_85;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_parameters_t v56 = __nwlog_obj();
      os_log_type_t v57 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v128[0])
    {
      os_log_type_t v71 = (char *)__nw_create_backtrace_string();
      nw_parameters_t v56 = __nwlog_obj();
      os_log_type_t v72 = type[0];
      BOOL v73 = os_log_type_enabled(v56, type[0]);
      if (v71)
      {
        if (v73)
        {
          *(_DWORD *)buf = 136446466;
          v134 = "nw_protocol_implementation_connected";
          __int16 v135 = 2082;
          id v136 = v71;
          _os_log_impl(&dword_1830D4000, v56, v72, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v71);
        goto LABEL_85;
      }
      if (v73)
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_1830D4000, v56, v72, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_parameters_t v56 = __nwlog_obj();
      os_log_type_t v96 = type[0];
      if (os_log_type_enabled(v56, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_1830D4000, v56, v96, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_202:

    goto LABEL_85;
  }
  BOOL v51 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  v134 = "nw_protocol_implementation_connected";
  os_log_type_t v52 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v128[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v52, type, v128))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      uint64_t v53 = __nwlog_obj();
      os_log_type_t v54 = type[0];
      if (os_log_type_enabled(v53, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v128[0])
    {
      uint64_t v68 = (char *)__nw_create_backtrace_string();
      uint64_t v53 = __nwlog_obj();
      os_log_type_t v69 = type[0];
      BOOL v70 = os_log_type_enabled(v53, type[0]);
      if (v68)
      {
        if (v70)
        {
          *(_DWORD *)buf = 136446466;
          v134 = "nw_protocol_implementation_connected";
          __int16 v135 = 2082;
          id v136 = v68;
          _os_log_impl(&dword_1830D4000, v53, v69, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v68);
        goto LABEL_192;
      }
      if (v70)
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_1830D4000, v53, v69, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v53 = __nwlog_obj();
      os_log_type_t v95 = type[0];
      if (os_log_type_enabled(v53, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        v134 = "nw_protocol_implementation_connected";
        _os_log_impl(&dword_1830D4000, v53, v95, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_192:
  if (v52) {
    free(v52);
  }
}

id nw_parameters_copy_avoided_netagent_uuids(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    unsigned int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v17 = "nw_parameters_copy_avoided_netagent_uuids";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_parameters_copy_avoided_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v17 = "nw_parameters_copy_avoided_netagent_uuids";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_parameters_copy_avoided_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v17 = "nw_parameters_copy_avoided_netagent_uuids";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 120);
LABEL_23:

  return v4;
}

nw_endpoint_t nw_path_copy_endpoint_from_tlv(int a1, size_t __n, void *__src)
{
  unsigned int v3 = __n;
  uint64_t v127 = *MEMORY[0x1E4F143B8];
  memset(__dst, 0, sizeof(__dst));
  if ((__n - 257) <= 0xFFFFFF06)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
    __int16 v116 = 1024;
    int v117 = a1;
    __int16 v118 = 1024;
    unsigned int v119 = v3;
    __int16 v120 = 2080;
    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
    __int16 v122 = 1024;
    int v123 = 1693;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v6, type, &v112)) {
      goto LABEL_50;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      os_log_type_t v8 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        __int16 v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1693;
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
LABEL_49:

LABEL_50:
      if (!v6) {
        return 0;
      }
LABEL_51:
      free(v6);
      return 0;
    }
    if (v112 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      os_log_type_t v27 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        __int16 v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1693;
        _os_log_impl(&dword_1830D4000, v7, v27, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    os_log_type_t v19 = type[0];
    BOOL v20 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (v20)
      {
        *(_DWORD *)buf = 136447234;
        __int16 v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1693;
        _os_log_impl(&dword_1830D4000, v7, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_49;
    }
    if (v20)
    {
      *(_DWORD *)buf = 136447490;
      __int16 v115 = "nw_path_copy_endpoint_from_tlv";
      __int16 v116 = 1024;
      int v117 = a1;
      __int16 v118 = 1024;
      unsigned int v119 = v3;
      __int16 v120 = 2080;
      os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
      __int16 v122 = 1024;
      int v123 = 1693;
      __int16 v124 = 2082;
      id v125 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v7, v19, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
LABEL_31:

    free(backtrace_string);
    if (!v6) {
      return 0;
    }
    goto LABEL_51;
  }
  memcpy(__dst, __src, __n);
  if (__dst[0].sa_len > v3)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v9 = (id)gLogObj;
    *(_DWORD *)buf = 136447234;
    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
    __int16 v116 = 1024;
    int v117 = a1;
    __int16 v118 = 1024;
    unsigned int v119 = v3;
    __int16 v120 = 2080;
    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
    __int16 v122 = 1024;
    int v123 = 1874;
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v6, type, &v112)) {
      goto LABEL_50;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      os_log_type_t v10 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        __int16 v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1874;
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
      }
      goto LABEL_49;
    }
    if (v112 == OS_LOG_TYPE_DEFAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v7 = (id)gLogObj;
      os_log_type_t v28 = type[0];
      if (os_log_type_enabled(v7, type[0]))
      {
        *(_DWORD *)buf = 136447234;
        __int16 v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1874;
        _os_log_impl(&dword_1830D4000, v7, v28, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
      }
      goto LABEL_49;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v7 = (id)gLogObj;
    os_log_type_t v21 = type[0];
    BOOL v22 = os_log_type_enabled(v7, type[0]);
    if (!backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136447234;
        __int16 v115 = "nw_path_copy_endpoint_from_tlv";
        __int16 v116 = 1024;
        int v117 = a1;
        __int16 v118 = 1024;
        unsigned int v119 = v3;
        __int16 v120 = 2080;
        os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
        __int16 v122 = 1024;
        int v123 = 1874;
        _os_log_impl(&dword_1830D4000, v7, v21, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
      }
      goto LABEL_49;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136447490;
      __int16 v115 = "nw_path_copy_endpoint_from_tlv";
      __int16 v116 = 1024;
      int v117 = a1;
      __int16 v118 = 1024;
      unsigned int v119 = v3;
      __int16 v120 = 2080;
      os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
      __int16 v122 = 1024;
      int v123 = 1874;
      __int16 v124 = 2082;
      id v125 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v7, v21, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
    }
    goto LABEL_31;
  }
  unsigned int v11 = __dst[0].sa_len - 8;
  if (v3 - 8 >= v11) {
    size_t v12 = v11;
  }
  else {
    size_t v12 = v3 - 8;
  }
  if (!__dst[0].sa_family)
  {
    host_with_numeric_port = 0;
    switch(*(_DWORD *)&__dst[0].sa_data[2])
    {
      case 0:
        return (nw_endpoint_t)host_with_numeric_port;
      case 2:
        size_t v23 = strnlen(&__dst[0].sa_data[6], v12);
        if (v23 >= v12)
        {
          os_log_type_t v54 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1719;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112)) {
            goto LABEL_50;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v55 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1719;
              _os_log_impl(&dword_1830D4000, v7, v55, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            os_log_type_t v69 = (char *)__nw_create_backtrace_string();
            id v7 = __nwlog_obj();
            os_log_type_t v70 = type[0];
            BOOL v71 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v71)
              {
                *(_DWORD *)buf = 136447490;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1719;
                __int16 v124 = 2082;
                id v125 = v69;
                _os_log_impl(&dword_1830D4000, v7, v70, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v71)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1719;
              _os_log_impl(&dword_1830D4000, v7, v70, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            id v7 = __nwlog_obj();
            os_log_type_t v88 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1719;
              _os_log_impl(&dword_1830D4000, v7, v88, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        size_t v24 = v23;
        host_with_numeric_port = (id *)nw_endpoint_create_host_with_numeric_port(&__dst[0].sa_data[6], bswap32(*(unsigned __int16 *)__dst[0].sa_data) >> 16);
        if (host_with_numeric_port)
        {
          size_t v25 = v24 + 1;
          size_t v26 = v12 - (v24 + 1);
          if (v12 > v24 + 1) {
            goto LABEL_80;
          }
        }
        return (nw_endpoint_t)host_with_numeric_port;
      case 3:
        size_t v32 = strnlen(&__dst[0].sa_data[6], v12);
        if (v32 >= v12)
        {
          nw_parameters_t v56 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1735;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112)) {
            goto LABEL_50;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v57 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1735;
              _os_log_impl(&dword_1830D4000, v7, v57, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            os_log_type_t v69 = (char *)__nw_create_backtrace_string();
            id v7 = __nwlog_obj();
            os_log_type_t v72 = type[0];
            BOOL v73 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v73)
              {
                *(_DWORD *)buf = 136447490;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1735;
                __int16 v124 = 2082;
                id v125 = v69;
                _os_log_impl(&dword_1830D4000, v7, v72, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v73)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1735;
              _os_log_impl(&dword_1830D4000, v7, v72, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            id v7 = __nwlog_obj();
            os_log_type_t v89 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1735;
              _os_log_impl(&dword_1830D4000, v7, v89, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        BOOL v33 = &__dst[0].sa_data[v32 + 7];
        size_t v34 = strnlen(v33, v12 - (v32 + 1)) + v32 + 1;
        if (v34 >= v12)
        {
          os_log_type_t v65 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1742;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112)) {
            goto LABEL_50;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v66 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1742;
              _os_log_impl(&dword_1830D4000, v7, v66, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            os_log_type_t v69 = (char *)__nw_create_backtrace_string();
            id v7 = __nwlog_obj();
            os_log_type_t v84 = type[0];
            BOOL v85 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v85)
              {
                *(_DWORD *)buf = 136447490;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1742;
                __int16 v124 = 2082;
                id v125 = v69;
                _os_log_impl(&dword_1830D4000, v7, v84, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v85)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1742;
              _os_log_impl(&dword_1830D4000, v7, v84, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            id v7 = __nwlog_obj();
            os_log_type_t v99 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1742;
              _os_log_impl(&dword_1830D4000, v7, v99, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        os_log_type_t v35 = &__dst[0].sa_data[v34 + 7];
        size_t v36 = strnlen(v35, v12 - (v34 + 1)) + v34 + 1;
        if (v36 >= v12)
        {
          os_log_type_t v80 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1749;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112)) {
            goto LABEL_50;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v81 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1749;
              _os_log_impl(&dword_1830D4000, v7, v81, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            os_log_type_t v69 = (char *)__nw_create_backtrace_string();
            id v7 = __nwlog_obj();
            os_log_type_t v95 = type[0];
            BOOL v96 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v96)
              {
                *(_DWORD *)buf = 136447490;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1749;
                __int16 v124 = 2082;
                id v125 = v69;
                _os_log_impl(&dword_1830D4000, v7, v95, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v96)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1749;
              _os_log_impl(&dword_1830D4000, v7, v95, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            id v7 = __nwlog_obj();
            os_log_type_t v105 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1749;
              _os_log_impl(&dword_1830D4000, v7, v105, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        host_with_numeric_port = (id *)nw_endpoint_create_bonjour_service(&__dst[0].sa_data[6], v33, v35);
        if (host_with_numeric_port)
        {
          size_t v25 = v36 + 1;
          size_t v26 = v12 - (v36 + 1);
          if (v12 > v36 + 1) {
            goto LABEL_80;
          }
        }
        return (nw_endpoint_t)host_with_numeric_port;
      case 4:
        if (strnlen(&__dst[0].sa_data[6], v12) >= v12)
        {
          uint64_t v58 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1726;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112)) {
            goto LABEL_50;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v59 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1726;
              _os_log_impl(&dword_1830D4000, v7, v59, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112)
          {
            os_log_type_t v69 = (char *)__nw_create_backtrace_string();
            id v7 = __nwlog_obj();
            os_log_type_t v74 = type[0];
            BOOL v75 = os_log_type_enabled(v7, type[0]);
            if (v69)
            {
              if (v75)
              {
                *(_DWORD *)buf = 136447490;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1726;
                __int16 v124 = 2082;
                id v125 = v69;
                _os_log_impl(&dword_1830D4000, v7, v74, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
              goto LABEL_185;
            }
            if (v75)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1726;
              _os_log_impl(&dword_1830D4000, v7, v74, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
          }
          else
          {
            id v7 = __nwlog_obj();
            os_log_type_t v90 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1726;
              _os_log_impl(&dword_1830D4000, v7, v90, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
          }
          goto LABEL_49;
        }
        return nw_endpoint_create_url(&__dst[0].sa_data[6]);
      case 5:
        size_t v52 = strnlen(&__dst[0].sa_data[6], v12);
        if (v52 >= v12)
        {
          uint64_t v60 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1846;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v112 = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v6, type, &v112)) {
            goto LABEL_50;
          }
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v61 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1846;
              _os_log_impl(&dword_1830D4000, v7, v61, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v112 == OS_LOG_TYPE_DEFAULT)
          {
            id v7 = __nwlog_obj();
            os_log_type_t v91 = type[0];
            if (os_log_type_enabled(v7, type[0]))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1846;
              _os_log_impl(&dword_1830D4000, v7, v91, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
            goto LABEL_49;
          }
          os_log_type_t v69 = (char *)__nw_create_backtrace_string();
          id v7 = __nwlog_obj();
          os_log_type_t v76 = type[0];
          BOOL v77 = os_log_type_enabled(v7, type[0]);
          if (!v69)
          {
            if (v77)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1846;
              _os_log_impl(&dword_1830D4000, v7, v76, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
            goto LABEL_49;
          }
          if (v77)
          {
            *(_DWORD *)buf = 136447490;
            __int16 v115 = "nw_path_copy_endpoint_from_tlv";
            __int16 v116 = 1024;
            int v117 = a1;
            __int16 v118 = 1024;
            unsigned int v119 = v3;
            __int16 v120 = 2080;
            os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
            __int16 v122 = 1024;
            int v123 = 1846;
            __int16 v124 = 2082;
            id v125 = v69;
            _os_log_impl(&dword_1830D4000, v7, v76, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
          }
LABEL_185:

          goto LABEL_239;
        }
        size_t v53 = v52;
        host_with_numeric_port = (id *)nw_endpoint_create_srv(&__dst[0].sa_data[6]);
        if (host_with_numeric_port)
        {
          size_t v25 = v53 + 1;
          size_t v26 = v12 - (v53 + 1);
          if (v12 > v53 + 1)
          {
LABEL_80:
            nw_txt_record_t v17 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[0].sa_data[v25 + 6], v26);
            nw_endpoint_set_txt_record(host_with_numeric_port, v17);
            goto LABEL_21;
          }
        }
        return (nw_endpoint_t)host_with_numeric_port;
      case 6:
        memset(type, 0, sizeof(type));
        uuid_clear((unsigned __int8 *)type);
        size_t v37 = strnlen(&__dst[0].sa_data[6], v12);
        if (v37 >= v12)
        {
          uint64_t v62 = __nwlog_obj();
          *(_DWORD *)buf = 136447234;
          __int16 v115 = "nw_path_copy_endpoint_from_tlv";
          __int16 v116 = 1024;
          int v117 = a1;
          __int16 v118 = 1024;
          unsigned int v119 = v3;
          __int16 v120 = 2080;
          os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
          __int16 v122 = 1024;
          int v123 = 1771;
          uint64_t v6 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t v112 = OS_LOG_TYPE_ERROR;
          char v111 = 0;
          if (!__nwlog_fault(v6, &v112, &v111)) {
            goto LABEL_50;
          }
          if (v112 == OS_LOG_TYPE_FAULT)
          {
            BOOL v63 = __nwlog_obj();
            os_log_type_t v64 = v112;
            if (os_log_type_enabled(v63, v112))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1771;
              _os_log_impl(&dword_1830D4000, v63, v64, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
            }
            goto LABEL_258;
          }
          if (!v111)
          {
            BOOL v63 = __nwlog_obj();
            os_log_type_t v92 = v112;
            if (os_log_type_enabled(v63, v112))
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1771;
              _os_log_impl(&dword_1830D4000, v63, v92, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
            }
            goto LABEL_258;
          }
          os_log_type_t v69 = (char *)__nw_create_backtrace_string();
          BOOL v63 = __nwlog_obj();
          os_log_type_t v78 = v112;
          BOOL v79 = os_log_type_enabled(v63, v112);
          if (!v69)
          {
            if (v79)
            {
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1771;
              _os_log_impl(&dword_1830D4000, v63, v78, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
            }
            goto LABEL_258;
          }
          if (v79)
          {
            *(_DWORD *)buf = 136447490;
            __int16 v115 = "nw_path_copy_endpoint_from_tlv";
            __int16 v116 = 1024;
            int v117 = a1;
            __int16 v118 = 1024;
            unsigned int v119 = v3;
            __int16 v120 = 2080;
            os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
            __int16 v122 = 1024;
            int v123 = 1771;
            __int16 v124 = 2082;
            id v125 = v69;
            _os_log_impl(&dword_1830D4000, v63, v78, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
          }
        }
        else
        {
          BOOL v38 = &__dst[0].sa_data[v37 + 7];
          size_t v39 = strnlen(v38, v12 - (v37 + 1)) + v37 + 1;
          if (v39 >= v12)
          {
            uint64_t v67 = __nwlog_obj();
            *(_DWORD *)buf = 136447234;
            __int16 v115 = "nw_path_copy_endpoint_from_tlv";
            __int16 v116 = 1024;
            int v117 = a1;
            __int16 v118 = 1024;
            unsigned int v119 = v3;
            __int16 v120 = 2080;
            os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
            __int16 v122 = 1024;
            int v123 = 1778;
            uint64_t v6 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t v112 = OS_LOG_TYPE_ERROR;
            char v111 = 0;
            if (!__nwlog_fault(v6, &v112, &v111)) {
              goto LABEL_50;
            }
            if (v112 == OS_LOG_TYPE_FAULT)
            {
              BOOL v63 = __nwlog_obj();
              os_log_type_t v68 = v112;
              if (os_log_type_enabled(v63, v112))
              {
                *(_DWORD *)buf = 136447234;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1778;
                _os_log_impl(&dword_1830D4000, v63, v68, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
              }
              goto LABEL_258;
            }
            if (!v111)
            {
              BOOL v63 = __nwlog_obj();
              os_log_type_t v100 = v112;
              if (os_log_type_enabled(v63, v112))
              {
                *(_DWORD *)buf = 136447234;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1778;
                _os_log_impl(&dword_1830D4000, v63, v100, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
              }
              goto LABEL_258;
            }
            os_log_type_t v69 = (char *)__nw_create_backtrace_string();
            BOOL v63 = __nwlog_obj();
            os_log_type_t v86 = v112;
            BOOL v87 = os_log_type_enabled(v63, v112);
            if (!v69)
            {
              if (v87)
              {
                *(_DWORD *)buf = 136447234;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1778;
                _os_log_impl(&dword_1830D4000, v63, v86, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
              }
              goto LABEL_258;
            }
            if (v87)
            {
              *(_DWORD *)buf = 136447490;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1778;
              __int16 v124 = 2082;
              id v125 = v69;
              _os_log_impl(&dword_1830D4000, v63, v86, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
            }
          }
          else
          {
            char v40 = &__dst[0].sa_data[v39 + 7];
            size_t v41 = strnlen(v40, v12 - (v39 + 1)) + v39 + 1;
            if (v41 >= v12)
            {
              uint64_t v82 = __nwlog_obj();
              *(_DWORD *)buf = 136447234;
              __int16 v115 = "nw_path_copy_endpoint_from_tlv";
              __int16 v116 = 1024;
              int v117 = a1;
              __int16 v118 = 1024;
              unsigned int v119 = v3;
              __int16 v120 = 2080;
              os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
              __int16 v122 = 1024;
              int v123 = 1785;
              uint64_t v6 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v112 = OS_LOG_TYPE_ERROR;
              char v111 = 0;
              if (!__nwlog_fault(v6, &v112, &v111)) {
                goto LABEL_50;
              }
              if (v112 == OS_LOG_TYPE_FAULT)
              {
                BOOL v63 = __nwlog_obj();
                os_log_type_t v83 = v112;
                if (os_log_type_enabled(v63, v112))
                {
                  *(_DWORD *)buf = 136447234;
                  __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1785;
                  _os_log_impl(&dword_1830D4000, v63, v83, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
                }
                goto LABEL_258;
              }
              if (!v111)
              {
                BOOL v63 = __nwlog_obj();
                os_log_type_t v106 = v112;
                if (os_log_type_enabled(v63, v112))
                {
                  *(_DWORD *)buf = 136447234;
                  __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1785;
                  _os_log_impl(&dword_1830D4000, v63, v106, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
                }
                goto LABEL_258;
              }
              os_log_type_t v69 = (char *)__nw_create_backtrace_string();
              BOOL v63 = __nwlog_obj();
              os_log_type_t v97 = v112;
              BOOL v98 = os_log_type_enabled(v63, v112);
              if (!v69)
              {
                if (v98)
                {
                  *(_DWORD *)buf = 136447234;
                  __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1785;
                  _os_log_impl(&dword_1830D4000, v63, v97, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
                }
                goto LABEL_258;
              }
              if (v98)
              {
                *(_DWORD *)buf = 136447490;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1785;
                __int16 v124 = 2082;
                id v125 = v69;
                _os_log_impl(&dword_1830D4000, v63, v97, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
              }
            }
            else
            {
              uint64_t v42 = &__dst[0].sa_data[v41 + 7];
              size_t v43 = strnlen(v42, v12 - (v41 + 1)) + v41 + 1;
              if (v43 >= v12)
              {
                os_log_type_t v93 = __nwlog_obj();
                *(_DWORD *)buf = 136447234;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1792;
                uint64_t v6 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v112 = OS_LOG_TYPE_ERROR;
                char v111 = 0;
                if (!__nwlog_fault(v6, &v112, &v111)) {
                  goto LABEL_50;
                }
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  BOOL v63 = __nwlog_obj();
                  os_log_type_t v94 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1792;
                    _os_log_impl(&dword_1830D4000, v63, v94, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                if (!v111)
                {
                  BOOL v63 = __nwlog_obj();
                  os_log_type_t v109 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1792;
                    _os_log_impl(&dword_1830D4000, v63, v109, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                os_log_type_t v69 = (char *)__nw_create_backtrace_string();
                BOOL v63 = __nwlog_obj();
                os_log_type_t v103 = v112;
                BOOL v104 = os_log_type_enabled(v63, v112);
                if (!v69)
                {
                  if (v104)
                  {
                    *(_DWORD *)buf = 136447234;
                    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1792;
                    _os_log_impl(&dword_1830D4000, v63, v103, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                if (v104)
                {
                  *(_DWORD *)buf = 136447490;
                  __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1792;
                  __int16 v124 = 2082;
                  id v125 = v69;
                  _os_log_impl(&dword_1830D4000, v63, v103, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
                }
              }
              else
              {
                BOOL v44 = &__dst[0].sa_data[v43 + 7];
                size_t v45 = strnlen(v44, v12 - (v43 + 1)) + v43 + 1;
                if (v45 < v12)
                {
                  int v46 = *(_DWORD *)&__dst[0].sa_data[v45 + 7];
                  int v47 = *(_DWORD *)&__dst[0].sa_data[v45 + 11];
                  size_t v48 = v45 + 9;
                  size_t v49 = v45 + 25;
                  if (v49 <= v12)
                  {
                    *(sockaddr *)os_log_type_t type = *(sockaddr *)&__dst[0].sa_data[v48 + 6];
                    size_t v48 = v49;
                  }
                  host_with_numeric_port = (id *)nw_endpoint_create_application_service_internal(v38, &__dst[0].sa_data[6], (const unsigned __int8 *)type, v40, v42, v46, v47, v44);
                  if (host_with_numeric_port) {
                    BOOL v50 = v48 + 1 >= v12;
                  }
                  else {
                    BOOL v50 = 1;
                  }
                  if (!v50)
                  {
                    nw_txt_record_t v51 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[0].sa_data[v48 + 6], v12 - v48);
                    nw_endpoint_set_txt_record(host_with_numeric_port, v51);
                  }
                  return (nw_endpoint_t)host_with_numeric_port;
                }
                id v101 = __nwlog_obj();
                *(_DWORD *)buf = 136447234;
                __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                __int16 v116 = 1024;
                int v117 = a1;
                __int16 v118 = 1024;
                unsigned int v119 = v3;
                __int16 v120 = 2080;
                os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                __int16 v122 = 1024;
                int v123 = 1799;
                uint64_t v6 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v112 = OS_LOG_TYPE_ERROR;
                char v111 = 0;
                if (!__nwlog_fault(v6, &v112, &v111)) {
                  goto LABEL_50;
                }
                if (v112 == OS_LOG_TYPE_FAULT)
                {
                  BOOL v63 = __nwlog_obj();
                  os_log_type_t v102 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1799;
                    _os_log_impl(&dword_1830D4000, v63, v102, "%{public}s TLV of type %d has invalid length %u (%s:%d)", buf, 0x28u);
                  }
LABEL_258:

                  goto LABEL_50;
                }
                if (!v111)
                {
                  BOOL v63 = __nwlog_obj();
                  os_log_type_t v110 = v112;
                  if (os_log_type_enabled(v63, v112))
                  {
                    *(_DWORD *)buf = 136447234;
                    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1799;
                    _os_log_impl(&dword_1830D4000, v63, v110, "%{public}s TLV of type %d has invalid length %u (%s:%d), backtrace limit exceeded", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                os_log_type_t v69 = (char *)__nw_create_backtrace_string();
                BOOL v63 = __nwlog_obj();
                os_log_type_t v107 = v112;
                BOOL v108 = os_log_type_enabled(v63, v112);
                if (!v69)
                {
                  if (v108)
                  {
                    *(_DWORD *)buf = 136447234;
                    __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v116 = 1024;
                    int v117 = a1;
                    __int16 v118 = 1024;
                    unsigned int v119 = v3;
                    __int16 v120 = 2080;
                    os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                    __int16 v122 = 1024;
                    int v123 = 1799;
                    _os_log_impl(&dword_1830D4000, v63, v107, "%{public}s TLV of type %d has invalid length %u (%s:%d), no backtrace", buf, 0x28u);
                  }
                  goto LABEL_258;
                }
                if (v108)
                {
                  *(_DWORD *)buf = 136447490;
                  __int16 v115 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v116 = 1024;
                  int v117 = a1;
                  __int16 v118 = 1024;
                  unsigned int v119 = v3;
                  __int16 v120 = 2080;
                  os_log_type_t v121 = "nw_path_copy_endpoint_from_tlv";
                  __int16 v122 = 1024;
                  int v123 = 1799;
                  __int16 v124 = 2082;
                  id v125 = v69;
                  _os_log_impl(&dword_1830D4000, v63, v107, "%{public}s TLV of type %d has invalid length %u (%s:%d), dumping backtrace:%{public}s", buf, 0x32u);
                }
              }
            }
          }
        }

LABEL_239:
        free(v69);
        if (!v6) {
          return 0;
        }
        goto LABEL_51;
      default:
        if (!v12) {
          return 0;
        }
        dispatch_data_t v30 = dispatch_data_create(&__dst[0].sa_data[6], v12, 0, 0);
        if (!v30) {
          return 0;
        }
        dispatch_data_t v31 = v30;
        host_with_numeric_port = (id *)nw_endpoint_create_custom(*(unsigned int *)&__dst[0].sa_data[2], v30, 0);

        return (nw_endpoint_t)host_with_numeric_port;
    }
  }
  address = nw_endpoint_create_address(__dst);
  host_with_numeric_port = (id *)&address->isa;
  if (address)
  {
    uint64_t v15 = nw_endpoint_get_address(address);
    if (v3 >= 0x1D)
    {
      if (v15)
      {
        nw_txt_record_t v16 = nw_txt_record_create_with_bytes((const uint8_t *)&__dst[1].sa_data[10], v3 - 28);
        host_with_numeric_port = host_with_numeric_port;
        nw_txt_record_t v17 = v16;
        objc_storeStrong(host_with_numeric_port + 23, v16);

LABEL_21:
      }
    }
  }
  return (nw_endpoint_t)host_with_numeric_port;
}

void sub_18318F35C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_endpoint_create_address(const sockaddr *address)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  if (address)
  {
    id v1 = -[NWConcrete_nw_address_endpoint initWithAddress:overridePort:]([NWConcrete_nw_address_endpoint alloc], &address->sa_len, 0);
    uint64_t v2 = v1;
    if (v1)
    {
      unsigned int v3 = v1;
LABEL_11:

      return v2;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v4 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    size_t v24 = "nw_endpoint_create_address";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v5, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v24 = "nw_endpoint_create_address";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s NWOSAddressEndpoint alloc/init failed", buf, 0xCu);
        }
      }
      else if (v21)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            size_t v24 = "nw_endpoint_create_address";
            __int16 v25 = 2082;
            size_t v26 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s NWOSAddressEndpoint alloc/init failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          if (!v5) {
            goto LABEL_11;
          }
          goto LABEL_10;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          size_t v24 = "nw_endpoint_create_address";
          _os_log_impl(&dword_1830D4000, v6, v10, "%{public}s NWOSAddressEndpoint alloc/init failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v6 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v24 = "nw_endpoint_create_address";
          _os_log_impl(&dword_1830D4000, v6, v12, "%{public}s NWOSAddressEndpoint alloc/init failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v5) {
      goto LABEL_11;
    }
LABEL_10:
    free(v5);
    goto LABEL_11;
  }
  os_log_type_t v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  size_t v24 = "nw_endpoint_create_address";
  char v14 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v21 = 0;
  if (__nwlog_fault(v14, &type, &v21))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v24 = "nw_endpoint_create_address";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null address", buf, 0xCu);
      }
    }
    else if (v21)
    {
      nw_txt_record_t v17 = (char *)__nw_create_backtrace_string();
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v15, type);
      if (v17)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446466;
          size_t v24 = "nw_endpoint_create_address";
          __int16 v25 = 2082;
          size_t v26 = v17;
          _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null address, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v17);
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        size_t v24 = "nw_endpoint_create_address";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null address, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v24 = "nw_endpoint_create_address";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null address, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_41:
  if (v14) {
    free(v14);
  }
  return 0;
}

uint64_t ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke_25(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = *(void *)nw_hash_node_get_extra(a2);
  uint64_t object = nw_hash_node_get_object(a2);
  if ((*(unsigned char *)(v4 + 36) & 1) == 0 || !*(void *)v4) {
    return 1;
  }
  uint64_t v6 = object;
  if (gLogDatapath)
  {
    BOOL v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      uint64_t v12 = *(void *)(a1 + 32);
      os_log_type_t v13 = (const char *)(v12 + 205);
      BOOL v14 = v12 == 0;
      int v15 = *(_DWORD *)(v4 + 32);
      if (v14) {
        os_log_type_t v13 = "";
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      dispatch_data_t v31 = v13;
      __int16 v32 = 1024;
      LODWORD(v33) = v15;
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s calling input_available on stream %d", buf, 0x1Cu);
    }
  }
  if (v6)
  {
    uint64_t v7 = *(void *)(v6 + 24);
    if (v7)
    {
      os_log_type_t v8 = *(void (**)(uint64_t, void))(v7 + 64);
      if (v8)
      {
        v8(v6, *(void *)(a1 + 32));
        return 1;
      }
    }
    __nwlog_obj();
    os_log_type_t v10 = *(const char **)(v6 + 16);
    if (!v10) {
      os_log_type_t v10 = "invalid";
    }
  }
  else
  {
    __nwlog_obj();
    os_log_type_t v10 = "invalid";
  }
  *(_DWORD *)buf = 136446466;
  os_log_type_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
  __int16 v30 = 2082;
  dispatch_data_t v31 = v10;
  os_log_type_t v16 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v16, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_txt_record_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_43;
      }
      BOOL v19 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        BOOL v19 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      dispatch_data_t v31 = v19;
      os_log_type_t v20 = "%{public}s protocol %{public}s has invalid input_available callback";
      goto LABEL_42;
    }
    if (!v26)
    {
      nw_txt_record_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (!os_log_type_enabled(v17, type)) {
        goto LABEL_43;
      }
      size_t v24 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        size_t v24 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      dispatch_data_t v31 = v24;
      os_log_type_t v20 = "%{public}s protocol %{public}s has invalid input_available callback, backtrace limit exceeded";
      goto LABEL_42;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_txt_record_t v17 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v22 = os_log_type_enabled(v17, type);
    if (backtrace_string)
    {
      if (v22)
      {
        size_t v23 = "invalid";
        if (v6 && *(void *)(v6 + 16)) {
          size_t v23 = *(const char **)(v6 + 16);
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
        __int16 v30 = 2082;
        dispatch_data_t v31 = v23;
        __int16 v32 = 2082;
        BOOL v33 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s protocol %{public}s has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_43;
    }
    if (v22)
    {
      __int16 v25 = "invalid";
      if (v6 && *(void *)(v6 + 16)) {
        __int16 v25 = *(const char **)(v6 + 16);
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_http2_transport_process_input_block_invoke";
      __int16 v30 = 2082;
      dispatch_data_t v31 = v25;
      os_log_type_t v20 = "%{public}s protocol %{public}s has invalid input_available callback, no backtrace";
LABEL_42:
      _os_log_impl(&dword_1830D4000, v17, v18, v20, buf, 0x16u);
    }
  }
LABEL_43:
  if (v16) {
    free(v16);
  }
  return 1;
}

uint64_t __nw_association_is_empty_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = nw_hash_node_get_object(a2);
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (*(void *)(a1 + 48) <= *(void *)(extra + 32)) {
    goto LABEL_17;
  }
  uint64_t v6 = (uint64_t *)extra;
  uint64_t v7 = *(void *)(extra + 40);
  if (v7) {
    nw_protocol_definition_deallocate_cache_entry(v4, v7);
  }
  nw_context_remove_cache_entry(*(void **)(a1 + 32), v6);
  if (nw_hash_table_remove_node(*(void *)(*(void *)(a1 + 40) + 56), a2)
    || nw_path_parameters_get_logging_disabled(*(void *)(*(void *)(a1 + 40) + 16)))
  {
    goto LABEL_17;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  id v8 = (id)gconnectionLogObj;
  logging_description = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8));
  *(_DWORD *)buf = 136446722;
  uint64_t v27 = "nw_association_is_empty_block_invoke";
  __int16 v28 = 2082;
  os_log_type_t v29 = logging_description;
  __int16 v30 = 2048;
  uint64_t v31 = a2;
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v24 = 0;
  if (__nwlog_fault(v10, &type, &v24))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        os_log_type_t v13 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        uint64_t v27 = "nw_association_is_empty_block_invoke";
        __int16 v28 = 2082;
        os_log_type_t v29 = v13;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p", buf, 0x20u);
      }
    }
    else if (v24)
    {
      backtrace_string = __nw_create_backtrace_string();
      if (backtrace_string)
      {
        os_log_type_t v16 = (char *)backtrace_string;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        nw_txt_record_t v17 = (id)gconnectionLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v17, type))
        {
          BOOL v19 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8));
          *(_DWORD *)buf = 136446978;
          uint64_t v27 = "nw_association_is_empty_block_invoke";
          __int16 v28 = 2082;
          os_log_type_t v29 = v19;
          __int16 v30 = 2048;
          uint64_t v31 = a2;
          __int16 v32 = 2082;
          BOOL v33 = v16;
          _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v16);
        if (v10) {
          goto LABEL_16;
        }
        goto LABEL_17;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        size_t v23 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        uint64_t v27 = "nw_association_is_empty_block_invoke";
        __int16 v28 = 2082;
        os_log_type_t v29 = v23;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        char v21 = nw_endpoint_get_logging_description(*(void **)(*(void *)(a1 + 40) + 8));
        *(_DWORD *)buf = 136446722;
        uint64_t v27 = "nw_association_is_empty_block_invoke";
        __int16 v28 = 2082;
        os_log_type_t v29 = v21;
        __int16 v30 = 2048;
        uint64_t v31 = a2;
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s <nw_association %{public}s> failed to remove cache entry for node %p, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
  if (v10) {
LABEL_16:
  }
    free(v10);
LABEL_17:

  return 1;
}

void sub_183191138(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL27nw_association_update_pathsP25NWConcrete_nw_associationPU21objcproto10OS_nw_path8NSObject_block_invoke_2(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = nw_hash_node_get_object(a2);
  uint64_t extra = nw_hash_node_get_extra(a2);
  if (!*(unsigned char *)(a1 + 40) || (*(unsigned char *)(extra + 8) & 1) == 0)
  {
    uint64_t v6 = (void (**)(void *, void *, void))_Block_copy(*(const void **)extra);
    v6[2](v6, v4, *(void *)(a1 + 32));
  }
  return 1;
}

void sub_1831911F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_channel_add_input_frames(uint64_t a1, uint64_t a2)
{
  v253[33] = *MEMORY[0x1E4F143B8];
  if (!*(void *)(a1 + 136) || (uint64_t v2 = a1, !*(void *)(a1 + 224)) || !os_channel_available_slot_count())
  {
    char v158 = 0;
    return v158 & 1;
  }
  memset(v253, 0, 256);
  long long v244 = 0u;
  long long v245 = 0u;
  long long v242 = 0u;
  long long v243 = 0u;
  uint64_t v3 = *(void *)(v2 + 288);
  uint64_t next_slot = os_channel_get_next_slot();
  id v5 = (unsigned __int16 *)(v2 + 444);
  uint64_t v239 = v2;
  if (!next_slot)
  {
    BOOL v160 = 0;
    char v158 = 0;
    int v161 = *v5 | (*(unsigned __int8 *)(v2 + 446) << 16) | 0x8000;
    int v162 = 1;
    goto LABEL_361;
  }
  int v6 = 0;
  unint64_t v7 = 0;
  uint64_t v8 = 0;
  uint64_t v230 = (unsigned __int16 *)(v2 + 444);
  while (1)
  {
    uint64_t v9 = next_slot;
    if (!v3)
    {
      nw_channel_allocate_frames((void *)v2);
      uint64_t v3 = *(void *)(v2 + 288);
      if (!v3) {
        goto LABEL_271;
      }
    }
    uint64_t packet = os_channel_slot_get_packet();
    uint64_t v237 = v3;
    if (!packet)
    {
      if (nw_channel_check_defunct(v2)) {
        goto LABEL_384;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v248 = "nw_channel_add_input_frames";
      __int16 v124 = (char *)_os_log_send_and_compose_impl();
      v251[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v124, v251, type))
      {
        if (v251[0] == OS_LOG_TYPE_FAULT)
        {
          id v125 = __nwlog_obj();
          os_log_type_t v126 = v251[0];
          if (!os_log_type_enabled(v125, v251[0])) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          uint64_t v127 = v125;
          os_log_type_t v128 = v126;
          char v129 = "%{public}s failed to get packet from channel";
          goto LABEL_263;
        }
        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          v152 = __nwlog_obj();
          os_log_type_t v153 = v251[0];
          if (!os_log_type_enabled(v152, v251[0])) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          uint64_t v127 = v152;
          os_log_type_t v128 = v153;
          char v129 = "%{public}s failed to get packet from channel, backtrace limit exceeded";
          goto LABEL_263;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v141 = __nwlog_obj();
        os_log_type_t v142 = v251[0];
        BOOL v143 = os_log_type_enabled(v141, v251[0]);
        if (!backtrace_string)
        {
          if (!v143) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          uint64_t v127 = v141;
          os_log_type_t v128 = v142;
          char v129 = "%{public}s failed to get packet from channel, no backtrace";
          goto LABEL_263;
        }
        if (v143)
        {
          *(_DWORD *)buf = 136446466;
          v248 = "nw_channel_add_input_frames";
          __int16 v249 = 2082;
          *(void *)v250 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v141, v142, "%{public}s failed to get packet from channel, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
      }
LABEL_264:
      if (!v124)
      {
LABEL_266:
        uint64_t v3 = v237;
        uint64_t v2 = v239;
        goto LABEL_189;
      }
LABEL_265:
      free(v124);
      goto LABEL_266;
    }
    uint64_t v11 = packet;
    if (os_packet_get_trace_id()) {
      os_packet_trace_event();
    }
    if ((*v5 & 0x1000) != 0 && os_channel_slot_detach_packet())
    {
      if (nw_channel_check_defunct(v2)) {
        goto LABEL_384;
      }
      __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      v248 = "nw_channel_add_input_frames";
      __int16 v124 = (char *)_os_log_send_and_compose_impl();
      v251[0] = OS_LOG_TYPE_ERROR;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (__nwlog_fault(v124, v251, type))
      {
        if (v251[0] == OS_LOG_TYPE_FAULT)
        {
          v138 = __nwlog_obj();
          os_log_type_t v139 = v251[0];
          if (!os_log_type_enabled(v138, v251[0])) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          uint64_t v127 = v138;
          os_log_type_t v128 = v139;
          char v129 = "%{public}s failed to detach packet";
          goto LABEL_263;
        }
        if (type[0] == OS_LOG_TYPE_DEFAULT)
        {
          id v156 = __nwlog_obj();
          os_log_type_t v157 = v251[0];
          if (!os_log_type_enabled(v156, v251[0])) {
            goto LABEL_264;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          uint64_t v127 = v156;
          os_log_type_t v128 = v157;
          char v129 = "%{public}s failed to detach packet, backtrace limit exceeded";
          goto LABEL_263;
        }
        v148 = (char *)__nw_create_backtrace_string();
        uint64_t v149 = __nwlog_obj();
        os_log_type_t v150 = v251[0];
        BOOL v151 = os_log_type_enabled(v149, v251[0]);
        if (v148)
        {
          if (v151)
          {
            *(_DWORD *)buf = 136446466;
            v248 = "nw_channel_add_input_frames";
            __int16 v249 = 2082;
            *(void *)v250 = v148;
            _os_log_impl(&dword_1830D4000, v149, v150, "%{public}s failed to detach packet, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v148);
          if (!v124) {
            goto LABEL_266;
          }
          goto LABEL_265;
        }
        if (v151)
        {
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          uint64_t v127 = v149;
          os_log_type_t v128 = v150;
          char v129 = "%{public}s failed to detach packet, no backtrace";
LABEL_263:
          _os_log_impl(&dword_1830D4000, v127, v128, v129, buf, 0xCu);
          goto LABEL_264;
        }
      }
      goto LABEL_264;
    }
    if (!os_packet_get_data_length())
    {
      if ((nw_channel_check_defunct(v2) & 1) == 0)
      {
        __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        v248 = "nw_channel_add_input_frames";
        os_log_type_t v130 = (char *)_os_log_send_and_compose_impl();
        v251[0] = OS_LOG_TYPE_ERROR;
        type[0] = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v130, v251, type)) {
          goto LABEL_252;
        }
        if (v251[0] == OS_LOG_TYPE_FAULT)
        {
          id v131 = __nwlog_obj();
          os_log_type_t v132 = v251[0];
          if (!os_log_type_enabled(v131, v251[0])) {
            goto LABEL_252;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          int v133 = v131;
          os_log_type_t v134 = v132;
          __int16 v135 = "%{public}s zero length packet";
        }
        else if (type[0])
        {
          uint64_t v144 = (char *)__nw_create_backtrace_string();
          uint64_t v145 = __nwlog_obj();
          os_log_type_t v146 = v251[0];
          BOOL v147 = os_log_type_enabled(v145, v251[0]);
          if (v144)
          {
            if (v147)
            {
              *(_DWORD *)buf = 136446466;
              v248 = "nw_channel_add_input_frames";
              __int16 v249 = 2082;
              *(void *)v250 = v144;
              _os_log_impl(&dword_1830D4000, v145, v146, "%{public}s zero length packet, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v144);
            id v5 = v230;
LABEL_252:
            if (v130) {
              free(v130);
            }
            uint64_t v2 = v239;
            if ((*v5 & 0x1000) != 0)
            {
              uint64_t v3 = v237;
              if (*(void *)(v239 + 136) && os_channel_packet_free()) {
                goto LABEL_386;
              }
            }
            else
            {
              uint64_t v3 = v237;
            }
            goto LABEL_189;
          }
          id v5 = v230;
          if (!v147) {
            goto LABEL_252;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          int v133 = v145;
          os_log_type_t v134 = v146;
          __int16 v135 = "%{public}s zero length packet, no backtrace";
        }
        else
        {
          uint64_t v154 = __nwlog_obj();
          os_log_type_t v155 = v251[0];
          if (!os_log_type_enabled(v154, v251[0])) {
            goto LABEL_252;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          int v133 = v154;
          os_log_type_t v134 = v155;
          __int16 v135 = "%{public}s zero length packet, backtrace limit exceeded";
        }
        _os_log_impl(&dword_1830D4000, v133, v134, v135, buf, 0xCu);
        goto LABEL_252;
      }
LABEL_384:
      uint64_t v9 = v8;
      uint64_t v2 = v239;
      goto LABEL_272;
    }
    *(void *)v251 = 0;
    uint64_t v252 = 0;
    os_packet_get_flow_uuid();
    if (((*v5 & 0x100) == 0
       || (uint64_t v12 = *(void *)(v2 + 280)) == 0
       || (uint64_t node = nw_hash_table_get_node(v12, (uint64_t)v251, 16)) == 0)
      && ((uint64_t v14 = *(void *)(v2 + 272)) == 0 || (node = *(void *)(v14 + 56)) == 0)
      || (uint64_t v15 = *(void *)(node + 16)) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      nw_txt_record_t v17 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446722;
        v248 = "nw_channel_add_input_frames";
        __int16 v249 = 1042;
        *(_DWORD *)v250 = 16;
        *(_WORD *)&v250[4] = 2098;
        *(void *)&v250[6] = v251;
        _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s Failed to find client for slot (%{public,uuid_t}.16P)", buf, 0x1Cu);
      }
      if ((*v5 & 0x1000) == 0)
      {
        uint64_t v18 = v3;
        uint64_t v2 = v239;
        goto LABEL_188;
      }
      uint64_t v2 = v239;
      if (!*(void *)(v239 + 136) || !os_channel_packet_free())
      {
        uint64_t v18 = v3;
        goto LABEL_188;
      }
      goto LABEL_386;
    }
    uint64_t v16 = *(void *)(v15 + 56);
    unint64_t v229 = v7;
    uint64_t v227 = *(void *)(node + 16);
    if (v16) {
      int v236 = (*(unsigned __int8 *)(v16 + 153) >> 2) & 1;
    }
    else {
      int v236 = 0;
    }
    int v19 = *(_WORD *)(v3 + 204) & 0xFF7F | (*(unsigned __int8 *)(v3 + 206) << 16);
    *(_WORD *)(v3 + 204) &= ~0x80u;
    *(unsigned char *)(v3 + 206) = BYTE2(v19);
    int buflet_count = os_packet_get_buflet_count();
    if (!buflet_count)
    {
      uint64_t v58 = v227;
      if ((*(_WORD *)(v3 + 204) & 0x80) != 0)
      {
        uint64_t v228 = v9;
        LOWORD(v9) = 0;
        uint64_t v18 = v3;
LABEL_94:
        *(_WORD *)(v3 + 196) = v9;
        uint64_t v9 = v228;
      }
      else
      {
        uint64_t v18 = v3;
      }
      goto LABEL_180;
    }
    uint64_t v225 = v8;
    uint64_t v228 = v9;
    int v20 = 0;
    LODWORD(v9) = 0;
    uint64_t v18 = v3;
LABEL_34:
    uint64_t next_buflet = os_packet_get_next_buflet();
    *(_DWORD *)v231 = v6;
    if (!next_buflet)
    {
      os_log_type_t v112 = __nwlog_obj();
      if (os_log_type_enabled(v112, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)buf = 136446210;
        v248 = "nw_channel_add_input_frames";
        _os_log_impl(&dword_1830D4000, v112, OS_LOG_TYPE_ERROR, "%{public}s os_packet_get_next_buflet() returns NULL", buf, 0xCu);
      }
      uint64_t v28 = v18;
      uint64_t v9 = v228;
      unint64_t v7 = v229;
      uint64_t v8 = v225;
      goto LABEL_101;
    }
    uint64_t v25 = next_buflet;
    unsigned int data_offset = os_buflet_get_data_offset();
    uint64_t object_address = os_buflet_get_object_address();
    uint64_t v28 = v18;
    if (!v18)
    {
      nw_channel_allocate_frames((void *)v239);
      uint64_t v28 = *(void *)(v239 + 288);
      if (!v28)
      {
        uint64_t v2 = v239;
        uint64_t v59 = *(void *)(v239 + 152);
        if (!v59 || *(_DWORD *)(v59 + 124) != 4)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v60 = gLogObj;
          uint64_t v9 = v228;
          unint64_t v7 = v229;
          uint64_t v3 = v237;
          uint64_t v8 = v225;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO))
          {
            *(_DWORD *)buf = 136446210;
            v248 = "nw_channel_add_input_frames";
            _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_INFO, "%{public}s nw_channel_allocate_frames() is out of frames", buf, 0xCu);
          }
          uint64_t v28 = 0;
          goto LABEL_101;
        }
        uint64_t v28 = 0;
        uint64_t v9 = v228;
        unint64_t v7 = v229;
        uint64_t v3 = v237;
        uint64_t v8 = v225;
        goto LABEL_102;
      }
    }
    uint64_t v29 = node;
    data_size_t length = os_buflet_get_data_length();
    uint64_t v31 = object_address + data_offset;
    uint64_t v2 = v239;
    nw_frame_reset(v28, v31, data_length, (uint64_t)nw_channel_finalize_input_frame, v239);
    if (v236) {
      nw_frame_set_metadata(v28, 0, 1, 1);
    }
    if ((*(_WORD *)(v28 + 204) & 4) != 0)
    {
      *(void *)(v28 + 208) = v11;
      *(void *)(v28 + 216) = v25;
      *(unsigned char *)(v28 + 232) = *(unsigned char *)(v28 + 232) & 0xFE | ((*v230 & 0x400) != 0);
    }
    int v32 = os_packet_increment_use_count();
    if (v32) {
      break;
    }
    int v33 = *(unsigned __int16 *)(v28 + 204);
    int v34 = *(unsigned __int8 *)(v28 + 206);
    *(_WORD *)(v28 + 204) = v33 | 0x2000;
    if (v20)
    {
      int v35 = v33 | (v34 << 16);
      *(unsigned char *)(v28 + 206) = BYTE2(v35);
      *(_WORD *)(v28 + 204) = v35 | 0x2040;
      uint64_t v3 = v237;
      goto LABEL_82;
    }
    uint64_t v3 = v237;
    if ((*v230 & 0x400) != 0 && os_packet_get_aggregation_type() == 2)
    {
      *(_WORD *)(v237 + 204) |= 0x80u;
      int segment_count = os_packet_get_segment_count();
      if (segment_count)
      {
        if ((*(_WORD *)(v237 + 204) & 0x40) == 0)
        {
          *(unsigned char *)(v237 + 200) = segment_count;
          goto LABEL_80;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v248 = "__nw_frame_set_segment_count";
        size_t v37 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v246 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v37, type, &v246)) {
          goto LABEL_77;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v43 = gLogObj;
          os_log_type_t v44 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v248 = "__nw_frame_set_segment_count";
            char v40 = v43;
            os_log_type_t v41 = v44;
            uint64_t v42 = "%{public}s Attempt to set segment-count on a chain-member";
            goto LABEL_76;
          }
LABEL_77:
          if (v37) {
LABEL_78:
          }
            free(v37);
LABEL_79:
          uint64_t v3 = v237;
          uint64_t v2 = v239;
          goto LABEL_80;
        }
        if (v246)
        {
          size_t v48 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          size_t v49 = gLogObj;
          os_log_type_t v233 = type[0];
          BOOL v50 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v48)
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446466;
              v248 = "__nw_frame_set_segment_count";
              __int16 v249 = 2082;
              *(void *)v250 = v48;
              _os_log_impl(&dword_1830D4000, v49, v233, "%{public}s Attempt to set segment-count on a chain-member, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v48);
            if (v37) {
              goto LABEL_78;
            }
            goto LABEL_79;
          }
          if (!v50) {
            goto LABEL_77;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "__nw_frame_set_segment_count";
          char v40 = v49;
          os_log_type_t v41 = v233;
          uint64_t v42 = "%{public}s Attempt to set segment-count on a chain-member, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v53 = gLogObj;
          os_log_type_t v54 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_77;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "__nw_frame_set_segment_count";
          char v40 = v53;
          os_log_type_t v41 = v54;
          uint64_t v42 = "%{public}s Attempt to set segment-count on a chain-member, backtrace limit exceeded";
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)buf = 136446210;
        v248 = "nw_channel_add_input_frames";
        size_t v37 = (char *)_os_log_send_and_compose_impl();
        type[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v246 = OS_LOG_TYPE_DEFAULT;
        if (!__nwlog_fault(v37, type, &v246)) {
          goto LABEL_77;
        }
        if (type[0] == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v38 = gLogObj;
          os_log_type_t v39 = type[0];
          if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
          {
            *(_DWORD *)buf = 136446210;
            v248 = "nw_channel_add_input_frames";
            char v40 = v38;
            os_log_type_t v41 = v39;
            uint64_t v42 = "%{public}s No segment-count set on single-IP aggregate";
            goto LABEL_76;
          }
          goto LABEL_77;
        }
        if (v246)
        {
          size_t v45 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          int v46 = gLogObj;
          os_log_type_t v232 = type[0];
          BOOL v47 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v45)
          {
            if (v47)
            {
              *(_DWORD *)buf = 136446466;
              v248 = "nw_channel_add_input_frames";
              __int16 v249 = 2082;
              *(void *)v250 = v45;
              _os_log_impl(&dword_1830D4000, v46, v232, "%{public}s No segment-count set on single-IP aggregate, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v45);
            goto LABEL_77;
          }
          if (!v47) {
            goto LABEL_77;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          char v40 = v46;
          os_log_type_t v41 = v232;
          uint64_t v42 = "%{public}s No segment-count set on single-IP aggregate, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v51 = gLogObj;
          os_log_type_t v52 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_77;
          }
          *(_DWORD *)buf = 136446210;
          v248 = "nw_channel_add_input_frames";
          char v40 = v51;
          os_log_type_t v41 = v52;
          uint64_t v42 = "%{public}s No segment-count set on single-IP aggregate, backtrace limit exceeded";
        }
      }
LABEL_76:
      _os_log_impl(&dword_1830D4000, v40, v41, v42, buf, 0xCu);
      goto LABEL_77;
    }
LABEL_80:
    if (os_packet_get_wake_flag()) {
      *(_WORD *)(v3 + 204) |= 0x4000u;
    }
LABEL_82:
    uint64_t v56 = *(void *)(v28 + 16);
    os_log_type_t v57 = *(void **)(v28 + 24);
    os_log_type_t v55 = (void *)(v28 + 16);
    if (*(_OWORD *)(v28 + 16) == 0)
    {
      os_log_type_t v57 = 0;
      uint64_t v18 = 0;
    }
    else
    {
      uint64_t v18 = *(void *)(v28 + 16);
    }
    if (v56)
    {
      *(void *)(v56 + 24) = v57;
      os_log_type_t v57 = *(void **)(v28 + 24);
    }
    else
    {
      *(void *)(v2 + 296) = v57;
    }
    LODWORD(v9) = data_length + v9;
    *os_log_type_t v57 = v56;
    *os_log_type_t v55 = 0;
    *(void *)(v28 + 24) = 0;
    char v21 = *(uint64_t **)(v2 + 328);
    *(void *)(v28 + 24) = v21;
    *char v21 = v28;
    *(void *)(v2 + 328) = v55;
    ++*(_DWORD *)(v2 + 416);
    uint64_t node = v29;
    uint64_t extra = nw_hash_node_get_extra(v29);
    *(void *)(v28 + 32) = 0;
    size_t v23 = *(uint64_t **)(extra + 8);
    *(void *)(v28 + 40) = v23;
    uint64_t *v23 = v28;
    *(void *)(extra + 8) = v28 + 32;
    ++v20;
    int v6 = 1;
    if (buflet_count != v20) {
      goto LABEL_34;
    }
    if ((*(_WORD *)(v3 + 204) & 0x80) == 0)
    {
      unint64_t v7 = v229;
      id v5 = v230;
      uint64_t v58 = v227;
      uint64_t v9 = v228;
      goto LABEL_180;
    }
    unint64_t v7 = v229;
    if (!WORD1(v9))
    {
      id v5 = v230;
      uint64_t v58 = v227;
      goto LABEL_94;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    v248 = "nw_channel_add_input_frames";
    __int16 v249 = 1024;
    *(_DWORD *)v250 = v9;
    os_log_type_t v84 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v246 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v84, type, &v246))
    {
      if (type[0] != OS_LOG_TYPE_FAULT)
      {
        if (v246)
        {
          id v101 = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v102 = gLogObj;
          os_log_type_t v103 = type[0];
          BOOL v104 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
          if (v101)
          {
            if (v104)
            {
              *(_DWORD *)buf = 136446722;
              v248 = "nw_channel_add_input_frames";
              __int16 v249 = 1024;
              *(_DWORD *)v250 = v9;
              *(_WORD *)&v250[4] = 2082;
              *(void *)&v250[6] = v101;
              _os_log_impl(&dword_1830D4000, v102, v103, "%{public}s Chained packet-length is too big: %u, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v101);
            goto LABEL_177;
          }
          if (!v104) {
            goto LABEL_177;
          }
          *(_DWORD *)buf = 136446466;
          v248 = "nw_channel_add_input_frames";
          __int16 v249 = 1024;
          *(_DWORD *)v250 = v9;
          BOOL v87 = v102;
          os_log_type_t v88 = v103;
          os_log_type_t v89 = "%{public}s Chained packet-length is too big: %u, no backtrace";
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v107 = gLogObj;
          os_log_type_t v108 = type[0];
          if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
            goto LABEL_177;
          }
          *(_DWORD *)buf = 136446466;
          v248 = "nw_channel_add_input_frames";
          __int16 v249 = 1024;
          *(_DWORD *)v250 = v9;
          BOOL v87 = v107;
          os_log_type_t v88 = v108;
          os_log_type_t v89 = "%{public}s Chained packet-length is too big: %u, backtrace limit exceeded";
        }
LABEL_176:
        _os_log_impl(&dword_1830D4000, v87, v88, v89, buf, 0x12u);
        goto LABEL_177;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v85 = gLogObj;
      os_log_type_t v86 = type[0];
      if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        v248 = "nw_channel_add_input_frames";
        __int16 v249 = 1024;
        *(_DWORD *)v250 = v9;
        BOOL v87 = v85;
        os_log_type_t v88 = v86;
        os_log_type_t v89 = "%{public}s Chained packet-length is too big: %u";
        goto LABEL_176;
      }
    }
LABEL_177:
    if (v84) {
      free(v84);
    }
    id v5 = v230;
    uint64_t v58 = v227;
    uint64_t v9 = v228;
    uint64_t v2 = v239;
LABEL_180:
    if (v58 != a2)
    {
      if (v7)
      {
        os_log_type_t v109 = v253;
        unint64_t v110 = v7;
        while (*v109 != v58)
        {
          ++v109;
          if (!--v110)
          {
            unint64_t v111 = v7;
            goto LABEL_187;
          }
        }
      }
      else
      {
        unint64_t v111 = 0;
LABEL_187:
        v253[v111] = v58;
        ++v7;
      }
    }
LABEL_188:
    uint64_t v3 = v18;
LABEL_189:
    uint64_t next_slot = os_channel_get_next_slot();
    if (next_slot)
    {
      uint64_t v8 = v9;
      if (v7 < 0x20) {
        continue;
      }
    }
    goto LABEL_272;
  }
  int v113 = v32;
  __nwlog_obj();
  *(_DWORD *)buf = 136446466;
  v248 = "nw_channel_add_input_frames";
  __int16 v249 = 1024;
  *(_DWORD *)v250 = v113;
  BOOL v114 = (char *)_os_log_send_and_compose_impl();
  type[0] = OS_LOG_TYPE_ERROR;
  os_log_type_t v246 = OS_LOG_TYPE_DEFAULT;
  uint64_t v9 = v228;
  unint64_t v7 = v229;
  if (!__nwlog_fault(v114, type, &v246)) {
    goto LABEL_219;
  }
  if (type[0] != OS_LOG_TYPE_FAULT)
  {
    if (v246)
    {
      __int16 v120 = (char *)__nw_create_backtrace_string();
      os_log_type_t v121 = __nwlog_obj();
      os_log_type_t v122 = type[0];
      BOOL v123 = os_log_type_enabled(v121, type[0]);
      if (v120)
      {
        if (v123)
        {
          *(_DWORD *)buf = 136446722;
          v248 = "nw_channel_add_input_frames";
          __int16 v249 = 1024;
          *(_DWORD *)v250 = v113;
          *(_WORD *)&v250[4] = 2082;
          *(void *)&v250[6] = v120;
          _os_log_impl(&dword_1830D4000, v121, v122, "%{public}s os_packet_increment_use_count() %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v120);
        goto LABEL_219;
      }
      if (!v123) {
        goto LABEL_219;
      }
      *(_DWORD *)buf = 136446466;
      v248 = "nw_channel_add_input_frames";
      __int16 v249 = 1024;
      *(_DWORD *)v250 = v113;
      int v117 = v121;
      os_log_type_t v118 = v122;
      unsigned int v119 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d, no backtrace";
    }
    else
    {
      id v136 = __nwlog_obj();
      os_log_type_t v137 = type[0];
      if (!os_log_type_enabled(v136, type[0])) {
        goto LABEL_219;
      }
      *(_DWORD *)buf = 136446466;
      v248 = "nw_channel_add_input_frames";
      __int16 v249 = 1024;
      *(_DWORD *)v250 = v113;
      int v117 = v136;
      os_log_type_t v118 = v137;
      unsigned int v119 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d, backtrace limit exceeded";
    }
LABEL_218:
    _os_log_impl(&dword_1830D4000, v117, v118, v119, buf, 0x12u);
    goto LABEL_219;
  }
  __int16 v115 = __nwlog_obj();
  os_log_type_t v116 = type[0];
  if (os_log_type_enabled(v115, type[0]))
  {
    *(_DWORD *)buf = 136446466;
    v248 = "nw_channel_add_input_frames";
    __int16 v249 = 1024;
    *(_DWORD *)v250 = v113;
    int v117 = v115;
    os_log_type_t v118 = v116;
    unsigned int v119 = "%{public}s os_packet_increment_use_count() %{darwin.errno}d";
    goto LABEL_218;
  }
LABEL_219:
  if (v114) {
    free(v114);
  }
  uint64_t v3 = v237;
  uint64_t v8 = v225;
  uint64_t node = v29;
LABEL_101:
  uint64_t v2 = v239;
LABEL_102:
  if ((*(_WORD *)(v3 + 204) & 0x80) == 0) {
    goto LABEL_146;
  }
  *(_WORD *)os_log_type_t type = 1;
  uint64_t v61 = nw_hash_node_get_extra(node);
  char v62 = 0;
  while (2)
  {
    os_log_type_t v64 = (void *)v3;
    os_log_type_t v65 = (void *)(v3 + 16);
    uint64_t v3 = *(void *)(v3 + 16);
    if (!v3 && !v64[3]) {
      uint64_t v3 = 0;
    }
    --*(_DWORD *)(v2 + 416);
    uint64_t v66 = v64[4];
    uint64_t v67 = (void *)v64[5];
    if (v66)
    {
      *(void *)(v66 + 40) = v67;
      uint64_t v67 = (void *)v64[5];
    }
    else
    {
      *(void *)(v61 + 8) = v67;
    }
    void *v67 = v66;
    v64[4] = 0;
    v64[5] = 0;
    uint64_t v68 = v64[2];
    os_log_type_t v69 = (void *)v64[3];
    if (v68)
    {
      *(void *)(v68 + 24) = v69;
      os_log_type_t v69 = (void *)v64[3];
    }
    else
    {
      *(void *)(v2 + 328) = v69;
    }
    void *v69 = v68;
    *os_log_type_t v65 = 0;
    v65[1] = 0;
    if (v62) {
      goto LABEL_104;
    }
    int v70 = os_packet_decrement_use_count();
    if (!v70)
    {
      char v62 = 0;
      goto LABEL_105;
    }
    int v71 = v70;
    if (nw_channel_check_defunct(v2))
    {
LABEL_104:
      char v62 = 1;
      goto LABEL_105;
    }
    uint64_t v238 = v3;
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    v248 = "nw_channel_add_input_frames";
    __int16 v249 = 1024;
    *(_DWORD *)v250 = v71;
    os_log_type_t v72 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v246 = OS_LOG_TYPE_ERROR;
    char v240 = 0;
    if (!__nwlog_fault(v72, &v246, &v240)) {
      goto LABEL_133;
    }
    if (v246 == OS_LOG_TYPE_FAULT)
    {
      BOOL v73 = __nwlog_obj();
      os_log_type_t v74 = v246;
      if (os_log_type_enabled(v73, v246))
      {
        *(_DWORD *)buf = 136446466;
        v248 = "nw_channel_add_input_frames";
        __int16 v249 = 1024;
        *(_DWORD *)v250 = v71;
        BOOL v75 = v73;
        os_log_type_t v76 = v74;
        BOOL v77 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d";
        goto LABEL_132;
      }
      goto LABEL_133;
    }
    if (!v240)
    {
      uint64_t v82 = __nwlog_obj();
      os_log_type_t v83 = v246;
      if (!os_log_type_enabled(v82, v246)) {
        goto LABEL_133;
      }
      *(_DWORD *)buf = 136446466;
      v248 = "nw_channel_add_input_frames";
      __int16 v249 = 1024;
      *(_DWORD *)v250 = v71;
      BOOL v75 = v82;
      os_log_type_t v76 = v83;
      BOOL v77 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, backtrace limit exceeded";
LABEL_132:
      _os_log_impl(&dword_1830D4000, v75, v76, v77, buf, 0x12u);
      goto LABEL_133;
    }
    os_log_type_t v78 = (char *)__nw_create_backtrace_string();
    BOOL v79 = __nwlog_obj();
    os_log_type_t v80 = v246;
    BOOL v81 = os_log_type_enabled(v79, v246);
    if (v78)
    {
      if (v81)
      {
        *(_DWORD *)buf = 136446722;
        v248 = "nw_channel_add_input_frames";
        __int16 v249 = 1024;
        *(_DWORD *)v250 = v71;
        *(_WORD *)&v250[4] = 2082;
        *(void *)&v250[6] = v78;
        _os_log_impl(&dword_1830D4000, v79, v80, "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
      }
      free(v78);
      goto LABEL_133;
    }
    if (v81)
    {
      *(_DWORD *)buf = 136446466;
      v248 = "nw_channel_add_input_frames";
      __int16 v249 = 1024;
      *(_DWORD *)v250 = v71;
      BOOL v75 = v79;
      os_log_type_t v76 = v80;
      BOOL v77 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, no backtrace";
      goto LABEL_132;
    }
LABEL_133:
    if (v72) {
      free(v72);
    }
    char v62 = 0;
    unint64_t v7 = v229;
    uint64_t v3 = v238;
    uint64_t v2 = v239;
LABEL_105:
    v64[2] = 0;
    BOOL v63 = *(void **)(v2 + 296);
    v64[3] = v63;
    void *v63 = v64;
    *(void *)(v2 + 296) = v65;
    if (v3) {
      continue;
    }
    break;
  }
  if (!*(_WORD *)type) {
    char v62 = 1;
  }
  if ((v62 & 1) == 0)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v90 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      v248 = "nw_channel_add_input_frames";
      __int16 v249 = 1024;
      *(_DWORD *)v250 = *(unsigned __int16 *)type;
      _os_log_impl(&dword_1830D4000, v90, OS_LOG_TYPE_ERROR, "%{public}s use_count is not 0 at the end: %u", buf, 0x12u);
    }
  }
  uint64_t v9 = v228;
  uint64_t v8 = v225;
  uint64_t v2 = v239;
LABEL_146:
  if (nw_channel_check_defunct(v2))
  {
    id v5 = v230;
    LOBYTE(v6) = v231[0];
  }
  else
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446210;
    v248 = "nw_channel_add_input_frames";
    os_log_type_t v91 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v246 = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v91, type, &v246)) {
      goto LABEL_168;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (v246)
      {
        os_log_type_t v97 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v98 = gLogObj;
        os_log_type_t v99 = type[0];
        BOOL v100 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
        if (v97)
        {
          if (v100)
          {
            *(_DWORD *)buf = 136446466;
            v248 = "nw_channel_add_input_frames";
            __int16 v249 = 2082;
            *(void *)v250 = v97;
            _os_log_impl(&dword_1830D4000, v98, v99, "%{public}s failed to get buflet from packet, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v97);
          goto LABEL_168;
        }
        if (!v100) {
          goto LABEL_168;
        }
        *(_DWORD *)buf = 136446210;
        v248 = "nw_channel_add_input_frames";
        os_log_type_t v94 = v98;
        os_log_type_t v95 = v99;
        BOOL v96 = "%{public}s failed to get buflet from packet, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v105 = gLogObj;
        os_log_type_t v106 = type[0];
        if (!os_log_type_enabled((os_log_t)gLogObj, type[0])) {
          goto LABEL_168;
        }
        *(_DWORD *)buf = 136446210;
        v248 = "nw_channel_add_input_frames";
        os_log_type_t v94 = v105;
        os_log_type_t v95 = v106;
        BOOL v96 = "%{public}s failed to get buflet from packet, backtrace limit exceeded";
      }
LABEL_167:
      _os_log_impl(&dword_1830D4000, v94, v95, v96, buf, 0xCu);
      goto LABEL_168;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v92 = gLogObj;
    os_log_type_t v93 = type[0];
    if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
    {
      *(_DWORD *)buf = 136446210;
      v248 = "nw_channel_add_input_frames";
      os_log_type_t v94 = v92;
      os_log_type_t v95 = v93;
      BOOL v96 = "%{public}s failed to get buflet from packet";
      goto LABEL_167;
    }
LABEL_168:
    if (v91) {
      free(v91);
    }
    id v5 = v230;
    uint64_t v2 = v239;
    if ((*v230 & 0x1000) == 0 || !*(void *)(v239 + 136) || !os_channel_packet_free())
    {
      uint64_t v18 = v28;
      int v6 = *(_DWORD *)v231;
      goto LABEL_188;
    }
    LOBYTE(v6) = v231[0];
LABEL_386:
    nw_channel_check_defunct(v2);
  }
LABEL_271:
  uint64_t v9 = v8;
LABEL_272:
  uint64_t v163 = v9;
  BOOL v160 = v9 != 0;
  char v234 = v6;
  if (v163) {
    *(void *)(v2 + 400) = v163;
  }
  int v164 = *v5;
  int v161 = v164 | (*((unsigned __int8 *)v5 + 2) << 16) | 0x8000;
  unsigned __int16 *v5 = v164 | 0x8000;
  if (!v7)
  {
    int v162 = 1;
    goto LABEL_360;
  }
  uint64_t v165 = (void *)(v2 + 24);
  v166 = v253;
  unint64_t v167 = v7;
  while (2)
  {
    uint64_t v169 = *v166;
    if (*v166)
    {
      uint64_t v170 = *(void *)(v169 + 56);
      if (v170 && ((*(unsigned char *)(v170 + 153) & 8) != 0 || (*v230 & 0x80) == 0))
      {
        uint64_t v171 = *(void *)(v169 + 24);
        if (v171)
        {
          v172 = *(void (**)(uint64_t, void *))(v171 + 64);
          if (v172)
          {
            v173 = *(void **)(v169 + 40);
            if (v173 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v174 = *(void *)(v169 + 88);
              if (v174) {
                *(void *)(v169 + 88) = v174 + 1;
              }
            }
            if (*(_UNKNOWN **)(v2 + 64) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v175 = *(void *)(v2 + 112);
              if (v175) {
                *(void *)(v2 + 112) = v175 + 1;
              }
              v172(v169, v165);
              if (*(_UNKNOWN **)(v2 + 64) == &nw_protocol_ref_counted_handle)
              {
                uint64_t v180 = *(void *)(v2 + 112);
                if (v180)
                {
                  uint64_t v181 = v180 - 1;
                  *(void *)(v2 + 112) = v181;
                  if (!v181)
                  {
                    uint64_t v182 = v2;
                    v183 = *(void (***)(void))(v2 + 88);
                    if (v183)
                    {
                      *(void *)(v182 + 88) = 0;
                      v183[2](v183);
                      _Block_release(v183);
                    }
                    uint64_t v2 = v182;
                    if (*(unsigned char *)(v182 + 96))
                    {
                      v184 = *(const void **)(v182 + 88);
                      if (v184) {
                        _Block_release(v184);
                      }
                    }
                    free(v165);
                  }
                }
              }
            }
            else
            {
              v172(v169, v165);
            }
            if (v173 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v169 + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v176 = *(void *)(v169 + 88);
              if (v176)
              {
                uint64_t v177 = v176 - 1;
                *(void *)(v169 + 88) = v177;
                if (!v177)
                {
                  v178 = *(void (***)(void))(v169 + 64);
                  if (v178)
                  {
                    *(void *)(v169 + 64) = 0;
                    v178[2](v178);
                    _Block_release(v178);
                  }
                  if (*(unsigned char *)(v169 + 72))
                  {
                    v179 = *(const void **)(v169 + 64);
                    if (v179) {
                      _Block_release(v179);
                    }
                  }
                  v168 = (char *)v169;
LABEL_277:
                  free(v168);
                  goto LABEL_278;
                }
              }
            }
          }
        }
      }
      goto LABEL_279;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v248 = "__nw_protocol_get_output_handler_context";
    v185 = (const char *)_os_log_send_and_compose_impl();
    v251[0] = OS_LOG_TYPE_ERROR;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v185, v251, type)) {
      goto LABEL_325;
    }
    if (v251[0] == OS_LOG_TYPE_FAULT)
    {
      v186 = __nwlog_obj();
      os_log_type_t v187 = v251[0];
      if (os_log_type_enabled(v186, v251[0]))
      {
        *(_DWORD *)buf = 136446210;
        v248 = "__nw_protocol_get_output_handler_context";
        v188 = v186;
        os_log_type_t v189 = v187;
        v190 = "%{public}s called with null protocol";
        goto LABEL_324;
      }
      goto LABEL_325;
    }
    if (type[0] == OS_LOG_TYPE_DEFAULT)
    {
      v195 = __nwlog_obj();
      os_log_type_t v196 = v251[0];
      if (!os_log_type_enabled(v195, v251[0])) {
        goto LABEL_325;
      }
      *(_DWORD *)buf = 136446210;
      v248 = "__nw_protocol_get_output_handler_context";
      v188 = v195;
      os_log_type_t v189 = v196;
      v190 = "%{public}s called with null protocol, backtrace limit exceeded";
LABEL_324:
      _os_log_impl(&dword_1830D4000, v188, v189, v190, buf, 0xCu);
      goto LABEL_325;
    }
    v191 = (char *)__nw_create_backtrace_string();
    v192 = __nwlog_obj();
    os_log_type_t v193 = v251[0];
    BOOL v194 = os_log_type_enabled(v192, v251[0]);
    if (v191)
    {
      if (v194)
      {
        *(_DWORD *)buf = 136446466;
        v248 = "__nw_protocol_get_output_handler_context";
        __int16 v249 = 2082;
        *(void *)v250 = v191;
        _os_log_impl(&dword_1830D4000, v192, v193, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v191);
      goto LABEL_325;
    }
    if (v194)
    {
      *(_DWORD *)buf = 136446210;
      v248 = "__nw_protocol_get_output_handler_context";
      v188 = v192;
      os_log_type_t v189 = v193;
      v190 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_324;
    }
LABEL_325:
    if (v185)
    {
      v168 = (char *)v185;
      goto LABEL_277;
    }
LABEL_278:
    uint64_t v2 = v239;
LABEL_279:
    ++v166;
    if (--v7) {
      continue;
    }
    break;
  }
  v197 = v253;
  do
  {
    uint64_t v198 = *v197;
    if (*v197)
    {
      uint64_t v199 = *(void *)(v198 + 24);
      if (v199)
      {
        v200 = *(void (**)(uint64_t, void *))(v199 + 264);
        if (v200)
        {
          v201 = *(void **)(v198 + 40);
          if (v201 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v202 = *(void *)(v198 + 88);
            if (v202) {
              *(void *)(v198 + 88) = v202 + 1;
            }
          }
          if (*(_UNKNOWN **)(v2 + 64) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v203 = *(void *)(v2 + 112);
            if (v203) {
              *(void *)(v2 + 112) = v203 + 1;
            }
            v200(v198, v165);
            if (*(_UNKNOWN **)(v2 + 64) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v208 = *(void *)(v2 + 112);
              if (v208)
              {
                uint64_t v209 = v208 - 1;
                *(void *)(v2 + 112) = v209;
                if (!v209)
                {
                  uint64_t v210 = v2;
                  v211 = *(void (***)(void))(v2 + 88);
                  if (v211)
                  {
                    *(void *)(v210 + 88) = 0;
                    v211[2](v211);
                    _Block_release(v211);
                  }
                  uint64_t v2 = v210;
                  if (*(unsigned char *)(v210 + 96))
                  {
                    uint64_t v212 = *(const void **)(v210 + 88);
                    if (v212) {
                      _Block_release(v212);
                    }
                  }
                  free(v165);
                }
              }
            }
          }
          else
          {
            v200(v198, v165);
          }
          if (v201 == &nw_protocol_ref_counted_handle && *(_UNKNOWN **)(v198 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v204 = *(void *)(v198 + 88);
            if (v204)
            {
              uint64_t v205 = v204 - 1;
              *(void *)(v198 + 88) = v205;
              if (!v205)
              {
                v206 = *(void (***)(void))(v198 + 64);
                if (v206)
                {
                  *(void *)(v198 + 64) = 0;
                  v206[2](v206);
                  _Block_release(v206);
                }
                if (*(unsigned char *)(v198 + 72))
                {
                  v207 = *(const void **)(v198 + 64);
                  if (v207) {
                    _Block_release(v207);
                  }
                }
                free((void *)v198);
                uint64_t v2 = v239;
              }
            }
          }
        }
      }
    }
    ++v197;
    --v167;
  }
  while (v167);
  int v162 = 0;
  id v5 = v230;
  int v161 = *v230 | (*((unsigned __int8 *)v230 + 2) << 16);
LABEL_360:
  char v158 = v234;
LABEL_361:
  unsigned __int16 *v5 = v161 & 0x7FFF;
  *((unsigned char *)v5 + 2) = (v161 & 0xFFFF7FFF) >> 16;
  if ((v161 & 0x10000) != 0)
  {
    unsigned int v213 = v161 & 0xFFFE7FFF;
    unsigned __int16 *v5 = v213;
    *((unsigned char *)v5 + 2) = BYTE2(v213);
    if (*(void *)(v239 + 136))
    {
      if (_nw_signposts_once != -1) {
        dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
      }
      if (_nw_signposts_enabled && kdebug_is_enabled()) {
        kdebug_trace();
      }
      if (os_channel_sync()) {
        nw_channel_check_defunct(v239);
      }
    }
  }
  if ((v160 & v162) == 1)
  {
    uint64_t v214 = v239;
    if (!*(void *)(v239 + 320))
    {
      if (*(void *)(v239 + 224))
      {
        *(_DWORD *)(v239 + 416) = 0;
        int v215 = os_channel_advance_slot();
        if (v215)
        {
          int v217 = v215;
          if ((nw_channel_check_defunct(v239) & 1) == 0)
          {
            char v218 = v158;
            __nwlog_obj();
            *(_DWORD *)buf = 136446466;
            v248 = "nw_channel_add_input_frames";
            __int16 v249 = 1024;
            *(_DWORD *)v250 = v217;
            v219 = (char *)_os_log_send_and_compose_impl();
            v251[0] = OS_LOG_TYPE_ERROR;
            type[0] = OS_LOG_TYPE_DEFAULT;
            if (!__nwlog_fault(v219, v251, type)) {
              goto LABEL_402;
            }
            if (v251[0] != OS_LOG_TYPE_FAULT)
            {
              if (type[0])
              {
                v223 = (char *)__nw_create_backtrace_string();
                v220 = __nwlog_obj();
                os_log_type_t v221 = v251[0];
                BOOL v224 = os_log_type_enabled(v220, v251[0]);
                if (v223)
                {
                  if (v224)
                  {
                    *(_DWORD *)buf = 136446722;
                    v248 = "nw_channel_add_input_frames";
                    __int16 v249 = 1024;
                    *(_DWORD *)v250 = v217;
                    *(_WORD *)&v250[4] = 2082;
                    *(void *)&v250[6] = v223;
                    _os_log_impl(&dword_1830D4000, v220, v221, "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }
                  free(v223);
                  goto LABEL_402;
                }
                if (!v224) {
                  goto LABEL_402;
                }
                *(_DWORD *)buf = 136446466;
                v248 = "nw_channel_add_input_frames";
                __int16 v249 = 1024;
                *(_DWORD *)v250 = v217;
                v222 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, no backtrace";
              }
              else
              {
                v220 = __nwlog_obj();
                os_log_type_t v221 = v251[0];
                if (!os_log_type_enabled(v220, v251[0])) {
                  goto LABEL_402;
                }
                *(_DWORD *)buf = 136446466;
                v248 = "nw_channel_add_input_frames";
                __int16 v249 = 1024;
                *(_DWORD *)v250 = v217;
                v222 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, backtrace limit exceeded";
              }
LABEL_401:
              _os_log_impl(&dword_1830D4000, v220, v221, v222, buf, 0x12u);
              goto LABEL_402;
            }
            v220 = __nwlog_obj();
            os_log_type_t v221 = v251[0];
            if (os_log_type_enabled(v220, v251[0]))
            {
              *(_DWORD *)buf = 136446466;
              v248 = "nw_channel_add_input_frames";
              __int16 v249 = 1024;
              *(_DWORD *)v250 = v217;
              v222 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d";
              goto LABEL_401;
            }
LABEL_402:
            if (v219) {
              free(v219);
            }
            char v158 = v218;
            uint64_t v214 = v239;
          }
        }
        if (*(void *)(v214 + 136))
        {
          if (_nw_signposts_once != -1) {
            dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
          }
          if (_nw_signposts_enabled && kdebug_is_enabled()) {
            kdebug_trace();
          }
          uint64_t v214 = v239;
          char v216 = 1;
          if (os_channel_sync())
          {
            nw_channel_check_defunct(v239);
            goto LABEL_382;
          }
        }
        else
        {
LABEL_382:
          char v216 = v158;
        }
        *(void *)(v214 + 400) = 0;
        char v158 = v216;
      }
    }
  }
  return v158 & 1;
}

uint64_t nw_hash_node_get_extra(uint64_t a1)
{
  uint64_t v14 = *MEMORY[0x1E4F143B8];
  if (a1) {
    return a1 + 32;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v11 = "nw_hash_node_get_extra";
  uint64_t v2 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v8 = 0;
  if (__nwlog_fault(v2, &type, &v8))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_hash_node_get_extra";
        id v5 = "%{public}s called with null node";
LABEL_17:
        _os_log_impl(&dword_1830D4000, v3, v4, v5, buf, 0xCu);
      }
    }
    else if (v8)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      BOOL v7 = os_log_type_enabled(v3, type);
      if (backtrace_string)
      {
        if (v7)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v11 = "nw_hash_node_get_extra";
          __int16 v12 = 2082;
          os_log_type_t v13 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v3, v4, "%{public}s called with null node, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_18;
      }
      if (v7)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_hash_node_get_extra";
        id v5 = "%{public}s called with null node, no backtrace";
        goto LABEL_17;
      }
    }
    else
    {
      uint64_t v3 = __nwlog_obj();
      os_log_type_t v4 = type;
      if (os_log_type_enabled(v3, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v11 = "nw_hash_node_get_extra";
        id v5 = "%{public}s called with null node, backtrace limit exceeded";
        goto LABEL_17;
      }
    }
  }
LABEL_18:
  if (v2) {
    free(v2);
  }
  return 0;
}

void nw_protocol_default_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_protocol_default_input_available";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (!__nwlog_fault(v5, &type, &v13)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v16 = "nw_protocol_default_input_available";
      char v8 = "%{public}s called with null protocol";
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_protocol_default_input_available";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_36:
        if (!v5) {
          return;
        }
        goto LABEL_37;
      }
      if (!v10) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v16 = "nw_protocol_default_input_available";
      char v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_36;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v16 = "nw_protocol_default_input_available";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_35:
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_36;
  }
  default_input_handler = a1->default_input_handler;
  if (default_input_handler)
  {
    callbacks = default_input_handler->callbacks;
    if (callbacks)
    {
      input_available = (void (*)(void))callbacks->input_available;
      if (input_available)
      {
        input_available();
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_protocol_default_input_available";
  id v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (!__nwlog_fault(v5, &type, &v13)) {
    goto LABEL_36;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_protocol_default_input_available";
    char v8 = "%{public}s called with null protocol->default_input_handler";
    goto LABEL_35;
  }
  if (!v13)
  {
    int v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    if (!os_log_type_enabled(v6, type)) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_protocol_default_input_available";
    char v8 = "%{public}s called with null protocol->default_input_handler, backtrace limit exceeded";
    goto LABEL_35;
  }
  uint64_t v11 = (char *)__nw_create_backtrace_string();
  int v6 = __nwlog_obj();
  os_log_type_t v7 = type;
  BOOL v12 = os_log_type_enabled(v6, type);
  if (!v11)
  {
    if (!v12) {
      goto LABEL_36;
    }
    *(_DWORD *)buf = 136446210;
    uint64_t v16 = "nw_protocol_default_input_available";
    char v8 = "%{public}s called with null protocol->default_input_handler, no backtrace";
    goto LABEL_35;
  }
  if (v12)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v16 = "nw_protocol_default_input_available";
    __int16 v17 = 2082;
    uint64_t v18 = v11;
    _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol->default_input_handler, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v11);
  if (v5) {
LABEL_37:
  }
    free(v5);
}

void nw_protocol_default_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_flush = (void (*)(void))callbacks->input_flush;
        if (input_flush)
        {
          input_flush();
        }
      }
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v14 = "nw_protocol_default_input_flush";
  id v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_default_input_flush";
      char v8 = "%{public}s called with null protocol";
      goto LABEL_21;
    }
    if (!v11)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_default_input_flush";
      char v8 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_21;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v6 = __nwlog_obj();
    os_log_type_t v7 = type;
    BOOL v10 = os_log_type_enabled(v6, type);
    if (backtrace_string)
    {
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v14 = "nw_protocol_default_input_flush";
        __int16 v15 = 2082;
        uint64_t v16 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_22;
    }
    if (v10)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v14 = "nw_protocol_default_input_flush";
      char v8 = "%{public}s called with null protocol, no backtrace";
LABEL_21:
      _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    }
  }
LABEL_22:
  if (v5) {
    free(v5);
  }
}

void __nw_endpoint_handler_initialize_association_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  if (nw_path_changed_from_previous(v5)) {
    *(unsigned char *)(*(void *)(a1 + 32) + 268) = *(unsigned char *)(*(void *)(a1 + 32) + 268) & 0xF7 | (8
  }
                                                                                                * nw_endpoint_handler_get_alternate_path_state(*(void **)(a1 + 32), 0, 0, v5));
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 112));
  objc_storeStrong((id *)(*(void *)(a1 + 32) + 64), a3);
  os_unfair_lock_unlock((os_unfair_lock_t)(*(void *)(a1 + 32) + 112));
  nw_endpoint_handler_path_change(*(NWConcrete_nw_endpoint_handler **)(a1 + 32));
}

void sub_183194304(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_changed_from_previous(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[474] >> 4) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_path_changed_from_previous";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_path_changed_from_previous";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_path_changed_from_previous";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_implementation_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    char handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    id v5 = p_output_handler;
    int v6 = v5;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      parent_definition = v5->parent_definition;
      if (parent_definition)
      {
        if (parent_definition->extended_state)
        {
          nw_protocol_implementation_read(v5, a2);
LABEL_8:

          return;
        }
        uint64_t v18 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        char v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v35 = 0;
        if (!__nwlog_fault(v13, &type, &v35)) {
          goto LABEL_77;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v14 = __nwlog_obj();
          os_log_type_t v19 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "nw_protocol_implementation_input_available";
            _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (!v35)
        {
          uint64_t v14 = __nwlog_obj();
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "nw_protocol_implementation_input_available";
            _os_log_impl(&dword_1830D4000, v14, v34, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_76;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v14, type);
        if (!backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "nw_protocol_implementation_input_available";
            _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          char v40 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v29, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }
      else
      {
        uint64_t v16 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        char v13 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v35 = 0;
        if (!__nwlog_fault(v13, &type, &v35)) {
          goto LABEL_77;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v14 = __nwlog_obj();
          os_log_type_t v17 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "nw_protocol_implementation_input_available";
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null instance->parent_definition", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (!v35)
        {
          uint64_t v14 = __nwlog_obj();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v14, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "nw_protocol_implementation_input_available";
            _os_log_impl(&dword_1830D4000, v14, v33, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
          }
          goto LABEL_76;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v14 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v14, type);
        if (!backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v38 = "nw_protocol_implementation_input_available";
            _os_log_impl(&dword_1830D4000, v14, v27, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
          }
          goto LABEL_76;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          char v40 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v27, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
        }
      }

      free(backtrace_string);
      if (!v13) {
        goto LABEL_8;
      }
      goto LABEL_78;
    }
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v38 = "nw_protocol_implementation_input_available";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (!__nwlog_fault(v13, &type, &v35)) {
      goto LABEL_77;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null instance", buf, 0xCu);
      }
    }
    else if (v35)
    {
      size_t v23 = (char *)__nw_create_backtrace_string();
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v25 = os_log_type_enabled(v14, type);
      if (v23)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          char v40 = v23;
          _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v23);
LABEL_77:
        if (!v13) {
          goto LABEL_8;
        }
LABEL_78:
        free(v13);
        goto LABEL_8;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v14 = __nwlog_obj();
      os_log_type_t v32 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_1830D4000, v14, v32, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_76:

    goto LABEL_77;
  }
  os_log_type_t v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v38 = "nw_protocol_implementation_input_available";
  uint64_t v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v35 = 0;
  if (__nwlog_fault(v9, &type, &v35))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v35)
    {
      int v20 = (char *)__nw_create_backtrace_string();
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v10, type);
      if (v20)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v38 = "nw_protocol_implementation_input_available";
          __int16 v39 = 2082;
          char v40 = v20;
          _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v20);
        goto LABEL_66;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_1830D4000, v10, v21, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v10 = __nwlog_obj();
      os_log_type_t v31 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v38 = "nw_protocol_implementation_input_available";
        _os_log_impl(&dword_1830D4000, v10, v31, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_66:
  if (v9) {
    free(v9);
  }
}

void sub_183194E9C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_input_flush(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    char handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    os_log_type_t v4 = p_output_handler;
    id v5 = v4;
    if (handle == &nw_protocol_ref_counted_handle)
    {
      uint64_t v6 = *((void *)v4 + 1);
      if (v6)
      {
        if (*(void *)(v6 + 80))
        {
LABEL_7:

          return;
        }
        os_log_type_t v17 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        size_t v37 = "nw_protocol_implementation_input_flush";
        os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v34 = 0;
        if (!__nwlog_fault(v12, &type, &v34)) {
          goto LABEL_76;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          char v13 = __nwlog_obj();
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446210;
            size_t v37 = "nw_protocol_implementation_input_flush";
            _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          char v13 = __nwlog_obj();
          os_log_type_t v28 = type;
          BOOL v29 = os_log_type_enabled(v13, type);
          if (backtrace_string)
          {
            if (v29)
            {
              *(_DWORD *)buf = 136446466;
              size_t v37 = "nw_protocol_implementation_input_flush";
              __int16 v38 = 2082;
              __int16 v39 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v13, v28, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
LABEL_76:
            if (!v12) {
              goto LABEL_7;
            }
LABEL_77:
            free(v12);
            goto LABEL_7;
          }
          if (v29)
          {
            *(_DWORD *)buf = 136446210;
            size_t v37 = "nw_protocol_implementation_input_flush";
            _os_log_impl(&dword_1830D4000, v13, v28, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          char v13 = __nwlog_obj();
          os_log_type_t v33 = type;
          if (os_log_type_enabled(v13, type))
          {
            *(_DWORD *)buf = 136446210;
            size_t v37 = "nw_protocol_implementation_input_flush";
            _os_log_impl(&dword_1830D4000, v13, v33, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
          }
        }
LABEL_75:

        goto LABEL_76;
      }
      os_log_type_t v15 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v37 = "nw_protocol_implementation_input_flush";
      os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (!__nwlog_fault(v12, &type, &v34)) {
        goto LABEL_76;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (!v34)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v32 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_1830D4000, v13, v32, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_75;
      }
      BOOL v22 = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v13, type);
      if (!v22)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          size_t v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        size_t v37 = "nw_protocol_implementation_input_flush";
        __int16 v38 = 2082;
        __int16 v39 = v22;
        _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }
    else
    {
      os_log_type_t v11 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      size_t v37 = "nw_protocol_implementation_input_flush";
      os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (!__nwlog_fault(v12, &type, &v34)) {
        goto LABEL_76;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (!v34)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_1830D4000, v13, v31, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_75;
      }
      BOOL v22 = (char *)__nw_create_backtrace_string();
      char v13 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v13, type);
      if (!v22)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          size_t v37 = "nw_protocol_implementation_input_flush";
          _os_log_impl(&dword_1830D4000, v13, v23, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_75;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        size_t v37 = "nw_protocol_implementation_input_flush";
        __int16 v38 = 2082;
        __int16 v39 = v22;
        _os_log_impl(&dword_1830D4000, v13, v23, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
    }

    free(v22);
    if (!v12) {
      goto LABEL_7;
    }
    goto LABEL_77;
  }
  os_log_type_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  size_t v37 = "nw_protocol_implementation_input_flush";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (__nwlog_fault(v8, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v37 = "nw_protocol_implementation_input_flush";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v34)
    {
      os_log_type_t v19 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v9, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          size_t v37 = "nw_protocol_implementation_input_flush";
          __int16 v38 = 2082;
          __int16 v39 = v19;
          _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v19);
        goto LABEL_65;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        size_t v37 = "nw_protocol_implementation_input_flush";
        _os_log_impl(&dword_1830D4000, v9, v20, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        size_t v37 = "nw_protocol_implementation_input_flush";
        _os_log_impl(&dword_1830D4000, v9, v30, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_65:
  if (v8) {
    free(v8);
  }
}

id nw_connection_copy_connected_remote_endpoint(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    os_log_type_t v19 = __Block_byref_object_copy__24353;
    os_log_type_t v20 = __Block_byref_object_dispose__24354;
    id v21 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_connected_remote_endpoint_block_invoke;
    v13[3] = &unk_1E524B978;
    os_log_type_t v14 = v1;
    os_log_type_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_connected_remote_endpoint_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_remote_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_connected_remote_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    os_log_type_t v4 = v6;
    if (v6)
    {
      nw_endpoint_t v7 = nw_path_copy_effective_remote_endpoint(v6);
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
      uint64_t v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)) {
        goto LABEL_24;
      }
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16);
      if (!v10 || nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104))) {
        goto LABEL_24;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_remote_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v12;
      char v13 = "%{public}s [C%u] Connection has no remote endpoint";
    }
    else
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 16);
      if (!v14 || nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
      {
        os_log_type_t v4 = 0;
        goto LABEL_24;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
LABEL_23:

LABEL_24:
        return;
      }
      int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_remote_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v15;
      char v13 = "%{public}s [C%u] Connection has no connected path";
    }
    _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v16, 0x12u);
    goto LABEL_23;
  }
  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_remote_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v5;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Client called nw_connection_copy_connected_remote_endpoint on unconnected nw_connection", (uint8_t *)&v16, 0x12u);
    }
    goto LABEL_24;
  }
}

BOOL nw_parameters_get_reuse_local_address(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    BOOL v3 = BYTE1(v1[12].isa) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_reuse_local_address";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_reuse_local_address";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_reuse_local_address";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_reuse_local_address";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_reuse_local_address";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_next_hop_required_interface_type(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned int *)(*((void *)v1 + 13) + 92);
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_next_hop_required_interface_type";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_next_hop_required_interface_type";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_next_hop_required_interface_type";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_next_hop_required_interface_type";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_next_hop_required_interface_type";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_dry_run(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((unsigned char *)v1 + 96) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_dry_run";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_dry_run";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_dry_run";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_dry_run";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_dry_run";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_has_prohibited_interface_types(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_has_prohibited_interface_types";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_has_prohibited_interface_types";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_has_prohibited_interface_types";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v6) {
      free(v6);
    }
    goto LABEL_23;
  }
  uint64_t v3 = *(xpc_object_t **)(*((void *)v1 + 13) + 176);
  if (!v3 || !*v3)
  {
LABEL_23:
    BOOL v4 = 0;
    goto LABEL_24;
  }
  BOOL v4 = xpc_array_get_count(*v3) != 0;
LABEL_24:

  return v4;
}

void sub_183197764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_parameters_copy_prohibited_interface_types(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_copy_prohibited_interface_types";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_interface_types";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_copy_prohibited_interface_types";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_interface_types";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_interface_types";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(id **)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *v3;
LABEL_23:

  return v4;
}

id nw_parameters_copy_prohibited_interface_subtypes(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v17 = "nw_parameters_copy_prohibited_interface_subtypes";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v17 = "nw_parameters_copy_prohibited_interface_subtypes";
            __int16 v18 = 2082;
            uint64_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        nw_endpoint_t v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v17 = "nw_parameters_copy_prohibited_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3)
  {
LABEL_22:
    id v4 = 0;
    goto LABEL_23;
  }
  id v4 = *(id *)(v3 + 8);
LABEL_23:

  return v4;
}

uint64_t nw_parameters_is_third_party_web_content(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned __int16 *)(*((void *)v1 + 13) + 108) >> 15;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_is_third_party_web_content";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_is_third_party_web_content";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_is_third_party_web_content";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_is_third_party_web_content";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_is_third_party_web_content";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_is_approved_app_domain(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned char *)(*((void *)v1 + 13) + 110) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_is_approved_app_domain";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_is_approved_app_domain";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_is_approved_app_domain";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_is_approved_app_domain";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_is_approved_app_domain";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_include_screen_off_devices(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[100] >> 4) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_include_screen_off_devices";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_include_screen_off_devices";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_include_screen_off_devices";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_include_screen_off_devices";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_include_screen_off_devices";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_include_ble(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[100] >> 3) & 1;
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_include_ble";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_include_ble";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_include_ble";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_include_ble";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_include_ble";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_fallback_mode(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned __int8 *)(*((void *)v1 + 13) + 107);
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v16 = "nw_parameters_get_fallback_mode";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_fallback_mode";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          int v16 = "nw_parameters_get_fallback_mode";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_fallback_mode";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        int v16 = "nw_parameters_get_fallback_mode";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void sub_183198A3C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_required_netagents(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_parameters_has_required_netagents";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_required_netagents";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_parameters_has_required_netagents";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_required_netagents";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_required_netagents";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_28:
    if (v9) {
      free(v9);
    }
    goto LABEL_30;
  }
  uint64_t v3 = *(void **)(v1[13] + 176);
  if (!v3) {
    goto LABEL_30;
  }
  id v4 = (void *)v3[8];
  if (!v4)
  {
LABEL_6:
    int v5 = (void *)v3[7];
    if (v5)
    {
      if (xpc_array_get_count(v5)) {
        goto LABEL_8;
      }
      uint64_t v3 = *(void **)(v2[13] + 176);
    }
    nw_endpoint_t v7 = (void *)v3[9];
    if (v7)
    {
      BOOL v6 = xpc_array_get_count(v7) != 0;
      goto LABEL_31;
    }
LABEL_30:
    BOOL v6 = 0;
    goto LABEL_31;
  }
  if (!xpc_array_get_count(v4))
  {
    uint64_t v3 = *(void **)(v2[13] + 176);
    goto LABEL_6;
  }
LABEL_8:
  BOOL v6 = 1;
LABEL_31:

  return v6;
}

void sub_183199450(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_prohibited_netagents(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v20 = "nw_parameters_has_prohibited_netagents";
    uint64_t v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v9, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_prohibited_netagents";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        BOOL v14 = os_log_type_enabled(v10, type);
        if (backtrace_string)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v20 = "nw_parameters_has_prohibited_netagents";
            __int16 v21 = 2082;
            uint64_t v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v14)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_prohibited_netagents";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v10 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v20 = "nw_parameters_has_prohibited_netagents";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_28:
    if (v9) {
      free(v9);
    }
    goto LABEL_30;
  }
  uint64_t v3 = *(void **)(v1[13] + 176);
  if (!v3) {
    goto LABEL_30;
  }
  id v4 = (void *)v3[5];
  if (!v4)
  {
LABEL_6:
    int v5 = (void *)v3[4];
    if (v5)
    {
      if (xpc_array_get_count(v5)) {
        goto LABEL_8;
      }
      uint64_t v3 = *(void **)(v2[13] + 176);
    }
    nw_endpoint_t v7 = (void *)v3[6];
    if (v7)
    {
      BOOL v6 = xpc_array_get_count(v7) != 0;
      goto LABEL_31;
    }
LABEL_30:
    BOOL v6 = 0;
    goto LABEL_31;
  }
  if (!xpc_array_get_count(v4))
  {
    uint64_t v3 = *(void **)(v2[13] + 176);
    goto LABEL_6;
  }
LABEL_8:
  BOOL v6 = 1;
LABEL_31:

  return v6;
}

void sub_18319974C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_preferred_netagents(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v21 = "nw_parameters_has_preferred_netagents";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v21 = "nw_parameters_has_preferred_netagents";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v21 = "nw_parameters_has_preferred_netagents";
            __int16 v22 = 2082;
            uint64_t v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v21 = "nw_parameters_has_preferred_netagents";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v21 = "nw_parameters_has_preferred_netagents";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_29:
    if (v10) {
      free(v10);
    }
    goto LABEL_31;
  }
  uint64_t v3 = v1[13];
  if (*(_DWORD *)(v3 + 84) != 1)
  {
    int v5 = *(void **)(v3 + 176);
    if (v5)
    {
      BOOL v6 = (void *)v5[10];
      if (v6)
      {
        if (xpc_array_get_count(v6)) {
          goto LABEL_3;
        }
        int v5 = *(void **)(v2[13] + 176);
      }
      nw_endpoint_t v7 = (void *)v5[11];
      if (v7)
      {
        if (xpc_array_get_count(v7)) {
          goto LABEL_3;
        }
        int v5 = *(void **)(v2[13] + 176);
      }
      os_log_type_t v8 = (void *)v5[12];
      if (v8)
      {
        BOOL v4 = xpc_array_get_count(v8) != 0;
        goto LABEL_32;
      }
    }
LABEL_31:
    BOOL v4 = 0;
    goto LABEL_32;
  }
LABEL_3:
  BOOL v4 = 1;
LABEL_32:

  return v4;
}

void sub_183199A54(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_preferred_interface_subtypes(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    BOOL v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v18 = "nw_parameters_has_preferred_interface_subtypes";
    nw_endpoint_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (__nwlog_fault(v7, &type, &v15))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_parameters_has_preferred_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v15)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v11 = type;
        BOOL v12 = os_log_type_enabled(v8, type);
        if (backtrace_string)
        {
          if (v12)
          {
            *(_DWORD *)buf = 136446466;
            char v18 = "nw_parameters_has_preferred_interface_subtypes";
            __int16 v19 = 2082;
            uint64_t v20 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v12)
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_parameters_has_preferred_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v8, type))
        {
          *(_DWORD *)buf = 136446210;
          char v18 = "nw_parameters_has_preferred_interface_subtypes";
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v7) {
      free(v7);
    }
    goto LABEL_23;
  }
  uint64_t v3 = *(void *)(*((void *)v1 + 13) + 176);
  if (!v3 || (BOOL v4 = *(void **)(v3 + 16)) == 0)
  {
LABEL_23:
    BOOL v5 = 0;
    goto LABEL_24;
  }
  BOOL v5 = xpc_array_get_count(v4) != 0;
LABEL_24:

  return v5;
}

void sub_183199D18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_uid(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *(unsigned int *)(*((void *)v1 + 13) + 68);
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_uid";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_uid";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_uid";
          __int16 v17 = 2082;
          char v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_uid";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_uid";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_parameters_get_should_trust_invalid_certificates(void *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (!v1)
  {
    uint64_t v3 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v15 = "nw_parameters_get_should_trust_invalid_certificates";
    BOOL v4 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (__nwlog_fault(v4, &type, &v12))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v5 = __nwlog_obj();
        os_log_type_t v6 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          char v15 = "nw_parameters_get_should_trust_invalid_certificates";
          _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v5 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v9 = os_log_type_enabled(v5, type);
        if (backtrace_string)
        {
          if (v9)
          {
            *(_DWORD *)buf = 136446466;
            char v15 = "nw_parameters_get_should_trust_invalid_certificates";
            __int16 v16 = 2082;
            __int16 v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v9)
        {
          *(_DWORD *)buf = 136446210;
          char v15 = "nw_parameters_get_should_trust_invalid_certificates";
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v5 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v5, type))
        {
          *(_DWORD *)buf = 136446210;
          char v15 = "nw_parameters_get_should_trust_invalid_certificates";
          _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v4) {
      free(v4);
    }
    goto LABEL_22;
  }
  if (!os_variant_allows_internal_security_policies())
  {
LABEL_22:
    uint64_t v2 = 0;
    goto LABEL_23;
  }
  uint64_t v2 = (v1[101] >> 5) & 1;
LABEL_23:

  return v2;
}

void sub_18319A350(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_resolver_create_dns_getaddrinfo_locked(NWConcrete_nw_resolver *a1, NWConcrete_nw_resolver_service *a2)
{
  uint64_t v164 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  BOOL v4 = a2;
  id v131 = v4;
  if (v3)
  {
    BOOL v5 = v4;
    os_log_type_t v6 = (void *)dnssd_getaddrinfo_create();
    BOOL v130 = v6 != 0;
    if (v6)
    {
      if (v5)
      {
        nw_endpoint_t v7 = v5->service_host;
      }
      else
      {
        nw_endpoint_t v7 = *((id *)v3 + 3);
      }
      unsigned int v148 = 0;
      unsigned int v148 = nw_resolver_derive_service_flags(v3, v7, *((void **)v3 + 2));
      nw_resolver_get_scoped_interface_index(v3, &v148);
      BOOL v8 = nw_context_copy_workloop(*((void **)v3 + 4));
      dnssd_getaddrinfo_set_queue();

      dnssd_getaddrinfo_set_flags();
      dnssd_getaddrinfo_set_interface_index();
      nw_endpoint_get_hostname(v7);
      dnssd_getaddrinfo_set_hostname();
      dnssd_getaddrinfo_set_protocols();
      if (nw_parameters_get_sensitive_redacted(*((void **)v3 + 2))) {
        dnssd_getaddrinfo_set_log_privacy_level();
      }
      BOOL v9 = *((id *)v3 + 2);
      if (v9)
      {
        BOOL v10 = (v9[12] & 0x100000000) == 0;

        if (!v10) {
          dnssd_getaddrinfo_prohibit_encrypted_dns();
        }
        goto LABEL_11;
      }
      os_log_type_t v112 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
      int v113 = (char *)_os_log_send_and_compose_impl();

      v150[0] = 16;
      LOBYTE(v142) = 0;
      if (__nwlog_fault(v113, v150, &v142))
      {
        if (v150[0] == 17)
        {
          BOOL v114 = __nwlog_obj();
          os_log_type_t v115 = v150[0];
          if (os_log_type_enabled(v114, (os_log_type_t)v150[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
            _os_log_impl(&dword_1830D4000, v114, v115, "%{public}s called with null parameters", buf, 0xCu);
          }
        }
        else
        {
          if ((_BYTE)v142)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            __int16 v124 = __nwlog_obj();
            os_log_type_t v125 = v150[0];
            BOOL v126 = os_log_type_enabled(v124, (os_log_type_t)v150[0]);
            if (backtrace_string)
            {
              if (v126)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = backtrace_string;
                _os_log_impl(&dword_1830D4000, v124, v125, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(backtrace_string);
            }
            else
            {
              if (v126)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
                _os_log_impl(&dword_1830D4000, v124, v125, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
              }
            }
            goto LABEL_234;
          }
          BOOL v114 = __nwlog_obj();
          os_log_type_t v129 = v150[0];
          if (os_log_type_enabled(v114, (os_log_type_t)v150[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_prohibit_encrypted_dns";
            _os_log_impl(&dword_1830D4000, v114, v129, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_234:
      if (v113) {
        free(v113);
      }
LABEL_11:
      out_signature_size_t length = 0;
      if (nw_endpoint_get_signature(*((nw_endpoint_t *)v3 + 3), &out_signature_length) && out_signature_length) {
        dnssd_getaddrinfo_set_validation_data();
      }
      if (nw_parameters_get_account_id(*((void **)v3 + 2))) {
        dnssd_getaddrinfo_set_account_id();
      }
      if (networkd_settings_get_BOOL((const char *)nw_setting_disable_svcb))
      {
        if ((*((unsigned char *)v3 + 346) & 0x20) == 0)
        {
          if (*((unsigned char *)v3 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v11 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = (char *)v3 + 256;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s] Requesting SVCB disabled", buf, 0x16u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            BOOL v11 = (id)gLogObj;
            if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
            {
              int v33 = *((_DWORD *)v3 + 85);
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v33;
              _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s [R%u] Requesting SVCB disabled", buf, 0x12u);
            }
          }
        }
        goto LABEL_73;
      }
      BOOL v12 = networkd_settings_get_BOOL((const char *)nw_setting_disable_svcb_router);
      char v13 = (void *)*((void *)v3 + 25);
      if (v13)
      {
        os_log_type_t v14 = nw_path_copy_interface(v13);

        if (v14) {
          BOOL v15 = v12;
        }
        else {
          BOOL v15 = 0;
        }
        if (v15)
        {
          __int16 v16 = v14;
          int v17 = v16[24];

          if (v17 == 1 || (os_log_type_t v14 = v16, v18 = v16[24], v14, v18 == 3))
          {
            uint64_t v19 = (atomic_uchar *)nw_path_copy_gateways(*((void **)v3 + 25));
            *(void *)buf = 0;
            *(void *)&uint8_t buf[8] = buf;
            *(void *)&buf[16] = 0x2020000000;
            unsigned char buf[24] = 0;
            v144[0] = MEMORY[0x1E4F143A8];
            v144[1] = 3221225472;
            v144[2] = ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke;
            v144[3] = &unk_1E524A2E8;
            uint64_t v20 = v3;
            uint64_t v145 = v20;
            os_log_type_t v146 = buf;
            nw_array_apply(v19, (uint64_t)v144);
            if (*(unsigned char *)(*(void *)&buf[8] + 24))
            {
              if ((*((unsigned char *)v20 + 346) & 0x20) != 0)
              {
LABEL_72:

                _Block_object_dispose(buf, 8);
                goto LABEL_73;
              }
              if (*((unsigned char *)v20 + 256))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v21 = (id)gconnectionLogObj;
                if (!os_log_type_enabled(v21, OS_LOG_TYPE_INFO)) {
                  goto LABEL_71;
                }
                *(_DWORD *)os_log_type_t v150 = 136446466;
                *(void *)&v150[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                *(_WORD *)&v150[12] = 2082;
                *(void *)&v150[14] = (char *)v20 + 256;
                __int16 v22 = "%{public}s [C%{public}s] Requesting SVCB disabled due to local router mitigation";
                uint64_t v23 = v21;
                uint32_t v24 = 22;
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v21 = (id)gLogObj;
                if (!os_log_type_enabled(v21, OS_LOG_TYPE_INFO))
                {
LABEL_71:

                  goto LABEL_72;
                }
                int v39 = *((_DWORD *)v20 + 85);
                *(_DWORD *)os_log_type_t v150 = 136446466;
                *(void *)&v150[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                *(_WORD *)&v150[12] = 1024;
                *(_DWORD *)&v150[14] = v39;
                __int16 v22 = "%{public}s [R%u] Requesting SVCB disabled due to local router mitigation";
                uint64_t v23 = v21;
                uint32_t v24 = 18;
              }
              _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, v22, v150, v24);
              goto LABEL_71;
            }

            _Block_object_dispose(buf, 8);
            os_log_type_t v14 = v16;
          }
        }
      }
      else
      {
        os_log_type_t v14 = 0;
      }

      if (v131)
      {
        os_log_type_t v25 = v131;
        BOOL v26 = v25->priority == 0;

        if (!v26) {
          goto LABEL_73;
        }
      }
      unsigned int port = nw_endpoint_get_port(*((nw_endpoint_t *)v3 + 3));
      if (!port) {
        goto LABEL_73;
      }
      os_log_type_t v28 = (void *)*((void *)v3 + 2);
      if (v28)
      {
        BOOL v29 = v28;
        id v30 = v29[25];

        id v31 = v30;
        if (v31)
        {
          url_scheme = (const char *)nw_endpoint_get_url_scheme(v31);
          goto LABEL_57;
        }
        char v34 = (void *)*((void *)v3 + 2);
      }
      else
      {
        char v34 = 0;
      }
      if (nw_parameters_get_ip_protocol(v34) == 6)
      {
        if (nw_parameters_get_ip_protocol(*((void **)v3 + 2)) == 17) {
          goto LABEL_73;
        }
        char v35 = "udp";
      }
      else
      {
        char v35 = "tcp";
      }
      size_t v36 = getservbyport(__rev16(port), v35);
      if (!v36)
      {
LABEL_73:
        if (uuid_is_null((const unsigned __int8 *)v3 + 232)) {
          goto LABEL_93;
        }
        if ((*((char *)v3 + 347) & 0x80000000) == 0)
        {
          if ((*((unsigned char *)v3 + 346) & 0x20) != 0)
          {
LABEL_92:
            dnssd_getaddrinfo_add_resolver_uuid();
            goto LABEL_93;
          }
          if (*((unsigned char *)v3 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v40 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_91;
            }
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = (char *)v3 + 256;
            *(_WORD *)&buf[22] = 1042;
            *(_DWORD *)&unsigned char buf[24] = 16;
            *(_WORD *)&buf[28] = 2098;
            *(void *)&buf[30] = (char *)v3 + 232;
            uint64_t v41 = "%{public}s [C%{public}s] Requesting resolver UUID %{public,uuid_t}.16P";
            uint64_t v42 = v40;
            uint32_t v43 = 38;
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v40 = (id)gLogObj;
            if (!os_log_type_enabled(v40, OS_LOG_TYPE_DEBUG))
            {
LABEL_91:

              goto LABEL_92;
            }
            int v48 = *((_DWORD *)v3 + 85);
            *(_DWORD *)buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v48;
            *(_WORD *)&buf[18] = 1042;
            *(_DWORD *)&buf[20] = 16;
            *(_WORD *)&unsigned char buf[24] = 2098;
            *(void *)&buf[26] = (char *)v3 + 232;
            uint64_t v41 = "%{public}s [R%u] Requesting resolver UUID %{public,uuid_t}.16P";
            uint64_t v42 = v40;
            uint32_t v43 = 34;
          }
          _os_log_impl(&dword_1830D4000, v42, OS_LOG_TYPE_DEBUG, v41, buf, v43);
          goto LABEL_91;
        }
        if ((*((unsigned char *)v3 + 346) & 0x20) != 0)
        {
LABEL_93:
          dnssd_getaddrinfo_set_use_failover();
          if (!nw_context_get_require_encrypted_name_resolution(*((void **)v3 + 4)))
          {
LABEL_112:
            pid_t v59 = getpid();
            memset(v150, 0, sizeof(v150));
            long long v142 = 0u;
            long long v143 = 0u;
            BOOL v60 = nw_copy_current_audit_token(v150);
            if (v60 && nw_parameters_has_delegated_proc_audit_token(*((void **)v3 + 2), v150)) {
              goto LABEL_239;
            }
            if (!nw_parameters_has_delegated_proc_pid(*((void **)v3 + 2), v59)
              && !nw_parameters_has_delegated_proc_uuid(*((void **)v3 + 2)))
            {
LABEL_158:
              objc_initWeak((id *)&location, v3);
              v136[1] = (id)MEMORY[0x1E4F143A8];
              v136[2] = (id)3221225472;
              v136[3] = ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_198;
              v136[4] = &unk_1E523B358;
              os_log_type_t v80 = v3;
              os_log_type_t v137 = v80;
              BOOL v81 = v131;
              v138 = v81;
              os_log_type_t v139 = v6;
              dnssd_getaddrinfo_set_event_handler();
              if ((*((unsigned char *)v80 + 348) & 2) != 0)
              {
                if (nw_storage_copy_shared_token[0] != -1) {
                  dispatch_once(nw_storage_copy_shared_token, &__block_literal_global_45557);
                }
                id v82 = (id)nw_storage_copy_shared_storage;
                os_log_type_t v84 = (void *)*((void *)v3 + 3);
                os_log_type_t v83 = (void *)*((void *)v3 + 4);
                v133[0] = MEMORY[0x1E4F143A8];
                v133[1] = 3221225472;
                v133[2] = ___ZL41nw_resolver_create_dns_getaddrinfo_lockedP22NWConcrete_nw_resolverP30NWConcrete_nw_resolver_service_block_invoke_200;
                v133[3] = &unk_1E523B380;
                objc_copyWeak(v136, (id *)&location);
                os_log_type_t v134 = v80;
                __int16 v135 = v81;
                nw_storage_lookup_items(v82, (uint64_t)"dns_cache", v84, v83, v133);

                objc_destroyWeak(v136);
              }
              objc_copyWeak(&v132, (id *)&location);
              uint64_t v85 = v80;
              os_log_type_t v86 = v81;
              dnssd_getaddrinfo_set_result_handler();
              if (v131)
              {
                BOOL v87 = v86;
                os_log_type_t v88 = v6;
                if (v87->gai)
                {
                  dnssd_getaddrinfo_invalidate();
                  gauint64_t i = v87->gai;
                  v87->gauint64_t i = 0;

                  os_log_type_t v90 = v87->gai;
                }
                else
                {
                  os_log_type_t v90 = 0;
                }
                v87->gauint64_t i = v88;
              }
              else
              {
                objc_storeStrong((id *)v85 + 6, v6);
              }
              dnssd_getaddrinfo_activate();
              if ((*((unsigned char *)v85 + 346) & 0x20) != 0) {
                goto LABEL_178;
              }
              if (*((unsigned char *)v85 + 256))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                os_log_type_t v91 = (id)gconnectionLogObj;
                if (!os_log_type_enabled(v91, OS_LOG_TYPE_INFO)) {
                  goto LABEL_177;
                }
                logging_description = nw_endpoint_get_logging_description(*((void **)v3 + 3));
                int v93 = *((_DWORD *)v3 + 20);
                uint64_t v94 = *((void *)v85 + 6);
                *(_DWORD *)buf = 136447491;
                *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = (char *)v85 + 256;
                *(_WORD *)&buf[22] = 2082;
                *(void *)&unsigned char buf[24] = logging_description;
                *(_WORD *)&unsigned char buf[32] = 1024;
                *(_DWORD *)&buf[34] = v148;
                *(_WORD *)&buf[38] = 1024;
                *(_DWORD *)&buf[40] = v93;
                *(_WORD *)&unsigned char buf[44] = 2117;
                *(void *)&buf[46] = v94;
                os_log_type_t v95 = "%{public}s [C%{public}s] Starting host resolution %{public}s, flags %#x proto %u using %{sensitive}@";
                BOOL v96 = v91;
                uint32_t v97 = 54;
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                os_log_type_t v91 = (id)gLogObj;
                if (!os_log_type_enabled(v91, OS_LOG_TYPE_INFO))
                {
LABEL_177:

LABEL_178:
                  objc_destroyWeak(&v132);

                  objc_destroyWeak((id *)&location);
LABEL_179:

                  os_log_type_t v102 = v131;
                  goto LABEL_180;
                }
                int v98 = *((_DWORD *)v85 + 85);
                os_log_type_t v99 = nw_endpoint_get_logging_description(*((void **)v3 + 3));
                int v100 = *((_DWORD *)v3 + 20);
                uint64_t v101 = *((void *)v85 + 6);
                *(_DWORD *)buf = 136447491;
                *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v98;
                *(_WORD *)&buf[18] = 2082;
                *(void *)&buf[20] = v99;
                *(_WORD *)&buf[28] = 1024;
                *(_DWORD *)&buf[30] = v148;
                *(_WORD *)&buf[34] = 1024;
                *(_DWORD *)&buf[36] = v100;
                *(_WORD *)&buf[40] = 2117;
                *(void *)&buf[42] = v101;
                os_log_type_t v95 = "%{public}s [R%u] Starting host resolution %{public}s, flags %#x proto %u using %{sensitive}@";
                BOOL v96 = v91;
                uint32_t v97 = 50;
              }
              _os_log_impl(&dword_1830D4000, v96, OS_LOG_TYPE_INFO, v95, buf, v97);
              goto LABEL_177;
            }
            if (v60)
            {
LABEL_239:
              if (nw_parameters_has_delegated_proc_audit_token(*((void **)v3 + 2), v150)
                && nw_parameters_get_effective_audit_token(*((void **)v3 + 2), &v142))
              {
                if ((*((unsigned char *)v3 + 346) & 0x20) != 0)
                {
LABEL_157:
                  long long v140 = v142;
                  long long v141 = v143;
                  dnssd_getaddrinfo_set_delegate_audit_token();
                  goto LABEL_158;
                }
                if (*((unsigned char *)v3 + 256))
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  uint64_t v61 = (id)gconnectionLogObj;
                  if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG)) {
                    goto LABEL_156;
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                  *(_WORD *)&buf[12] = 2082;
                  *(void *)&buf[14] = (char *)v3 + 256;
                  *(_WORD *)&buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = DWORD1(v143);
                  char v62 = "%{public}s [C%{public}s] Delegating DNS service to audit_token_t PID %d";
                  BOOL v63 = v61;
                  uint32_t v64 = 28;
                }
                else
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  uint64_t v61 = (id)gLogObj;
                  if (!os_log_type_enabled(v61, OS_LOG_TYPE_DEBUG))
                  {
LABEL_156:

                    goto LABEL_157;
                  }
                  int v79 = *((_DWORD *)v3 + 85);
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                  *(_WORD *)&buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v79;
                  *(_WORD *)&buf[18] = 1024;
                  *(_DWORD *)&buf[20] = DWORD1(v143);
                  char v62 = "%{public}s [R%u] Delegating DNS service to audit_token_t PID %d";
                  BOOL v63 = v61;
                  uint32_t v64 = 24;
                }
                _os_log_impl(&dword_1830D4000, v63, OS_LOG_TYPE_DEBUG, v62, buf, v64);
                goto LABEL_156;
              }
            }
            has_delegated_proc_int pid = nw_parameters_has_delegated_proc_pid(*((void **)v3 + 2), v59);
            uint64_t v66 = (void *)*((void *)v3 + 2);
            if (has_delegated_proc_pid)
            {
              int pid = nw_parameters_get_pid(v66);
              if ((*((unsigned char *)v3 + 346) & 0x20) != 0)
              {
LABEL_143:
                dnssd_getaddrinfo_set_delegate_pid();
                goto LABEL_158;
              }
              if (*((unsigned char *)v3 + 256))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v68 = (id)gconnectionLogObj;
                if (!os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG)) {
                  goto LABEL_142;
                }
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                *(_WORD *)&buf[12] = 2082;
                *(void *)&buf[14] = (char *)v3 + 256;
                *(_WORD *)&buf[22] = 1024;
                *(_DWORD *)&unsigned char buf[24] = pid;
                os_log_type_t v69 = "%{public}s [C%{public}s] Delegating DNS service to PID %d";
                int v70 = v68;
                uint32_t v71 = 28;
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v68 = (id)gLogObj;
                if (!os_log_type_enabled(v68, OS_LOG_TYPE_DEBUG))
                {
LABEL_142:

                  goto LABEL_143;
                }
                int v76 = *((_DWORD *)v3 + 85);
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
                *(_WORD *)&buf[12] = 1024;
                *(_DWORD *)&buf[14] = v76;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = pid;
                os_log_type_t v69 = "%{public}s [R%u] Delegating DNS service to PID %d";
                int v70 = v68;
                uint32_t v71 = 24;
              }
              _os_log_impl(&dword_1830D4000, v70, OS_LOG_TYPE_DEBUG, v69, buf, v71);
              goto LABEL_142;
            }
            if (!nw_parameters_has_delegated_proc_uuid(v66)) {
              goto LABEL_158;
            }
            long long location = 0uLL;
            nw_parameters_get_e_proc_uuid(*((void **)v3 + 2), &location);
            if ((*((unsigned char *)v3 + 346) & 0x20) != 0)
            {
LABEL_148:
              dnssd_getaddrinfo_set_delegate_uuid();
              goto LABEL_158;
            }
            if (*((unsigned char *)v3 + 256))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              os_log_type_t v72 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_147;
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = (char *)v3 + 256;
              *(_WORD *)&buf[22] = 1042;
              *(_DWORD *)&unsigned char buf[24] = 16;
              *(_WORD *)&buf[28] = 2098;
              *(void *)&buf[30] = &location;
              BOOL v73 = "%{public}s [C%{public}s] Delegating DNS service to eUUID %{public,uuid_t}.16P";
              os_log_type_t v74 = v72;
              uint32_t v75 = 38;
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v72 = (id)gLogObj;
              if (!os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
              {
LABEL_147:

                goto LABEL_148;
              }
              int v77 = *((_DWORD *)v3 + 85);
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
              *(_WORD *)&buf[12] = 1024;
              *(_DWORD *)&buf[14] = v77;
              *(_WORD *)&buf[18] = 1042;
              *(_DWORD *)&buf[20] = 16;
              *(_WORD *)&unsigned char buf[24] = 2098;
              *(void *)&buf[26] = &location;
              BOOL v73 = "%{public}s [R%u] Delegating DNS service to eUUID %{public,uuid_t}.16P";
              os_log_type_t v74 = v72;
              uint32_t v75 = 34;
            }
            _os_log_impl(&dword_1830D4000, v74, OS_LOG_TYPE_DEBUG, v73, buf, v75);
            goto LABEL_147;
          }
          id v49 = nw_context_copy_fallback_resolver_config(*((void **)v3 + 4));
          BOOL v50 = v49;
          if (v49)
          {
            id v51 = nw_resolver_config_copy_dictionary(v49);
            if ((*((unsigned char *)v3 + 346) & 0x20) != 0) {
              goto LABEL_111;
            }
          }
          else
          {
            id v51 = 0;
            if ((*((unsigned char *)v3 + 346) & 0x20) != 0)
            {
LABEL_111:
              dnssd_getaddrinfo_set_need_encrypted_query();

              goto LABEL_112;
            }
          }
          if (*((unsigned char *)v3 + 256))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v52 = (id)gconnectionLogObj;
            if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG)) {
              goto LABEL_110;
            }
            uint64_t v53 = "";
            *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
            *(_DWORD *)buf = 136446722;
            if (!v51) {
              uint64_t v53 = "out";
            }
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = (char *)v3 + 256;
            *(_WORD *)&buf[22] = 2080;
            *(void *)&unsigned char buf[24] = v53;
            os_log_type_t v54 = "%{public}s [C%{public}s] Requiring encrypted resolution with%s fallback config";
            os_log_type_t v55 = v52;
            uint32_t v56 = 32;
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v52 = (id)gLogObj;
            if (!os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
            {
LABEL_110:

              goto LABEL_111;
            }
            int v57 = *((_DWORD *)v3 + 85);
            uint64_t v58 = "";
            *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
            *(_DWORD *)buf = 136446722;
            if (!v51) {
              uint64_t v58 = "out";
            }
            *(_WORD *)&buf[12] = 1024;
            *(_DWORD *)&buf[14] = v57;
            *(_WORD *)&buf[18] = 2080;
            *(void *)&buf[20] = v58;
            os_log_type_t v54 = "%{public}s [R%u] Requiring encrypted resolution with%s fallback config";
            os_log_type_t v55 = v52;
            uint32_t v56 = 28;
          }
          _os_log_impl(&dword_1830D4000, v55, OS_LOG_TYPE_DEBUG, v54, buf, v56);
          goto LABEL_110;
        }
        if (*((unsigned char *)v3 + 256))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v44 = (id)gconnectionLogObj;
          if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG)) {
            goto LABEL_152;
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = (char *)v3 + 256;
          *(_WORD *)&buf[22] = 1042;
          *(_DWORD *)&unsigned char buf[24] = 16;
          *(_WORD *)&buf[28] = 2098;
          *(void *)&buf[30] = (char *)v3 + 232;
          size_t v45 = "%{public}s [C%{public}s] Requesting failover from UUID %{public,uuid_t}.16P";
          int v46 = v44;
          uint32_t v47 = 38;
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v44 = (id)gLogObj;
          if (!os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
          {
LABEL_152:

            goto LABEL_93;
          }
          int v78 = *((_DWORD *)v3 + 85);
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
          *(_WORD *)&buf[12] = 1024;
          *(_DWORD *)&buf[14] = v78;
          *(_WORD *)&buf[18] = 1042;
          *(_DWORD *)&buf[20] = 16;
          *(_WORD *)&unsigned char buf[24] = 2098;
          *(void *)&buf[26] = (char *)v3 + 232;
          size_t v45 = "%{public}s [R%u] Requesting failover from UUID %{public,uuid_t}.16P";
          int v46 = v44;
          uint32_t v47 = 34;
        }
        _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_DEBUG, v45, buf, v47);
        goto LABEL_152;
      }
      id v31 = 0;
      url_scheme = v36->s_name;
LABEL_57:

      if (url_scheme)
      {
        if (!strcmp(url_scheme, "https") || !strcmp(url_scheme, "http") || port == 80 || port == 443)
        {
          unsigned int port = 443;
          url_scheme = "https";
        }
        int v37 = _os_feature_enabled_impl();
        if (port == 443) {
          int v38 = 1;
        }
        else {
          int v38 = v37;
        }
        if (v38 == 1)
        {
          long long v162 = 0u;
          long long v163 = 0u;
          long long v160 = 0u;
          long long v161 = 0u;
          long long v158 = 0u;
          long long v159 = 0u;
          long long v156 = 0u;
          long long v157 = 0u;
          long long v154 = 0u;
          long long v155 = 0u;
          long long v152 = 0u;
          long long v153 = 0u;
          memset(buf, 0, sizeof(buf));
          snprintf((char *)buf, 0x100uLL, "_%u._%s", port, url_scheme);
          dnssd_getaddrinfo_set_service_scheme();
          *((unsigned char *)v3 + 347) |= 2u;
        }
      }
      goto LABEL_73;
    }
    os_log_type_t v108 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
    os_log_type_t v109 = (char *)_os_log_send_and_compose_impl();

    v150[0] = 16;
    LOBYTE(v142) = 0;
    if (__nwlog_fault(v109, v150, &v142))
    {
      if (v150[0] == 17)
      {
        unint64_t v110 = __nwlog_obj();
        os_log_type_t v111 = v150[0];
        if (os_log_type_enabled(v110, (os_log_type_t)v150[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
          _os_log_impl(&dword_1830D4000, v110, v111, "%{public}s called with null gai", buf, 0xCu);
        }
      }
      else
      {
        if ((_BYTE)v142)
        {
          unsigned int v119 = (char *)__nw_create_backtrace_string();
          __int16 v120 = __nwlog_obj();
          os_log_type_t v121 = v150[0];
          BOOL v122 = os_log_type_enabled(v120, (os_log_type_t)v150[0]);
          if (v119)
          {
            if (v122)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
              *(_WORD *)&buf[12] = 2082;
              *(void *)&buf[14] = v119;
              _os_log_impl(&dword_1830D4000, v120, v121, "%{public}s called with null gai, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v119);
          }
          else
          {
            if (v122)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
              _os_log_impl(&dword_1830D4000, v120, v121, "%{public}s called with null gai, no backtrace", buf, 0xCu);
            }
          }
          goto LABEL_229;
        }
        unint64_t v110 = __nwlog_obj();
        os_log_type_t v128 = v150[0];
        if (os_log_type_enabled(v110, (os_log_type_t)v150[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
          _os_log_impl(&dword_1830D4000, v110, v128, "%{public}s called with null gai, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_229:
    if (v109) {
      free(v109);
    }
    goto LABEL_179;
  }
  BOOL v104 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
  uint64_t v105 = (char *)_os_log_send_and_compose_impl();

  v150[0] = 16;
  LOBYTE(v142) = 0;
  if (__nwlog_fault(v105, v150, &v142))
  {
    if (v150[0] == 17)
    {
      os_log_type_t v106 = __nwlog_obj();
      os_log_type_t v107 = v150[0];
      if (os_log_type_enabled(v106, (os_log_type_t)v150[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
        _os_log_impl(&dword_1830D4000, v106, v107, "%{public}s called with null resolver", buf, 0xCu);
      }
    }
    else if ((_BYTE)v142)
    {
      os_log_type_t v116 = (char *)__nw_create_backtrace_string();
      os_log_type_t v106 = __nwlog_obj();
      os_log_type_t v117 = v150[0];
      BOOL v118 = os_log_type_enabled(v106, (os_log_type_t)v150[0]);
      if (v116)
      {
        if (v118)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v116;
          _os_log_impl(&dword_1830D4000, v106, v117, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v116);
        goto LABEL_223;
      }
      if (v118)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
        _os_log_impl(&dword_1830D4000, v106, v117, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v106 = __nwlog_obj();
      os_log_type_t v127 = v150[0];
      if (os_log_type_enabled(v106, (os_log_type_t)v150[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_resolver_create_dns_getaddrinfo_locked";
        _os_log_impl(&dword_1830D4000, v106, v127, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_223:
  os_log_type_t v102 = v131;
  if (v105) {
    free(v105);
  }
  BOOL v130 = 0;
LABEL_180:

  return v130;
}

void sub_18319C0AC(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, void *a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,uint64_t a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,uint64_t a30,uint64_t a31,uint64_t a32,uint64_t a33,uint64_t a34,uint64_t a35,uint64_t a36,uint64_t a37,uint64_t a38,uint64_t a39,uint64_t a40,uint64_t a41,uint64_t a42,uint64_t a43,uint64_t a44,uint64_t a45,uint64_t a46,uint64_t a47,uint64_t a48,uint64_t a49,uint64_t a50,uint64_t a51,uint64_t a52,uint64_t a53,uint64_t a54,id location)
{
  _Unwind_Resume(a1);
}

const uint8_t *__cdecl nw_endpoint_get_signature(nw_endpoint_t endpoint, size_t *out_signature_length)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  nw_endpoint_t v3 = endpoint;
  p_Class isa = (xpc_object_t *)&v3->isa;
  if (!v3)
  {
    nw_endpoint_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v24 = "nw_endpoint_get_signature";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v24 = "nw_endpoint_get_signature";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (!v21)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v24 = "nw_endpoint_get_signature";
        _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v9 = __nwlog_obj();
    os_log_type_t v14 = type;
    BOOL v15 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v24 = "nw_endpoint_get_signature";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint32_t v24 = "nw_endpoint_get_signature";
      __int16 v25 = 2082;
      BOOL v26 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_24;
  }
  if (!out_signature_length)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint32_t v24 = "nw_endpoint_get_signature";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (!__nwlog_fault(v8, &type, &v21)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v24 = "nw_endpoint_get_signature";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null out_signature_length", buf, 0xCu);
      }
LABEL_36:

LABEL_37:
      if (v8) {
        free(v8);
      }
      goto LABEL_39;
    }
    if (!v21)
    {
      BOOL v9 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v24 = "nw_endpoint_get_signature";
        _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null out_signature_length, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_36;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v9 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v9, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint32_t v24 = "nw_endpoint_get_signature";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null out_signature_length, no backtrace", buf, 0xCu);
      }
      goto LABEL_36;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      uint32_t v24 = "nw_endpoint_get_signature";
      __int16 v25 = 2082;
      BOOL v26 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null out_signature_length, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_24:

    free(backtrace_string);
    goto LABEL_37;
  }
  Class isa = v3[24].isa;
  if (!isa)
  {
LABEL_39:
    bytes_ptr = 0;
    goto LABEL_40;
  }
  *out_signature_size_t length = xpc_data_get_length(isa);
  bytes_ptr = (const uint8_t *)xpc_data_get_bytes_ptr(p_isa[24]);
LABEL_40:

  return bytes_ptr;
}

void sub_18319C680(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_path_copy_interface(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  p_Class isa = (void **)&v1->super.isa;
  if (!v1)
  {
    BOOL v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v16 = "nw_path_copy_interface";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v16 = "nw_path_copy_interface";
            __int16 v17 = 2082;
            os_log_type_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_21;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v6 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v16 = "nw_path_copy_interface";
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_21:
    if (v5) {
      free(v5);
    }
    goto LABEL_23;
  }
  if (!nw_path_network_is_satisfied_update_reason(v1, 0) && !nw_path_endpoint_is_always_satisfied(p_isa[3]))
  {
LABEL_23:
    id v3 = 0;
    goto LABEL_24;
  }
  id v3 = p_isa[12];
LABEL_24:

  return v3;
}

void sub_18319C948(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_get_url_scheme(void *a1)
{
  *(void *)&v40[13] = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    BOOL v26 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v38 = "nw_endpoint_get_url_scheme";
    uint64_t v27 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v27, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          int v38 = "nw_endpoint_get_url_scheme";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v35)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v28 = __nwlog_obj();
        os_log_type_t v31 = type;
        BOOL v32 = os_log_type_enabled(v28, type);
        if (backtrace_string)
        {
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            int v38 = "nw_endpoint_get_url_scheme";
            __int16 v39 = 2082;
            *(void *)uint64_t v40 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_42;
        }
        if (v32)
        {
          *(_DWORD *)buf = 136446210;
          int v38 = "nw_endpoint_get_url_scheme";
          _os_log_impl(&dword_1830D4000, v28, v31, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v28 = __nwlog_obj();
        os_log_type_t v33 = type;
        if (os_log_type_enabled(v28, type))
        {
          *(_DWORD *)buf = 136446210;
          int v38 = "nw_endpoint_get_url_scheme";
          _os_log_impl(&dword_1830D4000, v28, v33, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_42:
    if (!v27) {
      goto LABEL_24;
    }
    uint32_t v24 = (char *)v27;
    goto LABEL_23;
  }
  id v3 = v1;
  int v4 = [v3 type];

  if (v4 != 4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v6 = (id)gLogObj;
    os_log_type_t v7 = v3;
    int v8 = [v7 type];

    *(_DWORD *)buf = 136446466;
    int v38 = "nw_endpoint_get_url_scheme";
    __int16 v39 = 1024;
    *(_DWORD *)uint64_t v40 = v8;
    LODWORD(v34) = 18;
    os_log_type_t v9 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v35 = 0;
    if (__nwlog_fault(v9, &type, &v35))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          os_log_type_t v12 = v7;
          int v13 = objc_msgSend(v12, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          int v38 = "nw_endpoint_get_url_scheme";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v13;
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s incorrect endpoint type %u", buf, 0x12u);
        }
      }
      else if (v35)
      {
        os_log_type_t v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v10, type);
        if (v14)
        {
          if (v16)
          {
            __int16 v17 = v7;
            int v18 = objc_msgSend(v17, "type", buf, v34);

            *(_DWORD *)buf = 136446722;
            int v38 = "nw_endpoint_get_url_scheme";
            __int16 v39 = 1024;
            *(_DWORD *)uint64_t v40 = v18;
            v40[2] = 2082;
            *(void *)&v40[3] = v14;
            _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, dumping backtrace:%{public}s", buf, 0x1Cu);
          }

          free(v14);
          if (!v9) {
            goto LABEL_24;
          }
LABEL_22:
          uint32_t v24 = (char *)v9;
LABEL_23:
          free(v24);
          goto LABEL_24;
        }
        if (v16)
        {
          __int16 v22 = v7;
          int v23 = objc_msgSend(v22, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          int v38 = "nw_endpoint_get_url_scheme";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v23;
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s incorrect endpoint type %u, no backtrace", buf, 0x12u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v10 = (id)gLogObj;
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          uint64_t v20 = v7;
          int v21 = objc_msgSend(v20, "type", buf, v34);

          *(_DWORD *)buf = 136446466;
          int v38 = "nw_endpoint_get_url_scheme";
          __int16 v39 = 1024;
          *(_DWORD *)uint64_t v40 = v21;
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s incorrect endpoint type %u, backtrace limit exceeded", buf, 0x12u);
        }
      }
    }
    if (!v9)
    {
LABEL_24:
      uint64_t v5 = 0;
      goto LABEL_25;
    }
    goto LABEL_22;
  }
  uint64_t v5 = v3[32];
LABEL_25:

  return v5;
}

void sub_18319CF44(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_resolver_get_scoped_interface_index(NWConcrete_nw_resolver *a1, unsigned int *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    BOOL v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v32 = "nw_resolver_get_scoped_interface_index";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v17, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null resolver", buf, 0xCu);
        }
        goto LABEL_67;
      }
      if (!v29)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_1830D4000, v18, v27, "%{public}s called with null resolver, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v18 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null resolver, no backtrace", buf, 0xCu);
        }
        goto LABEL_67;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v32 = "nw_resolver_get_scoped_interface_index";
        __int16 v33 = 2082;
        *(void *)uint64_t v34 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null resolver, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_55:

      free(backtrace_string);
    }
LABEL_68:
    if (v17) {
      free(v17);
    }
    uint64_t v5 = 0;
    goto LABEL_27;
  }
  if (!a2)
  {
    uint64_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v32 = "nw_resolver_get_scoped_interface_index";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v29 = 0;
    if (__nwlog_fault(v17, &type, &v29))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null service_flags", buf, 0xCu);
        }
LABEL_67:

        goto LABEL_68;
      }
      if (!v29)
      {
        int v18 = __nwlog_obj();
        os_log_type_t v28 = type;
        if (os_log_type_enabled(v18, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_1830D4000, v18, v28, "%{public}s called with null service_flags, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_67;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v18 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (!backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v32 = "nw_resolver_get_scoped_interface_index";
          _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s called with null service_flags, no backtrace", buf, 0xCu);
        }
        goto LABEL_67;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v32 = "nw_resolver_get_scoped_interface_index";
        __int16 v33 = 2082;
        *(void *)uint64_t v34 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s called with null service_flags, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_55;
    }
    goto LABEL_68;
  }
  if (*((_DWORD *)v3 + 14))
  {
    *a2 |= 0x10000000u;
    uint64_t v5 = *((unsigned int *)v3 + 14);
    id v6 = "ServiceIndex";
    if (!v5) {
      goto LABEL_27;
    }
  }
  else
  {
    os_log_type_t v7 = (char *)*((id *)v3 + 26);
    if (v7
      || (os_log_type_t v7 = (char *)nw_parameters_copy_required_interface(*((nw_parameters_t *)v4 + 2))) != 0
      || (os_log_type_t v7 = (char *)nw_endpoint_copy_interface(*((void **)v4 + 3))) != 0)
    {
      id v6 = v7 + 104;
      int v8 = v7;
      unsigned int v9 = v8[24];

      if (v9 == 4) {
        uint64_t v5 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v5 = v8[2];
      }
    }
    else if ((*((unsigned char *)v4 + 346) & 0x10) != 0)
    {
      int v8 = 0;
      id v6 = "LocalOnly";
      uint64_t v5 = 0xFFFFFFFFLL;
    }
    else
    {
      required_interface_os_log_type_t type = nw_parameters_get_required_interface_type(*((nw_parameters_t *)v4 + 2));
      int v8 = 0;
      if (required_interface_type == nw_interface_type_loopback) {
        uint64_t v5 = 0xFFFFFFFFLL;
      }
      else {
        uint64_t v5 = 0;
      }
      if (required_interface_type == nw_interface_type_loopback) {
        id v6 = "loopback";
      }
      else {
        id v6 = "<NULL>";
      }
    }

    if (!v5) {
      goto LABEL_27;
    }
  }
  if ((*((unsigned char *)v4 + 346) & 0x20) == 0)
  {
    if (*((unsigned char *)v4 + 256))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v11 = "unknown";
        *(_DWORD *)buf = 136446978;
        BOOL v32 = "nw_resolver_get_scoped_interface_index";
        __int16 v33 = 2082;
        if (v6) {
          os_log_type_t v11 = v6;
        }
        *(void *)uint64_t v34 = (char *)v4 + 256;
        *(_WORD *)&v34[8] = 2082;
        *(void *)&v34[10] = v11;
        *(_WORD *)&v34[18] = 1024;
        int v35 = v5;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s] Scoping resolution to %{public}s [%d]", buf, 0x26u);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v10 = (id)gLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        int v12 = *((_DWORD *)v4 + 85);
        int v13 = "unknown";
        if (v6) {
          int v13 = v6;
        }
        *(_DWORD *)buf = 136446978;
        BOOL v32 = "nw_resolver_get_scoped_interface_index";
        __int16 v33 = 1024;
        *(_DWORD *)uint64_t v34 = v12;
        *(_WORD *)&v34[4] = 2082;
        *(void *)&v34[6] = v13;
        *(_WORD *)&v34[14] = 1024;
        *(_DWORD *)&v34[16] = v5;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [R%u] Scoping resolution to %{public}s [%d]", buf, 0x22u);
      }
    }
  }
LABEL_27:

  return v5;
}

nw_interface_t nw_parameters_copy_required_interface(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    id v3 = *((id *)v1[13].isa + 21);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_copy_required_interface";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_copy_required_interface";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_copy_required_interface";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_copy_required_interface";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_copy_required_interface";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

nw_interface_type_t nw_parameters_get_required_interface_type(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    nw_interface_type_t v3 = *((_DWORD *)v1[13].isa + 19);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_parameters_get_required_interface_type";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_required_interface_type";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_parameters_get_required_interface_type";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_required_interface_type";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_parameters_get_required_interface_type";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_interface_type_t v3 = nw_interface_type_other;
LABEL_3:

  return v3;
}

BOOL nw_parameters_has_delegated_proc_audit_token(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  nw_interface_type_t v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    unsigned int v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (!v23)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v16 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_35;
  }
  if (!a2)
  {
    char v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_48;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null audit_token", buf, 0xCu);
      }
LABEL_47:

LABEL_48:
      if (v10) {
        free(v10);
      }
      goto LABEL_50;
    }
    if (!v23)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null audit_token, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_47;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v11 = __nwlog_obj();
    os_log_type_t v18 = type;
    BOOL v19 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null audit_token, no backtrace", buf, 0xCu);
      }
      goto LABEL_47;
    }
    if (v19)
    {
      *(_DWORD *)buf = 136446466;
      BOOL v26 = "nw_parameters_has_delegated_proc_audit_token";
      __int16 v27 = 2082;
      os_log_type_t v28 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s called with null audit_token, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_35:

    free(backtrace_string);
    goto LABEL_48;
  }
  if (!(v3[5] | v3[6] | v3[7] | v3[8]))
  {
LABEL_50:
    BOOL v8 = 0;
    goto LABEL_51;
  }
  BOOL v8 = v3[5] != *a2 || v3[6] != a2[1] || v3[7] != a2[2] || v3[8] != a2[3];
LABEL_51:

  return v8;
}

BOOL nw_copy_current_audit_token(_OWORD *a1)
{
  *(void *)&v22[13] = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (nw_copy_current_audit_token::onceToken != -1) {
      dispatch_once(&nw_copy_current_audit_token::onceToken, &__block_literal_global_48617);
    }
    if (nw_copy_current_audit_token::valid)
    {
      long long v2 = unk_1EB2672A8;
      *a1 = nw_copy_current_audit_token::my_audit_token;
      a1[1] = v2;
      return 1;
    }
    int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)buf = 136446466;
    os_log_type_t v20 = "nw_copy_current_audit_token";
    __int16 v21 = 1024;
    *(_DWORD *)__int16 v22 = v4;
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (!__nwlog_fault(v5, &type, &v17)) {
      goto LABEL_20;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "nw_copy_current_audit_token";
        __int16 v21 = 1024;
        *(_DWORD *)__int16 v22 = v4;
        BOOL v8 = "%{public}s task_info(mach_task_self(), TASK_AUDIT_TOKEN, (integer_t *) &audit_token, &info_size) failed %{darwin.errno}d";
LABEL_19:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0x12u);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = gLogObj;
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled((os_log_t)gLogObj, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446722;
          os_log_type_t v20 = "nw_copy_current_audit_token";
          __int16 v21 = 1024;
          *(_DWORD *)__int16 v22 = v4;
          v22[2] = 2082;
          *(void *)&v22[3] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s task_info(mach_task_self(), TASK_AUDIT_TOKEN, (integer_t *) &audit_token, &info_size) failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "nw_copy_current_audit_token";
        __int16 v21 = 1024;
        *(_DWORD *)__int16 v22 = v4;
        BOOL v8 = "%{public}s task_info(mach_task_self(), TASK_AUDIT_TOKEN, (integer_t *) &audit_token, &info_size) failed %{d"
             "arwin.errno}d, no backtrace";
        goto LABEL_19;
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v6 = gLogObj;
      os_log_type_t v7 = type;
      if (os_log_type_enabled((os_log_t)gLogObj, type))
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v20 = "nw_copy_current_audit_token";
        __int16 v21 = 1024;
        *(_DWORD *)__int16 v22 = v4;
        BOOL v8 = "%{public}s task_info(mach_task_self(), TASK_AUDIT_TOKEN, (integer_t *) &audit_token, &info_size) failed %{d"
             "arwin.errno}d, backtrace limit exceeded";
        goto LABEL_19;
      }
    }
LABEL_20:
    if (v5) {
      free(v5);
    }
    return nw_copy_current_audit_token::valid != 0;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v20 = "nw_copy_current_audit_token";
  BOOL v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v11, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_copy_current_audit_token";
        os_log_type_t v14 = "%{public}s called with null audit_token";
LABEL_36:
        _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
      }
    }
    else if (v17)
    {
      os_log_type_t v15 = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (v15)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v20 = "nw_copy_current_audit_token";
          __int16 v21 = 2082;
          *(void *)__int16 v22 = v15;
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null audit_token, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v15);
        goto LABEL_37;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_copy_current_audit_token";
        os_log_type_t v14 = "%{public}s called with null audit_token, no backtrace";
        goto LABEL_36;
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v20 = "nw_copy_current_audit_token";
        os_log_type_t v14 = "%{public}s called with null audit_token, backtrace limit exceeded";
        goto LABEL_36;
      }
    }
  }
LABEL_37:
  if (v11) {
    free(v11);
  }
  return 0;
}

BOOL nw_context_get_require_encrypted_name_resolution(void *a1)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  long long v2 = v1;
  if (!v1)
  {
    unsigned int v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v20 = "nw_context_get_require_encrypted_name_resolution";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v17 = 0;
    if (__nwlog_fault(v10, &type, &v17))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_context_get_require_encrypted_name_resolution";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (v17)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v20 = "nw_context_get_require_encrypted_name_resolution";
            __int16 v21 = 2082;
            __int16 v22 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_28;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_context_get_require_encrypted_name_resolution";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v20 = "nw_context_get_require_encrypted_name_resolution";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_28:
    if (v10) {
      free(v10);
    }
    BOOL v5 = 0;
    goto LABEL_11;
  }
  char v3 = v1[136];
  if ((v3 & 0x48) != 0x40) {
    goto LABEL_5;
  }
  if (dispatch_workloop_is_current())
  {
    char v3 = v2[136];
LABEL_5:
    if (v3 < 0)
    {
      BOOL v5 = 1;
    }
    else
    {
      BOOL v4 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
      BOOL v5 = *(char *)(v4 + 136) < 0;
    }
    goto LABEL_11;
  }
  os_unfair_lock_lock((os_unfair_lock_t)v2 + 20);
  int v6 = (char)v2[136];
  if ((v6 & 0x80000000) == 0)
  {
    BOOL v7 = nw_context_copy_globals_context((NWConcrete_nw_context *)v2);
    LOBYTE(v6) = *(unsigned char *)(v7 + 136);
  }
  BOOL v5 = (v6 & 0x80u) != 0;
  os_unfair_lock_unlock((os_unfair_lock_t)v2 + 20);
LABEL_11:

  return v5;
}

void sub_18319E8C4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_effective_audit_token(void *a1, _OWORD *a2)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  char v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    BOOL v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v19 = "nw_parameters_get_effective_audit_token";
    BOOL v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v16 = 0;
    if (__nwlog_fault(v8, &type, &v16))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_parameters_get_effective_audit_token";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v16)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        BOOL v13 = os_log_type_enabled(v9, type);
        if (backtrace_string)
        {
          if (v13)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v19 = "nw_parameters_get_effective_audit_token";
            __int16 v20 = 2082;
            __int16 v21 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v13)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_parameters_get_effective_audit_token";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unsigned int v9 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v19 = "nw_parameters_get_effective_audit_token";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v8) {
      free(v8);
    }
    goto LABEL_22;
  }
  if (!(v3[5] | v3[6] | v3[7] | v3[8]))
  {
LABEL_22:
    uint64_t v6 = 0;
    goto LABEL_23;
  }
  long long v5 = *(_OWORD *)(v3 + 7);
  *a2 = *(_OWORD *)(v3 + 5);
  a2[1] = v5;
  uint64_t v6 = 1;
LABEL_23:

  return v6;
}

NWConcrete_nw_association *nw_association_create(void *a1, void *a2)
{
  uint64_t v45 = *MEMORY[0x1E4F143B8];
  id v4 = a1;
  id v5 = a2;
  uint64_t v6 = [NWConcrete_nw_association alloc];
  id v7 = v4;
  id v8 = v5;
  unsigned int v9 = v8;
  if (v6)
  {
    if (v7)
    {
      if (v8)
      {
        v39.os_log_type_t receiver = v6;
        v39.super_class = (Class)NWConcrete_nw_association;
        os_log_type_t v10 = (NWConcrete_nw_association *)objc_msgSendSuper2(&v39, sel_init);
        uint64_t v6 = v10;
        if (v10)
        {
          objc_storeStrong((id *)&v10->endpoint, a1);
          BOOL v11 = (OS_nw_path_parameters *)nw_parameters_copy_path_parameters(v9, 1);
          path_parameters = v6->path_parameters;
          v6->path_parameters = v11;

          *((unsigned char *)v6 + 76) |= 1u;
          goto LABEL_6;
        }
        uint64_t v22 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
        uint64_t v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v38 = 0;
        if ((__nwlog_fault(v23, &type, &v38) & 1) == 0) {
          goto LABEL_61;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          BOOL v24 = __nwlog_obj();
          os_log_type_t v25 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s [super init] failed", buf, 0xCu);
          }
        }
        else if (v38)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          BOOL v24 = __nwlog_obj();
          os_log_type_t v33 = type;
          BOOL v34 = os_log_type_enabled(v24, type);
          if (backtrace_string)
          {
            if (v34)
            {
              *(_DWORD *)buf = 136446466;
              uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
              __int16 v43 = 2082;
              os_log_type_t v44 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v24, v33, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_61;
          }
          if (v34)
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            _os_log_impl(&dword_1830D4000, v24, v33, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          BOOL v24 = __nwlog_obj();
          os_log_type_t v37 = type;
          if (os_log_type_enabled(v24, type))
          {
            *(_DWORD *)buf = 136446210;
            uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            _os_log_impl(&dword_1830D4000, v24, v37, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
          }
        }

LABEL_61:
        if (v23) {
          free(v23);
        }
        goto LABEL_63;
      }
      os_log_type_t v18 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
      BOOL v19 = (char *)_os_log_send_and_compose_impl();

      LOBYTE(v39.receiver) = 16;
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v19, &v39, &type)) {
        goto LABEL_55;
      }
      if (LOBYTE(v39.receiver) == 17)
      {
        __int16 v20 = __nwlog_obj();
        os_log_type_t receiver = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_1830D4000, v20, receiver, "%{public}s called with null _parameters", buf, 0xCu);
        }
      }
      else if (type)
      {
        uint64_t v29 = (char *)__nw_create_backtrace_string();
        __int16 v20 = __nwlog_obj();
        os_log_type_t v30 = (os_log_type_t)v39.receiver;
        BOOL v31 = os_log_type_enabled(v20, (os_log_type_t)v39.receiver);
        if (v29)
        {
          if (v31)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            __int16 v43 = 2082;
            os_log_type_t v44 = v29;
            _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null _parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v29);
          goto LABEL_55;
        }
        if (v31)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s called with null _parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v20 = __nwlog_obj();
        os_log_type_t v36 = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v20, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_1830D4000, v20, v36, "%{public}s called with null _parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }

LABEL_55:
      if (v19) {
        free(v19);
      }
LABEL_51:

LABEL_63:
      uint64_t v6 = 0;
      goto LABEL_6;
    }
    os_log_type_t v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v39.receiver) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, &v39, &type))
    {
      if (LOBYTE(v39.receiver) == 17)
      {
        char v16 = __nwlog_obj();
        os_log_type_t v17 = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v16, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null _endpoint", buf, 0xCu);
        }
      }
      else if (type)
      {
        BOOL v26 = (char *)__nw_create_backtrace_string();
        char v16 = __nwlog_obj();
        os_log_type_t v27 = (os_log_type_t)v39.receiver;
        BOOL v28 = os_log_type_enabled(v16, (os_log_type_t)v39.receiver);
        if (v26)
        {
          if (v28)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
            __int16 v43 = 2082;
            os_log_type_t v44 = v26;
            _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s called with null _endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v26);
          goto LABEL_49;
        }
        if (v28)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_1830D4000, v16, v27, "%{public}s called with null _endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v16 = __nwlog_obj();
        os_log_type_t v35 = (os_log_type_t)v39.receiver;
        if (os_log_type_enabled(v16, (os_log_type_t)v39.receiver))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v42 = "-[NWConcrete_nw_association initWithEndpoint:parameters:]";
          _os_log_impl(&dword_1830D4000, v16, v35, "%{public}s called with null _endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_49:
    if (v15) {
      free(v15);
    }
    goto LABEL_51;
  }
LABEL_6:

  return v6;
}

void sub_18319F308(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_18319F31C()
{
  JUMPOUT(0x18319F30CLL);
}

void nw_context_add_cache_entry(void *a1, void *a2)
{
  uint64_t v34 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (v3)
  {
    id v4 = v3;
    if (a2)
    {
      id v5 = (dispatch_queue_t *)v3;
      uint64_t v6 = v5;
      if (((_BYTE)v5[17] & 8) == 0) {
        dispatch_assert_queue_V2(v5[1]);
      }

      BOOL v27 = nw_context_copy_cache_context(v6);
      uint64_t v7 = **(void **)(v27 + 24);
      *a2 = v7;
      id v8 = *(void **)(v27 + 24);
      if (v7) {
        id v8 = (void *)*v8;
      }
      v8[1] = a2;
      **(void **)(v27 + 24) = a2;
      a2[1] = *(void *)(v27 + 24);
      uint64_t v9 = *(void *)(*(void *)(v27 + 24) + 16);
      a2[2] = v9;
      os_log_type_t v10 = *(void **)(v27 + 24);
      if (v9) {
        os_log_type_t v10 = (void *)v10[2];
      }
      v10[3] = a2 + 2;
      *(void *)(*(void *)(v27 + 24) + 16) = a2;
      a2[3] = *(void *)(v27 + 24) + 16;
      *(int32x2_t *)(*(void *)(v27 + 24) + 64) = vadd_s32(*(int32x2_t *)(*(void *)(v27 + 24) + 64), (int32x2_t)0x100000001);

      return;
    }
    BOOL v15 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v31 = "nw_context_add_cache_entry";
    char v16 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v16, &type, &v28)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s called with null cache_entry", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v17, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v31 = "nw_context_add_cache_entry";
          __int16 v32 = 2082;
          os_log_type_t v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v17, v23, "%{public}s called with null cache_entry, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_46;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_1830D4000, v17, v23, "%{public}s called with null cache_entry, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v17 = __nwlog_obj();
      os_log_type_t v26 = type;
      if (os_log_type_enabled(v17, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_1830D4000, v17, v26, "%{public}s called with null cache_entry, backtrace limit exceeded", buf, 0xCu);
      }
    }

LABEL_46:
    if (v16) {
      free(v16);
    }

    return;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v31 = "nw_context_add_cache_entry";
  os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v28 = 0;
  if (__nwlog_fault(v12, &type, &v28))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null context", buf, 0xCu);
      }
    }
    else if (v28)
    {
      BOOL v19 = (char *)__nw_create_backtrace_string();
      BOOL v13 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v21 = os_log_type_enabled(v13, type);
      if (v19)
      {
        if (v21)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v31 = "nw_context_add_cache_entry";
          __int16 v32 = 2082;
          os_log_type_t v33 = v19;
          _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v19);
        goto LABEL_41;
      }
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_1830D4000, v13, v20, "%{public}s called with null context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v13 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v31 = "nw_context_add_cache_entry";
        _os_log_impl(&dword_1830D4000, v13, v25, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_41:
  if (v12) {
    free(v12);
  }
}

void sub_18319F8B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_initialize_association(void *a1)
{
  nw_parameters_t v1 = a1;
  long long v2 = v1;
  if (!v1[7])
  {
    id v3 = nw_context_copy_registered_endpoint(v1[5], v1[3]);
    id v4 = v2[3];
    v2[3] = v3;

    id v5 = nw_endpoint_copy_association_with_evaluator(v2[3], v2[4], v2[32]);
    uint64_t v6 = v2[7];
    v2[7] = v5;

    uint64_t v7 = v2[7];
    if (v7)
    {
      id v8 = v2[4];
      int v9 = *((unsigned char *)v2 + 268) & 1;
      v13[0] = MEMORY[0x1E4F143A8];
      v13[1] = 3221225472;
      v13[2] = __nw_endpoint_handler_initialize_association_block_invoke;
      v13[3] = &unk_1E523F9F0;
      os_log_type_t v10 = v2;
      os_log_type_t v14 = v10;
      nw_association_register_internal(v7, v8, v10, v9, 1, v13);
      id v11 = nw_association_copy_current_path(v2[7], v2[4]);
      os_unfair_lock_lock(v10 + 28);
      os_log_type_t v12 = *(void **)&v10[16]._os_unfair_lock_opaque;
      *(void *)&v10[16]._int os_unfair_lock_opaque = v11;

      os_unfair_lock_unlock(v10 + 28);
    }
    *((unsigned char *)v2 + 268) |= 4u;
  }
}

void sub_18319FA08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

id *nw_endpoint_copy_association_with_evaluator(void *a1, void *a2, void *a3)
{
  uint64_t v73 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = a3;
  id v8 = v7;
  if (!v5)
  {
    id v41 = v7;
    uint64_t v42 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
    __int16 v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (!__nwlog_fault(v43, &type, &v68)) {
      goto LABEL_69;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v45 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_1830D4000, v44, v45, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v68)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v49 = type;
      BOOL v50 = os_log_type_enabled(v44, type);
      if (backtrace_string)
      {
        if (v50)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v44, v49, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_69:
        if (!v43)
        {
LABEL_71:
          BOOL v15 = 0;
          id v8 = v41;
          goto LABEL_30;
        }
LABEL_70:
        free(v43);
        goto LABEL_71;
      }
      if (v50)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_1830D4000, v44, v49, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v54 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_1830D4000, v44, v54, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_68:

    goto LABEL_69;
  }
  if (!v6)
  {
    id v41 = v7;
    int v46 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
    __int16 v43 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (!__nwlog_fault(v43, &type, &v68)) {
      goto LABEL_69;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_1830D4000, v44, v47, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v68)
    {
      id v51 = (char *)__nw_create_backtrace_string();
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v52 = type;
      BOOL v53 = os_log_type_enabled(v44, type);
      if (v51)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = v51;
          _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v51);
        if (!v43) {
          goto LABEL_71;
        }
        goto LABEL_70;
      }
      if (v53)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_1830D4000, v44, v52, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v44 = __nwlog_obj();
      os_log_type_t v55 = type;
      if (os_log_type_enabled(v44, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        _os_log_impl(&dword_1830D4000, v44, v55, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_68;
  }
  if (*((void *)v5 + 1))
  {
    int v9 = v6;
    id v10 = *(id *)(v9[13] + 136);

    uint64_t v67 = v8;
    nw_context_assert_queue(v10);
    if ((nw_context_caches_are_shared(v10, *((void **)v5 + 1)) & 1) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v12 = (id)gLogObj;
      if (os_log_type_enabled(v12, OS_LOG_TYPE_INFO))
      {
        BOOL v24 = (void *)*((void *)v5 + 1);
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_copy_association_with_evaluator";
        *(_WORD *)&buf[12] = 2112;
        *(void *)&buf[14] = v10;
        *(_WORD *)&buf[22] = 2112;
        uint32_t v71 = v24;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_INFO, "%{public}s nw_context_caches_are_shared(context (%@), endpoint->context (%@)) is false", buf, 0x20u);
      }
      BOOL v15 = 0;
      goto LABEL_29;
    }
    if (!*((void *)v5 + 25))
    {
      uint64_t internal = nw_hash_table_create_internal(5u, 0, (const void *(*)(const void *, unsigned int *))nw_endpoint_association_get_key, (unsigned int (*)(const void *, unsigned int))nw_endpoint_association_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_endpoint_association_matches_key, (void (*)(void *))nw_endpoint_association_release);
      if (internal) {
        *(_DWORD *)(internal + 48) &= ~2u;
      }
      *((void *)v5 + 25) = internal;
    }
    os_log_type_t v12 = nw_parameters_copy_path_parameters(v9, 0);
    uint64_t node = nw_hash_table_get_node(*((void *)v5 + 25), (uint64_t)v12, 0);
    if (!node)
    {
      os_log_type_t type = OS_LOG_TYPE_DEFAULT;
      id v25 = v5;
      os_log_type_t v26 = v9;
      id v27 = v8;
      uint32_t v64 = v25;
      os_log_type_t v65 = v26;
      char v28 = nw_association_create(v25, v26);
      uint64_t v29 = v28;
      if (v27)
      {
        p_evaluator = (void **)&v28->evaluator;
        objc_storeStrong((id *)&v28->evaluator, a3);
        *((unsigned char *)v29 + 76) &= ~1u;
        BOOL v31 = (os_unfair_lock_s *)*p_evaluator;
        if (*p_evaluator)
        {
          __int16 v32 = v31 + 24;
          os_log_type_t v33 = v31;
          os_unfair_lock_lock(v32);
          id v34 = v33[6];
          os_unfair_lock_unlock(v32);
        }
        else
        {
          id v34 = 0;
        }
        os_log_type_t v35 = (OS_nw_path *)nw_path_copy_without_parameters(v34);
        previous_path = v29->previous_path;
        v29->previous_path = v35;

        evaluator = v29->evaluator;
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_association_create_with_evaluator_block_invoke;
        uint32_t v71 = &unk_1E524AEE0;
        os_log_type_t v72 = v29;
        nw_path_evaluator_set_update_handler(evaluator, 0, buf);
      }
      uint64_t v38 = *((void *)v5 + 25);
      BOOL v15 = v29;
      nw_hash_table_add_object(v38, (uint64_t)v15, (char *)&type);
      goto LABEL_29;
    }
    os_log_type_t v14 = (id *)*(id *)(node + 16);
    BOOL v15 = v14;
    if (!v8)
    {
LABEL_29:

      id v8 = v67;
      goto LABEL_30;
    }
    BOOL v15 = v14;
    id v16 = v8;
    if (v15)
    {
      if (*((unsigned char *)v15 + 76))
      {
        id v17 = v16;
        objc_storeStrong(v15 + 3, a3);
        *((unsigned char *)v15 + 76) &= ~1u;
        os_log_type_t v18 = (os_unfair_lock_s *)v15[3];
        if (v18)
        {
          BOOL v19 = v18 + 24;
          os_log_type_t v20 = v18;
          os_unfair_lock_lock(v19);
          id v21 = v20[6];
          os_unfair_lock_unlock(v19);

          if (v21)
          {
            uint64_t v22 = nw_path_copy_without_parameters(v21);
            id v23 = v15[4];
            v15[4] = v22;
          }
        }
        else
        {
          id v21 = 0;
        }
        id v39 = v15[3];
        *(void *)buf = MEMORY[0x1E4F143A8];
        *(void *)&uint8_t buf[8] = 3221225472;
        *(void *)&buf[16] = __nw_association_update_with_evaluator_block_invoke;
        uint32_t v71 = &unk_1E524AEE0;
        os_log_type_t v72 = v15;
        nw_path_evaluator_set_update_handler(v39, 0, buf);

        id v16 = v17;
      }
LABEL_28:

      goto LABEL_29;
    }
    id v66 = v16;
    uint32_t v56 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
    int v57 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v68 = 0;
    if (__nwlog_fault(v57, &type, &v68))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v58 = __nwlog_obj();
        os_log_type_t v59 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_1830D4000, v58, v59, "%{public}s called with null association", buf, 0xCu);
        }
      }
      else if (v68)
      {
        BOOL v60 = (char *)__nw_create_backtrace_string();
        uint64_t v58 = __nwlog_obj();
        os_log_type_t v61 = type;
        BOOL v62 = os_log_type_enabled(v58, type);
        if (v60)
        {
          if (v62)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
            *(_WORD *)&buf[12] = 2082;
            *(void *)&buf[14] = v60;
            _os_log_impl(&dword_1830D4000, v58, v61, "%{public}s called with null association, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v60);
          goto LABEL_83;
        }
        if (v62)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_1830D4000, v58, v61, "%{public}s called with null association, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v58 = __nwlog_obj();
        os_log_type_t v63 = type;
        if (os_log_type_enabled(v58, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_association_update_with_evaluator";
          _os_log_impl(&dword_1830D4000, v58, v63, "%{public}s called with null association, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_83:
    if (v57) {
      free(v57);
    }
    id v16 = v66;
    goto LABEL_28;
  }
  BOOL v15 = 0;
LABEL_30:

  return v15;
}

void sub_1831A04CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, void *a15)
{
  _Unwind_Resume(a1);
}

id nw_parameters_copy_path_parameters(void *a1, int a2)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    uint64_t v5 = v3[19];
    if (v5)
    {
      id v6 = *(void **)(v5 + 24);
      if (a2)
      {
        if (v6)
        {
          id v7 = nw_protocol_options_copy(*(void **)(v5 + 24));
          uint64_t v8 = *((void *)v4 + 13);
          int v9 = *(void **)(v8 + 144);
          *(void *)(v8 + 144) = v7;

          uint64_t v5 = *((void *)v4 + 19);
        }
        id v10 = *(void **)(v5 + 48);
        if (!v10) {
          goto LABEL_10;
        }
        id v11 = nw_protocol_options_copy(v10);
        uint64_t v12 = *((void *)v4 + 13);
        BOOL v13 = *(void **)(v12 + 152);
        *(void *)(v12 + 152) = v11;
      }
      else
      {
        objc_storeStrong((id *)(v3[13] + 144), v6);
        uint64_t v14 = *((void *)v4 + 13);
        id v15 = *(id *)(*((void *)v4 + 19) + 48);
        BOOL v13 = *(void **)(v14 + 152);
        *(void *)(v14 + 152) = v15;
      }
    }
LABEL_10:
    id v16 = *((id *)v4 + 13);
    goto LABEL_11;
  }
  os_log_type_t v18 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v29 = "nw_parameters_copy_path_parameters";
  BOOL v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (__nwlog_fault(v19, &type, &v26))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_copy_path_parameters";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v26)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v23 = type;
      BOOL v24 = os_log_type_enabled(v20, type);
      if (backtrace_string)
      {
        if (v24)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v29 = "nw_parameters_copy_path_parameters";
          __int16 v30 = 2082;
          BOOL v31 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v24)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_copy_path_parameters";
        _os_log_impl(&dword_1830D4000, v20, v23, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v20 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v29 = "nw_parameters_copy_path_parameters";
        _os_log_impl(&dword_1830D4000, v20, v25, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_28:
  if (v19) {
    free(v19);
  }
  id v16 = 0;
LABEL_11:

  return v16;
}

void sub_1831A0878(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_context_caches_are_shared(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (v3 == v4) {
    goto LABEL_12;
  }
  if (nw_context_get_isolate_protocol_cache(v3))
  {
    char v5 = v3[136];
    if ((v5 & 4) == 0) {
      goto LABEL_7;
    }
  }
  if (!nw_context_get_isolate_protocol_cache(v4) || (v4[136] & 4) != 0)
  {
LABEL_12:
    uint64_t v6 = 1;
    goto LABEL_13;
  }
  char v5 = v3[136];
LABEL_7:
  if ((v5 & 0x20) != 0 && *((unsigned char **)v4 + 5) == v3 || (v4[136] & 0x20) != 0 && *((unsigned char **)v3 + 5) == v4) {
    goto LABEL_12;
  }
  uint64_t v6 = 0;
LABEL_13:

  return v6;
}

id nw_context_copy_registered_endpoint(void *a1, void *a2)
{
  uint64_t v27 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  char v5 = v4;
  if (v3)
  {
    if (v4)
    {
      if (((_BYTE)v3[17] & 8) == 0) {
        dispatch_assert_queue_V2(v3[1]);
      }
      id v6 = nw_context_copy_registered_endpoint_internal(v3, v5, 0);
      goto LABEL_6;
    }
    uint64_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v24 = "nw_context_copy_registered_endpoint";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null endpoint", buf, 0xCu);
        }
LABEL_38:

        goto LABEL_39;
      }
      if (!v21)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v10, v20, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v10 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v24 = "nw_context_copy_registered_endpoint";
        __int16 v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v17, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_26;
    }
  }
  else
  {
    uint64_t v8 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v24 = "nw_context_copy_registered_endpoint";
    int v9 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v21 = 0;
    if (__nwlog_fault(v9, &type, &v21))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null context", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (!v21)
      {
        id v10 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v10, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v10, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_38;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v10, type);
      if (!backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v24 = "nw_context_copy_registered_endpoint";
          _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
        goto LABEL_38;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v24 = "nw_context_copy_registered_endpoint";
        __int16 v25 = 2082;
        char v26 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_26:

      free(backtrace_string);
    }
  }
LABEL_39:
  if (v9) {
    free(v9);
  }
  id v6 = 0;
LABEL_6:

  return v6;
}

void sub_1831A0E00(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_context_copy_registered_endpoint_internal(void *a1, void *a2, int a3)
{
  uint64_t v126 = *MEMORY[0x1E4F143B8];
  char v5 = a1;
  id v6 = a2;
  id v7 = v6;
  if (!v5)
  {
    uint64_t v85 = __nwlog_obj();
    *(_DWORD *)unsigned int v119 = 136446210;
    *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
    os_log_type_t v86 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v86, buf, &type))
    {
      if (buf[0] == 17)
      {
        BOOL v87 = __nwlog_obj();
        os_log_type_t v88 = buf[0];
        if (os_log_type_enabled(v87, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v87, v88, "%{public}s called with null context", v119, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v87 = __nwlog_obj();
        os_log_type_t v98 = buf[0];
        BOOL v99 = os_log_type_enabled(v87, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v99)
          {
            *(_DWORD *)unsigned int v119 = 136446466;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2082;
            *(void *)&v119[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v87, v98, "%{public}s called with null context, dumping backtrace:%{public}s", v119, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_158;
        }
        if (v99)
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v87, v98, "%{public}s called with null context, no backtrace", v119, 0xCu);
        }
      }
      else
      {
        BOOL v87 = __nwlog_obj();
        os_log_type_t v113 = buf[0];
        if (os_log_type_enabled(v87, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v87, v113, "%{public}s called with null context, backtrace limit exceeded", v119, 0xCu);
        }
      }
    }
LABEL_158:
    if (v86) {
      free(v86);
    }
    goto LABEL_172;
  }
  if (!v6)
  {
    os_log_type_t v89 = __nwlog_obj();
    *(_DWORD *)unsigned int v119 = 136446210;
    *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
    os_log_type_t v90 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v90, buf, &type))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v92 = buf[0];
        if (os_log_type_enabled(v91, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v91, v92, "%{public}s called with null endpoint", v119, 0xCu);
        }
      }
      else if (type)
      {
        int v100 = (char *)__nw_create_backtrace_string();
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v101 = buf[0];
        BOOL v102 = os_log_type_enabled(v91, (os_log_type_t)buf[0]);
        if (v100)
        {
          if (v102)
          {
            *(_DWORD *)unsigned int v119 = 136446466;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2082;
            *(void *)&v119[14] = v100;
            _os_log_impl(&dword_1830D4000, v91, v101, "%{public}s called with null endpoint, dumping backtrace:%{public}s", v119, 0x16u);
          }

          free(v100);
          goto LABEL_163;
        }
        if (v102)
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v91, v101, "%{public}s called with null endpoint, no backtrace", v119, 0xCu);
        }
      }
      else
      {
        os_log_type_t v91 = __nwlog_obj();
        os_log_type_t v114 = buf[0];
        if (os_log_type_enabled(v91, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v91, v114, "%{public}s called with null endpoint, backtrace limit exceeded", v119, 0xCu);
        }
      }
    }
LABEL_163:
    if (v90) {
      free(v90);
    }
    goto LABEL_171;
  }
  uint64_t v8 = v5;
  int v9 = v8;
  if ((*((unsigned char *)v8 + 136) & 8) == 0) {
    dispatch_assert_queue_V2(*((dispatch_queue_t *)v8 + 1));
  }

  if (a3) {
    BOOL v10 = nw_context_copy_globals_context(v9);
  }
  else {
    BOOL v10 = nw_context_copy_cache_context(v9);
  }
  char v5 = (void *)v10;

  id v11 = v7;
  int v12 = [v11 type];

  if (v12 == 2)
  {
    os_log_type_t v13 = (uint64_t *)(v5[3] + 40);
  }
  else if (v12 == 1)
  {
    os_log_type_t v13 = (uint64_t *)(v5[3] + 32);
  }
  else
  {
    os_log_type_t v13 = (uint64_t *)(v5[3] + 48);
  }
  uint64_t v14 = *v13;
  if (!*v13)
  {
    int v93 = __nwlog_obj();
    *(_DWORD *)unsigned int v119 = 136446210;
    *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
    uint64_t v94 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v94, buf, &type))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v95 = __nwlog_obj();
        os_log_type_t v96 = buf[0];
        if (os_log_type_enabled(v95, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s called with null hash_table", v119, 0xCu);
        }
      }
      else if (type)
      {
        os_log_type_t v107 = (char *)__nw_create_backtrace_string();
        os_log_type_t v95 = __nwlog_obj();
        os_log_type_t v108 = buf[0];
        BOOL v109 = os_log_type_enabled(v95, (os_log_type_t)buf[0]);
        if (v107)
        {
          if (v109)
          {
            *(_DWORD *)unsigned int v119 = 136446466;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2082;
            *(void *)&v119[14] = v107;
            _os_log_impl(&dword_1830D4000, v95, v108, "%{public}s called with null hash_table, dumping backtrace:%{public}s", v119, 0x16u);
          }

          free(v107);
          goto LABEL_169;
        }
        if (v109)
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v95, v108, "%{public}s called with null hash_table, no backtrace", v119, 0xCu);
        }
      }
      else
      {
        os_log_type_t v95 = __nwlog_obj();
        os_log_type_t v115 = buf[0];
        if (os_log_type_enabled(v95, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)unsigned int v119 = 136446210;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          _os_log_impl(&dword_1830D4000, v95, v115, "%{public}s called with null hash_table, backtrace limit exceeded", v119, 0xCu);
        }
      }
    }
LABEL_169:
    if (v94) {
      free(v94);
    }
LABEL_171:

LABEL_172:
    id v29 = 0;
    goto LABEL_57;
  }
  os_log_type_t v15 = v5;
  BOOL v16 = v15;
  if ((v15[17] & 7) != 0)
  {
    if (*(void *)(v15[3] + 56)) {
      goto LABEL_28;
    }
    *(void *)unsigned int v119 = MEMORY[0x1E4F143A8];
    *(void *)&v119[8] = 3221225472;
    *(void *)&v119[16] = ___ZL28nw_context_start_purge_timerP21NWConcrete_nw_context_block_invoke;
    __int16 v120 = (const char *)&unk_1E524BAA8;
    os_log_type_t v17 = v15;
    v121[0] = v17;
    *(void *)(v16[3] + 56) = nw_queue_context_create_source(v17, 2, 3, 0, v119, 0);
    uint64_t v18 = *(void *)(v16[3] + 56);
    if (v18)
    {
      int64_t v19 = v17[13];
      if (!v19)
      {
        int64_t v19 = 1000 * networkd_settings_get_int64_with_default((const char *)nw_setting_context_purge_delay, 30);
        uint64_t v18 = *(void *)(v16[3] + 56);
      }
      uint64_t v20 = 1000000 * v19;
      dispatch_time_t v21 = dispatch_time(0x8000000000000000, 1000000 * v19);
      nw_queue_set_timer_values(v18, v21, v20, v20);
      nw_queue_activate_source(*(void *)(v16[3] + 56));
      goto LABEL_27;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v22 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    BOOL v123 = "nw_context_start_purge_timer";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v117 = 0;
    if (__nwlog_fault(v23, &type, &v117))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v24 = (id)gLogObj;
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v123 = "nw_context_start_purge_timer";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_queue_context_create_source failed", buf, 0xCu);
        }
      }
      else if (v117)
      {
        uint32_t v64 = __nw_create_backtrace_string();
        if (v64)
        {
          os_log_type_t v65 = (char *)v64;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v66 = (id)gLogObj;
          os_log_type_t v67 = type;
          if (os_log_type_enabled(v66, type))
          {
            *(_DWORD *)buf = 136446466;
            BOOL v123 = "nw_context_start_purge_timer";
            __int16 v124 = 2082;
            os_log_type_t v125 = v65;
            _os_log_impl(&dword_1830D4000, v66, v67, "%{public}s nw_queue_context_create_source failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v65);
          if (!v23) {
            goto LABEL_27;
          }
          goto LABEL_26;
        }
        BOOL v24 = __nwlog_obj();
        os_log_type_t v83 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v123 = "nw_context_start_purge_timer";
          _os_log_impl(&dword_1830D4000, v24, v83, "%{public}s nw_queue_context_create_source failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v24 = (id)gLogObj;
        os_log_type_t v76 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v123 = "nw_context_start_purge_timer";
          _os_log_impl(&dword_1830D4000, v24, v76, "%{public}s nw_queue_context_create_source failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
    if (!v23)
    {
LABEL_27:

      goto LABEL_28;
    }
LABEL_26:
    free(v23);
    goto LABEL_27;
  }
  os_log_type_t v103 = __nwlog_obj();
  *(_DWORD *)unsigned int v119 = 136446210;
  *(void *)&v119[4] = "nw_context_start_purge_timer";
  BOOL v104 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v104, buf, &type))
  {
    if (buf[0] == 17)
    {
      uint64_t v105 = __nwlog_obj();
      os_log_type_t v106 = buf[0];
      if (os_log_type_enabled(v105, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)unsigned int v119 = 136446210;
        *(void *)&v119[4] = "nw_context_start_purge_timer";
        _os_log_impl(&dword_1830D4000, v105, v106, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context))", v119, 0xCu);
      }
    }
    else if (type)
    {
      unint64_t v110 = (char *)__nw_create_backtrace_string();
      uint64_t v105 = __nwlog_obj();
      os_log_type_t v111 = buf[0];
      BOOL v112 = os_log_type_enabled(v105, (os_log_type_t)buf[0]);
      if (v110)
      {
        if (v112)
        {
          *(_DWORD *)unsigned int v119 = 136446466;
          *(void *)&v119[4] = "nw_context_start_purge_timer";
          *(_WORD *)&v119[12] = 2082;
          *(void *)&v119[14] = v110;
          _os_log_impl(&dword_1830D4000, v105, v111, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), dumping backtrace:%{public}s", v119, 0x16u);
        }

        free(v110);
        goto LABEL_179;
      }
      if (v112)
      {
        *(_DWORD *)unsigned int v119 = 136446210;
        *(void *)&v119[4] = "nw_context_start_purge_timer";
        _os_log_impl(&dword_1830D4000, v105, v111, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), no backtrace", v119, 0xCu);
      }
    }
    else
    {
      uint64_t v105 = __nwlog_obj();
      os_log_type_t v116 = buf[0];
      if (os_log_type_enabled(v105, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)unsigned int v119 = 136446210;
        *(void *)&v119[4] = "nw_context_start_purge_timer";
        _os_log_impl(&dword_1830D4000, v105, v116, "%{public}s called with null (context->is_implicit || nw_context_get_isolate_protocol_cache(context)), backtrace limit exceeded", v119, 0xCu);
      }
    }
  }
LABEL_179:
  if (v104) {
    free(v104);
  }
LABEL_28:

  uint64_t node = nw_hash_table_get_node(v14, (uint64_t)v11, 0);
  if (!node)
  {
    BOOL internal = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_context_object_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_endpoint_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_endpoint_matches_key, (void (*)(void *))nw_context_object_release);
    id v31 = v11;
    uint64_t v32 = (void *)[v31 copyEndpoint];
    nw_endpoint_copy_properties(v31, v32);

    nw_endpoint_set_context(v32, v16);
    nw_endpoint_set_is_registered(v32);
    buf[0] = 0;
    id v29 = v32;
    nw_hash_table_add_object(internal, (uint64_t)v29, (char *)buf);
    if (buf[0]) {
      goto LABEL_39;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v33 = (id)gLogObj;
    logging_description = nw_endpoint_get_logging_description(v29);
    *(_DWORD *)unsigned int v119 = 136446722;
    *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
    *(_WORD *)&v119[12] = 2114;
    *(void *)&v119[14] = v16;
    *(_WORD *)&v119[22] = 2082;
    __int16 v120 = logging_description;
    os_log_type_t v35 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v117 = 0;
    if (__nwlog_fault((const char *)v35, &type, &v117))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v36 = (id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          uint64_t v38 = nw_endpoint_get_logging_description(v29);
          *(_DWORD *)unsigned int v119 = 136446722;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v16;
          *(_WORD *)&v119[22] = 2082;
          __int16 v120 = v38;
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s %{public}@ failed to add endpoint %{public}s", v119, 0x20u);
        }
      }
      else if (v117)
      {
        os_log_type_t v54 = __nw_create_backtrace_string();
        if (v54)
        {
          os_log_type_t v55 = (char *)v54;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint32_t v56 = (id)gLogObj;
          os_log_type_t v57 = type;
          if (os_log_type_enabled(v56, type))
          {
            uint64_t v58 = nw_endpoint_get_logging_description(v29);
            *(_DWORD *)unsigned int v119 = 136446978;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v16;
            *(_WORD *)&v119[22] = 2082;
            __int16 v120 = v58;
            LOWORD(v121[0]) = 2082;
            *(id *)((char *)v121 + 2) = v55;
            _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s %{public}@ failed to add endpoint %{public}s, dumping backtrace:%{public}s", v119, 0x2Au);
          }

          free(v55);
          if (!v35)
          {
LABEL_39:
            nw_hash_table_add_object(v14, internal, (char *)buf);
            if (buf[0]) {
              goto LABEL_56;
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v39 = (id)gLogObj;
            uint64_t v40 = nw_endpoint_get_logging_description(v29);
            *(_DWORD *)unsigned int v119 = 136446722;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v16;
            *(_WORD *)&v119[22] = 2082;
            __int16 v120 = v40;
            id v41 = (char *)_os_log_send_and_compose_impl();

            os_log_type_t type = OS_LOG_TYPE_ERROR;
            char v117 = 0;
            if (__nwlog_fault(v41, &type, &v117))
            {
              if (type == OS_LOG_TYPE_FAULT)
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v42 = (id)gLogObj;
                os_log_type_t v43 = type;
                if (os_log_type_enabled(v42, type))
                {
                  os_log_type_t v44 = nw_endpoint_get_logging_description(v29);
                  *(_DWORD *)unsigned int v119 = 136446722;
                  *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
                  *(_WORD *)&v119[12] = 2114;
                  *(void *)&v119[14] = v16;
                  *(_WORD *)&v119[22] = 2082;
                  __int16 v120 = v44;
                  _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s", v119, 0x20u);
                }
              }
              else if (v117)
              {
                os_log_type_t v59 = __nw_create_backtrace_string();
                if (v59)
                {
                  BOOL v60 = (char *)v59;
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  os_log_type_t v61 = (id)gLogObj;
                  os_log_type_t v62 = type;
                  if (os_log_type_enabled(v61, type))
                  {
                    os_log_type_t v63 = nw_endpoint_get_logging_description(v29);
                    *(_DWORD *)unsigned int v119 = 136446978;
                    *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
                    *(_WORD *)&v119[12] = 2114;
                    *(void *)&v119[14] = v16;
                    *(_WORD *)&v119[22] = 2082;
                    __int16 v120 = v63;
                    LOWORD(v121[0]) = 2082;
                    *(id *)((char *)v121 + 2) = v60;
                    _os_log_impl(&dword_1830D4000, v61, v62, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s, dumping backtrace:%{public}s", v119, 0x2Au);
                  }

                  free(v60);
                  if (!v41) {
                    goto LABEL_56;
                  }
                  goto LABEL_46;
                }
                uint64_t v42 = __nwlog_obj();
                os_log_type_t v81 = type;
                if (os_log_type_enabled(v42, type))
                {
                  id v82 = nw_endpoint_get_logging_description(v29);
                  *(_DWORD *)unsigned int v119 = 136446722;
                  *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
                  *(_WORD *)&v119[12] = 2114;
                  *(void *)&v119[14] = v16;
                  *(_WORD *)&v119[22] = 2082;
                  __int16 v120 = v82;
                  _os_log_impl(&dword_1830D4000, v42, v81, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s, no backtrace", v119, 0x20u);
                }
              }
              else
              {
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v42 = (id)gLogObj;
                os_log_type_t v74 = type;
                if (os_log_type_enabled(v42, type))
                {
                  uint32_t v75 = nw_endpoint_get_logging_description(v29);
                  *(_DWORD *)unsigned int v119 = 136446722;
                  *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
                  *(_WORD *)&v119[12] = 2114;
                  *(void *)&v119[14] = v16;
                  *(_WORD *)&v119[22] = 2082;
                  __int16 v120 = v75;
                  _os_log_impl(&dword_1830D4000, v42, v74, "%{public}s %{public}@ failed to add hash table for endpoint %{public}s, backtrace limit exceeded", v119, 0x20u);
                }
              }
            }
            if (!v41) {
              goto LABEL_56;
            }
LABEL_46:
            free(v41);
            goto LABEL_56;
          }
LABEL_38:
          free(v35);
          goto LABEL_39;
        }
        os_log_type_t v36 = __nwlog_obj();
        os_log_type_t v77 = type;
        if (os_log_type_enabled(v36, type))
        {
          int v78 = nw_endpoint_get_logging_description(v29);
          *(_DWORD *)unsigned int v119 = 136446722;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v16;
          *(_WORD *)&v119[22] = 2082;
          __int16 v120 = v78;
          _os_log_impl(&dword_1830D4000, v36, v77, "%{public}s %{public}@ failed to add endpoint %{public}s, no backtrace", v119, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v36 = (id)gLogObj;
        os_log_type_t v72 = type;
        if (os_log_type_enabled(v36, type))
        {
          uint64_t v73 = nw_endpoint_get_logging_description(v29);
          *(_DWORD *)unsigned int v119 = 136446722;
          *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
          *(_WORD *)&v119[12] = 2114;
          *(void *)&v119[14] = v16;
          *(_WORD *)&v119[22] = 2082;
          __int16 v120 = v73;
          _os_log_impl(&dword_1830D4000, v36, v72, "%{public}s %{public}@ failed to add endpoint %{public}s, backtrace limit exceeded", v119, 0x20u);
        }
      }
    }
    if (!v35) {
      goto LABEL_39;
    }
    goto LABEL_38;
  }
  uint64_t v27 = *(void *)(node + 16);
  uint64_t v28 = nw_hash_table_get_node(v27, (uint64_t)v11, 0);
  if (!v28)
  {
    buf[0] = 0;
    id v45 = v11;
    int v46 = (void *)[v45 copyEndpoint];
    nw_endpoint_copy_properties(v45, v46);

    nw_endpoint_set_context(v46, v16);
    nw_endpoint_set_is_registered(v46);
    id v29 = v46;
    nw_hash_table_add_object(v27, (uint64_t)v29, (char *)buf);
    if (!buf[0])
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v47 = (id)gLogObj;
      int v48 = nw_endpoint_get_logging_description(v29);
      *(_DWORD *)unsigned int v119 = 136446722;
      *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
      *(_WORD *)&v119[12] = 2114;
      *(void *)&v119[14] = v16;
      *(_WORD *)&v119[22] = 2082;
      __int16 v120 = v48;
      os_log_type_t v49 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v117 = 0;
      if (__nwlog_fault(v49, &type, &v117))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v50 = (id)gLogObj;
          os_log_type_t v51 = type;
          if (os_log_type_enabled(v50, type))
          {
            os_log_type_t v52 = nw_endpoint_get_logging_description(v29);
            *(_DWORD *)unsigned int v119 = 136446722;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v16;
            *(_WORD *)&v119[22] = 2082;
            __int16 v120 = v52;
            _os_log_impl(&dword_1830D4000, v50, v51, "%{public}s %{public}@ failed to add endpoint %{public}s", v119, 0x20u);
          }
        }
        else if (v117)
        {
          char v68 = (char *)__nw_create_backtrace_string();
          BOOL v50 = __nwlog_obj();
          os_log_type_t v69 = type;
          BOOL v70 = os_log_type_enabled(v50, type);
          if (v68)
          {
            if (v70)
            {
              uint32_t v71 = nw_endpoint_get_logging_description(v29);
              *(_DWORD *)unsigned int v119 = 136446978;
              *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
              *(_WORD *)&v119[12] = 2114;
              *(void *)&v119[14] = v16;
              *(_WORD *)&v119[22] = 2082;
              __int16 v120 = v71;
              LOWORD(v121[0]) = 2082;
              *(id *)((char *)v121 + 2) = v68;
              _os_log_impl(&dword_1830D4000, v50, v69, "%{public}s %{public}@ failed to add endpoint %{public}s, dumping backtrace:%{public}s", v119, 0x2Au);
            }

            free(v68);
            if (!v49) {
              goto LABEL_56;
            }
            goto LABEL_55;
          }
          if (v70)
          {
            os_log_type_t v84 = nw_endpoint_get_logging_description(v29);
            *(_DWORD *)unsigned int v119 = 136446722;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v16;
            *(_WORD *)&v119[22] = 2082;
            __int16 v120 = v84;
            _os_log_impl(&dword_1830D4000, v50, v69, "%{public}s %{public}@ failed to add endpoint %{public}s, no backtrace", v119, 0x20u);
          }
        }
        else
        {
          BOOL v50 = __nwlog_obj();
          os_log_type_t v79 = type;
          if (os_log_type_enabled(v50, type))
          {
            os_log_type_t v80 = nw_endpoint_get_logging_description(v29);
            *(_DWORD *)unsigned int v119 = 136446722;
            *(void *)&v119[4] = "nw_context_copy_registered_endpoint_internal";
            *(_WORD *)&v119[12] = 2114;
            *(void *)&v119[14] = v16;
            *(_WORD *)&v119[22] = 2082;
            __int16 v120 = v80;
            _os_log_impl(&dword_1830D4000, v50, v79, "%{public}s %{public}@ failed to add endpoint %{public}s, backtrace limit exceeded", v119, 0x20u);
          }
        }
      }
      if (v49) {
LABEL_55:
      }
        free(v49);
    }
LABEL_56:

    goto LABEL_57;
  }
  id v29 = *(id *)(v28 + 16);

LABEL_57:
  return v29;
}

void sub_1831A25E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_context_copy_cache_context(void *a1)
{
  nw_parameters_t v1 = a1;
  long long v2 = v1;
  if ((v1[136] & 4) != 0 || (id v3 = v1, v4 = v2[136] & 3, v3, v4))
  {
    char v5 = (void *)*((void *)v2 + 5);
    if (!v5) {
      char v5 = v2;
    }
  }
  else
  {
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    char v5 = (void *)nw_context_copy_implicit_context::implicit_context;
  }
  id v6 = v5;
  if (v6[3]) {
    goto LABEL_8;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v7 = (id)gLogObj;
  os_log_type_enabled(v7, OS_LOG_TYPE_ERROR);
  uint64_t v8 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v8);
  if (!result)
  {
    free(v8);
LABEL_8:

    return (BOOL)v6;
  }
  __break(1u);
  return result;
}

void nw_endpoint_set_is_registered(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  long long v2 = v1;
  if (v1)
  {
    *((unsigned char *)v1 + 231) |= 4u;
    goto LABEL_3;
  }
  id v3 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v14 = "nw_endpoint_set_is_registered";
  int v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v5 = __nwlog_obj();
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_endpoint_set_is_registered";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v5 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v14 = "nw_endpoint_set_is_registered";
          __int16 v15 = 2082;
          BOOL v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_endpoint_set_is_registered";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v5 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v14 = "nw_endpoint_set_is_registered";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v4) {
    free(v4);
  }
LABEL_3:
}

uint64_t tcp_connection_fillout_event_locked(void *a1, uint64_t a2, int a3, const void *a4, size_t a5, uint64_t a6)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  char v11 = a1;
  int v12 = v11;
  if (*((unsigned __int8 *)v11 + 156) == 255) {
    goto LABEL_51;
  }
  if (a3 == 3)
  {
    *((unsigned char *)v11 + 156) = 3;
    *((unsigned char *)v11 + 158) |= 0x30u;
  }
  if (v11[8])
  {
    os_log_type_t v13 = v11;
    switch(a3)
    {
      case 1:
        if ((v13[158] & 4) != 0) {
          goto LABEL_18;
        }
        char v14 = v13[158] | 4;
        goto LABEL_16;
      case 2:
        if (v13[158]) {
          goto LABEL_18;
        }
        char v14 = v13[158] | 1;
        goto LABEL_16;
      case 3:
        if ((v13[158] & 8) != 0) {
          goto LABEL_18;
        }
        char v14 = v13[158] | 8;
        goto LABEL_16;
      case 4:
        if ((v13[158] & 2) != 0)
        {
LABEL_18:
          int v15 = 0;
        }
        else
        {
          char v14 = v13[158] | 2;
LABEL_16:
          v13[158] = v14;
LABEL_17:
          int v15 = 1;
        }

        if (a3 != 7) {
          goto LABEL_20;
        }
        goto LABEL_21;
      default:
        goto LABEL_17;
    }
  }
  int v15 = 0;
  if (a3 != 7)
  {
LABEL_20:
    if (a3 != 1) {
      goto LABEL_23;
    }
  }
LABEL_21:
  BOOL v16 = v12[10];
  if (v16)
  {
    dispatch_source_cancel(v16);
    uint64_t v17 = (void *)v12[10];
    v12[10] = 0;
  }
LABEL_23:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v18 = (id)gLogObj;
  if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
  {
    size_t v21 = v12[12];
    if (!(!v20 & v19))
    {
      switch(a3)
      {
        case 1073741825:
          id v22 = "TCP_CONNECTION_EVENT_KEEPALIVE";
          goto LABEL_45;
        case 1073741826:
          id v22 = "TCP_CONNECTION_EVENT_CONDITIONS_CHANGED";
          goto LABEL_45;
        case 1073741827:
          id v22 = "TCP_CONNECTION_EVENT_DNSSEC";
          goto LABEL_45;
        case 1073741828:
          id v22 = "TCP_CONNECTION_EVENT_ADAPTIVE_READ_TIMEOUT";
          goto LABEL_45;
        case 1073741829:
          id v22 = "TCP_CONNECTION_EVENT_ADAPTIVE_WRITE_TIMEOUT";
          goto LABEL_45;
        case 1073741830:
          id v22 = "TCP_CONNECTION_EVENT_LOW_THROUGHPUT";
          goto LABEL_45;
        case 1073741831:
          id v22 = "TCP_CONNECTION_EVENT_BETTER_ROUTE_CHANGED";
          goto LABEL_45;
        case 1073741832:
          id v22 = "TCP_CONNECTION_EVENT_CONNECTION_ATTEMPT_TIMEOUT";
          goto LABEL_45;
        case 1073741833:
          id v22 = "TCP_CONNECTION_EVENT_CONNECTION_QUALITY_CHANGED";
          goto LABEL_45;
        default:
          goto LABEL_60;
      }
    }
    id v22 = "TCP_CONNECTION_EVENT_CONNECTED";
    switch(a3)
    {
      case 1:
        break;
      case 2:
        id v22 = "TCP_CONNECTION_EVENT_READ_CLOSE";
        break;
      case 3:
        id v22 = "TCP_CONNECTION_EVENT_DISCONNECTED";
        break;
      case 4:
        id v22 = "TCP_CONNECTION_EVENT_WRITE_CLOSE";
        break;
      case 5:
        id v22 = "TCP_CONNECTION_EVENT_BETTER_ROUTE";
        break;
      case 6:
        id v22 = "TCP_CONNECTION_EVENT_VIABILITY_CHANGED";
        break;
      case 7:
        id v22 = "TCP_CONNECTION_EVENT_WAITING";
        break;
      case 8:
        id v22 = "TCP_CONNECTION_EVENT_TLS_HANDSHAKE_COMPLETE";
        break;
      default:
        id v22 = "UNKNOWN";
        break;
    }
LABEL_45:
    *(_DWORD *)buf = 136447234;
    id v31 = "tcp_connection_fillout_event_locked";
    __int16 v32 = 2048;
    size_t v33 = v21;
    __int16 v34 = 2082;
    os_log_type_t v35 = v22;
    __int16 v36 = 2082;
    uint64_t v37 = a6;
    __int16 v38 = 1024;
    int v39 = v15;
    _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %llu event: %{public}s, reason: %{public}s, should deliver: %{BOOL}d", buf, 0x30u);
  }

  if (v15)
  {
    if (!a4)
    {
      os_log_type_t v23 = 0;
      goto LABEL_53;
    }
    if (!a5)
    {
      char v26 = __nwlog_obj();
      os_log_type_enabled(v26, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446210;
      id v31 = "strict_malloc";
      uint64_t v27 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v27)) {
        goto LABEL_59;
      }
      free(v27);
    }
    os_log_type_t v23 = malloc_type_malloc(a5, 0xF2B69DE5uLL);
    if (v23)
    {
LABEL_50:
      memcpy(v23, a4, a5);
LABEL_53:
      *(_DWORD *)(a2 + 8) = a3;
      *(void *)a2 = v23;
      uint64_t v24 = 1;
      goto LABEL_54;
    }
    uint64_t v28 = __nwlog_obj();
    os_log_type_enabled(v28, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446466;
    id v31 = "strict_malloc";
    __int16 v32 = 2048;
    size_t v33 = a5;
    id v29 = (void *)_os_log_send_and_compose_impl();

    if (!__nwlog_abort((uint64_t)v29))
    {
      free(v29);
      goto LABEL_50;
    }
LABEL_59:
    __break(1u);
LABEL_60:
    JUMPOUT(0);
  }
LABEL_51:
  uint64_t v24 = 0;
LABEL_54:

  return v24;
}

BOOL nw_endpoint_copy_original_endpoint(void *a1, uint64_t a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  int v4 = v3;
  if (!v3)
  {
    int v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
    os_log_type_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v14 = __nwlog_obj();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
            __int16 v24 = 2082;
            os_log_type_t v25 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_29;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v14 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_29:
    if (v13) {
      free(v13);
    }
    char v11 = 0;
    goto LABEL_12;
  }
  char v5 = (void *)nw_endpoint_copy_proxy_original_endpoint(v3);
  os_log_type_t v6 = v5;
  if (v5) {
    goto LABEL_3;
  }
  if ([v4 type] == a2 || (char v5 = (void *)v4[14]) == 0)
  {
    id v7 = v4;
    goto LABEL_11;
  }
  if (v5 != v4)
  {
LABEL_3:
    id v7 = (void *)nw_endpoint_copy_original_endpoint(v5, a2);
LABEL_11:
    char v11 = v7;

LABEL_12:
    return (BOOL)v11;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v8 = (id)gLogObj;
  os_log_type_enabled(v8, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_endpoint_copy_original_endpoint";
  BOOL v9 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v9);
  if (!result)
  {
    free(v9);
    char v5 = (void *)v4[14];
    goto LABEL_3;
  }
  __break(1u);
  return result;
}

void sub_1831A3378(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_copy_proxy_original_endpoint(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v3 = v1;
  if (!v1)
  {
    os_log_type_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    size_t v21 = "nw_endpoint_copy_proxy_original_endpoint";
    char v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v11, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null endpoint", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v12, type);
        if (backtrace_string)
        {
          if (v16)
          {
            *(_DWORD *)buf = 136446466;
            size_t v21 = "nw_endpoint_copy_proxy_original_endpoint";
            __int16 v22 = 2082;
            os_log_type_t v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v16)
        {
          *(_DWORD *)buf = 136446210;
          size_t v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v12 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          size_t v21 = "nw_endpoint_copy_proxy_original_endpoint";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v11) {
      free(v11);
    }
    goto LABEL_28;
  }
  id v4 = (id)v1[14];
  if (!v4)
  {
LABEL_28:
    id v9 = 0;
    goto LABEL_29;
  }
  if (v4 != v3)
  {
    if ((*((unsigned char *)v3 + 231) & 2) == 0)
    {
LABEL_5:
      id v5 = (id)nw_endpoint_copy_proxy_original_endpoint(v4, v2);
LABEL_9:
      id v9 = v5;
LABEL_29:

      return (BOOL)v9;
    }
LABEL_8:
    id v5 = v4;
    goto LABEL_9;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v6 = (id)gLogObj;
  os_log_type_enabled(v6, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446210;
  size_t v21 = "nw_endpoint_copy_proxy_original_endpoint";
  id v7 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v7);
  if (!result)
  {
    free(v7);
    id v4 = (id)*((void *)v3 + 14);
    if ((*((unsigned char *)v3 + 231) & 2) == 0) {
      goto LABEL_5;
    }
    goto LABEL_8;
  }
  __break(1u);
  return result;
}

void sub_1831A3718(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ____nwlog_salted_hash_block_invoke()
{
}

BOOL nw_endpoint_resolver_create_child_parameters(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = nw_endpoint_handler_copy_current_path(v1);
  id v3 = nw_endpoint_handler_copy_parameters(v1);
  BOOL v4 = -[NWConcrete_nw_parameters initWithParameters:stripConnected:shallowCopy:]((id *)[NWConcrete_nw_parameters alloc], v3, 0, 0);

  if (v4)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = 0;
    if (nw_path_get_client_id(v2, buf)) {
      nw_parameters_set_parent_id_inner((NWConcrete_nw_parameters *)v4, buf, 0);
    }
    id v5 = (id)v4;
    *(_WORD *)(v5[13] + 108) |= 0x800u;

    nw_endpoint_t v6 = nw_endpoint_handler_copy_endpoint(v1);
    if (v6)
    {
      BOOL v7 = v6[11].isa == 0;

      if (v7)
      {
LABEL_8:
        os_log_type_t v8 = v5;
        goto LABEL_16;
      }
      nw_endpoint_t v6 = v5;
      *(_WORD *)(v5[13] + 108) |= 0x4000u;
    }

    goto LABEL_8;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v9 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_create_child_parameters";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (!__nwlog_fault(v10, &type, &v18)) {
    goto LABEL_14;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v11 = (id)gLogObj;
    os_log_type_t v12 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_create_child_parameters";
      _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s nw_parameters_copy failed", buf, 0xCu);
    }
LABEL_13:

LABEL_14:
    if (!v10) {
      goto LABEL_16;
    }
LABEL_15:
    free(v10);
    goto LABEL_16;
  }
  if (!v18)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v11 = (id)gLogObj;
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_create_child_parameters";
      _os_log_impl(&dword_1830D4000, v11, v17, "%{public}s nw_parameters_copy failed, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_13;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  char v11 = (id)gLogObj;
  os_log_type_t v15 = type;
  BOOL v16 = os_log_type_enabled(v11, type);
  if (!backtrace_string)
  {
    if (v16)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_create_child_parameters";
      _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s nw_parameters_copy failed, no backtrace", buf, 0xCu);
    }
    goto LABEL_13;
  }
  if (v16)
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_endpoint_resolver_create_child_parameters";
    *(_WORD *)&buf[12] = 2082;
    *(void *)&buf[14] = backtrace_string;
    _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s nw_parameters_copy failed, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(backtrace_string);
  if (v10) {
    goto LABEL_15;
  }
LABEL_16:

  return v4;
}

void sub_1831A3B18(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_get_client_id(void *a1, unsigned __int8 *a2)
{
  uint64_t v86 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  BOOL v4 = v3;
  if (!v3)
  {
    id v41 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
    uint64_t v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v66 = 0;
    if (__nwlog_fault(v42, &type, &v66))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v43 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v66)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v43 = __nwlog_obj();
        os_log_type_t v46 = type;
        BOOL v47 = os_log_type_enabled(v43, type);
        if (backtrace_string)
        {
          if (v47)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
            __int16 v70 = 2082;
            uint32_t v71 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v43, v46, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_81;
        }
        if (v47)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
          _os_log_impl(&dword_1830D4000, v43, v46, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v43 = __nwlog_obj();
        os_log_type_t v62 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
          _os_log_impl(&dword_1830D4000, v43, v62, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_81:
    if (v42) {
      free(v42);
    }
    goto LABEL_52;
  }
  if (*((_DWORD *)v3 + 29) != 2 || !nw_endpoint_flow_should_not_use_path(v3[31]))
  {
    if (v4[7])
    {
      nw_path_get_client_id(v4[8], a2);
      goto LABEL_52;
    }
    os_log_type_t v10 = v4;
    char v11 = v10;
    os_log_type_t v12 = v10[4];
    if (v12)
    {
      os_log_type_t v13 = v12;
      uint64_t v14 = v13[12];

      if ((v14 & 0x4000000000) != 0)
      {
        if (nw_endpoint_handler_get_logging_disabled(v11)) {
          goto LABEL_52;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v15 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v15, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v11);
          os_log_type_t v49 = nw_endpoint_handler_dry_run_string(v11);
          nw_endpoint_t v50 = nw_endpoint_handler_copy_endpoint(v11);
          logging_description = nw_endpoint_get_logging_description(v50);
          os_log_type_t v52 = nw_endpoint_handler_state_string(v11);
          BOOL v53 = nw_endpoint_handler_mode_string(v11);
          id v54 = nw_endpoint_handler_copy_current_path(v11);
          *(_DWORD *)buf = 136447746;
          os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
          __int16 v70 = 2082;
          uint32_t v71 = (void *)id_string;
          __int16 v72 = 2082;
          uint64_t v73 = v49;
          __int16 v74 = 2082;
          uint32_t v75 = logging_description;
          __int16 v76 = 2082;
          os_log_type_t v77 = v52;
          __int16 v78 = 2082;
          os_log_type_t v79 = v53;
          __int16 v80 = 2114;
          id v81 = v54;
          _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find association, no client ID", buf, 0x48u);
        }
        goto LABEL_44;
      }
      if ((*((unsigned char *)v11 + 268) & 0x20) != 0) {
        goto LABEL_52;
      }
    }
    else
    {

      if ((*((unsigned char *)v11 + 268) & 0x20) != 0) {
        goto LABEL_52;
      }
    }
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v15 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v15, OS_LOG_TYPE_INFO))
    {
      if (*((unsigned char *)v11 + 268)) {
        BOOL v16 = "dry-run ";
      }
      else {
        BOOL v16 = "";
      }
      nw_endpoint_t v17 = nw_endpoint_handler_copy_endpoint(v11);
      char v18 = nw_endpoint_get_logging_description(v17);
      os_log_type_t v19 = v11 + 21;
      uint64_t v20 = *((unsigned int *)v11 + 30);
      uint64_t v21 = v18;
      if (v20 > 5) {
        __int16 v22 = "unknown-state";
      }
      else {
        __int16 v22 = off_1E523FB38[v20];
      }
      os_log_type_t v65 = v22;
      __int16 v30 = v11;
      id v31 = v30;
      __int16 v32 = "path";
      switch(*((_DWORD *)v4 + 29))
      {
        case 0:
          break;
        case 1:
          __int16 v32 = "resolver";
          break;
        case 2:
          __int16 v32 = nw_endpoint_flow_mode_string(*(void **)&v30[62]._os_unfair_lock_opaque);
          break;
        case 3:
          __int16 v32 = "proxy";
          break;
        case 4:
          __int16 v32 = "fallback";
          break;
        case 5:
          __int16 v32 = "transform";
          break;
        default:
          __int16 v32 = "unknown-mode";
          break;
      }

      os_log_type_t v35 = v31 + 28;
      __int16 v36 = v31;
      os_unfair_lock_lock(v31 + 28);
      id v37 = v36[8];
      os_unfair_lock_unlock(v35);

      *(_DWORD *)buf = 136447746;
      os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
      __int16 v70 = 2082;
      uint32_t v71 = v19;
      __int16 v72 = 2082;
      uint64_t v73 = v16;
      __int16 v74 = 2082;
      uint32_t v75 = v21;
      __int16 v76 = 2082;
      os_log_type_t v77 = v65;
      __int16 v78 = 2082;
      os_log_type_t v79 = v32;
      __int16 v80 = 2114;
      id v81 = v37;
      _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to find association, no client ID", buf, 0x48u);
    }
LABEL_44:

    goto LABEL_52;
  }
  uuid_generate_random(a2);
  id v5 = v4;
  nw_endpoint_t v6 = v5;
  BOOL v7 = v5[4];
  if (v7)
  {
    os_log_type_t v8 = v7;
    uint64_t v9 = v8[12];

    if ((v9 & 0x4000000000) != 0)
    {
      if (nw_endpoint_handler_get_logging_disabled(v6)) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v23 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v55 = nw_endpoint_handler_get_id_string(v6);
        uint32_t v56 = nw_endpoint_handler_dry_run_string(v6);
        nw_endpoint_t v57 = nw_endpoint_handler_copy_endpoint(v6);
        uint64_t v58 = nw_endpoint_get_logging_description(v57);
        os_log_type_t v59 = nw_endpoint_handler_state_string(v6);
        BOOL v60 = nw_endpoint_handler_mode_string(v6);
        id v61 = nw_endpoint_handler_copy_current_path(v6);
        *(_DWORD *)buf = 136448258;
        os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
        __int16 v70 = 2082;
        uint32_t v71 = (void *)v55;
        __int16 v72 = 2082;
        uint64_t v73 = v56;
        __int16 v74 = 2082;
        uint32_t v75 = v58;
        __int16 v76 = 2082;
        os_log_type_t v77 = v59;
        __int16 v78 = 2082;
        os_log_type_t v79 = v60;
        __int16 v80 = 2114;
        id v81 = v61;
        __int16 v82 = 1042;
        int v83 = 16;
        __int16 v84 = 2098;
        uint64_t v85 = a2;
        _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Generated client ID %{public,uuid_t}.16P for non-path based handler", buf, 0x58u);
      }
      goto LABEL_51;
    }
    if ((*((unsigned char *)v6 + 268) & 0x20) != 0) {
      goto LABEL_52;
    }
LABEL_24:
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    os_log_type_t v23 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v23, OS_LOG_TYPE_INFO))
    {
      if (*((unsigned char *)v6 + 268)) {
        uint64_t v24 = "dry-run ";
      }
      else {
        uint64_t v24 = "";
      }
      nw_endpoint_t v25 = nw_endpoint_handler_copy_endpoint(v6);
      uint64_t v26 = nw_endpoint_get_logging_description(v25);
      uint64_t v27 = v6 + 21;
      uint64_t v28 = *((unsigned int *)v6 + 30);
      uint32_t v64 = v26;
      if (v28 > 5) {
        id v29 = "unknown-state";
      }
      else {
        id v29 = off_1E523FB38[v28];
      }
      os_log_type_t v63 = v29;
      size_t v33 = v6;
      __int16 v34 = "path";
      switch(*((_DWORD *)v4 + 29))
      {
        case 0:
          break;
        case 1:
          __int16 v34 = "resolver";
          break;
        case 2:
          __int16 v34 = nw_endpoint_flow_mode_string(v4[31]);
          break;
        case 3:
          __int16 v34 = "proxy";
          break;
        case 4:
          __int16 v34 = "fallback";
          break;
        case 5:
          __int16 v34 = "transform";
          break;
        default:
          __int16 v34 = "unknown-mode";
          break;
      }

      __int16 v38 = v33 + 28;
      int v39 = v33;
      os_unfair_lock_lock(v33 + 28);
      id v40 = v39[8];
      os_unfair_lock_unlock(v38);

      *(_DWORD *)buf = 136448258;
      os_log_type_t v69 = "nw_endpoint_handler_get_client_id";
      __int16 v70 = 2082;
      uint32_t v71 = v27;
      __int16 v72 = 2082;
      uint64_t v73 = v24;
      __int16 v74 = 2082;
      uint32_t v75 = v64;
      __int16 v76 = 2082;
      os_log_type_t v77 = v63;
      __int16 v78 = 2082;
      os_log_type_t v79 = v34;
      __int16 v80 = 2114;
      id v81 = v40;
      __int16 v82 = 1042;
      int v83 = 16;
      __int16 v84 = 2098;
      uint64_t v85 = a2;
      _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Generated client ID %{public,uuid_t}.16P for non-path based handler", buf, 0x58u);
    }
LABEL_51:

    goto LABEL_52;
  }

  if ((*((unsigned char *)v6 + 268) & 0x20) == 0) {
    goto LABEL_24;
  }
LABEL_52:
}

void sub_1831A44BC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_path_get_client_id(void *a1, _OWORD *a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  BOOL v4 = v3;
  if (v3)
  {
    *a2 = *(_OWORD *)(v3 + 120);
    goto LABEL_3;
  }
  nw_endpoint_t v6 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  nw_endpoint_t v17 = "nw_path_get_client_id";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v7, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v17 = "nw_path_get_client_id";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v11 = type;
      BOOL v12 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          nw_endpoint_t v17 = "nw_path_get_client_id";
          __int16 v18 = 2082;
          os_log_type_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v17 = "nw_path_get_client_id";
        _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        nw_endpoint_t v17 = "nw_path_get_client_id";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v7) {
    free(v7);
  }
LABEL_3:

  return v4 != 0;
}

BOOL nw_endpoint_proxy_handler_should_use_proxy(void *a1, void *a2, BOOL a3)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  id v7 = nw_endpoint_handler_copy_parameters(v5);
  if (v7)
  {
    id v8 = nw_path_copy_endpoint(v6);
    if (nw_path_should_use_proxy(v6, a3))
    {
      os_log_type_t v9 = (atomic_uchar *)nw_parameters_copy_custom_proxy_configs(v7);
      if (!v9) {
        os_log_type_t v9 = (atomic_uchar *)nw_path_copy_proxy_configs(v6);
      }
      *(void *)buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x2020000000;
      char v37 = 0;
      v29[0] = MEMORY[0x1E4F143A8];
      v29[1] = 3221225472;
      v29[2] = __nw_endpoint_proxy_handler_should_use_proxy_block_invoke;
      v29[3] = &unk_1E523E170;
      id v30 = v8;
      id v31 = v7;
      id v32 = v6;
      size_t v33 = buf;
      nw_array_apply(v9, (uint64_t)v29);
      BOOL v10 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;

      _Block_object_dispose(buf, 8);
      goto LABEL_17;
    }
    os_log_type_t v11 = v7;
    __int16 v12 = *(_WORD *)(v11[13] + 108);

    if ((v12 & 0x1000) == 0)
    {
      os_log_type_t v13 = v11;
      __int16 v14 = *(_WORD *)(v11[13] + 100);

      BOOL v10 = 0;
      if ((v14 & 0x40) == 0 || !v8) {
        goto LABEL_17;
      }
      if (nw_path_can_support_endpoint(v6, v8))
      {
        id v15 = nw_path_copy_interface(v6);
        BOOL v16 = v15;
        if (v15)
        {
          nw_endpoint_t v17 = v15;
          unsigned int v18 = v17[24] & 0xFFFFFFFB;

          if (v18)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v19 = (id)gLogObj;
            if (os_log_type_enabled(v19, OS_LOG_TYPE_INFO))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
              _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_INFO, "%{public}s Proxies not present, but required to fail closed", buf, 0xCu);
            }

            BOOL v10 = 1;
            goto LABEL_17;
          }
        }
      }
    }
    BOOL v10 = 0;
LABEL_17:

    goto LABEL_18;
  }
  uint64_t v21 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
  __int16 v22 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v34 = 0;
  if (__nwlog_fault(v22, &type, &v34))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
        _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v34)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v26 = type;
      BOOL v27 = os_log_type_enabled(v23, type);
      if (backtrace_string)
      {
        if (v27)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
          *(_WORD *)&buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }
      if (v27)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
        _os_log_impl(&dword_1830D4000, v23, v26, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v23 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v23, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_proxy_handler_should_use_proxy";
        _os_log_impl(&dword_1830D4000, v23, v28, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_35:
  if (v22) {
    free(v22);
  }
  BOOL v10 = 0;
LABEL_18:

  return v10;
}

void sub_1831A4C74(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_parameters(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[4];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_endpoint_handler_copy_parameters";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_handler_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_endpoint_handler_copy_parameters";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_handler_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_handler_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

id nw_path_copy_endpoint(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    id v3 = v1[3];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_path_copy_endpoint";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_path_copy_endpoint";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_copy_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_path_should_use_proxy(void *a1, BOOL a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  BOOL v4 = (nw_endpoint_t *)v3;
  if (!v3)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v23 = "nw_path_should_use_proxy";
    char v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_path_should_use_proxy";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v14 = __nwlog_obj();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v23 = "nw_path_should_use_proxy";
            __int16 v24 = 2082;
            nw_endpoint_t v25 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_50;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_path_should_use_proxy";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v14 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v23 = "nw_path_should_use_proxy";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_50:
    if (v13) {
      free(v13);
    }
    goto LABEL_7;
  }
  if (!*((void *)v3 + 3)) {
    goto LABEL_7;
  }
  if (*((void *)v3 + 30) || *((void *)v3 + 29) || a2)
  {
    if (!*((void *)v3 + 12)
      || (nw_parameters_get_proxy_applied(*((void **)v3 + 2)) & 1) != 0
      || nw_path_get_dns_service_id(v4, 0))
    {
      goto LABEL_7;
    }
    nw_endpoint_type_t v6 = nw_endpoint_get_type(v4[3]);
    if (v6 - 2 < 2)
    {
LABEL_15:
      a2 = nw_interface_get_type(v4[12]) != nw_interface_type_loopback;
      goto LABEL_8;
    }
    if (v6 != nw_endpoint_type_address)
    {
      if (v6 == (nw_endpoint_type_url|nw_endpoint_type_host)) {
        goto LABEL_15;
      }
      goto LABEL_7;
    }
    address = nw_endpoint_get_address(v4[3]);
    int sa_family = address->sa_family;
    if (sa_family != 2)
    {
      if (sa_family == 30)
      {
        int v9 = address->sa_data[6];
        if (v9 == 255)
        {
          char v11 = address->sa_data[7];
          if ((v11 & 0xF0) != 0x30 && (v11 & 0xF) == 2) {
            goto LABEL_7;
          }
        }
        else if (v9 == 254 && (address->sa_data[7] & 0xC0) == 0x80)
        {
          goto LABEL_7;
        }
        if (*(_DWORD *)&address->sa_data[6]
          || *(_DWORD *)&address->sa_data[10]
          || *(_DWORD *)&address[1].sa_len
          || (*(_DWORD *)&address[1].sa_data[2] | 0x1000000) != 0x1000000)
        {
          goto LABEL_15;
        }
      }
LABEL_7:
      a2 = 0;
      goto LABEL_8;
    }
    unsigned int v10 = bswap32(*(_DWORD *)&address->sa_data[2]);
    if (HIWORD(v10) == 43518) {
      goto LABEL_7;
    }
    a2 = 0;
    if (v10 >> 8 != 14680064
      && *(_DWORD *)&address->sa_data[2]
      && *(_DWORD *)&address->sa_data[2] != 127)
    {
      goto LABEL_15;
    }
  }
LABEL_8:

  return a2;
}

void sub_1831A55B8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_connected_path_change(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v183 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    int v93 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v166 = "nw_endpoint_handler_get_mode";
    uint64_t v94 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v163 = 0;
    if (__nwlog_fault(v94, &type, &v163))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v95 = __nwlog_obj();
        os_log_type_t v96 = type;
        if (os_log_type_enabled(v95, type))
        {
          *(_DWORD *)buf = 136446210;
          v166 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v163)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v95 = __nwlog_obj();
        os_log_type_t v98 = type;
        BOOL v99 = os_log_type_enabled(v95, type);
        if (backtrace_string)
        {
          if (v99)
          {
            *(_DWORD *)buf = 136446466;
            v166 = "nw_endpoint_handler_get_mode";
            __int16 v167 = 2082;
            v168 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v95, v98, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_119;
        }
        if (v99)
        {
          *(_DWORD *)buf = 136446210;
          v166 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v95, v98, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        os_log_type_t v95 = __nwlog_obj();
        os_log_type_t v100 = type;
        if (os_log_type_enabled(v95, type))
        {
          *(_DWORD *)buf = 136446210;
          v166 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v95, v100, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_119:
    if (v94) {
      free(v94);
    }
    unsigned int mode = 0;
    id v2 = 0;
    goto LABEL_122;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    long long v162 = v2;
    BOOL v4 = nw_endpoint_handler_copy_flow(v2);
    id v5 = v2;
    char v6 = *((unsigned char *)v5 + 268);

    if ((v6 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v7 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        os_log_type_t v8 = v5;

        int v9 = v8;
        char v10 = *((unsigned char *)v5 + 268);

        if (v10) {
          char v11 = "dry-run ";
        }
        else {
          char v11 = "";
        }
        nw_endpoint_t v12 = nw_endpoint_handler_copy_endpoint(v9);
        logging_description = nw_endpoint_get_logging_description(v12);
        long long v158 = v4;
        id_str = v8->id_str;
        os_log_type_t v15 = v9;
        BOOL v16 = v15;
        uint64_t v17 = v15[30];
        if (v17 > 5) {
          BOOL v18 = "unknown-state";
        }
        else {
          BOOL v18 = off_1E523FB38[v17];
        }
        os_log_t log = (os_log_t)v18;

        os_log_type_t v19 = v16;
        char v20 = v19;
        uint64_t v21 = "path";
        switch(v162->mode)
        {
          case 0:
            break;
          case 1:
            uint64_t v21 = "resolver";
            break;
          case 2:
            uint64_t v21 = nw_endpoint_flow_mode_string(v19[31]);
            break;
          case 3:
            uint64_t v21 = "proxy";
            break;
          case 4:
            uint64_t v21 = "fallback";
            break;
          case 5:
            uint64_t v21 = "transform";
            break;
          default:
            uint64_t v21 = "unknown-mode";
            break;
        }

        __int16 v22 = v20;
        os_unfair_lock_lock((os_unfair_lock_t)v22 + 28);
        id v23 = v22[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v22 + 28);

        *(_DWORD *)buf = 136447746;
        v166 = "nw_endpoint_flow_connected_path_change";
        __int16 v167 = 2082;
        v168 = id_str;
        __int16 v169 = 2082;
        uint64_t v170 = v11;
        __int16 v171 = 2082;
        v172 = (void *)logging_description;
        __int16 v173 = 2082;
        uint64_t v174 = log;
        __int16 v175 = 2082;
        uint64_t v176 = v21;
        __int16 v177 = 2114;
        id v178 = v23;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x48u);

        BOOL v4 = v158;
      }
    }
    __int16 v24 = v5;
    int state = v24->state;

    if ((state & 0xFFFFFFFE) == 4) {
      goto LABEL_102;
    }
    if (nw_endpoint_flow_should_not_use_path(v4))
    {
      uint64_t v26 = (char *)v4 + 33;
      char v27 = *((unsigned char *)v4 + 33);
      if ((v27 & 2) != 0)
      {
LABEL_82:
        char v88 = 1;
        if ((v27 & 4) != 0)
        {
LABEL_100:
          if ((v88 & 1) == 0)
          {
            v24->event = (nw_endpoint_handler_event_s)524291;
            nw_endpoint_handler_report(v24, 0, &v24->event.domain, 0);
          }
LABEL_102:

          os_log_type_t v92 = v162;
          goto LABEL_156;
        }
LABEL_88:
        if (state == 3)
        {
          *uint64_t v26 = v27 | 0xC;
          os_log_type_t v90 = v24;
          os_log_type_t v91 = v90->association;

          if (v91) {
            nw_association_mark_flow_connected(v91, v90);
          }
          v90->event = (nw_endpoint_handler_event_s)393219;
          nw_endpoint_handler_report(v90, 0, &v90->event.domain, 0);
          if (*((void *)v4 + 127)) {
            nw_endpoint_handler_register_adaptive_read_handler(v90);
          }
          if (*((void *)v4 + 128)) {
            nw_endpoint_handler_register_adaptive_write_handler(v90);
          }
          if (*((void *)v4 + 129)) {
            nw_endpoint_handler_register_keepalive_handler(v90);
          }
          if (*((void *)v4 + 130)) {
            nw_endpoint_handler_register_metadata_changed_handler(v90);
          }
        }
        goto LABEL_100;
      }
      goto LABEL_85;
    }
    if ((*((unsigned char *)v4 + 32) & 2) != 0) {
      goto LABEL_47;
    }
    if ((*((unsigned char *)v4 + 33) & 1) == 0)
    {
      os_log_type_t v28 = (void *)*((void *)v4 + 117);
      if (v28)
      {
        int is_viable = nw_endpoint_handler_is_viable(v28);
        int minimize_logging = nw_endpoint_handler_get_minimize_logging(v24);
        char logging_disabled = nw_endpoint_handler_get_logging_disabled(v24);
        int v159 = is_viable;
        if (!minimize_logging)
        {
          if (logging_disabled) {
            goto LABEL_81;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v32 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
          {
            id_string = nw_endpoint_handler_get_id_string(v24);
            loga = nw_endpoint_handler_dry_run_string(v24);
            char v34 = id_string;
            nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v24);
            __int16 v36 = nw_endpoint_get_logging_description(v35);
            char v37 = nw_endpoint_handler_state_string(v24);
            uint64_t v38 = nw_endpoint_handler_mode_string(v24);
            id v39 = nw_endpoint_handler_copy_current_path(v24);
            id v40 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            id v41 = "not ";
            v168 = (void *)v34;
            __int16 v167 = 2082;
            if (v159) {
              id v41 = "";
            }
            __int16 v169 = 2082;
            uint64_t v170 = loga;
            __int16 v171 = 2082;
            v172 = (void *)v36;
            __int16 v173 = 2082;
            uint64_t v174 = (void *)v37;
            __int16 v175 = 2082;
            uint64_t v176 = v38;
            __int16 v177 = 2114;
            id v178 = v39;
            __int16 v179 = 2082;
            uint64_t v180 = v40;
            __int16 v181 = 2082;
            uint64_t v182 = v41;
            _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public}s, child is %{public}sviable", buf, 0x5Cu);
          }
          goto LABEL_80;
        }
        if ((logging_disabled & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v32 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
          {
            BOOL v122 = nw_endpoint_handler_get_id_string(v24);
            loge = nw_endpoint_handler_dry_run_string(v24);
            nw_endpoint_t v123 = nw_endpoint_handler_copy_endpoint(v24);
            __int16 v124 = nw_endpoint_get_logging_description(v123);
            os_log_type_t v125 = nw_endpoint_handler_state_string(v24);
            uint64_t v126 = nw_endpoint_handler_mode_string(v24);
            id v127 = nw_endpoint_handler_copy_current_path(v24);
            os_log_type_t v128 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            os_log_type_t v129 = "not ";
            v168 = (void *)v122;
            __int16 v167 = 2082;
            if (v159) {
              os_log_type_t v129 = "";
            }
            __int16 v169 = 2082;
            uint64_t v170 = loge;
            __int16 v171 = 2082;
            v172 = (void *)v124;
            __int16 v173 = 2082;
            uint64_t v174 = (void *)v125;
            __int16 v175 = 2082;
            uint64_t v176 = v126;
            __int16 v177 = 2114;
            id v178 = v127;
            __int16 v179 = 2082;
            uint64_t v180 = v128;
            __int16 v181 = 2082;
            uint64_t v182 = v129;
            _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public}s, child is %{public}sviable", buf, 0x5Cu);
          }
          goto LABEL_80;
        }
LABEL_81:
        uint64_t v26 = (char *)v4 + 33;
        char v27 = *((unsigned char *)v4 + 33);
        if ((v159 ^ ((v27 & 2) == 0))) {
          goto LABEL_82;
        }
        if (!v159)
        {
          char v89 = 0;
LABEL_87:
          char v88 = 0;
          char v27 = v27 & 0xFD | v89;
          *uint64_t v26 = v27;
          if ((v27 & 4) != 0) {
            goto LABEL_100;
          }
          goto LABEL_88;
        }
LABEL_85:
        char v89 = 2;
        goto LABEL_87;
      }
LABEL_47:
      id v54 = (void *)*((void *)v4 + 1);
      if (v54) {
        LODWORD(v54) = nw_path_is_viable(v54);
      }
      int v159 = (int)v54;
      if (!nw_endpoint_handler_get_minimize_logging(v24))
      {
        os_log_type_t v55 = v24;
        BOOL v56 = (*((unsigned char *)v5 + 268) & 0x20) == 0;

        if (!v56) {
          goto LABEL_81;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v32 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
          nw_endpoint_t v57 = v55;

          uint64_t v58 = v57;
          BOOL v59 = (*((unsigned char *)v5 + 268) & 1) == 0;

          if (v59) {
            BOOL v60 = "";
          }
          else {
            BOOL v60 = "dry-run ";
          }
          nw_endpoint_t v61 = nw_endpoint_handler_copy_endpoint(v58);
          os_log_type_t v62 = nw_endpoint_get_logging_description(v61);
          os_log_type_t v63 = v58;
          uint32_t v64 = v63;
          uint64_t v65 = v24->state;
          unsigned int v148 = v62;
          os_log_t logb = (os_log_t)v60;
          if (v65 > 5) {
            char v66 = "unknown-state";
          }
          else {
            char v66 = off_1E523FB38[v65];
          }
          uint64_t v144 = v66;

          os_log_type_t v67 = v64;
          char v68 = v67;
          os_log_type_t v69 = "path";
          switch(v162->mode)
          {
            case 0:
              break;
            case 1:
              os_log_type_t v69 = "resolver";
              break;
            case 2:
              os_log_type_t v69 = nw_endpoint_flow_mode_string(v67[31]);
              break;
            case 3:
              os_log_type_t v69 = "proxy";
              break;
            case 4:
              os_log_type_t v69 = "fallback";
              break;
            case 5:
              os_log_type_t v69 = "transform";
              break;
            default:
              os_log_type_t v69 = "unknown-mode";
              break;
          }

          __int16 v82 = v68;
          os_unfair_lock_lock((os_unfair_lock_t)v82 + 28);
          id v83 = v82[8];
          os_unfair_lock_unlock((os_unfair_lock_t)v82 + 28);

          __int16 v84 = v57 + 168;
          id v85 = v83;
          uint64_t v86 = nw_endpoint_handler_path_status_string(v82);
          *(_DWORD *)buf = 136448258;
          v166 = "nw_endpoint_flow_connected_path_change";
          BOOL v87 = "not ";
          if (v159) {
            BOOL v87 = "";
          }
          __int16 v167 = 2082;
          v168 = v84;
          __int16 v169 = 2082;
          uint64_t v170 = (const char *)logb;
          __int16 v171 = 2082;
          v172 = (void *)v148;
          __int16 v173 = 2082;
          uint64_t v174 = (void *)v144;
          __int16 v175 = 2082;
          uint64_t v176 = v69;
          __int16 v177 = 2114;
          id v178 = v85;
          __int16 v179 = 2082;
          uint64_t v180 = v86;
          __int16 v181 = 2082;
          uint64_t v182 = v87;
          _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public}s, %{public}sviable", buf, 0x5Cu);
        }
        goto LABEL_80;
      }
      if ((nw_endpoint_handler_get_logging_disabled(v24) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v32 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v32, OS_LOG_TYPE_DEBUG))
        {
          os_log_type_t v114 = nw_endpoint_handler_get_id_string(v24);
          logd = nw_endpoint_handler_dry_run_string(v24);
          nw_endpoint_t v115 = nw_endpoint_handler_copy_endpoint(v24);
          os_log_type_t v116 = nw_endpoint_get_logging_description(v115);
          char v117 = nw_endpoint_handler_state_string(v24);
          BOOL v118 = nw_endpoint_handler_mode_string(v24);
          id v119 = nw_endpoint_handler_copy_current_path(v24);
          __int16 v120 = nw_endpoint_handler_path_status_string(v24);
          *(_DWORD *)buf = 136448258;
          v166 = "nw_endpoint_flow_connected_path_change";
          os_log_type_t v121 = "not ";
          v168 = (void *)v114;
          __int16 v167 = 2082;
          if (v159) {
            os_log_type_t v121 = "";
          }
          __int16 v169 = 2082;
          uint64_t v170 = logd;
          __int16 v171 = 2082;
          v172 = (void *)v116;
          __int16 v173 = 2082;
          uint64_t v174 = (void *)v117;
          __int16 v175 = 2082;
          uint64_t v176 = v118;
          __int16 v177 = 2114;
          id v178 = v119;
          __int16 v179 = 2082;
          uint64_t v180 = v120;
          __int16 v181 = 2082;
          uint64_t v182 = v121;
          _os_log_impl(&dword_1830D4000, v32, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public}s, %{public}sviable", buf, 0x5Cu);
        }
        goto LABEL_80;
      }
      goto LABEL_81;
    }
    uint64_t v42 = (void *)*((void *)v4 + 104);
    if (!v42) {
      goto LABEL_47;
    }
    id v32 = nw_path_flow_registration_force_update(v42);
    int v43 = nw_endpoint_handler_get_minimize_logging(v24);
    char v44 = nw_endpoint_handler_get_logging_disabled(v24);
    if (v43)
    {
      if (v44)
      {
LABEL_45:
        if (v32) {
          BOOL v53 = nw_path_is_viable(v32);
        }
        else {
          BOOL v53 = 0;
        }
        int v70 = nw_endpoint_handler_get_minimize_logging(v24);
        char v71 = nw_endpoint_handler_get_logging_disabled(v24);
        int v159 = v53;
        if (v70)
        {
          if (v71) {
            goto LABEL_80;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v136 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v136, OS_LOG_TYPE_DEBUG))
          {
            logg = nw_endpoint_handler_get_id_string(v24);
            os_log_type_t v146 = nw_endpoint_handler_dry_run_string(v24);
            nw_endpoint_t v137 = nw_endpoint_handler_copy_endpoint(v24);
            v138 = nw_endpoint_get_logging_description(v137);
            os_log_type_t v139 = nw_endpoint_handler_state_string(v24);
            long long v140 = nw_endpoint_handler_mode_string(v24);
            id v141 = nw_endpoint_handler_copy_current_path(v24);
            long long v142 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            long long v143 = "not ";
            v168 = (void *)logg;
            __int16 v167 = 2082;
            if (v159) {
              long long v143 = "";
            }
            __int16 v169 = 2082;
            uint64_t v170 = v146;
            __int16 v171 = 2082;
            v172 = (void *)v138;
            __int16 v173 = 2082;
            uint64_t v174 = (void *)v139;
            __int16 v175 = 2082;
            uint64_t v176 = v140;
            __int16 v177 = 2114;
            id v178 = v141;
            __int16 v179 = 2082;
            uint64_t v180 = v142;
            __int16 v181 = 2082;
            uint64_t v182 = v143;
            _os_log_impl(&dword_1830D4000, v136, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public}s, join flow is %{public}sviable", buf, 0x5Cu);

            __int16 v72 = v136;
          }
          else
          {
            __int16 v72 = v136;
          }
        }
        else
        {
          if (v71)
          {
LABEL_80:

            goto LABEL_81;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v72 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v72, OS_LOG_TYPE_INFO))
          {
            uint64_t v73 = nw_endpoint_handler_get_id_string(v24);
            logc = v72;
            uint64_t v145 = nw_endpoint_handler_dry_run_string(v24);
            __int16 v74 = v73;
            nw_endpoint_t v75 = nw_endpoint_handler_copy_endpoint(v24);
            __int16 v76 = nw_endpoint_get_logging_description(v75);
            os_log_type_t v77 = nw_endpoint_handler_state_string(v24);
            __int16 v78 = nw_endpoint_handler_mode_string(v24);
            id v79 = nw_endpoint_handler_copy_current_path(v24);
            __int16 v80 = nw_endpoint_handler_path_status_string(v24);
            *(_DWORD *)buf = 136448258;
            v166 = "nw_endpoint_flow_connected_path_change";
            id v81 = "not ";
            v168 = (void *)v74;
            __int16 v167 = 2082;
            if (v159) {
              id v81 = "";
            }
            __int16 v169 = 2082;
            uint64_t v170 = v145;
            __int16 v171 = 2082;
            v172 = (void *)v76;
            __int16 v173 = 2082;
            uint64_t v174 = (void *)v77;
            __int16 v175 = 2082;
            uint64_t v176 = v78;
            __int16 v177 = 2114;
            id v178 = v79;
            __int16 v179 = 2082;
            uint64_t v180 = v80;
            __int16 v181 = 2082;
            uint64_t v182 = v81;
            _os_log_impl(&dword_1830D4000, logc, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Connected path is %{public}s, join flow is %{public}sviable", buf, 0x5Cu);

            __int16 v72 = logc;
          }
        }

        goto LABEL_80;
      }
      uint64_t v149 = v32;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v45 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_DEBUG))
      {
        long long v161 = nw_endpoint_handler_get_id_string(v24);
        logf = nw_endpoint_handler_dry_run_string(v24);
        nw_endpoint_t v130 = nw_endpoint_handler_copy_endpoint(v24);
        id v131 = nw_endpoint_get_logging_description(v130);
        id v132 = nw_endpoint_handler_state_string(v24);
        int v133 = nw_endpoint_handler_mode_string(v24);
        id v134 = nw_endpoint_handler_copy_current_path(v24);
        __int16 v135 = (const char *)*((void *)v4 + 104);
        *(_DWORD *)buf = 136448258;
        v166 = "nw_endpoint_flow_connected_path_change";
        __int16 v167 = 2082;
        v168 = (void *)v161;
        __int16 v169 = 2082;
        uint64_t v170 = logf;
        __int16 v171 = 2082;
        v172 = (void *)v131;
        __int16 v173 = 2082;
        uint64_t v174 = (void *)v132;
        __int16 v175 = 2082;
        uint64_t v176 = v133;
        __int16 v177 = 2114;
        id v178 = v134;
        __int16 v179 = 2112;
        uint64_t v180 = v135;
        __int16 v181 = 2112;
        id v32 = v149;
        uint64_t v182 = (const char *)v149;
        _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] registration %@ flow_path %@", buf, 0x5Cu);
      }
    }
    else
    {
      if (v44) {
        goto LABEL_45;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v45 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v45, OS_LOG_TYPE_INFO))
      {
        os_log_type_t v46 = nw_endpoint_handler_get_id_string(v24);
        BOOL v47 = nw_endpoint_handler_dry_run_string(v24);
        BOOL v147 = v32;
        nw_endpoint_t v160 = nw_endpoint_handler_copy_endpoint(v24);
        int v48 = nw_endpoint_get_logging_description(v160);
        os_log_type_t v49 = nw_endpoint_handler_state_string(v24);
        nw_endpoint_t v50 = nw_endpoint_handler_mode_string(v24);
        id v51 = nw_endpoint_handler_copy_current_path(v24);
        os_log_type_t v52 = (const char *)*((void *)v4 + 104);
        *(_DWORD *)buf = 136448258;
        v166 = "nw_endpoint_flow_connected_path_change";
        __int16 v167 = 2082;
        v168 = (void *)v46;
        __int16 v169 = 2082;
        uint64_t v170 = v47;
        __int16 v171 = 2082;
        v172 = (void *)v48;
        __int16 v173 = 2082;
        uint64_t v174 = (void *)v49;
        __int16 v175 = 2082;
        uint64_t v176 = v50;
        __int16 v177 = 2114;
        id v178 = v51;
        __int16 v179 = 2112;
        uint64_t v180 = v52;
        __int16 v181 = 2112;
        id v32 = v147;
        uint64_t v182 = (const char *)v147;
        _os_log_impl(&dword_1830D4000, v45, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] registration %@ flow_path %@", buf, 0x5Cu);
      }
    }

    goto LABEL_45;
  }
LABEL_122:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v101 = (id)gLogObj;
  os_log_type_t v92 = v2;
  if (mode > 5) {
    BOOL v102 = "unknown-mode";
  }
  else {
    BOOL v102 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  v166 = "nw_endpoint_flow_connected_path_change";
  __int16 v167 = 2082;
  v168 = (void *)v102;
  __int16 v169 = 2082;
  uint64_t v170 = "flow";
  os_log_type_t v103 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v163 = 0;
  if (!__nwlog_fault((const char *)v103, &type, &v163))
  {
LABEL_154:
    if (!v103) {
      goto LABEL_156;
    }
LABEL_155:
    free(v103);
    goto LABEL_156;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v104 = (id)gLogObj;
    os_log_type_t v105 = type;
    if (os_log_type_enabled(v104, type))
    {
      if (mode > 5) {
        os_log_type_t v106 = "unknown-mode";
      }
      else {
        os_log_type_t v106 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      v166 = "nw_endpoint_flow_connected_path_change";
      __int16 v167 = 2082;
      v168 = (void *)v106;
      __int16 v169 = 2082;
      uint64_t v170 = "flow";
      _os_log_impl(&dword_1830D4000, v104, v105, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_153:

    goto LABEL_154;
  }
  if (!v163)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v104 = (id)gLogObj;
    os_log_type_t v111 = type;
    if (os_log_type_enabled(v104, type))
    {
      if (mode > 5) {
        BOOL v112 = "unknown-mode";
      }
      else {
        BOOL v112 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      v166 = "nw_endpoint_flow_connected_path_change";
      __int16 v167 = 2082;
      v168 = (void *)v112;
      __int16 v169 = 2082;
      uint64_t v170 = "flow";
      _os_log_impl(&dword_1830D4000, v104, v111, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_153;
  }
  os_log_type_t v107 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v104 = (id)gLogObj;
  os_log_type_t v108 = type;
  BOOL v109 = os_log_type_enabled(v104, type);
  if (!v107)
  {
    if (v109)
    {
      if (mode > 5) {
        os_log_type_t v113 = "unknown-mode";
      }
      else {
        os_log_type_t v113 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      v166 = "nw_endpoint_flow_connected_path_change";
      __int16 v167 = 2082;
      v168 = (void *)v113;
      __int16 v169 = 2082;
      uint64_t v170 = "flow";
      _os_log_impl(&dword_1830D4000, v104, v108, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_153;
  }
  if (v109)
  {
    if (mode > 5) {
      unint64_t v110 = "unknown-mode";
    }
    else {
      unint64_t v110 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    v166 = "nw_endpoint_flow_connected_path_change";
    __int16 v167 = 2082;
    v168 = (void *)v110;
    __int16 v169 = 2082;
    uint64_t v170 = "flow";
    __int16 v171 = 2082;
    v172 = v107;
    _os_log_impl(&dword_1830D4000, v104, v108, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v107);
  if (v103) {
    goto LABEL_155;
  }
LABEL_156:
}

void sub_1831A6C38(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_should_not_use_path(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[34] >> 1) & 1;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_endpoint_flow_should_not_use_path";
  char v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_flow_should_not_use_path";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_endpoint_flow_should_not_use_path";
          __int16 v17 = 2082;
          BOOL v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_flow_should_not_use_path";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_endpoint_flow_should_not_use_path";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

const char *nw_endpoint_handler_path_status_string(void *a1)
{
  id v1 = a1;
  id v2 = (void *)v1[8];
  if (v2)
  {
    uint64_t v3 = v2;
    uint64_t v4 = v3[94];

    if (v4 > 3) {
      id v5 = "unknown";
    }
    else {
      id v5 = off_1E5248570[v4];
    }
  }
  else
  {
    id v5 = "null";
  }

  return v5;
}

void *nw_parameters_get_upper_transport_protocol_identifier(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (!v1)
  {
    int v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "nw_parameters_get_upper_transport_protocol_identifier";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (__nwlog_fault(v10, &type, &v18))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "nw_parameters_get_upper_transport_protocol_identifier";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v18)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        BOOL v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled(v11, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v21 = "nw_parameters_get_upper_transport_protocol_identifier";
            __int16 v22 = 2082;
            id v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "nw_parameters_get_upper_transport_protocol_identifier";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        BOOL v11 = __nwlog_obj();
        os_log_type_t v16 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v21 = "nw_parameters_get_upper_transport_protocol_identifier";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v10) {
      free(v10);
    }
    goto LABEL_28;
  }
  uint64_t v3 = v1[19];
  if (!v3 || (uint64_t v4 = *(void **)(v3 + 24)) == 0)
  {
LABEL_28:
    quic_stream_protocol_identifier = 0;
    goto LABEL_29;
  }
  id v5 = v4;
  if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
    dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
  }
  BOOL v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  if (v6 && nw_udp_options_get_use_quic_stats(*(void **)(v2[19] + 24)))
  {
    quic_stream_protocol_identifier = nw_protocol_get_quic_stream_protocol_identifier();
  }
  else
  {
    nw_protocol_definition_t v8 = nw_protocol_options_copy_definition(*(nw_protocol_options_t *)(v2[19] + 24));
    quic_stream_protocol_identifier = nw_protocol_definition_get_identifier(v8);
  }
LABEL_29:

  return quic_stream_protocol_identifier;
}

void sub_1831A7398(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_flow_join_protocol(void *a1, void *a2, void *a3, void *a4, void *a5, uint64_t a6, uint64_t a7, uint64_t a8, unsigned __int8 a9, unsigned char *a10)
{
  uint64_t v109 = *MEMORY[0x1E4F143B8];
  __int16 v17 = a1;
  id v86 = a2;
  id v87 = a3;
  id v18 = a4;
  BOOL v85 = nw_protocols_are_equal(*(void **)(a7 + 16), a5);
  if (!v85) {
    goto LABEL_68;
  }
  id v84 = v18;
  nw_endpoint_handler_set_protocol_instance(v17, v87, v18, a7);
  uint64_t v19 = *(void *)(a7 + 24);
  if (v19)
  {
    char v20 = *(void (**)(uint64_t))(v19 + 112);
    if (v20)
    {
      uint64_t v21 = *(void **)(a7 + 40);
      if (v21 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v23 = *(void *)(a7 + 88);
        if (v23) {
          *(void *)(a7 + 88) = v23 + 1;
        }
        char v22 = -1;
      }
      else
      {
        char v22 = 0;
      }
      *(void *)buf = a7;
      uint8_t buf[8] = v22;
      uint64_t v24 = v20(a7);
      if (v21 == &nw_protocol_ref_counted_handle) {
        nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
      }
      nw_parameters_inherit_protocol_instances(v86, a6, v24, a7, a9);
    }
  }
  if (!a8)
  {
    uint32_t v64 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
    char v44 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (!__nwlog_fault(v44, type, &v88)) {
      goto LABEL_56;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v65 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_1830D4000, v45, v65, "%{public}s called with null input_protocol", buf, 0xCu);
      }
      goto LABEL_89;
    }
    if (!v88)
    {
      id v45 = __nwlog_obj();
      os_log_type_t v78 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        _os_log_impl(&dword_1830D4000, v45, v78, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_89;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v49 = __nwlog_obj();
    os_log_type_t v67 = type[0];
    BOOL v68 = os_log_type_enabled(v49, type[0]);
    if (backtrace_string)
    {
      if (v68)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        __int16 v91 = 2082;
        uint64_t v92 = (uint64_t)backtrace_string;
        _os_log_impl(&dword_1830D4000, v49, v67, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }

      free(backtrace_string);
LABEL_56:
      if (!v44) {
        goto LABEL_58;
      }
LABEL_57:
      free(v44);
      goto LABEL_58;
    }
    if (v68)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
      _os_log_impl(&dword_1830D4000, v49, v67, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
    }
    goto LABEL_55;
  }
  if (a7 == a8)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v43 = (id)gLogObj;
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
    __int16 v91 = 2048;
    uint64_t v92 = a7;
    char v44 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v88 = 0;
    if (!__nwlog_fault(v44, type, &v88)) {
      goto LABEL_56;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v45 = (id)gLogObj;
      os_log_type_t v46 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        __int16 v91 = 2048;
        uint64_t v92 = a7;
        _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
      }
LABEL_89:

      goto LABEL_56;
    }
    if (!v88)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v45 = (id)gLogObj;
      os_log_type_t v52 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        __int16 v91 = 2048;
        uint64_t v92 = a7;
        _os_log_impl(&dword_1830D4000, v45, v52, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
      }
      goto LABEL_89;
    }
    int v48 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v49 = (id)gLogObj;
    os_log_type_t v50 = type[0];
    BOOL v51 = os_log_type_enabled(v49, type[0]);
    if (v48)
    {
      if (v51)
      {
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
        __int16 v91 = 2048;
        uint64_t v92 = a7;
        __int16 v93 = 2082;
        uint64_t v94 = v48;
        _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
      }

      free(v48);
      if (!v44) {
        goto LABEL_58;
      }
      goto LABEL_57;
    }
    if (v51)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
      __int16 v91 = 2048;
      uint64_t v92 = a7;
      _os_log_impl(&dword_1830D4000, v49, v50, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
    }
LABEL_55:

    goto LABEL_56;
  }
  nw_endpoint_t v25 = *(void **)(a7 + 24);
  if (v25 && *v25)
  {
    if (nw_protocol_add_input_handler(a7, a8))
    {
      uint64_t v26 = nw_endpoint_handler_copy_flow(v17);
      id v27 = nw_parameters_copy_context(v86);
      uint64_t v28 = 0;
      __int16 v82 = v26;
      id v83 = v27;
      do
      {
        if (!uuid_is_null((const unsigned __int8 *)a8)) {
          uint64_t v28 = a8;
        }
        a8 = *(void *)(a8 + 32);
      }
      while (a8);
      if (v28) {
        uint64_t v29 = v28;
      }
      else {
        uint64_t v29 = a7;
      }
      id v81 = nw_path_copy_flow_registration(v27, v29);
      objc_storeStrong((id *)v26 + 104, v81);
      int minimize_logging = nw_endpoint_handler_get_minimize_logging(v17);
      char logging_disabled = nw_endpoint_handler_get_logging_disabled(v17);
      if (minimize_logging)
      {
        if (logging_disabled) {
          goto LABEL_35;
        }
        uint64_t v79 = v29;
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_t log = (id)gconnectionLogObj;
        if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
        {
          id_string = nw_endpoint_handler_get_id_string(v17);
          int v70 = nw_endpoint_handler_dry_run_string(v17);
          nw_endpoint_t v71 = nw_endpoint_handler_copy_endpoint(v17);
          logging_description = nw_endpoint_get_logging_description(v71);
          uint64_t v73 = nw_endpoint_handler_state_string(v17);
          __int16 v74 = nw_endpoint_handler_mode_string(v17);
          id v75 = nw_endpoint_handler_copy_current_path(v17);
          __int16 v76 = v75;
          os_log_type_t v77 = "invalid";
          if (a7 && *(void *)(a7 + 16)) {
            os_log_type_t v77 = *(const char **)(a7 + 16);
          }
          *(_DWORD *)buf = 136448514;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_join_protocol";
          __int16 v91 = 2082;
          uint64_t v92 = (uint64_t)id_string;
          __int16 v93 = 2082;
          uint64_t v94 = (void *)v70;
          __int16 v95 = 2082;
          os_log_type_t v96 = logging_description;
          __int16 v97 = 2082;
          os_log_type_t v98 = v73;
          __int16 v99 = 2082;
          os_log_type_t v100 = v74;
          __int16 v101 = 2114;
          id v102 = v75;
          __int16 v103 = 2082;
          BOOL v104 = v77;
          __int16 v105 = 1042;
          int v106 = 16;
          __int16 v107 = 2098;
          uint64_t v108 = v79;
          _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Joined protocol %{public}s, using flow id %{public,uuid_t}.16P", buf, 0x62u);
        }
      }
      else
      {
        if (logging_disabled)
        {
LABEL_35:

          id v18 = v84;
          goto LABEL_68;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        id v32 = (id)gconnectionLogObj;
        if (!os_log_type_enabled(v32, OS_LOG_TYPE_INFO))
        {
LABEL_34:

          goto LABEL_35;
        }
        size_t v33 = nw_endpoint_handler_get_id_string(v17);
        char v34 = nw_endpoint_handler_dry_run_string(v17);
        os_log_t log = v32;
        nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v17);
        __int16 v36 = nw_endpoint_get_logging_description(v35);
        char v37 = nw_endpoint_handler_state_string(v17);
        uint64_t v38 = nw_endpoint_handler_mode_string(v17);
        uint64_t v39 = v29;
        id v40 = nw_endpoint_handler_copy_current_path(v17);
        id v41 = v40;
        uint64_t v42 = "invalid";
        if (a7 && *(void *)(a7 + 16)) {
          uint64_t v42 = *(const char **)(a7 + 16);
        }
        *(_DWORD *)buf = 136448514;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_join_protocol";
        __int16 v91 = 2082;
        uint64_t v92 = (uint64_t)v33;
        __int16 v93 = 2082;
        uint64_t v94 = (void *)v34;
        __int16 v95 = 2082;
        os_log_type_t v96 = v36;
        __int16 v97 = 2082;
        os_log_type_t v98 = v37;
        __int16 v99 = 2082;
        os_log_type_t v100 = v38;
        __int16 v101 = 2114;
        id v102 = v40;
        __int16 v103 = 2082;
        BOOL v104 = v42;
        __int16 v105 = 1042;
        int v106 = 16;
        __int16 v107 = 2098;
        uint64_t v108 = v39;
        _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Joined protocol %{public}s, using flow id %{public,uuid_t}.16P", buf, 0x62u);
      }
      id v32 = log;
      goto LABEL_34;
    }
    goto LABEL_59;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v47 = (id)gLogObj;
  if (os_log_type_enabled(v47, OS_LOG_TYPE_ERROR))
  {
    *(_DWORD *)buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_protocol_utilities_add_input_handler";
    __int16 v91 = 2048;
    uint64_t v92 = a7;
    _os_log_impl(&dword_1830D4000, v47, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
  }

LABEL_58:
  id v18 = v84;
LABEL_59:
  if ((nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v53 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v53, OS_LOG_TYPE_ERROR))
    {
      id v54 = nw_endpoint_handler_get_id_string(v17);
      os_log_type_t v55 = nw_endpoint_handler_dry_run_string(v17);
      nw_endpoint_t v56 = nw_endpoint_handler_copy_endpoint(v17);
      nw_endpoint_t v57 = nw_endpoint_get_logging_description(v56);
      uint64_t v58 = nw_endpoint_handler_state_string(v17);
      BOOL v59 = nw_endpoint_handler_mode_string(v17);
      id v60 = nw_endpoint_handler_copy_current_path(v17);
      nw_endpoint_t v61 = v60;
      os_log_type_t v62 = *(const char **)(a7 + 16);
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_join_protocol";
      *(_DWORD *)buf = 136448002;
      if (!v62) {
        os_log_type_t v62 = "invalid";
      }
      __int16 v91 = 2082;
      uint64_t v92 = (uint64_t)v54;
      __int16 v93 = 2082;
      uint64_t v94 = (void *)v55;
      __int16 v95 = 2082;
      os_log_type_t v96 = v57;
      __int16 v97 = 2082;
      os_log_type_t v98 = v58;
      __int16 v99 = 2082;
      os_log_type_t v100 = v59;
      __int16 v101 = 2114;
      id v102 = v60;
      __int16 v103 = 2082;
      BOOL v104 = v62;
      _os_log_impl(&dword_1830D4000, v53, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to join protocol %{public}s", buf, 0x52u);
    }
    id v18 = v84;
  }
  *a10 = 1;
LABEL_68:

  return v85;
}

void sub_1831A7F74(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, void *a13, void *a14, void *a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_protocol_stack_replace_protocol_block_invoke_3(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v4 = a3;
  nw_protocol_definition_t v5 = nw_protocol_options_copy_definition(v4);
  if (nw_protocol_definition_is_equal_unsafe(*(void *)(a1 + 32), (uint64_t)v5)
    || nw_protocol_definition_is_equal_unsafe(*(void *)(a1 + 40), (uint64_t)v5))
  {
    BOOL v6 = nw_array_create();
    uint64_t v7 = *(void *)(*(void *)(a1 + 64) + 8);
    nw_protocol_definition_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;

    int v9 = *(atomic_uchar **)(*(void *)(a1 + 48) + 16);
    v14[0] = MEMORY[0x1E4F143A8];
    v14[1] = 3221225472;
    v14[2] = __nw_protocol_stack_replace_protocol_block_invoke_4;
    v14[3] = &unk_1E5244660;
    BOOL v15 = v4;
    long long v13 = *(_OWORD *)(a1 + 56);
    id v10 = (id)v13;
    long long v16 = v13;
    nw_array_apply(v9, (uint64_t)v14);

    uint64_t v11 = 0;
  }
  else
  {
    uint64_t v11 = 1;
  }

  return v11;
}

void sub_1831A8154(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_parameters_has_protocol_in_stack(void *a1, void *a2)
{
  id v3 = a1;
  BOOL v4 = nw_parameters_has_protocol_at_level(v3, 5, a2)
    || nw_parameters_has_protocol_at_level(v3, 4, a2)
    || nw_parameters_has_protocol_at_level(v3, 3, a2)
    || nw_parameters_has_protocol_at_level(v3, 2, a2);

  return v4;
}

BOOL nw_parameters_has_protocol_at_level(void *a1, int a2, void *a3)
{
  uint64_t v50 = *MEMORY[0x1E4F143B8];
  nw_protocol_definition_t v5 = a1;
  BOOL v6 = v5;
  if (v5)
  {
    if (a3)
    {
      uint64_t v7 = v5[19];
      nw_protocol_definition_t v8 = v7;
      if (v7)
      {
        *(void *)int v48 = 0;
        *(void *)&v48[8] = v48;
        *(void *)&v48[16] = 0x2020000000;
        char v49 = 0;
        switch(a2)
        {
          case 2:
            int v9 = (void *)v7[6];
            if (v9) {
              goto LABEL_11;
            }
            goto LABEL_15;
          case 3:
            int v9 = (void *)v7[3];
            if (v9)
            {
LABEL_11:
              os_log_type_t v12 = v9;
              id v13 = v12[1];

              identifier = nw_protocol_definition_get_identifier(v13);
              BOOL v15 = nw_protocols_are_equal(a3, identifier);
              *(unsigned char *)(*(void *)&v48[8] + 24) = v15;
            }
            goto LABEL_15;
          case 4:
            long long v16 = (atomic_uchar *)v7[2];
            __int16 v17 = v41;
            v41[0] = MEMORY[0x1E4F143A8];
            v41[1] = 3221225472;
            id v18 = __nw_parameters_has_protocol_at_level_block_invoke_2;
            goto LABEL_14;
          case 5:
            long long v16 = (atomic_uchar *)v7[1];
            __int16 v17 = v42;
            v42[0] = MEMORY[0x1E4F143A8];
            v42[1] = 3221225472;
            id v18 = __nw_parameters_has_protocol_at_level_block_invoke;
LABEL_14:
            v17[2] = v18;
            v17[3] = &unk_1E524BAD0;
            v17[4] = v48;
            v17[5] = a3;
            nw_array_apply(v16, (uint64_t)v17);
LABEL_15:
            BOOL v11 = *(unsigned char *)(*(void *)&v48[8] + 24) != 0;
            break;
          default:
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            id v10 = (id)gLogObj;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446466;
              id v45 = "nw_parameters_has_protocol_at_level";
              __int16 v46 = 1024;
              int v47 = a2;
              _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, "%{public}s Unsupported protocol level %u", buf, 0x12u);
            }

            BOOL v11 = 0;
            break;
        }
        _Block_object_dispose(v48, 8);
LABEL_17:

        goto LABEL_18;
      }
      uint64_t v26 = __nwlog_obj();
      *(_DWORD *)int v48 = 136446210;
      *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
      id v27 = (char *)_os_log_send_and_compose_impl();

      buf[0] = 16;
      char v43 = 0;
      if (__nwlog_fault(v27, buf, &v43))
      {
        if (buf[0] == 17)
        {
          uint64_t v28 = __nwlog_obj();
          os_log_type_t v29 = buf[0];
          if (os_log_type_enabled(v28, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)int v48 = 136446210;
            *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
            _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null stack", v48, 0xCu);
          }
        }
        else if (v43)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          uint64_t v28 = __nwlog_obj();
          os_log_type_t v36 = buf[0];
          BOOL v37 = os_log_type_enabled(v28, (os_log_type_t)buf[0]);
          if (backtrace_string)
          {
            if (v37)
            {
              *(_DWORD *)int v48 = 136446466;
              *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
              *(_WORD *)&v48[12] = 2082;
              *(void *)&v48[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v28, v36, "%{public}s called with null stack, dumping backtrace:%{public}s", v48, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_70;
          }
          if (v37)
          {
            *(_DWORD *)int v48 = 136446210;
            *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
            _os_log_impl(&dword_1830D4000, v28, v36, "%{public}s called with null stack, no backtrace", v48, 0xCu);
          }
        }
        else
        {
          uint64_t v28 = __nwlog_obj();
          os_log_type_t v40 = buf[0];
          if (os_log_type_enabled(v28, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)int v48 = 136446210;
            *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
            _os_log_impl(&dword_1830D4000, v28, v40, "%{public}s called with null stack, backtrace limit exceeded", v48, 0xCu);
          }
        }
      }
LABEL_70:
      if (v27) {
        free(v27);
      }
      BOOL v11 = 0;
      goto LABEL_17;
    }
    uint64_t v24 = __nwlog_obj();
    *(_DWORD *)int v48 = 136446210;
    *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v43 = 0;
    if (__nwlog_fault(v21, buf, &v43))
    {
      if (buf[0] == 17)
      {
        char v22 = __nwlog_obj();
        os_log_type_t v25 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)int v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null protocol_identifier", v48, 0xCu);
        }
LABEL_63:

        goto LABEL_64;
      }
      if (!v43)
      {
        char v22 = __nwlog_obj();
        os_log_type_t v39 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)int v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_1830D4000, v22, v39, "%{public}s called with null protocol_identifier, backtrace limit exceeded", v48, 0xCu);
        }
        goto LABEL_63;
      }
      id v30 = (char *)__nw_create_backtrace_string();
      char v22 = __nwlog_obj();
      os_log_type_t v33 = buf[0];
      BOOL v34 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!v30)
      {
        if (v34)
        {
          *(_DWORD *)int v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_1830D4000, v22, v33, "%{public}s called with null protocol_identifier, no backtrace", v48, 0xCu);
        }
        goto LABEL_63;
      }
      if (v34)
      {
        *(_DWORD *)int v48 = 136446466;
        *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
        *(_WORD *)&v48[12] = 2082;
        *(void *)&v48[14] = v30;
        _os_log_impl(&dword_1830D4000, v22, v33, "%{public}s called with null protocol_identifier, dumping backtrace:%{public}s", v48, 0x16u);
      }
      goto LABEL_43;
    }
  }
  else
  {
    char v20 = __nwlog_obj();
    *(_DWORD *)int v48 = 136446210;
    *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
    uint64_t v21 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    char v43 = 0;
    if (__nwlog_fault(v21, buf, &v43))
    {
      if (buf[0] == 17)
      {
        char v22 = __nwlog_obj();
        os_log_type_t v23 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)int v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null parameters", v48, 0xCu);
        }
        goto LABEL_63;
      }
      if (!v43)
      {
        char v22 = __nwlog_obj();
        os_log_type_t v38 = buf[0];
        if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)int v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_1830D4000, v22, v38, "%{public}s called with null parameters, backtrace limit exceeded", v48, 0xCu);
        }
        goto LABEL_63;
      }
      id v30 = (char *)__nw_create_backtrace_string();
      char v22 = __nwlog_obj();
      os_log_type_t v31 = buf[0];
      BOOL v32 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (!v30)
      {
        if (v32)
        {
          *(_DWORD *)int v48 = 136446210;
          *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
          _os_log_impl(&dword_1830D4000, v22, v31, "%{public}s called with null parameters, no backtrace", v48, 0xCu);
        }
        goto LABEL_63;
      }
      if (v32)
      {
        *(_DWORD *)int v48 = 136446466;
        *(void *)&v48[4] = "nw_parameters_has_protocol_at_level";
        *(_WORD *)&v48[12] = 2082;
        *(void *)&v48[14] = v30;
        _os_log_impl(&dword_1830D4000, v22, v31, "%{public}s called with null parameters, dumping backtrace:%{public}s", v48, 0x16u);
      }
LABEL_43:

      free(v30);
    }
  }
LABEL_64:
  if (v21) {
    free(v21);
  }
  BOOL v11 = 0;
LABEL_18:

  return v11;
}

BOOL __nw_parameters_has_protocol_at_level_block_invoke_2(uint64_t a1, int a2, nw_protocol_options_t options)
{
  nw_protocol_definition_t v4 = nw_protocol_options_copy_definition(options);
  identifier = nw_protocol_definition_get_identifier(v4);
  BOOL v6 = nw_protocols_are_equal(*(void **)(a1 + 40), identifier);
  if (v6) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
  BOOL v7 = !v6;

  return v7;
}

BOOL nw_protocols_are_equal(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2) {
      return *a1 == *a2 && a1[1] == a2[1] && a1[2] == a2[2] && a1[3] == a2[3] && a1[4] == a2[4];
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v18 = "nw_protocols_are_equal";
    BOOL v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_46;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_protocol_definition_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_protocols_are_equal";
        id v10 = "%{public}s called with null identifier2";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (!v15)
    {
      nw_protocol_definition_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_protocols_are_equal";
        id v10 = "%{public}s called with null identifier2, backtrace limit exceeded";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_protocol_definition_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_protocols_are_equal";
        id v10 = "%{public}s called with null identifier2, no backtrace";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (v14)
    {
      *(_DWORD *)buf = 136446466;
      id v18 = "nw_protocols_are_equal";
      __int16 v19 = 2082;
      char v20 = backtrace_string;
      id v13 = "%{public}s called with null identifier2, dumping backtrace:%{public}s";
      goto LABEL_35;
    }
    goto LABEL_36;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v18 = "nw_protocols_are_equal";
  BOOL v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15)) {
    goto LABEL_46;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      nw_protocol_definition_t v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_protocols_are_equal";
        id v10 = "%{public}s called with null identifier1, backtrace limit exceeded";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    nw_protocol_definition_t v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        id v18 = "nw_protocols_are_equal";
        id v10 = "%{public}s called with null identifier1, no backtrace";
        goto LABEL_45;
      }
      goto LABEL_46;
    }
    if (v12)
    {
      *(_DWORD *)buf = 136446466;
      id v18 = "nw_protocols_are_equal";
      __int16 v19 = 2082;
      char v20 = backtrace_string;
      id v13 = "%{public}s called with null identifier1, dumping backtrace:%{public}s";
LABEL_35:
      _os_log_impl(&dword_1830D4000, v8, v9, v13, buf, 0x16u);
    }
LABEL_36:
    free(backtrace_string);
    goto LABEL_46;
  }
  nw_protocol_definition_t v8 = __nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)buf = 136446210;
    id v18 = "nw_protocols_are_equal";
    id v10 = "%{public}s called with null identifier1";
LABEL_45:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
  }
LABEL_46:
  if (v7) {
    free(v7);
  }
  return 0;
}

void __nw_parameters_has_proxy_protocol_in_stack_block_invoke(uint64_t a1, nw_protocol_options_t options)
{
  nw_protocol_definition_t v3 = nw_protocol_options_copy_definition(options);
  if (nw_protocol_definition_is_proxy(v3)) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = 1;
  }
}

BOOL nw_protocol_definition_is_proxy(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  id v2 = v1;
  if (v1)
  {
    BOOL v3 = v1[184] < 0;
    goto LABEL_3;
  }
  nw_protocol_definition_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  long long v16 = "nw_protocol_definition_is_proxy";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_protocol_definition_is_proxy";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null definition", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          long long v16 = "nw_protocol_definition_is_proxy";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_protocol_definition_is_proxy";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null definition, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_protocol_definition_is_proxy";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t __nw_parameters_internal_iterate_protocol_stack_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  nw_protocol_definition_t v4 = a3;
  nw_protocol_definition_t v5 = nw_protocol_options_copy_definition(v4);
  uint64_t v6 = (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();

  return v6;
}

void sub_1831A922C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL __nw_protocol_stack_includes_protocol_block_invoke_2(uint64_t a1, int a2, nw_protocol_options_t options)
{
  nw_protocol_definition_t v4 = nw_protocol_options_copy_definition(options);
  BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(*(void *)(a1 + 32), (uint64_t)v4);
  if (is_equal_unsafe) {
    *(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = 1;
  }
  BOOL v6 = !is_equal_unsafe;

  return v6;
}

void sub_1831A9298(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_definition_t nw_protocol_options_copy_definition(nw_protocol_options_t options)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_protocol_options_t v1 = options;
  nw_protocol_options_t v2 = v1;
  if (v1)
  {
    BOOL v3 = v1[1].isa;
    goto LABEL_3;
  }
  nw_protocol_definition_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  long long v16 = "nw_protocol_options_copy_definition";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_protocol_options_copy_definition";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          long long v16 = "nw_protocol_options_copy_definition";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_protocol_options_copy_definition";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        long long v16 = "nw_protocol_options_copy_definition";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

uint64_t ___ZL33nw_endpoint_flow_attach_protocolsP30NWConcrete_nw_endpoint_handlerP11nw_protocolS2__block_invoke_222(uint64_t a1, uint64_t a2, void *a3, void *a4)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  id v7 = a3;
  id v8 = a4;
  identifier = nw_protocol_definition_get_identifier(v7);
  uint64_t registered_endpoint = *(void *)(a1 + 96);
  if (registered_endpoint) {
    goto LABEL_74;
  }
  id v88 = v8;
  int v11 = *(unsigned __int8 *)(*(void *)(*(void *)(a1 + 64) + 8) + 24);
  os_log_type_t v12 = *(void **)(a1 + 40);
  char v13 = *(void **)(*(void *)(*(void *)(a1 + 72) + 8) + 40);
  BOOL v14 = *(void **)(a1 + 48);
  id v15 = *(id *)(a1 + 32);
  id v89 = v12;
  id v16 = v13;
  id v90 = v14;
  id v86 = v15;
  id v87 = v16;
  if (!v15)
  {
    os_log_type_t v52 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    nw_endpoint_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (!__nwlog_fault(v35, &type, &v91)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v53 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v53, "%{public}s called with null handler", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (!v91)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v69 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v69, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_161;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v36 = __nwlog_obj();
    os_log_type_t v57 = type;
    BOOL v58 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v57, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (v58)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v94 = 2082;
      __int16 v95 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v36, v57, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_128;
  }
  __int16 v17 = (unsigned int *)v15;
  uint64_t v18 = v17[29];

  if (v18 != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v27 = (id)gLogObj;
    if (v18 > 5) {
      uint64_t v28 = "unknown-mode";
    }
    else {
      uint64_t v28 = off_1E523FB08[v18];
    }
    *(_DWORD *)buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    __int16 v94 = 2082;
    __int16 v95 = (void *)v28;
    __int16 v96 = 2082;
    __int16 v97 = "flow";
    nw_endpoint_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (__nwlog_fault(v35, &type, &v91))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v36 = (id)gLogObj;
        os_log_type_t v37 = type;
        if (os_log_type_enabled(v36, type))
        {
          if (v18 > 5) {
            os_log_type_t v38 = "unknown-mode";
          }
          else {
            os_log_type_t v38 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v94 = 2082;
          __int16 v95 = (void *)v38;
          __int16 v96 = 2082;
          __int16 v97 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v37, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
        goto LABEL_161;
      }
      if (!v91)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v36 = (id)gLogObj;
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v36, type))
        {
          if (v18 > 5) {
            id v45 = "unknown-mode";
          }
          else {
            id v45 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v94 = 2082;
          __int16 v95 = (void *)v45;
          __int16 v96 = 2082;
          __int16 v97 = "flow";
          _os_log_impl(&dword_1830D4000, v36, v44, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
        goto LABEL_161;
      }
      os_log_type_t v39 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v40 = (id)gLogObj;
      os_log_type_t v41 = type;
      BOOL v42 = os_log_type_enabled(v40, type);
      if (v39)
      {
        if (v42)
        {
          if (v18 > 5) {
            char v43 = "unknown-mode";
          }
          else {
            char v43 = off_1E523FB08[v18];
          }
          *(_DWORD *)buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
          __int16 v94 = 2082;
          __int16 v95 = (void *)v43;
          __int16 v96 = 2082;
          __int16 v97 = "flow";
          __int16 v98 = 2082;
          __int16 v99 = v39;
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v39);
        if (!v35) {
          goto LABEL_72;
        }
        goto LABEL_71;
      }
      if (v42)
      {
        if (v18 > 5) {
          __int16 v46 = "unknown-mode";
        }
        else {
          __int16 v46 = off_1E523FB08[v18];
        }
        *(_DWORD *)buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v94 = 2082;
        __int16 v95 = (void *)v46;
        __int16 v96 = 2082;
        __int16 v97 = "flow";
        _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
      }
    }
LABEL_70:
    if (!v35)
    {
LABEL_72:
      uint64_t registered_endpoint = 0;
      goto LABEL_73;
    }
LABEL_71:
    free(v35);
    goto LABEL_72;
  }
  if (!identifier)
  {
    id v54 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    nw_endpoint_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (!__nwlog_fault(v35, &type, &v91)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v55 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v55, "%{public}s called with null identifier", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (!v91)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v70 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v70, "%{public}s called with null identifier, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_161;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v36 = __nwlog_obj();
    os_log_type_t v63 = type;
    BOOL v64 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v64)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v63, "%{public}s called with null identifier, no backtrace", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (v64)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v94 = 2082;
      __int16 v95 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v36, v63, "%{public}s called with null identifier, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_128;
  }
  if (!v16)
  {
    BOOL v59 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    nw_endpoint_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (!__nwlog_fault(v35, &type, &v91)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v60 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v60, "%{public}s called with null endpoint", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (!v91)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v71 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v71, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_161;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v36 = __nwlog_obj();
    os_log_type_t v65 = type;
    BOOL v66 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v65, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (v66)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v94 = 2082;
      __int16 v95 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v36, v65, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_128;
  }
  if (!v90)
  {
    nw_endpoint_t v61 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
    nw_endpoint_t v35 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v91 = 0;
    if (!__nwlog_fault(v35, &type, &v91)) {
      goto LABEL_70;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v62 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v62, "%{public}s called with null parameters", buf, 0xCu);
      }
LABEL_161:

      goto LABEL_70;
    }
    if (!v91)
    {
      os_log_type_t v36 = __nwlog_obj();
      os_log_type_t v72 = type;
      if (os_log_type_enabled(v36, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v72, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_161;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v36 = __nwlog_obj();
    os_log_type_t v67 = type;
    BOOL v68 = os_log_type_enabled(v36, type);
    if (!backtrace_string)
    {
      if (v68)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        _os_log_impl(&dword_1830D4000, v36, v67, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
      goto LABEL_161;
    }
    if (v68)
    {
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      __int16 v94 = 2082;
      __int16 v95 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v36, v67, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_128:

    free(backtrace_string);
    if (!v35) {
      goto LABEL_72;
    }
    goto LABEL_71;
  }
  os_unfair_lock_lock(&nw_protocol_registrar_lock);
  uint64_t v19 = &g_registration_list;
  do
  {
    uint64_t v19 = (uint64_t *)*v19;
    if (!v19)
    {
      os_unfair_lock_unlock(&nw_protocol_registrar_lock);
      goto LABEL_31;
    }
  }
  while (*(void *)identifier != v19[4]
       || *((void *)identifier + 1) != v19[5]
       || *((void *)identifier + 2) != v19[6]
       || *((void *)identifier + 3) != v19[7]
       || *((void *)identifier + 4) != v19[8]);
  uint64_t v24 = v19[13];
  os_unfair_lock_unlock(&nw_protocol_registrar_lock);
  if (!v24)
  {
LABEL_31:
    if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v29 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v29, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v17);
        id v84 = nw_endpoint_handler_dry_run_string(v17);
        nw_endpoint_t v31 = nw_endpoint_handler_copy_endpoint(v17);
        logging_description = nw_endpoint_get_logging_description(v31);
        BOOL v32 = nw_endpoint_handler_state_string(v17);
        os_log_type_t v33 = nw_endpoint_handler_mode_string(v17);
        id v34 = nw_endpoint_handler_copy_current_path(v17);
        *(_DWORD *)buf = 136448258;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
        __int16 v94 = 2082;
        __int16 v95 = (void *)id_string;
        __int16 v96 = 2082;
        __int16 v97 = v84;
        __int16 v98 = 2082;
        __int16 v99 = (void *)logging_description;
        __int16 v100 = 2082;
        __int16 v101 = v32;
        __int16 v102 = 2082;
        __int16 v103 = v33;
        __int16 v104 = 2114;
        id v105 = v34;
        __int16 v106 = 2080;
        __int16 v107 = identifier;
        __int16 v108 = 2048;
        uint64_t v109 = (uint64_t)identifier;
        _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] protocol %s (%p) does not have accept function, cannot search for protocol to join", buf, 0x5Cu);
      }
    }
    goto LABEL_72;
  }
  id v25 = v16;
  uint64_t v26 = v25;
  while (1)
  {
    uint64_t registered_endpoint = nw_protocol_instance_registrar_search_for_instance_to_join((uint64_t)identifier, a2, v89, v26, v25, v90, v11 != 0);
    if (registered_endpoint) {
      break;
    }
    uint64_t registered_endpoint = (uint64_t)nw_protocol_instance_registrar_copy_next_registered_endpoint(v26, v11 != 0);

    uint64_t v26 = (void *)registered_endpoint;
    if (!registered_endpoint) {
      goto LABEL_53;
    }
  }
  if (gLogDatapath && (nw_endpoint_handler_get_logging_disabled(v17) & 1) == 0)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v73 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v73, OS_LOG_TYPE_DEBUG))
    {
      BOOL v85 = nw_endpoint_handler_get_id_string(v17);
      id v83 = nw_endpoint_handler_dry_run_string(v17);
      nw_endpoint_t v74 = nw_endpoint_handler_copy_endpoint(v17);
      id v81 = nw_endpoint_get_logging_description(v74);
      __int16 v80 = nw_endpoint_handler_state_string(v17);
      id v75 = nw_endpoint_handler_mode_string(v17);
      id v76 = nw_endpoint_handler_copy_current_path(v17);
      os_log_type_t v77 = v76;
      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_find_protocol_to_join";
      os_log_type_t v78 = "invalid";
      uint64_t v79 = *(const char **)(registered_endpoint + 16);
      *(_DWORD *)buf = 136448258;
      if (v79) {
        os_log_type_t v78 = v79;
      }
      __int16 v94 = 2082;
      __int16 v95 = (void *)v85;
      __int16 v96 = 2082;
      __int16 v97 = v83;
      __int16 v98 = 2082;
      __int16 v99 = (void *)v81;
      __int16 v100 = 2082;
      __int16 v101 = v80;
      __int16 v102 = 2082;
      __int16 v103 = v75;
      __int16 v104 = 2114;
      id v105 = v76;
      __int16 v106 = 2080;
      __int16 v107 = (void *)v78;
      __int16 v108 = 2048;
      uint64_t v109 = registered_endpoint;
      _os_log_impl(&dword_1830D4000, v73, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] returning protocol to join %s (%p)", buf, 0x5Cu);
    }
  }
LABEL_53:

LABEL_73:
  id v8 = v88;
  if (registered_endpoint)
  {
LABEL_74:
    if (nw_endpoint_flow_join_protocol(*(void **)(a1 + 32), *(void **)(a1 + 48), v8, v7, identifier, a2, registered_endpoint, *(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24), *(unsigned char *)(*(void *)(*(void *)(a1 + 64) + 8) + 24), (unsigned char *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)))
    {
      *(void *)(*(void *)(a1 + 56) + 736) = *(void *)(*(void *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)
                                                            + 32);
      *(unsigned char *)(*(void *)(a1 + 56) + 33) |= 1u;
      while (1)
      {
        uint64_t registered_endpoint = *(void *)(registered_endpoint + 32);
        if (!registered_endpoint) {
          break;
        }
        if (*(_DWORD *)(*(void *)(registered_endpoint + 16) + 32) == 3)
        {
          os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 56) + 880));
          uint64_t v47 = *(void *)(a1 + 56);
          if (!*(void *)(v47 + 720))
          {
            if (*(_UNKNOWN **)(registered_endpoint + 40) == &nw_protocol_ref_counted_handle)
            {
              uint64_t v49 = *(void *)(registered_endpoint + 88);
              if (v49)
              {
                *(void *)(registered_endpoint + 88) = v49 + 1;
                uint64_t v47 = *(void *)(a1 + 56);
              }
              *(void *)buf = registered_endpoint;
              char v48 = buf[8] | 1;
            }
            else
            {
              *(void *)buf = registered_endpoint;
              char v48 = buf[8] & 0xFE;
            }
            uint8_t buf[8] = v48;
            char v50 = *(unsigned char *)(v47 + 728);
            if (v50)
            {
              nw::release_if_needed<nw_protocol *>((uint64_t *)(v47 + 720));
              char v50 = *(unsigned char *)(v47 + 728);
              uint64_t registered_endpoint = *(void *)buf;
              char v48 = buf[8];
            }
            *(void *)(v47 + 720) = registered_endpoint;
            *(unsigned char *)(v47 + 728) = v50 & 0xFE | v48 & 1;
            uint64_t v47 = *(void *)(a1 + 56);
          }
          os_unfair_lock_unlock((os_unfair_lock_t)(v47 + 880));
          break;
        }
      }
    }
  }

  return 0;
}

void sub_1831AA6EC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19, void *a20,void *a21)
{
  _Unwind_Resume(a1);
}

BOOL nw_connection_endpoint_report_on_nw_queue(void *a1, int a2, int a3, uint64_t a4, void *a5, void *a6)
{
  id v11 = a1;
  id v12 = a5;
  id v13 = a6;
  BOOL v14 = (os_unfair_lock_s *)v13;
  if (v13)
  {
    nw_context_assert_queue(*((void **)v13 + 3));
    v16[0] = MEMORY[0x1E4F143A8];
    v16[1] = 3221225472;
    v16[2] = ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke;
    v16[3] = &unk_1E5249AC0;
    __int16 v17 = v14;
    uint64_t v20 = a4;
    id v18 = v11;
    id v19 = v12;
    int v21 = a3;
    int v22 = a2;
    os_unfair_lock_lock(v14 + 34);
    ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke((uint64_t)v16);
    os_unfair_lock_unlock(v14 + 34);
  }
  return v14 != 0;
}

void sub_1831AA8A8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke(uint64_t a1)
{
  uint64_t v548 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = mach_continuous_time();
  if (v2 <= 1) {
    uint64_t v3 = 1;
  }
  else {
    uint64_t v3 = v2;
  }
  unint64_t v4 = nw_delta_nanos(*(void *)(*(void *)(a1 + 32) + 72), v3);
  unint64_t v5 = v4 / 0xF4240;
  if (v4 > 0xF423FFFFFFFFFLL) {
    LODWORD(v5) = -1;
  }
  int v517 = v5;
  if (!*(void *)(a1 + 56)) {
    goto LABEL_51;
  }
  BOOL v6 = *(void **)(a1 + 40);
  if (!v6) {
    goto LABEL_51;
  }
  id v7 = v6;
  char v8 = v7[268];

  if (v8) {
    goto LABEL_51;
  }
  os_log_type_t v9 = *(void **)(a1 + 48);
  if (!v9)
  {
    LOBYTE(v15) = -1;
    goto LABEL_38;
  }
  id v10 = *(id *)(a1 + 32);
  id v11 = v9;
  if (!v10)
  {
    id v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
    __int16 v17 = (char *)_os_log_send_and_compose_impl();

    aBlock[0] = 16;
    v535[0] = 0;
    if (__nwlog_fault(v17, aBlock, v535))
    {
      if (aBlock[0] == 17)
      {
        id v18 = __nwlog_obj();
        os_log_type_t v19 = aBlock[0];
        if (os_log_type_enabled(v18, (os_log_type_t)aBlock[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v535[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v18 = __nwlog_obj();
        os_log_type_t v21 = aBlock[0];
        BOOL v22 = os_log_type_enabled(v18, (os_log_type_t)aBlock[0]);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_34;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v18 = __nwlog_obj();
        os_log_type_t v23 = aBlock[0];
        if (os_log_type_enabled(v18, (os_log_type_t)aBlock[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_add_error_locked_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_34:
    if (v17) {
      free(v17);
    }
    goto LABEL_36;
  }
  nw_context_assert_queue(*((void **)v10 + 3));
  uint64_t v12 = *((void *)v10 + 55);
  if (!v12)
  {
    BOOL v13 = nw_array_create();
    BOOL v14 = (void *)*((void *)v10 + 55);
    *((void *)v10 + 55) = v13;

    uint64_t v12 = *((void *)v10 + 55);
    if (!v12)
    {
      LOBYTE(v15) = 0;
      goto LABEL_17;
    }
  }
  if (*(void *)(v12 + 24) - *(void *)(v12 + 16) > 0x7F7uLL)
  {
LABEL_36:
    LOBYTE(v15) = -1;
    goto LABEL_37;
  }
  uint64_t v15 = (uint64_t)(*(void *)(v12 + 24) - *(void *)(v12 + 16)) >> 3;
LABEL_17:
  nw_array_append(v12, v11);
LABEL_37:

LABEL_38:
  *(void *)buf = v3;
  *(void *)&uint8_t buf[8] = 0;
  *(_DWORD *)&uint8_t buf[8] = **(_DWORD **)(a1 + 56);
  uint64_t v24 = *(void **)(a1 + 32);
  uint64_t v25 = *(void *)(a1 + 40);
  if (v25) {
    __int16 v26 = WORD1(v25) ^ WORD2(v25) ^ HIWORD(v25) ^ v25;
  }
  else {
    __int16 v26 = 0;
  }
  *(_WORD *)&unsigned char buf[12] = v26;
  *(_WORD *)&buf[14] = v15;
  nw_connection_add_timestamp_locked_on_nw_queue(v24, buf);
  nw_endpoint_t v27 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
  if (v27)
  {
    uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 328);
    if (!v28)
    {
      BOOL v29 = nw_array_create();
      uint64_t v30 = *(void *)(a1 + 32);
      nw_endpoint_t v31 = *(void **)(v30 + 328);
      *(void *)(v30 + 328) = v29;

      uint64_t v28 = *(void *)(*(void *)(a1 + 32) + 328);
      if (!v28) {
        goto LABEL_49;
      }
    }
    os_log_type_t v33 = *(nw_endpoint_t **)(v28 + 16);
    BOOL v32 = *(nw_endpoint_t **)(v28 + 24);
    if (v33 != v32)
    {
      while (*v33 != v27)
      {
        if (++v33 == v32)
        {
          os_log_type_t v33 = *(nw_endpoint_t **)(v28 + 24);
          break;
        }
      }
    }
    if (v33 == v32) {
LABEL_49:
    }
      nw_array_append(v28, v27);
  }

LABEL_51:
  id v34 = *(void **)(a1 + 40);
  if (!v34) {
    goto LABEL_155;
  }
  nw_endpoint_t v35 = *(_WORD **)(a1 + 56);
  if (*(void *)(a1 + 48))
  {
    if (v35 && *v35 == 1 && v35[1] != 1)
    {
      *(void *)aBlock = 0;
      *(void *)&aBlock[8] = 0;
      nw_endpoint_handler_get_client_id(v34, aBlock);
      if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v38 = (id)gconnectionLogObj;
        if (nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40))) {
          os_log_type_t is_dry_run = OS_LOG_TYPE_DEBUG;
        }
        else {
          os_log_type_t is_dry_run = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 40));
        }
        if (os_log_type_enabled(v38, is_dry_run))
        {
          id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          nw_endpoint_t v74 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          nw_endpoint_t v75 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          v514 = v74;
          logging_description = nw_endpoint_get_logging_description(v75);
          os_log_type_t v77 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          os_log_type_t v78 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          id v79 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          __int16 v80 = *(unsigned __int16 **)(a1 + 56);
          if (v80)
          {
            int v81 = *v80;
            if ((v81 - 1) > 6) {
              __int16 v82 = "unknown";
            }
            else {
              __int16 v82 = off_1E523FFD8[v81 - 1];
            }
            __int16 v94 = nw_endpoint_event_event_string(v81, v80[1]);
          }
          else
          {
            __int16 v82 = "null";
            __int16 v94 = "null";
          }
          uint64_t v95 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136449282;
          *(void *)&uint8_t buf[4] = id_string;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v514;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)&unsigned char buf[24] = logging_description;
          *(_WORD *)v522 = 2082;
          *(void *)&v522[2] = v77;
          *(_WORD *)&v522[10] = 2082;
          *(void *)&v522[12] = v78;
          *(_WORD *)&v522[20] = 2114;
          *(void *)&v522[22] = v79;
          __int16 v523 = 2082;
          v524 = v82;
          __int16 v525 = 2082;
          v526 = v94;
          __int16 v527 = 1024;
          int v528 = v517 / 1000;
          __int16 v529 = 1024;
          int v530 = v517 % 1000;
          __int16 v531 = 2114;
          *(void *)v532 = v95;
          *(_WORD *)&v532[8] = 1042;
          *(_DWORD *)&v532[10] = 16;
          __int16 v533 = 2098;
          v534 = aBlock;
          _os_log_impl(&dword_1830D4000, v38, is_dry_run, "[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] event: %{public}s:%{public}s @%u.%03us, error %{public}@, uuid: %{public,uuid_t}.16P", buf, 0x78u);
        }
        goto LABEL_145;
      }
    }
    else
    {
      os_log_type_t v36 = v34;
      BOOL v37 = (v36[268] & 0x20) == 0;

      if (v37)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v38 = (id)gconnectionLogObj;
        if (nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40))) {
          os_log_type_t v39 = OS_LOG_TYPE_DEBUG;
        }
        else {
          os_log_type_t v39 = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 40));
        }
        if (os_log_type_enabled(v38, v39))
        {
          char v43 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
          os_log_type_t v44 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
          nw_endpoint_t v45 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
          __int16 v46 = nw_endpoint_get_logging_description(v45);
          uint64_t v47 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
          char v48 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
          id v49 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          char v50 = v49;
          BOOL v51 = *(unsigned __int16 **)(a1 + 56);
          if (v51)
          {
            unsigned int v52 = *v51 - 1;
            if (v52 > 6) {
              os_log_type_t v53 = "unknown";
            }
            else {
              os_log_type_t v53 = off_1E523FFD8[v52];
            }
            int v67 = v51[1];
            switch(v52)
            {
              case 0u:
                if (--v67 >= 0xA) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E5240010;
                goto LABEL_121;
              case 1u:
                LOWORD(v67) = v67 - 1;
                if ((unsigned __int16)v67 >= 8u) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E5240060;
                goto LABEL_121;
              case 2u:
                if (--v67 >= 0xF) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E52400A0;
                goto LABEL_121;
              case 3u:
                if (--v67 >= 6) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E5240118;
                goto LABEL_121;
              case 4u:
                if (--v67 >= 5) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E5240148;
                goto LABEL_121;
              case 5u:
                if (--v67 >= 5) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E5240188;
                goto LABEL_121;
              case 6u:
                if (--v67 >= 3) {
                  goto LABEL_122;
                }
                BOOL v68 = off_1E5240170;
LABEL_121:
                os_log_type_t v65 = v68[(unsigned __int16)v67];
                break;
              default:
LABEL_122:
                os_log_type_t v65 = "unknown";
                break;
            }
          }
          else
          {
            os_log_type_t v53 = "null";
            os_log_type_t v65 = "null";
          }
          uint64_t v93 = *(void *)(a1 + 48);
          *(_DWORD *)buf = 136448770;
          *(void *)&uint8_t buf[4] = v43;
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v44;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)&unsigned char buf[24] = v46;
          *(_WORD *)v522 = 2082;
          *(void *)&v522[2] = v47;
          *(_WORD *)&v522[10] = 2082;
          *(void *)&v522[12] = v48;
          *(_WORD *)&v522[20] = 2114;
          *(void *)&v522[22] = v49;
          __int16 v523 = 2082;
          v524 = v53;
          __int16 v525 = 2082;
          v526 = v65;
          __int16 v527 = 1024;
          int v528 = v517 / 1000;
          __int16 v529 = 1024;
          int v530 = v517 % 1000;
          __int16 v531 = 2114;
          *(void *)v532 = v93;
          _os_log_impl(&dword_1830D4000, v38, v39, "[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] event: %{public}s:%{public}s @%u.%03us, error %{public}@", buf, 0x68u);
        }
LABEL_145:
      }
    }
  }
  else if (v35 && *v35 == 1 && v35[1] != 1)
  {
    *(void *)aBlock = 0;
    *(void *)&aBlock[8] = 0;
    nw_endpoint_handler_get_client_id(v34, aBlock);
    if ((nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40)) & 1) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v38 = (id)gconnectionLogObj;
      if (nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40))) {
        os_log_type_t v70 = OS_LOG_TYPE_DEBUG;
      }
      else {
        os_log_type_t v70 = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 40));
      }
      if (os_log_type_enabled(v38, v70))
      {
        id v83 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
        id v84 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
        nw_endpoint_t v85 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
        v515 = v84;
        id v86 = nw_endpoint_get_logging_description(v85);
        id v87 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
        id v88 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
        id v89 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
        id v90 = *(unsigned __int16 **)(a1 + 56);
        if (v90)
        {
          int v91 = *v90;
          if ((v91 - 1) > 6) {
            uint64_t v92 = "unknown";
          }
          else {
            uint64_t v92 = off_1E523FFD8[v91 - 1];
          }
          id v134 = nw_endpoint_event_event_string(v91, v90[1]);
        }
        else
        {
          uint64_t v92 = "null";
          id v134 = "null";
        }
        *(_DWORD *)buf = 136449026;
        *(void *)&uint8_t buf[4] = v83;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v515;
        *(_WORD *)&unsigned char buf[22] = 2082;
        *(void *)&unsigned char buf[24] = v86;
        *(_WORD *)v522 = 2082;
        *(void *)&v522[2] = v87;
        *(_WORD *)&v522[10] = 2082;
        *(void *)&v522[12] = v88;
        *(_WORD *)&v522[20] = 2114;
        *(void *)&v522[22] = v89;
        __int16 v523 = 2082;
        v524 = v92;
        __int16 v525 = 2082;
        v526 = v134;
        __int16 v527 = 1024;
        int v528 = v517 / 1000;
        __int16 v529 = 1024;
        int v530 = v517 % 1000;
        __int16 v531 = 1042;
        *(_DWORD *)v532 = 16;
        *(_WORD *)&v532[4] = 2098;
        *(void *)&v532[6] = aBlock;
        _os_log_impl(&dword_1830D4000, v38, v70, "[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] event: %{public}s:%{public}s @%u.%03us, uuid: %{public,uuid_t}.16P", buf, 0x6Eu);
      }
      goto LABEL_145;
    }
  }
  else
  {
    os_log_type_t v40 = v34;
    BOOL v41 = (v40[268] & 0x20) == 0;

    if (v41)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v38 = (id)gconnectionLogObj;
      if (nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40))) {
        os_log_type_t v42 = OS_LOG_TYPE_DEBUG;
      }
      else {
        os_log_type_t v42 = nw_endpoint_handler_is_dry_run(*(void **)(a1 + 40));
      }
      if (os_log_type_enabled(v38, v42))
      {
        id v54 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
        os_log_type_t v55 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
        nw_endpoint_t v56 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
        os_log_type_t v57 = nw_endpoint_get_logging_description(v56);
        BOOL v58 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
        BOOL v59 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
        id v60 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
        nw_endpoint_t v61 = v60;
        os_log_type_t v62 = *(unsigned __int16 **)(a1 + 56);
        if (v62)
        {
          unsigned int v63 = *v62 - 1;
          if (v63 > 6) {
            BOOL v64 = "unknown";
          }
          else {
            BOOL v64 = off_1E523FFD8[v63];
          }
          int v71 = v62[1];
          switch(v63)
          {
            case 0u:
              if (--v71 >= 0xA) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E5240010;
              goto LABEL_142;
            case 1u:
              LOWORD(v71) = v71 - 1;
              if ((unsigned __int16)v71 >= 8u) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E5240060;
              goto LABEL_142;
            case 2u:
              if (--v71 >= 0xF) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E52400A0;
              goto LABEL_142;
            case 3u:
              if (--v71 >= 6) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E5240118;
              goto LABEL_142;
            case 4u:
              if (--v71 >= 5) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E5240148;
              goto LABEL_142;
            case 5u:
              if (--v71 >= 5) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E5240188;
              goto LABEL_142;
            case 6u:
              if (--v71 >= 3) {
                goto LABEL_143;
              }
              os_log_type_t v72 = off_1E5240170;
LABEL_142:
              os_log_type_t v69 = v72[(unsigned __int16)v71];
              break;
            default:
LABEL_143:
              os_log_type_t v69 = "unknown";
              break;
          }
        }
        else
        {
          BOOL v64 = "null";
          os_log_type_t v69 = "null";
        }
        *(_DWORD *)buf = 136448514;
        *(void *)&uint8_t buf[4] = v54;
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = v55;
        *(_WORD *)&unsigned char buf[22] = 2082;
        *(void *)&unsigned char buf[24] = v57;
        *(_WORD *)v522 = 2082;
        *(void *)&v522[2] = v58;
        *(_WORD *)&v522[10] = 2082;
        *(void *)&v522[12] = v59;
        *(_WORD *)&v522[20] = 2114;
        *(void *)&v522[22] = v60;
        __int16 v523 = 2082;
        v524 = v64;
        __int16 v525 = 2082;
        v526 = v69;
        __int16 v527 = 1024;
        int v528 = v517 / 1000;
        __int16 v529 = 1024;
        int v530 = v517 % 1000;
        _os_log_impl(&dword_1830D4000, v38, v42, "[C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] event: %{public}s:%{public}s @%u.%03us", buf, 0x5Eu);
      }
      goto LABEL_145;
    }
  }
  __int16 v96 = *(void **)(a1 + 40);
  if (v96)
  {
    uint64_t v97 = *(void *)(a1 + 32);
    __int16 v98 = *(void **)(v97 + 144);
    if (v98)
    {
      if (v96 == v98 && !*(_DWORD *)(v97 + 280))
      {
        unsigned int v99 = *(_DWORD *)(a1 + 64);
        if (v99 <= 5 && ((1 << v99) & 0x3A) != 0)
        {
          id v100 = v96;
          os_unfair_lock_lock((os_unfair_lock_t)v100 + 28);
          id v101 = *((id *)v100 + 8);
          os_unfair_lock_unlock((os_unfair_lock_t)v100 + 28);

          if (v101)
          {
            __int16 v102 = v101;
            int v103 = v102[92];

            *(_DWORD *)(*(void *)(a1 + 32) + 280) = v103;
          }
        }
      }
    }
  }
LABEL_155:
  __int16 v104 = *(unsigned __int16 **)(a1 + 56);
  if (!v104) {
    goto LABEL_172;
  }
  int v105 = *v104;
  if (v105 != 4) {
    goto LABEL_162;
  }
  __int16 v106 = *(void **)(a1 + 40);
  if (v106)
  {
    __int16 v107 = v106;
    int v108 = v107[29];

    if (v108 == 3) {
      *(_DWORD *)(*(void *)(a1 + 32) + 504) = nw_endpoint_handler_get_proxy_privacy_stance(*(void **)(a1 + 40));
    }
  }
  uint64_t v109 = *(unsigned __int16 **)(a1 + 56);
  if (v109)
  {
    int v105 = *v109;
LABEL_162:
    if (v105 == 5 && !nw_parameters_get_multipath(*(void **)(*(void *)(a1 + 32) + 16))) {
      nw_connection_enable_stats_report_on_nw_queue(*(void **)(a1 + 32), 1);
    }
    uint64_t v110 = *(_WORD **)(a1 + 56);
    if (v110)
    {
      if (*v110 == 5 && v110[1] == 1)
      {
        if (*(void *)(*(void *)(a1 + 32) + 288))
        {
          os_log_type_t v111 = *(void **)(a1 + 40);
          if (v111)
          {
            BOOL v112 = v111;
            int v113 = v112[29];

            if (v113 == 4) {
              nw_endpoint_handler_reset_expected_progress_target(*(void **)(a1 + 40), *(void *)(*(void *)(a1 + 32) + 288), (const unsigned __int8 *)(*(void *)(a1 + 32) + 452));
            }
          }
        }
      }
    }
  }
LABEL_172:
  uint64_t v114 = *(void *)(a1 + 32);
  unsigned int v115 = *(unsigned __int8 *)(v114 + 109);
  if ((v115 & 0x40) != 0 && *(void *)(v114 + 144) == *(void *)(a1 + 40) && *(_DWORD *)(a1 + 68) != 2)
  {
    *(unsigned char *)(v114 + 109) = v115 & 0xBF;
    uint64_t v114 = *(void *)(a1 + 32);
    unsigned int v115 = *(unsigned __int8 *)(v114 + 109);
  }
  int v116 = (v115 >> 6) & 1;
  if (*(_DWORD *)(a1 + 68) == 2 && *(_DWORD *)(a1 + 64) == 3 && (v115 & 0x40) == 0)
  {
    int v116 = 0;
    uint64_t v117 = *(void *)(a1 + 40);
    if (v117)
    {
      if (v117 == *(void *)(v114 + 144))
      {
        BOOL v118 = *(void **)(v114 + 152);
        *(void *)(v114 + 152) = 0;

        *(unsigned char *)(*(void *)(a1 + 32) + 109) |= 0x40u;
        id v119 = (void **)*(id *)(a1 + 32);
        __int16 v120 = v119;
        if (v119)
        {
          nw_context_assert_queue(v119[3]);
          if ((*((unsigned char *)v120 + 109) & 0x40) != 0)
          {
            os_log_type_t v121 = v120[18];
            if (v121)
            {
              uint64_t v122 = (uint64_t)v120[36];
              if (v122)
              {
                nw_endpoint_t v123 = v121;
                __int16 v124 = v123;
                int v125 = v123[29];
                if (v125 == 4)
                {
                  nw_endpoint_fallback_reset_expected_progress_target(v123, v122);
                }
                else if (v125 == 2)
                {
                  nw_endpoint_flow_reset_expected_progress_target(v123, v122, (const unsigned __int8 *)v120 + 452);
                }
              }
              uint64_t v126 = v120[25];
              if (v126)
              {
                id v127 = v120[18];
                id v128 = v126;
                if (v127)
                {
                  os_log_type_t v129 = (NWConcrete_nw_endpoint_handler *)v127;
                  uint64_t mode = v129->mode;

                  if (mode == 2)
                  {
                    id v131 = (id *)nw_endpoint_handler_copy_flow(v129);
                    objc_storeStrong(v131 + 105, v126);

LABEL_233:
                    goto LABEL_234;
                  }
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  id v132 = (id)gLogObj;
                  if (mode > 5) {
                    int v133 = "unknown-mode";
                  }
                  else {
                    int v133 = off_1E523FB08[mode];
                  }
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v133;
                  *(_WORD *)&unsigned char buf[22] = 2082;
                  *(void *)&unsigned char buf[24] = "flow";
                  __int16 v135 = (char *)_os_log_send_and_compose_impl();

                  aBlock[0] = 16;
                  v535[0] = 0;
                  if (!__nwlog_fault(v135, aBlock, v535)) {
                    goto LABEL_231;
                  }
                  if (aBlock[0] == 17)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v136 = (id)gLogObj;
                    os_log_type_t v137 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      if (mode > 5) {
                        v138 = "unknown-mode";
                      }
                      else {
                        v138 = off_1E523FB08[mode];
                      }
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = v138;
                      *(_WORD *)&unsigned char buf[22] = 2082;
                      *(void *)&unsigned char buf[24] = "flow";
                      _os_log_impl(&dword_1830D4000, v136, v137, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
                    }
                  }
                  else if (v535[0])
                  {
                    os_log_type_t v139 = (char *)__nw_create_backtrace_string();
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v136 = (id)gLogObj;
                    os_log_type_t v140 = aBlock[0];
                    BOOL v141 = os_log_type_enabled(v136, (os_log_type_t)aBlock[0]);
                    if (v139)
                    {
                      if (v141)
                      {
                        if (mode > 5) {
                          long long v142 = "unknown-mode";
                        }
                        else {
                          long long v142 = off_1E523FB08[mode];
                        }
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                        *(_WORD *)&unsigned char buf[12] = 2082;
                        *(void *)&buf[14] = v142;
                        *(_WORD *)&unsigned char buf[22] = 2082;
                        *(void *)&unsigned char buf[24] = "flow";
                        *(_WORD *)v522 = 2082;
                        *(void *)&v522[2] = v139;
                        _os_log_impl(&dword_1830D4000, v136, v140, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
                      }

                      free(v139);
                      if (!v135) {
                        goto LABEL_233;
                      }
                      goto LABEL_232;
                    }
                    if (v141)
                    {
                      if (mode > 5) {
                        uint64_t v145 = "unknown-mode";
                      }
                      else {
                        uint64_t v145 = off_1E523FB08[mode];
                      }
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = v145;
                      *(_WORD *)&unsigned char buf[22] = 2082;
                      *(void *)&unsigned char buf[24] = "flow";
                      _os_log_impl(&dword_1830D4000, v136, v140, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
                    }
                  }
                  else
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    id v136 = (id)gLogObj;
                    os_log_type_t v143 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      if (mode > 5) {
                        uint64_t v144 = "unknown-mode";
                      }
                      else {
                        uint64_t v144 = off_1E523FB08[mode];
                      }
                      *(_DWORD *)buf = 136446722;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      *(_WORD *)&unsigned char buf[12] = 2082;
                      *(void *)&buf[14] = v144;
                      *(_WORD *)&unsigned char buf[22] = 2082;
                      *(void *)&unsigned char buf[24] = "flow";
                      _os_log_impl(&dword_1830D4000, v136, v143, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
                    }
                  }
                  goto LABEL_230;
                }
                v487 = __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                __int16 v135 = (char *)_os_log_send_and_compose_impl();

                aBlock[0] = 16;
                v535[0] = 0;
                if (__nwlog_fault(v135, aBlock, v535))
                {
                  if (aBlock[0] == 17)
                  {
                    id v136 = __nwlog_obj();
                    os_log_type_t v488 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      _os_log_impl(&dword_1830D4000, v136, v488, "%{public}s called with null handler", buf, 0xCu);
                    }
LABEL_230:

                    goto LABEL_231;
                  }
                  if (!v535[0])
                  {
                    id v136 = __nwlog_obj();
                    os_log_type_t v505 = aBlock[0];
                    if (os_log_type_enabled(v136, (os_log_type_t)aBlock[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      _os_log_impl(&dword_1830D4000, v136, v505, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
                    }
                    goto LABEL_230;
                  }
                  v494 = (char *)__nw_create_backtrace_string();
                  id v136 = __nwlog_obj();
                  os_log_type_t v495 = aBlock[0];
                  BOOL v496 = os_log_type_enabled(v136, (os_log_type_t)aBlock[0]);
                  if (!v494)
                  {
                    if (v496)
                    {
                      *(_DWORD *)buf = 136446210;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                      _os_log_impl(&dword_1830D4000, v136, v495, "%{public}s called with null handler, no backtrace", buf, 0xCu);
                    }
                    goto LABEL_230;
                  }
                  if (v496)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_set_client_queue";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = v494;
                    _os_log_impl(&dword_1830D4000, v136, v495, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v494);
                }
LABEL_231:
                if (!v135) {
                  goto LABEL_233;
                }
LABEL_232:
                free(v135);
                goto LABEL_233;
              }
            }
          }
LABEL_234:

          id v146 = *(id *)(a1 + 32);
          BOOL v147 = v146;
          if (v146)
          {
            nw_context_assert_queue(*((void **)v146 + 3));
            unsigned int v148 = (atomic_uchar *)v147[53];
            if (v148)
            {
              *(void *)buf = MEMORY[0x1E4F143A8];
              *(void *)&uint8_t buf[8] = 3221225472;
              *(void *)&buf[16] = ___ZL62nw_connection_take_initial_data_transfer_snapshots_on_nw_queueP24NWConcrete_nw_connection_block_invoke;
              *(void *)&unsigned char buf[24] = &unk_1E524AE18;
              *(void *)v522 = v147;
              nw_array_apply(v148, (uint64_t)buf);
            }
            goto LABEL_237;
          }
          v451 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_take_initial_data_transfer_snapshots_on_nw_queue";
          v452 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v535[0] = 0;
          if (__nwlog_fault(v452, aBlock, v535))
          {
            if (aBlock[0] == 17)
            {
              v453 = __nwlog_obj();
              os_log_type_t v454 = aBlock[0];
              if (os_log_type_enabled(v453, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_take_initial_data_transfer_snapshots_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v453, v454, "%{public}s called with null connection", buf, 0xCu);
              }
            }
            else if (v535[0])
            {
              v470 = (char *)__nw_create_backtrace_string();
              v453 = __nwlog_obj();
              os_log_type_t v471 = aBlock[0];
              BOOL v472 = os_log_type_enabled(v453, (os_log_type_t)aBlock[0]);
              if (v470)
              {
                if (v472)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_take_initial_data_transfer_snapshots_on_nw_queue";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v470;
                  _os_log_impl(&dword_1830D4000, v453, v471, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v470);
                goto LABEL_818;
              }
              if (v472)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_take_initial_data_transfer_snapshots_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v453, v471, "%{public}s called with null connection, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              v453 = __nwlog_obj();
              os_log_type_t v490 = aBlock[0];
              if (os_log_type_enabled(v453, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_take_initial_data_transfer_snapshots_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v453, v490, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
LABEL_818:
          if (v452) {
            free(v452);
          }
LABEL_237:

          uint64_t v149 = (void **)*(id *)(a1 + 32);
          os_log_type_t v150 = v149;
          if (v149)
          {
            nw_context_assert_queue(v149[3]);
            if (nw_parameters_get_is_probe(v150[2])) {
              goto LABEL_313;
            }
            BOOL v151 = v150;
            nw_context_assert_queue(v150[3]);
            if (!nw_connection_should_run_probe_locked(v151)
              || (*((unsigned char *)v150[2] + 101) & 0x40) == 0
              && !networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_enable_tls_experiments))
            {
LABEL_262:

              __int16 v167 = v151;
              nw_context_assert_queue(v150[3]);
              if (!nw_connection_should_run_probe_locked(v167))
              {
LABEL_312:

                goto LABEL_313;
              }
              if ((nw_parameters_get_tls(v150[2]) & 1) == 0)
              {
                BOOL v194 = v150[2];
                if (!v194 || nw_path_parameters_get_logging_disabled(v194[13])) {
                  goto LABEL_312;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                v168 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v168, OS_LOG_TYPE_DEBUG))
                {
                  unsigned int top_id = v167->top_id;
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = top_id;
                  _os_log_impl(&dword_1830D4000, v168, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] stack doesn't include TLS; not running ECH probe",
                    buf,
                    0x12u);
                }
                goto LABEL_311;
              }
              v168 = nw_protocol_boringssl_copy_definition();
              id v169 = nw_connection_copy_protocol_metadata_locked((uint64_t)v167, v168, 0, 0);
              uint64_t v170 = v169;
              if (v169)
              {
                __int16 v171 = v169;
                if (sec_protocol_metadata_get_negotiated_protocol_version(v171) != kTLSProtocol13)
                {
                  uint64_t v198 = v150[2];
                  if (v198 && !nw_path_parameters_get_logging_disabled(v198[13]))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v199 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v199, OS_LOG_TYPE_DEBUG))
                    {
                      unsigned int v200 = v167->top_id;
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v200;
                      _os_log_impl(&dword_1830D4000, v199, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] TLS 1.3 wasn't the negotiated protocol; not running ECH probe",
                        buf,
                        0x12u);
                    }
                  }
                  goto LABEL_309;
                }
                if (nw_endpoint_get_type((nw_endpoint_t)v167->endpoint) == nw_endpoint_type_host)
                {
                  v518 = v167;
                  v172 = (void *)nw_endpoint_handler_copy_connected_path(v518->parent_endpoint_handler);
                  __int16 v173 = v172;
                  if (!v172)
                  {
                    v327 = v150[2];
                    if (v327 && !nw_path_parameters_get_logging_disabled(v327[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      v328 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v328, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v329 = v518->top_id;
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_has_eligible_interface_for_probe";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v329;
                        _os_log_impl(&dword_1830D4000, v328, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] no connected path, not probing", buf, 0x12u);
                      }
                    }
                    goto LABEL_309;
                  }
                  uint64_t v174 = nw_path_copy_interface(v172);
                  __int16 v175 = v174;
                  if (!v174
                    || nw_interface_get_type(v174) != nw_interface_type_cellular
                    && nw_interface_get_type(v175) != nw_interface_type_wifi
                    && nw_interface_get_type(v175) != nw_interface_type_wired)
                  {
                    v335 = v150[2];
                    if (v335 && !nw_path_parameters_get_logging_disabled(v335[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      v336 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v336, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v337 = v518->top_id;
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_has_eligible_interface_for_probe";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v337;
                        _os_log_impl(&dword_1830D4000, v336, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] no interface or ineligible interface type, not probing", buf, 0x12u);
                      }
                    }
                    goto LABEL_309;
                  }

                  if (nw_parameters_get_should_skip_probe_sampling(v150[2]))
                  {
                    uint64_t v176 = v150[2];
                    if (v176 && !nw_path_parameters_get_logging_disabled(v176[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      __int16 v177 = (id)gconnectionLogObj;
                      if (!os_log_type_enabled(v177, OS_LOG_TYPE_INFO)) {
                        goto LABEL_280;
                      }
                      unsigned int v178 = v518->top_id;
                      *(_DWORD *)buf = 136446466;
                      *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                      *(_WORD *)&unsigned char buf[12] = 1024;
                      *(_DWORD *)&buf[14] = v178;
                      __int16 v179 = "%{public}s [C%u] sampling overridden, running ECH probe";
                      uint64_t v180 = v177;
                      os_log_type_t v181 = OS_LOG_TYPE_INFO;
                      uint32_t v182 = 18;
LABEL_279:
                      _os_log_impl(&dword_1830D4000, v180, v181, v179, buf, v182);
LABEL_280:

                      goto LABEL_281;
                    }
                    goto LABEL_281;
                  }
                  if (networkd_settings_get_BOOL((const char *)nw_setting_ech_probe_enabled))
                  {
                    uint32_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_ech_probe_numerator, 0);
                    uint32_t v339 = networkd_settings_get_int64_with_default((const char *)nw_setting_ech_probe_denominator, 0);
                    if (arc4random_uniform(v339) < int64_with_default)
                    {
                      v340 = v150[2];
                      if (v340 && !nw_path_parameters_get_logging_disabled(v340[13]))
                      {
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        __int16 v177 = (id)gconnectionLogObj;
                        if (!os_log_type_enabled(v177, OS_LOG_TYPE_DEBUG)) {
                          goto LABEL_280;
                        }
                        unsigned int v341 = v518->top_id;
                        *(_DWORD *)buf = 136446978;
                        *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v341;
                        *(_WORD *)&buf[18] = 1024;
                        *(_DWORD *)&buf[20] = int64_with_default;
                        *(_WORD *)&unsigned char buf[24] = 1024;
                        *(_DWORD *)&buf[26] = v339;
                        __int16 v179 = "%{public}s [C%u] ECH probe sampled at %u / %u";
                        uint64_t v180 = v177;
                        os_log_type_t v181 = OS_LOG_TYPE_DEBUG;
                        uint32_t v182 = 30;
                        goto LABEL_279;
                      }
LABEL_281:
                      nw_parameters_t v512 = nw_parameters_copy((nw_parameters_t)v150[2]);
                      v510 = nw_parameters_copy_protocol_options_for_definition(v512, v168);
                      sec_protocol_options_set_enable_encrypted_client_hello((sec_protocol_options_t)v510, 1);
                      *(void *)v535 = 0;
                      *(void *)&v535[8] = v535;
                      *(void *)&v535[16] = 0x2020000000;
                      v535[24] = 0;
                      uint64_t v183 = nw_parameters_copy_default_protocol_stack((nw_parameters_t)v150[2]);
                      nw_parameters_clear_protocol_stack(v512, 5);
                      nw_parameters_clear_protocol_stack(v512, 4);
                      nw_protocol_stack_t v184 = nw_parameters_copy_default_protocol_stack(v512);
                      *(void *)buf = MEMORY[0x1E4F143A8];
                      *(void *)&uint8_t buf[8] = 3221225472;
                      *(void *)&buf[16] = ___ZL46nw_connection_run_ech_probe_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke;
                      *(void *)&unsigned char buf[24] = &unk_1E523DDB0;
                      *(void *)&v522[16] = v535;
                      v185 = v184;
                      *(void *)v522 = v185;
                      v516 = v510;
                      *(void *)&v522[8] = v516;
                      v511 = v183;
                      nw_protocol_stack_iterate_application_protocols(v183, buf);
                      v513 = v185;
                      probe_locked = (NWConcrete_nw_connection *)nw_connection_create_probe_locked(v518, v512);
                      if (probe_locked)
                      {
                        BOOL v187 = nw_queue_copy_current_workloop();
                        nw_connection_set_queue(&probe_locked->super, (dispatch_queue_t)v187);

                        nw_connection_add_probe_locked(v518, probe_locked);
                        v188 = v150[3];
                        *(void *)aBlock = MEMORY[0x1E4F143A8];
                        *(void *)&aBlock[8] = 3221225472;
                        *(void *)&aBlock[16] = ___ZL46nw_connection_run_ech_probe_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_229;
                        v539 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E524BAA8;
                        os_log_type_t v189 = probe_locked;
                        v540 = (void (*)(uint64_t))v189;
                        nw_queue_context_async(v188, aBlock);
                        v190 = v150[2];
                        if (v190 && !nw_path_parameters_get_logging_disabled(v190[13]))
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          v191 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v191, OS_LOG_TYPE_INFO))
                          {
                            unsigned int v192 = v518->top_id;
                            *(_DWORD *)v542 = 136446722;
                            v543 = "nw_connection_run_ech_probe_locked_on_nw_queue";
                            __int16 v544 = 1024;
                            unsigned int v545 = v192;
                            __int16 v546 = 2112;
                            v547 = v189;
                            _os_log_impl(&dword_1830D4000, v191, OS_LOG_TYPE_INFO, "%{public}s [C%u] Started ECH probe: %@", v542, 0x1Cu);
                          }
                        }
                        os_log_type_t v193 = v540;
                      }
                      else
                      {
                        v350 = v150[2];
                        if (!v350 || nw_path_parameters_get_logging_disabled(v350[13])) {
                          goto LABEL_571;
                        }
                        if (__nwlog_connection_log::onceToken != -1) {
                          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                        }
                        os_log_type_t v193 = (id)gconnectionLogObj;
                        if (os_log_type_enabled(v193, OS_LOG_TYPE_INFO))
                        {
                          unsigned int v351 = v518->top_id;
                          *(_DWORD *)aBlock = 136446466;
                          *(void *)&void aBlock[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                          *(_WORD *)&aBlock[12] = 1024;
                          *(_DWORD *)&aBlock[14] = v351;
                          _os_log_impl(&dword_1830D4000, v193, OS_LOG_TYPE_INFO, "%{public}s [C%u] Could not create probe, nw_connection_create_probe_locked returned nil connection", aBlock, 0x12u);
                        }
                      }

LABEL_571:
                      _Block_object_dispose(v535, 8);

                      goto LABEL_309;
                    }
LABEL_557:
                    v347 = v150[2];
                    if (v347 && !nw_path_parameters_get_logging_disabled(v347[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      v348 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v348, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v349 = v518->top_id;
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v349;
                        _os_log_impl(&dword_1830D4000, v348, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] connection wasn't sampled for ECH probe", buf, 0x12u);
                      }
                    }
                    goto LABEL_309;
                  }
                  v344 = v150[2];
                  if (v344)
                  {
                    if (!nw_path_parameters_get_logging_disabled(v344[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      v345 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v345, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v346 = v518->top_id;
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v346;
                        _os_log_impl(&dword_1830D4000, v345, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] ECH probes not enabled on this network", buf, 0x12u);
                      }
                    }
                    goto LABEL_557;
                  }
                }
              }
              else
              {
                os_log_type_t v196 = v150[2];
                if (!v196 || nw_path_parameters_get_logging_disabled(v196[13])) {
                  goto LABEL_310;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                __int16 v171 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v171, OS_LOG_TYPE_DEBUG))
                {
                  unsigned int v197 = v167->top_id;
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_run_ech_probe_locked_on_nw_queue";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v197;
                  _os_log_impl(&dword_1830D4000, v171, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] No TLS metadata; not running ECH probe",
                    buf,
                    0x12u);
                }
              }
LABEL_309:

LABEL_310:
LABEL_311:

              goto LABEL_312;
            }
            *(void *)buf = MEMORY[0x1E4F143A8];
            *(void *)&uint8_t buf[8] = 3221225472;
            *(void *)&buf[16] = ___ZL51nw_connection_run_sec_experiment_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke;
            *(void *)&unsigned char buf[24] = &unk_1E52480D0;
            long long v152 = v151;
            *(void *)v522 = v152;
            long long v153 = _Block_copy(buf);
            *(void *)aBlock = MEMORY[0x1E4F143A8];
            *(void *)&aBlock[8] = 3221225472;
            *(void *)&aBlock[16] = ___ZL51nw_connection_run_sec_experiment_locked_on_nw_queueP24NWConcrete_nw_connection_block_invoke_225;
            v539 = (uint64_t (*)(uint64_t, uint64_t))&unk_1E5248B60;
            long long v154 = v152;
            v540 = v154;
            long long v155 = _Block_copy(aBlock);
            BOOL should_skip_probe_sampling = nw_parameters_get_should_skip_probe_sampling(v150[2]);
            BOOL v157 = nw_queue_copy_current_workloop();
            char v158 = sec_experiment_run_async_with_sampling_disabled();

            if (v158)
            {
              *((unsigned char *)v154 + 109) |= 1u;
              int v159 = v150[2];
              if (!v159 || nw_path_parameters_get_logging_disabled(v159[13])) {
                goto LABEL_261;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              nw_endpoint_t v160 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG))
              {
LABEL_260:

LABEL_261:
                goto LABEL_262;
              }
              int v161 = *((_DWORD *)v154 + 112);
              long long v162 = "enabled";
              *(void *)&v535[4] = "nw_connection_run_sec_experiment_locked_on_nw_queue";
              *(_DWORD *)v535 = 136446722;
              if (should_skip_probe_sampling) {
                long long v162 = "disabled";
              }
              *(_WORD *)&v535[12] = 1024;
              *(_DWORD *)&v535[14] = v161;
              *(_WORD *)&v535[18] = 2082;
              *(void *)&v535[20] = v162;
              char v163 = "%{public}s [C%u] Probe connection started with sampling %{public}s";
            }
            else
            {
              uint64_t v164 = v150[2];
              if (!v164 || nw_path_parameters_get_logging_disabled(v164[13])) {
                goto LABEL_261;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              nw_endpoint_t v160 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v160, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_260;
              }
              int v165 = *((_DWORD *)v154 + 112);
              v166 = "enabled";
              *(void *)&v535[4] = "nw_connection_run_sec_experiment_locked_on_nw_queue";
              *(_DWORD *)v535 = 136446722;
              if (should_skip_probe_sampling) {
                v166 = "disabled";
              }
              *(_WORD *)&v535[12] = 1024;
              *(_DWORD *)&v535[14] = v165;
              *(_WORD *)&v535[18] = 2082;
              *(void *)&v535[20] = v166;
              char v163 = "%{public}s [C%u] Probe connection not run with sampling %{public}s";
            }
            _os_log_impl(&dword_1830D4000, v160, OS_LOG_TYPE_DEBUG, v163, v535, 0x1Cu);
            goto LABEL_260;
          }
          v455 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_run_probes_locked_on_nw_queue";
          v456 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v535[0] = 0;
          if (__nwlog_fault(v456, aBlock, v535))
          {
            if (aBlock[0] == 17)
            {
              v457 = __nwlog_obj();
              os_log_type_t v458 = aBlock[0];
              if (os_log_type_enabled(v457, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_run_probes_locked_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v457, v458, "%{public}s called with null connection", buf, 0xCu);
              }
            }
            else if (v535[0])
            {
              v473 = (char *)__nw_create_backtrace_string();
              v457 = __nwlog_obj();
              os_log_type_t v474 = aBlock[0];
              BOOL v475 = os_log_type_enabled(v457, (os_log_type_t)aBlock[0]);
              if (v473)
              {
                if (v475)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_run_probes_locked_on_nw_queue";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v473;
                  _os_log_impl(&dword_1830D4000, v457, v474, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v473);
                goto LABEL_823;
              }
              if (v475)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_run_probes_locked_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v457, v474, "%{public}s called with null connection, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              v457 = __nwlog_obj();
              os_log_type_t v491 = aBlock[0];
              if (os_log_type_enabled(v457, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_run_probes_locked_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v457, v491, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
LABEL_823:
          if (v456) {
            free(v456);
          }
LABEL_313:

          v201 = (void **)*(id *)(a1 + 32);
          uint64_t v202 = v201;
          if (v201)
          {
            nw_context_assert_queue(v201[3]);
            uint64_t v203 = nw_endpoint_handler_copy_connected_flow_handler(v202[18]);
            uint64_t v204 = v203;
            if (v203)
            {
              uint64_t v205 = v203;
              id v206 = v205[4];

              if (v206)
              {
                id v207 = v206;
                uint64_t v208 = v207;
                if (*((void *)v207 + 24)
                  || (uint64_t v214 = (void *)*((void *)v207 + 23)) != 0
                  && (int v215 = v214, v216 = (v215[171] & 0x40) == 0, v215, !v216))
                {

                  uint32_t v209 = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_race_report_numerator, 1);
                  uint32_t v210 = networkd_settings_get_int64_with_default((const char *)nw_setting_proxy_race_report_denominator, 20000);
                  if (arc4random_uniform(v210) < v209)
                  {
                    v211 = v202[2];
                    if (v211 && !nw_path_parameters_get_logging_disabled(v211[13]))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      uint64_t v212 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v212, OS_LOG_TYPE_DEBUG))
                      {
                        int v213 = *((_DWORD *)v202 + 112);
                        *(_DWORD *)buf = 136446466;
                        *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                        *(_WORD *)&unsigned char buf[12] = 1024;
                        *(_DWORD *)&buf[14] = v213;
                        _os_log_impl(&dword_1830D4000, v212, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] selected for reporting (proxy race)", buf, 0x12u);
                      }
                    }
                    *((unsigned char *)v202 + 109) |= 2u;
                  }
                }
                else
                {
                }
              }
            }
            goto LABEL_331;
          }
          v459 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
          v460 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v535[0] = 0;
          if (__nwlog_fault(v460, aBlock, v535))
          {
            if (aBlock[0] == 17)
            {
              v461 = __nwlog_obj();
              os_log_type_t v462 = aBlock[0];
              if (os_log_type_enabled(v461, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v461, v462, "%{public}s called with null connection", buf, 0xCu);
              }
            }
            else if (v535[0])
            {
              v476 = (char *)__nw_create_backtrace_string();
              v461 = __nwlog_obj();
              os_log_type_t v477 = aBlock[0];
              BOOL v478 = os_log_type_enabled(v461, (os_log_type_t)aBlock[0]);
              if (v476)
              {
                if (v478)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v476;
                  _os_log_impl(&dword_1830D4000, v461, v477, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v476);
                goto LABEL_828;
              }
              if (v478)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v461, v477, "%{public}s called with null connection, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              v461 = __nwlog_obj();
              os_log_type_t v492 = aBlock[0];
              if (os_log_type_enabled(v461, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_check_proxy_race_report_locked_on_nw_queue";
                _os_log_impl(&dword_1830D4000, v461, v492, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
LABEL_828:
          if (v460) {
            free(v460);
          }
LABEL_331:

          id v217 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
          char v218 = v217;
          if (v217)
          {
            if (nw_path_is_multilayer_packet_logging_enabled(v217))
            {
              *(void *)aBlock = 0;
              *(void *)&aBlock[8] = 0;
              if (nw_endpoint_handler_get_flow_id(*(void **)(a1 + 40), aBlock))
              {
                uint64_t v219 = *(void *)(*(void *)(a1 + 32) + 16);
                if (v219 && !nw_path_parameters_get_logging_disabled(*(void *)(v219 + 104)))
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  v220 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v220, OS_LOG_TYPE_DEFAULT))
                  {
                    int v221 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v221;
                    _os_log_impl(&dword_1830D4000, v220, OS_LOG_TYPE_DEFAULT, "%{public}s [C%u] Multilayer packet logging enabled", buf, 0x12u);
                  }
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                v222 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v222, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v223 = *(void *)(a1 + 32);
                  int v224 = *(_DWORD *)(v223 + 448);
                  *(_DWORD *)buf = 67110146;
                  *(_DWORD *)&uint8_t buf[4] = v224;
                  *(_WORD *)&uint8_t buf[8] = 1042;
                  *(_DWORD *)&buf[10] = 16;
                  *(_WORD *)&buf[14] = 2098;
                  *(void *)&buf[16] = v223 + 452;
                  *(_WORD *)&unsigned char buf[24] = 1042;
                  *(_DWORD *)&buf[26] = 16;
                  *(_WORD *)&buf[30] = 2098;
                  *(void *)v522 = aBlock;
                  _os_log_impl(&dword_1830D4000, v222, OS_LOG_TYPE_DEFAULT, "[C%u %{public,uuid_t}.16P] newly connected endpoint handler with UUID %{public,uuid_t}.16P", buf, 0x28u);
                }

                pthread_once(&nw_mpkl_log_init(void)::init_once, (void (*)(void))nw_mpkl_log_init_once);
                uint64_t v225 = gMpklLogObj;
                if (os_log_type_enabled((os_log_t)gMpklLogObj, OS_LOG_TYPE_DEFAULT))
                {
                  uint64_t v226 = *(void *)(a1 + 32);
                  uint64_t v227 = v226 + 452;
                  LODWORD(v226) = *(unsigned __int8 *)(v226 + 500);
                  *(_DWORD *)buf = 67110658;
                  *(_DWORD *)&uint8_t buf[4] = 140;
                  *(_WORD *)&uint8_t buf[8] = 1024;
                  *(_DWORD *)&buf[10] = 150;
                  *(_WORD *)&buf[14] = 1042;
                  *(_DWORD *)&buf[16] = 16;
                  *(_WORD *)&buf[20] = 2098;
                  *(void *)&unsigned char buf[22] = v227;
                  *(_WORD *)&buf[30] = 1042;
                  *(_DWORD *)v522 = 16;
                  *(_WORD *)&v522[4] = 2098;
                  *(void *)&v522[6] = aBlock;
                  *(_WORD *)&v522[14] = 1024;
                  *(_DWORD *)&v522[16] = v226;
                  _os_log_impl(&dword_1830D4000, v225, OS_LOG_TYPE_DEFAULT, "33 {curProtocol: %hhu, nextProtocol: %hhu, curUUID: %{public}.16P, nextUUID: %{public}.16P, logSeqn: %hhu}", buf, 0x34u);
                }

                ++*(unsigned char *)(*(void *)(a1 + 32) + 500);
              }
            }
          }
          uint64_t v228 = *(void *)(a1 + 32);
          unint64_t v229 = *(void **)(v228 + 440);
          *(void *)(v228 + 440) = 0;

          uint64_t v230 = *(void **)(*(void *)(a1 + 32) + 432);
          *(void *)(*(void *)(a1 + 32) + 432) = 0;

          v231 = nw_endpoint_handler_copy_connected_flow_handler(*(void **)(a1 + 40));
          v519[0] = MEMORY[0x1E4F143A8];
          v519[1] = 3221225472;
          v519[2] = ___ZL41nw_connection_endpoint_report_on_nw_queuePU33objcproto22OS_nw_endpoint_handler8NSObject26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_errorS_PU23objcproto12OS_nw_objectS__block_invoke_219;
          v519[3] = &unk_1E523DD88;
          id v520 = *(id *)(a1 + 32);
          nw_endpoint_handler_access_proxy_handler(v231, v519);
          nw_connection_fillout_establishment_report_on_nw_queue(*(void **)(a1 + 32), 1);
          uint64_t v232 = *(void *)(a1 + 32);
          if ((*(unsigned char *)(v232 + 108) & 1) == 0)
          {
            os_log_type_t v233 = (id *)(id)v232;
            id v234 = v233[2];

            if (v234 && nw_parameters_get_ip_protocol(v234) == 6 && nw_parameters_get_multipath(v234)) {
              nw_connection_enable_stats_report_on_nw_queue(*(void **)(a1 + 32), 2);
            }

            uint64_t v232 = *(void *)(a1 + 32);
          }
          id v235 = nw_endpoint_handler_copy_current_path(*(void **)(v232 + 144));
          int v236 = v235;
          if (v235)
          {
            uint64_t v237 = v235;
            int v238 = v237[93];

            *(_DWORD *)(*(void *)(a1 + 32) + 284) = v238;
            uint64_t v239 = *(void *)(a1 + 32);
            int v240 = *(_DWORD *)(v239 + 284);
            uint64_t v241 = *(void *)(v239 + 16);
            if (v240)
            {
              if (v241 && !nw_path_parameters_get_logging_disabled(*(void *)(v241 + 104)))
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                long long v242 = (id)gconnectionLogObj;
                if (!os_log_type_enabled(v242, OS_LOG_TYPE_INFO)) {
                  goto LABEL_369;
                }
                uint64_t v243 = *(void *)(a1 + 32);
                int v244 = *(_DWORD *)(v243 + 448);
                LODWORD(v243) = *(_DWORD *)(v243 + 284);
                *(_DWORD *)buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke_2";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v244;
                *(_WORD *)&buf[18] = 1024;
                *(_DWORD *)&buf[20] = v243;
                long long v245 = "%{public}s [C%u] Connected fallback generation %u";
                os_log_type_t v246 = v242;
                os_log_type_t v247 = OS_LOG_TYPE_INFO;
                uint32_t v248 = 24;
LABEL_368:
                _os_log_impl(&dword_1830D4000, v246, v247, v245, buf, v248);
LABEL_369:
              }
            }
            else if (v241 && !nw_path_parameters_get_logging_disabled(*(void *)(v241 + 104)))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              long long v242 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v242, OS_LOG_TYPE_DEBUG)) {
                goto LABEL_369;
              }
              int v249 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v249;
              long long v245 = "%{public}s [C%u] Connected fallback generation 0";
              os_log_type_t v246 = v242;
              os_log_type_t v247 = OS_LOG_TYPE_DEBUG;
              uint32_t v248 = 18;
              goto LABEL_368;
            }
          }
          v250 = *(id *)(a1 + 32);
          id v251 = v250;
          if (v250)
          {
            uint64_t v252 = v250[2];
            if (v252 && !nw_path_parameters_get_logging_disabled(*(void *)(v252 + 104)))
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              v253 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v253, OS_LOG_TYPE_INFO))
              {
                int v254 = *((_DWORD *)v251 + 112);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v254;
                _os_log_impl(&dword_1830D4000, v253, OS_LOG_TYPE_INFO, "%{public}s [C%u] Checking whether to start candidate manager", buf, 0x12u);
              }
            }
            if (nw_parameters_get_multipath_service(*((nw_parameters_t *)v251 + 2)))
            {
              v255 = (uint64_t *)*((void *)v251 + 2);
              if (*((void *)v251 + 52))
              {
                if (nw_parameters_get_server_mode(v255))
                {
                  uint64_t v256 = *((void *)v251 + 2);
                  if (!v256 || nw_path_parameters_get_logging_disabled(*(void *)(v256 + 104))) {
                    goto LABEL_440;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  v257 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v257, OS_LOG_TYPE_DEFAULT))
                  {
                    int v258 = *((_DWORD *)v251 + 112);
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v258;
                    _os_log_impl(&dword_1830D4000, v257, OS_LOG_TYPE_DEFAULT, "%{public}s [C%u] Server side, will wait for call to set IDS endpoint", buf, 0x12u);
                  }
                  goto LABEL_401;
                }
                *(void *)aBlock = 0;
                *(void *)&aBlock[8] = aBlock;
                *(void *)&aBlock[16] = 0x3032000000;
                v539 = __Block_byref_object_copy__24353;
                v540 = __Block_byref_object_dispose__24354;
                id v541 = 0;
                *(void *)v535 = 0;
                *(void *)&v535[8] = v535;
                *(void *)&v535[16] = 0x3032000000;
                *(void *)&v535[24] = __Block_byref_object_copy__24353;
                v536 = __Block_byref_object_dispose__24354;
                id v537 = 0;
                v262 = *((void *)v251 + 52);
                *(void *)buf = MEMORY[0x1E4F143A8];
                *(void *)&uint8_t buf[8] = 3221225472;
                *(void *)&buf[16] = ___ZL54nw_connection_start_candidate_manager_if_needed_lockedP24NWConcrete_nw_connection_block_invoke;
                *(void *)&unsigned char buf[24] = &unk_1E523DDD8;
                id v263 = v251;
                *(void *)v522 = v263;
                *(void *)&v522[8] = aBlock;
                *(void *)&v522[16] = v535;
                nw_establishment_report_enumerate_resolution_reports(v262, buf);
                if ((nw_parameters_get_server_mode(*((void **)v251 + 2)) & 1) == 0)
                {
                  uint64_t v264 = *((void *)v251 + 2);
                  if (v264 && !nw_path_parameters_get_logging_disabled(*(void *)(v264 + 104)))
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    v265 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v265, OS_LOG_TYPE_DEFAULT))
                    {
                      unsigned int v266 = *((_DWORD *)v263 + 112);
                      *(_DWORD *)v542 = 136446466;
                      v543 = "nw_connection_start_candidate_manager_if_needed_locked";
                      __int16 v544 = 1024;
                      unsigned int v545 = v266;
                      _os_log_impl(&dword_1830D4000, v265, OS_LOG_TYPE_DEFAULT, "%{public}s [C%u] Client side", v542, 0x12u);
                    }
                  }
                  uint64_t v267 = *(void *)&aBlock[8];
                  if (!*(void *)(*(void *)&aBlock[8] + 40) && *(void *)(*(void *)&v535[8] + 40))
                  {
                    nw_endpoint_t v272 = nw_connection_copy_endpoint((nw_connection_t)v263);
                    v273 = *(void **)(*(void *)&aBlock[8] + 40);
                    *(void *)(*(void *)&aBlock[8] + 40) = v272;

                    uint64_t v274 = *((void *)v251 + 2);
                    if (v274 && !nw_path_parameters_get_logging_disabled(*(void *)(v274 + 104)))
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      v275 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v275, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v276 = *((_DWORD *)v263 + 112);
                        v277 = *(NWConcrete_nw_connection **)(*(void *)&aBlock[8] + 40);
                        *(_DWORD *)v542 = 136446722;
                        v543 = "nw_connection_start_candidate_manager_if_needed_locked";
                        __int16 v544 = 1024;
                        unsigned int v545 = v276;
                        __int16 v546 = 2112;
                        v547 = v277;
                        _os_log_impl(&dword_1830D4000, v275, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Trying to use original endpoint %@", v542, 0x1Cu);
                      }
                    }
                    nw_endpoint_type_t type = nw_endpoint_get_type(*(nw_endpoint_t *)(*(void *)&aBlock[8] + 40));
                    uint64_t v267 = *(void *)&aBlock[8];
                    if (type != nw_endpoint_type_bonjour_service)
                    {
                      v279 = *(void **)(*(void *)&aBlock[8] + 40);
                      *(void *)(*(void *)&aBlock[8] + 40) = 0;

                      uint64_t v267 = *(void *)&aBlock[8];
                    }
                  }
                  v268 = (uint64_t *)*((void *)v251 + 2);
                  if (!*(void *)(v267 + 40))
                  {
                    if (!v268 || nw_path_parameters_get_logging_disabled(v268[13])) {
                      goto LABEL_439;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    v280 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v280, OS_LOG_TYPE_DEBUG)) {
                      goto LABEL_438;
                    }
                    unsigned int v281 = *((_DWORD *)v263 + 112);
                    *(_DWORD *)v542 = 136446466;
                    v543 = "nw_connection_start_candidate_manager_if_needed_locked";
                    __int16 v544 = 1024;
                    unsigned int v545 = v281;
                    v282 = "%{public}s [C%u] No bonjour endpoint in establishment report, cannot start candidate manager";
                    v283 = v280;
                    os_log_type_t v284 = OS_LOG_TYPE_DEBUG;
                    goto LABEL_437;
                  }
                  if (nw_parameters_get_stricter_path_scoping(v268))
                  {
                    id v269 = nw_candidate_manager_create_with_connection(v263, *(void **)(*(void *)&aBlock[8] + 40));
                    v270 = (void *)*((void *)v263 + 7);
                    *((void *)v263 + 7) = v269;

                    v271 = (void *)*((void *)v263 + 7);
                    if (v271)
                    {
                      nw_candidate_manager_set_original_path(v271, *(void **)(*(void *)&v535[8] + 40));
                      nw_candidate_manager_start_client(*((void **)v263 + 7), 0);
                      goto LABEL_439;
                    }
                    uint64_t v285 = *((void *)v251 + 2);
                    if (!v285 || nw_path_parameters_get_logging_disabled(*(void *)(v285 + 104))) {
                      goto LABEL_439;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    v280 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v280, OS_LOG_TYPE_INFO))
                    {
LABEL_438:

                      goto LABEL_439;
                    }
                    unsigned int v286 = *((_DWORD *)v263 + 112);
                    *(_DWORD *)v542 = 136446466;
                    v543 = "nw_connection_start_candidate_manager_if_needed_locked";
                    __int16 v544 = 1024;
                    unsigned int v545 = v286;
                    v282 = "%{public}s [C%u] Failed to create candidate manager";
                    v283 = v280;
                    os_log_type_t v284 = OS_LOG_TYPE_INFO;
LABEL_437:
                    _os_log_impl(&dword_1830D4000, v283, v284, v282, v542, 0x12u);
                    goto LABEL_438;
                  }
                }
LABEL_439:

                _Block_object_dispose(v535, 8);
                _Block_object_dispose(aBlock, 8);

                goto LABEL_440;
              }
              if (!v255 || nw_path_parameters_get_logging_disabled(v255[13])) {
                goto LABEL_440;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              v257 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v257, OS_LOG_TYPE_ERROR))
              {
                int v261 = *((_DWORD *)v251 + 112);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v261;
                _os_log_impl(&dword_1830D4000, v257, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Establishment report is not ready, cannot start candidate manager", buf, 0x12u);
              }
            }
            else
            {
              uint64_t v259 = *((void *)v251 + 2);
              if (!v259 || nw_path_parameters_get_logging_disabled(*(void *)(v259 + 104))) {
                goto LABEL_440;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              v257 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v257, OS_LOG_TYPE_DEBUG))
              {
                int v260 = *((_DWORD *)v251 + 112);
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v260;
                _os_log_impl(&dword_1830D4000, v257, OS_LOG_TYPE_DEBUG, "%{public}s [C%u] Connection does not support multipath, not starting candidate manager", buf, 0x12u);
              }
            }
LABEL_401:

LABEL_440:
            uint64_t v114 = *(void *)(a1 + 32);
            LOBYTE(v115) = *(unsigned char *)(v114 + 109);
            int v116 = 1;
            goto LABEL_441;
          }
          v463 = __nwlog_obj();
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
          v464 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v535[0] = 0;
          if (__nwlog_fault(v464, aBlock, v535))
          {
            if (aBlock[0] == 17)
            {
              v465 = __nwlog_obj();
              os_log_type_t v466 = aBlock[0];
              if (os_log_type_enabled(v465, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                _os_log_impl(&dword_1830D4000, v465, v466, "%{public}s called with null connection", buf, 0xCu);
              }
            }
            else if (v535[0])
            {
              v479 = (char *)__nw_create_backtrace_string();
              v465 = __nwlog_obj();
              os_log_type_t v480 = aBlock[0];
              BOOL v481 = os_log_type_enabled(v465, (os_log_type_t)aBlock[0]);
              if (v479)
              {
                if (v481)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v479;
                  _os_log_impl(&dword_1830D4000, v465, v480, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
                }

                free(v479);
                goto LABEL_833;
              }
              if (v481)
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                _os_log_impl(&dword_1830D4000, v465, v480, "%{public}s called with null connection, no backtrace", buf, 0xCu);
              }
            }
            else
            {
              v465 = __nwlog_obj();
              os_log_type_t v493 = aBlock[0];
              if (os_log_type_enabled(v465, (os_log_type_t)aBlock[0]))
              {
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_connection_start_candidate_manager_if_needed_locked";
                _os_log_impl(&dword_1830D4000, v465, v493, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
              }
            }
          }
LABEL_833:
          if (v464) {
            free(v464);
          }
          goto LABEL_440;
        }
        v447 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
        v448 = (char *)_os_log_send_and_compose_impl();

        aBlock[0] = 16;
        v535[0] = 0;
        if (__nwlog_fault(v448, aBlock, v535))
        {
          if (aBlock[0] == 17)
          {
            v449 = __nwlog_obj();
            os_log_type_t v450 = aBlock[0];
            if (os_log_type_enabled(v449, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v449, v450, "%{public}s called with null connection", buf, 0xCu);
            }
          }
          else if (v535[0])
          {
            v467 = (char *)__nw_create_backtrace_string();
            v449 = __nwlog_obj();
            os_log_type_t v468 = aBlock[0];
            BOOL v469 = os_log_type_enabled(v449, (os_log_type_t)aBlock[0]);
            if (v467)
            {
              if (v469)
              {
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v467;
                _os_log_impl(&dword_1830D4000, v449, v468, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v467);
              goto LABEL_813;
            }
            if (v469)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v449, v468, "%{public}s called with null connection, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            v449 = __nwlog_obj();
            os_log_type_t v489 = aBlock[0];
            if (os_log_type_enabled(v449, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_connection_set_event_handlers_on_connected_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v449, v489, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_813:
        if (v448) {
          free(v448);
        }
        goto LABEL_234;
      }
    }
  }
LABEL_441:
  if ((v115 & 0x40) == 0)
  {
    uint64_t v288 = *(void *)(v114 + 152);
    v287 = (id *)(v114 + 152);
    if (!v288)
    {
      v289 = *(unsigned __int16 **)(a1 + 56);
      if (!v289) {
        goto LABEL_582;
      }
      int v290 = *v289;
      if (v290 != 3) {
        goto LABEL_445;
      }
      if (v289[1] == 5)
      {
        objc_storeStrong(v287, *(id *)(a1 + 40));
        uint64_t v311 = *(void *)(a1 + 32);
        if ((*(unsigned char *)(v311 + 108) & 1) == 0)
        {
          nw_parameters_t v312 = nw_connection_copy_parameters((nw_connection_t)v311);
          nw_parameters_t v313 = v312;
          if (v312 && nw_parameters_get_ip_protocol(v312) == 6 && nw_parameters_get_multipath(v313)) {
            nw_connection_enable_stats_report_on_nw_queue(*(void **)(a1 + 32), 2);
          }
        }
      }
    }
  }
  v289 = *(unsigned __int16 **)(a1 + 56);
  if (!v289) {
    goto LABEL_582;
  }
  int v290 = *v289;
LABEL_445:
  if (v290 == 5 && v289[1] - 3 <= 1)
  {
    uint64_t v291 = *(void *)(a1 + 32);
    if ((*(unsigned char *)(v291 + 109) & 0x40) != 0 || *(void *)(v291 + 152))
    {
      if (nw_connection_used_fallback_locked((void *)v291))
      {
        uint64_t v292 = *(void *)(a1 + 32);
        uint64_t v293 = 144;
        if ((*(unsigned char *)(v292 + 109) & 0x40) == 0) {
          uint64_t v293 = 152;
        }
        id v294 = *(id *)(v292 + v293);
        v295 = v294;
        if (v294)
        {
          v296 = (unsigned int *)v294;
          uint64_t v297 = v296[29];

          if (v297 == 2)
          {
            v298 = v296;
            int state = v298->state;

            if (state != 5)
            {
              v300 = nw_endpoint_handler_copy_flow(v298);
              if ((*((unsigned char *)v300 + 33) & 0x40) != 0) {
                goto LABEL_580;
              }
              v301 = v298;
              v302 = v301->parameters;

              LOBYTE(v301) = nw_parameters_multipath_fallback_allowed(v302);
              if (v301) {
                goto LABEL_580;
              }
              uint64_t v303 = *((void *)v300 + 114);
              if (!v303) {
                goto LABEL_580;
              }
              if (*(_UNKNOWN **)(v303 + 40) == &nw_protocol_ref_counted_handle)
              {
                *(_DWORD *)aBlock = 1;
                if (!setsockopt(*(_DWORD *)(v303 + 268), 0xFFFF, 4373, aBlock, 4u))
                {
                  if ((*(_WORD *)(v303 + 397) & 0x80) != 0) {
                    goto LABEL_580;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  uint64_t v330 = gconnectionLogObj;
                  if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO)) {
                    goto LABEL_580;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v303 + 404;
                  v307 = "%{public}s %{public}s Setting SO_MARK_CELLFALLBACK on socket";
                  v308 = v330;
                  os_log_type_t v309 = OS_LOG_TYPE_INFO;
                  uint32_t v310 = 22;
                  goto LABEL_523;
                }
                int v304 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                v305 = gconnectionLogObj;
                if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&unsigned char buf[12] = 2080;
                  *(void *)&buf[14] = v303 + 404;
                  *(_WORD *)&unsigned char buf[22] = 1024;
                  *(_DWORD *)&unsigned char buf[24] = v304;
                  _os_log_impl(&dword_1830D4000, v305, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d", buf, 0x1Cu);
                }
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                uint64_t v306 = gLogObj;
                if (v304 == 22)
                {
                  if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
                  {
LABEL_580:

                    goto LABEL_581;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 22;
                  v307 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d";
                  v308 = v306;
                  os_log_type_t v309 = OS_LOG_TYPE_ERROR;
                  uint32_t v310 = 18;
LABEL_523:
                  _os_log_impl(&dword_1830D4000, v308, v309, v307, buf, v310);
                  goto LABEL_580;
                }
                *(_DWORD *)buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v304;
                v331 = (char *)_os_log_send_and_compose_impl();
                v535[0] = 16;
                v542[0] = 0;
                if (!__nwlog_fault(v331, v535, v542)) {
                  goto LABEL_578;
                }
                if (v535[0] == 17)
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v332 = gLogObj;
                  os_log_type_t v333 = v535[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v535[0])) {
                    goto LABEL_578;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v304;
                  v334 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d";
                  goto LABEL_576;
                }
                if (!v542[0])
                {
                  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                  networkd_settings_init();
                  v332 = gLogObj;
                  os_log_type_t v333 = v535[0];
                  if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v535[0])) {
                    goto LABEL_578;
                  }
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v304;
                  v334 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_576;
                }
                v342 = (char *)__nw_create_backtrace_string();
                pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                networkd_settings_init();
                v332 = gLogObj;
                os_log_type_t v333 = v535[0];
                BOOL v343 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v535[0]);
                if (v342)
                {
                  if (v343)
                  {
                    *(_DWORD *)buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v304;
                    *(_WORD *)&buf[18] = 2082;
                    *(void *)&buf[20] = v342;
                    _os_log_impl(&dword_1830D4000, v332, v333, "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                  }
                  free(v342);
                  if (!v331) {
                    goto LABEL_580;
                  }
                  goto LABEL_579;
                }
                if (v343)
                {
                  *(_DWORD *)buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v304;
                  v334 = "%{public}s setsockopt SO_MARK_CELLFALLBACK failed %{darwin.errno}d, no backtrace";
LABEL_576:
                  v352 = v332;
                  os_log_type_t v353 = v333;
                  uint32_t v354 = 18;
LABEL_577:
                  _os_log_impl(&dword_1830D4000, v352, v353, v334, buf, v354);
                }
LABEL_578:
                if (!v331) {
                  goto LABEL_580;
                }
LABEL_579:
                free(v331);
                goto LABEL_580;
              }
              __nwlog_obj();
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
              v331 = (char *)_os_log_send_and_compose_impl();
              aBlock[0] = 16;
              v535[0] = 0;
              if (!__nwlog_fault(v331, aBlock, v535)) {
                goto LABEL_578;
              }
              if (aBlock[0] == 17)
              {
                v506 = __nwlog_obj();
                os_log_type_t v507 = aBlock[0];
                if (!os_log_type_enabled(v506, (os_log_type_t)aBlock[0])) {
                  goto LABEL_578;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                v334 = "%{public}s called with null socket_handler";
              }
              else if (v535[0])
              {
                v508 = (char *)__nw_create_backtrace_string();
                v506 = __nwlog_obj();
                os_log_type_t v507 = aBlock[0];
                BOOL v509 = os_log_type_enabled(v506, (os_log_type_t)aBlock[0]);
                if (v508)
                {
                  if (v509)
                  {
                    *(_DWORD *)buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = v508;
                    _os_log_impl(&dword_1830D4000, v506, v507, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
                  }
                  free(v508);
                  goto LABEL_578;
                }
                if (!v509) {
                  goto LABEL_578;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                v334 = "%{public}s called with null socket_handler, no backtrace";
              }
              else
              {
                v506 = __nwlog_obj();
                os_log_type_t v507 = aBlock[0];
                if (!os_log_type_enabled(v506, (os_log_type_t)aBlock[0])) {
                  goto LABEL_578;
                }
                *(_DWORD *)buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_socket_mark_fallback";
                v334 = "%{public}s called with null socket_handler, backtrace limit exceeded";
              }
              v352 = v506;
              os_log_type_t v353 = v507;
              uint32_t v354 = 12;
              goto LABEL_577;
            }
LABEL_581:

            goto LABEL_582;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          id v314 = (id)gLogObj;
          if (v297 > 5) {
            v315 = "unknown-mode";
          }
          else {
            v315 = off_1E523FB08[v297];
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v315;
          *(_WORD *)&unsigned char buf[22] = 2082;
          *(void *)&unsigned char buf[24] = "flow";
          v316 = (char *)_os_log_send_and_compose_impl();

          aBlock[0] = 16;
          v535[0] = 0;
          if (!__nwlog_fault(v316, aBlock, v535)) {
            goto LABEL_516;
          }
          if (aBlock[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v317 = (id)gLogObj;
            os_log_type_t v318 = aBlock[0];
            if (os_log_type_enabled(v317, (os_log_type_t)aBlock[0]))
            {
              if (v297 > 5) {
                v319 = "unknown-mode";
              }
              else {
                v319 = off_1E523FB08[v297];
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v319;
              *(_WORD *)&unsigned char buf[22] = 2082;
              *(void *)&unsigned char buf[24] = "flow";
              _os_log_impl(&dword_1830D4000, v317, v318, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
            }
          }
          else if (v535[0])
          {
            v320 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v317 = (id)gLogObj;
            os_log_type_t v321 = aBlock[0];
            BOOL v322 = os_log_type_enabled(v317, (os_log_type_t)aBlock[0]);
            if (v320)
            {
              if (v322)
              {
                if (v297 > 5) {
                  v323 = "unknown-mode";
                }
                else {
                  v323 = off_1E523FB08[v297];
                }
                *(_DWORD *)buf = 136446978;
                *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = v323;
                *(_WORD *)&unsigned char buf[22] = 2082;
                *(void *)&unsigned char buf[24] = "flow";
                *(_WORD *)v522 = 2082;
                *(void *)&v522[2] = v320;
                _os_log_impl(&dword_1830D4000, v317, v321, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
              }

              free(v320);
              if (!v316) {
                goto LABEL_581;
              }
              goto LABEL_517;
            }
            if (v322)
            {
              if (v297 > 5) {
                v326 = "unknown-mode";
              }
              else {
                v326 = off_1E523FB08[v297];
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v326;
              *(_WORD *)&unsigned char buf[22] = 2082;
              *(void *)&unsigned char buf[24] = "flow";
              _os_log_impl(&dword_1830D4000, v317, v321, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            v317 = (id)gLogObj;
            os_log_type_t v324 = aBlock[0];
            if (os_log_type_enabled(v317, (os_log_type_t)aBlock[0]))
            {
              if (v297 > 5) {
                v325 = "unknown-mode";
              }
              else {
                v325 = off_1E523FB08[v297];
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v325;
              *(_WORD *)&unsigned char buf[22] = 2082;
              *(void *)&unsigned char buf[24] = "flow";
              _os_log_impl(&dword_1830D4000, v317, v324, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
            }
          }
          goto LABEL_515;
        }
        v482 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
        v316 = (char *)_os_log_send_and_compose_impl();

        aBlock[0] = 16;
        v535[0] = 0;
        if (__nwlog_fault(v316, aBlock, v535))
        {
          if (aBlock[0] == 17)
          {
            v317 = __nwlog_obj();
            os_log_type_t v483 = aBlock[0];
            if (os_log_type_enabled(v317, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              _os_log_impl(&dword_1830D4000, v317, v483, "%{public}s called with null handler", buf, 0xCu);
            }
LABEL_515:

            goto LABEL_516;
          }
          if (!v535[0])
          {
            v317 = __nwlog_obj();
            os_log_type_t v497 = aBlock[0];
            if (os_log_type_enabled(v317, (os_log_type_t)aBlock[0]))
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              _os_log_impl(&dword_1830D4000, v317, v497, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
            }
            goto LABEL_515;
          }
          v484 = (char *)__nw_create_backtrace_string();
          v317 = __nwlog_obj();
          os_log_type_t v485 = aBlock[0];
          BOOL v486 = os_log_type_enabled(v317, (os_log_type_t)aBlock[0]);
          if (!v484)
          {
            if (v486)
            {
              *(_DWORD *)buf = 136446210;
              *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
              _os_log_impl(&dword_1830D4000, v317, v485, "%{public}s called with null handler, no backtrace", buf, 0xCu);
            }
            goto LABEL_515;
          }
          if (v486)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_mark_fallback";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v484;
            _os_log_impl(&dword_1830D4000, v317, v485, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v484);
        }
LABEL_516:
        if (!v316) {
          goto LABEL_581;
        }
LABEL_517:
        free(v316);
        goto LABEL_581;
      }
    }
  }
LABEL_582:
  int v355 = *(_DWORD *)(a1 + 64);
  int v356 = *(_DWORD *)(a1 + 68);
  v357 = *(_WORD **)(a1 + 56);
  if (v356 == 1 && v355 == 4 && v357 && *v357 == 2 && v357[1] == 2)
  {
    v358 = *(void **)(a1 + 48);
    if (v358)
    {
      v359 = v358;
      int v360 = v359[3];

      if (v360 != -65554)
      {
        v361 = *(void **)(a1 + 32);
        v362 = *(void **)(a1 + 40);
        int error_code = nw_error_get_error_code(*(nw_error_t *)(a1 + 48));
        nw_connection_report_symptom_on_nw_queue(v361, 421894, v362, error_code);
      }
    }
    v364 = *(void **)(a1 + 40);
    if (v364) {
      goto LABEL_591;
    }
    goto LABEL_639;
  }
  v365 = (void **)*(id *)(a1 + 32);
  v366 = v365;
  if (v365)
  {
    nw_context_assert_queue(v365[3]);
    if (v356 == 2
      && v355 == 4
      && v357
      && *v357 == 3
      && v357[1] == 7
      && ((nw_parameters_get_tls(v366[2]) & 1) != 0
       || (*((unsigned char *)v366 + 109) & 0x40) != 0 && nw_endpoint_handler_stack_uses_tls(v366[18])))
    {
      v367 = v366;
      nw_context_assert_queue(v366[3]);
      uint64_t v368 = *((unsigned __int16 *)v367 + 161);
      if (*((_WORD *)v367 + 161))
      {
        v369 = (char *)v367[39] + 10;
        while (*(v369 - 1) != 3 || *v369 != 5)
        {
          v369 += 8;
          if (!--v368) {
            goto LABEL_609;
          }
        }

        v371 = *(void **)(a1 + 32);
        v370 = *(void **)(a1 + 40);
        v372 = *(void **)(a1 + 48);
        if (v372)
        {
          v373 = v372;
          int v374 = v373[3];
        }
        else
        {
          int v374 = 0;
        }
        nw_connection_report_symptom_on_nw_queue(v371, 421893, v370, v374);
        goto LABEL_639;
      }
LABEL_609:
    }
    goto LABEL_610;
  }
  v439 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
  v440 = (char *)_os_log_send_and_compose_impl();

  aBlock[0] = 16;
  v535[0] = 0;
  if (__nwlog_fault(v440, aBlock, v535))
  {
    if (aBlock[0] == 17)
    {
      v441 = __nwlog_obj();
      os_log_type_t v442 = aBlock[0];
      if (os_log_type_enabled(v441, (os_log_type_t)aBlock[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v441, v442, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v535[0])
    {
      v443 = (char *)__nw_create_backtrace_string();
      v441 = __nwlog_obj();
      os_log_type_t v444 = aBlock[0];
      BOOL v445 = os_log_type_enabled(v441, (os_log_type_t)aBlock[0]);
      if (v443)
      {
        if (v445)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v443;
          _os_log_impl(&dword_1830D4000, v441, v444, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v443);
        goto LABEL_753;
      }
      if (v445)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v441, v444, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      v441 = __nwlog_obj();
      os_log_type_t v446 = aBlock[0];
      if (os_log_type_enabled(v441, (os_log_type_t)aBlock[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_event_is_tls_failure_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v441, v446, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_753:
  if (v440) {
    free(v440);
  }
LABEL_610:

  v375 = *(_WORD **)(a1 + 56);
  v376 = (void **)*(id *)(a1 + 32);
  v377 = v376;
  if (v375 && *v375 == 5 && v375[1] == 5 && (nw_parameters_get_tls(v376[2]) & 1) != 0)
  {

    v379 = *(void **)(a1 + 32);
    v378 = *(void **)(a1 + 40);
    v380 = *(void **)(a1 + 48);
    if (v380)
    {
      v381 = v380;
      int v382 = v381[3];
    }
    else
    {
      int v382 = 0;
    }
    nw_connection_report_symptom_on_nw_queue(v379, 421895, v378, v382);
    nw_connection_enable_stats_report_on_nw_queue(*(void **)(a1 + 32), 5);
  }
  else
  {

    int v383 = *(_DWORD *)(a1 + 64);
    int v384 = *(_DWORD *)(a1 + 68);
    v385 = *(_WORD **)(a1 + 56);
    if (v384 == 2 && v383 == 4 && v385)
    {
      if (*v385 == 3 && v385[1] == 7)
      {
        v387 = *(void **)(a1 + 32);
        v386 = *(void **)(a1 + 40);
        v388 = *(void **)(a1 + 48);
        if (v388)
        {
          v389 = v388;
          int v390 = v389[3];
        }
        else
        {
          int v390 = 0;
        }
        nw_connection_report_symptom_on_nw_queue(v387, 421904, v386, v390);
      }
    }
    else if (v384 == 3 && v383 == 4 && v385 && *v385 == 4 && v385[1] == 5)
    {
      v391 = *(void **)(a1 + 32);
      v392 = *(void **)(a1 + 40);
      v393 = *(NSObject **)(a1 + 48);
      int v394 = v393 ? nw_error_get_error_code(v393) : 0;
      nw_connection_report_symptom_on_nw_queue(v391, 421902, v392, v394);
      v364 = *(void **)(a1 + 40);
      if (v364) {
LABEL_591:
      }
        nw_connection_fillout_failed_resolution_report_on_nw_queue(*(void **)(a1 + 32), v364);
    }
  }
LABEL_639:
  if (*(_DWORD *)(a1 + 64) == 4 && (v395 = *(_WORD **)(a1 + 56)) != 0 && *v395 == 1 && v395[1] == 9)
  {
    *(unsigned char *)(*(void *)(a1 + 32) + 110) |= 1u;
  }
  else
  {
    v396 = *(void **)(a1 + 40);
    if (v396)
    {
      v397 = *(void **)(a1 + 32);
      nw_endpoint_t v398 = nw_endpoint_handler_copy_endpoint(v396);
      id v399 = v397;
      v400 = v398;
      v401 = v400;
      if (v400)
      {
        if (v400[11].isa)
        {
          if ((*((unsigned char *)v399 + 110) & 4) == 0)
          {
            v402 = v400;
            BOOL v403 = (HIBYTE(v402[28].isa) & 0x40) == 0;

            if (v403
              && nw_parameters_get_attribution(*((nw_parameters_t *)v399 + 2)) == nw_parameters_attribution_developer
              && ne_tracker_should_save_stacktrace())
            {
              char v404 = *((unsigned char *)v399 + 110);
              *((unsigned char *)v399 + 110) = v404 | 4;
              v405 = *((void *)v399 + 11);
              if (v405)
              {
                *(void *)buf = MEMORY[0x1E4F143A8];
                *(void *)&uint8_t buf[8] = 3221225472;
                *(void *)&buf[16] = ___ZL49nw_connection_check_for_unlisted_tracker_on_queueP24NWConcrete_nw_connectionPU25objcproto14OS_nw_endpoint8NSObject_block_invoke;
                *(void *)&unsigned char buf[24] = &unk_1E523DE00;
                *(void *)v522 = v402;
                dispatch_data_apply(v405, buf);
              }
              else
              {
                *((unsigned char *)v399 + 110) = v404 | 6;
              }
            }
          }
        }
      }
    }
  }
  if (!v116)
  {
    unsigned int v408 = *(_DWORD *)(a1 + 64);
    uint64_t v409 = *(void *)(a1 + 32);
    if (v408 != 5) {
      goto LABEL_671;
    }
LABEL_670:
    nw_connection_set_state_on_nw_queue((NWConcrete_nw_connection *)v409, 5u);
    goto LABEL_687;
  }
  uint64_t v406 = *(void *)(a1 + 32);
  if (!*(void *)(v406 + 176) && !nw_endpoint_handler_uses_multipath(*(void **)(v406 + 144)))
  {
    v407 = *(_WORD **)(a1 + 56);
    if (v407)
    {
      if (*v407 == 1 && v407[1] == 5) {
        nw_connection_start_dry_run_on_nw_queue(*(NWConcrete_nw_connection **)(a1 + 32));
      }
    }
  }
  unsigned int v408 = *(_DWORD *)(a1 + 64);
  uint64_t v409 = *(void *)(a1 + 32);
  if (v408 == 5) {
    goto LABEL_670;
  }
  if (*(void *)(a1 + 40) == *(void *)(v409 + 144))
  {
    v410 = *(_WORD **)(a1 + 56);
    if (v410 && *v410 == 3 && v410[1] == 8)
    {
      nw_connection_update_better_path_locked_on_nw_queue((NWConcrete_nw_connection *)v409);
      v411 = *(NWConcrete_nw_connection **)(a1 + 32);
      int is_viable = nw_endpoint_handler_is_viable(*(void **)(a1 + 40));
      nw_connection_send_viability_changed_on_nw_queue(v411, is_viable);
      uint64_t v409 = *(void *)(a1 + 32);
      unsigned int v408 = *(_DWORD *)(a1 + 64);
    }
    goto LABEL_686;
  }
LABEL_671:
  if ((*(unsigned char *)(v409 + 109) & 0x40) == 0)
  {
    uint64_t v413 = *(void *)(v409 + 144);
    if (*(void *)(a1 + 40) == v413)
    {
      if (v413)
      {
        if (v408 != 1
          || (v414 = *(_WORD **)(a1 + 56)) == 0
          || *v414 != 1
          || (int v415 = (unsigned __int16)v414[1], v415 != 5) && v415 != 3)
        {
LABEL_686:
          nw_connection_set_state_on_nw_queue((NWConcrete_nw_connection *)v409, v408);
          goto LABEL_687;
        }
        int minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40));
        char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40));
        if (!minimize_logging)
        {
          if (logging_disabled) {
            goto LABEL_687;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v418 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v418, OS_LOG_TYPE_INFO))
          {
            v419 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
            v420 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
            nw_endpoint_t v421 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
            v422 = nw_endpoint_get_logging_description(v421);
            v423 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
            v424 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
            v425 = (char *)nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v419;
            *(_WORD *)&unsigned char buf[22] = 2082;
            *(void *)&unsigned char buf[24] = v420;
            *(_WORD *)v522 = 2082;
            *(void *)&v522[2] = v422;
            *(_WORD *)&v522[10] = 2082;
            *(void *)&v522[12] = v423;
            *(_WORD *)&v522[20] = 2082;
            *(void *)&v522[22] = v424;
            __int16 v523 = 2114;
            v524 = v425;
            _os_log_impl(&dword_1830D4000, v418, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping state update", buf, 0x48u);
          }
          goto LABEL_685;
        }
        if ((logging_disabled & 1) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          v418 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v418, OS_LOG_TYPE_DEBUG))
          {
            v498 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
            v499 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
            nw_endpoint_t v500 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
            v501 = nw_endpoint_get_logging_description(v500);
            v502 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
            v503 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
            v504 = (char *)nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
            *(_DWORD *)buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_connection_endpoint_report_on_nw_queue_block_invoke";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v498;
            *(_WORD *)&unsigned char buf[22] = 2082;
            *(void *)&unsigned char buf[24] = v499;
            *(_WORD *)v522 = 2082;
            *(void *)&v522[2] = v501;
            *(_WORD *)&v522[10] = 2082;
            *(void *)&v522[12] = v502;
            *(_WORD *)&v522[20] = 2082;
            *(void *)&v522[22] = v503;
            __int16 v523 = 2114;
            v524 = v504;
            _os_log_impl(&dword_1830D4000, v418, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] skipping state update", buf, 0x48u);
          }
LABEL_685:
        }
      }
    }
  }
LABEL_687:
  uint64_t v427 = *(void *)(a1 + 32);
  v426 = *(void **)(a1 + 40);
  v428 = *(void **)(v427 + 144);
  if (v426 == v428)
  {
    if ((*(unsigned char *)(v427 + 109) & 0x40) != 0
      && (v429 = *(_WORD **)(a1 + 56)) != 0
      && *v429 == 1
      && (unsigned int v430 = (unsigned __int16)v429[1], v430 <= 6)
      && ((1 << v430) & 0x68) != 0)
    {
      id v431 = (id)v427;
      nw_context_assert_queue(*((void **)v431 + 3));
      v432 = (atomic_uchar *)*((void *)v431 + 53);
      if (v432) {
        nw_array_apply(v432, (uint64_t)&__block_literal_global_235);
      }

      uint64_t v427 = *(void *)(a1 + 32);
      v426 = *(void **)(a1 + 40);
      v428 = *(void **)(v427 + 144);
    }
    else
    {
      v428 = *(void **)(a1 + 40);
    }
  }
  if (v426 == v428 && v428)
  {
    v433 = *(_WORD **)(a1 + 56);
    if (v433 && *v433 == 1 && (unsigned int v434 = (unsigned __int16)v433[1], v434 <= 6) && ((1 << v434) & 0x68) != 0)
    {
      id v435 = v428;
      os_unfair_lock_lock((os_unfair_lock_t)v435 + 28);
      id v436 = *((id *)v435 + 8);
      os_unfair_lock_unlock((os_unfair_lock_t)v435 + 28);

      nw_connection_send_path_changed_on_nw_queue((void *)v427, v436);
      uint64_t v427 = *(void *)(a1 + 32);
      v426 = *(void **)(a1 + 40);
      v428 = *(void **)(v427 + 144);
    }
    else
    {
      v426 = v428;
    }
  }
  if (v426 == v428)
  {
    if (v428)
    {
      v437 = *(_WORD **)(a1 + 56);
      if (v437)
      {
        if (*v437 == 1 && v437[1] == 10)
        {
          v438 = (void *)nw_endpoint_handler_copy_connected_path(v428);
          nw_connection_send_path_changed_on_nw_queue((void *)v427, v438);
        }
      }
    }
  }
}

void sub_1831AFD80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_is_dry_run(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((unsigned char *)v1 + 268) & 1;
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v16 = "nw_endpoint_handler_is_dry_run";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_endpoint_handler_is_dry_run";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v16 = "nw_endpoint_handler_is_dry_run";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_endpoint_handler_is_dry_run";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v16 = "nw_endpoint_handler_is_dry_run";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_connection_set_state_on_nw_queue(NWConcrete_nw_connection *a1, unsigned int a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  unint64_t v4 = v3;
  if (v3)
  {
    nw_context_assert_queue(v3->context);
    int state = v4->state;
    if (state != a2 && state != 5)
    {
      v4->int state = a2;
      if (a2 == 4)
      {
        id v7 = v4;
        nw_context_assert_queue(v4->context);
        data_transfer_reports = v7->data_transfer_reports;
        if (data_transfer_reports)
        {
          os_log_type_t v9 = (OS_nw_array *)nw_array_create();
          if (v9 != data_transfer_reports)
          {
            os_log_type_t v10 = v9;
            std::vector<nw_object_wrapper_t>::__assign_with_size[abi:nn180100]<nw_object_wrapper_t*,nw_object_wrapper_t*>((uint64_t)&v9[2], (void **)data_transfer_reports[2].super.super.isa, (void **)data_transfer_reports[3].super.super.isa, (data_transfer_reports[3].super.super.isa - data_transfer_reports[2].super.super.isa) >> 3);
            data_transfer_reports = v10;
          }
          nw_array_apply((atomic_uchar *)data_transfer_reports, (uint64_t)&__block_literal_global_233);
        }
      }
      BOOL v11 = v4;
      nw_context_assert_queue(v4->context);
      nw_connection_report_state_with_handler_on_nw_queue(v11, a2, v11[26], v11[25]);
    }
    goto LABEL_13;
  }
  os_log_type_t v12 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_connection_set_state_on_nw_queue";
  char v13 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v13, &type, &v20))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v14 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_connection_set_state_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v14 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v14, type);
      if (backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v23 = "nw_connection_set_state_on_nw_queue";
          __int16 v24 = 2082;
          uint64_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_30;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_connection_set_state_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v14, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_connection_set_state_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_30:
  if (v13) {
    free(v13);
  }
LABEL_13:
}

void sub_1831B0658(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

const char *nw_endpoint_event_event_string(int a1, int a2)
{
  switch(a1)
  {
    case 1:
      unsigned __int16 v2 = a2 - 1;
      if ((a2 - 1) >= 0xA) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E5240010;
      goto LABEL_16;
    case 2:
      unsigned __int16 v2 = a2 - 1;
      if ((unsigned __int16)(a2 - 1) >= 8u) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E5240060;
      goto LABEL_16;
    case 3:
      unsigned __int16 v2 = a2 - 1;
      if ((a2 - 1) >= 0xF) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E52400A0;
      goto LABEL_16;
    case 4:
      unsigned __int16 v2 = a2 - 1;
      if ((a2 - 1) >= 6) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E5240118;
      goto LABEL_16;
    case 5:
      unsigned __int16 v2 = a2 - 1;
      if ((a2 - 1) >= 5) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E5240148;
      goto LABEL_16;
    case 6:
      unsigned __int16 v2 = a2 - 1;
      if ((a2 - 1) >= 5) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E5240188;
      goto LABEL_16;
    case 7:
      unsigned __int16 v2 = a2 - 1;
      if ((a2 - 1) >= 3) {
        goto LABEL_17;
      }
      uint64_t v3 = off_1E5240170;
LABEL_16:
      BOOL result = v3[v2];
      break;
    default:
LABEL_17:
      BOOL result = "unknown";
      break;
  }
  return result;
}

void nw_connection_send_path_changed_on_nw_queue(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_context_assert_queue(*((void **)v3 + 3));
    unint64_t v5 = (const void *)*((void *)v3 + 32);
    if (v5 && *((_DWORD *)v3 + 20) != 5)
    {
      BOOL v6 = _Block_copy(v5);
      dispatch_qos_class_t v7 = *((_DWORD *)v3 + 48);
      v17[0] = MEMORY[0x1E4F143A8];
      v17[1] = 3221225472;
      v17[2] = ___ZL43nw_connection_send_path_changed_on_nw_queueP24NWConcrete_nw_connectionPU21objcproto10OS_nw_path8NSObject_block_invoke;
      v17[3] = &unk_1E524B950;
      id v19 = v6;
      id v18 = v4;
      id v8 = v6;
      nw_connection_async_client(v3, v7, v17);
    }
    goto LABEL_5;
  }
  os_log_type_t v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v23 = "nw_connection_send_path_changed_on_nw_queue";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t v21 = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (__nwlog_fault(v10, &v21, &v20))
  {
    if (v21 == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = v21;
      if (os_log_type_enabled(v11, v21))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_connection_send_path_changed_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v14 = v21;
      BOOL v15 = os_log_type_enabled(v11, v21);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v23 = "nw_connection_send_path_changed_on_nw_queue";
          __int16 v24 = 2082;
          uint64_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_connection_send_path_changed_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = v21;
      if (os_log_type_enabled(v11, v21))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v23 = "nw_connection_send_path_changed_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v10) {
    free(v10);
  }
LABEL_5:
}

void sub_1831B0AA4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, void *a19)
{
  _Unwind_Resume(a1);
}

void nw_connection_send_viability_changed_on_nw_queue(NWConcrete_nw_connection *a1, int a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    os_log_type_t v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v34 = "nw_connection_send_viability_changed_on_nw_queue";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t v32 = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v17, &v32, &v31))
    {
      if (v32 == OS_LOG_TYPE_FAULT)
      {
        id v18 = __nwlog_obj();
        os_log_type_t v19 = v32;
        if (os_log_type_enabled(v18, v32))
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_connection_send_viability_changed_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v18 = __nwlog_obj();
        os_log_type_t v21 = v32;
        BOOL v22 = os_log_type_enabled(v18, v32);
        if (backtrace_string)
        {
          if (v22)
          {
            *(_DWORD *)buf = 136446466;
            id v34 = "nw_connection_send_viability_changed_on_nw_queue";
            __int16 v35 = 2082;
            os_log_type_t v36 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_connection_send_viability_changed_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null connection, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v18 = __nwlog_obj();
        os_log_type_t v23 = v32;
        if (os_log_type_enabled(v18, v32))
        {
          *(_DWORD *)buf = 136446210;
          id v34 = "nw_connection_send_viability_changed_on_nw_queue";
          _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_40:
    if (v17) {
      free(v17);
    }
    goto LABEL_23;
  }
  nw_context_assert_queue(v3->context);
  int reported_viable = v4->reported_viable;
  if (a2)
  {
    if (reported_viable == 1) {
      goto LABEL_23;
    }
  }
  else if (reported_viable == 2)
  {
    goto LABEL_23;
  }
  id viability_changed_handler = v4->viability_changed_handler;
  if (viability_changed_handler && v4->state != 5)
  {
    if (a2)
    {
      v4->int reported_viable = 1;
      id v7 = _Block_copy(viability_changed_handler);
    }
    else
    {
      v4->int reported_viable = 2;
      id v7 = _Block_copy(viability_changed_handler);
      if (nw_endpoint_handler_uses_multipath(v4->parent_endpoint_handler))
      {
        parameters = v4->parameters;
        if (parameters && !nw_path_parameters_get_logging_disabled(*((void *)parameters + 13)))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v9 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v9, OS_LOG_TYPE_INFO))
          {
            unsigned int top_id = v4->top_id;
            *(_DWORD *)buf = 136446466;
            id v34 = "nw_connection_send_viability_changed_on_nw_queue";
            __int16 v35 = 1024;
            LODWORD(v36) = top_id;
            _os_log_impl(&dword_1830D4000, v9, OS_LOG_TYPE_INFO, "%{public}s [C%u] Delaying not viable notification on a multipath protocol", buf, 0x12u);
          }
        }
        int64_t int64_with_default = networkd_settings_get_int64_with_default((const char *)nw_setting_multipath_viability_delay, 500);
        uint64_t viability_changed_timer = (uint64_t)v4->viability_changed_timer;
        if (!viability_changed_timer)
        {
          id v13 = nw_context_copy_implicit_context();
          v27[0] = MEMORY[0x1E4F143A8];
          v27[1] = 3221225472;
          v27[2] = ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke;
          v27[3] = &unk_1E523FD18;
          uint64_t v28 = v4;
          id v29 = v7;
          char v30 = 0;
          v4->uint64_t viability_changed_timer = (void *)nw_queue_context_create_source(v13, 2, 3, 0, v27, 0);

          uint64_t viability_changed_timer = (uint64_t)v4->viability_changed_timer;
        }
        dispatch_time_t v14 = dispatch_time(0x8000000000000000, 1000000 * int64_with_default);
        nw_queue_set_timer_values(viability_changed_timer, v14, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
        nw_queue_activate_source((uint64_t)v4->viability_changed_timer);
        goto LABEL_22;
      }
    }
    dispatch_qos_class_t client_qos_class = v4->client_qos_class;
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = ___ZL48nw_connection_send_viability_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke_3;
    v24[3] = &unk_1E5249BD0;
    id v7 = v7;
    id v25 = v7;
    char v26 = a2;
    nw_connection_async_client(v4, client_qos_class, v24);

LABEL_22:
  }
LABEL_23:
}

void sub_1831B0FD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,void *a24,void *a25)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_access_proxy_handler(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  unint64_t v5 = (void (**)(void, void))v4;
  if (!v3)
  {
    os_log_type_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_endpoint_handler_access_proxy_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_endpoint_handler_access_proxy_handler";
          __int16 v27 = 2082;
          uint64_t v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_43:
        if (!v10) {
          goto LABEL_9;
        }
        goto LABEL_44;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_42:

    goto LABEL_43;
  }
  if (!v4)
  {
    id v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v26 = "nw_endpoint_handler_access_proxy_handler";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null accessor", buf, 0xCu);
      }
    }
    else if (v23)
    {
      id v18 = (char *)__nw_create_backtrace_string();
      BOOL v11 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v11, type);
      if (v18)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446466;
          char v26 = "nw_endpoint_handler_access_proxy_handler";
          __int16 v27 = 2082;
          uint64_t v28 = v18;
          _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null accessor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v18);
        if (!v10) {
          goto LABEL_9;
        }
LABEL_44:
        free(v10);
        goto LABEL_9;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null accessor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v11 = __nwlog_obj();
      os_log_type_t v22 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v26 = "nw_endpoint_handler_access_proxy_handler";
        _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null accessor, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_42;
  }
  BOOL v6 = v3;
  while (1)
  {
    BOOL v6 = v6;
    int v7 = v6[29];

    if (v7 == 3) {
      break;
    }
    id v8 = v6;
    BOOL v6 = v8[9];

    if (!v6) {
      goto LABEL_8;
    }
  }
  ((void (**)(void, _DWORD *))v5)[2](v5, v6);
LABEL_8:

LABEL_9:
}

void sub_1831B1538(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_parameters_t nw_connection_copy_parameters(nw_connection_t connection)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = connection;
  nw_connection_t v2 = v1;
  if (v1)
  {
    id v3 = v1[2].isa;
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_connection_copy_parameters";
  BOOL v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_connection_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_connection_copy_parameters";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_connection_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_connection_copy_parameters";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_parameters_get_should_skip_probe_sampling(void *a1)
{
  nw_connection_t v1 = a1;
  if (os_variant_allows_internal_security_policies()) {
    BOOL v2 = (v1[101] & 0x40) != 0
  }
      || networkd_settings_get_BOOL((const char *)nw_setting_tcpconn_disable_tls_experiment_sampling);
  else {
    BOOL v2 = 0;
  }

  return v2;
}

void sub_1831B1858(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_migration_callback(void *a1, void *a2)
{
  id v6 = a1;
  id v3 = a2;
  *((_DWORD *)v6 + 20) = 655361;
  nw_endpoint_handler_report(v6, 0, (_WORD *)v6 + 40, 0);
  id v4 = _Block_copy(*((const void **)v6 + 6));
  unint64_t v5 = v4;
  if (v4) {
    (*((void (**)(void *, id))v4 + 2))(v4, v3);
  }
}

void sub_1831B190C(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, id a10)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_receive_report(void *a1, int a2, int a3, unsigned __int16 *a4, void *a5, void *a6)
{
  BOOL v11 = a1;
  uint64_t v412 = *MEMORY[0x1E4F143B8];
  os_log_type_t v12 = a1;
  id v371 = a5;
  id v13 = a6;
  v372 = v13;
  v373 = v12;
  if (!v13)
  {
    v289 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    v387 = "nw_endpoint_flow_receive_report";
    int v290 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v381[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v290, type, v381))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v291 = __nwlog_obj();
        os_log_type_t v292 = type[0];
        if (os_log_type_enabled(v291, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v387 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_1830D4000, v291, v292, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v381[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v291 = __nwlog_obj();
        os_log_type_t v294 = type[0];
        BOOL v295 = os_log_type_enabled(v291, type[0]);
        if (backtrace_string)
        {
          if (v295)
          {
            *(_DWORD *)buf = 136446466;
            v387 = "nw_endpoint_flow_receive_report";
            __int16 v388 = 2082;
            v389 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v291, v294, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_397;
        }
        if (v295)
        {
          *(_DWORD *)buf = 136446210;
          v387 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_1830D4000, v291, v294, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v291 = __nwlog_obj();
        os_log_type_t v300 = type[0];
        if (os_log_type_enabled(v291, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          v387 = "nw_endpoint_flow_receive_report";
          _os_log_impl(&dword_1830D4000, v291, v300, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_397:
    if (v290) {
      free(v290);
    }
    goto LABEL_18;
  }
  os_log_type_t v14 = (unsigned int *)v13;
  uint64_t v15 = v14[29];

  if (v15 == 2)
  {
    int v354 = a3;
    v359 = v14;
    os_log_type_t v16 = v14;
    char v17 = *((unsigned char *)v16 + 268);

    v367 = v16;
    v358 = a4;
    if ((v17 & 0x20) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v18 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v18, OS_LOG_TYPE_DEBUG))
      {
        uint64_t v19 = v367;

        BOOL v20 = v19;
        char v21 = *((unsigned char *)v367 + 268);

        if (v21) {
          os_log_type_t v22 = "dry-run ";
        }
        else {
          os_log_type_t v22 = "";
        }
        os_log_t log = v18;
        nw_endpoint_t v363 = nw_endpoint_handler_copy_endpoint(v20);
        logging_description = nw_endpoint_get_logging_description(v363);
        __int16 v24 = v20;
        id v25 = v24;
        uint64_t v26 = v24[30];
        if (v26 > 5) {
          __int16 v27 = "unknown-state";
        }
        else {
          __int16 v27 = off_1E523FB38[v26];
        }
        os_log_t v348 = (os_log_t)v27;

        char v31 = v25;
        v361 = v11;
        int v355 = v22;
        v352 = logging_description;
        os_log_type_t v32 = "path";
        switch(v359[29])
        {
          case 0u:
            break;
          case 1u:
            os_log_type_t v32 = "resolver";
            break;
          case 2u:
            os_log_type_t v32 = nw_endpoint_flow_mode_string(v31[31]);
            break;
          case 3u:
            os_log_type_t v32 = "proxy";
            break;
          case 4u:
            os_log_type_t v32 = "fallback";
            break;
          case 5u:
            os_log_type_t v32 = "transform";
            break;
          default:
            os_log_type_t v32 = "unknown-mode";
            break;
        }
        os_log_t v346 = (os_log_t)v32;

        os_log_type_t v33 = v31;
        os_unfair_lock_lock((os_unfair_lock_t)v33 + 28);
        id v34 = v33[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v33 + 28);

        id v35 = v34;
        id_string = nw_endpoint_handler_get_id_string(v373);
        uint64_t v37 = nw_endpoint_handler_dry_run_string(v373);
        nw_endpoint_t v38 = nw_endpoint_handler_copy_endpoint(v373);
        int v39 = a2;
        os_log_type_t v40 = nw_endpoint_get_logging_description(v38);
        BOOL v41 = v19 + 168;
        os_log_type_t v42 = nw_endpoint_handler_state_string(v373);
        char v43 = nw_endpoint_handler_mode_string(v373);
        id v44 = nw_endpoint_handler_copy_current_path(v373);
        *(_DWORD *)buf = 136449282;
        v387 = "nw_endpoint_flow_receive_report";
        __int16 v388 = 2082;
        v389 = v41;
        __int16 v390 = 2082;
        v391 = v355;
        __int16 v392 = 2082;
        v393 = (void *)v352;
        __int16 v394 = 2082;
        v395 = v348;
        __int16 v396 = 2082;
        v397 = v346;
        __int16 v398 = 2114;
        id v399 = v35;
        __int16 v400 = 2082;
        v401 = id_string;
        __int16 v402 = 2082;
        BOOL v403 = v37;
        __int16 v404 = 2082;
        v405 = v40;
        __int16 v406 = 2082;
        v407 = v42;
        __int16 v408 = 2082;
        uint64_t v409 = v43;
        __int16 v410 = 2114;
        id v411 = v44;
        id v18 = log;
        _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] received child report: [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] ", buf, 0x84u);

        BOOL v11 = v361;
        a2 = v39;
      }
      os_log_type_t v12 = v373;
      os_log_type_t v16 = v367;
      a4 = v358;
    }
    if (a4 && *a4 == 3)
    {
      int v45 = a4[1];
      if (v45 == 6)
      {
        __int16 v46 = 13;
        goto LABEL_36;
      }
      if (v45 == 9)
      {
        __int16 v46 = 15;
LABEL_36:
        *((_WORD *)v16 + 40) = 3;
        *((_WORD *)v16 + 41) = v46;
        nw_endpoint_handler_report(v16, v12, (_WORD *)v16 + 40, v371);
LABEL_37:
        uint64_t v47 = nw_endpoint_handler_copy_flow((NWConcrete_nw_endpoint_handler *)v16);
        char v48 = (os_unfair_lock_s *)((char *)v47 + 880);
        os_unfair_lock_lock((os_unfair_lock_t)v47 + 220);
        int v49 = 0;
        id v50 = 0;
        v364 = v47;
        if (a2 == 2)
        {
          loga = 0;
          if (v354 != 3) {
            goto LABEL_70;
          }
          int v49 = 0;
          id v50 = 0;
          if (a4 && v12)
          {
            loga = 0;
            if (!*((void *)v47 + 117))
            {
              if (*a4 == 3 && a4[1] == 6)
              {
                id v356 = *((id *)v47 + 118);
                BOOL v51 = (void *)*((void *)v47 + 118);
                *((void *)v47 + 118) = 0;

                objc_storeStrong((id *)v47 + 117, v11);
                unsigned int v52 = nw_endpoint_handler_copy_flow(v373);
                os_log_type_t v53 = v52;
                if (!*((void *)v47 + 96) && v52 && *((void *)v52 + 96))
                {
                  *((unsigned char *)v47 + 35) |= 2u;
                  nw_endpoint_flow_reinitialize_protocol_for_handling_requests(v373);
                }
                loga = v373;
                if ((*((unsigned char *)v47 + 32) & 2) == 0) {
                  goto LABEL_69;
                }
                id v54 = __nwlog_obj();
                *(_DWORD *)buf = 136446210;
                v387 = "nw_endpoint_flow_receive_report";
                os_log_type_t v55 = (char *)_os_log_send_and_compose_impl();

                type[0] = OS_LOG_TYPE_ERROR;
                v381[0] = OS_LOG_TYPE_DEFAULT;
                if (__nwlog_fault(v55, type, v381))
                {
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    nw_endpoint_t v56 = __nwlog_obj();
                    os_log_type_t v57 = type[0];
                    if (os_log_type_enabled(v56, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v387 = "nw_endpoint_flow_receive_report";
                      _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s leaf flow had child flow become ready", buf, 0xCu);
                    }
                  }
                  else if (v381[0])
                  {
                    BOOL v58 = (char *)__nw_create_backtrace_string();
                    nw_endpoint_t v56 = __nwlog_obj();
                    os_log_type_t v59 = type[0];
                    BOOL v60 = os_log_type_enabled(v56, type[0]);
                    if (v58)
                    {
                      if (v60)
                      {
                        *(_DWORD *)buf = 136446466;
                        v387 = "nw_endpoint_flow_receive_report";
                        __int16 v388 = 2082;
                        v389 = v58;
                        _os_log_impl(&dword_1830D4000, v56, v59, "%{public}s leaf flow had child flow become ready, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      free(v58);
                      goto LABEL_67;
                    }
                    if (v60)
                    {
                      *(_DWORD *)buf = 136446210;
                      v387 = "nw_endpoint_flow_receive_report";
                      _os_log_impl(&dword_1830D4000, v56, v59, "%{public}s leaf flow had child flow become ready, no backtrace", buf, 0xCu);
                    }
                  }
                  else
                  {
                    nw_endpoint_t v56 = __nwlog_obj();
                    os_log_type_t v61 = type[0];
                    if (os_log_type_enabled(v56, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v387 = "nw_endpoint_flow_receive_report";
                      _os_log_impl(&dword_1830D4000, v56, v61, "%{public}s leaf flow had child flow become ready, backtrace limit exceeded", buf, 0xCu);
                    }
                  }
                }
LABEL_67:
                if (v55) {
                  free(v55);
                }
LABEL_69:

                int v49 = 1;
                os_log_type_t v12 = v373;
                id v50 = v356;
                a4 = v358;
                os_log_type_t v16 = v367;
                goto LABEL_70;
              }
              id v50 = 0;
              loga = 0;
              int v49 = 0;
            }
LABEL_70:
            v357 = v50;
            unsigned int v62 = 0;
            unsigned int v63 = (void *)*((void *)v47 + 117);
            if (a4 && v63 == v16)
            {
              int v64 = *a4;
              if (v64 == 1)
              {
                unsigned int v65 = a4[1];
                if (v65 <= 6)
                {
                  unsigned int v62 = (0x68u >> v65) & 1;
                  goto LABEL_78;
                }
              }
              else if (v64 == 3)
              {
                unsigned int v62 = a4[1] == 8;
                goto LABEL_78;
              }
              unsigned int v62 = 0;
            }
LABEL_78:
            int v353 = v49;
            if (a2 == 2 && a4 && !v63 && *a4 == 3 && a4[1] == 9)
            {
              uint64_t v66 = *((void *)v47 + 118);
              if (!v66)
              {
                BOOL v67 = nw_array_create();
                BOOL v68 = (void *)*((void *)v47 + 118);
                *((void *)v47 + 118) = v67;

                uint64_t v66 = *((void *)v47 + 118);
                os_log_type_t v12 = v373;
                os_log_type_t v16 = v367;
                a4 = v358;
              }
              if (!v66 || !v12) {
                goto LABEL_92;
              }
              os_log_type_t v70 = *(id **)(v66 + 16);
              os_log_type_t v69 = *(id **)(v66 + 24);
              if (v70 != v69)
              {
                while (*v70 != v12)
                {
                  if (++v70 == v69)
                  {
                    os_log_type_t v70 = *(id **)(v66 + 24);
                    break;
                  }
                }
              }
              if (v70 == v69)
              {
LABEL_92:
                nw_array_append(v66, v12);
LABEL_113:
                v362 = v12;
                int v353 = 1;
                goto LABEL_115;
              }
              goto LABEL_114;
            }
            if (a4 && v63 == v12 && (*((unsigned char *)v47 + 32) & 1) != 0 && *a4 == 1)
            {
              int v71 = a4[1];
              if (a2 != 2 || v71 == 7)
              {
                os_unfair_lock_unlock(v48);
                if (v71 == 7)
                {
                  nw_endpoint_flow_cleanup_protocol(v16, (uint64_t)v47 + 376, 1);
                  *((_WORD *)v47 + 354) &= ~1u;
                  nw_endpoint_flow_initialize_protocol(v16, (char *)v47 + 376, *((unsigned char *)v47 + 32) & 1);
                  os_log_type_t v121 = (void *)*((void *)v47 + 117);
                  *((void *)v47 + 117) = 0;

                  uint64_t v122 = v367;
                  v122[30] = 2;

                  os_log_type_t v12 = v373;
                  os_log_type_t v16 = v367;
                  nw_endpoint_handler_report(v122, 0, v358, 0);
                  if (!loga)
                  {
                    v362 = 0;
                    goto LABEL_340;
                  }
                  v362 = 0;
                  goto LABEL_118;
                }
                v362 = 0;
                if (!v62)
                {
LABEL_117:
                  if (!loga)
                  {
                    if (!v362)
                    {
                      v362 = 0;
                      if (!v353)
                      {
LABEL_342:
                        if (*((NWConcrete_nw_endpoint_handler **)v47 + 116) != v12)
                        {
LABEL_343:
                          uint64_t v30 = 1;
                          goto LABEL_344;
                        }
                        if (v354 == 4)
                        {
                          *((unsigned char *)v47 + 35) |= 4u;
                          int v261 = v16;
                          int state = v261->state;

                          if (state != 5
                            && (*((unsigned char *)v364 + 32) & 1) != 0
                            && nw_endpoint_handler_get_has_better_path(v261, 0))
                          {
                            int minimize_logging = nw_endpoint_handler_get_minimize_logging(v261);
                            char logging_disabled = nw_endpoint_handler_get_logging_disabled(v261);
                            if (minimize_logging)
                            {
                              if (logging_disabled) {
                                goto LABEL_357;
                              }
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              v265 = (id)gconnectionLogObj;
                              if (os_log_type_enabled(v265, OS_LOG_TYPE_DEBUG))
                              {
                                unsigned int v337 = nw_endpoint_handler_get_id_string(v261);
                                v338 = nw_endpoint_handler_dry_run_string(v261);
                                nw_endpoint_t v339 = nw_endpoint_handler_copy_endpoint(v261);
                                v340 = nw_endpoint_get_logging_description(v339);
                                unsigned int v341 = nw_endpoint_handler_state_string(v261);
                                v342 = nw_endpoint_handler_mode_string(v261);
                                id v343 = nw_endpoint_handler_copy_current_path(v261);
                                *(_DWORD *)buf = 136447746;
                                v387 = "nw_endpoint_flow_receive_report";
                                __int16 v388 = 2082;
                                v389 = (char *)v337;
                                __int16 v390 = 2082;
                                v391 = v338;
                                __int16 v392 = 2082;
                                v393 = (void *)v340;
                                __int16 v394 = 2082;
                                v395 = (void *)v341;
                                __int16 v396 = 2082;
                                v397 = (void *)v342;
                                __int16 v398 = 2114;
                                id v399 = v343;
                                _os_log_impl(&dword_1830D4000, v265, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected child failed when a better path is available", buf, 0x48u);
                              }
                            }
                            else
                            {
                              if (logging_disabled)
                              {
LABEL_357:
                                nw_endpoint_handler_handle_failure(v261);
                                goto LABEL_343;
                              }
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              v265 = (id)gconnectionLogObj;
                              if (os_log_type_enabled(v265, OS_LOG_TYPE_INFO))
                              {
                                unsigned int v266 = nw_endpoint_handler_get_id_string(v261);
                                uint64_t v267 = nw_endpoint_handler_dry_run_string(v261);
                                nw_endpoint_t v268 = nw_endpoint_handler_copy_endpoint(v261);
                                id v269 = nw_endpoint_get_logging_description(v268);
                                v270 = nw_endpoint_handler_state_string(v261);
                                v271 = nw_endpoint_handler_mode_string(v261);
                                id v272 = nw_endpoint_handler_copy_current_path(v261);
                                *(_DWORD *)buf = 136447746;
                                v387 = "nw_endpoint_flow_receive_report";
                                __int16 v388 = 2082;
                                v389 = (char *)v266;
                                __int16 v390 = 2082;
                                v391 = v267;
                                __int16 v392 = 2082;
                                v393 = (void *)v269;
                                __int16 v394 = 2082;
                                v395 = (void *)v270;
                                __int16 v396 = 2082;
                                v397 = (void *)v271;
                                __int16 v398 = 2114;
                                id v399 = v272;
                                _os_log_impl(&dword_1830D4000, v265, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connected child failed when a better path is available", buf, 0x48u);
                              }
                            }

                            goto LABEL_357;
                          }
                          os_log_type_t v16 = v367;
                          if ((*((unsigned char *)v364 + 33) & 4) == 0)
                          {
                            v273 = v261;
                            int v274 = v261->state;

                            if (v274 == 5) {
                              goto LABEL_343;
                            }
                            int v275 = nw_endpoint_handler_get_minimize_logging(v273);
                            char v276 = nw_endpoint_handler_get_logging_disabled(v273);
                            if (v275)
                            {
                              v277 = v364;
                              if (v276) {
                                goto LABEL_371;
                              }
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              v278 = (id)gconnectionLogObj;
                              if (os_log_type_enabled(v278, OS_LOG_TYPE_DEBUG))
                              {
                                uint64_t v330 = nw_endpoint_handler_get_id_string(v273);
                                v331 = nw_endpoint_handler_dry_run_string(v273);
                                nw_endpoint_t v332 = nw_endpoint_handler_copy_endpoint(v273);
                                os_log_type_t v333 = nw_endpoint_get_logging_description(v332);
                                v334 = nw_endpoint_handler_state_string(v273);
                                v335 = nw_endpoint_handler_mode_string(v273);
                                id v336 = nw_endpoint_handler_copy_current_path(v273);
                                *(_DWORD *)buf = 136447746;
                                v387 = "nw_endpoint_flow_receive_report";
                                __int16 v388 = 2082;
                                v389 = (char *)v330;
                                __int16 v390 = 2082;
                                v391 = v331;
                                __int16 v392 = 2082;
                                v393 = (void *)v333;
                                __int16 v394 = 2082;
                                v395 = (void *)v334;
                                __int16 v396 = 2082;
                                v397 = (void *)v335;
                                __int16 v398 = 2114;
                                id v399 = v336;
                                _os_log_impl(&dword_1830D4000, v278, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed", buf, 0x48u);
                              }
                            }
                            else
                            {
                              v277 = v364;
                              if (v276)
                              {
LABEL_371:
                                if ((*((unsigned char *)v277 + 33) & 8) == 0) {
                                  nw_endpoint_handler_handle_failure(v273);
                                }
                                v273->event = (nw_endpoint_handler_event_s)720899;
                                nw_endpoint_handler_report(v273, 0, &v273->event.domain, 0);
                                goto LABEL_343;
                              }
                              if (__nwlog_connection_log::onceToken != -1) {
                                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                              }
                              v278 = (id)gconnectionLogObj;
                              if (os_log_type_enabled(v278, OS_LOG_TYPE_INFO))
                              {
                                v279 = nw_endpoint_handler_get_id_string(v273);
                                v280 = nw_endpoint_handler_dry_run_string(v273);
                                nw_endpoint_t v281 = nw_endpoint_handler_copy_endpoint(v273);
                                v282 = nw_endpoint_get_logging_description(v281);
                                v283 = nw_endpoint_handler_state_string(v273);
                                os_log_type_t v284 = nw_endpoint_handler_mode_string(v273);
                                id v285 = nw_endpoint_handler_copy_current_path(v273);
                                *(_DWORD *)buf = 136447746;
                                v387 = "nw_endpoint_flow_receive_report";
                                __int16 v388 = 2082;
                                v389 = (char *)v279;
                                __int16 v390 = 2082;
                                v391 = v280;
                                __int16 v392 = 2082;
                                v393 = (void *)v282;
                                __int16 v394 = 2082;
                                v395 = (void *)v283;
                                __int16 v396 = 2082;
                                v397 = (void *)v284;
                                __int16 v398 = 2114;
                                id v399 = v285;
                                _os_log_impl(&dword_1830D4000, v278, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] child failed", buf, 0x48u);
                              }
                            }

                            v277 = v364;
                            goto LABEL_371;
                          }
                        }
                        else if ((*((unsigned char *)v47 + 33) & 4) == 0 || v354 <= 3 && (*((unsigned char *)v47 + 32) & 0x20) != 0)
                        {
                          goto LABEL_343;
                        }
                        unsigned int v286 = v16;
                        unsigned int v287 = v286[30];

                        if (v287 != 5)
                        {
                          uint64_t v288 = v286;
                          v286[30] = v354;

                          nw_endpoint_handler_report(v288, 0, v358, 0);
                        }
                        goto LABEL_343;
                      }
LABEL_341:
                      nw_endpoint_flow_setup_protocols((NWConcrete_nw_endpoint_handler *)v16, 0, 0, 1, 0);
                      goto LABEL_342;
                    }
                    id v89 = v16;
                    BOOL v90 = (v16[67] & 0x20) == 0;

                    if (v90)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      int v91 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v92 = v89;

                        uint64_t v93 = v92;
                        BOOL v94 = (v367[67] & 1) == 0;

                        if (v94) {
                          uint64_t v95 = "";
                        }
                        else {
                          uint64_t v95 = "dry-run ";
                        }
                        nw_endpoint_t v96 = nw_endpoint_handler_copy_endpoint(v93);
                        uint64_t v97 = nw_endpoint_get_logging_description(v96);
                        __int16 v98 = v93;
                        unsigned int v99 = v98;
                        uint64_t v100 = v98[30];
                        if (v100 > 5) {
                          id v101 = "unknown-state";
                        }
                        else {
                          id v101 = off_1E523FB38[v100];
                        }

                        id v119 = v99;
                        __int16 v120 = "path";
                        switch(v359[29])
                        {
                          case 0u:
                            break;
                          case 1u:
                            __int16 v120 = "resolver";
                            break;
                          case 2u:
                            __int16 v120 = nw_endpoint_flow_mode_string(v119[31]);
                            break;
                          case 3u:
                            __int16 v120 = "proxy";
                            break;
                          case 4u:
                            __int16 v120 = "fallback";
                            break;
                          case 5u:
                            __int16 v120 = "transform";
                            break;
                          default:
                            __int16 v120 = "unknown-mode";
                            break;
                        }
                        os_log_t v351 = (os_log_t)v120;

                        nw_endpoint_t v182 = v96;
                        uint64_t v183 = v101;
                        nw_protocol_stack_t v184 = v97;
                        v185 = v95;
                        v186 = v119;
                        os_unfair_lock_lock((os_unfair_lock_t)v186 + 28);
                        id v187 = v186[8];
                        os_unfair_lock_unlock((os_unfair_lock_t)v186 + 28);

                        *(_DWORD *)buf = 136447746;
                        v387 = "nw_endpoint_flow_receive_report";
                        __int16 v388 = 2082;
                        v389 = v92 + 168;
                        __int16 v390 = 2082;
                        v391 = v185;
                        __int16 v392 = 2082;
                        v393 = (void *)v184;
                        __int16 v394 = 2082;
                        v395 = (void *)v183;
                        __int16 v396 = 2082;
                        v397 = v351;
                        __int16 v398 = 2114;
                        id v399 = v187;
                        _os_log_impl(&dword_1830D4000, v91, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] adding candidate child protocol", buf, 0x48u);
                      }
                    }
                    v188 = nw_endpoint_handler_copy_flow(v362);
                    nw_endpoint_t v130 = v188;
                    if (v188)
                    {
                      if ((nw_flow_replay_add_candidate_output_handler(v89, (uint64_t)v364 + 376, (uint64_t)v188 + 376) & 1) == 0)
                      {
                        os_log_type_t v189 = v89;
                        BOOL v190 = (v367[67] & 0x20) == 0;

                        if (v190)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          v191 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR))
                          {
                            unsigned int v192 = v189;

                            os_log_type_t v193 = v192;
                            BOOL v194 = (v367[67] & 1) == 0;

                            if (v194) {
                              v195 = "";
                            }
                            else {
                              v195 = "dry-run ";
                            }
                            nw_endpoint_t v196 = nw_endpoint_handler_copy_endpoint(v193);
                            unsigned int v197 = nw_endpoint_get_logging_description(v196);
                            uint64_t v198 = v193;
                            uint64_t v199 = v198;
                            uint64_t v200 = v198[30];
                            if (v200 > 5) {
                              v201 = "unknown-state";
                            }
                            else {
                              v201 = off_1E523FB38[v200];
                            }
                            uint64_t v368 = v201;

                            uint64_t v202 = v199;
                            uint64_t v203 = v202;
                            uint64_t v204 = "path";
                            switch(v359[29])
                            {
                              case 0u:
                                break;
                              case 1u:
                                uint64_t v204 = "resolver";
                                break;
                              case 2u:
                                uint64_t v204 = nw_endpoint_flow_mode_string(v202[31]);
                                break;
                              case 3u:
                                uint64_t v204 = "proxy";
                                break;
                              case 4u:
                                uint64_t v204 = "fallback";
                                break;
                              case 5u:
                                uint64_t v204 = "transform";
                                break;
                              default:
                                uint64_t v204 = "unknown-mode";
                                break;
                            }

                            uint64_t v230 = v203;
                            os_unfair_lock_lock((os_unfair_lock_t)v230 + 28);
                            id v231 = v230[8];
                            os_unfair_lock_unlock((os_unfair_lock_t)v230 + 28);

                            *(_DWORD *)buf = 136447746;
                            v387 = "nw_endpoint_flow_receive_report";
                            __int16 v388 = 2082;
                            v389 = v192 + 168;
                            __int16 v390 = 2082;
                            v391 = v195;
                            __int16 v392 = 2082;
                            v393 = (void *)v197;
                            __int16 v394 = 2082;
                            v395 = (void *)v368;
                            __int16 v396 = 2082;
                            v397 = (void *)v204;
                            __int16 v398 = 2114;
                            id v399 = v231;
                            _os_log_impl(&dword_1830D4000, v191, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach to candidate child flow", buf, 0x48u);
                          }
                          goto LABEL_327;
                        }
                        goto LABEL_328;
                      }

LABEL_339:
                      os_log_type_t v12 = v373;
                      uint64_t v47 = v364;
                      os_log_type_t v16 = v367;
LABEL_340:
                      if ((v353 & 1) == 0) {
                        goto LABEL_342;
                      }
                      goto LABEL_341;
                    }
                    v307 = __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    v387 = "nw_endpoint_flow_receive_report";
                    uint64_t v297 = (char *)_os_log_send_and_compose_impl();

                    type[0] = OS_LOG_TYPE_ERROR;
                    v381[0] = OS_LOG_TYPE_DEFAULT;
                    if (!__nwlog_fault(v297, type, v381)) {
                      goto LABEL_466;
                    }
                    if (type[0] == OS_LOG_TYPE_FAULT)
                    {
                      v298 = __nwlog_obj();
                      os_log_type_t v308 = type[0];
                      if (os_log_type_enabled(v298, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        v387 = "nw_endpoint_flow_receive_report";
                        _os_log_impl(&dword_1830D4000, v298, v308, "%{public}s called with null candidate_child_flow", buf, 0xCu);
                      }
                      goto LABEL_465;
                    }
                    if (v381[0] == OS_LOG_TYPE_DEFAULT)
                    {
                      v298 = __nwlog_obj();
                      os_log_type_t v329 = type[0];
                      if (os_log_type_enabled(v298, type[0]))
                      {
                        *(_DWORD *)buf = 136446210;
                        v387 = "nw_endpoint_flow_receive_report";
                        _os_log_impl(&dword_1830D4000, v298, v329, "%{public}s called with null candidate_child_flow, backtrace limit exceeded", buf, 0xCu);
                      }
                      goto LABEL_465;
                    }
                    nw_parameters_t v312 = (char *)__nw_create_backtrace_string();
                    v298 = __nwlog_obj();
                    os_log_type_t v318 = type[0];
                    BOOL v319 = os_log_type_enabled(v298, type[0]);
                    if (!v312)
                    {
                      if (v319)
                      {
                        *(_DWORD *)buf = 136446210;
                        v387 = "nw_endpoint_flow_receive_report";
                        _os_log_impl(&dword_1830D4000, v298, v318, "%{public}s called with null candidate_child_flow, no backtrace", buf, 0xCu);
                      }
                      goto LABEL_465;
                    }
                    if (v319)
                    {
                      *(_DWORD *)buf = 136446466;
                      v387 = "nw_endpoint_flow_receive_report";
                      __int16 v388 = 2082;
                      v389 = v312;
                      _os_log_impl(&dword_1830D4000, v298, v318, "%{public}s called with null candidate_child_flow, dumping backtrace:%{public}s", buf, 0x16u);
                    }
                    goto LABEL_433;
                  }
LABEL_118:
                  BOOL v75 = *((void *)v47 + 83) == 0;
                  id v76 = v16;
                  char v77 = *((unsigned char *)v16 + 268);

                  if (!v75)
                  {
                    if ((v77 & 0x20) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      os_log_type_t v78 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v78, OS_LOG_TYPE_DEBUG))
                      {
                        unsigned int v349 = v78;
                        id v79 = v76;

                        __int16 v80 = v79;
                        BOOL v81 = (v367[67] & 1) == 0;

                        if (v81) {
                          __int16 v82 = "";
                        }
                        else {
                          __int16 v82 = "dry-run ";
                        }
                        nw_endpoint_t v83 = nw_endpoint_handler_copy_endpoint(v80);
                        id v84 = nw_endpoint_get_logging_description(v83);
                        nw_endpoint_t v85 = v80;
                        id v86 = v85;
                        uint64_t v87 = v85[30];
                        if (v87 > 5) {
                          id v88 = "unknown-state";
                        }
                        else {
                          id v88 = off_1E523FB38[v87];
                        }

                        int v113 = v86;
                        uint64_t v114 = v113;
                        unsigned int v115 = "path";
                        switch(v359[29])
                        {
                          case 0u:
                            break;
                          case 1u:
                            unsigned int v115 = "resolver";
                            break;
                          case 2u:
                            unsigned int v115 = nw_endpoint_flow_mode_string(v113[31]);
                            break;
                          case 3u:
                            unsigned int v115 = "proxy";
                            break;
                          case 4u:
                            unsigned int v115 = "fallback";
                            break;
                          case 5u:
                            unsigned int v115 = "transform";
                            break;
                          default:
                            unsigned int v115 = "unknown-mode";
                            break;
                        }

                        nw_endpoint_t v123 = v83;
                        __int16 v124 = v88;
                        int v125 = v84;
                        uint64_t v126 = v82;
                        id v127 = v76;
                        id v128 = v114;
                        os_unfair_lock_lock((os_unfair_lock_t)v128 + 28);
                        id v129 = v128[8];
                        os_unfair_lock_unlock((os_unfair_lock_t)v128 + 28);

                        id v76 = v127;
                        *(_DWORD *)buf = 136447746;
                        v387 = "nw_endpoint_flow_receive_report";
                        __int16 v388 = 2082;
                        v389 = v79 + 168;
                        __int16 v390 = 2082;
                        v391 = v126;
                        __int16 v392 = 2082;
                        v393 = (void *)v125;
                        __int16 v394 = 2082;
                        v395 = (void *)v124;
                        __int16 v396 = 2082;
                        v397 = (void *)v115;
                        __int16 v398 = 2114;
                        id v399 = v129;
                        _os_log_impl(&dword_1830D4000, v349, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] selecting connected child protocol from candidates", buf, 0x48u);

                        os_log_type_t v78 = v349;
                      }
                    }
                    nw_endpoint_t v130 = nw_endpoint_handler_copy_flow(loga);
                    if (v130)
                    {
                      id v131 = v76;
                      uint64_t v132 = v359[29];

                      if (v132 == 2)
                      {
                        int v133 = v364;
                        id v134 = (char *)*((void *)v364 + 83);
                        if (!v134)
                        {
LABEL_338:
                          *((_WORD *)v133 + 354) &= ~0x800u;
                          nw_protocol_set_output_handler((uint64_t)v133 + 472, (uint64_t)v130 + 376);

                          goto LABEL_339;
                        }
                        *(void *)v381 = 0;
                        int v382 = v381;
                        uint64_t v383 = 0x2020000000;
                        char v384 = 0;
                        *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
                        uint64_t v375 = 3221225472;
                        v376 = __nw_flow_replay_select_output_handler_block_invoke;
                        v377 = &unk_1E523C998;
                        v378 = v381;
                        v379 = (char *)v130 + 376;
                        v380 = (char *)v364 + 376;
                        nw_hash_table_apply(v134, (uint64_t)type);
                        if (*((unsigned char *)v382 + 24))
                        {
LABEL_337:
                          _Block_object_dispose(v381, 8);
                          goto LABEL_338;
                        }
                        if (nw_endpoint_handler_get_minimize_logging(v131))
                        {
                          if (nw_endpoint_handler_get_logging_disabled(v131)) {
                            goto LABEL_336;
                          }
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          os_log_type_t v137 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v137, OS_LOG_TYPE_DEBUG))
                          {
                            int v360 = nw_endpoint_handler_get_id_string(v131);
                            os_log_type_t v321 = nw_endpoint_handler_dry_run_string(v131);
                            nw_endpoint_t v322 = nw_endpoint_handler_copy_endpoint(v131);
                            v323 = nw_endpoint_get_logging_description(v322);
                            os_log_type_t v324 = nw_endpoint_handler_state_string(v131);
                            v325 = nw_endpoint_handler_mode_string(v131);
                            id v326 = nw_endpoint_handler_copy_current_path(v131);
                            *(_DWORD *)buf = 136447746;
                            v387 = "nw_flow_replay_select_output_handler";
                            __int16 v388 = 2082;
                            v389 = (char *)v360;
                            __int16 v390 = 2082;
                            v391 = v321;
                            __int16 v392 = 2082;
                            v393 = (void *)v323;
                            __int16 v394 = 2082;
                            v395 = (void *)v324;
                            __int16 v396 = 2082;
                            v397 = (void *)v325;
                            __int16 v398 = 2114;
                            id v399 = v326;
                            _os_log_impl(&dword_1830D4000, v137, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Did not find selected output handler, adding to the candidate list", buf, 0x48u);
                          }
                        }
                        else
                        {
                          __int16 v135 = v131;
                          BOOL v136 = (v367[67] & 0x20) == 0;

                          if (!v136)
                          {
LABEL_336:
                            int v133 = v364;
                            nw_flow_replay_add_candidate_output_handler(v131, (uint64_t)v364 + 376, (uint64_t)v130 + 376);
                            goto LABEL_337;
                          }
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          os_log_type_t v137 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v137, OS_LOG_TYPE_INFO))
                          {
                            v347 = v137;
                            v138 = v135;

                            os_log_type_t v139 = v138;
                            BOOL v140 = (v367[67] & 1) == 0;

                            if (v140) {
                              BOOL v141 = "";
                            }
                            else {
                              BOOL v141 = "dry-run ";
                            }
                            nw_endpoint_t v142 = nw_endpoint_handler_copy_endpoint(v139);
                            os_log_type_t v143 = nw_endpoint_get_logging_description(v142);
                            uint64_t v144 = v139;
                            uint64_t v145 = v144;
                            uint64_t v146 = v144[30];
                            v344 = v143;
                            nw_endpoint_t v345 = v142;
                            if (v146 > 5) {
                              BOOL v147 = "unknown-state";
                            }
                            else {
                              BOOL v147 = off_1E523FB38[v146];
                            }

                            uint64_t v205 = v145;
                            id v206 = v205;
                            id v207 = "path";
                            switch(v359[29])
                            {
                              case 0u:
                                break;
                              case 1u:
                                id v207 = "resolver";
                                break;
                              case 2u:
                                id v207 = nw_endpoint_flow_mode_string(v205[31]);
                                break;
                              case 3u:
                                id v207 = "proxy";
                                break;
                              case 4u:
                                id v207 = "fallback";
                                break;
                              case 5u:
                                id v207 = "transform";
                                break;
                              default:
                                id v207 = "unknown-mode";
                                break;
                            }

                            int v258 = v206;
                            os_unfair_lock_lock((os_unfair_lock_t)v258 + 28);
                            id v259 = v258[8];
                            os_unfair_lock_unlock((os_unfair_lock_t)v258 + 28);

                            *(_DWORD *)buf = 136447746;
                            v387 = "nw_flow_replay_select_output_handler";
                            __int16 v388 = 2082;
                            v389 = v138 + 168;
                            __int16 v390 = 2082;
                            v391 = v141;
                            __int16 v392 = 2082;
                            v393 = (void *)v344;
                            __int16 v394 = 2082;
                            v395 = (void *)v147;
                            __int16 v396 = 2082;
                            v397 = (void *)v207;
                            __int16 v398 = 2114;
                            id v399 = v259;
                            _os_log_impl(&dword_1830D4000, v347, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Did not find selected output handler, adding to the candidate list", buf, 0x48u);

                            os_log_type_t v137 = v347;
                          }
                        }

                        goto LABEL_336;
                      }
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      id v148 = (id)gLogObj;
                      if (v132 > 5) {
                        uint64_t v149 = "unknown-mode";
                      }
                      else {
                        uint64_t v149 = off_1E523FB08[v132];
                      }
                      *(_DWORD *)buf = 136446722;
                      v387 = "nw_flow_replay_select_output_handler";
                      __int16 v388 = 2082;
                      v389 = (char *)v149;
                      __int16 v390 = 2082;
                      v391 = "flow";
                      os_log_type_t v150 = (void *)_os_log_send_and_compose_impl();

                      v381[0] = OS_LOG_TYPE_ERROR;
                      char v385 = 0;
                      if (__nwlog_fault((const char *)v150, v381, &v385))
                      {
                        if (v381[0] == OS_LOG_TYPE_FAULT)
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          BOOL v151 = (id)gLogObj;
                          os_log_type_t v152 = v381[0];
                          if (os_log_type_enabled(v151, v381[0]))
                          {
                            if (v132 > 5) {
                              long long v153 = "unknown-mode";
                            }
                            else {
                              long long v153 = off_1E523FB08[v132];
                            }
                            *(_DWORD *)buf = 136446722;
                            v387 = "nw_flow_replay_select_output_handler";
                            __int16 v388 = 2082;
                            v389 = (char *)v153;
                            __int16 v390 = 2082;
                            v391 = "flow";
                            _os_log_impl(&dword_1830D4000, v151, v152, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
                          }
                        }
                        else if (v385)
                        {
                          long long v154 = (char *)__nw_create_backtrace_string();
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          BOOL v151 = (id)gLogObj;
                          os_log_type_t v155 = v381[0];
                          BOOL v156 = os_log_type_enabled(v151, v381[0]);
                          if (v154)
                          {
                            if (v156)
                            {
                              if (v132 > 5) {
                                BOOL v157 = "unknown-mode";
                              }
                              else {
                                BOOL v157 = off_1E523FB08[v132];
                              }
                              *(_DWORD *)buf = 136446978;
                              v387 = "nw_flow_replay_select_output_handler";
                              __int16 v388 = 2082;
                              v389 = (char *)v157;
                              __int16 v390 = 2082;
                              v391 = "flow";
                              __int16 v392 = 2082;
                              v393 = v154;
                              _os_log_impl(&dword_1830D4000, v151, v155, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
                            }

                            free(v154);
                            if (!v150)
                            {
LABEL_309:

                              uint64_t v232 = v131;
                              BOOL v233 = (v367[67] & 0x20) == 0;

                              if (v233)
                              {
                                if (__nwlog_connection_log::onceToken != -1) {
                                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                                }
                                v191 = (id)gconnectionLogObj;
                                if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR))
                                {
                                  id v234 = v232;

                                  id v235 = v234;
                                  BOOL v236 = (v367[67] & 1) == 0;

                                  if (v236) {
                                    uint64_t v237 = "";
                                  }
                                  else {
                                    uint64_t v237 = "dry-run ";
                                  }
                                  nw_endpoint_t v238 = nw_endpoint_handler_copy_endpoint(v235);
                                  uint64_t v239 = nw_endpoint_get_logging_description(v238);
                                  int v240 = v235;
                                  uint64_t v241 = v240;
                                  uint64_t v242 = v240[30];
                                  if (v242 > 5) {
                                    uint64_t v243 = "unknown-state";
                                  }
                                  else {
                                    uint64_t v243 = off_1E523FB38[v242];
                                  }

                                  int v244 = v241;
                                  long long v245 = "path";
                                  switch(v359[29])
                                  {
                                    case 0u:
                                      break;
                                    case 1u:
                                      long long v245 = "resolver";
                                      break;
                                    case 2u:
                                      long long v245 = nw_endpoint_flow_mode_string(v244[31]);
                                      break;
                                    case 3u:
                                      long long v245 = "proxy";
                                      break;
                                    case 4u:
                                      long long v245 = "fallback";
                                      break;
                                    case 5u:
                                      long long v245 = "transform";
                                      break;
                                    default:
                                      long long v245 = "unknown-mode";
                                      break;
                                  }
                                  v370 = v245;

                                  os_log_type_t v246 = v234;
                                  os_log_type_t v247 = v191;
                                  nw_endpoint_t v248 = v238;
                                  int v249 = v243;
                                  v250 = v130;
                                  id v251 = v239;
                                  uint64_t v252 = v237;
                                  v253 = v244;
                                  os_unfair_lock_lock((os_unfair_lock_t)v253 + 28);
                                  id v254 = v253[8];
                                  os_unfair_lock_unlock((os_unfair_lock_t)v253 + 28);

                                  v255 = v252;
                                  uint64_t v256 = v251;
                                  nw_endpoint_t v130 = v250;
                                  nw_endpoint_t v257 = v248;
                                  v191 = v247;
                                  *(_DWORD *)buf = 136447746;
                                  v387 = "nw_endpoint_flow_receive_report";
                                  __int16 v388 = 2082;
                                  v389 = v246 + 168;
                                  __int16 v390 = 2082;
                                  v391 = v255;
                                  __int16 v392 = 2082;
                                  v393 = (void *)v256;
                                  __int16 v394 = 2082;
                                  v395 = (void *)v249;
                                  __int16 v396 = 2082;
                                  v397 = (void *)v370;
                                  __int16 v398 = 2114;
                                  id v399 = v254;
                                  _os_log_impl(&dword_1830D4000, v247, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to select the connected candidate child flow", buf, 0x48u);
                                }
LABEL_327:

                                goto LABEL_328;
                              }
                              goto LABEL_328;
                            }
LABEL_308:
                            free(v150);
                            goto LABEL_309;
                          }
                          if (v156)
                          {
                            if (v132 > 5) {
                              nw_endpoint_t v160 = "unknown-mode";
                            }
                            else {
                              nw_endpoint_t v160 = off_1E523FB08[v132];
                            }
                            *(_DWORD *)buf = 136446722;
                            v387 = "nw_flow_replay_select_output_handler";
                            __int16 v388 = 2082;
                            v389 = (char *)v160;
                            __int16 v390 = 2082;
                            v391 = "flow";
                            _os_log_impl(&dword_1830D4000, v151, v155, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
                          }
                        }
                        else
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          BOOL v151 = (id)gLogObj;
                          os_log_type_t v158 = v381[0];
                          if (os_log_type_enabled(v151, v381[0]))
                          {
                            if (v132 > 5) {
                              int v159 = "unknown-mode";
                            }
                            else {
                              int v159 = off_1E523FB08[v132];
                            }
                            *(_DWORD *)buf = 136446722;
                            v387 = "nw_flow_replay_select_output_handler";
                            __int16 v388 = 2082;
                            v389 = (char *)v159;
                            __int16 v390 = 2082;
                            v391 = "flow";
                            _os_log_impl(&dword_1830D4000, v151, v158, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
                          }
                        }
                      }
                      if (!v150) {
                        goto LABEL_309;
                      }
                      goto LABEL_308;
                    }
                    v296 = __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    v387 = "nw_endpoint_flow_receive_report";
                    uint64_t v297 = (char *)_os_log_send_and_compose_impl();

                    type[0] = OS_LOG_TYPE_ERROR;
                    v381[0] = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v297, type, v381))
                    {
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        v298 = __nwlog_obj();
                        os_log_type_t v299 = type[0];
                        if (os_log_type_enabled(v298, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          v387 = "nw_endpoint_flow_receive_report";
                          _os_log_impl(&dword_1830D4000, v298, v299, "%{public}s called with null child_flow", buf, 0xCu);
                        }
LABEL_465:

                        goto LABEL_466;
                      }
                      if (v381[0] == OS_LOG_TYPE_DEFAULT)
                      {
                        v298 = __nwlog_obj();
                        os_log_type_t v320 = type[0];
                        if (os_log_type_enabled(v298, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          v387 = "nw_endpoint_flow_receive_report";
                          _os_log_impl(&dword_1830D4000, v298, v320, "%{public}s called with null child_flow, backtrace limit exceeded", buf, 0xCu);
                        }
                        goto LABEL_465;
                      }
                      os_log_type_t v309 = (char *)__nw_create_backtrace_string();
                      v298 = __nwlog_obj();
                      os_log_type_t v310 = type[0];
                      BOOL v311 = os_log_type_enabled(v298, type[0]);
                      if (!v309)
                      {
                        if (v311)
                        {
                          *(_DWORD *)buf = 136446210;
                          v387 = "nw_endpoint_flow_receive_report";
                          _os_log_impl(&dword_1830D4000, v298, v310, "%{public}s called with null child_flow, no backtrace", buf, 0xCu);
                        }
                        goto LABEL_465;
                      }
                      if (v311)
                      {
                        *(_DWORD *)buf = 136446466;
                        v387 = "nw_endpoint_flow_receive_report";
                        __int16 v388 = 2082;
                        v389 = v309;
                        _os_log_impl(&dword_1830D4000, v298, v310, "%{public}s called with null child_flow, dumping backtrace:%{public}s", buf, 0x16u);
                      }

                      free(v309);
                    }
LABEL_466:
                    if (!v297)
                    {
LABEL_468:
                      nw_endpoint_t v130 = 0;
                      goto LABEL_328;
                    }
LABEL_467:
                    free(v297);
                    goto LABEL_468;
                  }
                  if ((v77 & 0x20) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    __int16 v102 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                    {
                      int v103 = v76;

                      __int16 v104 = v103;
                      BOOL v105 = (v367[67] & 1) == 0;

                      if (v105) {
                        __int16 v106 = "";
                      }
                      else {
                        __int16 v106 = "dry-run ";
                      }
                      nw_endpoint_t v107 = nw_endpoint_handler_copy_endpoint(v104);
                      int v108 = nw_endpoint_get_logging_description(v107);
                      uint64_t v109 = v104;
                      uint64_t v110 = v109;
                      uint64_t v111 = v109[30];
                      if (v111 > 5) {
                        BOOL v112 = "unknown-state";
                      }
                      else {
                        BOOL v112 = off_1E523FB38[v111];
                      }
                      os_log_t v350 = (os_log_t)v112;

                      int v116 = v110;
                      uint64_t v117 = v116;
                      BOOL v118 = "path";
                      switch(v359[29])
                      {
                        case 0u:
                          break;
                        case 1u:
                          BOOL v118 = "resolver";
                          break;
                        case 2u:
                          BOOL v118 = nw_endpoint_flow_mode_string(v116[31]);
                          break;
                        case 3u:
                          BOOL v118 = "proxy";
                          break;
                        case 4u:
                          BOOL v118 = "fallback";
                          break;
                        case 5u:
                          BOOL v118 = "transform";
                          break;
                        default:
                          BOOL v118 = "unknown-mode";
                          break;
                      }

                      int v161 = v76;
                      long long v162 = v117;
                      os_unfair_lock_lock((os_unfair_lock_t)v162 + 28);
                      id v163 = v162[8];
                      os_unfair_lock_unlock((os_unfair_lock_t)v162 + 28);

                      id v76 = v161;
                      uint64_t v164 = v103 + 168;
                      id v165 = v163;
                      v166 = v165;
                      __int16 v167 = (const char *)*((void *)v364 + 94);
                      if (v167)
                      {
                        __int16 v167 = (const char *)*((void *)v167 + 2);
                        if (!v167) {
                          __int16 v167 = "invalid";
                        }
                      }
                      *(_DWORD *)buf = 136448002;
                      v387 = "nw_endpoint_flow_receive_report";
                      __int16 v388 = 2082;
                      v389 = v164;
                      __int16 v390 = 2082;
                      v391 = v106;
                      __int16 v392 = 2082;
                      v393 = (void *)v108;
                      __int16 v394 = 2082;
                      v395 = v350;
                      __int16 v396 = 2082;
                      v397 = (void *)v118;
                      __int16 v398 = 2114;
                      id v399 = v165;
                      __int16 v400 = 2082;
                      v401 = v167;
                      _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] connecting %{public}s to child's shared protocol", buf, 0x52u);
                    }
                  }
                  v168 = nw_endpoint_handler_copy_flow(loga);
                  nw_endpoint_t v130 = v168;
                  if (v168)
                  {
                    uint64_t v169 = *((void *)v364 + 94);
                    if (v169)
                    {
                      uint64_t v170 = (char *)v168 + 376;
                      if ((NWConcrete_nw_endpoint_mode_handler *)((char *)v168 + 376) != (NWConcrete_nw_endpoint_mode_handler *)v169)
                      {
                        __int16 v171 = (void *)*((void *)v168 + 50);
                        if (v171 && *v171)
                        {
                          if (nw_protocol_add_input_handler((uint64_t)v168 + 376, v169))
                          {
                            v172 = (void *)*((void *)v130 + 68);
                            *((void *)v130 + 68) = v130;

                            goto LABEL_339;
                          }
                        }
                        else
                        {
                          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                          networkd_settings_init();
                          __int16 v177 = (id)gLogObj;
                          if (os_log_type_enabled(v177, OS_LOG_TYPE_ERROR))
                          {
                            *(_DWORD *)buf = 136446466;
                            v387 = "nw_protocol_utilities_add_input_handler";
                            __int16 v388 = 2048;
                            v389 = v170;
                            _os_log_impl(&dword_1830D4000, v177, OS_LOG_TYPE_ERROR, "%{public}s Unable to invoke add_input_handler on protocol %p because it is not valid", buf, 0x16u);
                          }
                        }
LABEL_268:
                        uint32_t v209 = v76;
                        BOOL v210 = (v367[67] & 0x20) == 0;

                        if (v210)
                        {
                          if (__nwlog_connection_log::onceToken != -1) {
                            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                          }
                          v191 = (id)gconnectionLogObj;
                          if (os_log_type_enabled(v191, OS_LOG_TYPE_ERROR))
                          {
                            v211 = v209;

                            uint64_t v212 = v211;
                            BOOL v213 = (v367[67] & 1) == 0;

                            if (v213) {
                              uint64_t v214 = "";
                            }
                            else {
                              uint64_t v214 = "dry-run ";
                            }
                            nw_endpoint_t v215 = nw_endpoint_handler_copy_endpoint(v212);
                            BOOL v216 = nw_endpoint_get_logging_description(v215);
                            id v217 = v212;
                            char v218 = v217;
                            uint64_t v219 = v217[30];
                            if (v219 > 5) {
                              v220 = "unknown-state";
                            }
                            else {
                              v220 = off_1E523FB38[v219];
                            }
                            v369 = v220;

                            int v221 = v218;
                            v222 = v221;
                            uint64_t v223 = "path";
                            switch(v359[29])
                            {
                              case 0u:
                                break;
                              case 1u:
                                uint64_t v223 = "resolver";
                                break;
                              case 2u:
                                uint64_t v223 = nw_endpoint_flow_mode_string(v221[31]);
                                break;
                              case 3u:
                                uint64_t v223 = "proxy";
                                break;
                              case 4u:
                                uint64_t v223 = "fallback";
                                break;
                              case 5u:
                                uint64_t v223 = "transform";
                                break;
                              default:
                                uint64_t v223 = "unknown-mode";
                                break;
                            }

                            int v224 = v222;
                            os_unfair_lock_lock((os_unfair_lock_t)v224 + 28);
                            id v225 = v224[8];
                            os_unfair_lock_unlock((os_unfair_lock_t)v224 + 28);

                            uint64_t v226 = v211 + 168;
                            id v227 = v225;
                            uint64_t v228 = v227;
                            unint64_t v229 = (const char *)*((void *)v364 + 94);
                            if (v229)
                            {
                              unint64_t v229 = (const char *)*((void *)v229 + 2);
                              if (!v229) {
                                unint64_t v229 = "invalid";
                              }
                            }
                            *(_DWORD *)buf = 136448002;
                            v387 = "nw_endpoint_flow_receive_report";
                            __int16 v388 = 2082;
                            v389 = v226;
                            __int16 v390 = 2082;
                            v391 = v214;
                            __int16 v392 = 2082;
                            v393 = (void *)v216;
                            __int16 v394 = 2082;
                            v395 = (void *)v369;
                            __int16 v396 = 2082;
                            v397 = (void *)v223;
                            __int16 v398 = 2114;
                            id v399 = v227;
                            __int16 v400 = 2082;
                            v401 = v229;
                            _os_log_impl(&dword_1830D4000, v191, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to attach protocol %{public}s to newly connected child flow", buf, 0x52u);
                          }
                          goto LABEL_327;
                        }
LABEL_328:

                        uint64_t v30 = 0;
LABEL_344:

                        goto LABEL_345;
                      }
                      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init();
                      id v173 = (id)gLogObj;
                      *(_DWORD *)buf = 136446466;
                      v387 = "nw_protocol_utilities_add_input_handler";
                      __int16 v388 = 2048;
                      v389 = v170;
                      uint64_t v174 = (const char *)_os_log_send_and_compose_impl();

                      type[0] = OS_LOG_TYPE_ERROR;
                      v381[0] = OS_LOG_TYPE_DEFAULT;
                      if (!__nwlog_fault(v174, type, v381)) {
                        goto LABEL_265;
                      }
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                        networkd_settings_init();
                        __int16 v175 = (id)gLogObj;
                        os_log_type_t v176 = type[0];
                        if (os_log_type_enabled(v175, type[0]))
                        {
                          *(_DWORD *)buf = 136446466;
                          v387 = "nw_protocol_utilities_add_input_handler";
                          __int16 v388 = 2048;
                          v389 = v170;
                          _os_log_impl(&dword_1830D4000, v175, v176, "%{public}s Cannot add input handler %p to itself", buf, 0x16u);
                        }
                      }
                      else if (v381[0])
                      {
                        unsigned int v178 = (char *)__nw_create_backtrace_string();
                        __int16 v175 = __nwlog_obj();
                        os_log_type_t v179 = type[0];
                        BOOL v180 = os_log_type_enabled(v175, type[0]);
                        if (v178)
                        {
                          if (v180)
                          {
                            *(_DWORD *)buf = 136446722;
                            v387 = "nw_protocol_utilities_add_input_handler";
                            __int16 v388 = 2048;
                            v389 = v170;
                            __int16 v390 = 2082;
                            v391 = v178;
                            _os_log_impl(&dword_1830D4000, v175, v179, "%{public}s Cannot add input handler %p to itself, dumping backtrace:%{public}s", buf, 0x20u);
                          }

                          free(v178);
                          goto LABEL_265;
                        }
                        if (v180)
                        {
                          *(_DWORD *)buf = 136446466;
                          v387 = "nw_protocol_utilities_add_input_handler";
                          __int16 v388 = 2048;
                          v389 = v170;
                          _os_log_impl(&dword_1830D4000, v175, v179, "%{public}s Cannot add input handler %p to itself, no backtrace", buf, 0x16u);
                        }
                      }
                      else
                      {
                        __int16 v175 = __nwlog_obj();
                        os_log_type_t v181 = type[0];
                        if (os_log_type_enabled(v175, type[0]))
                        {
                          *(_DWORD *)buf = 136446466;
                          v387 = "nw_protocol_utilities_add_input_handler";
                          __int16 v388 = 2048;
                          v389 = v170;
                          _os_log_impl(&dword_1830D4000, v175, v181, "%{public}s Cannot add input handler %p to itself, backtrace limit exceeded", buf, 0x16u);
                        }
                      }

LABEL_265:
                      if (!v174) {
                        goto LABEL_268;
                      }
                      uint64_t v208 = (char *)v174;
                      goto LABEL_267;
                    }
                    uint64_t v303 = __nwlog_obj();
                    *(_DWORD *)buf = 136446210;
                    v387 = "nw_protocol_utilities_add_input_handler";
                    int v304 = (const char *)_os_log_send_and_compose_impl();

                    type[0] = OS_LOG_TYPE_ERROR;
                    v381[0] = OS_LOG_TYPE_DEFAULT;
                    if (__nwlog_fault(v304, type, v381))
                    {
                      if (type[0] == OS_LOG_TYPE_FAULT)
                      {
                        v305 = __nwlog_obj();
                        os_log_type_t v306 = type[0];
                        if (os_log_type_enabled(v305, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          v387 = "nw_protocol_utilities_add_input_handler";
                          _os_log_impl(&dword_1830D4000, v305, v306, "%{public}s called with null input_protocol", buf, 0xCu);
                        }
                      }
                      else if (v381[0])
                      {
                        v315 = (char *)__nw_create_backtrace_string();
                        v305 = __nwlog_obj();
                        os_log_type_t v316 = type[0];
                        BOOL v317 = os_log_type_enabled(v305, type[0]);
                        if (v315)
                        {
                          if (v317)
                          {
                            *(_DWORD *)buf = 136446466;
                            v387 = "nw_protocol_utilities_add_input_handler";
                            __int16 v388 = 2082;
                            v389 = v315;
                            _os_log_impl(&dword_1830D4000, v305, v316, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
                          }

                          free(v315);
                          goto LABEL_461;
                        }
                        if (v317)
                        {
                          *(_DWORD *)buf = 136446210;
                          v387 = "nw_protocol_utilities_add_input_handler";
                          _os_log_impl(&dword_1830D4000, v305, v316, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
                        }
                      }
                      else
                      {
                        v305 = __nwlog_obj();
                        os_log_type_t v328 = type[0];
                        if (os_log_type_enabled(v305, type[0]))
                        {
                          *(_DWORD *)buf = 136446210;
                          v387 = "nw_protocol_utilities_add_input_handler";
                          _os_log_impl(&dword_1830D4000, v305, v328, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
                        }
                      }
                    }
LABEL_461:
                    if (!v304) {
                      goto LABEL_268;
                    }
                    uint64_t v208 = (char *)v304;
LABEL_267:
                    free(v208);
                    goto LABEL_268;
                  }
                  v301 = __nwlog_obj();
                  *(_DWORD *)buf = 136446210;
                  v387 = "nw_endpoint_flow_receive_report";
                  uint64_t v297 = (char *)_os_log_send_and_compose_impl();

                  type[0] = OS_LOG_TYPE_ERROR;
                  v381[0] = OS_LOG_TYPE_DEFAULT;
                  if (!__nwlog_fault(v297, type, v381)) {
                    goto LABEL_466;
                  }
                  if (type[0] == OS_LOG_TYPE_FAULT)
                  {
                    v298 = __nwlog_obj();
                    os_log_type_t v302 = type[0];
                    if (os_log_type_enabled(v298, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v387 = "nw_endpoint_flow_receive_report";
                      _os_log_impl(&dword_1830D4000, v298, v302, "%{public}s called with null child_flow", buf, 0xCu);
                    }
                    goto LABEL_465;
                  }
                  if (v381[0] == OS_LOG_TYPE_DEFAULT)
                  {
                    v298 = __nwlog_obj();
                    os_log_type_t v327 = type[0];
                    if (os_log_type_enabled(v298, type[0]))
                    {
                      *(_DWORD *)buf = 136446210;
                      v387 = "nw_endpoint_flow_receive_report";
                      _os_log_impl(&dword_1830D4000, v298, v327, "%{public}s called with null child_flow, backtrace limit exceeded", buf, 0xCu);
                    }
                    goto LABEL_465;
                  }
                  nw_parameters_t v312 = (char *)__nw_create_backtrace_string();
                  v298 = __nwlog_obj();
                  os_log_type_t v313 = type[0];
                  BOOL v314 = os_log_type_enabled(v298, type[0]);
                  if (!v312)
                  {
                    if (v314)
                    {
                      *(_DWORD *)buf = 136446210;
                      v387 = "nw_endpoint_flow_receive_report";
                      _os_log_impl(&dword_1830D4000, v298, v313, "%{public}s called with null child_flow, no backtrace", buf, 0xCu);
                    }
                    goto LABEL_465;
                  }
                  if (v314)
                  {
                    *(_DWORD *)buf = 136446466;
                    v387 = "nw_endpoint_flow_receive_report";
                    __int16 v388 = 2082;
                    v389 = v312;
                    _os_log_impl(&dword_1830D4000, v298, v313, "%{public}s called with null child_flow, dumping backtrace:%{public}s", buf, 0x16u);
                  }
LABEL_433:

                  free(v312);
                  if (!v297) {
                    goto LABEL_468;
                  }
                  goto LABEL_467;
                }
LABEL_116:
                nw_endpoint_handler_report(v16, 0, a4, 0);
                goto LABEL_117;
              }
            }
            else if (a2 != 2)
            {
              goto LABEL_114;
            }
            v362 = 0;
            uint64_t v72 = *((void *)v47 + 118);
            if (!v72 || !v12) {
              goto LABEL_115;
            }
            nw_endpoint_t v74 = *(id **)(v72 + 16);
            uint64_t v73 = *(id **)(v72 + 24);
            if (v74 != v73)
            {
              while (*v74 != v12)
              {
                if (++v74 == v73)
                {
                  nw_endpoint_t v74 = v73;
                  break;
                }
              }
            }
            v362 = 0;
            if (!a4 || v74 == v73)
            {
LABEL_115:
              os_unfair_lock_unlock(v48);
              if (!v62) {
                goto LABEL_117;
              }
              goto LABEL_116;
            }
            if (*a4 == 3 && a4[1] == 4) {
              goto LABEL_113;
            }
LABEL_114:
            v362 = 0;
            goto LABEL_115;
          }
        }
        loga = 0;
        goto LABEL_70;
      }
    }
    nw_endpoint_handler_report(v16, v12, a4, v371);
    goto LABEL_37;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v28 = (id)gLogObj;
  if (os_log_type_enabled(v28, OS_LOG_TYPE_DEFAULT))
  {
    if (v15 > 5) {
      uint64_t v29 = "unknown-mode";
    }
    else {
      uint64_t v29 = off_1E523FB08[v15];
    }
    *(_DWORD *)buf = 136446722;
    v387 = "nw_endpoint_flow_receive_report";
    __int16 v388 = 2082;
    v389 = (char *)v29;
    __int16 v390 = 2082;
    v391 = "flow";
    _os_log_impl(&dword_1830D4000, v28, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }

LABEL_18:
  uint64_t v30 = 0;
LABEL_345:

  return v30;
}

void sub_1831B4DD4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, void *a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,void *a23,uint64_t a24,void *a25,void *a26,void *a27,uint64_t a28,uint64_t a29,void *a30,uint64_t a31,void *a32)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_report(void *a1, void *a2, _WORD *a3, void *a4)
{
  os_log_type_t v16 = a1;
  int v7 = a2;
  id v8 = a4;
  if (v16[30] != 5)
  {
    os_log_type_t v9 = v16;
    os_log_type_t v10 = v9;
    if (a3)
    {
      if ((*((unsigned char *)v9 + 268) & 0x10) == 0 && *a3 == 3)
      {
        unsigned int v11 = (unsigned __int16)a3[1];
        if (v11 <= 0xD && ((1 << v11) & 0x2060) != 0) {
          *((unsigned char *)v9 + 268) |= 0x10u;
        }
      }
    }
    if (v9->fallback_timer)
    {
      if (!nw_endpoint_handler_should_reset_for_fallback(v9))
      {
        uint64_t fallback_timer = (uint64_t)v10->fallback_timer;
        if (fallback_timer)
        {
          nw_queue_cancel_source(fallback_timer);
          v10->uint64_t fallback_timer = 0;
        }
      }
    }

    id WeakRetained = objc_loadWeakRetained((id *)&v10->callback_context);
    os_log_type_t v14 = v7 + 30;
    if (v7)
    {
      uint64_t v15 = v7;
    }
    else
    {
      os_log_type_t v14 = v16 + 30;
      uint64_t v15 = (unsigned int *)v10;
    }
    ((void (*)(unsigned int *, void, void, _WORD *, id, id))v10->report_callback)(v15, v15[29], *v14, a3, v8, WeakRetained);
  }
}

void sub_1831B5128(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_handler_handle_failure(void *a1)
{
  uint64_t v58 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    if (v1[9])
    {
LABEL_3:
      if (*((_DWORD *)v2 + 29) == 2)
      {
        id v3 = v2[31];
        [v3 cancelWithHandler:v2 forced:0];
      }
      *((_DWORD *)v2 + 30) = 4;
      goto LABEL_33;
    }
    unsigned int v4 = *((unsigned __int8 *)v1 + 268);
    if ((v4 & 8) != 0)
    {
      unint64_t v5 = v1;
      id v6 = v5;
      int v7 = (void *)*((void *)v5 + 4);
      if (v7)
      {
        id v8 = v7;
        uint64_t v9 = v8[12];

        if ((v9 & 0x4000000000) != 0)
        {
          if (nw_endpoint_handler_get_logging_disabled(v6)) {
            goto LABEL_32;
          }
          unsigned int v31 = v4;
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v10 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
          {
            id_string = nw_endpoint_handler_get_id_string(v6);
            os_log_type_t v33 = nw_endpoint_handler_dry_run_string(v6);
            nw_endpoint_t v34 = nw_endpoint_handler_copy_endpoint(v6);
            logging_description = nw_endpoint_get_logging_description(v34);
            os_log_type_t v36 = nw_endpoint_handler_state_string(v6);
            uint64_t v37 = nw_endpoint_handler_mode_string(v6);
            id v38 = nw_endpoint_handler_copy_current_path(v6);
            *(_DWORD *)buf = 136447746;
            int v45 = "nw_endpoint_handler_handle_failure";
            __int16 v46 = 2082;
            uint64_t v47 = (void *)id_string;
            __int16 v48 = 2082;
            int v49 = v33;
            __int16 v50 = 2082;
            BOOL v51 = logging_description;
            __int16 v52 = 2082;
            os_log_type_t v53 = v36;
            __int16 v54 = 2082;
            os_log_type_t v55 = v37;
            __int16 v56 = 2114;
            id v57 = v38;
            _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] detected better path on parent handler, restarting evaluation", buf, 0x48u);

            unsigned int v4 = v31;
          }
          goto LABEL_31;
        }
        if ((*((unsigned char *)v2 + 268) & 0x20) != 0) {
          goto LABEL_32;
        }
LABEL_14:
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        os_log_type_t v10 = (id)gconnectionLogObj;
        if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
        {
          if (*((unsigned char *)v2 + 268)) {
            unsigned int v11 = "dry-run ";
          }
          else {
            unsigned int v11 = "";
          }
          nw_endpoint_t v12 = nw_endpoint_handler_copy_endpoint(v6);
          id v13 = nw_endpoint_get_logging_description(v12);
          os_log_type_t v14 = v6 + 42;
          uint64_t v15 = v6[30];
          if (v15 > 5) {
            os_log_type_t v16 = "unknown-state";
          }
          else {
            os_log_type_t v16 = off_1E523FB38[v15];
          }
          char v17 = v6;
          id v18 = (os_unfair_lock_s *)v17;
          os_log_type_t v40 = v16;
          nw_endpoint_t v41 = v12;
          uint64_t v19 = v13;
          BOOL v20 = "path";
          switch(v17[29])
          {
            case 0u:
              break;
            case 1u:
              BOOL v20 = "resolver";
              break;
            case 2u:
              BOOL v20 = nw_endpoint_flow_mode_string(*((void **)v17 + 31));
              break;
            case 3u:
              BOOL v20 = "proxy";
              break;
            case 4u:
              BOOL v20 = "fallback";
              break;
            case 5u:
              BOOL v20 = "transform";
              break;
            default:
              BOOL v20 = "unknown-mode";
              break;
          }

          char v21 = v18 + 28;
          os_log_type_t v22 = v18;
          os_unfair_lock_lock(v18 + 28);
          id v23 = v22[8];
          os_unfair_lock_unlock(v21);

          *(_DWORD *)buf = 136447746;
          int v45 = "nw_endpoint_handler_handle_failure";
          __int16 v46 = 2082;
          uint64_t v47 = v14;
          __int16 v48 = 2082;
          int v49 = v11;
          __int16 v50 = 2082;
          BOOL v51 = v19;
          __int16 v52 = 2082;
          os_log_type_t v53 = v40;
          __int16 v54 = 2082;
          os_log_type_t v55 = v20;
          __int16 v56 = 2114;
          id v57 = v23;
          _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] detected better path on parent handler, restarting evaluation", buf, 0x48u);
        }
LABEL_31:

        goto LABEL_32;
      }

      if ((*((unsigned char *)v2 + 268) & 0x20) == 0) {
        goto LABEL_14;
      }
    }
    else if (!nw_parameters_get_indefinite(v1[4]))
    {
      goto LABEL_3;
    }
LABEL_32:
    nw_endpoint_handler_reset_mode(v2, (v4 >> 3) & 1);
    goto LABEL_33;
  }
  __int16 v24 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  int v45 = "nw_endpoint_handler_handle_failure";
  id v25 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v42 = 0;
  if (__nwlog_fault(v25, &type, &v42))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        int v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v42)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v30 = os_log_type_enabled(v26, type);
      if (backtrace_string)
      {
        if (v30)
        {
          *(_DWORD *)buf = 136446466;
          int v45 = "nw_endpoint_handler_handle_failure";
          __int16 v46 = 2082;
          uint64_t v47 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_55;
      }
      if (v30)
      {
        *(_DWORD *)buf = 136446210;
        int v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v26 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v26, type))
      {
        *(_DWORD *)buf = 136446210;
        int v45 = "nw_endpoint_handler_handle_failure";
        _os_log_impl(&dword_1830D4000, v26, v39, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_55:
  if (v25) {
    free(v25);
  }
LABEL_33:
}

void sub_1831B5784(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_indefinite(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  BOOL v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[96] >> 6) & 1;
    goto LABEL_3;
  }
  unint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_get_indefinite";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_indefinite";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_get_indefinite";
          __int16 v17 = 2082;
          id v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_indefinite";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_get_indefinite";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_endpoint_handler_get_has_better_path(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  unsigned int v4 = v3;
  if (!v3)
  {
    BOOL v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v22 = "nw_endpoint_handler_get_has_better_path";
    os_log_type_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v22 = "nw_endpoint_handler_get_has_better_path";
            __int16 v23 = 2082;
            __int16 v24 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_26;
        }
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v22 = "nw_endpoint_handler_get_has_better_path";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_26:
    if (v12) {
      free(v12);
    }
    uint64_t v6 = 0;
    goto LABEL_9;
  }
  unsigned int v5 = *((unsigned __int8 *)v3 + 268);
  uint64_t v6 = (v5 >> 3) & 1;
  if ((v5 & 8) != 0 && a2)
  {
    int v7 = v3;
    while (1)
    {
      parent_handler = v7->parent_handler;
      if (!parent_handler) {
        break;
      }
      uint64_t v9 = parent_handler;

      int v7 = v9;
      if ((*((unsigned char *)v9 + 268) & 8) == 0)
      {

        uint64_t v6 = 0;
        goto LABEL_9;
      }
    }

    uint64_t v6 = 1;
  }
LABEL_9:

  return v6;
}

void nw_endpoint_flow_reinitialize_protocol_for_handling_requests(void *a1)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  BOOL v2 = v1;
  if (!v1)
  {
    unsigned int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_endpoint_handler_get_mode";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (__nwlog_fault(v6, &type, &v26))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v26)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v29 = "nw_endpoint_handler_get_mode";
            __int16 v30 = 2082;
            unsigned int v31 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_22;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v29 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_22:
    if (v6) {
      free(v6);
    }
    unsigned int mode = 0;
    goto LABEL_25;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    unsigned int v4 = nw_endpoint_handler_copy_flow(v2);
    if ((*((unsigned char *)v4 + 32) & 8) != 0)
    {
      *((void *)v4 + 20) = nw_flow_output_available;
      *((void *)v4 + 19) = nw_flow_input_available;
      *((void *)v4 + 34) = nw_flow_input_finished;
      *((void *)v4 + 17) = nw_flow_disconnected;
      *((void *)v4 + 31) = nw_flow_notify;
      *((void *)v4 + 33) = nw_flow_supports_external_data;
    }

    goto LABEL_46;
  }
LABEL_25:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v13 = (id)gLogObj;
  if (mode > 5) {
    os_log_type_t v14 = "unknown-mode";
  }
  else {
    os_log_type_t v14 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  os_log_type_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
  __int16 v30 = 2082;
  unsigned int v31 = (void *)v14;
  __int16 v32 = 2082;
  os_log_type_t v33 = "flow";
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v26 = 0;
  if (!__nwlog_fault((const char *)v15, &type, &v26))
  {
LABEL_44:
    if (!v15) {
      goto LABEL_46;
    }
LABEL_45:
    free(v15);
    goto LABEL_46;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v16 = (id)gLogObj;
    os_log_type_t v17 = type;
    if (os_log_type_enabled(v16, type))
    {
      if (mode > 5) {
        os_log_type_t v18 = "unknown-mode";
      }
      else {
        os_log_type_t v18 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      __int16 v30 = 2082;
      unsigned int v31 = (void *)v18;
      __int16 v32 = 2082;
      os_log_type_t v33 = "flow";
      _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_43:

    goto LABEL_44;
  }
  if (!v26)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v16 = (id)gLogObj;
    os_log_type_t v23 = type;
    if (os_log_type_enabled(v16, type))
    {
      if (mode > 5) {
        __int16 v24 = "unknown-mode";
      }
      else {
        __int16 v24 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      __int16 v30 = 2082;
      unsigned int v31 = (void *)v24;
      __int16 v32 = 2082;
      os_log_type_t v33 = "flow";
      _os_log_impl(&dword_1830D4000, v16, v23, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_43;
  }
  char v19 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v16 = (id)gLogObj;
  os_log_type_t v20 = type;
  BOOL v21 = os_log_type_enabled(v16, type);
  if (!v19)
  {
    if (v21)
    {
      if (mode > 5) {
        uint64_t v25 = "unknown-mode";
      }
      else {
        uint64_t v25 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
      __int16 v30 = 2082;
      unsigned int v31 = (void *)v25;
      __int16 v32 = 2082;
      os_log_type_t v33 = "flow";
      _os_log_impl(&dword_1830D4000, v16, v20, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_43;
  }
  if (v21)
  {
    if (mode > 5) {
      os_log_type_t v22 = "unknown-mode";
    }
    else {
      os_log_type_t v22 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    os_log_type_t v29 = "nw_endpoint_flow_reinitialize_protocol_for_handling_requests";
    __int16 v30 = 2082;
    unsigned int v31 = (void *)v22;
    __int16 v32 = 2082;
    os_log_type_t v33 = "flow";
    __int16 v34 = 2082;
    id v35 = v19;
    _os_log_impl(&dword_1830D4000, v16, v20, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v19);
  if (v15) {
    goto LABEL_45;
  }
LABEL_46:
}

void sub_1831B63E8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_access_flow_state(void *a1, uint64_t a2, void *a3)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  unsigned int v5 = a1;
  id v6 = a3;
  int v7 = (uint64_t (**)(void, void))v6;
  if (!v5)
  {
    id v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s called with null instance", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (!v26)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_1830D4000, v15, v24, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v15 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v21 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v21)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null instance, no backtrace", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (v21)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
      __int16 v30 = 2082;
      unsigned int v31 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v20, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_32;
  }
  if (!v6)
  {
    os_log_type_t v17 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v14, &type, &v26)) {
      goto LABEL_45;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_1830D4000, v15, v18, "%{public}s called with null access_block", buf, 0xCu);
      }
LABEL_44:

LABEL_45:
      if (v14) {
        free(v14);
      }
      goto LABEL_11;
    }
    if (!v26)
    {
      uint64_t v15 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v15, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_1830D4000, v15, v25, "%{public}s called with null access_block, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_44;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v15 = __nwlog_obj();
    os_log_type_t v22 = type;
    BOOL v23 = os_log_type_enabled(v15, type);
    if (!backtrace_string)
    {
      if (v23)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null access_block, no backtrace", buf, 0xCu);
      }
      goto LABEL_44;
    }
    if (v23)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
      __int16 v30 = 2082;
      unsigned int v31 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v15, v22, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_32:

    free(backtrace_string);
    goto LABEL_45;
  }
  if (*(_DWORD *)(*((void *)v5 + 1) + 64) != 3 || (uint64_t v8 = *((void *)v5 + 29)) == 0)
  {
LABEL_11:
    uint64_t v10 = 0;
    goto LABEL_12;
  }
  uint64_t node = nw_hash_table_get_node(v8, a2, 8);
  if (!node)
  {
    if ((v5[405] & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v11 = (id)gLogObj;
      if (os_log_type_enabled(v11, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)buf = 136446978;
        os_log_type_t v29 = "nw_protocol_instance_access_flow_state";
        __int16 v30 = 2082;
        unsigned int v31 = v5 + 407;
        __int16 v32 = 2080;
        os_log_type_t v33 = " ";
        __int16 v34 = 2048;
        uint64_t v35 = a2;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_INFO, "%{public}s %{public}s%sFlow %llx not present, not getting state", buf, 0x2Au);
      }
    }
    goto LABEL_11;
  }
  uint64_t v10 = v7[2](v7, *(void *)(node + 32));
LABEL_12:

  return v10;
}

void sub_1831B69A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *nw_tcp_create_metadata(_OWORD *a1)
{
  if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
    dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
  }
  BOOL v2 = (void *)g_tcp_definition;

  return nw_protocol_metadata_create(v2, a1);
}

void ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke(uint64_t a1)
{
  uint64_t v137 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 56);
  LODWORD(logging_description) = *(_DWORD *)(a1 + 64);
  unsigned int v4 = &unk_183D5C000;
  switch((int)logging_description)
  {
    case 1:
      uint64_t v19 = *(void *)(a1 + 32);
      uint64_t v20 = *(void *)(v19 + 96);
      if (v20)
      {
        ++*(_DWORD *)(v20 + 184);
        uint64_t v19 = *(void *)(a1 + 32);
      }
      os_log_type_t v17 = *(void **)(v19 + 144);
      int v18 = 0;
      goto LABEL_17;
    case 2:
      uint64_t v22 = *(void *)(*(void *)(a1 + 32) + 96);
      if (v22)
      {
        ++*(_DWORD *)(v22 + 188);
        BOOL v23 = *(void **)(a1 + 40);
        if (v23)
        {
          if (object_getClass(v23) == (Class)MEMORY[0x1E4F145F8]) {
            *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 96) + 192) = xpc_uint64_get_value(*(xpc_object_t *)(a1 + 40));
          }
        }
      }
      nw_connection_report_symptom_on_nw_queue(*(void **)(a1 + 32), 421890, 0, 0);
      id v24 = *(id *)(*(void *)(a1 + 32) + 144);
      uint64_t v114 = v2;
      if (v24)
      {
        id v113 = v24;
        os_log_type_t v25 = (NWConcrete_nw_endpoint_handler *)v24;
        uint64_t mode = v25->mode;

        if (mode == 2)
        {
          os_log_type_t v27 = nw_endpoint_handler_copy_flow(v25);
          if (nw_endpoint_handler_get_minimize_logging(v25))
          {
            if (nw_endpoint_handler_get_logging_disabled(v25))
            {
LABEL_100:
              uint64_t v73 = *((void *)v27 + 51);
              if (v73)
              {
                uint64_t v74 = *(void *)(v73 + 24);
                if (v74)
                {
                  BOOL v75 = *(void (**)(void))(v74 + 160);
                  if (v75) {
                    v75();
                  }
                }
              }

              goto LABEL_117;
            }
            __int16 v97 = (__int16)logging_description;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v30 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v30, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(v25);
              uint64_t v110 = nw_endpoint_handler_dry_run_string(v25);
              nw_endpoint_t v98 = nw_endpoint_handler_copy_endpoint(v25);
              logging_description = (char *)nw_endpoint_get_logging_description(v98);
              unsigned int v99 = nw_endpoint_handler_state_string(v25);
              uint64_t v100 = nw_endpoint_handler_mode_string(v25);
              id v101 = nw_endpoint_handler_copy_current_path(v25);
              *(_DWORD *)nw_endpoint_t v130 = 136447746;
              *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
              *(_WORD *)&v130[12] = 2082;
              *(void *)&v130[14] = id_string;
              *(_WORD *)&v130[22] = 2082;
              id v131 = v110;
              *(_WORD *)uint64_t v132 = 2082;
              *(void *)&v132[2] = logging_description;
              *(_WORD *)&v132[10] = 2082;
              *(void *)&v132[12] = v99;
              __int16 v133 = 2082;
              id v134 = v100;
              __int16 v135 = 2114;
              id v136 = v101;
              _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting data stall to protocols", v130, 0x48u);

              LOWORD(logging_description) = v97;
            }
          }
          else
          {
            uint64_t v28 = v25;
            char v29 = *((unsigned char *)v28 + 268);

            if ((v29 & 0x20) != 0) {
              goto LABEL_100;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            __int16 v30 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v30, OS_LOG_TYPE_INFO))
            {
              unsigned int v31 = v28;

              __int16 v32 = v31;
              char v33 = *((unsigned char *)v28 + 268);

              if (v33) {
                __int16 v34 = "dry-run ";
              }
              else {
                __int16 v34 = "";
              }
              nw_endpoint_t v35 = nw_endpoint_handler_copy_endpoint(v32);
              uint64_t v36 = nw_endpoint_get_logging_description(v35);
              id_str = v31->id_str;
              uint64_t v37 = v32;
              id v38 = v37;
              uint64_t v39 = v37[30];
              if (v39 > 5) {
                os_log_type_t v40 = "unknown-state";
              }
              else {
                os_log_type_t v40 = off_1E523FB38[v39];
              }
              int v108 = v40;

              unsigned int v63 = v38;
              int v64 = v63;
              __int16 v111 = (__int16)logging_description;
              unsigned int v65 = "path";
              switch(v25->mode)
              {
                case 0:
                  break;
                case 1:
                  unsigned int v65 = "resolver";
                  break;
                case 2:
                  unsigned int v65 = nw_endpoint_flow_mode_string(v63[31]);
                  break;
                case 3:
                  unsigned int v65 = "proxy";
                  break;
                case 4:
                  unsigned int v65 = "fallback";
                  break;
                case 5:
                  unsigned int v65 = "transform";
                  break;
                default:
                  unsigned int v65 = "unknown-mode";
                  break;
              }

              logging_description = v64;
              os_unfair_lock_lock((os_unfair_lock_t)logging_description + 28);
              id v72 = *((id *)logging_description + 8);
              os_unfair_lock_unlock((os_unfair_lock_t)logging_description + 28);

              *(_DWORD *)nw_endpoint_t v130 = 136447746;
              *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
              *(_WORD *)&v130[12] = 2082;
              *(void *)&v130[14] = id_str;
              *(_WORD *)&v130[22] = 2082;
              id v131 = v34;
              *(_WORD *)uint64_t v132 = 2082;
              *(void *)&v132[2] = v36;
              *(_WORD *)&v132[10] = 2082;
              *(void *)&v132[12] = v108;
              __int16 v133 = 2082;
              id v134 = v65;
              __int16 v135 = 2114;
              id v136 = v72;
              _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting data stall to protocols", v130, 0x48u);

              LOWORD(logging_description) = v111;
            }
          }

          unsigned int v4 = (void *)&unk_183D5C000;
          goto LABEL_100;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v42 = (id)gLogObj;
        if (mode > 5) {
          char v43 = "unknown-mode";
        }
        else {
          char v43 = off_1E523FB08[mode];
        }
        *(_DWORD *)nw_endpoint_t v130 = 136446722;
        *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
        *(_WORD *)&v130[12] = 2082;
        *(void *)&v130[14] = v43;
        *(_WORD *)&v130[22] = 2082;
        id v131 = "flow";
        os_log_type_t v53 = (char *)_os_log_send_and_compose_impl();

        v128[0] = 16;
        buf[0] = 0;
        if (__nwlog_fault(v53, v128, buf))
        {
          if (v128[0] == 17)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v54 = (id)gLogObj;
            os_log_type_t v55 = v128[0];
            if (os_log_type_enabled(v54, (os_log_type_t)v128[0]))
            {
              if (mode > 5) {
                __int16 v56 = "unknown-mode";
              }
              else {
                __int16 v56 = off_1E523FB08[mode];
              }
              *(_DWORD *)nw_endpoint_t v130 = 136446722;
              *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
              *(_WORD *)&v130[12] = 2082;
              *(void *)&v130[14] = v56;
              *(_WORD *)&v130[22] = 2082;
              id v131 = "flow";
              _os_log_impl(&dword_1830D4000, v54, v55, "%{public}s Handler is in mode %{public}s, expected %{public}s", v130, 0x20u);
            }
          }
          else if (buf[0])
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v54 = (id)gLogObj;
            os_log_type_t v58 = v128[0];
            BOOL v59 = os_log_type_enabled(v54, (os_log_type_t)v128[0]);
            if (backtrace_string)
            {
              if (v59)
              {
                if (mode > 5) {
                  BOOL v60 = "unknown-mode";
                }
                else {
                  BOOL v60 = off_1E523FB08[mode];
                }
                *(_DWORD *)nw_endpoint_t v130 = 136446978;
                *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
                *(_WORD *)&v130[12] = 2082;
                *(void *)&v130[14] = v60;
                *(_WORD *)&v130[22] = 2082;
                id v131 = "flow";
                *(_WORD *)uint64_t v132 = 2082;
                *(void *)&v132[2] = backtrace_string;
                _os_log_impl(&dword_1830D4000, v54, v58, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", v130, 0x2Au);
              }

              free(backtrace_string);
              if (!v53) {
                goto LABEL_117;
              }
              goto LABEL_116;
            }
            if (v59)
            {
              if (mode > 5) {
                int v71 = "unknown-mode";
              }
              else {
                int v71 = off_1E523FB08[mode];
              }
              *(_DWORD *)nw_endpoint_t v130 = 136446722;
              *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
              *(_WORD *)&v130[12] = 2082;
              *(void *)&v130[14] = v71;
              *(_WORD *)&v130[22] = 2082;
              id v131 = "flow";
              _os_log_impl(&dword_1830D4000, v54, v58, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", v130, 0x20u);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v54 = (id)gLogObj;
            os_log_type_t v69 = v128[0];
            if (os_log_type_enabled(v54, (os_log_type_t)v128[0]))
            {
              if (mode > 5) {
                os_log_type_t v70 = "unknown-mode";
              }
              else {
                os_log_type_t v70 = off_1E523FB08[mode];
              }
              *(_DWORD *)nw_endpoint_t v130 = 136446722;
              *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
              *(_WORD *)&v130[12] = 2082;
              *(void *)&v130[14] = v70;
              *(_WORD *)&v130[22] = 2082;
              id v131 = "flow";
              _os_log_impl(&dword_1830D4000, v54, v69, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", v130, 0x20u);
            }
          }
        }
        if (!v53)
        {
LABEL_117:
          id v76 = v113;
          goto LABEL_118;
        }
LABEL_116:
        free(v53);
        goto LABEL_117;
      }
      id v76 = 0;
      uint64_t v87 = __nwlog_obj();
      *(_DWORD *)nw_endpoint_t v130 = 136446210;
      *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
      id v88 = (char *)_os_log_send_and_compose_impl();

      v128[0] = 16;
      buf[0] = 0;
      if (!__nwlog_fault(v88, v128, buf)) {
        goto LABEL_180;
      }
      if (v128[0] == 17)
      {
        id v89 = __nwlog_obj();
        os_log_type_t v90 = v128[0];
        if (os_log_type_enabled(v89, (os_log_type_t)v128[0]))
        {
          *(_DWORD *)nw_endpoint_t v130 = 136446210;
          *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
          _os_log_impl(&dword_1830D4000, v89, v90, "%{public}s called with null handler", v130, 0xCu);
        }
LABEL_179:

        goto LABEL_180;
      }
      if (!buf[0])
      {
        id v89 = __nwlog_obj();
        os_log_type_t v107 = v128[0];
        if (os_log_type_enabled(v89, (os_log_type_t)v128[0]))
        {
          *(_DWORD *)nw_endpoint_t v130 = 136446210;
          *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
          _os_log_impl(&dword_1830D4000, v89, v107, "%{public}s called with null handler, backtrace limit exceeded", v130, 0xCu);
        }
        goto LABEL_179;
      }
      __int16 v102 = (char *)__nw_create_backtrace_string();
      id v89 = __nwlog_obj();
      os_log_type_t v103 = v128[0];
      BOOL v104 = os_log_type_enabled(v89, (os_log_type_t)v128[0]);
      if (!v102)
      {
        if (v104)
        {
          *(_DWORD *)nw_endpoint_t v130 = 136446210;
          *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
          _os_log_impl(&dword_1830D4000, v89, v103, "%{public}s called with null handler, no backtrace", v130, 0xCu);
        }
        goto LABEL_179;
      }
      if (v104)
      {
        *(_DWORD *)nw_endpoint_t v130 = 136446466;
        *(void *)&void v130[4] = "nw_endpoint_handler_report_data_stall";
        *(_WORD *)&v130[12] = 2082;
        *(void *)&v130[14] = v102;
        _os_log_impl(&dword_1830D4000, v89, v103, "%{public}s called with null handler, dumping backtrace:%{public}s", v130, 0x16u);
      }

      free(v102);
LABEL_180:
      if (v88) {
        free(v88);
      }
LABEL_118:

      LOWORD(v21) = -1;
      uint64_t v2 = v114;
LABEL_119:
      char v77 = *(os_unfair_lock_s **)(a1 + 32);
      os_log_type_t v78 = v77 + 34;
      v115[0] = MEMORY[0x1E4F143A8];
      v115[1] = v4[310];
      v115[2] = ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke_122;
      v115[3] = &unk_1E5249DC0;
      int v116 = v77;
      uint64_t v117 = v2;
      __int16 v118 = 6;
      __int16 v119 = (__int16)logging_description;
      __int16 v120 = v21;
      __int16 v121 = 0;
      os_unfair_lock_lock(v78);
      ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke_122((uint64_t)v115);
      os_unfair_lock_unlock(v78);

      return;
    case 3:
      os_log_type_t v17 = *(void **)(*(void *)(a1 + 32) + 144);
      int v18 = 1;
LABEL_17:
      nw_endpoint_handler_report_connection_idle(v17, v18);
      LOWORD(v21) = -1;
      goto LABEL_119;
    case 4:
    case 5:
      unsigned int v5 = *(void **)(a1 + 48);
      if (!v5)
      {
        id v79 = __nwlog_obj();
        *(_DWORD *)nw_endpoint_t v130 = 136446210;
        *(void *)&void v130[4] = "nw_connection_add_client_event_internal_block_invoke";
        __int16 v80 = (char *)_os_log_send_and_compose_impl();

        v128[0] = 16;
        buf[0] = 0;
        if (__nwlog_fault(v80, v128, buf))
        {
          if (v128[0] == 17)
          {
            BOOL v81 = __nwlog_obj();
            os_log_type_t v82 = v128[0];
            if (os_log_type_enabled(v81, (os_log_type_t)v128[0]))
            {
              *(_DWORD *)nw_endpoint_t v130 = 136446210;
              *(void *)&void v130[4] = "nw_connection_add_client_event_internal_block_invoke";
              _os_log_impl(&dword_1830D4000, v81, v82, "%{public}s called with null activity", v130, 0xCu);
            }
          }
          else if (buf[0])
          {
            int v91 = (char *)__nw_create_backtrace_string();
            BOOL v81 = __nwlog_obj();
            os_log_type_t v92 = v128[0];
            BOOL v93 = os_log_type_enabled(v81, (os_log_type_t)v128[0]);
            if (v91)
            {
              if (v93)
              {
                *(_DWORD *)nw_endpoint_t v130 = 136446466;
                *(void *)&void v130[4] = "nw_connection_add_client_event_internal_block_invoke";
                *(_WORD *)&v130[12] = 2082;
                *(void *)&v130[14] = v91;
                _os_log_impl(&dword_1830D4000, v81, v92, "%{public}s called with null activity, dumping backtrace:%{public}s", v130, 0x16u);
              }

              free(v91);
              goto LABEL_166;
            }
            if (v93)
            {
              *(_DWORD *)nw_endpoint_t v130 = 136446210;
              *(void *)&void v130[4] = "nw_connection_add_client_event_internal_block_invoke";
              _os_log_impl(&dword_1830D4000, v81, v92, "%{public}s called with null activity, no backtrace", v130, 0xCu);
            }
          }
          else
          {
            BOOL v81 = __nwlog_obj();
            os_log_type_t v105 = v128[0];
            if (os_log_type_enabled(v81, (os_log_type_t)v128[0]))
            {
              *(_DWORD *)nw_endpoint_t v130 = 136446210;
              *(void *)&void v130[4] = "nw_connection_add_client_event_internal_block_invoke";
              _os_log_impl(&dword_1830D4000, v81, v105, "%{public}s called with null activity, backtrace limit exceeded", v130, 0xCu);
            }
          }
        }
LABEL_166:
        if (v80) {
          free(v80);
        }
        return;
      }
      id v6 = *(id *)(a1 + 32);
      id v7 = v5;
      if (!v6)
      {
        nw_endpoint_t v83 = __nwlog_obj();
        *(_DWORD *)id v128 = 136446210;
        *(void *)&v128[4] = "nw_connection_add_activity_on_nw_queue";
        id v84 = (char *)_os_log_send_and_compose_impl();

        buf[0] = 16;
        os_log_type_t type = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v84, buf, &type))
        {
          if (buf[0] == 17)
          {
            nw_endpoint_t v85 = __nwlog_obj();
            os_log_type_t v86 = buf[0];
            if (os_log_type_enabled(v85, (os_log_type_t)buf[0]))
            {
              *(_DWORD *)id v128 = 136446210;
              *(void *)&v128[4] = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v85, v86, "%{public}s called with null connection", v128, 0xCu);
            }
          }
          else if (type)
          {
            BOOL v94 = (char *)__nw_create_backtrace_string();
            nw_endpoint_t v85 = __nwlog_obj();
            os_log_type_t v95 = buf[0];
            BOOL v96 = os_log_type_enabled(v85, (os_log_type_t)buf[0]);
            if (v94)
            {
              if (v96)
              {
                *(_DWORD *)id v128 = 136446466;
                *(void *)&v128[4] = "nw_connection_add_activity_on_nw_queue";
                *(_WORD *)&v128[12] = 2082;
                *(void *)&v128[14] = v94;
                _os_log_impl(&dword_1830D4000, v85, v95, "%{public}s called with null connection, dumping backtrace:%{public}s", v128, 0x16u);
              }

              free(v94);
              goto LABEL_171;
            }
            if (v96)
            {
              *(_DWORD *)id v128 = 136446210;
              *(void *)&v128[4] = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v85, v95, "%{public}s called with null connection, no backtrace", v128, 0xCu);
            }
          }
          else
          {
            nw_endpoint_t v85 = __nwlog_obj();
            os_log_type_t v106 = buf[0];
            if (os_log_type_enabled(v85, (os_log_type_t)buf[0]))
            {
              *(_DWORD *)id v128 = 136446210;
              *(void *)&v128[4] = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v85, v106, "%{public}s called with null connection, backtrace limit exceeded", v128, 0xCu);
            }
          }
        }
LABEL_171:
        if (v84) {
          free(v84);
        }

        LOWORD(v21) = 255;
        unsigned int v4 = &unk_183D5C000;
        goto LABEL_119;
      }
      nw_context_assert_queue(*((void **)v6 + 3));
      uint64_t v8 = (atomic_uchar *)*((void *)v6 + 49);
      if (!v8)
      {
        BOOL v9 = nw_array_create();
        uint64_t v10 = (void *)*((void *)v6 + 49);
        *((void *)v6 + 49) = v9;

        uint64_t v8 = (atomic_uchar *)*((void *)v6 + 49);
      }
      *(void *)id v128 = 0;
      *(void *)&os_log_type_t v128[8] = v128;
      *(void *)&v128[16] = 0x2020000000;
      __int16 v129 = -1;
      *(void *)nw_endpoint_t v130 = MEMORY[0x1E4F143A8];
      *(void *)&v130[8] = 3221225472;
      *(void *)&v130[16] = ___ZL38nw_connection_add_activity_on_nw_queueP24NWConcrete_nw_connectionPU25objcproto14OS_nw_activity8NSObjectb_block_invoke;
      id v131 = (const char *)&unk_1E524A2E8;
      BOOL v11 = (char *)v7;
      *(void *)uint64_t v132 = v11;
      *(void *)&v132[8] = v128;
      nw_array_apply(v8, (uint64_t)v130);
      int v12 = *(unsigned __int16 *)(*(void *)&v128[8] + 24);
      if (logging_description != 4 && v12 == 0xFFFF)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v13 = (id)gLogObj;
        *(_DWORD *)buf = 136446210;
        int v125 = "nw_connection_add_activity_on_nw_queue";
        os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v122 = 0;
        if (__nwlog_fault(v14, &type, &v122))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v15 = (id)gLogObj;
            os_log_type_t v16 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              int v125 = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started", buf, 0xCu);
            }
          }
          else if (v122)
          {
            id v44 = __nw_create_backtrace_string();
            if (v44)
            {
              int v45 = (char *)v44;
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v46 = (id)gLogObj;
              os_log_type_t v47 = type;
              if (os_log_type_enabled(v46, type))
              {
                *(_DWORD *)buf = 136446466;
                int v125 = "nw_connection_add_activity_on_nw_queue";
                __int16 v126 = 2082;
                id v127 = v45;
                _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v45);
              if (!v14) {
                goto LABEL_79;
              }
              goto LABEL_78;
            }
            uint64_t v15 = __nwlog_obj();
            os_log_type_t v66 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              int v125 = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v15, v66, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v15 = (id)gLogObj;
            os_log_type_t v61 = type;
            if (os_log_type_enabled(v15, type))
            {
              *(_DWORD *)buf = 136446210;
              int v125 = "nw_connection_add_activity_on_nw_queue";
              _os_log_impl(&dword_1830D4000, v15, v61, "%{public}s BUG IN CLIENT OF LIBNETWORK: Cannot end an activity that was not started, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
        if (!v14)
        {
LABEL_79:
          int v21 = 255;
          goto LABEL_80;
        }
LABEL_78:
        free(v14);
        goto LABEL_79;
      }
      if (v12 != 0xFFFF)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        nw_endpoint_t v41 = (id)gLogObj;
        if (os_log_type_enabled(v41, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          int v125 = "nw_connection_add_activity_on_nw_queue";
          __int16 v126 = 2114;
          id v127 = v11;
          _os_log_impl(&dword_1830D4000, v41, OS_LOG_TYPE_DEBUG, "%{public}s Activity %{public}@ is already present, not adding to connection array", buf, 0x16u);
        }

        int v21 = *(unsigned __int16 *)(*(void *)&v128[8] + 24);
        goto LABEL_80;
      }
      __int16 v48 = v11;
      BOOL v49 = (v48[17] & 1) == 0;

      if (!v49)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v50 = (id)gLogObj;
        if (os_log_type_enabled(v50, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446466;
          int v125 = "nw_connection_add_activity_on_nw_queue";
          __int16 v126 = 2114;
          id v127 = v48;
          _os_log_impl(&dword_1830D4000, v50, OS_LOG_TYPE_DEBUG, "%{public}s Activity %{public}@ selected, connection will report activity metrics", buf, 0x16u);
        }

        *((unsigned char *)v6 + 108) |= 0x20u;
      }
      uint64_t v51 = *((void *)v6 + 49);
      if (!v51)
      {
        LOWORD(v62) = 0;
LABEL_73:
        nw_array_append(v51, v48);
        int v21 = (unsigned __int16)v62;
        goto LABEL_80;
      }
      uint64_t v52 = *(void *)(v51 + 24) - *(void *)(v51 + 16);
      if ((unint64_t)v52 <= 0x7FFF0)
      {
        uint64_t v62 = v52 >> 3;
        goto LABEL_73;
      }
      int v21 = 0xFFFF;
LABEL_80:

      _Block_object_dispose(v128, 8);
      unsigned int v4 = &unk_183D5C000;
      if (v21 != 0xFFFF) {
        goto LABEL_119;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v67 = (id)gLogObj;
      if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
      {
        uint64_t v68 = *(void *)(a1 + 48);
        *(_DWORD *)nw_endpoint_t v130 = 136446466;
        *(void *)&void v130[4] = "nw_connection_add_client_event_internal_block_invoke";
        *(_WORD *)&v130[12] = 2114;
        *(void *)&v130[14] = v68;
        _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_ERROR, "%{public}s Cannot add activity %{public}@, nw_connection_add_activity_on_nw_queue failed", v130, 0x16u);
      }

      return;
    default:
      LOWORD(v21) = -1;
      goto LABEL_119;
  }
}

void sub_1831B7FD0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_add_timestamp_locked_on_nw_queue(void *a1, _OWORD *a2)
{
  *(void *)&v44[5] = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  unsigned int v4 = v3;
  if (!v3)
  {
    os_log_type_t v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v17, &type, &v39)) {
      goto LABEL_81;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v39)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v18 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
          __int16 v43 = 2082;
          *(void *)id v44 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_81:
        if (!v17) {
          goto LABEL_27;
        }
LABEL_82:
        free(v17);
        goto LABEL_27;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v25, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v18 = __nwlog_obj();
      os_log_type_t v36 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v36, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_80:

    goto LABEL_81;
  }
  if (!a2)
  {
    uint64_t v20 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v17, &type, &v39)) {
      goto LABEL_81;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null timestamp", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v39)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v37 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v37, "%{public}s called with null timestamp, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    os_log_type_t v27 = (char *)__nw_create_backtrace_string();
    int v18 = __nwlog_obj();
    os_log_type_t v28 = type;
    BOOL v29 = os_log_type_enabled(v18, type);
    if (!v27)
    {
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v28, "%{public}s called with null timestamp, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v29)
    {
      *(_DWORD *)buf = 136446466;
      id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
      __int16 v43 = 2082;
      *(void *)id v44 = v27;
      _os_log_impl(&dword_1830D4000, v18, v28, "%{public}s called with null timestamp, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_57;
  }
  if (!v3[39])
  {
    uint64_t v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
    os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v39 = 0;
    if (!__nwlog_fault(v17, &type, &v39)) {
      goto LABEL_81;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null connection->timestamps", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (!v39)
    {
      int v18 = __nwlog_obj();
      os_log_type_t v38 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v38, "%{public}s called with null connection->timestamps, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_80;
    }
    os_log_type_t v27 = (char *)__nw_create_backtrace_string();
    int v18 = __nwlog_obj();
    os_log_type_t v30 = type;
    BOOL v31 = os_log_type_enabled(v18, type);
    if (!v27)
    {
      if (v31)
      {
        *(_DWORD *)buf = 136446210;
        id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v18, v30, "%{public}s called with null connection->timestamps, no backtrace", buf, 0xCu);
      }
      goto LABEL_80;
    }
    if (v31)
    {
      *(_DWORD *)buf = 136446466;
      id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
      __int16 v43 = 2082;
      *(void *)id v44 = v27;
      _os_log_impl(&dword_1830D4000, v18, v30, "%{public}s called with null connection->timestamps, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_57:

    free(v27);
    if (!v17) {
      goto LABEL_27;
    }
    goto LABEL_82;
  }
  nw_context_assert_queue(v3[3]);
  unsigned int v5 = *((unsigned __int16 *)v4 + 161);
  if (v5 >= 0x40)
  {
    if ((*((unsigned char *)v4 + 108) & 0x10) == 0)
    {
      *((unsigned char *)v4 + 108) |= 0x10u;
      id v6 = v4[2];
      if (v6)
      {
        if (!nw_path_parameters_get_logging_disabled(v6[13]))
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v7 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v7, OS_LOG_TYPE_ERROR))
          {
            int v8 = *((_DWORD *)v4 + 112);
            *(_DWORD *)buf = 136446466;
            id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
            __int16 v43 = 1024;
            *(_DWORD *)id v44 = v8;
            _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Hit maximum timestamp count, will start dropping events", buf, 0x12u);
          }
        }
      }
    }
    memmove((char *)v4[39] + 880, (char *)v4[39] + 896, 0x80uLL);
    *((_OWORD *)v4[39] + 63) = *a2;
    goto LABEL_27;
  }
  unsigned int v9 = *((unsigned __int16 *)v4 + 160);
  if (v5 <= v9 && (v9 & 0xF) == 0)
  {
    if (v5 == v9) {
      goto LABEL_17;
    }
LABEL_25:
    BOOL v11 = v4[39];
    goto LABEL_26;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  int v12 = (id)gLogObj;
  os_log_type_enabled(v12, OS_LOG_TYPE_ERROR);
  int v13 = *((unsigned __int16 *)v4 + 160);
  int v14 = *((unsigned __int16 *)v4 + 161);
  *(_DWORD *)buf = 136446722;
  id v42 = "nw_connection_add_timestamp_locked_on_nw_queue";
  __int16 v43 = 1024;
  *(_DWORD *)id v44 = v13;
  v44[2] = 1024;
  *(_DWORD *)&v44[3] = v14;
  uint64_t v15 = (void *)_os_log_send_and_compose_impl();

  if (__nwlog_abort((uint64_t)v15)) {
    goto LABEL_83;
  }
  free(v15);
  unsigned int v5 = *((unsigned __int16 *)v4 + 161);
  unsigned int v9 = *((unsigned __int16 *)v4 + 160);
  if (v5 != v9) {
    goto LABEL_25;
  }
LABEL_17:
  if (v9 <= 0x30) {
    unsigned __int16 v10 = v9 + 16;
  }
  else {
    unsigned __int16 v10 = 64;
  }
  *((_WORD *)v4 + 160) = v10;
  if (!v10)
  {
    __int16 v32 = __nwlog_obj();
    os_log_type_enabled(v32, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    id v42 = "_strict_reallocf";
    char v33 = (void *)_os_log_send_and_compose_impl();

    if (__nwlog_abort((uint64_t)v33)) {
      goto LABEL_83;
    }
    free(v33);
  }
  BOOL v11 = reallocf(v4[39], 16 * v10);
  if (v11)
  {
LABEL_22:
    v4[39] = v11;
    unsigned int v5 = *((unsigned __int16 *)v4 + 161);
LABEL_26:
    v11[v5] = *a2;
    ++*((_WORD *)v4 + 161);
LABEL_27:

    return;
  }
  __int16 v34 = __nwlog_obj();
  os_log_type_enabled(v34, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446466;
  id v42 = "_strict_reallocf";
  __int16 v43 = 2048;
  *(void *)id v44 = 16 * v10;
  nw_endpoint_t v35 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v35))
  {
    free(v35);
    BOOL v11 = 0;
    goto LABEL_22;
  }
LABEL_83:
  __break(1u);
}

void sub_1831B8A50(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void ___ZL39nw_connection_add_client_event_internalP24NWConcrete_nw_connection26nw_endpoint_client_event_tPU24objcproto13OS_xpc_object8NSObjectPU25objcproto14OS_nw_activityS2__block_invoke_122(uint64_t a1)
{
}

void nw_endpoint_handler_report_connection_idle(void *a1, int a2)
{
  LODWORD(v2) = a2;
  uint64_t v81 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    id v44 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
    id v24 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v63 = 0;
    if (!__nwlog_fault(v24, &type, &v63)) {
      goto LABEL_88;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v45 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v45, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_1830D4000, v45, v46, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v63)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v45 = __nwlog_obj();
      os_log_type_t v56 = type;
      BOOL v57 = os_log_type_enabled(v45, type);
      if (backtrace_string)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
          __int16 v67 = 2082;
          uint64_t v68 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v45, v56, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_88:
        uint64_t v22 = 0;
        if (!v24) {
          goto LABEL_64;
        }
        goto LABEL_63;
      }
      if (v57)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_1830D4000, v45, v56, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v45 = __nwlog_obj();
      os_log_type_t v58 = type;
      if (os_log_type_enabled(v45, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
        _os_log_impl(&dword_1830D4000, v45, v58, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }

    goto LABEL_88;
  }
  unsigned int v5 = (NWConcrete_nw_endpoint_handler *)v3;
  uint64_t mode = v5->mode;

  if (mode == 2)
  {
    id v7 = nw_endpoint_handler_copy_flow(v5);
    uint64_t v62 = v4;
    if (nw_endpoint_handler_get_minimize_logging(v5))
    {
      if (nw_endpoint_handler_get_logging_disabled(v5))
      {
LABEL_47:
        uint64_t v41 = *((void *)v7 + 51);
        buf[0] = v2;
        if (v41)
        {
          uint64_t v42 = *(void *)(v41 + 24);
          if (v42)
          {
            __int16 v43 = *(void (**)(void))(v42 + 160);
            if (v43) {
              v43();
            }
          }
        }

        uint64_t v22 = v62;
        goto LABEL_64;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unsigned __int16 v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
      {
        id_string = nw_endpoint_handler_get_id_string(v5);
        __int16 v48 = nw_endpoint_handler_dry_run_string(v5);
        int v49 = (int)v2;
        nw_endpoint_t v61 = nw_endpoint_handler_copy_endpoint(v5);
        logging_description = nw_endpoint_get_logging_description(v61);
        uint64_t v2 = nw_endpoint_handler_state_string(v5);
        uint64_t v51 = nw_endpoint_handler_mode_string(v5);
        id v52 = nw_endpoint_handler_copy_current_path(v5);
        os_log_type_t v53 = v52;
        *(_DWORD *)buf = 136448002;
        os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
        __int16 v54 = "not ";
        uint64_t v68 = (void *)id_string;
        __int16 v67 = 2082;
        if (v49) {
          __int16 v54 = "";
        }
        __int16 v69 = 2082;
        os_log_type_t v70 = v48;
        __int16 v71 = 2082;
        id v72 = (void *)logging_description;
        __int16 v73 = 2082;
        uint64_t v74 = v2;
        LOBYTE(v2) = v49;
        __int16 v75 = 2082;
        id v76 = v51;
        __int16 v77 = 2114;
        id v78 = v52;
        __int16 v79 = 2082;
        __int16 v80 = v54;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting connection %{public}sidle to protocols", buf, 0x52u);
      }
    }
    else
    {
      int v8 = v5;
      char v9 = *((unsigned char *)v8 + 268);

      if ((v9 & 0x20) != 0) {
        goto LABEL_47;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      unsigned __int16 v10 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
      {
        BOOL v11 = v8;

        int v12 = v11;
        char v13 = *((unsigned char *)v8 + 268);

        if (v13) {
          int v14 = "dry-run ";
        }
        else {
          int v14 = "";
        }
        nw_endpoint_t v15 = nw_endpoint_handler_copy_endpoint(v12);
        os_log_type_t v16 = nw_endpoint_get_logging_description(v15);
        id_str = v11->id_str;
        os_log_type_t v17 = v12;
        int v18 = v17;
        uint64_t v19 = v17[30];
        if (v19 > 5) {
          uint64_t v20 = "unknown-state";
        }
        else {
          uint64_t v20 = off_1E523FB38[v19];
        }
        BOOL v59 = v20;

        __int16 v32 = v18;
        char v33 = v32;
        __int16 v34 = "path";
        switch(v5->mode)
        {
          case 0:
            break;
          case 1:
            __int16 v34 = "resolver";
            break;
          case 2:
            __int16 v34 = nw_endpoint_flow_mode_string(v32[31]);
            break;
          case 3:
            __int16 v34 = "proxy";
            break;
          case 4:
            __int16 v34 = "fallback";
            break;
          case 5:
            __int16 v34 = "transform";
            break;
          default:
            __int16 v34 = "unknown-mode";
            break;
        }

        os_log_type_t v38 = v33;
        os_unfair_lock_lock((os_unfair_lock_t)v38 + 28);
        id v39 = v38[8];
        os_unfair_lock_unlock((os_unfair_lock_t)v38 + 28);

        os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
        os_log_type_t v40 = "not ";
        *(_DWORD *)buf = 136448002;
        if (v2) {
          os_log_type_t v40 = "";
        }
        __int16 v67 = 2082;
        uint64_t v68 = id_str;
        __int16 v69 = 2082;
        os_log_type_t v70 = v14;
        __int16 v71 = 2082;
        id v72 = (void *)v16;
        __int16 v73 = 2082;
        uint64_t v74 = v59;
        __int16 v75 = 2082;
        id v76 = v34;
        __int16 v77 = 2114;
        id v78 = v39;
        __int16 v79 = 2082;
        __int16 v80 = v40;
        _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Reporting connection %{public}sidle to protocols", buf, 0x52u);
      }
    }

    goto LABEL_47;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v21 = (id)gLogObj;
  uint64_t v22 = v4;
  if (mode > 5) {
    os_log_type_t v23 = "unknown-mode";
  }
  else {
    os_log_type_t v23 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
  __int16 v67 = 2082;
  uint64_t v68 = (void *)v23;
  __int16 v69 = 2082;
  os_log_type_t v70 = "flow";
  id v24 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v63 = 0;
  if (!__nwlog_fault(v24, &type, &v63)) {
    goto LABEL_62;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (id)gLogObj;
    os_log_type_t v26 = type;
    if (os_log_type_enabled(v25, type))
    {
      if (mode > 5) {
        os_log_type_t v27 = "unknown-mode";
      }
      else {
        os_log_type_t v27 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
      __int16 v67 = 2082;
      uint64_t v68 = (void *)v27;
      __int16 v69 = 2082;
      os_log_type_t v70 = "flow";
      _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_61:

LABEL_62:
    if (!v24) {
      goto LABEL_64;
    }
LABEL_63:
    free(v24);
    goto LABEL_64;
  }
  if (!v63)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    os_log_type_t v25 = (id)gLogObj;
    os_log_type_t v35 = type;
    if (os_log_type_enabled(v25, type))
    {
      if (mode > 5) {
        os_log_type_t v36 = "unknown-mode";
      }
      else {
        os_log_type_t v36 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
      __int16 v67 = 2082;
      uint64_t v68 = (void *)v36;
      __int16 v69 = 2082;
      os_log_type_t v70 = "flow";
      _os_log_impl(&dword_1830D4000, v25, v35, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_61;
  }
  os_log_type_t v28 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  os_log_type_t v25 = (id)gLogObj;
  os_log_type_t v29 = type;
  BOOL v30 = os_log_type_enabled(v25, type);
  if (!v28)
  {
    if (v30)
    {
      if (mode > 5) {
        os_log_type_t v37 = "unknown-mode";
      }
      else {
        os_log_type_t v37 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
      __int16 v67 = 2082;
      uint64_t v68 = (void *)v37;
      __int16 v69 = 2082;
      os_log_type_t v70 = "flow";
      _os_log_impl(&dword_1830D4000, v25, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_61;
  }
  if (v30)
  {
    if (mode > 5) {
      BOOL v31 = "unknown-mode";
    }
    else {
      BOOL v31 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    os_log_type_t v66 = "nw_endpoint_handler_report_connection_idle";
    __int16 v67 = 2082;
    uint64_t v68 = (void *)v31;
    __int16 v69 = 2082;
    os_log_type_t v70 = "flow";
    __int16 v71 = 2082;
    id v72 = v28;
    _os_log_impl(&dword_1830D4000, v25, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v28);
  if (v24) {
    goto LABEL_63;
  }
LABEL_64:
}

void sub_1831B94A4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, void *a14)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_connected_path(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  nw_connection_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v19 = __Block_byref_object_copy__24353;
    uint64_t v20 = __Block_byref_object_dispose__24354;
    id v21 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_connected_path_block_invoke;
    v13[3] = &unk_1E524B978;
    int v14 = v1;
    nw_endpoint_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_connected_path_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  unsigned int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_path";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_connected_path_block_invoke(uint64_t a1)
{
  uint64_t v13 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    uint64_t v6 = nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    uint64_t v7 = *(void *)(*(void *)(a1 + 40) + 8);
    os_log_type_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        int v9 = 136446466;
        os_log_type_t v10 = "nw_connection_copy_connected_path_block_invoke";
        __int16 v11 = 1024;
        int v12 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Client called nw_connection_copy_connected_path on unconnected nw_connection", (uint8_t *)&v9, 0x12u);
      }
    }
  }
}

void ____nwlog_activity_log_block_invoke()
{
  if ((gHasForked & 1) == 0) {
    gactivityLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "activity");
  }
}

nw_multipath_service_t nw_parameters_get_multipath_service(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    nw_multipath_service_t v3 = *(_DWORD *)((char *)v1[13].isa + 103);
    goto LABEL_3;
  }
  int v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_parameters_get_multipath_service";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_multipath_service";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_parameters_get_multipath_service";
          __int16 v17 = 2082;
          int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_multipath_service";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_parameters_get_multipath_service";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_multipath_service_t v3 = nw_multipath_service_disabled;
LABEL_3:

  return v3;
}

uint64_t validate_tcp_cksum(uint64_t a1, uint64_t a2, unsigned int *a3, unsigned int *a4, unsigned int a5, unsigned int a6, int a7)
{
  uint64_t v106 = *MEMORY[0x1E4F143B8];
  unsigned __int8 v89 = 0;
  unsigned __int16 v88 = 0;
  unsigned __int16 v87 = 0;
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v91 = "__nw_frame_get_internet_checksum";
    os_log_type_t v47 = (char *)_os_log_send_and_compose_impl();
    v105[0] = 16;
    v104[0] = 0;
    if (__nwlog_fault(v47, v105, v104))
    {
      if (v105[0] == 17)
      {
        __int16 v48 = __nwlog_obj();
        os_log_type_t v49 = v105[0];
        if (os_log_type_enabled(v48, (os_log_type_t)v105[0]))
        {
          *(_DWORD *)buf = 136446210;
          int v91 = "__nw_frame_get_internet_checksum";
          __int16 v50 = "%{public}s called with null frame";
LABEL_66:
          __int16 v54 = v48;
LABEL_67:
          _os_log_impl(&dword_1830D4000, v54, v49, v50, buf, 0xCu);
        }
      }
      else if (v104[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v52 = __nwlog_obj();
        os_log_type_t v49 = v105[0];
        loga = v52;
        BOOL v53 = os_log_type_enabled(v52, (os_log_type_t)v105[0]);
        if (backtrace_string)
        {
          if (v53)
          {
            *(_DWORD *)buf = 136446466;
            int v91 = "__nw_frame_get_internet_checksum";
            __int16 v92 = 2082;
            *(void *)BOOL v93 = backtrace_string;
            _os_log_impl(&dword_1830D4000, loga, v49, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_68;
        }
        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          int v91 = "__nw_frame_get_internet_checksum";
          __int16 v50 = "%{public}s called with null frame, no backtrace";
          __int16 v54 = loga;
          goto LABEL_67;
        }
      }
      else
      {
        __int16 v48 = __nwlog_obj();
        os_log_type_t v49 = v105[0];
        if (os_log_type_enabled(v48, (os_log_type_t)v105[0]))
        {
          *(_DWORD *)buf = 136446210;
          int v91 = "__nw_frame_get_internet_checksum";
          __int16 v50 = "%{public}s called with null frame, backtrace limit exceeded";
          goto LABEL_66;
        }
      }
    }
LABEL_68:
    if (v47) {
      free(v47);
    }
    int v14 = 22;
    goto LABEL_71;
  }
  int v14 = 45;
  if ((*(_WORD *)(a1 + 204) & 0x100) == 0 || !g_channel_get_internet_checksum_handler)
  {
LABEL_71:
    int v16 = 0;
    int v86 = v14;
    goto LABEL_72;
  }
  int internet_checksum_handler = g_channel_get_internet_checksum_handler(a1, &v89, &v88, &v87);
  int v86 = internet_checksum_handler;
  if (internet_checksum_handler)
  {
    int v14 = internet_checksum_handler;
    int v16 = 0;
  }
  else
  {
    int v17 = *(unsigned __int16 *)(a1 + 204);
    unsigned int v18 = v17 | (*(unsigned __int8 *)(a1 + 206) << 16);
    if ((v17 & 0x800) != 0)
    {
      if ((v17 & 0x1000) != 0)
      {
        BOOL v29 = v87 == 0xFFFF;
        if (v87 != 0xFFFF)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v30 = gLogObj;
          if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
          {
            BOOL v31 = a7 == 0;
            if (a7) {
              int v32 = 30;
            }
            else {
              int v32 = 2;
            }
            if (v31) {
              char v33 = "IPv4";
            }
            else {
              char v33 = "IPv6";
            }
            __int16 v34 = inet_ntop(v32, a3, v105, 0x2Eu);
            unsigned int v35 = __rev16(a5);
            unsigned int v36 = __rev16(a6);
            os_log_type_t v37 = inet_ntop(v32, a4, v104, 0x2Eu);
            os_log_type_t v38 = "partial";
            if (!v89) {
              os_log_type_t v38 = "";
            }
            *(_DWORD *)buf = 136448515;
            int v91 = "validate_tcp_cksum";
            __int16 v92 = 2085;
            *(void *)BOOL v93 = v34;
            *(_WORD *)&v93[8] = 1024;
            *(_DWORD *)BOOL v94 = v35;
            *(_WORD *)&v94[4] = 2085;
            os_log_type_t v95 = v37;
            *(_WORD *)BOOL v96 = 1024;
            *(_DWORD *)&v96[2] = v36;
            *(_WORD *)__int16 v97 = 2082;
            *(void *)&v97[2] = v33;
            __int16 v98 = 2082;
            unsigned int v99 = (void *)v38;
            __int16 v100 = 1024;
            *(_DWORD *)id v101 = v88;
            *(_WORD *)&v101[4] = 1024;
            *(_DWORD *)&v101[6] = v87;
            *(_WORD *)__int16 v102 = 1024;
            *(_DWORD *)&v102[2] = a2;
            _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_DEBUG, "%{public}s TCP %{sensitive}s:%d -> %{sensitive}s:%d invalid %{public}s-TCP offload %{public}s start %u checksum 0x%x tlen %u", buf, 0x52u);
          }
        }
        return v29;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v19 = gLogObj;
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEBUG))
      {
        if (a7) {
          int v20 = 30;
        }
        else {
          int v20 = 2;
        }
        id v21 = "IPv4";
        if (a7) {
          id v21 = "IPv6";
        }
        nw_endpoint_t v85 = v21;
        uint64_t v81 = inet_ntop(v20, a3, v105, 0x2Eu);
        unsigned int v82 = __rev16(a5);
        unsigned int log = __rev16(a6);
        uint64_t v22 = inet_ntop(v20, a4, v104, 0x2Eu);
        os_log_type_t v23 = "partial";
        if (!v89) {
          os_log_type_t v23 = "";
        }
        *(_DWORD *)buf = 136448515;
        int v91 = "validate_tcp_cksum";
        __int16 v92 = 2085;
        *(void *)BOOL v93 = v81;
        *(_WORD *)&v93[8] = 1024;
        *(_DWORD *)BOOL v94 = v82;
        *(_WORD *)&v94[4] = 2085;
        os_log_type_t v95 = v22;
        *(_WORD *)BOOL v96 = 1024;
        *(_DWORD *)&v96[2] = log;
        *(_WORD *)__int16 v97 = 2082;
        *(void *)&v97[2] = v85;
        __int16 v98 = 2082;
        unsigned int v99 = (void *)v23;
        __int16 v100 = 1024;
        *(_DWORD *)id v101 = v88;
        *(_WORD *)&v101[4] = 1024;
        *(_DWORD *)&v101[6] = v87;
        *(_WORD *)__int16 v102 = 1024;
        *(_DWORD *)&v102[2] = a2;
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s TCP %{sensitive}s:%d -> %{sensitive}s:%d not final %{public}s-TCP offload %{public}s start %u checksum 0x%x tlen %u", buf, 0x52u);
      }
    }
    int v16 = (v18 >> 11) & 1;
    if (v89)
    {
      if (((*(_WORD *)(a1 + 204) & 0x100) == 0
         || !g_channel_check_validity
         || g_channel_check_validity(a1, *(void *)(a1 + 88)))
        && (uint64_t v24 = *(void *)(a1 + 112)) != 0
        && (int v25 = *(_DWORD *)(a1 + 48)) != 0)
      {
        uint64_t v26 = *(void *)(a1 + 112);
        if ((*(_WORD *)(a1 + 204) & 0x100) == 0
          || (uint64_t v26 = *(void *)(a1 + 112), !g_channel_check_validity)
          || g_channel_check_validity(a1, *(void *)(a1 + 88)) && (uint64_t v26 = *(void *)(a1 + 112)) != 0)
        {
          unsigned int v27 = (unsigned __int16)(v26 + *(_WORD *)(a1 + 56) - v24);
          if ((a7 & 1) != 0 || !v88 || v88 == v27)
          {
            int v44 = v27 + a2;
            if (a7)
            {
              unsigned int v28 = v87;
              if (v88 == v27 && v25 == v44) {
                goto LABEL_83;
              }
            }
            else
            {
              unsigned int v28 = v87;
              if (v25 == v44) {
                goto LABEL_52;
              }
            }
          }
          else
          {
            unsigned int v28 = v87;
          }
          LOWORD(v28) = in_adjust_cksum(v24, v25, v88, v27, a2, v28);
          if (a7)
          {
LABEL_83:
            int v46 = in6_pseudo((unsigned __int16 *)a3, (unsigned __int16 *)a4, bswap32(a2 + 6) + (unsigned __int16)v28);
            goto LABEL_84;
          }
LABEL_52:
          unint64_t v45 = *a4 + (unint64_t)*a3 + bswap32(a2 + 6) + (unsigned __int16)v28;
          LODWORD(v45) = ((WORD1(v45) + (unsigned __int16)v45 + HIDWORD(v45)) >> 16)
                       + (unsigned __int16)(WORD1(v45) + v45 + WORD2(v45));
          int v46 = (unsigned __int16)(((WORD1(v45) + (unsigned __int16)v45) >> 16)
                                 + WORD1(v45)
                                 + v45
                                 + ((((WORD1(v45) + (unsigned __int16)v45) >> 16)
                                   + (unsigned __int16)(WORD1(v45) + v45)) >> 16));
LABEL_84:
          unsigned __int16 v87 = ~(_WORD)v46;
          if (v46 == 0xFFFF) {
            return 1;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v64 = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
            return 0;
          }
          BOOL v65 = a7 == 0;
          if (a7) {
            int v66 = 30;
          }
          else {
            int v66 = 2;
          }
          if (v65) {
            __int16 v67 = "IPv4";
          }
          else {
            __int16 v67 = "IPv6";
          }
          uint64_t v68 = inet_ntop(v66, a3, v105, 0x2Eu);
          unsigned int v69 = __rev16(a5);
          unsigned int v70 = __rev16(a6);
          __int16 v71 = inet_ntop(v66, a4, v104, 0x2Eu);
          id v72 = "";
          int v91 = "validate_tcp_cksum";
          __int16 v73 = "-fallback";
          *(_DWORD *)buf = 136448515;
          if (!v16) {
            __int16 v73 = "";
          }
          __int16 v92 = 2085;
          *(void *)BOOL v93 = v68;
          if (v89) {
            id v72 = "partial";
          }
          *(_WORD *)&v93[8] = 1024;
          *(_DWORD *)BOOL v94 = v69;
          *(_WORD *)&v94[4] = 2085;
          os_log_type_t v95 = v71;
          *(_WORD *)BOOL v96 = 1024;
          *(_DWORD *)&v96[2] = v70;
          *(_WORD *)__int16 v97 = 2082;
          *(void *)&v97[2] = v67;
          __int16 v98 = 2082;
          unsigned int v99 = (void *)v73;
          __int16 v100 = 2082;
          *(void *)id v101 = v72;
          *(_WORD *)&v101[8] = 1024;
          *(_DWORD *)__int16 v102 = v87;
          *(_WORD *)&v102[4] = 1024;
          int v103 = a2;
          os_log_type_t v40 = "%{public}s TCP %{sensitive}s:%d -> %{sensitive}s:%d incorrect %{public}s-TCP manual%{public}s %{public}s"
                " checksum 0x%x tlen %u";
          uint64_t v41 = v64;
          os_log_type_t v42 = OS_LOG_TYPE_INFO;
          uint32_t v43 = 86;
          goto LABEL_99;
        }
        id v39 = __nwlog_obj();
        if (!os_log_type_enabled(v39, OS_LOG_TYPE_INFO)) {
          return 0;
        }
        *(_DWORD *)buf = 136446210;
        int v91 = "validate_tcp_cksum";
        os_log_type_t v40 = "%{public}s Frame buffer no longer valid for TCP";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v39 = gLogObj;
        if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_INFO)) {
          return 0;
        }
        *(_DWORD *)buf = 136446210;
        int v91 = "validate_tcp_cksum";
        os_log_type_t v40 = "%{public}s Frame buffer no longer valid";
      }
      uint64_t v41 = v39;
      os_log_type_t v42 = OS_LOG_TYPE_INFO;
      uint32_t v43 = 12;
LABEL_99:
      _os_log_impl(&dword_1830D4000, v41, v42, v40, buf, v43);
      return 0;
    }
    int v14 = 0;
  }
LABEL_72:
  if (!*(void *)(a1 + 32))
  {
    int v86 = 0;
    __int16 v63 = inet_cksum(a1, 0, a2, &v86);
    if (!v86)
    {
      LOWORD(v28) = ~v63;
      if (a7) {
        goto LABEL_83;
      }
      goto LABEL_52;
    }
    return 0;
  }
  char v55 = 1;
  if ((*(_WORD *)(a1 + 204) & 0x100) != 0 && g_channel_check_validity) {
    char v55 = g_channel_check_validity(a1, *(void *)(a1 + 88));
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  uint64_t v56 = gLogObj;
  if (v55)
  {
    unsigned int v57 = *(unsigned __int16 *)(a1 + 204);
    *(_DWORD *)buf = 136448002;
    int v91 = "validate_tcp_cksum";
    __int16 v92 = 1024;
    *(_DWORD *)BOOL v93 = (v57 >> 8) & 1;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = (v57 >> 6) & 1;
    *(_WORD *)BOOL v94 = 1024;
    *(_DWORD *)&v94[2] = (v57 >> 11) & 1;
    LOWORD(v95) = 1024;
    *(_DWORD *)((char *)&v95 + 2) = (v57 >> 12) & 1;
    HIWORD(v95) = 1024;
    *(_DWORD *)BOOL v96 = v89;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)__int16 v97 = v87;
    *(_WORD *)&void v97[4] = 1024;
    *(_DWORD *)&v97[6] = v14;
    os_log_type_t v58 = (char *)_os_log_send_and_compose_impl();
    v105[0] = 16;
    v104[0] = 0;
    if (!__nwlog_fault(v58, v105, v104)) {
      goto LABEL_111;
    }
    if (v105[0] == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v59 = gLogObj;
      os_log_type_t v60 = v105[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v105[0])) {
        goto LABEL_111;
      }
      unsigned int v61 = *(unsigned __int16 *)(a1 + 204);
      *(_DWORD *)buf = 136448002;
      int v91 = "validate_tcp_cksum";
      __int16 v92 = 1024;
      *(_DWORD *)BOOL v93 = (v61 >> 8) & 1;
      *(_WORD *)&v93[4] = 1024;
      *(_DWORD *)&v93[6] = (v61 >> 6) & 1;
      *(_WORD *)BOOL v94 = 1024;
      *(_DWORD *)&v94[2] = (v61 >> 11) & 1;
      LOWORD(v95) = 1024;
      *(_DWORD *)((char *)&v95 + 2) = (v61 >> 12) & 1;
      HIWORD(v95) = 1024;
      *(_DWORD *)BOOL v96 = v89;
      *(_WORD *)&v96[4] = 1024;
      *(_DWORD *)__int16 v97 = v87;
      *(_WORD *)&void v97[4] = 1024;
      *(_DWORD *)&v97[6] = v14;
      uint64_t v62 = "%{public}s super packet checksum not validated or offloaded: channel_frame: %d packet_chain_member: %d csum_"
            "data_valid: %d csum_pseudo_hdr %d partial %u tcp_sum %x error: %d";
    }
    else if (v104[0])
    {
      __int16 v75 = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v59 = gLogObj;
      os_log_type_t v60 = v105[0];
      BOOL v76 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v105[0]);
      if (v75)
      {
        if (v76)
        {
          unsigned int v77 = *(unsigned __int16 *)(a1 + 204);
          *(_DWORD *)buf = 136448258;
          int v91 = "validate_tcp_cksum";
          __int16 v92 = 1024;
          *(_DWORD *)BOOL v93 = (v77 >> 8) & 1;
          *(_WORD *)&v93[4] = 1024;
          *(_DWORD *)&v93[6] = (v77 >> 6) & 1;
          *(_WORD *)BOOL v94 = 1024;
          *(_DWORD *)&v94[2] = (v77 >> 11) & 1;
          LOWORD(v95) = 1024;
          *(_DWORD *)((char *)&v95 + 2) = (v77 >> 12) & 1;
          HIWORD(v95) = 1024;
          *(_DWORD *)BOOL v96 = v89;
          *(_WORD *)&v96[4] = 1024;
          *(_DWORD *)__int16 v97 = v87;
          *(_WORD *)&void v97[4] = 1024;
          *(_DWORD *)&v97[6] = v14;
          __int16 v98 = 2082;
          unsigned int v99 = v75;
          _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s super packet checksum not validated or offloaded: channel_frame: %d packet_chain_member: %d csum_data_valid: %d csum_pseudo_hdr %d partial %u tcp_sum %x error: %d, dumping backtrace:%{public}s", buf, 0x40u);
        }
        free(v75);
        goto LABEL_111;
      }
      if (!v76)
      {
LABEL_111:
        if (v58) {
          free(v58);
        }
        return 1;
      }
      unsigned int v79 = *(unsigned __int16 *)(a1 + 204);
      *(_DWORD *)buf = 136448002;
      int v91 = "validate_tcp_cksum";
      __int16 v92 = 1024;
      *(_DWORD *)BOOL v93 = (v79 >> 8) & 1;
      *(_WORD *)&v93[4] = 1024;
      *(_DWORD *)&v93[6] = (v79 >> 6) & 1;
      *(_WORD *)BOOL v94 = 1024;
      *(_DWORD *)&v94[2] = (v79 >> 11) & 1;
      LOWORD(v95) = 1024;
      *(_DWORD *)((char *)&v95 + 2) = (v79 >> 12) & 1;
      HIWORD(v95) = 1024;
      *(_DWORD *)BOOL v96 = v89;
      *(_WORD *)&v96[4] = 1024;
      *(_DWORD *)__int16 v97 = v87;
      *(_WORD *)&void v97[4] = 1024;
      *(_DWORD *)&v97[6] = v14;
      uint64_t v62 = "%{public}s super packet checksum not validated or offloaded: channel_frame: %d packet_chain_member: %d csum_"
            "data_valid: %d csum_pseudo_hdr %d partial %u tcp_sum %x error: %d, no backtrace";
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v59 = gLogObj;
      os_log_type_t v60 = v105[0];
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v105[0])) {
        goto LABEL_111;
      }
      unsigned int v78 = *(unsigned __int16 *)(a1 + 204);
      *(_DWORD *)buf = 136448002;
      int v91 = "validate_tcp_cksum";
      __int16 v92 = 1024;
      *(_DWORD *)BOOL v93 = (v78 >> 8) & 1;
      *(_WORD *)&v93[4] = 1024;
      *(_DWORD *)&v93[6] = (v78 >> 6) & 1;
      *(_WORD *)BOOL v94 = 1024;
      *(_DWORD *)&v94[2] = (v78 >> 11) & 1;
      LOWORD(v95) = 1024;
      *(_DWORD *)((char *)&v95 + 2) = (v78 >> 12) & 1;
      HIWORD(v95) = 1024;
      *(_DWORD *)BOOL v96 = v89;
      *(_WORD *)&v96[4] = 1024;
      *(_DWORD *)__int16 v97 = v87;
      *(_WORD *)&void v97[4] = 1024;
      *(_DWORD *)&v97[6] = v14;
      uint64_t v62 = "%{public}s super packet checksum not validated or offloaded: channel_frame: %d packet_chain_member: %d csum_"
            "data_valid: %d csum_pseudo_hdr %d partial %u tcp_sum %x error: %d, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v59, v60, v62, buf, 0x36u);
    goto LABEL_111;
  }
  BOOL v29 = 0;
  if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT))
  {
    unsigned int v74 = *(unsigned __int16 *)(a1 + 204);
    *(_DWORD *)buf = 136448002;
    int v91 = "validate_tcp_cksum";
    __int16 v92 = 1024;
    *(_DWORD *)BOOL v93 = (v74 >> 8) & 1;
    *(_WORD *)&v93[4] = 1024;
    *(_DWORD *)&v93[6] = (v74 >> 6) & 1;
    *(_WORD *)BOOL v94 = 1024;
    *(_DWORD *)&v94[2] = (v74 >> 11) & 1;
    LOWORD(v95) = 1024;
    *(_DWORD *)((char *)&v95 + 2) = (v74 >> 12) & 1;
    HIWORD(v95) = 1024;
    *(_DWORD *)BOOL v96 = v89;
    *(_WORD *)&v96[4] = 1024;
    *(_DWORD *)__int16 v97 = v87;
    *(_WORD *)&void v97[4] = 1024;
    *(_DWORD *)&v97[6] = v14;
    os_log_type_t v40 = "%{public}s super packet invalid, channel_frame: %d packet_chain_member: %u csum_data_valid: %u csum_pseudo_hdr"
          " %u partial %u tcp_sum %x error: %d";
    uint64_t v41 = v56;
    os_log_type_t v42 = OS_LOG_TYPE_DEFAULT;
    uint32_t v43 = 54;
    goto LABEL_99;
  }
  return v29;
}

_DWORD *network_proxy_create_from_parameters(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v14 = "network_proxy_create_from_parameters";
    int v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v5, &type, &v11)) {
      goto LABEL_21;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      int v14 = "network_proxy_create_from_parameters";
      os_log_type_t v8 = "%{public}s called with null parameters";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          int v14 = "network_proxy_create_from_parameters";
          __int16 v15 = 2082;
          int v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_21;
      }
      if (!v10)
      {
LABEL_21:
        if (v5) {
          free(v5);
        }
        return 0;
      }
      *(_DWORD *)buf = 136446210;
      int v14 = "network_proxy_create_from_parameters";
      os_log_type_t v8 = "%{public}s called with null parameters, no backtrace";
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_21;
      }
      *(_DWORD *)buf = 136446210;
      int v14 = "network_proxy_create_from_parameters";
      os_log_type_t v8 = "%{public}s called with null parameters, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_21;
  }
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1[23];

  if (v2)
  {
    nw_parameters_t v2 = v2;
    int v3 = v2[38];

    if (v3 != 1)
    {
      os_release(v2);
      return 0;
    }
  }
  return v2;
}

uint64_t nw_context_128k_buffer_length()
{
  return dword_1E8F65238;
}

id nw_connection_copy_metadata(void *a1)
{
  uint64_t v30 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    unsigned int v27 = __Block_byref_object_copy__24353;
    unsigned int v28 = __Block_byref_object_dispose__24354;
    id v29 = 0;
    *(void *)os_log_type_t type = 0;
    uint64_t v22 = type;
    uint64_t v23 = 0x2020000000;
    char v24 = 0;
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    v17[2] = __nw_connection_copy_metadata_block_invoke;
    v17[3] = &unk_1E5244950;
    int v3 = v1;
    unsigned int v18 = v3;
    uint64_t v19 = type;
    int v20 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_metadata_block_invoke(v17);
    os_unfair_lock_unlock(v2 + 34);
    uint64_t v4 = *(void *)&buf[8];
    if (*((unsigned char *)v22 + 24) && !*(void *)(*(void *)&buf[8] + 40))
    {
      id v5 = nw_parameters_copy_metadata(v3[2]);
      uint64_t v6 = *(void **)(*(void *)&buf[8] + 40);
      *(void *)(*(void *)&buf[8] + 40) = v5;

      uint64_t v4 = *(void *)&buf[8];
    }
    id v7 = *(id *)(v4 + 40);

    _Block_object_dispose(type, 8);
    _Block_object_dispose(buf, 8);

    goto LABEL_6;
  }
  int v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_metadata";
  BOOL v10 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  char v25 = 0;
  if (__nwlog_fault(v10, type, &v25))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v12 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_metadata";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v25)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = __nwlog_obj();
      os_log_type_t v14 = type[0];
      BOOL v15 = os_log_type_enabled(v11, type[0]);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_metadata";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_23;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_metadata";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v11 = __nwlog_obj();
      os_log_type_t v16 = type[0];
      if (os_log_type_enabled(v11, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_metadata";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_23:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_6:

  return v7;
}

id nw_parameters_copy_metadata(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    id v3 = v1[27];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_parameters_copy_metadata";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_metadata";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_parameters_copy_metadata";
          __int16 v17 = 2082;
          unsigned int v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_metadata";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_metadata";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_metadata_block_invoke(void *a1)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = a1[4];
  if ((*(unsigned char *)(v2 + 109) & 0x40) == 0)
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(a1[4] + 448);
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_metadata_block_invoke";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Client called nw_connection_copy_metadata on unconnected nw_connection", buf, 0x12u);
      }
    }
    return;
  }
  *(unsigned char *)(*(void *)(a1[5] + 8) + 24) = 1;
  uint64_t v6 = (os_unfair_lock_s *)*(id *)(a1[4] + 144);
  id v7 = v6;
  if (!v6)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_metadata";
    BOOL v15 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v27 = 0;
    if (__nwlog_fault(v15, type, &v27))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_metadata";
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v27)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v19 = type[0];
        BOOL v20 = os_log_type_enabled(v16, type[0]);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_metadata";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_38;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_metadata";
          _os_log_impl(&dword_1830D4000, v16, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v16 = (id)gLogObj;
        os_log_type_t v21 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_copy_metadata";
          _os_log_impl(&dword_1830D4000, v16, v21, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_38:
    if (v15) {
      free(v15);
    }
    id v11 = 0;
    goto LABEL_19;
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x3032000000;
  id v29 = __Block_byref_object_copy__31359;
  uint64_t v30 = __Block_byref_object_dispose__31360;
  id v31 = 0;
  os_unfair_lock_lock(v6 + 28);
  int v8 = nw_endpoint_flow_uses_flow_divert(*(void **)&v7[62]._os_unfair_lock_opaque);
  os_unfair_lock_unlock(v7 + 28);
  if (v8)
  {
    int v9 = v7;
    os_unfair_lock_lock(v7 + 28);
    if (v9[29]._os_unfair_lock_opaque == 2) {
      id v10 = nw_endpoint_flow_copy_connected_socket_wrapper(*(void **)&v7[62]._os_unfair_lock_opaque);
    }
    else {
      id v10 = 0;
    }
    os_unfair_lock_unlock(v7 + 28);

    if (v10)
    {
      *(void *)os_log_type_t type = MEMORY[0x1E4F143A8];
      uint64_t v23 = 3221225472;
      char v24 = __nw_endpoint_handler_copy_metadata_block_invoke;
      char v25 = &unk_1E524A270;
      uint64_t v26 = buf;
      nw_fd_wrapper_get_fd(v10, type);
    }
  }
  id v11 = *(id *)(*(void *)&buf[8] + 40);
  _Block_object_dispose(buf, 8);

LABEL_19:
  uint64_t v12 = *(void *)(a1[6] + 8);
  char v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v11;
}

void sub_1831BBA50(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, char a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,id a24)
{
  _Block_object_dispose(&a19, 8);
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_uses_flow_divert(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    os_unfair_lock_lock(v1 + 220);
    if ((v2[8]._os_unfair_lock_opaque & 2) != 0 || (v2[8]._os_unfair_lock_opaque & 0x100) != 0)
    {
      uint64_t v5 = (BYTE2(v2[8]._os_unfair_lock_opaque) >> 2) & 1;
    }
    else
    {
      uint64_t v3 = *(NWConcrete_nw_endpoint_handler **)&v2[234]._os_unfair_lock_opaque;
      if (v3)
      {
        uint64_t v4 = nw_endpoint_handler_copy_flow(v3);
        uint64_t v5 = nw_endpoint_flow_uses_flow_divert();
      }
      else
      {
        uint64_t v5 = 0;
      }
    }
    os_unfair_lock_unlock(v2 + 220);
    goto LABEL_8;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  unsigned int v18 = "nw_endpoint_flow_uses_flow_divert";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_endpoint_flow_uses_flow_divert";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          unsigned int v18 = "nw_endpoint_flow_uses_flow_divert";
          __int16 v19 = 2082;
          BOOL v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_26;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_endpoint_flow_uses_flow_divert";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        unsigned int v18 = "nw_endpoint_flow_uses_flow_divert";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_26:
  if (v8) {
    free(v8);
  }
  uint64_t v5 = 0;
LABEL_8:

  return v5;
}

void sub_1831BBD78(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_connection_get_tls_version(NWConcrete_nw_connection *a1)
{
  nw_parameters_t v1 = a1;
  uint64_t v2 = nw_protocol_boringssl_copy_definition();
  nw_protocol_metadata_t v3 = nw_connection_copy_protocol_metadata(&v1->super, v2);

  if (v3)
  {
    uint64_t v4 = v3;
    int negotiated_tls_protocol_version = sec_protocol_metadata_get_negotiated_tls_protocol_version(v4);
    uint64_t v6 = 2;
    switch(negotiated_tls_protocol_version)
    {
      case 769:
        break;
      case 770:
        uint64_t v6 = 3;
        break;
      case 771:
        uint64_t v6 = 4;
        break;
      case 772:
        uint64_t v6 = 5;
        break;
      default:
        if (negotiated_tls_protocol_version == 65277)
        {
          uint64_t v6 = 7;
        }
        else if (negotiated_tls_protocol_version == 65279)
        {
          uint64_t v6 = 6;
        }
        else
        {
          uint64_t v6 = 0;
        }
        break;
    }
  }
  else
  {
    uint64_t v6 = 0;
  }

  return v6;
}

void sub_1831BBE7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_protocol_metadata_on_queue(void *a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (v3)
  {
    nw_context_assert_queue(*((void **)v3 + 3));
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v22 = __Block_byref_object_copy__24353;
    uint64_t v23 = __Block_byref_object_dispose__24354;
    id v24 = 0;
    v15[0] = MEMORY[0x1E4F143A8];
    v15[1] = 3221225472;
    v15[2] = __nw_connection_copy_protocol_metadata_on_queue_block_invoke;
    v15[3] = &unk_1E5242570;
    unsigned int v18 = buf;
    id v16 = v3;
    id v17 = v4;
    os_unfair_lock_lock((os_unfair_lock_t)v3 + 34);
    __nw_connection_copy_protocol_metadata_on_queue_block_invoke((uint64_t)v15);
    os_unfair_lock_unlock((os_unfair_lock_t)v3 + 34);
    id v5 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
  int v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v8, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_on_queue";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
  id v5 = 0;
LABEL_3:

  return v5;
}

void sub_1831BC23C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __nw_connection_copy_protocol_metadata_on_queue_block_invoke(uint64_t a1)
{
  id v2 = nw_connection_copy_protocol_metadata_locked(*(void *)(a1 + 32), *(void **)(a1 + 40), 1, 0);
  uint64_t v3 = *(void *)(*(void *)(a1 + 48) + 8);
  id v4 = *(void **)(v3 + 40);
  *(void *)(v3 + 40) = v2;
}

id nw_connection_copy_protocol_metadata_locked(uint64_t a1, void *a2, int a3, int a4)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v7 = a2;
  if (a1)
  {
    id v8 = nw_endpoint_handler_copy_protocol_metadata(*(void **)(a1 + 144), v7, a3, a4);
    goto LABEL_3;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v21 = "nw_connection_copy_protocol_metadata_locked";
  id v11 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v18 = 0;
  if (__nwlog_fault(v11, &type, &v18))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v13 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_connection_copy_protocol_metadata_locked";
        _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v18)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v15 = type;
      BOOL v16 = os_log_type_enabled(v12, type);
      if (backtrace_string)
      {
        if (v16)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v21 = "nw_connection_copy_protocol_metadata_locked";
          __int16 v22 = 2082;
          uint64_t v23 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v16)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_connection_copy_protocol_metadata_locked";
        _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (os_log_type_enabled(v12, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v21 = "nw_connection_copy_protocol_metadata_locked";
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v11) {
    free(v11);
  }
  id v8 = 0;
LABEL_3:

  return v8;
}

void sub_1831BC55C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_protocol_metadata_t nw_connection_copy_protocol_metadata(nw_connection_t connection, nw_protocol_definition_t definition)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = connection;
  id v4 = definition;
  if (v3)
  {
    id v5 = nw_connection_copy_protocol_metadata_internal(v3, v4, 0);
    goto LABEL_3;
  }
  id v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v18 = "nw_connection_copy_protocol_metadata";
  id v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_connection_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          char v18 = "nw_connection_copy_protocol_metadata";
          __int16 v19 = 2082;
          BOOL v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_connection_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        char v18 = "nw_connection_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
  id v5 = 0;
LABEL_3:

  return v5;
}

void sub_1831BC828(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_protocol_metadata_internal(void *a1, void *a2, char a3)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  if (v5)
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v25 = __Block_byref_object_copy__24353;
    uint64_t v26 = __Block_byref_object_dispose__24354;
    id v27 = 0;
    v17[0] = MEMORY[0x1E4F143A8];
    v17[1] = 3221225472;
    v17[2] = __nw_connection_copy_protocol_metadata_internal_block_invoke;
    v17[3] = &unk_1E523DB90;
    char v18 = v5;
    BOOL v20 = buf;
    id v19 = v6;
    char v21 = a3;
    os_unfair_lock_lock(v5 + 34);
    __nw_connection_copy_protocol_metadata_internal_block_invoke((uint64_t)v17);
    os_unfair_lock_unlock(v5 + 34);
    id v7 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  int v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v10, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v22)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_protocol_metadata_internal";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_3:

  return v7;
}

void __nw_connection_copy_protocol_metadata_internal_block_invoke(uint64_t a1)
{
  uint64_t v15 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    int v6 = *(unsigned __int8 *)(a1 + 56);
    id v7 = *(id *)(a1 + 40);
    id v8 = nw_endpoint_handler_copy_protocol_metadata(*(void **)(v2 + 144), v7, 0, v6);

    uint64_t v9 = *(void *)(*(void *)(a1 + 48) + 8);
    os_log_type_t v10 = *(void **)(v9 + 40);
    *(void *)(v9 + 40) = v8;
  }
  else
  {
    uint64_t v3 = *(void *)(v2 + 16);
    if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v4 = (id)gconnectionLogObj;
      if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
      {
        int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
        int v11 = 136446466;
        os_log_type_t v12 = "nw_connection_copy_protocol_metadata_internal_block_invoke";
        __int16 v13 = 1024;
        int v14 = v5;
        _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Client called nw_connection_copy_protocol_metadata_internal on unconnected nw_connection", (uint8_t *)&v11, 0x12u);
      }
    }
  }
}

void sub_1831BCD80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_handler_copy_protocol_metadata(void *a1, void *a2, int a3, int a4)
{
  uint64_t v31 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = v8;
  if (v7)
  {
    if (v8)
    {
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 28);
      if (*((_DWORD *)v7 + 29) == 2) {
        id v10 = nw_endpoint_flow_copy_protocol_metadata(v7, *((void **)v7 + 31), v9, a3, a4);
      }
      else {
        id v10 = 0;
      }
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 28);
      goto LABEL_7;
    }
    os_log_type_t v16 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
    __int16 v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = __nwlog_obj();
        os_log_type_t v17 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null definition", buf, 0xCu);
        }
LABEL_39:

        goto LABEL_40;
      }
      if (!v25)
      {
        int v14 = __nwlog_obj();
        os_log_type_t v24 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_1830D4000, v14, v24, "%{public}s called with null definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v14 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
        __int16 v29 = 2082;
        uint64_t v30 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v14, v21, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_27;
    }
  }
  else
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
    __int16 v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v25 = 0;
    if (__nwlog_fault(v13, &type, &v25))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null handler", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (!v25)
      {
        int v14 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_1830D4000, v14, v23, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_39;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v14 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v14, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
        goto LABEL_39;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v28 = "nw_endpoint_handler_copy_protocol_metadata";
        __int16 v29 = 2082;
        uint64_t v30 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_27:

      free(backtrace_string);
    }
  }
LABEL_40:
  if (v13) {
    free(v13);
  }
  id v10 = 0;
LABEL_7:

  return v10;
}

void sub_1831BD288(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_endpoint_flow_copy_protocol_metadata(void *a1, void *a2, void *a3, int a4, int a5)
{
  uint64_t v33 = *MEMORY[0x1E4F143B8];
  uint64_t v9 = a1;
  id v10 = a2;
  id v11 = a3;
  if (v10)
  {
    if (a4) {
      nw_endpoint_flow_update_connected_metadata(v9, a5);
    }
    os_unfair_lock_lock(v10 + 220);
    uint64_t v12 = 262;
    if (a5) {
      uint64_t v12 = 264;
    }
    __int16 v13 = (atomic_uchar *)*(id *)&v10[v12]._os_unfair_lock_opaque;
    os_unfair_lock_unlock(v10 + 220);
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    uint64_t v30 = __Block_byref_object_copy__81752;
    uint64_t v31 = __Block_byref_object_dispose__81753;
    id v32 = 0;
    v24[0] = MEMORY[0x1E4F143A8];
    v24[1] = 3221225472;
    v24[2] = __nw_endpoint_flow_copy_protocol_metadata_block_invoke;
    v24[3] = &unk_1E524A2E8;
    id v25 = v11;
    uint64_t v26 = buf;
    nw_array_apply(v13, (uint64_t)v24);
    id v14 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_7;
  }
  os_log_type_t v16 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
  os_log_type_t v17 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v27 = 0;
  if (__nwlog_fault(v17, &type, &v27))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v18 = __nwlog_obj();
      os_log_type_t v19 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v18, v19, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v27)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v18 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v22 = os_log_type_enabled(v18, type);
      if (backtrace_string)
      {
        if (v22)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v22)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v18, v21, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v18 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v18, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_copy_protocol_metadata";
        _os_log_impl(&dword_1830D4000, v18, v23, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v17) {
    free(v17);
  }
  id v14 = 0;
LABEL_7:

  return v14;
}

void sub_1831BD664(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_data_get_size(void *a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    int v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v17 = "nw_protocol_data_get_size";
    int v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v6, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null data", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v7 = __nwlog_obj();
        os_log_type_t v10 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v17 = "nw_protocol_data_get_size";
            __int16 v18 = 2082;
            os_log_type_t v19 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v11)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v7 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v7, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v17 = "nw_protocol_data_get_size";
          _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v6) {
      free(v6);
    }
    goto LABEL_22;
  }
  int v3 = v1[13];
  if (!v3)
  {
LABEL_22:
    uint64_t v4 = 0;
    goto LABEL_23;
  }
  uint64_t v4 = (v3 - (v1[14] + v1[15]));
LABEL_23:

  return v4;
}

int64_t nw_settings_get_flow_report_denominator()
{
  int64_t v0 = 500000;
  nw_parameters_t v1 = (const char *)nw_setting_flow_report_denominator;
  networkd_settings_init();
  if (sCachedSettings)
  {
    pthread_mutex_lock(&sSettingsMutex);
    uint64_t v2 = (void *)sCachedSettings;
    if (sCachedSettings)
    {
      Class Class = object_getClass((id)sCachedSettings);
      if (v1)
      {
        if (Class == (Class)MEMORY[0x1E4F14590])
        {
          xpc_object_t value = xpc_dictionary_get_value(v2, v1);
          if (value)
          {
            int v5 = value;
            if (object_getClass(value) == (Class)MEMORY[0x1E4F145C0]) {
              int64_t v0 = xpc_int64_get_value(v5);
            }
          }
        }
      }
    }
    pthread_mutex_unlock(&sSettingsMutex);
  }
  return v0;
}

id nw_parameters_get_upper_transport_protocol_options(void *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    os_log_type_t v12 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
    __int16 v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v22 = 0;
    if (__nwlog_fault(v13, &type, &v22))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v22)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        char v14 = __nwlog_obj();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_31;
        }
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v14 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_get_upper_transport_protocol_options";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_31:
    if (v13) {
      free(v13);
    }
    goto LABEL_33;
  }
  uint64_t v3 = v1[19];
  if (!v3 || (uint64_t v4 = *(void **)(v3 + 24)) == 0)
  {
LABEL_33:
    id v11 = 0;
    goto LABEL_34;
  }
  id v5 = v4;
  if (nw_protocol_setup_udp_definition(void)::onceToken[0] != -1) {
    dispatch_once(nw_protocol_setup_udp_definition(void)::onceToken, &__block_literal_global_45806);
  }
  BOOL v6 = nw_protocol_options_matches_definition(v5, (void *)g_udp_definition);

  id v7 = *(void **)(v2[19] + 24);
  if (v6)
  {
    if (nw_udp_options_get_use_quic_stats(v7))
    {
      *(void *)buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      id v25 = __Block_byref_object_copy__19403;
      uint64_t v26 = __Block_byref_object_dispose__19404;
      id v27 = 0;
      os_log_type_t v8 = v2[19];
      if (v8)
      {
        iterate_block[0] = MEMORY[0x1E4F143A8];
        iterate_block[1] = 3221225472;
        iterate_block[2] = __nw_parameters_get_upper_transport_protocol_options_block_invoke;
        iterate_block[3] = &unk_1E5240D88;
        void iterate_block[4] = buf;
        nw_protocol_stack_iterate_application_protocols(v8, iterate_block);
        uint64_t v9 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        uint64_t v9 = 0;
      }
      id v11 = v9;
      _Block_object_dispose(buf, 8);

      goto LABEL_34;
    }
    id v10 = *(id *)(v2[19] + 24);
  }
  else
  {
    id v10 = v7;
  }
  id v11 = v10;
LABEL_34:

  return v11;
}

void sub_1831BDDC8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_connection_update_better_path_locked_on_nw_queue(NWConcrete_nw_connection *a1)
{
  uint64_t v53 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    nw_context_assert_queue(v1->context);
    uint64_t v3 = v2->parent_endpoint_handler;
    if ((*((unsigned char *)v2 + 109) & 0x40) != 0) {
      uint64_t v4 = nw_endpoint_handler_copy_connected_flow_handler(v2->parent_endpoint_handler);
    }
    else {
      uint64_t v4 = 0;
    }
    id v5 = v2->ready_dry_run_endpoint_handler;
    if (v5 || (v6 = v4, v3, v5 = v6, (uint64_t v3 = v5) != 0))
    {
      id v7 = v5;
      os_unfair_lock_lock((os_unfair_lock_t)v7 + 28);
      id v8 = *((id *)v7 + 8);
      os_unfair_lock_unlock((os_unfair_lock_t)v7 + 28);

      if (!v4) {
        goto LABEL_21;
      }
      if (nw_endpoint_handler_get_alternate_path_state(v4, v3, v7, v8))
      {
        if (v2->alternate_path_state != 1)
        {
          v2->alternate_path_int state = 1;
          parameters = v2->parameters;
          if (parameters && !nw_path_parameters_get_logging_disabled(*((void *)parameters + 13)))
          {
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id v10 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v10, OS_LOG_TYPE_INFO))
            {
              unsigned int top_id = v2->top_id;
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = top_id;
              _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_INFO, "%{public}s [C%u] Better alternate path available", buf, 0x12u);
            }
          }
          stats_reunsigned int port = v2->stats_report;
          if (stats_report) {
            ++stats_report->u.legacy.statistics_report.better_route_event_count;
          }
          char v13 = 1;
          int v14 = 1;
          goto LABEL_54;
        }
LABEL_62:

        goto LABEL_63;
      }
      if ((nw_connection_used_fallback_locked(v2) & 1) == 0)
      {
        os_log_type_t v15 = nw_endpoint_handler_copy_current_path(v2->parent_endpoint_handler);
        os_log_type_t v16 = v15;
        if (v15
          && (uint64_t v17 = v15[14]) != 0
          && *(_DWORD *)(v17 + 8)
          && (v18 = v15, int v19 = v18[93], v18, v19 != v2->connected_fallback_generation))
        {
          if (nw_path_fallback_is_weak(v18)) {
            int v14 = 2;
          }
          else {
            int v14 = 3;
          }
        }
        else
        {
          int v14 = 0;
        }
      }
      else
      {
LABEL_21:
        int v14 = 0;
      }
    }
    else
    {
      id v8 = 0;
      id v7 = 0;
      int v14 = 0;
    }
    alternate_path_int state = v2->alternate_path_state;
    if (alternate_path_state == v14) {
      goto LABEL_62;
    }
    v2->alternate_path_int state = v14;
    if (v14 == 3)
    {
      id v25 = v2->parameters;
      if (!v25 || nw_path_parameters_get_logging_disabled(*((void *)v25 + 13))) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v22 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO)) {
        goto LABEL_51;
      }
      unsigned int v26 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v26;
      os_log_type_t v24 = "%{public}s [C%u] Alternate path recommended";
    }
    else if (v14 == 2)
    {
      id v27 = v2->parameters;
      if (!v27 || nw_path_parameters_get_logging_disabled(*((void *)v27 + 13))) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v22 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO)) {
        goto LABEL_51;
      }
      unsigned int v28 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v28;
      os_log_type_t v24 = "%{public}s [C%u] Alternate path potentially available";
    }
    else
    {
      os_log_type_t v21 = v2->parameters;
      if (!v21 || nw_path_parameters_get_logging_disabled(*((void *)v21 + 13))) {
        goto LABEL_52;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      char v22 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v22, OS_LOG_TYPE_INFO))
      {
LABEL_51:

LABEL_52:
        if (alternate_path_state != 1)
        {
LABEL_58:
          __int16 v34 = v2;
          nw_context_assert_queue(v2->context);
          id alternate_path_state_handler = v34->alternate_path_state_handler;
          if (alternate_path_state_handler && v34->state != 5)
          {
            unsigned int v36 = _Block_copy(alternate_path_state_handler);
            dispatch_qos_class_t client_qos_class = v34->client_qos_class;
            *(void *)buf = MEMORY[0x1E4F143A8];
            *(void *)&uint8_t buf[8] = 3221225472;
            *(void *)&buf[16] = ___ZL59nw_connection_send_alternate_path_state_changed_on_nw_queueP24NWConcrete_nw_connection36nw_connection_alternate_path_state_t_block_invoke;
            __int16 v50 = &unk_1E524B020;
            id v51 = v36;
            int v52 = v14;
            id v38 = v36;
            nw_connection_async_client(v34, client_qos_class, buf);
          }
          goto LABEL_62;
        }
        char v13 = 0;
LABEL_54:
        __int16 v29 = v2;
        nw_context_assert_queue(v2->context);
        id better_path_available_handler = v29->better_path_available_handler;
        if (better_path_available_handler && v29->state != 5)
        {
          uint64_t v31 = _Block_copy(better_path_available_handler);
          dispatch_qos_class_t v32 = v29->client_qos_class;
          *(void *)buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&buf[16] = ___ZL50nw_connection_send_better_path_changed_on_nw_queueP24NWConcrete_nw_connectionb_block_invoke;
          __int16 v50 = &unk_1E5249BD0;
          id v51 = v31;
          LOBYTE(v52) = v13;
          id v33 = v31;
          nw_connection_async_client(v29, v32, buf);
        }
        goto LABEL_58;
      }
      unsigned int v23 = v2->top_id;
      *(_DWORD *)buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v23;
      os_log_type_t v24 = "%{public}s [C%u] Alternate path not available";
    }
    _os_log_impl(&dword_1830D4000, v22, OS_LOG_TYPE_INFO, v24, buf, 0x12u);
    goto LABEL_51;
  }
  id v39 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
  os_log_type_t v40 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v47 = 0;
  if (__nwlog_fault(v40, &type, &v47))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v41 = __nwlog_obj();
      os_log_type_t v42 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v41, v42, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v47)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v41 = __nwlog_obj();
      os_log_type_t v44 = type;
      BOOL v45 = os_log_type_enabled(v41, type);
      if (backtrace_string)
      {
        if (v45)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v41, v44, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_83;
      }
      if (v45)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v41, v44, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v41 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v41, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_update_better_path_locked_on_nw_queue";
        _os_log_impl(&dword_1830D4000, v41, v46, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_83:
  if (v40) {
    free(v40);
  }
LABEL_63:
}

void sub_1831BE5F4(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_get_alternate_path_state(void *a1, void *a2, void *a3, void *a4)
{
  uint64_t v196 = *MEMORY[0x1E4F143B8];
  id v7 = a1;
  id v8 = a2;
  uint64_t v9 = a3;
  id v10 = a4;
  id v11 = v10;
  uint64_t v174 = v7;
  if (v7)
  {
    if (v8)
    {
      if (v9)
      {
LABEL_4:
        uint64_t v170 = v8;
        __int16 v171 = v9;
        id v173 = v11;
        if (*((_DWORD *)v7 + 29) != 2 || (os_log_type_t v12 = (void *)nw_endpoint_handler_copy_connected_path(v7)) == 0)
        {
          id v19 = v7[8];
          v172 = 0;
          BOOL v18 = 0;
          char v20 = 1;
          int is_viable = 1;
          __int16 v175 = v19;
          if (!v11) {
            goto LABEL_53;
          }
          goto LABEL_48;
        }
        id v13 = v12;
        int is_viable = nw_endpoint_handler_is_viable(v7);
        os_log_type_t v15 = v7;
        uint64_t v16 = *((unsigned int *)v7 + 29);

        if (v16 == 2)
        {
          uint64_t v17 = (char *)nw_endpoint_handler_copy_flow(v15);
          BOOL v18 = v17[34] < 0;

          goto LABEL_47;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v21 = (id)gLogObj;
        if (v16 > 5) {
          char v22 = "unknown-mode";
        }
        else {
          char v22 = off_1E523FB08[v16];
        }
        *(_DWORD *)buf = 136446722;
        os_log_type_t v179 = "nw_endpoint_handler_reported_do_not_reuse";
        __int16 v180 = 2082;
        os_log_type_t v181 = (void *)v22;
        __int16 v182 = 2082;
        uint64_t v183 = "flow";
        unsigned int v23 = (char *)_os_log_send_and_compose_impl();

        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v176 = 0;
        if (__nwlog_fault(v23, &type, &v176))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (id)gLogObj;
            os_log_type_t v25 = type;
            if (os_log_type_enabled(v24, type))
            {
              if (v16 > 5) {
                unsigned int v26 = "unknown-mode";
              }
              else {
                unsigned int v26 = off_1E523FB08[v16];
              }
              *(_DWORD *)buf = 136446722;
              os_log_type_t v179 = "nw_endpoint_handler_reported_do_not_reuse";
              __int16 v180 = 2082;
              os_log_type_t v181 = (void *)v26;
              __int16 v182 = 2082;
              uint64_t v183 = "flow";
              _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
            }
LABEL_30:

            goto LABEL_44;
          }
          if (!v176)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            os_log_type_t v24 = (id)gLogObj;
            os_log_type_t v32 = type;
            if (os_log_type_enabled(v24, type))
            {
              if (v16 > 5) {
                id v33 = "unknown-mode";
              }
              else {
                id v33 = off_1E523FB08[v16];
              }
              *(_DWORD *)buf = 136446722;
              os_log_type_t v179 = "nw_endpoint_handler_reported_do_not_reuse";
              __int16 v180 = 2082;
              os_log_type_t v181 = (void *)v33;
              __int16 v182 = 2082;
              uint64_t v183 = "flow";
              _os_log_impl(&dword_1830D4000, v24, v32, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
            }
            goto LABEL_30;
          }
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          unsigned int v28 = (id)gLogObj;
          os_log_type_t v29 = type;
          BOOL v30 = os_log_type_enabled(v28, type);
          if (backtrace_string)
          {
            if (v30)
            {
              if (v16 > 5) {
                uint64_t v31 = "unknown-mode";
              }
              else {
                uint64_t v31 = off_1E523FB08[v16];
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v179 = "nw_endpoint_handler_reported_do_not_reuse";
              __int16 v180 = 2082;
              os_log_type_t v181 = (void *)v31;
              __int16 v182 = 2082;
              uint64_t v183 = "flow";
              __int16 v184 = 2082;
              v185 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(backtrace_string);
            if (!v23) {
              goto LABEL_46;
            }
            goto LABEL_45;
          }
          if (v30)
          {
            if (v16 > 5) {
              __int16 v34 = "unknown-mode";
            }
            else {
              __int16 v34 = off_1E523FB08[v16];
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v179 = "nw_endpoint_handler_reported_do_not_reuse";
            __int16 v180 = 2082;
            os_log_type_t v181 = (void *)v34;
            __int16 v182 = 2082;
            uint64_t v183 = "flow";
            _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
          }
        }
LABEL_44:
        if (!v23)
        {
LABEL_46:
          BOOL v18 = 0;
LABEL_47:

          char v20 = 0;
          id v19 = v13;
          v172 = v13;
          id v11 = v173;
          __int16 v175 = v13;
          if (!v173) {
            goto LABEL_53;
          }
LABEL_48:
          if (v19)
          {
            unsigned int v35 = v11;
            int isa = (int)v35[47].isa;

            if (isa == 1)
            {
              os_log_type_t v37 = v175;
              id v38 = v37;
              if (LODWORD(v37[33].isa) != 4)
              {

LABEL_64:
                if (!is_viable || (os_log_type_t v49 = v38, v50 = (int)v49[47].isa, v49, v50 == 2))
                {
                  id v51 = v174;
                  int v52 = v51;
                  id v53 = v51[4];
                  if (v53)
                  {
                    __int16 v54 = v53;
                    BOOL v55 = (v54[12] & 0x4000000000) == 0;

                    if (v55)
                    {
                      if ((*((unsigned char *)v52 + 268) & 0x20) != 0) {
                        goto LABEL_191;
                      }
                      goto LABEL_83;
                    }
                    if ((nw_endpoint_handler_get_logging_disabled(v52) & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      uint64_t v56 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                      {
                        id_string = nw_endpoint_handler_get_id_string(v52);
                        os_log_type_t v143 = nw_endpoint_handler_dry_run_string(v52);
                        nw_endpoint_t v144 = nw_endpoint_handler_copy_endpoint(v52);
                        logging_description = nw_endpoint_get_logging_description(v144);
                        uint64_t v146 = nw_endpoint_handler_state_string(v52);
                        BOOL v147 = nw_endpoint_handler_mode_string(v52);
                        id v148 = nw_endpoint_handler_copy_current_path(v52);
                        *(_DWORD *)buf = 136448258;
                        os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                        __int16 v180 = 2082;
                        os_log_type_t v181 = (void *)id_string;
                        __int16 v182 = 2082;
                        uint64_t v183 = v143;
                        __int16 v184 = 2082;
                        v185 = (void *)logging_description;
                        __int16 v186 = 2082;
                        id v187 = v146;
                        __int16 v188 = 2082;
                        os_log_type_t v189 = v147;
                        __int16 v190 = 2114;
                        id v191 = v148;
                        __int16 v192 = 2114;
                        os_log_type_t v193 = v35;
                        __int16 v194 = 2114;
                        v195 = v38;
                        _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{public}@ due to non-viable current path %{public}@", buf, 0x5Cu);
                      }
LABEL_107:
                      uint64_t v43 = 1;
LABEL_122:

                      goto LABEL_123;
                    }
                  }
                  else
                  {

                    if ((*((unsigned char *)v52 + 268) & 0x20) == 0)
                    {
LABEL_83:
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      uint64_t v43 = 1;
                      __int16 v67 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v67, OS_LOG_TYPE_INFO))
                      {
                        if (*((unsigned char *)v52 + 268)) {
                          uint64_t v68 = "dry-run ";
                        }
                        else {
                          uint64_t v68 = "";
                        }
                        nw_endpoint_t v69 = nw_endpoint_handler_copy_endpoint(v52);
                        unsigned int v70 = nw_endpoint_get_logging_description(v69);
                        __int16 v71 = v52 + 21;
                        uint64_t v72 = *((unsigned int *)v52 + 30);
                        v168 = v70;
                        if (v72 > 5) {
                          __int16 v73 = "unknown-state";
                        }
                        else {
                          __int16 v73 = off_1E523FB38[v72];
                        }
                        id v165 = v73;
                        nw_endpoint_t v83 = v52;
                        id v84 = v83;
                        nw_endpoint_t v85 = "path";
                        switch(*((_DWORD *)v174 + 29))
                        {
                          case 0:
                            break;
                          case 1:
                            nw_endpoint_t v85 = "resolver";
                            break;
                          case 2:
                            nw_endpoint_t v85 = nw_endpoint_flow_mode_string(*(void **)&v83[62]._os_unfair_lock_opaque);
                            break;
                          case 3:
                            nw_endpoint_t v85 = "proxy";
                            break;
                          case 4:
                            nw_endpoint_t v85 = "fallback";
                            break;
                          case 5:
                            nw_endpoint_t v85 = "transform";
                            break;
                          default:
                            nw_endpoint_t v85 = "unknown-mode";
                            break;
                        }

                        __int16 v92 = v84 + 28;
                        BOOL v93 = v84;
                        os_unfair_lock_lock(v84 + 28);
                        id v94 = v93[8];
                        os_unfair_lock_unlock(v92);

                        *(_DWORD *)buf = 136448258;
                        os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                        __int16 v180 = 2082;
                        os_log_type_t v181 = v71;
                        __int16 v182 = 2082;
                        uint64_t v183 = v68;
                        __int16 v184 = 2082;
                        v185 = (void *)v168;
                        __int16 v186 = 2082;
                        id v187 = v165;
                        __int16 v188 = 2082;
                        os_log_type_t v189 = v85;
                        __int16 v190 = 2114;
                        id v191 = v94;
                        __int16 v192 = 2114;
                        os_log_type_t v193 = v35;
                        __int16 v194 = 2114;
                        v195 = v38;
                        _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{public}@ due to non-viable current path %{public}@", buf, 0x5Cu);

                        uint64_t v43 = 1;
                      }
                      uint64_t v56 = v67;
                      goto LABEL_122;
                    }
                  }
                  goto LABEL_191;
                }
                if (v18)
                {
                  int minimize_logging = nw_endpoint_handler_get_minimize_logging(v174);
                  char logging_disabled = nw_endpoint_handler_get_logging_disabled(v174);
                  if (minimize_logging)
                  {
                    if ((logging_disabled & 1) == 0)
                    {
                      if (__nwlog_connection_log::onceToken != -1) {
                        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                      }
                      uint64_t v56 = (id)gconnectionLogObj;
                      if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                      {
                        uint64_t v149 = nw_endpoint_handler_get_id_string(v174);
                        os_log_type_t v150 = nw_endpoint_handler_dry_run_string(v174);
                        nw_endpoint_t v151 = nw_endpoint_handler_copy_endpoint(v174);
                        os_log_type_t v152 = nw_endpoint_get_logging_description(v151);
                        long long v153 = nw_endpoint_handler_state_string(v174);
                        long long v154 = nw_endpoint_handler_mode_string(v174);
                        id v155 = nw_endpoint_handler_copy_current_path(v174);
                        *(_DWORD *)buf = 136448002;
                        os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                        __int16 v180 = 2082;
                        os_log_type_t v181 = (void *)v149;
                        __int16 v182 = 2082;
                        uint64_t v183 = v150;
                        __int16 v184 = 2082;
                        v185 = (void *)v152;
                        __int16 v186 = 2082;
                        id v187 = v153;
                        __int16 v188 = 2082;
                        os_log_type_t v189 = v154;
                        __int16 v190 = 2114;
                        id v191 = v155;
                        __int16 v192 = 2114;
                        os_log_type_t v193 = v35;
                        _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{public}@ due non-reusable flow", buf, 0x52u);
                      }
                      goto LABEL_107;
                    }
                  }
                  else if ((logging_disabled & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v43 = 1;
                    uint64_t v56 = (id)gconnectionLogObj;
                    if (!os_log_type_enabled(v56, OS_LOG_TYPE_INFO)) {
                      goto LABEL_122;
                    }
                    BOOL v76 = nw_endpoint_handler_get_id_string(v174);
                    unsigned int v77 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v78 = nw_endpoint_handler_copy_endpoint(v174);
                    unsigned int v79 = nw_endpoint_get_logging_description(v78);
                    __int16 v80 = nw_endpoint_handler_state_string(v174);
                    uint64_t v81 = nw_endpoint_handler_mode_string(v174);
                    id v82 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448002;
                    os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    os_log_type_t v181 = (void *)v76;
                    __int16 v182 = 2082;
                    uint64_t v183 = v77;
                    __int16 v184 = 2082;
                    v185 = (void *)v79;
                    __int16 v186 = 2082;
                    id v187 = v80;
                    __int16 v188 = 2082;
                    os_log_type_t v189 = v81;
                    __int16 v190 = 2114;
                    id v191 = v82;
                    __int16 v192 = 2114;
                    os_log_type_t v193 = v35;
                    _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{public}@ due non-reusable flow", buf, 0x52u);

                    goto LABEL_107;
                  }
LABEL_191:
                  uint64_t v43 = 1;
                  goto LABEL_123;
                }
                if (v20) {
                  unsigned __int8 v89 = nw_path_copy_interface(v49);
                }
                else {
                  unsigned __int8 v89 = nw_path_copy_connected_interface(v172);
                }
                os_log_type_t v90 = v89;
                int v91 = v49;
                uint64_t v43 = 0;
                if (nw_path_is_tunnelled(v49))
                {
LABEL_156:
                  uint64_t v56 = v90;
                  goto LABEL_122;
                }
                uint64_t v56 = v90;
                if (!v90) {
                  goto LABEL_122;
                }
                if (nw_interface_get_type(v90) == nw_interface_type_loopback)
                {
                  uint64_t v43 = 0;
                  goto LABEL_122;
                }
                int v97 = (int)v90[1].isa;
                if (v97 == nw_path_get_interface_index(v35))
                {
                  uint64_t v43 = 0;
                  uint64_t v56 = v90;
                  goto LABEL_122;
                }
                __int16 v98 = nw_path_copy_endpoint(v91);
                unsigned int v99 = nw_path_copy_endpoint(v35);
                uint64_t v164 = v98;
                v166 = v99;
                if (v98) {
                  nw_endpoint_type_t v100 = nw_endpoint_get_type(v98);
                }
                else {
                  nw_endpoint_type_t v100 = nw_endpoint_type_invalid;
                }
                id v101 = v174;
                if (v99) {
                  LODWORD(v99) = nw_endpoint_get_type(v99);
                }
                id v169 = nw_endpoint_handler_copy_current_path(v170);
                if (v100 != v99
                  || nw_path_may_span_multiple_interfaces(v169)
                  && nw_endpoint_handler_has_matching_handler(v170, v171))
                {
                  if (nw_endpoint_handler_get_logging_disabled(v174))
                  {
                    uint64_t v43 = 0;
                    goto LABEL_155;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  __int16 v102 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                  {
                    int v103 = nw_endpoint_handler_get_id_string(v174);
                    BOOL v104 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v105 = nw_endpoint_handler_copy_endpoint(v174);
                    uint64_t v106 = nw_endpoint_get_logging_description(v105);
                    os_log_type_t v107 = nw_endpoint_handler_state_string(v174);
                    int v108 = nw_endpoint_handler_mode_string(v174);
                    id v109 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448258;
                    os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    os_log_type_t v181 = (void *)v103;
                    __int16 v182 = 2082;
                    uint64_t v183 = v104;
                    __int16 v184 = 2082;
                    v185 = (void *)v106;
                    __int16 v186 = 2082;
                    id v187 = v107;
                    __int16 v188 = 2082;
                    os_log_type_t v189 = v108;
                    __int16 v190 = 2114;
                    id v191 = v109;
                    __int16 v192 = 2114;
                    os_log_type_t v193 = v166;
                    __int16 v194 = 2114;
                    v195 = v164;
                    _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] suppressing better path notification (comparing %{public}@ to %{public}@)", buf, 0x5Cu);
                  }
                  uint64_t v43 = 0;
LABEL_154:

LABEL_155:
                  goto LABEL_156;
                }
                int v110 = nw_endpoint_handler_get_minimize_logging(v174);
                char v111 = nw_endpoint_handler_get_logging_disabled(v174);
                if (v110)
                {
                  if (v111) {
                    goto LABEL_148;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  BOOL v112 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v112, OS_LOG_TYPE_DEBUG))
                  {
                    loga = nw_endpoint_handler_get_id_string(v174);
                    BOOL v156 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v157 = nw_endpoint_handler_copy_endpoint(v174);
                    os_log_type_t v158 = nw_endpoint_get_logging_description(v157);
                    int v159 = nw_endpoint_handler_state_string(v174);
                    nw_endpoint_t v160 = nw_endpoint_handler_mode_string(v174);
                    id v161 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448258;
                    os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    os_log_type_t v181 = (void *)loga;
                    __int16 v182 = 2082;
                    uint64_t v183 = v156;
                    __int16 v184 = 2082;
                    v185 = (void *)v158;
                    __int16 v186 = 2082;
                    id v187 = v159;
                    __int16 v188 = 2082;
                    os_log_type_t v189 = v160;
                    __int16 v190 = 2114;
                    id v191 = v161;
                    __int16 v192 = 2114;
                    os_log_type_t v193 = v35;
                    __int16 v194 = 2114;
                    v195 = v91;
                    _os_log_impl(&dword_1830D4000, v112, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{public}@ preferred to path %{public}@", buf, 0x5Cu);
                  }
                }
                else
                {
                  if (v111)
                  {
LABEL_148:
                    if (nw_endpoint_handler_get_logging_disabled(v101))
                    {
                      uint64_t v43 = 1;
                      goto LABEL_155;
                    }
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    __int16 v102 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v102, OS_LOG_TYPE_DEBUG))
                    {
                      __int16 v120 = nw_endpoint_handler_get_id_string(v101);
                      __int16 v121 = nw_endpoint_handler_dry_run_string(v101);
                      nw_endpoint_t v122 = nw_endpoint_handler_copy_endpoint(v101);
                      nw_endpoint_t v123 = nw_endpoint_get_logging_description(v122);
                      __int16 v124 = nw_endpoint_handler_state_string(v101);
                      int v125 = nw_endpoint_handler_mode_string(v101);
                      id v126 = nw_endpoint_handler_copy_current_path(v101);
                      *(_DWORD *)buf = 136448258;
                      os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                      __int16 v180 = 2082;
                      os_log_type_t v181 = (void *)v120;
                      __int16 v182 = 2082;
                      uint64_t v183 = v121;
                      __int16 v184 = 2082;
                      v185 = (void *)v123;
                      __int16 v186 = 2082;
                      id v187 = v124;
                      __int16 v188 = 2082;
                      os_log_type_t v189 = v125;
                      __int16 v190 = 2114;
                      id v191 = v126;
                      __int16 v192 = 2114;
                      os_log_type_t v193 = v166;
                      __int16 v194 = 2114;
                      v195 = v164;
                      _os_log_impl(&dword_1830D4000, v102, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] comparing %{public}@ to %{public}@", buf, 0x5Cu);
                    }
                    uint64_t v43 = 1;
                    goto LABEL_154;
                  }
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  BOOL v112 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v112, OS_LOG_TYPE_INFO))
                  {
                    unsigned int log = v112;
                    id v113 = nw_endpoint_handler_get_id_string(v174);
                    uint64_t v114 = nw_endpoint_handler_dry_run_string(v174);
                    nw_endpoint_t v115 = nw_endpoint_handler_copy_endpoint(v174);
                    int v116 = nw_endpoint_get_logging_description(v115);
                    uint64_t v117 = nw_endpoint_handler_state_string(v174);
                    __int16 v118 = nw_endpoint_handler_mode_string(v174);
                    id v119 = nw_endpoint_handler_copy_current_path(v174);
                    *(_DWORD *)buf = 136448258;
                    os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                    __int16 v180 = 2082;
                    os_log_type_t v181 = (void *)v113;
                    __int16 v182 = 2082;
                    uint64_t v183 = v114;
                    __int16 v184 = 2082;
                    v185 = (void *)v116;
                    __int16 v186 = 2082;
                    id v187 = v117;
                    __int16 v188 = 2082;
                    os_log_type_t v189 = v118;
                    __int16 v190 = 2114;
                    id v191 = v119;
                    __int16 v192 = 2114;
                    os_log_type_t v193 = v35;
                    __int16 v194 = 2114;
                    v195 = v91;
                    _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] better path %{public}@ preferred to path %{public}@", buf, 0x5Cu);

                    BOOL v112 = log;
                  }
                }

                id v101 = v174;
                goto LABEL_148;
              }
              int isa_high = HIDWORD(v37[33].isa);

              if (!isa_high) {
                goto LABEL_64;
              }
            }
LABEL_54:
            os_log_type_t v40 = v175;
            int v41 = (int)v40[47].isa;

            if (v41 == 3) {
              char v42 = is_viable;
            }
            else {
              char v42 = 1;
            }
            if ((v42 & 1) == 0)
            {
              os_log_type_t v44 = v7;
              BOOL v45 = v44;
              os_log_type_t v46 = (void *)*((void *)v44 + 4);
              if (v46)
              {
                char v47 = v46;
                BOOL v48 = (v47[12] & 0x4000000000) == 0;

                if (!v48)
                {
                  if ((nw_endpoint_handler_get_logging_disabled(v45) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v56 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v56, OS_LOG_TYPE_DEBUG))
                    {
                      id v134 = nw_endpoint_handler_get_id_string(v45);
                      __int16 v135 = nw_endpoint_handler_dry_run_string(v45);
                      nw_endpoint_t v136 = nw_endpoint_handler_copy_endpoint(v45);
                      uint64_t v137 = nw_endpoint_get_logging_description(v136);
                      v138 = nw_endpoint_handler_state_string(v45);
                      os_log_type_t v139 = nw_endpoint_handler_mode_string(v45);
                      id v140 = nw_endpoint_handler_copy_current_path(v45);
                      *(_DWORD *)buf = 136448258;
                      os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
                      __int16 v180 = 2082;
                      os_log_type_t v181 = (void *)v134;
                      __int16 v182 = 2082;
                      uint64_t v183 = v135;
                      __int16 v184 = 2082;
                      v185 = (void *)v137;
                      __int16 v186 = 2082;
                      id v187 = v138;
                      __int16 v188 = 2082;
                      os_log_type_t v189 = v139;
                      __int16 v190 = 2114;
                      id v191 = v140;
                      __int16 v192 = 2114;
                      os_log_type_t v193 = v173;
                      __int16 v194 = 2114;
                      v195 = v40;
                      _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] satisfiable path %{public}@ preferred to non-viable path %{public}@", buf, 0x5Cu);
                    }
                    goto LABEL_107;
                  }
                  goto LABEL_191;
                }
                if ((*((unsigned char *)v45 + 268) & 0x20) != 0) {
                  goto LABEL_191;
                }
              }
              else
              {

                if ((*((unsigned char *)v45 + 268) & 0x20) != 0) {
                  goto LABEL_191;
                }
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v43 = 1;
              uint64_t v56 = (id)gconnectionLogObj;
              if (!os_log_type_enabled(v56, OS_LOG_TYPE_INFO)) {
                goto LABEL_122;
              }
              if (*((unsigned char *)v45 + 268)) {
                unsigned int v57 = "dry-run ";
              }
              else {
                unsigned int v57 = "";
              }
              nw_endpoint_t v58 = nw_endpoint_handler_copy_endpoint(v45);
              BOOL v59 = nw_endpoint_get_logging_description(v58);
              os_log_type_t v60 = v45 + 21;
              uint64_t v61 = *((unsigned int *)v45 + 30);
              uint64_t v62 = v59;
              if (v61 > 5) {
                __int16 v63 = "unknown-state";
              }
              else {
                __int16 v63 = off_1E523FB38[v61];
              }
              __int16 v167 = v63;
              uint64_t v64 = v45;
              BOOL v65 = v64;
              int v66 = "path";
              switch(*((_DWORD *)v174 + 29))
              {
                case 0:
                  break;
                case 1:
                  int v66 = "resolver";
                  break;
                case 2:
                  int v66 = nw_endpoint_flow_mode_string(*(void **)&v64[62]._os_unfair_lock_opaque);
                  break;
                case 3:
                  int v66 = "proxy";
                  break;
                case 4:
                  int v66 = "fallback";
                  break;
                case 5:
                  int v66 = "transform";
                  break;
                default:
                  int v66 = "unknown-mode";
                  break;
              }

              int v86 = v65 + 28;
              unsigned __int16 v87 = v65;
              os_unfair_lock_lock(v65 + 28);
              id v88 = v87[8];
              os_unfair_lock_unlock(v86);

              *(_DWORD *)buf = 136448258;
              os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
              __int16 v180 = 2082;
              os_log_type_t v181 = v60;
              __int16 v182 = 2082;
              uint64_t v183 = v57;
              __int16 v184 = 2082;
              v185 = (void *)v62;
              __int16 v186 = 2082;
              id v187 = v167;
              __int16 v188 = 2082;
              os_log_type_t v189 = v66;
              __int16 v190 = 2114;
              id v191 = v88;
              __int16 v192 = 2114;
              os_log_type_t v193 = v173;
              __int16 v194 = 2114;
              v195 = v40;
              _os_log_impl(&dword_1830D4000, v56, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] satisfiable path %{public}@ preferred to non-viable path %{public}@", buf, 0x5Cu);

              goto LABEL_107;
            }
LABEL_58:
            uint64_t v43 = 0;
LABEL_123:

            os_log_type_t v95 = v173;
            goto LABEL_124;
          }
LABEL_53:
          if (!v19) {
            goto LABEL_58;
          }
          goto LABEL_54;
        }
LABEL_45:
        free(v23);
        goto LABEL_46;
      }
    }
    else
    {
      id v8 = v7;
      if (v9) {
        goto LABEL_4;
      }
    }
    uint64_t v9 = v7;
    goto LABEL_4;
  }
  os_log_type_t v95 = v10;
  uint64_t v170 = v8;
  __int16 v171 = v9;
  id v127 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
  id v128 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v176 = 0;
  if (__nwlog_fault(v128, &type, &v176))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      __int16 v129 = __nwlog_obj();
      os_log_type_t v130 = type;
      if (os_log_type_enabled(v129, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
        _os_log_impl(&dword_1830D4000, v129, v130, "%{public}s called with null endpoint_handler", buf, 0xCu);
      }
    }
    else if (v176)
    {
      id v131 = (char *)__nw_create_backtrace_string();
      __int16 v129 = __nwlog_obj();
      os_log_type_t v132 = type;
      BOOL v133 = os_log_type_enabled(v129, type);
      if (v131)
      {
        if (v133)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
          __int16 v180 = 2082;
          os_log_type_t v181 = v131;
          _os_log_impl(&dword_1830D4000, v129, v132, "%{public}s called with null endpoint_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v131);
        goto LABEL_183;
      }
      if (v133)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
        _os_log_impl(&dword_1830D4000, v129, v132, "%{public}s called with null endpoint_handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      __int16 v129 = __nwlog_obj();
      os_log_type_t v141 = type;
      if (os_log_type_enabled(v129, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v179 = "nw_endpoint_handler_get_alternate_path_state";
        _os_log_impl(&dword_1830D4000, v129, v141, "%{public}s called with null endpoint_handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_183:
  if (v128) {
    free(v128);
  }
  uint64_t v43 = 0;
LABEL_124:

  return v43;
}

void sub_1831BFDC8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15, void *a16, void *a17, void *a18, void *a19, void *a20)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_handler_is_viable(void *a1)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    char v22 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v31 = "nw_endpoint_handler_is_viable";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (!__nwlog_fault(v10, &type, &v28)) {
      goto LABEL_41;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v11 = __nwlog_obj();
      os_log_type_t v23 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_endpoint_handler_is_viable";
        _os_log_impl(&dword_1830D4000, v11, v23, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if (v28)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v11 = __nwlog_obj();
      os_log_type_t v25 = type;
      BOOL v26 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v26)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v31 = "nw_endpoint_handler_is_viable";
          __int16 v32 = 2082;
          id v33 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_41;
      }
      if (v26)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_endpoint_handler_is_viable";
        _os_log_impl(&dword_1830D4000, v11, v25, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v11 = __nwlog_obj();
      os_log_type_t v27 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v31 = "nw_endpoint_handler_is_viable";
        _os_log_impl(&dword_1830D4000, v11, v27, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_40:

    goto LABEL_41;
  }
  uint64_t v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v8 = (id)gLogObj;
    if (mode > 5) {
      uint64_t v9 = "unknown-mode";
    }
    else {
      uint64_t v9 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446722;
    uint64_t v31 = "nw_endpoint_handler_is_viable";
    __int16 v32 = 2082;
    id v33 = (void *)v9;
    __int16 v34 = 2082;
    unsigned int v35 = "flow";
    id v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v10, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5) {
            id v13 = "unknown-mode";
          }
          else {
            id v13 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v31 = "nw_endpoint_handler_is_viable";
          __int16 v32 = 2082;
          id v33 = (void *)v13;
          __int16 v34 = 2082;
          unsigned int v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v28)
      {
        int v14 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v15 = type;
        BOOL v16 = os_log_type_enabled(v11, type);
        if (v14)
        {
          if (v16)
          {
            if (mode > 5) {
              uint64_t v17 = "unknown-mode";
            }
            else {
              uint64_t v17 = off_1E523FB08[mode];
            }
            *(_DWORD *)buf = 136446978;
            uint64_t v31 = "nw_endpoint_handler_is_viable";
            __int16 v32 = 2082;
            id v33 = (void *)v17;
            __int16 v34 = 2082;
            unsigned int v35 = "flow";
            __int16 v36 = 2082;
            os_log_type_t v37 = v14;
            _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v14);
          if (!v10) {
            goto LABEL_43;
          }
          goto LABEL_42;
        }
        if (v16)
        {
          if (mode > 5) {
            char v20 = "unknown-mode";
          }
          else {
            char v20 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v31 = "nw_endpoint_handler_is_viable";
          __int16 v32 = 2082;
          id v33 = (void *)v20;
          __int16 v34 = 2082;
          unsigned int v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v15, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        id v11 = (id)gLogObj;
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v11, type))
        {
          if (mode > 5) {
            id v19 = "unknown-mode";
          }
          else {
            id v19 = off_1E523FB08[mode];
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v31 = "nw_endpoint_handler_is_viable";
          __int16 v32 = 2082;
          id v33 = (void *)v19;
          __int16 v34 = 2082;
          unsigned int v35 = "flow";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
      goto LABEL_40;
    }
LABEL_41:
    if (!v10)
    {
LABEL_43:
      uint64_t is_viable = 0;
      goto LABEL_44;
    }
LABEL_42:
    free(v10);
    goto LABEL_43;
  }
  id v5 = nw_endpoint_handler_copy_flow(v3);
  os_unfair_lock_lock((os_unfair_lock_t)v5 + 220);
  unsigned int v6 = *((unsigned __int8 *)v5 + 33);
  if (*((unsigned char *)v5 + 32) & 2 | v6 & 1)
  {
    uint64_t is_viable = (v6 >> 1) & 1;
  }
  else if (*((void *)v5 + 117))
  {
    uint64_t is_viable = nw_endpoint_handler_is_viable();
  }
  else
  {
    uint64_t is_viable = 0;
  }
  os_unfair_lock_unlock((os_unfair_lock_t)v5 + 220);

LABEL_44:
  return is_viable;
}

void sub_1831C05F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_interface_type_t nw_interface_get_type(nw_interface_t interface)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_interface_t v1 = interface;
  nw_interface_t v2 = v1;
  if (v1)
  {
    nw_interface_type_t isa = (nw_interface_type_t)v1[12].isa;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_interface_get_type";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_get_type";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null interface", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_interface_get_type";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null interface, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_get_type";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null interface, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_interface_get_type";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null interface, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  nw_interface_type_t isa = nw_interface_type_other;
LABEL_3:

  return isa;
}

BOOL nw_path_is_tunnelled(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    BOOL v3 = *((_DWORD *)v1 + 66) == 6;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v16 = "nw_path_is_tunnelled";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_is_tunnelled";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v16 = "nw_path_is_tunnelled";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_is_tunnelled";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v16 = "nw_path_is_tunnelled";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:

  return v3;
}

BOOL ___ZL25nw_path_snapshot_fallbackP18NWConcrete_nw_path_block_invoke(uint64_t a1, uint64_t a2, void *a3)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v4 = a3;
  id v5 = v4;
  *(void *)size_t length = 0;
  if (!v4
    || (data = (unsigned int *)xpc_dictionary_get_data(v4, "data", (size_t *)length)) == 0
    || *(void *)length < 0xD8uLL
    || (id v7 = data, *(void *)length != data[53] + 216)
    || (data[52] & 2) == 0
    || (nw_path_get_interface_index(*(void **)(a1 + 32)),
        (*(unsigned char *)(*(void *)(*(void *)(a1 + 40) + 8) + 24) = ne_session_agent_get_advisory()) == 0)
    || !*(_DWORD *)(*(void *)(*(void *)(a1 + 80) + 8) + 24)
    && (!*(void *)(*(void *)(*(void *)(a1 + 88) + 8) + 24)
     || !*(void *)(*(void *)(*(void *)(a1 + 96) + 8) + 24)))
  {
    uint64_t v9 = 1;
    goto LABEL_13;
  }
  os_log_type_t v8 = malloc_type_calloc(1uLL, 0x10uLL, 0xEAFB8F1AuLL);
  if (v8)
  {
LABEL_9:
    *(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = v8;
    *(_OWORD *)*(void *)(*(void *)(*(void *)(a1 + 104) + 8) + 24) = *v7;
    uint64_t v9 = 0;
    *(_DWORD *)(*(void *)(*(void *)(a1 + 112) + 8) + 24) = xpc_dictionary_get_uint64(v5, "generation");
LABEL_13:

    return v9;
  }
  BOOL v11 = __nwlog_obj();
  os_log_type_enabled(v11, OS_LOG_TYPE_ERROR);
  *(_DWORD *)size_t length = 136446722;
  *(void *)&length[4] = "strict_calloc";
  __int16 v14 = 2048;
  uint64_t v15 = 1;
  __int16 v16 = 2048;
  uint64_t v17 = 16;
  os_log_type_t v12 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v12);
  if (!result)
  {
    free(v12);
    os_log_type_t v8 = 0;
    goto LABEL_9;
  }
  __break(1u);
  return result;
}

void sub_1831C0DD8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_path_get_interface_index(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = (unsigned int *)v1;
  if (!v1)
  {
    id v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v16 = "nw_path_get_interface_index";
    id v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v13 = 0;
    if (__nwlog_fault(v5, &type, &v13))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v16 = "nw_path_get_interface_index";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null path", buf, 0xCu);
        }
      }
      else if (v13)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v16 = "nw_path_get_interface_index";
            __int16 v17 = 2082;
            uint64_t v18 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v16 = "nw_path_get_interface_index";
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null path, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v16 = "nw_path_get_interface_index";
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v5) {
      free(v5);
    }
    goto LABEL_22;
  }
  if (!nw_path_network_is_satisfied_update_reason(v1, 0))
  {
LABEL_22:
    uint64_t v3 = 0;
    goto LABEL_23;
  }
  uint64_t v3 = v2[80];
LABEL_23:

  return v3;
}

void sub_1831C1094(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_settings_setup_atfork_inner(void)
{
  return pthread_atfork((void (*)(void))nw_settings_prepare_fork, nw_settings_parent_has_forked, nw_settings_child_has_forked);
}

BOOL nw_endpoint_handler_should_reset_for_fallback(NWConcrete_nw_endpoint_handler *a1)
{
  id v1 = a1;
  nw_interface_t v2 = v1;
  BOOL v5 = !v1->parent_handler
    && !nw_endpoint_handler_has_fallback_children(v1)
    && (*((unsigned char *)v2 + 268) & 0x10) == 0
    && v2->state == 2
    && (int mode = v2->mode, (mode | 4) != 4)
    && (*((unsigned char *)v2 + 268) & 1) == 0
    && (mode != 2
     || (mode_handler = v2->mode_handler) == 0
     || (nw_endpoint_flow_should_ignore_path_result(mode_handler) & 1) == 0)
    && nw_path_should_fallback(v2->current_path, 0);

  return v5;
}

void sub_1831C1278(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_endpoint_flow_should_ignore_path_result(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = (v1[34] >> 6) & 1;
    goto LABEL_3;
  }
  BOOL v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v16 = "nw_endpoint_flow_should_ignore_path_result";
  unsigned int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_endpoint_flow_should_ignore_path_result";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null endpoint_flow", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v16 = "nw_endpoint_flow_should_ignore_path_result";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_endpoint_flow_should_ignore_path_result";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v16 = "nw_endpoint_flow_should_ignore_path_result";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

BOOL nw_endpoint_handler_has_fallback_children(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (!v1)
  {
    id v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
    BOOL v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v14 = 0;
    if (__nwlog_fault(v5, &type, &v14))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v14)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v9 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_20;
        }
        if (v10)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unsigned int v6 = __nwlog_obj();
        os_log_type_t v11 = type;
        if (os_log_type_enabled(v6, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_has_fallback_children";
          _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_20:
    if (v5) {
      free(v5);
    }
    goto LABEL_22;
  }
  if ((objc_opt_respondsToSelector() & 1) == 0)
  {
LABEL_22:
    BOOL v3 = 0;
    goto LABEL_23;
  }
  *(void *)buf = 0;
  *(void *)&uint8_t buf[8] = buf;
  *(void *)&buf[16] = 0x2020000000;
  char v17 = 0;
  mode_handler = v1->mode_handler;
  v13[0] = MEMORY[0x1E4F143A8];
  v13[1] = 3221225472;
  v13[2] = ___ZL41nw_endpoint_handler_has_fallback_childrenP30NWConcrete_nw_endpoint_handler_block_invoke;
  v13[3] = &unk_1E523FA90;
  void v13[4] = buf;
  [(NWConcrete_nw_endpoint_mode_handler *)mode_handler applyWithHandler:v1 toChildren:v13];
  BOOL v3 = *(unsigned char *)(*(void *)&buf[8] + 24) != 0;
  _Block_object_dispose(buf, 8);
LABEL_23:

  return v3;
}

void sub_1831C1854(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

void sub_1831C20E4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_parameters_get_sensitive_redacted_for_endpoint(void *a1, void *a2)
{
  id v3 = a1;
  id v4 = a2;
  if (!v3) {
    goto LABEL_18;
  }
  BOOL v5 = v3;
  unsigned int v6 = *(id *)(v5[13] + 136);
  os_log_type_t v7 = v6;
  if (v6)
  {
    int v8 = v6[31];
    if ((v8 - 2) >= 2)
    {
      if (v8 == 1)
      {

        goto LABEL_10;
      }

LABEL_17:
      goto LABEL_18;
    }
  }
  if (nwlog_get_sensitive_redacted::onceToken != -1) {
    dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
  }
  int v9 = nwlog_get_sensitive_redacted::sensitiveRedacted;

  if (v9) {
    goto LABEL_17;
  }
LABEL_10:
  if (*(unsigned __int8 *)(v5[13] + 102) - 1 < 2)
  {
    if (nwlog_get_sensitive_redacted::onceToken != -1) {
      dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
    }
    int v10 = nwlog_get_sensitive_redacted::sensitiveRedacted;

    if (!v10)
    {
LABEL_20:
      uint64_t v11 = 0;
      goto LABEL_22;
    }
LABEL_18:
    if (!v4 || !nw_endpoint_get_do_not_redact(v4))
    {
      uint64_t v11 = 1;
      goto LABEL_22;
    }
    goto LABEL_20;
  }

  uint64_t v11 = 0;
LABEL_22:

  return v11;
}

void sub_1831C2240(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1831C2470(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_get_do_not_redact(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    if ((*((unsigned char *)v1 + 231) & 0x20) != 0)
    {
      BOOL v6 = 1;
    }
    else
    {
      id v3 = v1[1];
      id v4 = v3;
      if (v3 && (int v5 = *((_DWORD *)v3 + 31), (v5 - 2) >= 2))
      {
        BOOL v6 = v5 == 1;
      }
      else
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1) {
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
        }
        BOOL v6 = nwlog_get_sensitive_redacted::sensitiveRedacted == 0;
      }
    }
    goto LABEL_11;
  }
  int v8 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v19 = "nw_endpoint_get_do_not_redact";
  int v9 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v9, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v10 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_endpoint_get_do_not_redact";
        _os_log_impl(&dword_1830D4000, v10, v11, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v10 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v10, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v19 = "nw_endpoint_get_do_not_redact";
          __int16 v20 = 2082;
          id v21 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_28;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_endpoint_get_do_not_redact";
        _os_log_impl(&dword_1830D4000, v10, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v10 = __nwlog_obj();
      os_log_type_t v15 = type;
      if (os_log_type_enabled(v10, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v19 = "nw_endpoint_get_do_not_redact";
        _os_log_impl(&dword_1830D4000, v10, v15, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_28:
  if (v9) {
    free(v9);
  }
  BOOL v6 = 0;
LABEL_11:

  return v6;
}

uint64_t nw_protocol_implementation_connect(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v178 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    char handle = a1->handle;
    p_output_handler = &a1[1].output_handler;
    if (handle != &nw_protocol_ref_counted_handle) {
      p_output_handler = 0;
    }
    BOOL v6 = p_output_handler;
    os_log_type_t v7 = v6;
    if (handle != &nw_protocol_ref_counted_handle)
    {
      BOOL v76 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v169 = "nw_protocol_implementation_connect";
      int v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v52, type, v163)) {
        goto LABEL_152;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v77 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v77, "%{public}s called with null instance", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v107 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v107, "%{public}s called with null instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_151;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v53 = __nwlog_obj();
      os_log_type_t v87 = type[0];
      BOOL v88 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v88)
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v87, "%{public}s called with null instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v88)
      {
        *(_DWORD *)buf = 136446466;
        id v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        __int16 v171 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v53, v87, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_143;
    }
    uint64_t v8 = *((void *)v6 + 1);
    if (!v8)
    {
      nw_endpoint_t v78 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v169 = "nw_protocol_implementation_connect";
      int v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v52, type, v163)) {
        goto LABEL_152;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v79 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v79, "%{public}s called with null instance->parent_definition", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v108 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v108, "%{public}s called with null instance->parent_definition, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_151;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v53 = __nwlog_obj();
      os_log_type_t v89 = type[0];
      BOOL v90 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v90)
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v89, "%{public}s called with null instance->parent_definition, no backtrace", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v90)
      {
        *(_DWORD *)buf = 136446466;
        id v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        __int16 v171 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v53, v89, "%{public}s called with null instance->parent_definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_143;
    }
    if (!*(void *)(v8 + 80))
    {
      __int16 v80 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v169 = "nw_protocol_implementation_connect";
      int v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v52, type, v163)) {
        goto LABEL_152;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v81 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v81, "%{public}s called with null instance->parent_definition->extended_state", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v109 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v109, "%{public}s called with null instance->parent_definition->extended_state, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_151;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v53 = __nwlog_obj();
      os_log_type_t v91 = type[0];
      BOOL v92 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v92)
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v91, "%{public}s called with null instance->parent_definition->extended_state, no backtrace", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v92)
      {
        *(_DWORD *)buf = 136446466;
        id v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        __int16 v171 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v53, v91, "%{public}s called with null instance->parent_definition->extended_state, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_143;
    }
    if (!a2)
    {
      id v82 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v169 = "nw_protocol_implementation_connect";
      int v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v52, type, v163)) {
        goto LABEL_152;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v83 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v83, "%{public}s called with null input_protocol", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v110 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v110, "%{public}s called with null input_protocol, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_151;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v53 = __nwlog_obj();
      os_log_type_t v93 = type[0];
      BOOL v94 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v94)
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v93, "%{public}s called with null input_protocol, no backtrace", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v94)
      {
        *(_DWORD *)buf = 136446466;
        id v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        __int16 v171 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v53, v93, "%{public}s called with null input_protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_143;
    }
    if (a1->output_handler != a1)
    {
      if ((v6[402] & 0x20) == 0)
      {
        if ((v6[405] & 0x80000000) == 0 && gLogDatapath)
        {
          os_log_type_t v95 = __nwlog_obj();
          if (os_log_type_enabled(v95, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)buf = 136446722;
            id v169 = "nw_protocol_implementation_connect";
            __int16 v170 = 2082;
            __int16 v171 = v7 + 407;
            __int16 v172 = 2080;
            id v173 = (nw_protocol *)" ";
            _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sConnect", buf, 0x20u);
          }

          uint64_t v8 = *((void *)v7 + 1);
        }
        if (*(_DWORD *)(v8 + 64) == 3)
        {
          output_handler_context = a2->output_handler_context;
          int v10 = v7[405];
          if (output_handler_context)
          {
            if ((v10 & 0x80000000) == 0 && gLogDatapath)
            {
              nw_endpoint_t v123 = __nwlog_obj();
              if (os_log_type_enabled(v123, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v124 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v7, (uint64_t)a2);
                *(_DWORD *)buf = 136446978;
                id v169 = "nw_protocol_implementation_connect";
                __int16 v170 = 2082;
                __int16 v171 = v7 + 407;
                __int16 v172 = 2080;
                id v173 = (nw_protocol *)" ";
                __int16 v174 = 2048;
                __int16 v175 = (nw_protocol *)v124;
                _os_log_impl(&dword_1830D4000, v123, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sRequested connect from flow %llx", buf, 0x2Au);
              }
            }
            output_handler_context[42] |= 4u;
            output_handler = a1->output_handler;
            if (output_handler)
            {
              os_log_type_t v12 = output_handler->handle;
              if (v12 == &nw_protocol_ref_counted_handle)
              {
                callbacks = output_handler[1].callbacks;
                if (callbacks) {
                  output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
                }
                char v13 = -1;
              }
              else
              {
                char v13 = 0;
              }
              *(void *)os_log_type_t type = output_handler;
              char v167 = v13;
              int v41 = a1->handle;
              if (v41 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v43 = a1[1].callbacks;
                if (v43) {
                  a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v43->add_input_handler + 1);
                }
                char v42 = -1;
              }
              else
              {
                char v42 = 0;
              }
              *(void *)id v163 = a1;
              char v164 = v42;
              os_log_type_t v44 = output_handler->callbacks;
              if (v44)
              {
                connect = (void (*)(nw_protocol *, nw_protocol *))v44->connect;
                if (connect)
                {
                  connect(output_handler, a1);
LABEL_90:
                  if (v41 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)v163);
                  }
                  if (v12 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
LABEL_94:
                  if (output_handler_context == a2->output_handler_context)
                  {
                    __int16 v49 = output_handler_context[42];
                    if ((v49 & 0x20) != 0)
                    {
                      if ((v7[405] & 0x80000000) == 0 && gLogDatapath)
                      {
                        nw_endpoint_t v151 = __nwlog_obj();
                        if (os_log_type_enabled(v151, OS_LOG_TYPE_DEBUG))
                        {
                          *(_DWORD *)buf = 136446722;
                          id v169 = "nw_protocol_implementation_connect";
                          __int16 v170 = 2082;
                          __int16 v171 = v7 + 407;
                          __int16 v172 = 2080;
                          id v173 = (nw_protocol *)" ";
                          _os_log_impl(&dword_1830D4000, v151, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDelivering deferred connected event", buf, 0x20u);
                        }

                        __int16 v49 = output_handler_context[42];
                      }
                      output_handler_context[42] = v49 & 0xFFDF;
                      unint64_t v50 = nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v7, (uint64_t)a2);
                      nw_protocol_implementation_report_connected((NWConcrete_nw_protocol_instance *)v7, a1, a2, v50);
                    }
                  }
                  else if ((v7[405] & 0x80000000) == 0)
                  {
                    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                    networkd_settings_init();
                    os_log_type_t v46 = (id)gLogObj;
                    if (os_log_type_enabled(v46, OS_LOG_TYPE_ERROR))
                    {
                      char v47 = a2->output_handler_context;
                      *(_DWORD *)buf = 136446978;
                      id v169 = "nw_protocol_implementation_connect";
                      if (v47) {
                        BOOL v48 = "changed";
                      }
                      else {
                        BOOL v48 = "freed";
                      }
                      __int16 v170 = 2082;
                      __int16 v171 = v7 + 407;
                      __int16 v172 = 2080;
                      id v173 = (nw_protocol *)" ";
                      __int16 v174 = 2082;
                      __int16 v175 = (nw_protocol *)v48;
                      _os_log_impl(&dword_1830D4000, v46, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%soutput_handler_context %{public}s, no deferrred connected event", buf, 0x2Au);
                    }
                  }
                  goto LABEL_131;
                }
              }
              __int16 v102 = __nwlog_obj();
              name = output_handler->identifier->name;
              *(_DWORD *)buf = 136446722;
              id v169 = "__nw_protocol_connect";
              if (!name) {
                name = "invalid";
              }
              __int16 v170 = 2082;
              __int16 v171 = (char *)name;
              __int16 v172 = 2048;
              id v173 = output_handler;
              id v161 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v165 = OS_LOG_TYPE_ERROR;
              char v162 = 0;
              if (__nwlog_fault(v161, &v165, &v162))
              {
                if (v165 == OS_LOG_TYPE_FAULT)
                {
                  BOOL v104 = __nwlog_obj();
                  os_log_type_t v157 = v165;
                  if (os_log_type_enabled(v104, v165))
                  {
                    nw_endpoint_t v105 = output_handler->identifier->name;
                    if (!v105) {
                      nw_endpoint_t v105 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    id v169 = "__nw_protocol_connect";
                    __int16 v170 = 2082;
                    __int16 v171 = (char *)v105;
                    __int16 v172 = 2048;
                    id v173 = output_handler;
                    _os_log_impl(&dword_1830D4000, v104, v157, "%{public}s protocol %{public}s (%p) has invalid connect callback", buf, 0x20u);
                  }
                }
                else
                {
                  if (v162)
                  {
                    id v126 = (char *)__nw_create_backtrace_string();
                    os_log_type_t v158 = __nwlog_obj();
                    os_log_type_t v156 = v165;
                    BOOL v127 = os_log_type_enabled(v158, v165);
                    if (v126)
                    {
                      if (v127)
                      {
                        id v128 = output_handler->identifier->name;
                        if (!v128) {
                          id v128 = "invalid";
                        }
                        *(_DWORD *)buf = 136446978;
                        id v169 = "__nw_protocol_connect";
                        __int16 v170 = 2082;
                        __int16 v171 = (char *)v128;
                        __int16 v172 = 2048;
                        id v173 = output_handler;
                        __int16 v174 = 2082;
                        __int16 v175 = (nw_protocol *)v126;
                        _os_log_impl(&dword_1830D4000, v158, v156, "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s", buf, 0x2Au);
                      }

                      free(v126);
                    }
                    else
                    {
                      if (v127)
                      {
                        os_log_type_t v150 = output_handler->identifier->name;
                        if (!v150) {
                          os_log_type_t v150 = "invalid";
                        }
                        *(_DWORD *)buf = 136446722;
                        id v169 = "__nw_protocol_connect";
                        __int16 v170 = 2082;
                        __int16 v171 = (char *)v150;
                        __int16 v172 = 2048;
                        id v173 = output_handler;
                        _os_log_impl(&dword_1830D4000, v158, v156, "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace", buf, 0x20u);
                      }
                    }
                    goto LABEL_342;
                  }
                  BOOL v104 = __nwlog_obj();
                  os_log_type_t v159 = v165;
                  if (os_log_type_enabled(v104, v165))
                  {
                    nw_endpoint_t v144 = output_handler->identifier->name;
                    if (!v144) {
                      nw_endpoint_t v144 = "invalid";
                    }
                    *(_DWORD *)buf = 136446722;
                    id v169 = "__nw_protocol_connect";
                    __int16 v170 = 2082;
                    __int16 v171 = (char *)v144;
                    __int16 v172 = 2048;
                    id v173 = output_handler;
                    _os_log_impl(&dword_1830D4000, v104, v159, "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded", buf, 0x20u);
                  }
                }
              }
LABEL_342:
              if (v161) {
                free(v161);
              }
              goto LABEL_90;
            }
            id v119 = __nwlog_obj();
            *(_DWORD *)buf = 136446210;
            id v169 = "__nw_protocol_connect";
            __int16 v120 = (char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            v163[0] = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v120, type, v163))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                __int16 v121 = __nwlog_obj();
                os_log_type_t v122 = type[0];
                if (os_log_type_enabled(v121, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  id v169 = "__nw_protocol_connect";
                  _os_log_impl(&dword_1830D4000, v121, v122, "%{public}s called with null protocol", buf, 0xCu);
                }
              }
              else if (v163[0])
              {
                id v140 = (char *)__nw_create_backtrace_string();
                __int16 v121 = __nwlog_obj();
                os_log_type_t v141 = type[0];
                BOOL v142 = os_log_type_enabled(v121, type[0]);
                if (v140)
                {
                  if (v142)
                  {
                    *(_DWORD *)buf = 136446466;
                    id v169 = "__nw_protocol_connect";
                    __int16 v170 = 2082;
                    __int16 v171 = v140;
                    _os_log_impl(&dword_1830D4000, v121, v141, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
                  }

                  free(v140);
                  goto LABEL_358;
                }
                if (v142)
                {
                  *(_DWORD *)buf = 136446210;
                  id v169 = "__nw_protocol_connect";
                  _os_log_impl(&dword_1830D4000, v121, v141, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
                }
              }
              else
              {
                __int16 v121 = __nwlog_obj();
                os_log_type_t v152 = type[0];
                if (os_log_type_enabled(v121, type[0]))
                {
                  *(_DWORD *)buf = 136446210;
                  id v169 = "__nw_protocol_connect";
                  _os_log_impl(&dword_1830D4000, v121, v152, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
                }
              }
            }
LABEL_358:
            if (v120) {
              free(v120);
            }
            goto LABEL_94;
          }
          if ((v10 & 0x80000000) == 0)
          {
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v31 = (id)gLogObj;
            if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)buf = 136446978;
              id v169 = "nw_protocol_implementation_connect";
              __int16 v170 = 2082;
              __int16 v171 = v7 + 407;
              __int16 v172 = 2080;
              id v173 = (nw_protocol *)" ";
              __int16 v174 = 2048;
              __int16 v175 = a2;
              _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p", buf, 0x2Au);
            }
LABEL_48:
          }
LABEL_78:
          uint64_t v39 = 0;
LABEL_132:

          return v39;
        }
        os_log_type_t v27 = a1->output_handler;
        if (v27)
        {
          char v28 = v27->handle;
          if (v28 == &nw_protocol_ref_counted_handle)
          {
            __int16 v32 = v27[1].callbacks;
            if (v32) {
              v27[1].callbacks = (nw_protocol_callbacks *)((char *)&v32->add_input_handler + 1);
            }
            char v29 = -1;
          }
          else
          {
            char v29 = 0;
          }
          *(void *)os_log_type_t type = v27;
          char v167 = v29;
          id v33 = a1->handle;
          if (v33 == &nw_protocol_ref_counted_handle)
          {
            unsigned int v35 = a1[1].callbacks;
            if (v35) {
              a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v35->add_input_handler + 1);
            }
            char v34 = -1;
          }
          else
          {
            char v34 = 0;
          }
          *(void *)id v163 = a1;
          char v164 = v34;
          __int16 v36 = v27->callbacks;
          if (v36)
          {
            os_log_type_t v37 = (void (*)(nw_protocol *, nw_protocol *))v36->connect;
            if (v37)
            {
              v37(v27, a1);
LABEL_64:
              if (v33 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)v163);
              }
              if (v28 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              }
              goto LABEL_131;
            }
          }
          BOOL v96 = __nwlog_obj();
          int v97 = v27->identifier->name;
          *(_DWORD *)buf = 136446722;
          id v169 = "__nw_protocol_connect";
          if (!v97) {
            int v97 = "invalid";
          }
          __int16 v170 = 2082;
          __int16 v171 = (char *)v97;
          __int16 v172 = 2048;
          id v173 = v27;
          __int16 v98 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t v165 = OS_LOG_TYPE_ERROR;
          char v162 = 0;
          if (__nwlog_fault(v98, &v165, &v162))
          {
            if (v165 == OS_LOG_TYPE_FAULT)
            {
              unsigned int v99 = __nwlog_obj();
              os_log_type_t v100 = v165;
              if (os_log_type_enabled(v99, v165))
              {
                id v101 = v27->identifier->name;
                if (!v101) {
                  id v101 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                id v169 = "__nw_protocol_connect";
                __int16 v170 = 2082;
                __int16 v171 = (char *)v101;
                __int16 v172 = 2048;
                id v173 = v27;
                _os_log_impl(&dword_1830D4000, v99, v100, "%{public}s protocol %{public}s (%p) has invalid connect callback", buf, 0x20u);
              }
            }
            else if (v162)
            {
              nw_endpoint_t v115 = (char *)__nw_create_backtrace_string();
              unsigned int v99 = __nwlog_obj();
              os_log_type_t v116 = v165;
              BOOL v117 = os_log_type_enabled(v99, v165);
              if (v115)
              {
                if (v117)
                {
                  __int16 v118 = v27->identifier->name;
                  if (!v118) {
                    __int16 v118 = "invalid";
                  }
                  *(_DWORD *)buf = 136446978;
                  id v169 = "__nw_protocol_connect";
                  __int16 v170 = 2082;
                  __int16 v171 = (char *)v118;
                  __int16 v172 = 2048;
                  id v173 = v27;
                  __int16 v174 = 2082;
                  __int16 v175 = (nw_protocol *)v115;
                  _os_log_impl(&dword_1830D4000, v99, v116, "%{public}s protocol %{public}s (%p) has invalid connect callback, dumping backtrace:%{public}s", buf, 0x2Au);
                }

                free(v115);
                goto LABEL_317;
              }
              if (v117)
              {
                os_log_type_t v143 = v27->identifier->name;
                if (!v143) {
                  os_log_type_t v143 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                id v169 = "__nw_protocol_connect";
                __int16 v170 = 2082;
                __int16 v171 = (char *)v143;
                __int16 v172 = 2048;
                id v173 = v27;
                _os_log_impl(&dword_1830D4000, v99, v116, "%{public}s protocol %{public}s (%p) has invalid connect callback, no backtrace", buf, 0x20u);
              }
            }
            else
            {
              unsigned int v99 = __nwlog_obj();
              os_log_type_t v138 = v165;
              if (os_log_type_enabled(v99, v165))
              {
                os_log_type_t v139 = v27->identifier->name;
                if (!v139) {
                  os_log_type_t v139 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                id v169 = "__nw_protocol_connect";
                __int16 v170 = 2082;
                __int16 v171 = (char *)v139;
                __int16 v172 = 2048;
                id v173 = v27;
                _os_log_impl(&dword_1830D4000, v99, v138, "%{public}s protocol %{public}s (%p) has invalid connect callback, backtrace limit exceeded", buf, 0x20u);
              }
            }
          }
LABEL_317:
          if (v98) {
            free(v98);
          }
          goto LABEL_64;
        }
        char v111 = __nwlog_obj();
        *(_DWORD *)buf = 136446210;
        id v169 = "__nw_protocol_connect";
        BOOL v112 = (char *)_os_log_send_and_compose_impl();

        type[0] = OS_LOG_TYPE_ERROR;
        v163[0] = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v112, type, v163))
        {
          if (type[0] == OS_LOG_TYPE_FAULT)
          {
            id v113 = __nwlog_obj();
            os_log_type_t v114 = type[0];
            if (os_log_type_enabled(v113, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v169 = "__nw_protocol_connect";
              _os_log_impl(&dword_1830D4000, v113, v114, "%{public}s called with null protocol", buf, 0xCu);
            }
          }
          else if (v163[0])
          {
            __int16 v129 = (char *)__nw_create_backtrace_string();
            id v113 = __nwlog_obj();
            os_log_type_t v130 = type[0];
            BOOL v131 = os_log_type_enabled(v113, type[0]);
            if (v129)
            {
              if (v131)
              {
                *(_DWORD *)buf = 136446466;
                id v169 = "__nw_protocol_connect";
                __int16 v170 = 2082;
                __int16 v171 = v129;
                _os_log_impl(&dword_1830D4000, v113, v130, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
              }

              free(v129);
              goto LABEL_350;
            }
            if (v131)
            {
              *(_DWORD *)buf = 136446210;
              id v169 = "__nw_protocol_connect";
              _os_log_impl(&dword_1830D4000, v113, v130, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
            }
          }
          else
          {
            id v113 = __nwlog_obj();
            os_log_type_t v149 = type[0];
            if (os_log_type_enabled(v113, type[0]))
            {
              *(_DWORD *)buf = 136446210;
              id v169 = "__nw_protocol_connect";
              _os_log_impl(&dword_1830D4000, v113, v149, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
            }
          }
        }
LABEL_350:
        if (v112) {
          free(v112);
        }
        goto LABEL_131;
      }
      if (*(_DWORD *)(v8 + 64) != 3) {
        goto LABEL_131;
      }
      uint64_t v18 = a2->output_handler_context;
      int v19 = v6[405];
      if (!v18)
      {
        if (v19 < 0) {
          goto LABEL_78;
        }
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v31 = (id)gLogObj;
        if (os_log_type_enabled(v31, OS_LOG_TYPE_ERROR))
        {
          *(_DWORD *)buf = 136446978;
          id v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          __int16 v171 = v7 + 407;
          __int16 v172 = 2080;
          id v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          __int16 v175 = a2;
          _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sOutput handler context doesn't exist on protocol %p", buf, 0x2Au);
        }
        goto LABEL_48;
      }
      if ((v19 & 0x80000000) == 0 && gLogDatapath)
      {
        int v125 = __nwlog_obj();
        if (os_log_type_enabled(v125, OS_LOG_TYPE_DEBUG))
        {
          *(_DWORD *)buf = 136446978;
          id v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          __int16 v171 = v7 + 407;
          __int16 v172 = 2080;
          id v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          __int16 v175 = (nw_protocol *)nw_protocol_flow_for_protocol((NWConcrete_nw_protocol_instance *)v7, (uint64_t)a2);
          _os_log_impl(&dword_1830D4000, v125, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sConnect from flow %llx", buf, 0x2Au);
        }
      }
      __int16 v20 = v18[42];
      __int16 v21 = v20 | 4;
      v18[42] = v20 | 4;
      if ((v20 & 8) != 0)
      {
        if ((v20 & 0x10) != 0)
        {
          __int16 v21 = v20 | 0x24;
          v18[42] = v20 | 0x24;
        }
        if ((v21 & 0x20) == 0) {
          goto LABEL_131;
        }
        goto LABEL_125;
      }
      if (*(void *)(*(void *)(*((void *)v7 + 1) + 80) + 120))
      {
        uint64_t v22 = a2->handle;
        if (v22 == &nw_protocol_ref_counted_handle)
        {
          BOOL v55 = a2[1].callbacks;
          if (v55) {
            a2[1].callbacks = (nw_protocol_callbacks *)((char *)&v55->add_input_handler + 1);
          }
          *(void *)os_log_type_t type = a2;
          char v23 = v167 | 1;
        }
        else
        {
          *(void *)os_log_type_t type = a2;
          char v23 = v167 & 0xFE;
        }
        char v167 = v23;
        uint64_t v56 = a2->callbacks;
        if (v56)
        {
          get_parameters = (void (*)(nw_protocol *))v56->get_parameters;
          if (get_parameters)
          {
            nw_endpoint_t v58 = get_parameters(a2);
            if (v22 != &nw_protocol_ref_counted_handle) {
              goto LABEL_118;
            }
            goto LABEL_117;
          }
        }
        os_log_type_t v132 = __nwlog_obj();
        identifier = a2->identifier;
        *(_DWORD *)buf = 136446722;
        id v169 = "__nw_protocol_get_parameters";
        if (!identifier) {
          identifier = (nw_protocol_identifier *)"invalid";
        }
        __int16 v170 = 2082;
        __int16 v171 = (char *)identifier;
        __int16 v172 = 2048;
        id v173 = a2;
        id v134 = (char *)_os_log_send_and_compose_impl();

        v163[0] = OS_LOG_TYPE_ERROR;
        os_log_type_t v165 = OS_LOG_TYPE_DEFAULT;
        if (__nwlog_fault(v134, v163, &v165))
        {
          if (v163[0] == OS_LOG_TYPE_FAULT)
          {
            __int16 v135 = __nwlog_obj();
            os_log_type_t v136 = v163[0];
            if (os_log_type_enabled(v135, v163[0]))
            {
              uint64_t v137 = a2->identifier;
              if (!v137) {
                uint64_t v137 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              id v169 = "__nw_protocol_get_parameters";
              __int16 v170 = 2082;
              __int16 v171 = (char *)v137;
              __int16 v172 = 2048;
              id v173 = a2;
              _os_log_impl(&dword_1830D4000, v135, v136, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback", buf, 0x20u);
            }
LABEL_369:

            goto LABEL_370;
          }
          if (v165 == OS_LOG_TYPE_DEFAULT)
          {
            __int16 v135 = __nwlog_obj();
            os_log_type_t v153 = v163[0];
            if (os_log_type_enabled(v135, v163[0]))
            {
              long long v154 = a2->identifier;
              if (!v154) {
                long long v154 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              id v169 = "__nw_protocol_get_parameters";
              __int16 v170 = 2082;
              __int16 v171 = (char *)v154;
              __int16 v172 = 2048;
              id v173 = a2;
              _os_log_impl(&dword_1830D4000, v135, v153, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, backtrace limit exceeded", buf, 0x20u);
            }
            goto LABEL_369;
          }
          uint64_t v146 = (char *)__nw_create_backtrace_string();
          __int16 v135 = __nwlog_obj();
          os_log_type_t v160 = v163[0];
          BOOL v147 = os_log_type_enabled(v135, v163[0]);
          if (!v146)
          {
            if (v147)
            {
              id v155 = a2->identifier;
              if (!v155) {
                id v155 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              id v169 = "__nw_protocol_get_parameters";
              __int16 v170 = 2082;
              __int16 v171 = (char *)v155;
              __int16 v172 = 2048;
              id v173 = a2;
              _os_log_impl(&dword_1830D4000, v135, v160, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, no backtrace", buf, 0x20u);
            }
            goto LABEL_369;
          }
          if (v147)
          {
            id v148 = a2->identifier;
            if (!v148) {
              id v148 = (nw_protocol_identifier *)"invalid";
            }
            *(_DWORD *)buf = 136446978;
            id v169 = "__nw_protocol_get_parameters";
            __int16 v170 = 2082;
            __int16 v171 = (char *)v148;
            __int16 v172 = 2048;
            id v173 = a2;
            __int16 v174 = 2082;
            __int16 v175 = (nw_protocol *)v146;
            _os_log_impl(&dword_1830D4000, v135, v160, "%{public}s protocol %{public}s (%p) has invalid get_parameters callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v146);
        }
LABEL_370:
        if (v134) {
          free(v134);
        }
        nw_endpoint_t v58 = 0;
        if (v22 != &nw_protocol_ref_counted_handle)
        {
LABEL_118:
          if (v58)
          {
            BOOL v59 = nw_parameters_copy_protocol_options(v58, v7, 0);
            objc_storeStrong((id *)v7 + 7, v59);
            os_log_type_t v60 = (void *)*((void *)v18 + 5);
            *((void *)v18 + 5) = v59;
          }
          v18[42] |= 8u;
          uint64_t v61 = *(void (**)(uint64_t *, uint64_t, void))(*(void *)(*((void *)v7 + 1) + 80) + 120);
          uint64_t v62 = v7;
          if (nw_protocol_definition_get_message_is_stream(*((void **)v7 + 1))
            && (nw_protocol *)*(v62 - 6) == a2)
          {
            uint64_t v63 = -2;
          }
          else
          {
            uint64_t v63 = (uint64_t)a2;
          }

          v61(v62, v63, v18[42] & 1);
          if (!nw_hash_table_get_node(v62[29], (uint64_t)a2, 8))
          {
            if ((v7[405] & 0x80000000) == 0)
            {
              __int16 v67 = __nwlog_obj();
              if (os_log_type_enabled(v67, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)buf = 136446978;
                id v169 = "nw_protocol_implementation_connect";
                __int16 v170 = 2082;
                __int16 v171 = (char *)v62 + 407;
                __int16 v172 = 2080;
                id v173 = (nw_protocol *)" ";
                __int16 v174 = 2048;
                __int16 v175 = a2;
                _os_log_impl(&dword_1830D4000, v67, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sinput_protocol %p no longer exists in flows_table", buf, 0x2Au);
              }
            }
            goto LABEL_78;
          }

          __int16 v21 = v18[42];
          if ((v21 & 0x20) != 0)
          {
LABEL_125:
            if ((v7[405] & 0x80000000) == 0 && gLogDatapath)
            {
              uint64_t v145 = __nwlog_obj();
              if (os_log_type_enabled(v145, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)buf = 136446722;
                id v169 = "nw_protocol_implementation_connect";
                __int16 v170 = 2082;
                __int16 v171 = v7 + 407;
                __int16 v172 = 2080;
                id v173 = (nw_protocol *)" ";
                _os_log_impl(&dword_1830D4000, v145, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sDelivering deferred connected event", buf, 0x20u);
              }

              __int16 v21 = v18[42];
            }
            v18[42] = v21 & 0xFFDF;
            uint64_t v64 = v7;
            if (nw_protocol_definition_get_message_is_stream(*((void **)v7 + 1))
              && *(nw_protocol **)&v64[-1].log_str[41] == a2)
            {
              unint64_t v65 = -2;
            }
            else
            {
              unint64_t v65 = (unint64_t)a2;
            }

            nw_protocol_implementation_report_connected(v64, a1, a2, v65);
          }
LABEL_131:
          uint64_t v39 = 1;
          goto LABEL_132;
        }
LABEL_117:
        nw::release_if_needed<nw_protocol *>((uint64_t *)type);
        goto LABEL_118;
      }
      id v51 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      id v169 = "nw_protocol_implementation_connect";
      int v52 = (const char *)_os_log_send_and_compose_impl();

      type[0] = OS_LOG_TYPE_ERROR;
      v163[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v52, type, v163)) {
        goto LABEL_152;
      }
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v54 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null instance->parent_definition->start", buf, 0xCu);
        }
LABEL_151:

        goto LABEL_152;
      }
      if (v163[0] == OS_LOG_TYPE_DEFAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v71 = type[0];
        if (os_log_type_enabled(v53, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v71, "%{public}s called with null instance->parent_definition->start, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_151;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v53 = __nwlog_obj();
      os_log_type_t v69 = type[0];
      BOOL v70 = os_log_type_enabled(v53, type[0]);
      if (!backtrace_string)
      {
        if (v70)
        {
          *(_DWORD *)buf = 136446210;
          id v169 = "nw_protocol_implementation_connect";
          _os_log_impl(&dword_1830D4000, v53, v69, "%{public}s called with null instance->parent_definition->start, no backtrace", buf, 0xCu);
        }
        goto LABEL_151;
      }
      if (v70)
      {
        *(_DWORD *)buf = 136446466;
        id v169 = "nw_protocol_implementation_connect";
        __int16 v170 = 2082;
        __int16 v171 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v53, v69, "%{public}s called with null instance->parent_definition->start, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_143:

      free(backtrace_string);
LABEL_152:
      if (!v52) {
        goto LABEL_78;
      }
      uint64_t v38 = (char *)v52;
      goto LABEL_77;
    }
    if (v6[405] < 0) {
      goto LABEL_78;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v14 = (id)gLogObj;
    *(_DWORD *)buf = 136446978;
    id v169 = "nw_protocol_implementation_connect";
    __int16 v170 = 2082;
    __int16 v171 = v7 + 407;
    __int16 v172 = 2080;
    id v173 = (nw_protocol *)" ";
    __int16 v174 = 2048;
    __int16 v175 = a1;
    os_log_type_t v15 = (const char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    v163[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v15, type, v163))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (id)gLogObj;
        os_log_type_t v17 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          id v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          __int16 v171 = v7 + 407;
          __int16 v172 = 2080;
          id v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          __int16 v175 = a1;
          _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s %{public}s%sProtocol %p output_handler is pointing to itself", buf, 0x2Au);
        }
      }
      else if (v163[0])
      {
        os_log_type_t v24 = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (id)gLogObj;
        os_log_type_t v25 = type[0];
        BOOL v26 = os_log_type_enabled(v16, type[0]);
        if (v24)
        {
          if (v26)
          {
            *(_DWORD *)buf = 136447234;
            id v169 = "nw_protocol_implementation_connect";
            __int16 v170 = 2082;
            __int16 v171 = v7 + 407;
            __int16 v172 = 2080;
            id v173 = (nw_protocol *)" ";
            __int16 v174 = 2048;
            __int16 v175 = a1;
            __int16 v176 = 2082;
            __int16 v177 = v24;
            _os_log_impl(&dword_1830D4000, v16, v25, "%{public}s %{public}s%sProtocol %p output_handler is pointing to itself, dumping backtrace:%{public}s", buf, 0x34u);
          }

          free(v24);
          if (!v15) {
            goto LABEL_78;
          }
LABEL_76:
          uint64_t v38 = (char *)v15;
LABEL_77:
          free(v38);
          goto LABEL_78;
        }
        if (v26)
        {
          *(_DWORD *)buf = 136446978;
          id v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          __int16 v171 = v7 + 407;
          __int16 v172 = 2080;
          id v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          __int16 v175 = a1;
          _os_log_impl(&dword_1830D4000, v16, v25, "%{public}s %{public}s%sProtocol %p output_handler is pointing to itself, no backtrace", buf, 0x2Au);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        char v16 = (id)gLogObj;
        os_log_type_t v30 = type[0];
        if (os_log_type_enabled(v16, type[0]))
        {
          *(_DWORD *)buf = 136446978;
          id v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          __int16 v171 = v7 + 407;
          __int16 v172 = 2080;
          id v173 = (nw_protocol *)" ";
          __int16 v174 = 2048;
          __int16 v175 = a1;
          _os_log_impl(&dword_1830D4000, v16, v30, "%{public}s %{public}s%sProtocol %p output_handler is pointing to itself, backtrace limit exceeded", buf, 0x2Au);
        }
      }
    }
    if (!v15) {
      goto LABEL_78;
    }
    goto LABEL_76;
  }
  uint64_t v72 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v169 = "nw_protocol_implementation_connect";
  __int16 v73 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  v163[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v73, type, v163))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      unsigned int v74 = __nwlog_obj();
      os_log_type_t v75 = type[0];
      if (os_log_type_enabled(v74, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v169 = "nw_protocol_implementation_connect";
        _os_log_impl(&dword_1830D4000, v74, v75, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if (v163[0])
    {
      id v84 = (char *)__nw_create_backtrace_string();
      unsigned int v74 = __nwlog_obj();
      os_log_type_t v85 = type[0];
      BOOL v86 = os_log_type_enabled(v74, type[0]);
      if (v84)
      {
        if (v86)
        {
          *(_DWORD *)buf = 136446466;
          id v169 = "nw_protocol_implementation_connect";
          __int16 v170 = 2082;
          __int16 v171 = v84;
          _os_log_impl(&dword_1830D4000, v74, v85, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v84);
        goto LABEL_255;
      }
      if (v86)
      {
        *(_DWORD *)buf = 136446210;
        id v169 = "nw_protocol_implementation_connect";
        _os_log_impl(&dword_1830D4000, v74, v85, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      unsigned int v74 = __nwlog_obj();
      os_log_type_t v106 = type[0];
      if (os_log_type_enabled(v74, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        id v169 = "nw_protocol_implementation_connect";
        _os_log_impl(&dword_1830D4000, v74, v106, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_255:
  if (v73) {
    free(v73);
  }
  return 0;
}

void sub_1831C4FB8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL ___ZL44nw_parameters_copy_protocol_value_from_levelP24NWConcrete_nw_parameters19nw_protocol_level_tP11nw_protocolPKc_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v4 = a3;
  protocol_char handle = nw_protocol_options_get_protocol_handle(v4);
  if (protocol_handle && protocol_handle == *(void *)(a1 + 40))
  {
    uint64_t v6 = nw_parameters_copy_protocol_value_from_parameters(v4, *(const char **)(a1 + 48));
    uint64_t v7 = *(void *)(*(void *)(a1 + 32) + 8);
    uint64_t v8 = *(void **)(v7 + 40);
    *(void *)(v7 + 40) = v6;
  }
  BOOL v9 = *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 40) == 0;

  return v9;
}

void sub_1831C50AC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

atomic_uchar *nw_parameters_copy_protocol_options(void *a1, void *a2, _DWORD *a3)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v5 = a1;
  id v6 = a2;
  uint64_t v7 = v6;
  if (v5)
  {
    if (v6)
    {
      uint64_t v8 = nw_parameters_copy_protocol_options_internal(v5, v6, a3);
      goto LABEL_4;
    }
    id v14 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_copy_protocol_options";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_1830D4000, v12, v15, "%{public}s called with null protocol_instance", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v23)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_1830D4000, v12, v22, "%{public}s called with null protocol_instance, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v19 = type;
      BOOL v20 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null protocol_instance, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v20)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v26 = "nw_parameters_copy_protocol_options";
        __int16 v27 = 2082;
        char v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v19, "%{public}s called with null protocol_instance, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    int v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_parameters_copy_protocol_options";
    os_log_type_t v11 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v11, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v13 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_1830D4000, v12, v13, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v23)
      {
        os_log_type_t v12 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v12, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_1830D4000, v12, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v12 = __nwlog_obj();
      os_log_type_t v17 = type;
      BOOL v18 = os_log_type_enabled(v12, type);
      if (!backtrace_string)
      {
        if (v18)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_parameters_copy_protocol_options";
          _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v18)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v26 = "nw_parameters_copy_protocol_options";
        __int16 v27 = 2082;
        char v28 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v12, v17, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v11) {
    free(v11);
  }
  uint64_t v8 = 0;
LABEL_4:

  return v8;
}

void sub_1831C557C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

atomic_uchar *nw_parameters_copy_protocol_options_legacy(void *a1, nw_protocol *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (v3)
  {
    if (a2)
    {
      id v4 = nw_protocol_instance_stub_create(a2);
      id v5 = nw_parameters_copy_protocol_options_internal(v3, v4, 0);

      goto LABEL_4;
    }
    os_log_type_t v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_parameters_copy_protocol_options_legacy";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null protocol_handle", buf, 0xCu);
        }
LABEL_36:

        goto LABEL_37;
      }
      if (!v20)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_1830D4000, v9, v19, "%{public}s called with null protocol_handle, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          char v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null protocol_handle, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        char v23 = "nw_parameters_copy_protocol_options_legacy";
        __int16 v24 = 2082;
        os_log_type_t v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null protocol_handle, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_24;
    }
  }
  else
  {
    uint64_t v7 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v23 = "nw_parameters_copy_protocol_options_legacy";
    uint64_t v8 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v8, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v10 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null parameters", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (!v20)
      {
        BOOL v9 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v9, type))
        {
          *(_DWORD *)buf = 136446210;
          char v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_1830D4000, v9, v18, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_36;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v9, type);
      if (!backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446210;
          char v23 = "nw_parameters_copy_protocol_options_legacy";
          _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
        goto LABEL_36;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446466;
        char v23 = "nw_parameters_copy_protocol_options_legacy";
        __int16 v24 = 2082;
        os_log_type_t v25 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_24:

      free(backtrace_string);
    }
  }
LABEL_37:
  if (v8) {
    free(v8);
  }
  id v5 = 0;
LABEL_4:

  return v5;
}

void sub_1831C5A58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

atomic_uchar *nw_parameters_copy_protocol_options_internal(void *a1, void *a2, _DWORD *a3)
{
  uint64_t v55 = *MEMORY[0x1E4F143B8];
  id v6 = a1;
  id v7 = a2;
  if (v7)
  {
    id v8 = v6[19];
    BOOL v9 = v8;
    if (v8)
    {
      if (*((void *)v8 + 1))
      {
        *(void *)buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000;
        int v52 = __Block_byref_object_copy__19403;
        id v53 = __Block_byref_object_dispose__19404;
        id v54 = 0;
        id v3 = (atomic_uchar *)*((void *)v8 + 1);
        v46[0] = MEMORY[0x1E4F143A8];
        v46[1] = 3221225472;
        v46[2] = ___ZL44nw_parameters_copy_protocol_options_internalP24NWConcrete_nw_parametersPU40objcproto29NWConcrete_nw_protocol_handle8NSObjectP19nw_protocol_level_t_block_invoke;
        v46[3] = &unk_1E524A2E8;
        id v47 = v7;
        BOOL v48 = buf;
        nw_array_apply(v3, (uint64_t)v46);
        uint64_t v10 = *(void *)&buf[8];
        uint64_t v11 = *(void *)(*(void *)&buf[8] + 40);
        if (v11)
        {
          if (a3)
          {
            *a3 = 5;
            os_log_type_t v12 = *(void **)(v10 + 40);
          }
          else
          {
            os_log_type_t v12 = *(void **)(*(void *)&buf[8] + 40);
          }
          id v3 = v12;
        }

        _Block_object_dispose(buf, 8);
        if (v11) {
          goto LABEL_39;
        }
      }
      if (v9[2])
      {
        *(void *)buf = 0;
        *(void *)&uint8_t buf[8] = buf;
        *(void *)&buf[16] = 0x3032000000;
        int v52 = __Block_byref_object_copy__19403;
        id v53 = __Block_byref_object_dispose__19404;
        id v54 = 0;
        os_log_type_t v13 = (atomic_uchar *)v9[2];
        v43[0] = MEMORY[0x1E4F143A8];
        v43[1] = 3221225472;
        v43[2] = ___ZL44nw_parameters_copy_protocol_options_internalP24NWConcrete_nw_parametersPU40objcproto29NWConcrete_nw_protocol_handle8NSObjectP19nw_protocol_level_t_block_invoke_2;
        v43[3] = &unk_1E524A2E8;
        id v44 = v7;
        BOOL v45 = buf;
        nw_array_apply(v13, (uint64_t)v43);
        uint64_t v14 = *(void *)&buf[8];
        uint64_t v15 = *(void *)(*(void *)&buf[8] + 40);
        if (v15)
        {
          if (a3)
          {
            *a3 = 4;
            os_log_type_t v16 = *(void **)(v14 + 40);
          }
          else
          {
            os_log_type_t v16 = *(void **)(*(void *)&buf[8] + 40);
          }
          id v3 = v16;
        }

        _Block_object_dispose(buf, 8);
        if (v15) {
          goto LABEL_39;
        }
      }
      BOOL v17 = (void *)v9[3];
      if (v17
        && (v18 = v17, uint64_t v19 = v18[2], v18, v19)
        && v19 == [v7 getProtocolStructure])
      {
        if (a3) {
          *a3 = 3;
        }
        os_log_type_t v25 = (void *)v9[3];
      }
      else
      {
        char v20 = (void *)v9[4];
        if (v20
          && (os_log_type_t v21 = v20, v22 = v21[2], v21, v22)
          && v22 == [v7 getProtocolStructure])
        {
          if (a3) {
            *a3 = 3;
          }
          os_log_type_t v25 = (void *)v9[4];
        }
        else
        {
          char v23 = (void *)v9[6];
          if (!v23) {
            goto LABEL_28;
          }
          __int16 v24 = v23;
          id v3 = (atomic_uchar *)v24[2];

          if (!v3)
          {
LABEL_39:

            goto LABEL_40;
          }
          if (v3 != (atomic_uchar *)[v7 getProtocolStructure])
          {
LABEL_28:
            id v3 = 0;
            goto LABEL_39;
          }
          if (a3) {
            *a3 = 2;
          }
          os_log_type_t v25 = (void *)v9[6];
        }
      }
      id v3 = v25;
      goto LABEL_39;
    }
    uint64_t v31 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
    __int16 v32 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v49 = 0;
    if (__nwlog_fault(v32, &type, &v49))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        id v33 = __nwlog_obj();
        os_log_type_t v34 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
          _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s called with null stack", buf, 0xCu);
        }
      }
      else if (v49)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v33 = __nwlog_obj();
        os_log_type_t v39 = type;
        BOOL v40 = os_log_type_enabled(v33, type);
        if (backtrace_string)
        {
          if (v40)
          {
            *(_DWORD *)buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v33, v39, "%{public}s called with null stack, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_76;
        }
        if (v40)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
          _os_log_impl(&dword_1830D4000, v33, v39, "%{public}s called with null stack, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v33 = __nwlog_obj();
        os_log_type_t v42 = type;
        if (os_log_type_enabled(v33, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
          _os_log_impl(&dword_1830D4000, v33, v42, "%{public}s called with null stack, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_76:
    if (v32) {
      free(v32);
    }
    goto LABEL_28;
  }
  __int16 v27 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
  char v28 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v49 = 0;
  if (__nwlog_fault(v28, &type, &v49))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
        _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s called with null protocol_instance", buf, 0xCu);
      }
    }
    else if (v49)
    {
      unsigned int v35 = (char *)__nw_create_backtrace_string();
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v36 = type;
      BOOL v37 = os_log_type_enabled(v29, type);
      if (v35)
      {
        if (v37)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v35;
          _os_log_impl(&dword_1830D4000, v29, v36, "%{public}s called with null protocol_instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v35);
        goto LABEL_70;
      }
      if (v37)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
        _os_log_impl(&dword_1830D4000, v29, v36, "%{public}s called with null protocol_instance, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v29 = __nwlog_obj();
      os_log_type_t v41 = type;
      if (os_log_type_enabled(v29, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_parameters_copy_protocol_options_internal";
        _os_log_impl(&dword_1830D4000, v29, v41, "%{public}s called with null protocol_instance, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_70:
  if (v28) {
    free(v28);
  }
  id v3 = 0;
LABEL_40:

  return v3;
}

void sub_1831C61D8(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL44nw_parameters_copy_protocol_options_internalP24NWConcrete_nw_parametersPU40objcproto29NWConcrete_nw_protocol_handle8NSObjectP19nw_protocol_level_t_block_invoke_2(uint64_t a1, uint64_t a2, void *a3)
{
  id v5 = a3;
  protocol_char handle = nw_protocol_options_get_protocol_handle(v5);
  if (protocol_handle && protocol_handle == [*(id *)(a1 + 32) getProtocolStructure])
  {
    objc_storeStrong((id *)(*(void *)(*(void *)(a1 + 40) + 8) + 40), a3);
    uint64_t v7 = 0;
  }
  else
  {
    uint64_t v7 = 1;
  }

  return v7;
}

void sub_1831C6280(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_options_get_protocol_handle(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 2);
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_protocol_options_get_protocol_handle";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_options_get_protocol_handle";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null options", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_protocol_options_get_protocol_handle";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_options_get_protocol_handle";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null options, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_protocol_options_get_protocol_handle";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null options, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

NWConcrete_nw_protocol_instance_stub *nw_protocol_instance_stub_create(nw_protocol *a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  BOOL result = [NWConcrete_nw_protocol_instance_stub alloc];
  if (!result) {
    return result;
  }
  v13.os_log_type_t receiver = result;
  v13.super_class = (Class)NWConcrete_nw_protocol_instance_stub;
  BOOL result = (NWConcrete_nw_protocol_instance_stub *)[(nw_protocol *)&v13 init];
  if (result)
  {
    result->protocol = a1;
    return result;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v3 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  uint64_t v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
  id v4 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v4, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (id)gLogObj;
      os_log_type_t v6 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
        _os_log_impl(&dword_1830D4000, v5, v6, "%{public}s [super init] failed", buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (id)gLogObj;
      os_log_type_t v8 = type;
      BOOL v9 = os_log_type_enabled(v5, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
          __int16 v16 = 2082;
          __int16 v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_21;
      }
      if (v9)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
        _os_log_impl(&dword_1830D4000, v5, v8, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v5 = (id)gLogObj;
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v5, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v15 = "-[NWConcrete_nw_protocol_instance_stub initWithProtocol:]";
        _os_log_impl(&dword_1830D4000, v5, v10, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_21:
  if (v4) {
    free(v4);
  }
  return 0;
}

uint64_t nw_parameters_copy_protocol_value_from_parameters(void *a1, const char *a2)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    id v5 = (id *)v3;
    id v6 = v5[5];

    if (v6 && object_getClass(v6) == (Class)MEMORY[0x1E4F14590])
    {
      uint64_t v7 = xpc_dictionary_get_value(v6, a2);
    }
    else
    {
      uint64_t v7 = 0;
    }

    goto LABEL_7;
  }
  BOOL v9 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v20 = "nw_parameters_copy_protocol_value_from_parameters";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v17 = 0;
  if (__nwlog_fault(v10, &type, &v17))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v20 = "nw_parameters_copy_protocol_value_from_parameters";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null protocol_parameters", buf, 0xCu);
      }
    }
    else if (v17)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      char v11 = __nwlog_obj();
      os_log_type_t v14 = type;
      BOOL v15 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v15)
        {
          *(_DWORD *)buf = 136446466;
          char v20 = "nw_parameters_copy_protocol_value_from_parameters";
          __int16 v21 = 2082;
          uint64_t v22 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null protocol_parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_24;
      }
      if (v15)
      {
        *(_DWORD *)buf = 136446210;
        char v20 = "nw_parameters_copy_protocol_value_from_parameters";
        _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null protocol_parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      char v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        char v20 = "nw_parameters_copy_protocol_value_from_parameters";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null protocol_parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_24:
  if (v10) {
    free(v10);
  }
  uint64_t v7 = 0;
LABEL_7:

  return v7;
}

void sub_1831C6BA0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_protocol_implementation_read(NWConcrete_nw_protocol_instance *a1, nw_protocol *a2)
{
  uint64_t v104 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!a2)
  {
    uint64_t v61 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v93 = 136446210;
    *(void *)&v93[4] = "nw_protocol_implementation_read";
    uint64_t v62 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v91[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v62, buf, v91))
    {
      if (buf[0] == 17)
      {
        uint64_t v63 = __nwlog_obj();
        os_log_type_t v64 = buf[0];
        if (os_log_type_enabled(v63, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v93 = 136446210;
          *(void *)&v93[4] = "nw_protocol_implementation_read";
          _os_log_impl(&dword_1830D4000, v63, v64, "%{public}s called with null output_handler", v93, 0xCu);
        }
      }
      else if (v91[0])
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v63 = __nwlog_obj();
        os_log_type_t v66 = buf[0];
        BOOL v67 = os_log_type_enabled(v63, (os_log_type_t)buf[0]);
        if (backtrace_string)
        {
          if (v67)
          {
            *(_DWORD *)os_log_type_t v93 = 136446466;
            *(void *)&v93[4] = "nw_protocol_implementation_read";
            *(_WORD *)&v93[12] = 2082;
            *(void *)&v93[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v63, v66, "%{public}s called with null output_handler, dumping backtrace:%{public}s", v93, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_174;
        }
        if (v67)
        {
          *(_DWORD *)os_log_type_t v93 = 136446210;
          *(void *)&v93[4] = "nw_protocol_implementation_read";
          _os_log_impl(&dword_1830D4000, v63, v66, "%{public}s called with null output_handler, no backtrace", v93, 0xCu);
        }
      }
      else
      {
        uint64_t v63 = __nwlog_obj();
        os_log_type_t v68 = buf[0];
        if (os_log_type_enabled(v63, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v93 = 136446210;
          *(void *)&v93[4] = "nw_protocol_implementation_read";
          _os_log_impl(&dword_1830D4000, v63, v68, "%{public}s called with null output_handler, backtrace limit exceeded", v93, 0xCu);
        }
      }
    }
LABEL_174:
    if (v62) {
      free(v62);
    }
    goto LABEL_157;
  }
  if ((v3->flow_in_connected & 0x10000000) != 0) {
    goto LABEL_157;
  }
  unint64_t v85 = 0;
  if (v3->flow_registration && !nw_protocol_implementation_lookup_path_by_protocol(v3, a2, &v85))
  {
    if ((SBYTE5(v4->flow_in_connected) & 0x80000000) == 0)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      os_log_type_t v60 = (id)gLogObj;
      if (os_log_type_enabled(v60, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)os_log_type_t v93 = 136446978;
        *(void *)&v93[4] = "nw_protocol_implementation_read";
        *(_WORD *)&v93[12] = 2082;
        *(void *)&v93[14] = (char *)&v4->flow_in_connected + 7;
        *(_WORD *)&v93[22] = 2080;
        BOOL v94 = " ";
        LOWORD(v95) = 2048;
        *(void *)((char *)&v95 + 2) = a2;
        _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_ERROR, "%{public}s %{public}s%sCould not find path state for protocol %p", v93, 0x2Au);
      }
    }
    goto LABEL_157;
  }
  char v5 = BYTE4(v4->flow_in_connected);
  while (1)
  {
    BYTE4(v4->flow_in_connected) = v5 & 0xDF;
    BYTE3(v4->flow_in_connected) |= 0x10u;
    var10 = (void (*)(NWConcrete_nw_protocol_instance *))v4->parent_definition->extended_state->var10;
    if (var10) {
      var10(v4);
    }
    unint64_t v7 = v85;
    os_log_type_t v8 = v4;
    if (!v4->parent_definition->extended_state->var7)
    {
      id v33 = __nwlog_obj();
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_internal";
      os_log_type_t v34 = (char *)_os_log_send_and_compose_impl();

      v91[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(p_paths_log_id_num) = 0;
      if (__nwlog_fault(v34, v91, &p_paths_log_id_num))
      {
        if (v91[0] == OS_LOG_TYPE_FAULT)
        {
          unsigned int v35 = __nwlog_obj();
          os_log_type_t v36 = v91[0];
          if (os_log_type_enabled(v35, v91[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_internal";
            _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s called with null instance->parent_definition->extended_state->handle_inbound", buf, 0xCu);
          }
        }
        else if ((_BYTE)p_paths_log_id_num)
        {
          BOOL v48 = (char *)__nw_create_backtrace_string();
          unsigned int v35 = __nwlog_obj();
          os_log_type_t v49 = v91[0];
          BOOL v50 = os_log_type_enabled(v35, v91[0]);
          if (v48)
          {
            if (v50)
            {
              *(_DWORD *)buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_internal";
              __int16 v98 = 2082;
              unsigned int v99 = (nw_protocol_identifier *)v48;
              _os_log_impl(&dword_1830D4000, v35, v49, "%{public}s called with null instance->parent_definition->extended_state->handle_inbound, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(v48);
            goto LABEL_140;
          }
          if (v50)
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_internal";
            _os_log_impl(&dword_1830D4000, v35, v49, "%{public}s called with null instance->parent_definition->extended_state->handle_inbound, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          unsigned int v35 = __nwlog_obj();
          os_log_type_t v57 = v91[0];
          if (os_log_type_enabled(v35, v91[0]))
          {
            *(_DWORD *)buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_protocol_implementation_get_input_internal";
            _os_log_impl(&dword_1830D4000, v35, v57, "%{public}s called with null instance->parent_definition->extended_state->handle_inbound, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
LABEL_140:
      if (v34) {
        free(v34);
      }
      int v15 = 0;
      goto LABEL_32;
    }
    v86[0] = 0;
    v86[1] = v86;
    if (a2->handle == &nw_protocol_ref_counted_handle)
    {
      callbacks = a2[1].callbacks;
      if (callbacks) {
        a2[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
      }
      *(void *)os_log_type_t v91 = a2;
      char v9 = v92 | 1;
    }
    else
    {
      *(void *)os_log_type_t v91 = a2;
      char v9 = v92 & 0xFE;
    }
    char v92 = v9;
    if (*(_UNKNOWN **)&v4[-1].log_str[33] == &nw_protocol_ref_counted_handle)
    {
      uint64_t v12 = *(void *)&v4[-1].log_str[81];
      if (v12) {
        *(void *)&v4[-1].log_str[81] = v12 + 1;
      }
      p_paths_log_id_num = &v4[-1].paths_log_id_num;
      char v11 = v90 | 1;
    }
    else
    {
      p_paths_log_id_num = &v4[-1].paths_log_id_num;
      char v11 = v90 & 0xFE;
    }
    char v90 = v11;
    objc_super v13 = a2->callbacks;
    if (!v13
      || (get_input_frames = (uint64_t (*)(nw_protocol *, unsigned __int16 *, uint64_t, uint64_t, uint64_t, void *))v13->get_input_frames) == 0)
    {
      os_log_type_t v25 = __nwlog_obj();
      identifier = a2->identifier;
      if (!identifier) {
        identifier = (nw_protocol_identifier *)"invalid";
      }
      *(_DWORD *)buf = 136446722;
      *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
      __int16 v98 = 2082;
      unsigned int v99 = identifier;
      __int16 v100 = 2048;
      id v101 = a2;
      unsigned int log = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v87 = 0;
      __int16 v27 = (char *)log;
      if (!__nwlog_fault(log, &type, &v87))
      {
LABEL_118:
        if (v27) {
          free(v27);
        }
        int v15 = 0;
        if ((v11 & 1) == 0) {
          goto LABEL_24;
        }
LABEL_23:
        nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
        goto LABEL_24;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v28 = __nwlog_obj();
        os_log_type_t v72 = type;
        if (os_log_type_enabled(v28, type))
        {
          uint64_t v29 = a2->identifier;
          if (!v29) {
            uint64_t v29 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          __int16 v98 = 2082;
          unsigned int v99 = v29;
          __int16 v100 = 2048;
          id v101 = a2;
          _os_log_impl(&dword_1830D4000, v28, v72, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback", buf, 0x20u);
        }
      }
      else
      {
        if (v87)
        {
          BOOL v37 = (char *)__nw_create_backtrace_string();
          unsigned int v74 = __nwlog_obj();
          os_log_type_t v70 = type;
          BOOL v38 = os_log_type_enabled(v74, type);
          if (v37)
          {
            if (v38)
            {
              os_log_type_t v39 = a2->identifier;
              if (!v39) {
                os_log_type_t v39 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              __int16 v98 = 2082;
              unsigned int v99 = v39;
              __int16 v100 = 2048;
              id v101 = a2;
              __int16 v102 = 2082;
              int v103 = v37;
              _os_log_impl(&dword_1830D4000, v74, v70, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v37);
          }
          else
          {
            if (v38)
            {
              uint64_t v55 = a2->identifier;
              if (!v55) {
                uint64_t v55 = (nw_protocol_identifier *)"invalid";
              }
              *(_DWORD *)buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
              __int16 v98 = 2082;
              unsigned int v99 = v55;
              __int16 v100 = 2048;
              id v101 = a2;
              _os_log_impl(&dword_1830D4000, v74, v70, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace", buf, 0x20u);
            }
          }
          goto LABEL_117;
        }
        char v28 = __nwlog_obj();
        os_log_type_t v76 = type;
        if (os_log_type_enabled(v28, type))
        {
          id v51 = a2->identifier;
          if (!v51) {
            id v51 = (nw_protocol_identifier *)"invalid";
          }
          *(_DWORD *)buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_get_input_frames";
          __int16 v98 = 2082;
          unsigned int v99 = v51;
          __int16 v100 = 2048;
          id v101 = a2;
          _os_log_impl(&dword_1830D4000, v28, v76, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded", buf, 0x20u);
        }
      }

LABEL_117:
      __int16 v27 = (char *)log;
      goto LABEL_118;
    }
    int v15 = get_input_frames(a2, &v4[-1].paths_log_id_num, 1, 0xFFFFFFFFLL, 0xFFFFFFFFLL, v86);
    if (v11) {
      goto LABEL_23;
    }
LABEL_24:
    if (v9)
    {
      nw::release_if_needed<nw_protocol *>((uint64_t *)v91);
      if (!v15) {
        goto LABEL_32;
      }
    }
    else if (!v15)
    {
      goto LABEL_32;
    }
    *(void *)os_log_type_t v93 = MEMORY[0x1E4F143A8];
    *(void *)&v93[8] = 3221225472;
    *(void *)&v93[16] = ___ZL45nw_protocol_implementation_get_input_internalP31NWConcrete_nw_protocol_instanceP11nw_protocolmjjj_block_invoke;
    BOOL v94 = (const char *)&unk_1E523BF38;
    *((void *)&v95 + 1) = v86;
    *(void *)&long long v95 = v8;
    unint64_t v96 = v7;
    uint64_t v16 = v86[0];
    do
    {
      if (!v16) {
        break;
      }
      uint64_t v17 = *(void *)(v16 + 32);
      char v18 = (*(uint64_t (**)(unsigned char *))&v93[16])(v93);
      uint64_t v16 = v17;
    }
    while ((v18 & 1) != 0);

LABEL_32:
    nw_protocol_instance_flush_batched_input_internal(v8);
    if (!v4->pending_inbound_frames.tqh_last) {
      goto LABEL_46;
    }
    if ((SBYTE5(v4->flow_in_connected) & 0x80000000) == 0 && gLogDatapath)
    {
      id v44 = __nwlog_obj();
      if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_log_type_t v93 = 136446722;
        *(void *)&v93[4] = "nw_protocol_implementation_read";
        *(_WORD *)&v93[12] = 2082;
        *(void *)&v93[14] = (char *)&v4->flow_in_connected + 7;
        *(_WORD *)&v93[22] = 2080;
        BOOL v94 = " ";
        _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s%sFinalizing pending outbound frames (one-off)", v93, 0x20u);
      }
    }
    uint64_t v19 = *(void *)&v4[-1].log_str[25];
    if (v19)
    {
      if (*(_UNKNOWN **)(v19 + 40) == &nw_protocol_ref_counted_handle)
      {
        uint64_t v21 = *(void *)(v19 + 88);
        if (v21) {
          *(void *)(v19 + 88) = v21 + 1;
        }
        *(void *)buf = v19;
        char v20 = buf[8] | 1;
      }
      else
      {
        *(void *)buf = *(void *)&v4[-1].log_str[25];
        char v20 = buf[8] & 0xFE;
      }
      uint8_t buf[8] = v20;
      uint64_t v22 = *(void *)(v19 + 24);
      if (v22)
      {
        uint64_t v23 = *(void (**)(uint64_t, nw_frame ***))(v22 + 96);
        if (v23)
        {
          v23(v19, &v4->pending_inbound_frames.tqh_last);
LABEL_44:
          if (v20) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
          }
          goto LABEL_46;
        }
      }
      __nwlog_obj();
      os_log_t loga = (os_log_t)objc_claimAutoreleasedReturnValue();
      os_log_type_t v30 = *(const char **)(v19 + 16);
      if (!v30) {
        os_log_type_t v30 = "invalid";
      }
      *(_DWORD *)os_log_type_t v93 = 136446722;
      *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
      *(_WORD *)&v93[12] = 2082;
      *(void *)&v93[14] = v30;
      *(_WORD *)&v93[22] = 2048;
      BOOL v94 = (const char *)v19;
      uint64_t v31 = (char *)_os_log_send_and_compose_impl();

      v91[0] = OS_LOG_TYPE_ERROR;
      LOBYTE(p_paths_log_id_num) = 0;
      if (__nwlog_fault(v31, v91, &p_paths_log_id_num))
      {
        if (v91[0] == OS_LOG_TYPE_FAULT)
        {
          os_log_t logb = __nwlog_obj();
          os_log_type_t v73 = v91[0];
          if (os_log_type_enabled(logb, v91[0]))
          {
            __int16 v32 = *(const char **)(v19 + 16);
            if (!v32) {
              __int16 v32 = "invalid";
            }
            *(_DWORD *)os_log_type_t v93 = 136446722;
            *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v93[12] = 2082;
            *(void *)&v93[14] = v32;
            *(_WORD *)&v93[22] = 2048;
            BOOL v94 = (const char *)v19;
            _os_log_impl(&dword_1830D4000, logb, v73, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback", v93, 0x20u);
          }
        }
        else
        {
          if ((_BYTE)p_paths_log_id_num)
          {
            *(void *)os_log_type_t v75 = v31;
            BOOL v45 = __nw_create_backtrace_string();
            logc = __nwlog_obj();
            os_log_type_t v69 = v91[0];
            BOOL v46 = os_log_type_enabled(logc, v91[0]);
            os_log_type_t v71 = (char *)v45;
            if (v45)
            {
              if (v46)
              {
                id v47 = *(const char **)(v19 + 16);
                if (!v47) {
                  id v47 = "invalid";
                }
                *(_DWORD *)os_log_type_t v93 = 136446978;
                *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
                *(_WORD *)&v93[12] = 2082;
                *(void *)&v93[14] = v47;
                *(_WORD *)&v93[22] = 2048;
                BOOL v94 = (const char *)v19;
                LOWORD(v95) = 2082;
                *(void *)((char *)&v95 + 2) = v45;
                _os_log_impl(&dword_1830D4000, logc, v69, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", v93, 0x2Au);
              }

              uint64_t v31 = *(char **)v75;
              free(v71);
            }
            else
            {
              if (v46)
              {
                nw_endpoint_t v58 = *(const char **)(v19 + 16);
                if (!v58) {
                  nw_endpoint_t v58 = "invalid";
                }
                *(_DWORD *)os_log_type_t v93 = 136446722;
                *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
                *(_WORD *)&v93[12] = 2082;
                *(void *)&v93[14] = v58;
                *(_WORD *)&v93[22] = 2048;
                BOOL v94 = (const char *)v19;
                _os_log_impl(&dword_1830D4000, logc, v69, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace", v93, 0x20u);
              }

              uint64_t v31 = *(char **)v75;
            }
            goto LABEL_135;
          }
          os_log_t logb = __nwlog_obj();
          os_log_type_t v77 = v91[0];
          if (os_log_type_enabled(logb, v91[0]))
          {
            uint64_t v56 = *(const char **)(v19 + 16);
            if (!v56) {
              uint64_t v56 = "invalid";
            }
            *(_DWORD *)os_log_type_t v93 = 136446722;
            *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
            *(_WORD *)&v93[12] = 2082;
            *(void *)&v93[14] = v56;
            *(_WORD *)&v93[22] = 2048;
            BOOL v94 = (const char *)v19;
            _os_log_impl(&dword_1830D4000, logb, v77, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded", v93, 0x20u);
          }
        }
      }
LABEL_135:
      if (v31) {
        free(v31);
      }
      goto LABEL_44;
    }
    BOOL v40 = __nwlog_obj();
    *(_DWORD *)os_log_type_t v93 = 136446210;
    *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
    os_log_type_t v41 = (char *)_os_log_send_and_compose_impl();

    buf[0] = 16;
    v91[0] = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v41, buf, v91))
    {
      if (buf[0] == 17)
      {
        os_log_type_t v42 = __nwlog_obj();
        os_log_type_t v43 = buf[0];
        if (os_log_type_enabled(v42, (os_log_type_t)buf[0]))
        {
          *(_DWORD *)os_log_type_t v93 = 136446210;
          *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
          _os_log_impl(&dword_1830D4000, v42, v43, "%{public}s called with null protocol", v93, 0xCu);
        }
      }
      else
      {
        if (v91[0])
        {
          int v52 = (char *)__nw_create_backtrace_string();
          id v53 = __nwlog_obj();
          os_log_type_t logd = buf[0];
          BOOL v54 = os_log_type_enabled(v53, (os_log_type_t)buf[0]);
          if (v52)
          {
            if (v54)
            {
              *(_DWORD *)os_log_type_t v93 = 136446466;
              *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
              *(_WORD *)&v93[12] = 2082;
              *(void *)&v93[14] = v52;
              _os_log_impl(&dword_1830D4000, v53, logd, "%{public}s called with null protocol, dumping backtrace:%{public}s", v93, 0x16u);
            }

            free(v52);
            goto LABEL_149;
          }
          if (v54)
          {
            *(_DWORD *)os_log_type_t v93 = 136446210;
            *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v53, logd, "%{public}s called with null protocol, no backtrace", v93, 0xCu);
          }
        }
        else
        {
          id v53 = __nwlog_obj();
          os_log_type_t v59 = buf[0];
          if (os_log_type_enabled(v53, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)os_log_type_t v93 = 136446210;
            *(void *)&v93[4] = "__nw_protocol_finalize_output_frames";
            _os_log_impl(&dword_1830D4000, v53, v59, "%{public}s called with null protocol, backtrace limit exceeded", v93, 0xCu);
          }
        }
      }
    }
LABEL_149:
    if (v41) {
      free(v41);
    }
LABEL_46:
    flow_registration = (char *)v4->flow_registration;
    if (flow_registration)
    {
      v83[0] = MEMORY[0x1E4F143A8];
      v83[1] = 3221225472;
      v83[2] = ___ZL31nw_protocol_implementation_readP31NWConcrete_nw_protocol_instanceP11nw_protocol_block_invoke;
      v83[3] = &unk_1E524AF58;
      id v84 = v8;
      nw_hash_table_apply(flow_registration, (uint64_t)v83);
    }
    char v5 = BYTE4(v4->flow_in_connected);
    if ((v5 & 0x40) != 0 || v15 && (v4->flow_in_connected & 0x2000000000) == 0) {
      break;
    }
    if (!v15) {
      goto LABEL_152;
    }
  }
  BYTE4(v4->flow_in_connected) = v5 | 0x40;
LABEL_152:
  nw_protocol_implementation_deliver_output_available(v8);
LABEL_157:
}

void sub_1831C7D58(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t ___ZL45nw_protocol_implementation_get_input_internalP31NWConcrete_nw_protocol_instanceP11nw_protocolmjjj_block_invoke(void *a1, void *a2)
{
  id v3 = a2;
  id v4 = v3;
  id v6 = v3 + 4;
  uint64_t v5 = v3[4];
  unint64_t v7 = (void *)v3[5];
  if (v5)
  {
    *(void *)(v5 + 40) = v7;
    unint64_t v7 = (void *)v3[5];
  }
  else
  {
    *(void *)(a1[5] + 8) = v7;
  }
  *unint64_t v7 = v5;
  void *v6 = 0;
  v3[5] = 0;
  uint64_t v8 = a1[4];
  uint64_t v9 = *(void *)(v8 + 8);
  os_log_type_t v10 = *(void (**)(uint64_t, uint64_t, void *, void *, void))(*(void *)(v9 + 80) + 56);
  uint64_t v11 = a1[6];
  uint64_t v12 = nw_frame_copy_metadata_for_protocol((uint64_t)v3, v9);
  v10(v8, v11, v4, v12, 0);

  if (!*v6 && !v4[5] && (v4[2] || v4[3])) {
    nw_frame_finalize((uint64_t)v4);
  }

  return 1;
}

void sub_1831C7E80(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_channel_finalize_input_frame(nw_frame *a1, BOOL a2, void *a3)
{
  uint64_t v43 = *MEMORY[0x1E4F143B8];
  uint64_t v5 = *((void *)a1 + 2);
  id v6 = (void *)*((void *)a1 + 3);
  unint64_t v7 = (void *)((char *)a1 + 16);
  if (v5)
  {
    *(void *)(v5 + 24) = v6;
    id v6 = (void *)*((void *)a1 + 3);
  }
  else
  {
    a3[41] = v6;
  }
  void *v6 = v5;
  *unint64_t v7 = 0;
  *((void *)a1 + 3) = 0;
  metadata = (void *)nw_frame_get_metadata((uint64_t)a1);
  if (metadata)
  {
    uint64_t v9 = metadata;
    if (*metadata)
    {
      int v10 = *((unsigned __int16 *)a3 + 222);
      if ((v10 & 0x1000) == 0) {
        goto LABEL_22;
      }
      if (!a3[17])
      {
        if (_nw_signposts_once != -1) {
          dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
        }
        if (_nw_signposts_enabled && kdebug_is_enabled()) {
          kdebug_trace();
        }
        goto LABEL_22;
      }
      if (((v10 | (*((unsigned __int8 *)a3 + 446) << 16)) & 0x80000) != 0)
      {
LABEL_22:
        *uint64_t v9 = 0;
        v9[1] = 0;
        goto LABEL_23;
      }
      if (os_channel_is_defunct())
      {
        nw_channel_handle_defunct((uint64_t)a3);
        goto LABEL_22;
      }
      *(_WORD *)os_log_type_t type = 0;
      if ((*((_WORD *)a1 + 102) & 0x2000) == 0 || (int v11 = os_packet_decrement_use_count()) == 0)
      {
LABEL_18:
        if (((*((_WORD *)a1 + 102) & 0x2000) == 0 || !*(_WORD *)type) && os_channel_packet_free()) {
          nw_channel_check_defunct((uint64_t)a3);
        }
        goto LABEL_22;
      }
      int v26 = v11;
      if (nw_channel_check_defunct((uint64_t)a3)) {
        goto LABEL_22;
      }
      id v33 = v7;
      __nwlog_obj();
      *(_DWORD *)buf = 136446466;
      BOOL v38 = "nw_channel_finalize_input_frame";
      __int16 v39 = 1024;
      int v40 = v26;
      __int16 v27 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v35 = OS_LOG_TYPE_ERROR;
      char v34 = 0;
      if (__nwlog_fault(v27, &v35, &v34))
      {
        if (v35 == OS_LOG_TYPE_FAULT)
        {
          char v28 = __nwlog_obj();
          os_log_type_t v29 = v35;
          if (os_log_type_enabled(v28, v35))
          {
            *(_DWORD *)buf = 136446466;
            BOOL v38 = "nw_channel_finalize_input_frame";
            __int16 v39 = 1024;
            int v40 = v26;
            os_log_type_t v30 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d";
LABEL_78:
            _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0x12u);
          }
        }
        else if (v34)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          char v28 = __nwlog_obj();
          os_log_type_t v29 = v35;
          BOOL v32 = os_log_type_enabled(v28, v35);
          if (backtrace_string)
          {
            if (v32)
            {
              *(_DWORD *)buf = 136446722;
              BOOL v38 = "nw_channel_finalize_input_frame";
              __int16 v39 = 1024;
              int v40 = v26;
              __int16 v41 = 2082;
              os_log_type_t v42 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(backtrace_string);
            goto LABEL_79;
          }
          if (v32)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v38 = "nw_channel_finalize_input_frame";
            __int16 v39 = 1024;
            int v40 = v26;
            os_log_type_t v30 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, no backtrace";
            goto LABEL_78;
          }
        }
        else
        {
          char v28 = __nwlog_obj();
          os_log_type_t v29 = v35;
          if (os_log_type_enabled(v28, v35))
          {
            *(_DWORD *)buf = 136446466;
            BOOL v38 = "nw_channel_finalize_input_frame";
            __int16 v39 = 1024;
            int v40 = v26;
            os_log_type_t v30 = "%{public}s os_packet_decrement_use_count() %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_78;
          }
        }
      }
LABEL_79:
      if (v27) {
        free(v27);
      }
      unint64_t v7 = v33;
      goto LABEL_18;
    }
  }
LABEL_23:
  *((void *)a1 + 2) = 0;
  uint64_t v12 = (void *)a3[37];
  *((void *)a1 + 3) = v12;
  void *v12 = a1;
  a3[37] = v7;
  if (a3[40]) {
    return;
  }
  *((_DWORD *)a3 + 104) = 0;
  if (a3[50] && a3[28])
  {
    int v13 = os_channel_advance_slot();
    if (!v13 || (int v19 = v13, (nw_channel_check_defunct((uint64_t)a3) & 1) != 0))
    {
LABEL_28:
      a3[50] = 0;
      goto LABEL_29;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446466;
    BOOL v38 = "nw_channel_finalize_input_frame";
    __int16 v39 = 1024;
    int v40 = v19;
    char v20 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    os_log_type_t v35 = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v20, type, &v35))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v38 = "nw_channel_finalize_input_frame";
        __int16 v39 = 1024;
        int v40 = v19;
        uint64_t v23 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d";
        goto LABEL_66;
      }
      if (v35 == OS_LOG_TYPE_DEFAULT)
      {
        uint64_t v21 = __nwlog_obj();
        os_log_type_t v22 = type[0];
        if (!os_log_type_enabled(v21, type[0])) {
          goto LABEL_67;
        }
        *(_DWORD *)buf = 136446466;
        BOOL v38 = "nw_channel_finalize_input_frame";
        __int16 v39 = 1024;
        int v40 = v19;
        uint64_t v23 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_66;
      }
      __int16 v24 = (char *)__nw_create_backtrace_string();
      uint64_t v21 = __nwlog_obj();
      os_log_type_t v22 = type[0];
      BOOL v25 = os_log_type_enabled(v21, type[0]);
      if (v24)
      {
        if (v25)
        {
          *(_DWORD *)buf = 136446722;
          BOOL v38 = "nw_channel_finalize_input_frame";
          __int16 v39 = 1024;
          int v40 = v19;
          __int16 v41 = 2082;
          os_log_type_t v42 = v24;
          _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v24);
        goto LABEL_67;
      }
      if (v25)
      {
        *(_DWORD *)buf = 136446466;
        BOOL v38 = "nw_channel_finalize_input_frame";
        __int16 v39 = 1024;
        int v40 = v19;
        uint64_t v23 = "%{public}s os_channel_advance_slot(rx) %{darwin.errno}d, no backtrace";
LABEL_66:
        _os_log_impl(&dword_1830D4000, v21, v22, v23, buf, 0x12u);
      }
    }
LABEL_67:
    if (v20) {
      free(v20);
    }
    goto LABEL_28;
  }
LABEL_29:
  os_log_type_t v14 = (_WORD *)a3 + 222;
  if ((*((_WORD *)a3 + 222) & 4) != 0)
  {
    int v15 = (void *)a3[21];
    if (v15)
    {
      if (*v15 && _dispatch_source_will_reenable_kevent_4NW() && a3[21] && (*v14 & 8) != 0) {
        goto LABEL_42;
      }
    }
  }
  if (!a3[17]) {
    goto LABEL_42;
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_73_88215);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  if (!os_channel_sync())
  {
LABEL_42:
    uint64_t v16 = a3[21];
    if (!v16) {
      return;
    }
  }
  else
  {
    nw_channel_check_defunct((uint64_t)a3);
    uint64_t v16 = a3[21];
    if (!v16) {
      return;
    }
  }
  int v17 = (unsigned __int16)*v14;
  if ((v17 & 8) != 0)
  {
    unsigned int v18 = v17 & 0xFFFFFFF7 | (*((unsigned __int8 *)a3 + 446) << 16);
    _WORD *v14 = v17 & 0xFFF7;
    *((unsigned char *)a3 + 446) = BYTE2(v18);
    nw_queue_resume_source(v16);
  }
}

void nw_queue_resume_source(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    id v4 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v15 = "nw_queue_resume_source";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v5, &type, &v12)) {
      goto LABEL_30;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        int v15 = "nw_queue_resume_source";
        uint64_t v8 = "%{public}s called with null source";
LABEL_28:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        id v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)buf = 136446466;
            int v15 = "nw_queue_resume_source";
            __int16 v16 = 2082;
            int v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_30;
        }
        if (!v10) {
          goto LABEL_29;
        }
        *(_DWORD *)buf = 136446210;
        int v15 = "nw_queue_resume_source";
        uint64_t v8 = "%{public}s called with null source, no backtrace";
        goto LABEL_28;
      }
      id v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        int v15 = "nw_queue_resume_source";
        uint64_t v8 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_28;
      }
    }
LABEL_29:

LABEL_30:
    if (v5) {
      free(v5);
    }
    return;
  }
  nw_interface_t v2 = *(NSObject **)a1;
  if (v2)
  {
    dispatch_resume(v2);
    return;
  }
  if (*(unsigned char *)(a1 + 48))
  {
    if (*(unsigned char *)(a1 + 49)) {
      return;
    }
    nw_queue_source_run_timer(a1);
    goto LABEL_12;
  }
  id v3 = *(void **)(a1 + 16);
  if (v3)
  {
    if (*(unsigned char *)(a1 + 49)) {
      return;
    }
    nw_context_queue_source_block(*(void **)(a1 + 8), v3);
LABEL_12:
    *(unsigned char *)(a1 + 49) = 1;
    return;
  }
  if (gLogDatapath)
  {
    int v11 = __nwlog_obj();
    if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)buf = 136446210;
      int v15 = "nw_queue_resume_source";
      _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not resuming source", buf, 0xCu);
    }
  }
}

void *nw_frame_copy_metadata_for_protocol(uint64_t a1, uint64_t a2)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      int v13 = "%{public}s called with null frame";
      goto LABEL_41;
    }
    if (!v18)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      int v13 = "%{public}s called with null frame, backtrace limit exceeded";
      goto LABEL_41;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    int v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v15 = os_log_type_enabled(v11, type);
    if (!backtrace_string)
    {
      if (!v15) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      int v13 = "%{public}s called with null frame, no backtrace";
      goto LABEL_41;
    }
    if (v15)
    {
      *(_DWORD *)buf = 136446466;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      __int16 v22 = 2082;
      uint64_t v23 = backtrace_string;
      _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(backtrace_string);
LABEL_42:
    if (!v10) {
      return 0;
    }
LABEL_43:
    free(v10);
    return 0;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
    BOOL v10 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v18 = 0;
    if (!__nwlog_fault(v10, &type, &v18)) {
      goto LABEL_42;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      int v13 = "%{public}s called with null definition";
      goto LABEL_41;
    }
    if (!v18)
    {
      int v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (!os_log_type_enabled(v11, type)) {
        goto LABEL_42;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      int v13 = "%{public}s called with null definition, backtrace limit exceeded";
      goto LABEL_41;
    }
    __int16 v16 = (char *)__nw_create_backtrace_string();
    int v11 = __nwlog_obj();
    os_log_type_t v12 = type;
    BOOL v17 = os_log_type_enabled(v11, type);
    if (v16)
    {
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
        __int16 v22 = 2082;
        uint64_t v23 = v16;
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null definition, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v16);
      if (!v10) {
        return 0;
      }
      goto LABEL_43;
    }
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v21 = "__nw_frame_copy_metadata_for_protocol";
      int v13 = "%{public}s called with null definition, no backtrace";
LABEL_41:
      _os_log_impl(&dword_1830D4000, v11, v12, v13, buf, 0xCu);
      goto LABEL_42;
    }
    goto LABEL_42;
  }
  id v3 = *(void **)(a1 + 64);
  if (!v3) {
    return 0;
  }
  while (1)
  {
    uint64_t v5 = (void *)v3[6];
    if (v5)
    {
      id v6 = v5;
      id v7 = v6[1];

      BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe(a2, (uint64_t)v7);
      if (v7) {
        os_release(v7);
      }
      if (is_equal_unsafe) {
        break;
      }
    }
    id v3 = (void *)*v3;
    if (!v3) {
      return 0;
    }
  }
  uint64_t v9 = (void *)v3[6];
  if (!v9) {
    return 0;
  }

  return os_retain(v9);
}

void nw_protocol_implementation_deliver_output_available(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = v1;
  char v3 = BYTE5(v1->flow_in_connected);
  if (v3)
  {
    if (v1->parent_definition->variant == 3)
    {
      BYTE5(v1->flow_in_connected) = v3 & 0xFE;
      tqh_last = (char *)v1->pending_outbound_frames.tqh_last;
      v31[0] = MEMORY[0x1E4F143A8];
      v31[1] = 3221225472;
      v31[2] = ___ZL51nw_protocol_implementation_deliver_output_availableP31NWConcrete_nw_protocol_instance_block_invoke;
      v31[3] = &unk_1E524AF58;
      BOOL v32 = v1;
      nw_hash_table_apply(tqh_last, (uint64_t)v31);

      goto LABEL_2;
    }
    uint64_t v5 = *(void **)&v1[-1].log_str[41];
    if (v5)
    {
      uint64_t v6 = v5[3];
      if (v6)
      {
        if (*(void *)(v6 + 72))
        {
          BYTE5(v2->flow_in_connected) = v3 & 0xFE;
          id v7 = (void *)v5[5];
          if (v7 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v9 = v5[11];
            if (v9) {
              v5[11] = v9 + 1;
            }
            char v8 = -1;
          }
          else
          {
            char v8 = 0;
          }
          BOOL v37 = v5;
          char v38 = v8;
          BOOL v10 = *(void **)&v2[-1].log_str[33];
          if (v10 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v12 = *(void *)&v2[-1].log_str[81];
            if (v12) {
              *(void *)&v2[-1].log_str[81] = v12 + 1;
            }
            char v11 = -1;
          }
          else
          {
            char v11 = 0;
          }
          p_paths_log_id_num = &v2[-1].paths_log_id_num;
          char v36 = v11;
          uint64_t v13 = v5[3];
          if (v13)
          {
            os_log_type_t v14 = *(void (**)(void))(v13 + 72);
            if (v14)
            {
              v14();
              if (v10 != &nw_protocol_ref_counted_handle) {
                goto LABEL_23;
              }
              goto LABEL_22;
            }
          }
          os_log_type_t v30 = v10;
          BOOL v15 = v5;
          __int16 v16 = __nwlog_obj();
          BOOL v17 = (const char *)v15[2];
          *(_DWORD *)buf = 136446722;
          int v40 = "__nw_protocol_output_available";
          if (!v17) {
            BOOL v17 = "invalid";
          }
          __int16 v41 = 2082;
          os_log_type_t v42 = v17;
          __int16 v43 = 2048;
          char v18 = v15;
          id v44 = v15;
          int v19 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v33 = 0;
          if (__nwlog_fault(v19, &type, &v33))
          {
            if (type == OS_LOG_TYPE_FAULT)
            {
              char v20 = __nwlog_obj();
              os_log_type_t v21 = type;
              if (os_log_type_enabled(v20, type))
              {
                __int16 v22 = (const char *)v18[2];
                if (!v22) {
                  __int16 v22 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                int v40 = "__nw_protocol_output_available";
                __int16 v41 = 2082;
                os_log_type_t v42 = v22;
                __int16 v43 = 2048;
                id v44 = v18;
                _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s protocol %{public}s (%p) has invalid output_available callback", buf, 0x20u);
              }
LABEL_50:

              goto LABEL_51;
            }
            if (!v33)
            {
              char v20 = __nwlog_obj();
              os_log_type_t v27 = type;
              if (os_log_type_enabled(v20, type))
              {
                char v28 = (const char *)v18[2];
                if (!v28) {
                  char v28 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                int v40 = "__nw_protocol_output_available";
                __int16 v41 = 2082;
                os_log_type_t v42 = v28;
                __int16 v43 = 2048;
                id v44 = v18;
                _os_log_impl(&dword_1830D4000, v20, v27, "%{public}s protocol %{public}s (%p) has invalid output_available callback, backtrace limit exceeded", buf, 0x20u);
              }
              goto LABEL_50;
            }
            backtrace_string = (char *)__nw_create_backtrace_string();
            char v20 = __nwlog_obj();
            os_log_type_t v24 = type;
            BOOL v25 = os_log_type_enabled(v20, type);
            if (!backtrace_string)
            {
              if (v25)
              {
                os_log_type_t v29 = (const char *)v18[2];
                if (!v29) {
                  os_log_type_t v29 = "invalid";
                }
                *(_DWORD *)buf = 136446722;
                int v40 = "__nw_protocol_output_available";
                __int16 v41 = 2082;
                os_log_type_t v42 = v29;
                __int16 v43 = 2048;
                id v44 = v18;
                _os_log_impl(&dword_1830D4000, v20, v24, "%{public}s protocol %{public}s (%p) has invalid output_available callback, no backtrace", buf, 0x20u);
              }
              goto LABEL_50;
            }
            if (v25)
            {
              int v26 = (const char *)v18[2];
              if (!v26) {
                int v26 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              int v40 = "__nw_protocol_output_available";
              __int16 v41 = 2082;
              os_log_type_t v42 = v26;
              __int16 v43 = 2048;
              id v44 = v18;
              __int16 v45 = 2082;
              BOOL v46 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v20, v24, "%{public}s protocol %{public}s (%p) has invalid output_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(backtrace_string);
          }
LABEL_51:
          if (v19) {
            free(v19);
          }
          if (v30 != &nw_protocol_ref_counted_handle) {
            goto LABEL_23;
          }
LABEL_22:
          nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
LABEL_23:
          if (v7 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)&v37);
          }
        }
      }
    }
  }
LABEL_2:
}

void sub_1831C91E8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, ...)
{
  va_start(va1, a13);
  va_start(va, a13);
  uint64_t v18 = va_arg(va1, void);
  uint64_t v20 = va_arg(va1, void);
  if (v15 == v14) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v16 == v14) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

void nw_protocol_instance_flush_batched_input_internal(NWConcrete_nw_protocol_instance *a1)
{
  uint64_t v84 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_interface_t v2 = v1;
  parent_definition = v1->parent_definition;
  var11 = (void (*)(NWConcrete_nw_protocol_instance *))parent_definition->extended_state->var11;
  if (var11)
  {
    var11(v1);
    parent_definition = v2->parent_definition;
  }
  char v5 = BYTE3(v2->flow_in_connected) & 0xEF;
  BYTE3(v2->flow_in_connected) = v5;
  if (parent_definition->variant == 3)
  {
    tqh_last = (char *)v2->pending_outbound_frames.tqh_last;
    v68[0] = MEMORY[0x1E4F143A8];
    v68[1] = 3221225472;
    v68[2] = ___ZL49nw_protocol_instance_flush_batched_input_internalP31NWConcrete_nw_protocol_instance_block_invoke;
    v68[3] = &unk_1E524AF58;
    os_log_type_t v69 = v2;
    nw_hash_table_apply(tqh_last, (uint64_t)v68);

    goto LABEL_45;
  }
  if ((v2->flow_in_connected & 0x80000) == 0) {
    goto LABEL_45;
  }
  if (v2->empty_frame_pool.tqh_first)
  {
    id v7 = *(void **)&v2[-1].log_str[41];
    if (v7)
    {
      char v8 = (void *)v7[5];
      if (v8 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v10 = v7[11];
        if (v10) {
          v7[11] = v10 + 1;
        }
        char v9 = -1;
      }
      else
      {
        char v9 = 0;
      }
      *(void *)unsigned int v74 = v7;
      char v75 = v9;
      char v11 = *(void **)&v2[-1].log_str[33];
      if (v11 == &nw_protocol_ref_counted_handle)
      {
        uint64_t v13 = *(void *)&v2[-1].log_str[81];
        if (v13) {
          *(void *)&v2[-1].log_str[81] = v13 + 1;
        }
        char v12 = -1;
      }
      else
      {
        char v12 = 0;
      }
      p_paths_log_id_num = &v2[-1].paths_log_id_num;
      char v73 = v12;
      uint64_t v14 = v7[3];
      if (v14)
      {
        uint64_t v15 = *(void (**)(void *, unsigned __int16 *))(v14 + 64);
        if (v15)
        {
          v15(v7, &v2[-1].paths_log_id_num);
LABEL_21:
          if (v11 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
          }
          if (v8 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)v74);
          }
LABEL_25:
          char v5 = BYTE3(v2->flow_in_connected);
          goto LABEL_26;
        }
      }
      BOOL v25 = __nwlog_obj();
      int v26 = (const char *)v7[2];
      os_log_type_t v27 = "invalid";
      *(_DWORD *)buf = 136446722;
      os_log_type_t v77 = "__nw_protocol_input_available";
      if (v26) {
        os_log_type_t v27 = v26;
      }
      __int16 v78 = 2082;
      os_log_type_t v79 = (void *)v27;
      __int16 v80 = 2048;
      os_log_type_t v81 = v7;
      char v28 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v70 = 0;
      if (__nwlog_fault(v28, &type, &v70))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v30 = type;
          if (os_log_type_enabled(v29, type))
          {
            uint64_t v31 = (const char *)v7[2];
            if (!v31) {
              uint64_t v31 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            os_log_type_t v79 = (void *)v31;
            __int16 v80 = 2048;
            os_log_type_t v81 = v7;
            _os_log_impl(&dword_1830D4000, v29, v30, "%{public}s protocol %{public}s (%p) has invalid input_available callback", buf, 0x20u);
          }
        }
        else if (v70)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v43 = type;
          BOOL v44 = os_log_type_enabled(v29, type);
          if (backtrace_string)
          {
            if (v44)
            {
              __int16 v45 = (const char *)v7[2];
              if (!v45) {
                __int16 v45 = "invalid";
              }
              *(_DWORD *)buf = 136446978;
              os_log_type_t v77 = "__nw_protocol_input_available";
              __int16 v78 = 2082;
              os_log_type_t v79 = (void *)v45;
              __int16 v80 = 2048;
              os_log_type_t v81 = v7;
              __int16 v82 = 2082;
              os_log_type_t v83 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v29, v43, "%{public}s protocol %{public}s (%p) has invalid input_available callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(backtrace_string);
            goto LABEL_113;
          }
          if (v44)
          {
            os_log_type_t v64 = (const char *)v7[2];
            if (!v64) {
              os_log_type_t v64 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            os_log_type_t v79 = (void *)v64;
            __int16 v80 = 2048;
            os_log_type_t v81 = v7;
            _os_log_impl(&dword_1830D4000, v29, v43, "%{public}s protocol %{public}s (%p) has invalid input_available callback, no backtrace", buf, 0x20u);
          }
        }
        else
        {
          os_log_type_t v29 = __nwlog_obj();
          os_log_type_t v60 = type;
          if (os_log_type_enabled(v29, type))
          {
            uint64_t v61 = (const char *)v7[2];
            if (!v61) {
              uint64_t v61 = "invalid";
            }
            *(_DWORD *)buf = 136446722;
            os_log_type_t v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            os_log_type_t v79 = (void *)v61;
            __int16 v80 = 2048;
            os_log_type_t v81 = v7;
            _os_log_impl(&dword_1830D4000, v29, v60, "%{public}s protocol %{public}s (%p) has invalid input_available callback, backtrace limit exceeded", buf, 0x20u);
          }
        }
      }
LABEL_113:
      if (v28) {
        free(v28);
      }
      goto LABEL_21;
    }
    char v38 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v77 = "__nw_protocol_input_available";
    __int16 v39 = (char *)_os_log_send_and_compose_impl();

    v74[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(p_paths_log_id_num) = 0;
    if (__nwlog_fault(v39, v74, &p_paths_log_id_num))
    {
      if (v74[0] == OS_LOG_TYPE_FAULT)
      {
        int v40 = __nwlog_obj();
        os_log_type_t v41 = v74[0];
        if (os_log_type_enabled(v40, v74[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v77 = "__nw_protocol_input_available";
          _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if ((_BYTE)p_paths_log_id_num)
      {
        BOOL v54 = (char *)__nw_create_backtrace_string();
        int v40 = __nwlog_obj();
        os_log_type_t v55 = v74[0];
        BOOL v56 = os_log_type_enabled(v40, v74[0]);
        if (v54)
        {
          if (v56)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v77 = "__nw_protocol_input_available";
            __int16 v78 = 2082;
            os_log_type_t v79 = v54;
            _os_log_impl(&dword_1830D4000, v40, v55, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v54);
          goto LABEL_131;
        }
        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v77 = "__nw_protocol_input_available";
          _os_log_impl(&dword_1830D4000, v40, v55, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v40 = __nwlog_obj();
        os_log_type_t v65 = v74[0];
        if (os_log_type_enabled(v40, v74[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v77 = "__nw_protocol_input_available";
          _os_log_impl(&dword_1830D4000, v40, v65, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_131:
    if (v39) {
      free(v39);
    }
    goto LABEL_25;
  }
LABEL_26:
  if ((v5 & 0x40) == 0) {
    goto LABEL_45;
  }
  BYTE3(v2->flow_in_connected) = v5 & 0xBF;
  uint64_t v16 = *(void **)&v2[-1].log_str[41];
  if (v16)
  {
    BOOL v17 = (void *)v16[5];
    if (v17 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v19 = v16[11];
      if (v19) {
        v16[11] = v19 + 1;
      }
      char v18 = -1;
    }
    else
    {
      char v18 = 0;
    }
    *(void *)unsigned int v74 = v16;
    char v75 = v18;
    uint64_t v20 = *(void **)&v2[-1].log_str[33];
    if (v20 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v22 = *(void *)&v2[-1].log_str[81];
      if (v22) {
        *(void *)&v2[-1].log_str[81] = v22 + 1;
      }
      char v21 = -1;
    }
    else
    {
      char v21 = 0;
    }
    p_paths_log_id_num = &v2[-1].paths_log_id_num;
    char v73 = v21;
    uint64_t v23 = v16[3];
    if (v23)
    {
      os_log_type_t v24 = *(void (**)(void *, unsigned __int16 *))(v23 + 184);
      if (v24)
      {
        v24(v16, &v2[-1].paths_log_id_num);
LABEL_41:
        if (v20 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)&p_paths_log_id_num);
        }
        if (v17 == &nw_protocol_ref_counted_handle) {
          nw::release_if_needed<nw_protocol *>((uint64_t *)v74);
        }
        goto LABEL_45;
      }
    }
    BOOL v32 = __nwlog_obj();
    char v33 = (const char *)v16[2];
    *(_DWORD *)buf = 136446722;
    os_log_type_t v77 = "__nw_protocol_input_finished";
    if (!v33) {
      char v33 = "invalid";
    }
    __int16 v78 = 2082;
    os_log_type_t v79 = (void *)v33;
    __int16 v80 = 2048;
    os_log_type_t v81 = v16;
    char v34 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v70 = 0;
    if (__nwlog_fault(v34, &type, &v70))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v35 = __nwlog_obj();
        os_log_type_t v36 = type;
        if (os_log_type_enabled(v35, type))
        {
          BOOL v37 = (const char *)v16[2];
          if (!v37) {
            BOOL v37 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v77 = "__nw_protocol_input_finished";
          __int16 v78 = 2082;
          os_log_type_t v79 = (void *)v37;
          __int16 v80 = 2048;
          os_log_type_t v81 = v16;
          _os_log_impl(&dword_1830D4000, v35, v36, "%{public}s protocol %{public}s (%p) has invalid input_finished callback", buf, 0x20u);
        }
      }
      else if (v70)
      {
        BOOL v50 = (char *)__nw_create_backtrace_string();
        os_log_type_t v35 = __nwlog_obj();
        os_log_type_t v51 = type;
        BOOL v52 = os_log_type_enabled(v35, type);
        if (v50)
        {
          if (v52)
          {
            id v53 = (const char *)v16[2];
            if (!v53) {
              id v53 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            os_log_type_t v77 = "__nw_protocol_input_finished";
            __int16 v78 = 2082;
            os_log_type_t v79 = (void *)v53;
            __int16 v80 = 2048;
            os_log_type_t v81 = v16;
            __int16 v82 = 2082;
            os_log_type_t v83 = v50;
            _os_log_impl(&dword_1830D4000, v35, v51, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v50);
          goto LABEL_123;
        }
        if (v52)
        {
          os_log_type_t v66 = (const char *)v16[2];
          if (!v66) {
            os_log_type_t v66 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v77 = "__nw_protocol_input_finished";
          __int16 v78 = 2082;
          os_log_type_t v79 = (void *)v66;
          __int16 v80 = 2048;
          os_log_type_t v81 = v16;
          _os_log_impl(&dword_1830D4000, v35, v51, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        os_log_type_t v35 = __nwlog_obj();
        os_log_type_t v62 = type;
        if (os_log_type_enabled(v35, type))
        {
          uint64_t v63 = (const char *)v16[2];
          if (!v63) {
            uint64_t v63 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          os_log_type_t v77 = "__nw_protocol_input_finished";
          __int16 v78 = 2082;
          os_log_type_t v79 = (void *)v63;
          __int16 v80 = 2048;
          os_log_type_t v81 = v16;
          _os_log_impl(&dword_1830D4000, v35, v62, "%{public}s protocol %{public}s (%p) has invalid input_finished callback, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
LABEL_123:
    if (v34) {
      free(v34);
    }
    goto LABEL_41;
  }
  BOOL v46 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v77 = "__nw_protocol_input_finished";
  uint64_t v47 = (char *)_os_log_send_and_compose_impl();

  v74[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(p_paths_log_id_num) = 0;
  if (__nwlog_fault(v47, v74, &p_paths_log_id_num))
  {
    if (v74[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v48 = __nwlog_obj();
      os_log_type_t v49 = v74[0];
      if (os_log_type_enabled(v48, v74[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_1830D4000, v48, v49, "%{public}s called with null protocol", buf, 0xCu);
      }
    }
    else if ((_BYTE)p_paths_log_id_num)
    {
      os_log_type_t v57 = (char *)__nw_create_backtrace_string();
      BOOL v48 = __nwlog_obj();
      os_log_type_t v58 = v74[0];
      BOOL v59 = os_log_type_enabled(v48, v74[0]);
      if (v57)
      {
        if (v59)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v77 = "__nw_protocol_input_finished";
          __int16 v78 = 2082;
          os_log_type_t v79 = v57;
          _os_log_impl(&dword_1830D4000, v48, v58, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v57);
        goto LABEL_136;
      }
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_1830D4000, v48, v58, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v48 = __nwlog_obj();
      os_log_type_t v67 = v74[0];
      if (os_log_type_enabled(v48, v74[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v77 = "__nw_protocol_input_finished";
        _os_log_impl(&dword_1830D4000, v48, v67, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_136:
  if (v47) {
    free(v47);
  }
LABEL_45:
}

void sub_1831C9EAC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va1, a11);
  va_start(va, a11);
  uint64_t v16 = va_arg(va1, void);
  uint64_t v18 = va_arg(va1, void);
  if (v14 == v12) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va);
  }
  if (v13 == v12) {
    nw::release_if_needed<nw_protocol *>((uint64_t *)va1);
  }

  _Unwind_Resume(a1);
}

uint64_t nw_protocol_instance_access_state(uint64_t a1, uint64_t a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    char v5 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_instance_access_state";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_instance_access_state";
        char v9 = "%{public}s called with null instance";
LABEL_34:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      BOOL v12 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v12)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v18 = "nw_protocol_instance_access_state";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null instance, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_36:
        if (!v6) {
          return 0;
        }
LABEL_37:
        free(v6);
        return 0;
      }
      if (v12)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_instance_access_state";
        char v9 = "%{public}s called with null instance, no backtrace";
        goto LABEL_34;
      }
    }
    else
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_instance_access_state";
        char v9 = "%{public}s called with null instance, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
LABEL_35:

    goto LABEL_36;
  }
  if (!a2)
  {
    uint64_t v10 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v18 = "nw_protocol_instance_access_state";
    uint64_t v6 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v6, &type, &v15)) {
      goto LABEL_36;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_instance_access_state";
        char v9 = "%{public}s called with null access_block";
        goto LABEL_34;
      }
    }
    else
    {
      if (v15)
      {
        uint64_t v13 = (char *)__nw_create_backtrace_string();
        id v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v14 = os_log_type_enabled(v7, type);
        if (v13)
        {
          if (v14)
          {
            *(_DWORD *)buf = 136446466;
            uint64_t v18 = "nw_protocol_instance_access_state";
            __int16 v19 = 2082;
            uint64_t v20 = v13;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null access_block, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v13);
          if (!v6) {
            return 0;
          }
          goto LABEL_37;
        }
        if (!v14) {
          goto LABEL_35;
        }
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_instance_access_state";
        char v9 = "%{public}s called with null access_block, no backtrace";
        goto LABEL_34;
      }
      id v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v18 = "nw_protocol_instance_access_state";
        char v9 = "%{public}s called with null access_block, backtrace limit exceeded";
        goto LABEL_34;
      }
    }
    goto LABEL_35;
  }
  uint64_t v2 = *(void *)(a1 + 112);
  if (!v2) {
    return 0;
  }
  char v3 = *(uint64_t (**)(uint64_t, uint64_t))(a2 + 16);

  return v3(a2, v2);
}

uint64_t nw_protocol_udp_get_input_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v136 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v129 = "nw_protocol_udp_get_input_frames";
    char v92 = (char *)_os_log_send_and_compose_impl();
    v121[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v125[0]) = 0;
    if (!__nwlog_fault(v92, v121, v125)) {
      goto LABEL_190;
    }
    if (v121[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v89 = __nwlog_obj();
      os_log_type_t v90 = v121[0];
      if (os_log_type_enabled(v89, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v91 = "%{public}s called with null protocol";
LABEL_189:
        _os_log_impl(&dword_1830D4000, v89, v90, v91, buf, 0xCu);
      }
LABEL_190:
      if (v92) {
        free(v92);
      }
      return 0;
    }
    if (!LOBYTE(v125[0]))
    {
      os_log_type_t v89 = __nwlog_obj();
      os_log_type_t v90 = v121[0];
      if (os_log_type_enabled(v89, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v91 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v89 = __nwlog_obj();
    os_log_type_t v90 = v121[0];
    BOOL v95 = os_log_type_enabled(v89, v121[0]);
    if (!backtrace_string)
    {
      if (v95)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v91 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (v95)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v129 = "nw_protocol_udp_get_input_frames";
      __int16 v130 = 2082;
      BOOL v131 = backtrace_string;
      unint64_t v96 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_179:
      _os_log_impl(&dword_1830D4000, v89, v90, v96, buf, 0x16u);
    }
LABEL_180:
    free(backtrace_string);
    goto LABEL_190;
  }
  char handle = a1->handle;
  BOOL v8 = handle == &nw_protocol_ref_counted_handle;
  if (handle == &nw_protocol_ref_counted_handle) {
    p_output_handler = &a1[1].output_handler;
  }
  else {
    p_output_handler = 0;
  }
  id v113 = p_output_handler;
  if (!v8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v129 = "nw_protocol_udp_get_input_frames";
    char v92 = (char *)_os_log_send_and_compose_impl();
    v121[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v125[0]) = 0;
    if (!__nwlog_fault(v92, v121, v125)) {
      goto LABEL_190;
    }
    if (v121[0] == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v89 = __nwlog_obj();
      os_log_type_t v90 = v121[0];
      if (os_log_type_enabled(v89, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v91 = "%{public}s called with null udp";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (!LOBYTE(v125[0]))
    {
      os_log_type_t v89 = __nwlog_obj();
      os_log_type_t v90 = v121[0];
      if (os_log_type_enabled(v89, v121[0]))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v91 = "%{public}s called with null udp, backtrace limit exceeded";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v89 = __nwlog_obj();
    os_log_type_t v90 = v121[0];
    BOOL v97 = os_log_type_enabled(v89, v121[0]);
    if (!backtrace_string)
    {
      if (v97)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v129 = "nw_protocol_udp_get_input_frames";
        os_log_type_t v91 = "%{public}s called with null udp, no backtrace";
        goto LABEL_189;
      }
      goto LABEL_190;
    }
    if (v97)
    {
      *(_DWORD *)buf = 136446466;
      __int16 v129 = "nw_protocol_udp_get_input_frames";
      __int16 v130 = 2082;
      BOOL v131 = backtrace_string;
      unint64_t v96 = "%{public}s called with null udp, dumping backtrace:%{public}s";
      goto LABEL_179;
    }
    goto LABEL_180;
  }
  if (a3 >= 0xFFFFFFF8) {
    uint64_t v11 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v11 = a3 + 8;
  }
  if (a4 >= 0xFFFFFFF8) {
    uint64_t v12 = 0xFFFFFFFFLL;
  }
  else {
    uint64_t v12 = a4 + 8;
  }
  v125[0] = 0;
  v125[1] = v125;
  *(void *)__int16 v121 = 0;
  os_log_type_t v122 = v121;
  int v124 = 0;
  char v111 = a1 + 3;
  uint64_t v123 = 0x2000000000;
  while (1)
  {
    output_handler = a1->output_handler;
    if (output_handler)
    {
      BOOL v14 = output_handler->handle;
      if (v14 == &nw_protocol_ref_counted_handle)
      {
        callbacks = output_handler[1].callbacks;
        if (callbacks) {
          output_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&callbacks->add_input_handler + 1);
        }
      }
      uint64_t v16 = a1->handle;
      if (v16 == &nw_protocol_ref_counted_handle)
      {
        BOOL v17 = a1[1].callbacks;
        if (v17) {
          a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v17->add_input_handler + 1);
        }
      }
      uint64_t v18 = output_handler->callbacks;
      if (v18)
      {
        get_input_frames = (uint64_t (*)(void, void, void, void, void, void))v18->get_input_frames;
        if (get_input_frames)
        {
          int v20 = get_input_frames(output_handler, a1, v11, v12, a5, v125);
          if (v16 != &nw_protocol_ref_counted_handle)
          {
LABEL_25:
            if (v14 == &nw_protocol_ref_counted_handle && output_handler->handle == &nw_protocol_ref_counted_handle)
            {
              char v38 = output_handler[1].callbacks;
              if (v38)
              {
                __int16 v39 = (nw_protocol_callbacks *)((char *)v38 - 1);
                output_handler[1].callbacks = v39;
                if (!v39)
                {
                  int v40 = *(void (***)(void))output_handler[1].flow_id;
                  if (v40)
                  {
                    *(void *)output_handler[1].flow_id = 0;
                    v40[2](v40);
                    _Block_release(v40);
                  }
                  if (output_handler[1].flow_id[8])
                  {
                    os_log_type_t v41 = *(const void **)output_handler[1].flow_id;
                    if (v41) {
                      _Block_release(v41);
                    }
                  }
                  free(output_handler);
                }
              }
            }
            goto LABEL_27;
          }
LABEL_24:
          if (a1->handle == &nw_protocol_ref_counted_handle)
          {
            char v34 = a1[1].callbacks;
            if (v34)
            {
              os_log_type_t v35 = (nw_protocol_callbacks *)((char *)v34 - 1);
              a1[1].callbacks = v35;
              if (!v35)
              {
                os_log_type_t v36 = *(void (***)(void))a1[1].flow_id;
                if (v36)
                {
                  *(void *)a1[1].flow_id = 0;
                  v36[2](v36);
                  _Block_release(v36);
                }
                if (a1[1].flow_id[8])
                {
                  BOOL v37 = *(const void **)a1[1].flow_id;
                  if (v37) {
                    _Block_release(v37);
                  }
                }
                free(a1);
              }
            }
          }
          goto LABEL_25;
        }
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      name = output_handler->identifier->name;
      if (!name) {
        name = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      __int16 v129 = "__nw_protocol_get_input_frames";
      __int16 v130 = 2082;
      BOOL v131 = (void *)name;
      __int16 v132 = 2048;
      BOOL v133 = output_handler;
      os_log_type_t v51 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t v127 = OS_LOG_TYPE_ERROR;
      char v126 = 0;
      os_log_type_t v109 = (char *)v51;
      if (__nwlog_fault(v51, &v127, &v126))
      {
        if (v127 == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v52 = v127;
          *(void *)os_log_type_t type = gLogObj;
          if (!os_log_type_enabled((os_log_t)gLogObj, v127)) {
            goto LABEL_133;
          }
          id v53 = output_handler->identifier->name;
          if (!v53) {
            id v53 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v129 = "__nw_protocol_get_input_frames";
          __int16 v130 = 2082;
          BOOL v131 = (void *)v53;
          __int16 v132 = 2048;
          BOOL v133 = output_handler;
          BOOL v54 = *(NSObject **)type;
          os_log_type_t v55 = v52;
          BOOL v56 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback";
LABEL_132:
          _os_log_impl(&dword_1830D4000, v54, v55, v56, buf, 0x20u);
          goto LABEL_133;
        }
        if (!v126)
        {
          os_log_type_t v76 = __nwlog_obj();
          os_log_type_t v77 = v127;
          *(void *)typec = v76;
          if (!os_log_type_enabled(v76, v127)) {
            goto LABEL_133;
          }
          __int16 v78 = output_handler->identifier->name;
          if (!v78) {
            __int16 v78 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v129 = "__nw_protocol_get_input_frames";
          __int16 v130 = 2082;
          BOOL v131 = (void *)v78;
          __int16 v132 = 2048;
          BOOL v133 = output_handler;
          BOOL v54 = *(NSObject **)typec;
          os_log_type_t v55 = v77;
          BOOL v56 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, backtrace limit exceeded";
          goto LABEL_132;
        }
        uint64_t v63 = (char *)__nw_create_backtrace_string();
        unsigned int log = __nwlog_obj();
        os_log_type_t typea = v127;
        BOOL v64 = os_log_type_enabled(log, v127);
        if (!v63)
        {
          if (!v64) {
            goto LABEL_133;
          }
          __int16 v82 = output_handler->identifier->name;
          if (!v82) {
            __int16 v82 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          __int16 v129 = "__nw_protocol_get_input_frames";
          __int16 v130 = 2082;
          BOOL v131 = (void *)v82;
          __int16 v132 = 2048;
          BOOL v133 = output_handler;
          BOOL v54 = log;
          os_log_type_t v55 = typea;
          BOOL v56 = "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, no backtrace";
          goto LABEL_132;
        }
        if (v64)
        {
          os_log_type_t v65 = output_handler->identifier->name;
          if (!v65) {
            os_log_type_t v65 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          __int16 v129 = "__nw_protocol_get_input_frames";
          __int16 v130 = 2082;
          BOOL v131 = (void *)v65;
          __int16 v132 = 2048;
          BOOL v133 = output_handler;
          __int16 v134 = 2082;
          __int16 v135 = v63;
          _os_log_impl(&dword_1830D4000, log, typea, "%{public}s protocol %{public}s (%p) has invalid get_input_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(v63);
      }
LABEL_133:
      if (v109) {
        free(v109);
      }
      int v20 = 0;
      if (v16 != &nw_protocol_ref_counted_handle) {
        goto LABEL_25;
      }
      goto LABEL_24;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    __int16 v129 = "__nw_protocol_get_input_frames";
    os_log_type_t v57 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v127 = OS_LOG_TYPE_ERROR;
    char v126 = 0;
    if (__nwlog_fault(v57, &v127, &v126))
    {
      if (v127 == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v58 = __nwlog_obj();
        os_log_type_t v59 = v127;
        if (os_log_type_enabled(v58, v127))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v129 = "__nw_protocol_get_input_frames";
          os_log_type_t v60 = v58;
          os_log_type_t v61 = v59;
          os_log_type_t v62 = "%{public}s called with null protocol";
LABEL_141:
          _os_log_impl(&dword_1830D4000, v60, v61, v62, buf, 0xCu);
        }
      }
      else if (v126)
      {
        os_log_type_t v72 = (char *)__nw_create_backtrace_string();
        char v73 = __nwlog_obj();
        os_log_type_t v74 = v127;
        BOOL v75 = os_log_type_enabled(v73, v127);
        if (v72)
        {
          if (v75)
          {
            *(_DWORD *)buf = 136446466;
            __int16 v129 = "__nw_protocol_get_input_frames";
            __int16 v130 = 2082;
            BOOL v131 = v72;
            _os_log_impl(&dword_1830D4000, v73, v74, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v72);
          goto LABEL_142;
        }
        if (v75)
        {
          *(_DWORD *)buf = 136446210;
          __int16 v129 = "__nw_protocol_get_input_frames";
          os_log_type_t v60 = v73;
          os_log_type_t v61 = v74;
          os_log_type_t v62 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_141;
        }
      }
      else
      {
        os_log_type_t v83 = __nwlog_obj();
        os_log_type_t v84 = v127;
        if (os_log_type_enabled(v83, v127))
        {
          *(_DWORD *)buf = 136446210;
          __int16 v129 = "__nw_protocol_get_input_frames";
          os_log_type_t v60 = v83;
          os_log_type_t v61 = v84;
          os_log_type_t v62 = "%{public}s called with null protocol, backtrace limit exceeded";
          goto LABEL_141;
        }
      }
    }
LABEL_142:
    if (v57) {
      free(v57);
    }
    int v20 = 0;
LABEL_27:
    if ((HIWORD(a1[2].output_handler_context) & 0x200) == 0) {
      goto LABEL_44;
    }
    default_input_handler = a1->default_input_handler;
    if (!default_input_handler) {
      goto LABEL_44;
    }
    uint64_t v22 = default_input_handler->callbacks;
    if (!v22 || !v22->error) {
      goto LABEL_44;
    }
    HIWORD(a1[2].output_handler_context) &= ~0x200u;
    uint64_t v23 = default_input_handler->handle;
    if (v23 == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v24 = default_input_handler[1].callbacks;
      if (v24) {
        default_input_handler[1].callbacks = (nw_protocol_callbacks *)((char *)&v24->add_input_handler + 1);
      }
    }
    BOOL v25 = a1->handle;
    if (v25 == &nw_protocol_ref_counted_handle)
    {
      int v26 = a1[1].callbacks;
      if (v26) {
        a1[1].callbacks = (nw_protocol_callbacks *)((char *)&v26->add_input_handler + 1);
      }
    }
    os_log_type_t v27 = default_input_handler->callbacks;
    if (!v27 || (error = (void (*)(nw_protocol *, nw_protocol *, void))v27->error) == 0)
    {
      __nwlog_obj();
      os_log_type_t v66 = default_input_handler->identifier->name;
      if (!v66) {
        os_log_type_t v66 = "invalid";
      }
      *(_DWORD *)buf = 136446722;
      __int16 v129 = "__nw_protocol_error";
      __int16 v130 = 2082;
      BOOL v131 = (void *)v66;
      __int16 v132 = 2048;
      BOOL v133 = default_input_handler;
      os_log_type_t v67 = (const char *)_os_log_send_and_compose_impl();
      os_log_type_t v127 = OS_LOG_TYPE_ERROR;
      char v126 = 0;
      os_log_type_t v110 = (char *)v67;
      if (!__nwlog_fault(v67, &v127, &v126)) {
        goto LABEL_154;
      }
      if (v127 == OS_LOG_TYPE_FAULT)
      {
        typeb = __nwlog_obj();
        os_log_type_t loga = v127;
        if (!os_log_type_enabled(typeb, v127)) {
          goto LABEL_154;
        }
        os_log_type_t v68 = default_input_handler->identifier->name;
        if (!v68) {
          os_log_type_t v68 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v129 = "__nw_protocol_error";
        __int16 v130 = 2082;
        BOOL v131 = (void *)v68;
        __int16 v132 = 2048;
        BOOL v133 = default_input_handler;
        os_log_type_t v69 = typeb;
        os_log_type_t v70 = loga;
        os_log_type_t v71 = "%{public}s protocol %{public}s (%p) has invalid error callback";
      }
      else if (v126)
      {
        typed = __nw_create_backtrace_string();
        os_log_t logb = __nwlog_obj();
        os_log_type_t v98 = v127;
        BOOL v79 = os_log_type_enabled(logb, v127);
        __int16 v80 = (char *)typed;
        if (typed)
        {
          if (v79)
          {
            os_log_type_t v81 = default_input_handler->identifier->name;
            if (!v81) {
              os_log_type_t v81 = "invalid";
            }
            *(_DWORD *)buf = 136446978;
            __int16 v129 = "__nw_protocol_error";
            __int16 v130 = 2082;
            BOOL v131 = (void *)v81;
            __int16 v132 = 2048;
            BOOL v133 = default_input_handler;
            __int16 v134 = 2082;
            __int16 v135 = (void *)typed;
            _os_log_impl(&dword_1830D4000, logb, v98, "%{public}s protocol %{public}s (%p) has invalid error callback, dumping backtrace:%{public}s", buf, 0x2Au);
            __int16 v80 = (char *)typed;
          }
          free(v80);
          goto LABEL_154;
        }
        if (!v79)
        {
LABEL_154:
          if (v110) {
            free(v110);
          }
          goto LABEL_40;
        }
        BOOL v86 = default_input_handler->identifier->name;
        if (!v86) {
          BOOL v86 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v129 = "__nw_protocol_error";
        __int16 v130 = 2082;
        BOOL v131 = (void *)v86;
        __int16 v132 = 2048;
        BOOL v133 = default_input_handler;
        os_log_type_t v69 = logb;
        os_log_type_t v70 = v98;
        os_log_type_t v71 = "%{public}s protocol %{public}s (%p) has invalid error callback, no backtrace";
      }
      else
      {
        typee = __nwlog_obj();
        os_log_type_t logc = v127;
        if (!os_log_type_enabled(typee, v127)) {
          goto LABEL_154;
        }
        unint64_t v85 = default_input_handler->identifier->name;
        if (!v85) {
          unint64_t v85 = "invalid";
        }
        *(_DWORD *)buf = 136446722;
        __int16 v129 = "__nw_protocol_error";
        __int16 v130 = 2082;
        BOOL v131 = (void *)v85;
        __int16 v132 = 2048;
        BOOL v133 = default_input_handler;
        os_log_type_t v69 = typee;
        os_log_type_t v70 = logc;
        os_log_type_t v71 = "%{public}s protocol %{public}s (%p) has invalid error callback, backtrace limit exceeded";
      }
      _os_log_impl(&dword_1830D4000, v69, v70, v71, buf, 0x20u);
      goto LABEL_154;
    }
    error(default_input_handler, a1, 0);
LABEL_40:
    if (v25 == &nw_protocol_ref_counted_handle && a1->handle == &nw_protocol_ref_counted_handle)
    {
      os_log_type_t v42 = a1[1].callbacks;
      if (v42)
      {
        os_log_type_t v43 = (nw_protocol_callbacks *)((char *)v42 - 1);
        a1[1].callbacks = v43;
        if (!v43)
        {
          BOOL v44 = *(void (***)(void))a1[1].flow_id;
          if (v44)
          {
            *(void *)a1[1].flow_id = 0;
            v44[2](v44);
            _Block_release(v44);
          }
          if (a1[1].flow_id[8])
          {
            __int16 v45 = *(const void **)a1[1].flow_id;
            if (v45) {
              _Block_release(v45);
            }
          }
          free(a1);
        }
      }
    }
    if (v23 == &nw_protocol_ref_counted_handle && default_input_handler->handle == &nw_protocol_ref_counted_handle)
    {
      BOOL v46 = default_input_handler[1].callbacks;
      if (v46)
      {
        uint64_t v47 = (nw_protocol_callbacks *)((char *)v46 - 1);
        default_input_handler[1].callbacks = v47;
        if (!v47)
        {
          BOOL v48 = *(void (***)(void))default_input_handler[1].flow_id;
          if (v48)
          {
            *(void *)default_input_handler[1].flow_id = 0;
            v48[2](v48);
            _Block_release(v48);
          }
          if (default_input_handler[1].flow_id[8])
          {
            os_log_type_t v49 = *(const void **)default_input_handler[1].flow_id;
            if (v49) {
              _Block_release(v49);
            }
          }
          free(default_input_handler);
        }
      }
    }
LABEL_44:
    v114[0] = MEMORY[0x1E4F143A8];
    v114[1] = 0x40000000;
    nw_endpoint_t v115 = (uint64_t (*)(void *))___ZL32nw_protocol_udp_get_input_framesP11nw_protocolS0_jjjP16nw_frame_array_s_block_invoke;
    os_log_type_t v116 = &unk_1E523A290;
    id v119 = a1;
    __int16 v120 = a6;
    BOOL v117 = v121;
    __int16 v118 = v113;
    uint64_t v29 = v125[0];
    do
    {
      if (!v29) {
        break;
      }
      uint64_t v30 = *(void *)(v29 + 32);
      char v31 = v115(v114);
      uint64_t v29 = v30;
    }
    while ((v31 & 1) != 0);
    if (*((_DWORD *)v122 + 6) || v20 == 0) {
      break;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v33 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      __int16 v129 = "nw_protocol_udp_get_input_frames";
      __int16 v130 = 2082;
      BOOL v131 = v111;
      _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Dropped inbound packets, checking for more", buf, 0x16u);
    }
  }
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_17);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled()) {
    kdebug_trace();
  }
  uint64_t v87 = *((unsigned int *)v122 + 6);
  _Block_object_dispose(v121, 8);
  return v87;
}

void nw_endpoint_set_context(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  char v3 = a1;
  id v4 = a2;
  char v5 = v4;
  if (!v3)
  {
    uint64_t v6 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v23 = "nw_endpoint_set_context";
    id v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_endpoint_set_context";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null endpoint", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v23 = "nw_endpoint_set_context";
          __int16 v24 = 2082;
          BOOL v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null endpoint, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v7) {
          goto LABEL_4;
        }
LABEL_39:
        free(v7);
        goto LABEL_4;
      }
      if (v14)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_endpoint_set_context";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null endpoint, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      BOOL v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v23 = "nw_endpoint_set_context";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null endpoint, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    objc_storeStrong(v3 + 1, a2);
    goto LABEL_4;
  }
  uint64_t v10 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v23 = "nw_endpoint_set_context";
  id v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    BOOL v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_endpoint_set_context";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v20)
  {
    BOOL v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_endpoint_set_context";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  char v15 = (char *)__nw_create_backtrace_string();
  BOOL v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v23 = "nw_endpoint_set_context";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v17)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v23 = "nw_endpoint_set_context";
    __int16 v24 = 2082;
    BOOL v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_39;
  }
LABEL_4:
}

uint64_t ___ZL36nw_endpoint_transform_receive_reportP30NWConcrete_nw_endpoint_handler26nw_endpoint_handler_mode_t21nw_connection_state_tP27nw_endpoint_handler_event_sPU22objcproto11OS_nw_error8NSObjectPU23objcproto12OS_nw_objectS5__block_invoke(uint64_t a1, void *a2, void *a3)
{
  uint64_t v48 = *MEMORY[0x1E4F143B8];
  id v5 = a2;
  id v6 = a3;
  id v7 = v6;
  uint64_t v8 = 1;
  if (v5)
  {
    if (v6)
    {
      if (v5 != &__block_literal_global_6268)
      {
        uint64_t v9 = *(void *)(*(void *)(a1 + 32) + 32);
        if (v9)
        {
          os_log_type_t v11 = *(id **)(v9 + 16);
          uint64_t v10 = *(id **)(v9 + 24);
          if (v11 != v10)
          {
            while (*v11 != v6)
            {
              if (++v11 == v10)
              {
                os_log_type_t v11 = v10;
                break;
              }
            }
          }
          if (v11 == v10)
          {
            uint64_t v8 = 1;
            goto LABEL_19;
          }
          int minimize_logging = nw_endpoint_handler_get_minimize_logging(*(void **)(a1 + 40));
          char logging_disabled = nw_endpoint_handler_get_logging_disabled(*(void **)(a1 + 40));
          if (minimize_logging)
          {
            if (logging_disabled) {
              goto LABEL_17;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            unsigned int log = (id)gconnectionLogObj;
            if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
            {
              id_string = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
              __int16 v24 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
              nw_endpoint_t v25 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
              logging_description = nw_endpoint_get_logging_description(v25);
              os_log_type_t v27 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
              char v28 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
              id v29 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
              *(_DWORD *)buf = 136448002;
              char v33 = "nw_endpoint_transform_receive_report_block_invoke";
              __int16 v34 = 2082;
              os_log_type_t v35 = id_string;
              __int16 v36 = 2082;
              BOOL v37 = v24;
              __int16 v38 = 2082;
              __int16 v39 = logging_description;
              __int16 v40 = 2082;
              os_log_type_t v41 = v27;
              __int16 v42 = 2082;
              os_log_type_t v43 = v28;
              __int16 v44 = 2114;
              id v45 = v29;
              __int16 v46 = 2114;
              uint64_t v47 = v7;
              BOOL v14 = log;
              _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] updated endpoint alternatives allow %{public}@, restarting", buf, 0x52u);
            }
            else
            {
              BOOL v14 = log;
            }
          }
          else
          {
            if (logging_disabled)
            {
LABEL_17:
              uint64_t v8 = 0;
              *(unsigned char *)(*(void *)(a1 + 32) + 96) = 1;
              *(unsigned char *)(*(void *)(*(void *)(a1 + 48) + 8) + 24) = 1;
              goto LABEL_19;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            BOOL v14 = (id)gconnectionLogObj;
            if (os_log_type_enabled(v14, OS_LOG_TYPE_INFO))
            {
              char v15 = nw_endpoint_handler_get_id_string(*(void **)(a1 + 40));
              os_log_type_t v16 = nw_endpoint_handler_dry_run_string(*(void **)(a1 + 40));
              os_log_type_t loga = v14;
              nw_endpoint_t v17 = nw_endpoint_handler_copy_endpoint(*(void **)(a1 + 40));
              os_log_type_t v18 = nw_endpoint_get_logging_description(v17);
              os_log_type_t v19 = nw_endpoint_handler_state_string(*(void **)(a1 + 40));
              char v20 = nw_endpoint_handler_mode_string(*(void **)(a1 + 40));
              id v21 = nw_endpoint_handler_copy_current_path(*(void **)(a1 + 40));
              *(_DWORD *)buf = 136448002;
              char v33 = "nw_endpoint_transform_receive_report_block_invoke";
              __int16 v34 = 2082;
              os_log_type_t v35 = v15;
              __int16 v36 = 2082;
              BOOL v37 = v16;
              __int16 v38 = 2082;
              __int16 v39 = v18;
              __int16 v40 = 2082;
              os_log_type_t v41 = v19;
              __int16 v42 = 2082;
              os_log_type_t v43 = v20;
              __int16 v44 = 2114;
              id v45 = v21;
              __int16 v46 = 2114;
              uint64_t v47 = v7;
              BOOL v14 = loga;
              _os_log_impl(&dword_1830D4000, loga, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] updated endpoint alternatives allow %{public}@, restarting", buf, 0x52u);
            }
          }

          goto LABEL_17;
        }
      }
    }
  }
LABEL_19:

  return v8;
}

void sub_1831CBC3C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, void *a10)
{
  _Unwind_Resume(a1);
}

id nw_http_metadata_copy_trailer_fields(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    char v3 = nw_protocol_metadata_copy_definition(v1);
    if (nw_protocol_copy_http_definition_onceToken != -1) {
      dispatch_once(&nw_protocol_copy_http_definition_onceToken, &__block_literal_global_15_74223);
    }
    BOOL is_equal = nw_protocol_definition_is_equal(v3, (nw_protocol_definition_t)nw_protocol_copy_http_definition_http_definition);

    if (is_equal)
    {
      *(void *)buf = 0;
      *(void *)&uint8_t buf[8] = buf;
      *(void *)&buf[16] = 0x3032000000;
      uint64_t v26 = __Block_byref_object_copy__5_73857;
      os_log_type_t v27 = __Block_byref_object_dispose__6_73858;
      id v28 = 0;
      v22[0] = MEMORY[0x1E4F143A8];
      v22[1] = 3221225472;
      v22[2] = __nw_http_metadata_copy_trailer_fields_block_invoke;
      v22[3] = &unk_1E5248E90;
      v22[4] = buf;
      uint64_t isa = (uint64_t)v2[4].isa;
      if (isa)
      {
        __nw_http_metadata_copy_trailer_fields_block_invoke((uint64_t)v22, isa);
        id v6 = *(void **)(*(void *)&buf[8] + 40);
      }
      else
      {
        id v6 = 0;
      }
      id v7 = v6;
      _Block_object_dispose(buf, 8);

      goto LABEL_9;
    }
    os_log_type_t v13 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
          _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s metadata must be http", buf, 0xCu);
        }
LABEL_41:

        goto LABEL_42;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v21 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
          _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s metadata must be http, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v18 = type;
      BOOL v19 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v19)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
          _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v18, "%{public}s metadata must be http, dumping backtrace:%{public}s", buf, 0x16u);
      }
      goto LABEL_29;
    }
  }
  else
  {
    uint64_t v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
    uint64_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v10, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v12 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
          _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null metadata", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (!v23)
      {
        os_log_type_t v11 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v11, type))
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
          _os_log_impl(&dword_1830D4000, v11, v20, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
        }
        goto LABEL_41;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (!backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
        }
        goto LABEL_41;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_metadata_copy_trailer_fields";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
      }
LABEL_29:

      free(backtrace_string);
    }
  }
LABEL_42:
  if (v10) {
    free(v10);
  }
  id v7 = 0;
LABEL_9:

  return v7;
}

const char *__nw_create_backtrace_string()
{
  uint64_t v41 = *MEMORY[0x1E4F143B8];
  uint64_t v8 = 0;
  nw_append_format(&v8, "\n        [%s]%s libnetcore%s%s%s%s", "arm64", "", "-", "4277.60.255", "", "");
  long long v39 = 0u;
  long long v40 = 0u;
  long long v37 = 0u;
  long long v38 = 0u;
  long long v35 = 0u;
  long long v36 = 0u;
  long long v33 = 0u;
  long long v34 = 0u;
  long long v31 = 0u;
  long long v32 = 0u;
  long long v29 = 0u;
  long long v30 = 0u;
  long long v27 = 0u;
  long long v28 = 0u;
  long long v25 = 0u;
  long long v26 = 0u;
  long long v23 = 0u;
  long long v24 = 0u;
  long long v21 = 0u;
  long long v22 = 0u;
  long long v19 = 0u;
  long long v20 = 0u;
  long long v17 = 0u;
  long long v18 = 0u;
  long long v15 = 0u;
  long long v16 = 0u;
  long long v13 = 0u;
  long long v14 = 0u;
  long long v11 = 0u;
  long long v12 = 0u;
  *(_OWORD *)uint64_t v9 = 0u;
  long long v10 = 0u;
  int v0 = backtrace(v9, 128);
  id v1 = backtrace_symbols(v9, v0);
  uint64_t v2 = v1;
  if (v0 >= 1)
  {
    uint64_t v3 = v0 - 1;
    id v4 = (const char **)v1;
    do
    {
      id v5 = *v4++;
      nw_append_format(&v8, "\n    %s", v5);
      if (v8) {
        BOOL v6 = v3 == 0;
      }
      else {
        BOOL v6 = 1;
      }
      --v3;
    }
    while (!v6);
    goto LABEL_10;
  }
  if (v1) {
LABEL_10:
  }
    free(v2);
  return v8;
}

void nw_append_format(const char **a1, char *a2, ...)
{
  va_start(va, a2);
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a2)
    {
      va_copy(v70, va);
      *(void *)os_log_type_t v71 = 0;
      int v4 = vasprintf((char **)v71, a2, va);
      unsigned int v5 = v4;
      if ((v4 & 0x80000000) == 0 && *(void *)v71)
      {
        if (*a1)
        {
          size_t v6 = strlen(*a1);
          id v7 = (const char *)nw_reallocf_type<char *>((void *)*a1, v6 + v5 + 1);
          *a1 = v7;
          size_t v8 = strlen(v7);
          if (v7)
          {
LABEL_7:
            uint64_t v9 = *(char **)v71;
            if (!*(void *)v71)
            {
              os_log_type_t v62 = __nwlog_obj();
              os_log_type_enabled(v62, OS_LOG_TYPE_ERROR);
              *(_DWORD *)buf = 136446210;
              char v73 = "_strict_strlcat";
              uint64_t v63 = (void *)_os_log_send_and_compose_impl();
              if (__nwlog_abort((uint64_t)v63)) {
                goto LABEL_99;
              }
              free(v63);
            }
            uint64_t v10 = v5;
            uint64_t v11 = v5 + v8 + 1;
            if (v5 + v8 != -1)
            {
              uint64_t v12 = 0;
              uint64_t v13 = 1;
              while (1)
              {
                long long v14 = &v7[v12];
                if (!v7[v12]) {
                  break;
                }
                ++v12;
                --v13;
                if (v11 == v12) {
                  goto LABEL_12;
                }
              }
              if (v9) {
                goto LABEL_31;
              }
              os_log_type_t v66 = __nwlog_obj();
              os_log_type_enabled(v66, OS_LOG_TYPE_ERROR);
              *(_DWORD *)buf = 136446210;
              char v73 = "_strict_strlcpy";
              os_log_type_t v67 = (void *)_os_log_send_and_compose_impl();
              if (!__nwlog_abort((uint64_t)v67))
              {
                free(v67);
                long long v14 = &v7[v12];
LABEL_31:
                if (v8 + v10 + v13 < 2)
                {
LABEL_36:
                  const char *v14 = 0;
                }
                else
                {
                  uint64_t v36 = 0;
                  uint64_t v37 = 0;
                  while (1)
                  {
                    int v38 = v9[v36];
                    v7[v36 + v12] = v38;
                    if (!v38) {
                      break;
                    }
                    unint64_t v39 = v8 + v10 - v12 + v37--;
                    ++v36;
                    if (v39 <= 1)
                    {
                      long long v14 = &v7[v12 + v36];
                      goto LABEL_36;
                    }
                  }
                }
LABEL_58:
                os_log_type_t v49 = *(char **)v71;
                if (!*(void *)v71) {
                  return;
                }
                goto LABEL_59;
              }
LABEL_99:
              __break(1u);
              return;
            }
LABEL_12:
            if (v9) {
              goto LABEL_58;
            }
            long long v15 = __nwlog_obj();
            os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446210;
            char v73 = "_strict_strlcpy";
            long long v16 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort((uint64_t)v16)) {
              goto LABEL_99;
            }
LABEL_57:
            free(v16);
            goto LABEL_58;
          }
        }
        else
        {
          long long v28 = (const char *)malloc_type_malloc((v4 + 1), 0xF2B69DE5uLL);
          if (!v28)
          {
            BOOL v64 = __nwlog_obj();
            os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
            *(_DWORD *)buf = 136446466;
            char v73 = "strict_malloc";
            __int16 v74 = 2048;
            unint64_t v75 = v5 + 1;
            os_log_type_t v65 = (void *)_os_log_send_and_compose_impl();
            if (__nwlog_abort((uint64_t)v65)) {
              goto LABEL_99;
            }
            free(v65);
          }
          size_t v8 = 0;
          *a1 = v28;
          const char *v28 = 0;
          id v7 = *a1;
          if (*a1) {
            goto LABEL_7;
          }
        }
        uint64_t v29 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init(v29);
        *(_DWORD *)buf = 136446210;
        char v73 = "nw_append_format";
        long long v16 = (void *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v68 = 0;
        uint64_t v30 = __nwlog_fault((const char *)v16, &type, &v68);
        if (v30)
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v32 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init(v32);
            uint64_t v33 = gLogObj;
            os_log_type_t v34 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_56;
            }
            *(_DWORD *)buf = 136446210;
            char v73 = "nw_append_format";
            long long v35 = "%{public}s reallocf failed";
LABEL_54:
            uint64_t v47 = v33;
            os_log_type_t v48 = v34;
LABEL_55:
            _os_log_impl(&dword_1830D4000, v47, v48, v35, buf, 0xCu);
            goto LABEL_56;
          }
          if (!v68)
          {
            uint64_t v46 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init(v46);
            uint64_t v33 = gLogObj;
            os_log_type_t v34 = type;
            if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
              goto LABEL_56;
            }
            *(_DWORD *)buf = 136446210;
            char v73 = "nw_append_format";
            long long v35 = "%{public}s reallocf failed, backtrace limit exceeded";
            goto LABEL_54;
          }
          backtrace_string = (char *)__nw_create_backtrace_string(v30, v31);
          uint64_t v42 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v42);
          os_log_type_t v43 = gLogObj;
          os_log_type_t v44 = type;
          BOOL v45 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (backtrace_string)
          {
            if (v45)
            {
              *(_DWORD *)buf = 136446466;
              char v73 = "nw_append_format";
              __int16 v74 = 2082;
              unint64_t v75 = (unint64_t)backtrace_string;
              _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s reallocf failed, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(backtrace_string);
            if (!v16) {
              goto LABEL_58;
            }
            goto LABEL_57;
          }
          if (v45)
          {
            *(_DWORD *)buf = 136446210;
            char v73 = "nw_append_format";
            long long v35 = "%{public}s reallocf failed, no backtrace";
            uint64_t v47 = v43;
            os_log_type_t v48 = v44;
            goto LABEL_55;
          }
        }
LABEL_56:
        if (!v16) {
          goto LABEL_58;
        }
        goto LABEL_57;
      }
      uint64_t v17 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init(v17);
      *(_DWORD *)buf = 136446722;
      char v73 = "nw_append_format";
      __int16 v74 = 2082;
      unint64_t v75 = (unint64_t)a2;
      __int16 v76 = 1024;
      unsigned int v77 = v5;
      long long v18 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v68 = 0;
      uint64_t v19 = __nwlog_fault(v18, &type, &v68);
      if (v19)
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          uint64_t v21 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v21);
          long long v22 = gLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446722;
            char v73 = "nw_append_format";
            __int16 v74 = 2082;
            unint64_t v75 = (unint64_t)a2;
            __int16 v76 = 1024;
            unsigned int v77 = v5;
            long long v24 = "%{public}s vasprintf(\"%{public}s\") returned %d failed";
LABEL_47:
            _os_log_impl(&dword_1830D4000, v22, v23, v24, buf, 0x1Cu);
          }
        }
        else if (v68)
        {
          long long v25 = (void *)__nw_create_backtrace_string(v19, v20);
          uint64_t v26 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v26);
          long long v22 = gLogObj;
          os_log_type_t v23 = type;
          BOOL v27 = os_log_type_enabled((os_log_t)gLogObj, type);
          if (v25)
          {
            if (v27)
            {
              *(_DWORD *)buf = 136446978;
              char v73 = "nw_append_format";
              __int16 v74 = 2082;
              unint64_t v75 = (unint64_t)a2;
              __int16 v76 = 1024;
              unsigned int v77 = v5;
              __int16 v78 = 2082;
              BOOL v79 = v25;
              _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s vasprintf(\"%{public}s\") returned %d failed, dumping backtrace:%{public}s", buf, 0x26u);
            }
            free(v25);
            goto LABEL_48;
          }
          if (v27)
          {
            *(_DWORD *)buf = 136446722;
            char v73 = "nw_append_format";
            __int16 v74 = 2082;
            unint64_t v75 = (unint64_t)a2;
            __int16 v76 = 1024;
            unsigned int v77 = v5;
            long long v24 = "%{public}s vasprintf(\"%{public}s\") returned %d failed, no backtrace";
            goto LABEL_47;
          }
        }
        else
        {
          uint64_t v40 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init(v40);
          long long v22 = gLogObj;
          os_log_type_t v23 = type;
          if (os_log_type_enabled((os_log_t)gLogObj, type))
          {
            *(_DWORD *)buf = 136446722;
            char v73 = "nw_append_format";
            __int16 v74 = 2082;
            unint64_t v75 = (unint64_t)a2;
            __int16 v76 = 1024;
            unsigned int v77 = v5;
            long long v24 = "%{public}s vasprintf(\"%{public}s\") returned %d failed, backtrace limit exceeded";
            goto LABEL_47;
          }
        }
      }
LABEL_48:
      if (v18) {
        free(v18);
      }
      if (*a1)
      {
        free((void *)*a1);
        *a1 = 0;
      }
      goto LABEL_58;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v73 = "nw_append_format";
    BOOL v50 = (const char *)_os_log_send_and_compose_impl();
    v71[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v70) = 0;
    uint64_t v56 = __nwlog_fault(v50, v71, &v70);
    if (v56)
    {
      if (v71[0] == OS_LOG_TYPE_FAULT)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v54 = v71[0];
        if (!os_log_type_enabled(v53, v71[0])) {
          goto LABEL_95;
        }
        *(_DWORD *)buf = 136446210;
        char v73 = "nw_append_format";
        os_log_type_t v55 = "%{public}s called with null format";
        goto LABEL_94;
      }
      if (!(_BYTE)v70)
      {
        id v53 = __nwlog_obj();
        os_log_type_t v54 = v71[0];
        if (!os_log_type_enabled(v53, v71[0])) {
          goto LABEL_95;
        }
        *(_DWORD *)buf = 136446210;
        char v73 = "nw_append_format";
        os_log_type_t v55 = "%{public}s called with null format, backtrace limit exceeded";
        goto LABEL_94;
      }
      os_log_type_t v60 = (char *)__nw_create_backtrace_string(v56, v57);
      id v53 = __nwlog_obj();
      os_log_type_t v54 = v71[0];
      BOOL v61 = os_log_type_enabled(v53, v71[0]);
      if (v60)
      {
        if (v61)
        {
          *(_DWORD *)buf = 136446466;
          char v73 = "nw_append_format";
          __int16 v74 = 2082;
          unint64_t v75 = (unint64_t)v60;
          _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null format, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v60);
        if (v50) {
          goto LABEL_96;
        }
        return;
      }
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        char v73 = "nw_append_format";
        os_log_type_t v55 = "%{public}s called with null format, no backtrace";
LABEL_94:
        _os_log_impl(&dword_1830D4000, v53, v54, v55, buf, 0xCu);
      }
    }
  }
  else
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    char v73 = "nw_append_format";
    BOOL v50 = (const char *)_os_log_send_and_compose_impl();
    v71[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v70) = 0;
    uint64_t v51 = __nwlog_fault(v50, v71, &v70);
    if (!v51) {
      goto LABEL_95;
    }
    if (v71[0] == OS_LOG_TYPE_FAULT)
    {
      id v53 = __nwlog_obj();
      os_log_type_t v54 = v71[0];
      if (!os_log_type_enabled(v53, v71[0])) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446210;
      char v73 = "nw_append_format";
      os_log_type_t v55 = "%{public}s called with null buffer";
      goto LABEL_94;
    }
    if (!(_BYTE)v70)
    {
      id v53 = __nwlog_obj();
      os_log_type_t v54 = v71[0];
      if (!os_log_type_enabled(v53, v71[0])) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446210;
      char v73 = "nw_append_format";
      os_log_type_t v55 = "%{public}s called with null buffer, backtrace limit exceeded";
      goto LABEL_94;
    }
    os_log_type_t v58 = (char *)__nw_create_backtrace_string(v51, v52);
    id v53 = __nwlog_obj();
    os_log_type_t v54 = v71[0];
    BOOL v59 = os_log_type_enabled(v53, v71[0]);
    if (!v58)
    {
      if (!v59) {
        goto LABEL_95;
      }
      *(_DWORD *)buf = 136446210;
      char v73 = "nw_append_format";
      os_log_type_t v55 = "%{public}s called with null buffer, no backtrace";
      goto LABEL_94;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      char v73 = "nw_append_format";
      __int16 v74 = 2082;
      unint64_t v75 = (unint64_t)v58;
      _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null buffer, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v58);
  }
LABEL_95:
  if (v50)
  {
LABEL_96:
    os_log_type_t v49 = (char *)v50;
LABEL_59:
    free(v49);
  }
}

uint64_t __nwlog_obj()
{
  uint64_t v0 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init(v0);
  return gLogObj;
}

BOOL nwsc_get_identifier(void *a1, uint64_t a2, unsigned char *a3)
{
  id v5 = a1;
  uint64_t endpoint_identifier = nwsc_get_endpoint_identifier(v5, (uint64_t)a3);
  if ((endpoint_identifier & 1) == 0)
  {
LABEL_25:

    return endpoint_identifier;
  }
  if (!a3)
  {
    long long v15 = __nwlog_obj();
    os_log_type_enabled(v15, OS_LOG_TYPE_ERROR);
    long long v16 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v16);
    if (result) {
      goto LABEL_35;
    }
    free(v16);
  }
  unint64_t v7 = 436;
  size_t v8 = a3;
  while (*v8)
  {
    ++v8;
    if (!--v7) {
      goto LABEL_10;
    }
  }
  if (v7 >= 2) {
    *v8++ = 64;
  }
  unsigned char *v8 = 0;
LABEL_10:
  if (!a3)
  {
    uint64_t v17 = __nwlog_obj();
    os_log_type_enabled(v17, OS_LOG_TYPE_ERROR);
    long long v18 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v18);
    if (result) {
      goto LABEL_35;
    }
    free(v18);
    if (a2) {
      goto LABEL_12;
    }
LABEL_30:
    uint64_t v19 = __nwlog_obj();
    os_log_type_enabled(v19, OS_LOG_TYPE_ERROR);
    uint64_t v20 = (void *)_os_log_send_and_compose_impl();

    BOOL result = __nwlog_abort((uint64_t)v20);
    if (result) {
      goto LABEL_35;
    }
    free(v20);
    goto LABEL_12;
  }
  if (!a2) {
    goto LABEL_30;
  }
LABEL_12:
  unint64_t v9 = 436;
  do
  {
    if (!*a3)
    {
      if (a2)
      {
        if (v9 >= 2)
        {
LABEL_20:
          uint64_t v13 = 0;
          while (1)
          {
            int v14 = *(unsigned __int8 *)(a2 + v13);
            a3[v13] = v14;
            if (!v14) {
              goto LABEL_25;
            }
            --v9;
            ++v13;
            if (v9 <= 1)
            {
              a3 += v13;
              break;
            }
          }
        }
      }
      else
      {
        unint64_t v23 = v9;
        uint64_t v21 = __nwlog_obj();
        os_log_type_enabled(v21, OS_LOG_TYPE_ERROR);
        long long v22 = (void *)_os_log_send_and_compose_impl();

        BOOL result = __nwlog_abort((uint64_t)v22);
        if (result) {
          goto LABEL_35;
        }
        free(v22);
        unint64_t v9 = v23;
        if (v23 >= 2) {
          goto LABEL_20;
        }
      }
      *a3 = 0;
      goto LABEL_25;
    }
    ++a3;
    --v9;
  }
  while (v9);
  if (a2) {
    goto LABEL_25;
  }
  uint64_t v10 = __nwlog_obj();
  os_log_type_enabled(v10, OS_LOG_TYPE_ERROR);
  uint64_t v11 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v11);
  if (!result)
  {
    free(v11);
    goto LABEL_25;
  }
LABEL_35:
  __break(1u);
  return result;
}

void sub_1831CD764(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_http_encrypt_oblivious_request(const void *a1, size_t a2, const char *a3, unsigned __int16 *a4, uint64_t a5, char **a6, void *a7, void *a8, size_t *a9, size_t *a10)
{
  uint64_t v88 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null message_buffer, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v49 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v49)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null message_buffer, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v49) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null message_buffer, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null message_buffer";
LABEL_168:
    _os_log_impl(&dword_1830D4000, v45, v46, v47, buf, 0xCu);
    goto LABEL_169;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null message_length, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v51 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v51)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null message_length, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v51) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null message_length, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null message_length";
    goto LABEL_168;
  }
  if (!a3)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null media_type, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v52 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v52)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null media_type, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v52) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null media_type, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null media_type";
    goto LABEL_168;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null config_buffer, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v53 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v53)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null config_buffer, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v53) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null config_buffer, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null config_buffer";
    goto LABEL_168;
  }
  if (!a5)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null in_config_length, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v54 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v54)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null in_config_length, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v54) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null in_config_length, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null in_config_length";
    goto LABEL_168;
  }
  if (!a6)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null out_context, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v55 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v55)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null out_context, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v55) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null out_context, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null out_context";
    goto LABEL_168;
  }
  if (!a7)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null out_context_length, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v56 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v56)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null out_context_length, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v56) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null out_context_length, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null out_context_length";
    goto LABEL_168;
  }
  if (!a8)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] != OS_LOG_TYPE_FAULT)
    {
      if (!(_BYTE)v80)
      {
        BOOL v45 = __nwlog_obj();
        os_log_type_t v46 = type[0];
        if (os_log_type_enabled(v45, type[0]))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null out_request_enc, backtrace limit exceeded";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      BOOL v57 = os_log_type_enabled(v45, type[0]);
      if (!backtrace_string)
      {
        if (v57)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
          uint64_t v47 = "%{public}s called with null out_request_enc, no backtrace";
          goto LABEL_168;
        }
        goto LABEL_169;
      }
      if (!v57) {
        goto LABEL_119;
      }
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null out_request_enc, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    if (!os_log_type_enabled(v45, type[0])) {
      goto LABEL_169;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    uint64_t v47 = "%{public}s called with null out_request_enc";
    goto LABEL_168;
  }
  if (!a9)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      if (!os_log_type_enabled(v45, type[0])) {
        goto LABEL_169;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      uint64_t v47 = "%{public}s called with null out_request_enc_length";
      goto LABEL_168;
    }
    if (!(_BYTE)v80)
    {
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
        uint64_t v47 = "%{public}s called with null out_request_enc_length, backtrace limit exceeded";
        goto LABEL_168;
      }
      goto LABEL_169;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    BOOL v58 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (v58)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
        uint64_t v47 = "%{public}s called with null out_request_enc_length, no backtrace";
        goto LABEL_168;
      }
      goto LABEL_169;
    }
    if (!v58) {
      goto LABEL_119;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    __int16 v84 = 2082;
    uint64_t v85 = (uint64_t)backtrace_string;
    BOOL v50 = "%{public}s called with null out_request_enc_length, dumping backtrace:%{public}s";
LABEL_118:
    _os_log_impl(&dword_1830D4000, v45, v46, v50, buf, 0x16u);
    goto LABEL_119;
  }
  if (!a10)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
    os_log_type_t v44 = (const char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v80) = 0;
    if (!__nwlog_fault(v44, type, &v80)) {
      goto LABEL_169;
    }
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
        uint64_t v47 = "%{public}s called with null out_encrypted_length";
        goto LABEL_168;
      }
LABEL_169:
      if (!v44) {
        return 0;
      }
      unint64_t v39 = (char *)v44;
      goto LABEL_32;
    }
    if (!(_BYTE)v80)
    {
      BOOL v45 = __nwlog_obj();
      os_log_type_t v46 = type[0];
      if (os_log_type_enabled(v45, type[0]))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
        uint64_t v47 = "%{public}s called with null out_encrypted_length, backtrace limit exceeded";
        goto LABEL_168;
      }
      goto LABEL_169;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v45 = __nwlog_obj();
    os_log_type_t v46 = type[0];
    BOOL v59 = os_log_type_enabled(v45, type[0]);
    if (!backtrace_string)
    {
      if (v59)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
        uint64_t v47 = "%{public}s called with null out_encrypted_length, no backtrace";
        goto LABEL_168;
      }
      goto LABEL_169;
    }
    if (v59)
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 2082;
      uint64_t v85 = (uint64_t)backtrace_string;
      BOOL v50 = "%{public}s called with null out_encrypted_length, dumping backtrace:%{public}s";
      goto LABEL_118;
    }
LABEL_119:
    free(backtrace_string);
    goto LABEL_169;
  }
  *(void *)os_log_type_t type = 0;
  long long v16 = nw_http_oblivious_config_select(a4, a5, type);
  if (!v16 || *(void *)type <= 0x28uLL)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      uint64_t v20 = "%{public}s Config parsing failed";
      goto LABEL_18;
    }
    return 0;
  }
  uint64_t v17 = v16;
  size_t v18 = strlen(a3);
  if (v18 >= 0x101)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v19 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446210;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      uint64_t v20 = "%{public}s Media type exceeds max length";
LABEL_18:
      _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_ERROR, v20, buf, 0xCu);
      return 0;
    }
    return 0;
  }
  size_t v21 = v18;
  unint64_t v75 = a7;
  cchpke_params_x25519_AESGCM128_HKDF_SHA256();
  uint64_t v22 = cchpke_params_sizeof_aead_tag();
  uint64_t v23 = cchpke_params_sizeof_kem_enc();
  BOOL v79 = (char *)malloc_type_calloc(1uLL, 0x60uLL, 0xEAFB8F1AuLL);
  uint64_t v78 = v22;
  if (!v79)
  {
    uint64_t v60 = v23;
    BOOL v61 = __nwlog_obj();
    os_log_type_enabled(v61, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v83 = "strict_calloc";
    __int16 v84 = 2048;
    uint64_t v85 = 1;
    __int16 v86 = 2048;
    uint64_t v87 = 96;
    os_log_type_t v62 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v62);
    if (result) {
      goto LABEL_175;
    }
    free(v62);
    uint64_t v23 = v60;
    uint64_t v22 = v78;
  }
  size_t v24 = a2 + v22 + v23;
  size_t v25 = v24 + 7;
  size_t v77 = v24 + 7;
  if (v24 == -7)
  {
    uint64_t v63 = v23;
    BOOL v64 = __nwlog_obj();
    os_log_type_enabled(v64, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "strict_calloc";
    os_log_type_t v65 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v65);
    if (result) {
      goto LABEL_175;
    }
    free(v65);
    uint64_t v23 = v63;
    size_t v25 = v77;
  }
  __int16 v76 = a8;
  uint64_t v26 = (char *)malloc_type_calloc(1uLL, v25, 0xEAFB8F1AuLL);
  if (!v26)
  {
    uint64_t v66 = v23;
    os_log_type_t v67 = __nwlog_obj();
    os_log_type_enabled(v67, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v83 = "strict_calloc";
    __int16 v84 = 2048;
    uint64_t v85 = 1;
    __int16 v86 = 2048;
    uint64_t v87 = v77;
    char v68 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v68);
    if (result) {
      goto LABEL_175;
    }
    free(v68);
    uint64_t v23 = v66;
  }
  *uint64_t v26 = *(unsigned char *)v17;
  *(_WORD *)(v26 + 1) = *(unsigned __int16 *)((char *)v17 + 1);
  *(_DWORD *)(v26 + 3) = 16777472;
  int v80 = 0;
  ccrng();
  memcpy(&v26[v23 + 7], a1, a2);
  size_t v27 = v23;
  long long v28 = (char *)malloc_type_calloc(1uLL, v21 + 16, 0xEAFB8F1AuLL);
  if (!v28)
  {
    os_log_type_t v69 = __nwlog_obj();
    os_log_type_enabled(v69, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446722;
    os_log_type_t v83 = "strict_calloc";
    __int16 v84 = 2048;
    uint64_t v85 = 1;
    __int16 v86 = 2048;
    uint64_t v87 = v21 + 16;
    va_list v70 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v70);
    if (result) {
      goto LABEL_175;
    }
    free(v70);
  }
  size_t v29 = v21 + 9;
  snprintf(v28, v29, "%s request", a3);
  uint64_t v30 = &v28[v29];
  int v31 = *(_DWORD *)(v26 + 3);
  *(_DWORD *)uint64_t v30 = *(_DWORD *)v26;
  *(_DWORD *)(v30 + 3) = v31;
  int v32 = cchpke_initiator_setup();
  free(v28);
  if (v32)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v33 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 1024;
      LODWORD(v85) = v32;
      os_log_type_t v34 = "%{public}s Setup error: %d";
      long long v35 = v33;
LABEL_29:
      _os_log_impl(&dword_1830D4000, v35, OS_LOG_TYPE_ERROR, v34, buf, 0x12u);
      goto LABEL_30;
    }
    goto LABEL_30;
  }
  int v36 = cchpke_initiator_encrypt();
  if (v36)
  {
    int v37 = v36;
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v38 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)buf = 136446466;
      os_log_type_t v83 = "nw_http_encrypt_oblivious_request";
      __int16 v84 = 1024;
      LODWORD(v85) = v37;
      os_log_type_t v34 = "%{public}s Encrypt: %d";
      long long v35 = v38;
      goto LABEL_29;
    }
LABEL_30:
    free(v26);
    if (!v79) {
      return 0;
    }
    unint64_t v39 = v79;
LABEL_32:
    free(v39);
    return 0;
  }
  *a6 = v79;
  *unint64_t v75 = 96;
  size_t v41 = v27;
  if (!v27)
  {
    os_log_type_t v71 = __nwlog_obj();
    os_log_type_enabled(v71, OS_LOG_TYPE_ERROR);
    *(_DWORD *)buf = 136446210;
    os_log_type_t v83 = "strict_calloc";
    os_log_type_t v72 = (void *)_os_log_send_and_compose_impl();
    BOOL result = __nwlog_abort((uint64_t)v72);
    if (result) {
      goto LABEL_175;
    }
    free(v72);
    size_t v41 = 0;
  }
  uint64_t v42 = malloc_type_calloc(1uLL, v41, 0xEAFB8F1AuLL);
  os_log_type_t v43 = a10;
  if (v42)
  {
LABEL_37:
    void *v76 = v42;
    memcpy(v42, v26 + 7, v41);
    *a9 = v41;
    size_t *v43 = v77;
    return (BOOL)v26;
  }
  char v73 = __nwlog_obj();
  os_log_type_enabled(v73, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  os_log_type_t v83 = "strict_calloc";
  __int16 v84 = 2048;
  uint64_t v85 = 1;
  __int16 v86 = 2048;
  uint64_t v87 = v41;
  __int16 v74 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v74);
  if (!result)
  {
    free(v74);
    os_log_type_t v43 = a10;
    size_t v41 = v27;
    goto LABEL_37;
  }
LABEL_175:
  __break(1u);
  return result;
}

void ___ZL57nw_service_connector_trigger_request_complete_block_innerP31NWConcrete_nw_service_connectorP39NWConcrete_nw_unique_connection_requestU13block_pointerFvP24NWConcrete_nw_connectionP9__CFErrorES4_i_block_invoke(uint64_t a1)
{
  uint64_t v59 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = _Block_copy(*(const void **)(a1 + 64));
  uint64_t v3 = v2;
  uint64_t v4 = *(void *)(a1 + 32);
  if (v4)
  {
    id v5 = (void (**)(void *, void, CFErrorRef))_Block_copy(*(const void **)(v4 + 592));

    uint64_t v6 = *(void *)(a1 + 32);
    unint64_t v7 = *(void **)(v6 + 592);
    *(void *)(v6 + 592) = 0;

    size_t v8 = (NWConcrete_nw_unique_connection_request *)*(id *)(a1 + 32);
    nwsc_request_stop_path_watcher(v8);
    *((unsigned char *)v8 + 616) &= 0xE7u;

    unint64_t v9 = *(NSObject **)(a1 + 40);
    if (v9) {
      goto LABEL_3;
    }
  }
  else
  {
    id v5 = (void (**)(void *, void, CFErrorRef))v2;
    unint64_t v9 = *(NSObject **)(a1 + 40);
    if (v9)
    {
LABEL_3:
      CFErrorRef v10 = nw_error_copy_cf_error(v9);
      if (v5) {
        goto LABEL_4;
      }
      goto LABEL_14;
    }
  }
  CFErrorRef v10 = 0;
  if (v5)
  {
LABEL_4:
    uint64_t v11 = *(void **)(a1 + 48);
    if (v11)
    {
      uint64_t v12 = v11;
      uint64_t v13 = v12 + 34;
      *(void *)buf = MEMORY[0x1E4F143A8];
      *(void *)&uint8_t buf[8] = 3221225472;
      *(void *)&buf[16] = __nw_connection_allow_reset_queue_block_invoke;
      BOOL v53 = &unk_1E524BAA8;
      int v14 = v12;
      *(void *)BOOL v54 = v14;
      os_unfair_lock_lock(v13);
      __nw_connection_allow_reset_queue_block_invoke((uint64_t)buf);
      os_unfair_lock_unlock(v13);

      long long v15 = *(void **)(a1 + 32);
      if (v15)
      {
        long long v16 = (void *)v15[2];
        if (v16)
        {
          if (!v10) {
            nw_service_connector_apply_user_parameters(*(void **)(a1 + 56), v15, *(void **)(a1 + 48), v16);
          }
        }
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = (id)gLogObj;
    if (os_log_type_enabled(v17, OS_LOG_TYPE_DEFAULT))
    {
      uint64_t v19 = *(void **)(a1 + 48);
      uint64_t v18 = *(void *)(a1 + 56);
      uint64_t v21 = *(void *)(a1 + 32);
      uint64_t v20 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v18;
      *(_WORD *)&unsigned char buf[22] = 2114;
      BOOL v53 = v19;
      *(_WORD *)BOOL v54 = 2114;
      *(void *)&v54[2] = v20;
      __int16 v55 = 2114;
      uint64_t v56 = v21;
      _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}@ calling request completion block with connection %{public}@ error %{public}@ for %{public}@", buf, 0x34u);
    }

    v5[2](v5, *(void *)(a1 + 48), v10);
    goto LABEL_21;
  }
LABEL_14:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v22 = (id)gLogObj;
  size_t v24 = *(void **)(a1 + 48);
  uint64_t v23 = *(void *)(a1 + 56);
  uint64_t v26 = *(void *)(a1 + 32);
  uint64_t v25 = *(void *)(a1 + 40);
  *(_DWORD *)buf = 136447234;
  *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
  *(_WORD *)&unsigned char buf[12] = 2114;
  *(void *)&buf[14] = v23;
  *(_WORD *)&unsigned char buf[22] = 2114;
  BOOL v53 = v24;
  *(_WORD *)BOOL v54 = 2114;
  *(void *)&v54[2] = v25;
  __int16 v55 = 2114;
  uint64_t v56 = v26;
  size_t v27 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v50 = 0;
  if (!__nwlog_fault(v27, &type, &v50)) {
    goto LABEL_19;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v28 = (id)gLogObj;
    os_log_type_t v29 = type;
    if (os_log_type_enabled(v28, type))
    {
      int v31 = *(void **)(a1 + 48);
      uint64_t v30 = *(void *)(a1 + 56);
      uint64_t v33 = *(void *)(a1 + 32);
      uint64_t v32 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v30;
      *(_WORD *)&unsigned char buf[22] = 2114;
      BOOL v53 = v31;
      *(_WORD *)BOOL v54 = 2114;
      *(void *)&v54[2] = v32;
      __int16 v55 = 2114;
      uint64_t v56 = v33;
      _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ for %{public}@", buf, 0x34u);
    }
LABEL_18:

LABEL_19:
    if (!v27) {
      goto LABEL_21;
    }
    goto LABEL_20;
  }
  if (!v50)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    long long v28 = (id)gLogObj;
    os_log_type_t v41 = type;
    if (os_log_type_enabled(v28, type))
    {
      os_log_type_t v43 = *(void **)(a1 + 48);
      uint64_t v42 = *(void *)(a1 + 56);
      uint64_t v45 = *(void *)(a1 + 32);
      uint64_t v44 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v42;
      *(_WORD *)&unsigned char buf[22] = 2114;
      BOOL v53 = v43;
      *(_WORD *)BOOL v54 = 2114;
      *(void *)&v54[2] = v44;
      __int16 v55 = 2114;
      uint64_t v56 = v45;
      _os_log_impl(&dword_1830D4000, v28, v41, "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ for %{public}@, backtrace limit exceeded", buf, 0x34u);
    }
    goto LABEL_18;
  }
  backtrace_string = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  long long v28 = (id)gLogObj;
  os_log_type_t v35 = type;
  BOOL v36 = os_log_type_enabled(v28, type);
  if (!backtrace_string)
  {
    if (v36)
    {
      uint64_t v47 = *(void **)(a1 + 48);
      uint64_t v46 = *(void *)(a1 + 56);
      uint64_t v49 = *(void *)(a1 + 32);
      uint64_t v48 = *(void *)(a1 + 40);
      *(_DWORD *)buf = 136447234;
      *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
      *(_WORD *)&unsigned char buf[12] = 2114;
      *(void *)&buf[14] = v46;
      *(_WORD *)&unsigned char buf[22] = 2114;
      BOOL v53 = v47;
      *(_WORD *)BOOL v54 = 2114;
      *(void *)&v54[2] = v48;
      __int16 v55 = 2114;
      uint64_t v56 = v49;
      _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ for %{public}@, no backtrace", buf, 0x34u);
    }
    goto LABEL_18;
  }
  if (v36)
  {
    uint64_t v38 = *(void **)(a1 + 48);
    uint64_t v37 = *(void *)(a1 + 56);
    uint64_t v40 = *(void *)(a1 + 32);
    uint64_t v39 = *(void *)(a1 + 40);
    *(_DWORD *)buf = 136447490;
    *(void *)&uint8_t buf[4] = "nw_service_connector_trigger_request_complete_block_inner_block_invoke";
    *(_WORD *)&unsigned char buf[12] = 2114;
    *(void *)&buf[14] = v37;
    *(_WORD *)&unsigned char buf[22] = 2114;
    BOOL v53 = v38;
    *(_WORD *)BOOL v54 = 2114;
    *(void *)&v54[2] = v39;
    __int16 v55 = 2114;
    uint64_t v56 = v40;
    __int16 v57 = 2082;
    BOOL v58 = backtrace_string;
    _os_log_impl(&dword_1830D4000, v28, v35, "%{public}s %{public}@ tried to call missing request completion block with connection %{public}@ error %{public}@ for %{public}@, dumping backtrace:%{public}s", buf, 0x3Eu);
  }

  free(backtrace_string);
  if (v27) {
LABEL_20:
  }
    free(v27);
LABEL_21:
  if (v10) {
    CFRelease(v10);
  }
}

void sub_1831CF49C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1831CF4B0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_http_capsule_framer_finalize_output_frames(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t *a4)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &v27, &v26)) {
      goto LABEL_51;
    }
    if (v27 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = v27;
      if (!os_log_type_enabled(v12, v27)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null framer";
      goto LABEL_50;
    }
    if (!v26)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = v27;
      if (!os_log_type_enabled(v12, v27)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null framer, backtrace limit exceeded";
      goto LABEL_50;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v13 = v27;
    BOOL v16 = os_log_type_enabled(v12, v27);
    if (!backtrace_string)
    {
      if (!v16) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null framer, no backtrace";
      goto LABEL_50;
    }
    if (!v16) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
    __int16 v30 = 2082;
    int v31 = backtrace_string;
    uint64_t v17 = "%{public}s called with null framer, dumping backtrace:%{public}s";
LABEL_36:
    _os_log_impl(&dword_1830D4000, v12, v13, v17, buf, 0x16u);
    goto LABEL_37;
  }
  if (!a2)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &v27, &v26)) {
      goto LABEL_51;
    }
    if (v27 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = v27;
      if (!os_log_type_enabled(v12, v27)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null protocol";
      goto LABEL_50;
    }
    if (!v26)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = v27;
      if (!os_log_type_enabled(v12, v27)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null protocol, backtrace limit exceeded";
      goto LABEL_50;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v13 = v27;
    BOOL v18 = os_log_type_enabled(v12, v27);
    if (!backtrace_string)
    {
      if (!v18) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null protocol, no backtrace";
      goto LABEL_50;
    }
    if (!v18) {
      goto LABEL_37;
    }
    *(_DWORD *)buf = 136446466;
    os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
    __int16 v30 = 2082;
    int v31 = backtrace_string;
    uint64_t v17 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
    goto LABEL_36;
  }
  if (!a4)
  {
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
    uint64_t v11 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v27 = OS_LOG_TYPE_ERROR;
    char v26 = 0;
    if (!__nwlog_fault(v11, &v27, &v26)) {
      goto LABEL_51;
    }
    if (v27 == OS_LOG_TYPE_FAULT)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = v27;
      if (!os_log_type_enabled(v12, v27)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null frames";
      goto LABEL_50;
    }
    if (!v26)
    {
      uint64_t v12 = __nwlog_obj();
      os_log_type_t v13 = v27;
      if (!os_log_type_enabled(v12, v27)) {
        goto LABEL_51;
      }
      *(_DWORD *)buf = 136446210;
      os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
      int v14 = "%{public}s called with null frames, backtrace limit exceeded";
      goto LABEL_50;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v13 = v27;
    BOOL v19 = os_log_type_enabled(v12, v27);
    if (backtrace_string)
    {
      if (v19)
      {
        *(_DWORD *)buf = 136446466;
        os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
        __int16 v30 = 2082;
        int v31 = backtrace_string;
        uint64_t v17 = "%{public}s called with null frames, dumping backtrace:%{public}s";
        goto LABEL_36;
      }
LABEL_37:
      free(backtrace_string);
      goto LABEL_51;
    }
    if (!v19) {
      goto LABEL_51;
    }
    *(_DWORD *)buf = 136446210;
    os_log_type_t v29 = "nw_http_capsule_framer_finalize_output_frames";
    int v14 = "%{public}s called with null frames, no backtrace";
LABEL_50:
    _os_log_impl(&dword_1830D4000, v12, v13, v14, buf, 0xCu);
LABEL_51:
    if (v11) {
      free(v11);
    }
    return 0;
  }
  uint64_t v5 = *(void *)(a2 + 32);
  if (!v5) {
    return 0;
  }
  uint64_t v6 = *(void *)(v5 + 24);
  if (!v6 || !*(void *)(v6 + 96)) {
    return 0;
  }
  v20[0] = MEMORY[0x1E4F143A8];
  v20[1] = 0x40000000;
  uint64_t v21 = __nw_http_capsule_framer_finalize_output_frames_block_invoke;
  id v22 = &__block_descriptor_tmp_9_49471;
  uint64_t v23 = a3;
  uint64_t v24 = a1;
  uint64_t v25 = a2;
  uint64_t v7 = *a4;
  do
  {
    if (!v7) {
      break;
    }
    uint64_t v8 = *(void *)(v7 + 32);
    char v9 = ((uint64_t (*)(void *))v21)(v20);
    uint64_t v7 = v8;
  }
  while ((v9 & 1) != 0);
  return nw_protocol_finalize_output_frames(v5, (uint64_t)a4);
}

void nw_http_capsule_framer_cleanup(void *a1)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = *a1;
    do
    {
      if (!v2) {
        break;
      }
      uint64_t v3 = *(void *)(v2 + 32);
      char v4 = __nw_http_capsule_framer_cleanup_block_invoke((uint64_t)&__block_literal_global_49404, (_DWORD *)v2);
      uint64_t v2 = v3;
    }
    while ((v4 & 1) != 0);
    uint64_t v6 = a1 + 2;
    uint64_t v5 = a1[2];
    do
    {
      if (!v5) {
        break;
      }
      uint64_t v7 = *(void *)(v5 + 32);
      char v8 = __nw_http_capsule_framer_cleanup_block_invoke_1((uint64_t)&__block_literal_global_4_49405, (_DWORD *)v5);
      uint64_t v5 = v7;
    }
    while ((v8 & 1) != 0);
    if (gLogDatapath)
    {
      BOOL v19 = __nwlog_obj();
      if (os_log_type_enabled(v19, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_1830D4000, v19, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_49408;
    char v26 = &__block_descriptor_tmp_11_49409;
    os_log_type_t v27 = a1;
    char v28 = 0;
    uint64_t v9 = *a1;
    do
    {
      if (!v9) {
        break;
      }
      uint64_t v10 = *(void *)(v9 + 32);
      char v11 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
      uint64_t v9 = v10;
    }
    while ((v11 & 1) != 0);
    if (gLogDatapath)
    {
      uint64_t v20 = __nwlog_obj();
      if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_protocol_finalize_temp_frame_array";
        _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s called", buf, 0xCu);
      }
    }
    *(void *)buf = MEMORY[0x1E4F143A8];
    *(void *)&uint8_t buf[8] = 0x40000000;
    *(void *)&buf[16] = ___ZL37nw_protocol_finalize_temp_frame_arrayP16nw_frame_array_sb_block_invoke_49408;
    char v26 = &__block_descriptor_tmp_11_49409;
    os_log_type_t v27 = v6;
    char v28 = 0;
    uint64_t v12 = *v6;
    do
    {
      if (!v12) {
        break;
      }
      uint64_t v13 = *(void *)(v12 + 32);
      char v14 = (*(uint64_t (**)(unsigned char *))&buf[16])(buf);
      uint64_t v12 = v13;
    }
    while ((v14 & 1) != 0);
    return;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
  long long v15 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v15, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
      BOOL v18 = "%{public}s called with null framer";
      goto LABEL_34;
    }
    if (!v23)
    {
      BOOL v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_35;
      }
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
      BOOL v18 = "%{public}s called with null framer, backtrace limit exceeded";
      goto LABEL_34;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    BOOL v16 = __nwlog_obj();
    os_log_type_t v17 = type;
    BOOL v22 = os_log_type_enabled(v16, type);
    if (backtrace_string)
    {
      if (v22)
      {
        *(_DWORD *)buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = backtrace_string;
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s called with null framer, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_35;
    }
    if (v22)
    {
      *(_DWORD *)buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_http_capsule_framer_cleanup";
      BOOL v18 = "%{public}s called with null framer, no backtrace";
LABEL_34:
      _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0xCu);
    }
  }
LABEL_35:
  if (v15) {
    free(v15);
  }
}

uint64_t nw_path_flow_get_protocol_level(void *a1)
{
  uint64_t v24 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = (unsigned __int8 *)v1;
  if (!v1)
  {
    char v11 = __nwlog_obj();
    *(_DWORD *)size_t length = 136446210;
    *(void *)&length[4] = "nw_path_flow_get_protocol_level";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v19 = 0;
    if (__nwlog_fault(v12, &type, &v19))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)size_t length = 136446210;
          *(void *)&length[4] = "nw_path_flow_get_protocol_level";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null flow", length, 0xCu);
        }
      }
      else if (v19)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v17 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v17)
          {
            *(_DWORD *)size_t length = 136446466;
            *(void *)&length[4] = "nw_path_flow_get_protocol_level";
            __int16 v22 = 2082;
            char v23 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null flow, dumping backtrace:%{public}s", length, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v17)
        {
          *(_DWORD *)size_t length = 136446210;
          *(void *)&length[4] = "nw_path_flow_get_protocol_level";
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null flow, no backtrace", length, 0xCu);
        }
      }
      else
      {
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v18 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)size_t length = 136446210;
          *(void *)&length[4] = "nw_path_flow_get_protocol_level";
          _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null flow, backtrace limit exceeded", length, 0xCu);
        }
      }
    }
LABEL_35:
    if (v12) {
      free(v12);
    }
    goto LABEL_13;
  }
  if (uuid_is_null(v1 + 84))
  {
LABEL_13:
    uint64_t v8 = 0;
    goto LABEL_14;
  }
  uint64_t v3 = v2;
  char v4 = (void *)*((void *)v3 + 3);
  if (!v4
    || (*(void *)size_t length = 0, (data = xpc_dictionary_get_data(v4, "data", (size_t *)length)) == 0)
    || *(void *)length < 0xD8uLL
    || (uint64_t v6 = data, *(void *)length != data[53] + 216)
    || ((data[52] & 0xE080) != 0 ? (BOOL v7 = (data[52] & 0x13) == 1) : (BOOL v7 = 1), v7))
  {

    goto LABEL_13;
  }

  if (v6[53] < 0xCCu) {
    goto LABEL_13;
  }
  unsigned int v10 = v6[54];
  if (v10 >= 5) {
    uint64_t v8 = 0;
  }
  else {
    uint64_t v8 = v10;
  }
LABEL_14:

  return v8;
}

void sub_1831D01D4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_finalize_output_frames(uint64_t a1, uint64_t a2)
{
  uint64_t v47 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v3 = *(void **)(a1 + 40);
    if (v3 == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = *(void *)(a1 + 88);
      if (v4) {
        *(void *)(a1 + 88) = v4 + 1;
      }
    }
    if (a2)
    {
      uint64_t v5 = *(void *)(a1 + 24);
      if (v5)
      {
        uint64_t v6 = *(uint64_t (**)(uint64_t))(v5 + 96);
        if (v6)
        {
          uint64_t v7 = v6(a1);
          if (v3 != &nw_protocol_ref_counted_handle) {
            return v7;
          }
          goto LABEL_9;
        }
      }
      __nwlog_obj();
      uint64_t v13 = *(const char **)(a1 + 16);
      *(_DWORD *)buf = 136446722;
      uint64_t v40 = "__nw_protocol_finalize_output_frames";
      if (!v13) {
        uint64_t v13 = "invalid";
      }
      __int16 v41 = 2082;
      uint64_t v42 = (void *)v13;
      __int16 v43 = 2048;
      uint64_t v44 = a1;
      os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v37 = 0;
      if (__nwlog_fault(v14, &type, &v37))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          long long v15 = __nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          BOOL v17 = *(const char **)(a1 + 16);
          if (!v17) {
            BOOL v17 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          uint64_t v42 = (void *)v17;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          os_log_type_t v18 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback";
LABEL_61:
          os_log_type_t v34 = v15;
          os_log_type_t v35 = v16;
          uint32_t v36 = 32;
LABEL_75:
          _os_log_impl(&dword_1830D4000, v34, v35, v18, buf, v36);
          goto LABEL_76;
        }
        if (!v37)
        {
          long long v15 = __nwlog_obj();
          os_log_type_t v16 = type;
          if (!os_log_type_enabled(v15, type)) {
            goto LABEL_76;
          }
          uint64_t v32 = *(const char **)(a1 + 16);
          if (!v32) {
            uint64_t v32 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          uint64_t v42 = (void *)v32;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          os_log_type_t v18 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, backtrace limit exceeded";
          goto LABEL_61;
        }
        backtrace_string = (char *)__nw_create_backtrace_string();
        long long v15 = __nwlog_obj();
        os_log_type_t v16 = type;
        BOOL v26 = os_log_type_enabled(v15, type);
        if (!backtrace_string)
        {
          if (!v26) {
            goto LABEL_76;
          }
          uint64_t v33 = *(const char **)(a1 + 16);
          if (!v33) {
            uint64_t v33 = "invalid";
          }
          *(_DWORD *)buf = 136446722;
          uint64_t v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          uint64_t v42 = (void *)v33;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          os_log_type_t v18 = "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, no backtrace";
          goto LABEL_61;
        }
        if (v26)
        {
          os_log_type_t v27 = *(const char **)(a1 + 16);
          if (!v27) {
            os_log_type_t v27 = "invalid";
          }
          *(_DWORD *)buf = 136446978;
          uint64_t v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          uint64_t v42 = (void *)v27;
          __int16 v43 = 2048;
          uint64_t v44 = a1;
          __int16 v45 = 2082;
          uint64_t v46 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v15, v16, "%{public}s protocol %{public}s (%p) has invalid finalize_output_frames callback, dumping backtrace:%{public}s", buf, 0x2Au);
        }
        free(backtrace_string);
      }
LABEL_76:
      if (!v14) {
        goto LABEL_78;
      }
      goto LABEL_77;
    }
    __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v40 = "__nw_protocol_finalize_output_frames";
    os_log_type_t v14 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v37 = 0;
    if (!__nwlog_fault(v14, &type, &v37)) {
      goto LABEL_76;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v18 = "%{public}s called with null frames";
    }
    else if (v37)
    {
      __int16 v30 = (char *)__nw_create_backtrace_string();
      char v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      BOOL v31 = os_log_type_enabled(v23, type);
      if (v30)
      {
        if (v31)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          uint64_t v42 = v30;
          _os_log_impl(&dword_1830D4000, v23, v24, "%{public}s called with null frames, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v30);
        if (!v14)
        {
LABEL_78:
          uint64_t v7 = 0;
          if (v3 != &nw_protocol_ref_counted_handle) {
            return v7;
          }
LABEL_9:
          if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
          {
            uint64_t v9 = *(void *)(a1 + 88);
            if (v9)
            {
              uint64_t v10 = v9 - 1;
              *(void *)(a1 + 88) = v10;
              if (!v10)
              {
                char v11 = *(void (***)(void))(a1 + 64);
                if (v11)
                {
                  *(void *)(a1 + 64) = 0;
                  v11[2](v11);
                  _Block_release(v11);
                }
                if (*(unsigned char *)(a1 + 72))
                {
                  uint64_t v12 = *(const void **)(a1 + 64);
                  if (v12) {
                    _Block_release(v12);
                  }
                }
                free((void *)a1);
              }
            }
          }
          return v7;
        }
LABEL_77:
        free(v14);
        goto LABEL_78;
      }
      if (!v31) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v18 = "%{public}s called with null frames, no backtrace";
    }
    else
    {
      char v23 = __nwlog_obj();
      os_log_type_t v24 = type;
      if (!os_log_type_enabled(v23, type)) {
        goto LABEL_76;
      }
      *(_DWORD *)buf = 136446210;
      uint64_t v40 = "__nw_protocol_finalize_output_frames";
      os_log_type_t v18 = "%{public}s called with null frames, backtrace limit exceeded";
    }
    os_log_type_t v34 = v23;
    os_log_type_t v35 = v24;
    uint32_t v36 = 12;
    goto LABEL_75;
  }
  __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v40 = "__nw_protocol_finalize_output_frames";
  char v19 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v37 = 0;
  if (__nwlog_fault(v19, &type, &v37))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v40 = "__nw_protocol_finalize_output_frames";
        __int16 v22 = "%{public}s called with null protocol";
LABEL_68:
        _os_log_impl(&dword_1830D4000, v20, v21, v22, buf, 0xCu);
      }
    }
    else if (v37)
    {
      char v28 = (char *)__nw_create_backtrace_string();
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      BOOL v29 = os_log_type_enabled(v20, type);
      if (v28)
      {
        if (v29)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v40 = "__nw_protocol_finalize_output_frames";
          __int16 v41 = 2082;
          uint64_t v42 = v28;
          _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v28);
        goto LABEL_69;
      }
      if (v29)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v40 = "__nw_protocol_finalize_output_frames";
        __int16 v22 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_68;
      }
    }
    else
    {
      uint64_t v20 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v40 = "__nw_protocol_finalize_output_frames";
        __int16 v22 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_68;
      }
    }
  }
LABEL_69:
  if (v19) {
    free(v19);
  }
  return 0;
}

void nw_path_monitor_prohibit_interface_type(nw_path_monitor_t monitor, nw_interface_type_t interface_type)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = monitor;
  uint64_t v4 = v3;
  if (v3)
  {
    uint64_t v5 = v3;
    os_unfair_lock_lock((os_unfair_lock_t)&v5[12]);
    uint64_t v6 = v5[1].isa;
    os_unfair_lock_unlock((os_unfair_lock_t)&v5[12]);

    if (v6)
    {
      nw_parameters_prohibit_interface_type(v6, interface_type);
LABEL_4:

      goto LABEL_5;
    }
    char v11 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    BOOL v26 = "nw_path_monitor_prohibit_interface_type";
    uint64_t v12 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (__nwlog_fault(v12, &type, &v23))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v14 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_path_monitor_prohibit_interface_type";
          _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null parameters", buf, 0xCu);
        }
      }
      else if (v23)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v19 = type;
        BOOL v20 = os_log_type_enabled(v13, type);
        if (backtrace_string)
        {
          if (v20)
          {
            *(_DWORD *)buf = 136446466;
            BOOL v26 = "nw_path_monitor_prohibit_interface_type";
            __int16 v27 = 2082;
            char v28 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v19, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_40;
        }
        if (v20)
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_path_monitor_prohibit_interface_type";
          _os_log_impl(&dword_1830D4000, v13, v19, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v13 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v13, type))
        {
          *(_DWORD *)buf = 136446210;
          BOOL v26 = "nw_path_monitor_prohibit_interface_type";
          _os_log_impl(&dword_1830D4000, v13, v22, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_40:
    if (v12) {
      free(v12);
    }
    goto LABEL_4;
  }
  uint64_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  BOOL v26 = "nw_path_monitor_prohibit_interface_type";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (__nwlog_fault(v8, &type, &v23))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_path_monitor_prohibit_interface_type";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null monitor", buf, 0xCu);
      }
    }
    else if (v23)
    {
      long long v15 = (char *)__nw_create_backtrace_string();
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v9, type);
      if (v15)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          BOOL v26 = "nw_path_monitor_prohibit_interface_type";
          __int16 v27 = 2082;
          char v28 = v15;
          _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null monitor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v15);
        goto LABEL_35;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_path_monitor_prohibit_interface_type";
        _os_log_impl(&dword_1830D4000, v9, v16, "%{public}s called with null monitor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v9 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        BOOL v26 = "nw_path_monitor_prohibit_interface_type";
        _os_log_impl(&dword_1830D4000, v9, v21, "%{public}s called with null monitor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_35:
  if (v8) {
    free(v8);
  }
LABEL_5:
}

void sub_1831D0DC0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1831D11C4(_Unwind_Exception *a1, int a2, int a3, int a4, int a5, int a6, int a7, int a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, objc_super a14)
{
  a14.super_class = (Class)NWConcrete_nw_connection;
  [(_Unwind_Exception *)&a14 dealloc];
  _Unwind_Resume(a1);
}

void nw_connection_cancel_update_handler(NWConcrete_nw_connection *a1)
{
  id v1 = a1;
  v22[0] = 0;
  v22[1] = v22;
  v22[2] = 0x3032000000;
  v22[3] = __Block_byref_object_copy__10;
  v22[4] = __Block_byref_object_dispose__11;
  id v23 = 0;
  v20[0] = 0;
  v20[1] = v20;
  void v20[2] = 0x3032000000;
  v20[3] = __Block_byref_object_copy__10;
  v20[4] = __Block_byref_object_dispose__11;
  id v21 = 0;
  v18[0] = 0;
  v18[1] = v18;
  v18[2] = 0x3032000000;
  v18[3] = __Block_byref_object_copy__10;
  v18[4] = __Block_byref_object_dispose__11;
  id v19 = 0;
  v16[0] = 0;
  v16[1] = v16;
  v16[2] = 0x3032000000;
  v16[3] = __Block_byref_object_copy__10;
  void v16[4] = __Block_byref_object_dispose__11;
  id v17 = 0;
  v14[0] = 0;
  v14[1] = v14;
  v14[2] = 0x3032000000;
  v14[3] = __Block_byref_object_copy__10;
  void v14[4] = __Block_byref_object_dispose__11;
  id v15 = 0;
  v12[0] = 0;
  v12[1] = v12;
  v12[2] = 0x3032000000;
  v12[3] = __Block_byref_object_copy__10;
  v12[4] = __Block_byref_object_dispose__11;
  id v13 = 0;
  p_lock = &v1->lock;
  v4[0] = MEMORY[0x1E4F143A8];
  v4[1] = 3221225472;
  v4[2] = ___ZL35nw_connection_cancel_update_handlerP24NWConcrete_nw_connection_block_invoke;
  v4[3] = &unk_1E523DE28;
  uint64_t v5 = v1;
  uint64_t v6 = v22;
  uint64_t v7 = v20;
  uint64_t v8 = v18;
  uint64_t v9 = v16;
  os_log_type_t v10 = v14;
  char v11 = v12;
  uint64_t v3 = v1;
  os_unfair_lock_lock(p_lock);
  ___ZL35nw_connection_cancel_update_handlerP24NWConcrete_nw_connection_block_invoke(v4);
  os_unfair_lock_unlock(p_lock);

  _Block_object_dispose(v12, 8);
  _Block_object_dispose(v14, 8);

  _Block_object_dispose(v16, 8);
  _Block_object_dispose(v18, 8);

  _Block_object_dispose(v20, 8);
  _Block_object_dispose(v22, 8);
}

void ___ZL35nw_connection_cancel_update_handlerP24NWConcrete_nw_connection_block_invoke(void *a1)
{
  uint64_t v2 = a1[4];
  uint64_t v3 = *(void *)(v2 + 368);
  if (v3)
  {
    nw_queue_cancel_source(v3);
    *(void *)(a1[4] + 368) = 0;
    uint64_t v2 = a1[4];
  }
  uint64_t v4 = *(void **)(v2 + 144);
  *(void *)(v2 + 144) = 0;

  uint64_t v5 = a1[4];
  uint64_t v6 = *(void **)(v5 + 176);
  *(void *)(v5 + 176) = 0;

  uint64_t v7 = a1[4];
  uint64_t v8 = *(void **)(v7 + 184);
  *(void *)(v7 + 184) = 0;

  uint64_t v9 = a1[4];
  uint64_t v10 = *(void *)(v9 + 224);
  if (v10)
  {
    nw_queue_cancel_source(v10);
    *(void *)(a1[4] + 224) = 0;
    uint64_t v9 = a1[4];
  }
  *(unsigned char *)(v9 + 109) &= ~0x40u;
  char v11 = _Block_copy(*(const void **)(a1[4] + 208));
  uint64_t v12 = *(void *)(a1[5] + 8);
  id v13 = *(void **)(v12 + 40);
  *(void *)(v12 + 40) = v11;

  uint64_t v14 = a1[4];
  id v15 = *(void **)(v14 + 208);
  *(void *)(v14 + 208) = 0;

  os_log_type_t v16 = _Block_copy(*(const void **)(a1[4] + 232));
  uint64_t v17 = *(void *)(a1[6] + 8);
  os_log_type_t v18 = *(void **)(v17 + 40);
  *(void *)(v17 + 40) = v16;

  uint64_t v19 = a1[4];
  BOOL v20 = *(void **)(v19 + 232);
  *(void *)(v19 + 232) = 0;

  id v21 = _Block_copy(*(const void **)(a1[4] + 240));
  uint64_t v22 = *(void *)(a1[7] + 8);
  id v23 = *(void **)(v22 + 40);
  *(void *)(v22 + 40) = v21;

  uint64_t v24 = a1[4];
  uint64_t v25 = *(void **)(v24 + 240);
  *(void *)(v24 + 240) = 0;

  BOOL v26 = _Block_copy(*(const void **)(a1[4] + 248));
  uint64_t v27 = *(void *)(a1[8] + 8);
  char v28 = *(void **)(v27 + 40);
  *(void *)(v27 + 40) = v26;

  uint64_t v29 = a1[4];
  __int16 v30 = *(void **)(v29 + 248);
  *(void *)(v29 + 248) = 0;

  BOOL v31 = _Block_copy(*(const void **)(a1[4] + 256));
  uint64_t v32 = *(void *)(a1[9] + 8);
  uint64_t v33 = *(void **)(v32 + 40);
  *(void *)(v32 + 40) = v31;

  uint64_t v34 = a1[4];
  os_log_type_t v35 = *(void **)(v34 + 256);
  *(void *)(v34 + 256) = 0;

  uint32_t v36 = _Block_copy(*(const void **)(a1[4] + 384));
  uint64_t v37 = *(void *)(a1[10] + 8);
  uint64_t v38 = *(void **)(v37 + 40);
  *(void *)(v37 + 40) = v36;

  uint64_t v39 = a1[4];
  uint64_t v40 = *(void **)(v39 + 384);
  *(void *)(v39 + 384) = 0;

  __int16 v41 = *(void **)(a1[4] + 264);
  if (v41)
  {
    __int16 v43 = (void *)*v41;
    uint64_t v42 = (void *)v41[1];
    if (*v41)
    {
      do
      {
        v43[1] = v42;
        *(void *)v41[1] = v43;
        free(v41);
        __int16 v41 = v43;
        __int16 v43 = (void *)*v43;
        uint64_t v42 = (void *)v41[1];
      }
      while (v43);
    }
    *(void *)(a1[4] + 272) = v42;
    void *v42 = 0;
    free(v41);
  }
}

uint64_t nw_resolution_report_get_milliseconds(nw_resolution_report_t resolution_report)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_resolution_report_t v1 = resolution_report;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t isa = (uint64_t)v1[1].isa;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_resolution_report_get_milliseconds";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_resolution_report_get_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null resolution_report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_resolution_report_get_milliseconds";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null resolution_report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_resolution_report_get_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null resolution_report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_resolution_report_get_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null resolution_report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t isa = 0;
LABEL_3:

  return isa;
}

uint64_t nw_establishment_report_get_resolution_started_after_milliseconds(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 3);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_resolution_started_after_milliseconds";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_resolution_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_resolution_started_after_milliseconds";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_resolution_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_resolution_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_establishment_report_get_flow_started_after_milliseconds(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_resolution_report_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((void *)v1 + 4);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_flow_started_after_milliseconds";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_flow_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_flow_started_after_milliseconds";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_flow_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_flow_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_establishment_report_get_duration_milliseconds(nw_establishment_report_t report)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_establishment_report_t v1 = report;
  nw_establishment_report_t v2 = v1;
  if (v1)
  {
    uint64_t isa = (uint64_t)v1[2].isa;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_duration_milliseconds";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_duration_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_duration_milliseconds";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_duration_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_duration_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t isa = 0;
LABEL_3:

  return isa;
}

uint64_t nw_establishment_report_get_attempt_started_after_milliseconds(nw_establishment_report_t report)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_establishment_report_t v1 = report;
  nw_establishment_report_t v2 = v1;
  if (v1)
  {
    uint64_t isa = (uint64_t)v1[1].isa;
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  os_log_type_t v16 = "nw_establishment_report_get_attempt_started_after_milliseconds";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_attempt_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          os_log_type_t v16 = "nw_establishment_report_get_attempt_started_after_milliseconds";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_attempt_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        os_log_type_t v16 = "nw_establishment_report_get_attempt_started_after_milliseconds";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t isa = 0;
LABEL_3:

  return isa;
}

void network_release(void *object)
{
  if (object) {
    os_release(object);
  }
}

void nwlog_legacy_init_once(void)
{
  if ((gHasForked & 1) == 0) {
    gLogObj = (uint64_t)os_log_create((const char *)nw_oslog_subsystem, "");
  }
}

BOOL nw_connection_is_unlisted_tracker(void *a1)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  nw_establishment_report_t v1 = a1;
  nw_establishment_report_t v2 = v1;
  uint64_t v18 = 0;
  uint64_t v19 = &v18;
  uint64_t v20 = 0x2020000000;
  char v21 = 0;
  if (v1)
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_is_unlisted_tracker_block_invoke;
    v13[3] = &unk_1E524B978;
    id v15 = &v18;
    uint64_t v14 = v1;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_is_unlisted_tracker_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    BOOL v3 = *((unsigned char *)v19 + 24) != 0;

    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  id v23 = "nw_connection_is_unlisted_tracker";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_connection_is_unlisted_tracker";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          id v23 = "nw_connection_is_unlisted_tracker";
          __int16 v24 = 2082;
          uint64_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_connection_is_unlisted_tracker";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        id v23 = "nw_connection_is_unlisted_tracker";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  BOOL v3 = 0;
LABEL_3:
  _Block_object_dispose(&v18, 8);

  return v3;
}

uint64_t __nw_connection_is_unlisted_tracker_block_invoke(uint64_t result)
{
  *(unsigned char *)(*(void *)(*(void *)(result + 40) + 8) + 24) = (*(unsigned char *)(*(void *)(result + 32) + 110) & 2) != 0;
  return result;
}

void sub_1831D27FC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, ...)
{
  va_start(va, a7);

  _Block_object_dispose(va, 8);
  _Unwind_Resume(a1);
}

void nw_quic_stream_set_application_error(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_application_error_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  char v16 = "nw_quic_stream_set_application_error";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_quic_stream_set_application_error";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          char v16 = "nw_quic_stream_set_application_error";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_quic_stream_set_application_error";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        char v16 = "nw_quic_stream_set_application_error";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_1831D2CEC(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_application_error_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  uint64_t v5 = *(void *)(a2 + 24);
  if (v5) {
    (*(void (**)(uint64_t, void))(v5 + 16))(v5, *(void *)(a1 + 32));
  }
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t nw_quic_stream_get_application_error(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    uint64_t v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_application_error_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    uint64_t v2 = *(void *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_quic_stream_get_application_error";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_stream_get_application_error";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_stream_get_application_error";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_stream_get_application_error";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_stream_get_application_error";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831D3074(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_application_error_block_invoke(uint64_t a1, uint64_t a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *(void *)(a2 + 16);
  return 1;
}

uint64_t nw_quic_stream_get_id(void *a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  if (nw_protocol_metadata_is_quic_stream(v1))
  {
    *(void *)buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x2020000000;
    uint64_t v16 = 0;
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_get_id_block_invoke;
    v12[3] = &unk_1E5248E90;
    v12[4] = buf;
    nw_protocol_metadata_access_handle((uint64_t)v1, (uint64_t)v12);
    uint64_t v2 = *(void *)(*(void *)&buf[8] + 24);
    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_quic_stream_get_id";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_stream_get_id";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_quic_stream_get_id";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_stream_get_id";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_quic_stream_get_id";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
  uint64_t v2 = 0;
LABEL_3:

  return v2;
}

void sub_1831D33CC(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, ...)
{
  va_start(va, a11);
  _Block_object_dispose(va, 8);

  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_get_id_block_invoke(uint64_t a1, void *a2)
{
  *(void *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) = *a2;
  return 1;
}

void nw_quic_stream_set_type(void *a1, char a2)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_type_block_invoke;
    v12[3] = &__block_descriptor_33_e9_B16__0_v8l;
    char v13 = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v17 = "nw_quic_stream_set_type";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v14 = 0;
  if (__nwlog_fault(v5, &type, &v14))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_quic_stream_set_type";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v14)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v17 = "nw_quic_stream_set_type";
          __int16 v18 = 2082;
          uint64_t v19 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_quic_stream_set_type";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v17 = "nw_quic_stream_set_type";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_1831D36F4(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_quic_stream_set_id(void *a1, uint64_t a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v12[0] = MEMORY[0x1E4F143A8];
    v12[1] = 3221225472;
    v12[2] = __nw_quic_stream_set_id_block_invoke;
    v12[3] = &__block_descriptor_40_e9_B16__0_v8l;
    void v12[4] = a2;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v12);
    goto LABEL_3;
  }
  uint64_t v4 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v16 = "nw_quic_stream_set_id";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v5, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_quic_stream_set_id";
        _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v9 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v16 = "nw_quic_stream_set_id";
          __int16 v17 = 2082;
          __int16 v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v10)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_quic_stream_set_id";
        _os_log_impl(&dword_1830D4000, v6, v9, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v11 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v16 = "nw_quic_stream_set_id";
        _os_log_impl(&dword_1830D4000, v6, v11, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v5) {
    free(v5);
  }
LABEL_3:
}

void sub_1831D39F0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_quic_stream_set_connection_metadata(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_stream_set_connection_metadata_block_invoke;
    v13[3] = &unk_1E5248F68;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v18 = "nw_quic_stream_set_connection_metadata";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_quic_stream_set_connection_metadata";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v18 = "nw_quic_stream_set_connection_metadata";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_quic_stream_set_connection_metadata";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_quic_stream_set_connection_metadata";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_stream(stream_metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_1831D3D08(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

void nw_quic_stream_set_application_error_handler(void *a1, void *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  if (nw_protocol_metadata_is_quic_stream(v3))
  {
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_quic_stream_set_application_error_handler_block_invoke;
    v13[3] = &unk_1E5248ED8;
    id v14 = v4;
    nw_protocol_metadata_access_handle((uint64_t)v3, (uint64_t)v13);

    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v18 = "nw_quic_stream_set_application_error_handler";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v6, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_quic_stream_set_application_error_handler";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata)", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v18 = "nw_quic_stream_set_application_error_handler";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_quic_stream_set_application_error_handler";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_quic_stream_set_application_error_handler";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null nw_protocol_metadata_is_quic_stream(metadata), backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void sub_1831D4034(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, void *a17)
{
  _Unwind_Resume(a1);
}

BOOL nw_protocol_metadata_is_quic_stream(void *a1)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    id v3 = (id *)v1;
    id v4 = v3[1];

    if (nw_protocol_copy_quic_stream_definition::onceToken != -1) {
      dispatch_once(&nw_protocol_copy_quic_stream_definition::onceToken, &__block_literal_global_15_56153);
    }
    BOOL is_equal_unsafe = nw_protocol_definition_is_equal_unsafe((uint64_t)v4, nw_protocol_copy_quic_stream_definition::quic_definition);

    goto LABEL_5;
  }
  os_log_type_t v7 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  __int16 v18 = "nw_protocol_metadata_is_quic_stream";
  os_log_type_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_protocol_metadata_is_quic_stream";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null metadata", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)buf = 136446466;
          __int16 v18 = "nw_protocol_metadata_is_quic_stream";
          __int16 v19 = 2082;
          uint64_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null metadata, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_22;
      }
      if (v13)
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_protocol_metadata_is_quic_stream";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null metadata, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)buf = 136446210;
        __int16 v18 = "nw_protocol_metadata_is_quic_stream";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null metadata, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_22:
  if (v8) {
    free(v8);
  }
  BOOL is_equal_unsafe = 0;
LABEL_5:

  return is_equal_unsafe;
}

void sub_1831D4348(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t __nw_quic_stream_set_application_error_handler_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  uint64_t v5 = _Block_copy(*(const void **)(a1 + 32));
  uint64_t v6 = *(void **)(a2 + 24);
  *(void *)(a2 + 24) = v5;

  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_stream_set_connection_metadata_block_invoke(uint64_t a1, uint64_t a2)
{
  id v4 = (os_unfair_lock_s *)(a2 + 40);
  os_unfair_lock_lock((os_unfair_lock_t)(a2 + 40));
  objc_storeStrong((id *)(a2 + 32), *(id *)(a1 + 32));
  os_unfair_lock_unlock(v4);
  return 1;
}

uint64_t __nw_quic_stream_set_type_block_invoke(uint64_t a1, uint64_t a2)
{
  *(unsigned char *)(a2 + 46) = *(unsigned char *)(a1 + 32);
  return 1;
}

uint64_t __nw_quic_stream_set_id_block_invoke(uint64_t a1, void *a2)
{
  *a2 = *(void *)(a1 + 32);
  return 1;
}

void __nw_context_copy_implicit_context_block_invoke()
{
  uint64_t v11 = *MEMORY[0x1E4F143B8];
  BOOL v0 = -[NWConcrete_nw_context initWithIdentifier:]([NWConcrete_nw_context alloc], "Default Network Context");
  id v1 = (void *)nw_context_copy_implicit_context::implicit_context;
  nw_context_copy_implicit_context::implicit_context = v0;

  uint64_t v2 = (_DWORD *)nw_context_copy_implicit_context::implicit_context;
  *(unsigned char *)(nw_context_copy_implicit_context::implicit_context + 136) |= 4u;
  id v3 = getenv("DEFAULT_NETWORK_PRIVACY_LEVEL");
  if (v3)
  {
    id v4 = v3;
    if (!strcasecmp(v3, "public"))
    {
      int v6 = 1;
      goto LABEL_11;
    }
    if (strcasecmp(v4, "private"))
    {
      if (!strcasecmp(v4, "sensitive"))
      {
        int v6 = 3;
        goto LABEL_11;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v5 = (id)gLogObj;
      if (os_log_type_enabled(v5, OS_LOG_TYPE_ERROR))
      {
        int v7 = 136446466;
        os_log_type_t v8 = "nw_context_get_default_implicit_level";
        __int16 v9 = 2082;
        os_log_type_t v10 = v4;
        _os_log_impl(&dword_1830D4000, v5, OS_LOG_TYPE_ERROR, "%{public}s Unsupported privacy level: %{public}s", (uint8_t *)&v7, 0x16u);
      }

      uint64_t v2 = (_DWORD *)nw_context_copy_implicit_context::implicit_context;
    }
  }
  int v6 = 2;
LABEL_11:
  v2[31] = v6;
  nw_context_activate(v2);
}

void nw_parameters_set_context(void *a1, void *a2)
{
  uint64_t v29 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  uint64_t v5 = v4;
  if (!v3)
  {
    __int16 v9 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    uint64_t v26 = "nw_parameters_set_context";
    os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v23 = 0;
    if (!__nwlog_fault(v10, &type, &v23)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_parameters_set_context";
        _os_log_impl(&dword_1830D4000, v11, v12, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v23)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v11, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)buf = 136446466;
          uint64_t v26 = "nw_parameters_set_context";
          __int16 v27 = 2082;
          char v28 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_38:
        if (!v10) {
          goto LABEL_4;
        }
LABEL_39:
        free(v10);
        goto LABEL_4;
      }
      if (v17)
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_parameters_set_context";
        _os_log_impl(&dword_1830D4000, v11, v16, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v11 = __nwlog_obj();
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v11, type))
      {
        *(_DWORD *)buf = 136446210;
        uint64_t v26 = "nw_parameters_set_context";
        _os_log_impl(&dword_1830D4000, v11, v21, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_37:

    goto LABEL_38;
  }
  if (v4)
  {
    nw_context_activate(v4);
    BOOL v6 = nw_context_copy_cache_context(v5);
    uint64_t v7 = v3[13];
    os_log_type_t v8 = *(void **)(v7 + 136);
    *(void *)(v7 + 136) = v6;

    goto LABEL_4;
  }
  BOOL v13 = __nwlog_obj();
  *(_DWORD *)buf = 136446210;
  uint64_t v26 = "nw_parameters_set_context";
  os_log_type_t v10 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v23 = 0;
  if (!__nwlog_fault(v10, &type, &v23)) {
    goto LABEL_38;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v14 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_parameters_set_context";
      _os_log_impl(&dword_1830D4000, v11, v14, "%{public}s called with null context", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (!v23)
  {
    uint64_t v11 = __nwlog_obj();
    os_log_type_t v22 = type;
    if (os_log_type_enabled(v11, type))
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_parameters_set_context";
      _os_log_impl(&dword_1830D4000, v11, v22, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_37;
  }
  __int16 v18 = (char *)__nw_create_backtrace_string();
  uint64_t v11 = __nwlog_obj();
  os_log_type_t v19 = type;
  BOOL v20 = os_log_type_enabled(v11, type);
  if (!v18)
  {
    if (v20)
    {
      *(_DWORD *)buf = 136446210;
      uint64_t v26 = "nw_parameters_set_context";
      _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null context, no backtrace", buf, 0xCu);
    }
    goto LABEL_37;
  }
  if (v20)
  {
    *(_DWORD *)buf = 136446466;
    uint64_t v26 = "nw_parameters_set_context";
    __int16 v27 = 2082;
    char v28 = v18;
    _os_log_impl(&dword_1830D4000, v11, v19, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v18);
  if (v10) {
    goto LABEL_39;
  }
LABEL_4:
}

void sub_1831D4A7C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_initialize_protocol(void *a1, uint64_t a2, int a3)
{
  uint64_t v154 = *MEMORY[0x1E4F143B8];
  BOOL v6 = a1;
  uint64_t v7 = v6;
  if (!v6)
  {
    __int16 v86 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v139 = "nw_endpoint_handler_get_mode";
    uint64_t v87 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v136 = 0;
    if (__nwlog_fault(v87, &type, &v136))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v88 = __nwlog_obj();
        os_log_type_t v89 = type;
        if (os_log_type_enabled(v88, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v139 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v88, v89, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v136)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v88 = __nwlog_obj();
        os_log_type_t v91 = type;
        BOOL v92 = os_log_type_enabled(v88, type);
        if (backtrace_string)
        {
          if (v92)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v139 = "nw_endpoint_handler_get_mode";
            __int16 v140 = 2082;
            os_log_type_t v141 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v88, v91, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_100;
        }
        if (v92)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v139 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v88, v91, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v88 = __nwlog_obj();
        os_log_type_t v98 = type;
        if (os_log_type_enabled(v88, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v139 = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v88, v98, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_100:
    if (v87) {
      free(v87);
    }
    unsigned int mode = 0;
    goto LABEL_103;
  }
  unsigned int mode = v6->mode;

  if (mode == 2)
  {
    __int16 v9 = nw_endpoint_handler_copy_flow(v7);
    os_log_type_t v10 = v9;
    if ((*((unsigned char *)v9 + 32) & 8) == 0)
    {
      *((unsigned char *)v9 + 32) |= 8u;
      strcpy((char *)v9 + 48, "endpoint_flow");
      *((void *)v9 + 10) = 0x100000004;
      if (a3)
      {
        *((void *)v9 + 20) = nw_flow_output_available;
        *((void *)v9 + 19) = nw_flow_input_available;
        *((void *)v9 + 34) = nw_flow_input_finished;
        uint64_t v11 = nw_flow_supports_external_data;
        os_log_type_t v12 = nw_flow_notify;
        BOOL v13 = nw_flow_disconnected;
      }
      else
      {
        *((void *)v9 + 13) = nw_protocol_default_replace_input_handler;
        *((void *)v9 + 35) = nw_protocol_default_output_finished;
        *((void *)v9 + 44) = nw_protocol_default_input_flush;
        *((void *)v9 + 42) = nw_protocol_default_get_message_properties;
        *((void *)v9 + 24) = nw_protocol_default_link_state;
        *((void *)v9 + 25) = nw_protocol_default_get_parameters;
        *((void *)v9 + 27) = nw_protocol_default_get_local;
        *((void *)v9 + 28) = nw_protocol_default_get_remote;
        *((void *)v9 + 26) = nw_protocol_default_get_path;
        *((void *)v9 + 32) = nw_protocol_default_updated_path;
        *((void *)v9 + 36) = nw_protocol_default_get_output_local;
        *((void *)v9 + 37) = nw_protocol_default_get_output_interface;
        *((void *)v9 + 14) = nw_protocol_default_connect;
        *((void *)v9 + 15) = nw_protocol_default_disconnect;
        *((void *)v9 + 16) = nw_protocol_default_connected;
        *((void *)v9 + 18) = nw_protocol_default_error;
        *((void *)v9 + 43) = nw_protocol_default_reset;
        *((void *)v9 + 38) = nw_protocol_default_waiting_for_output;
        *((void *)v9 + 39) = nw_protocol_default_copy_info;
        *((void *)v9 + 29) = nw_protocol_default_register_notification;
        *((void *)v9 + 30) = nw_protocol_default_unregister_notification;
        *((void *)v9 + 40) = nw_protocol_default_add_listen_handler;
        *((void *)v9 + 41) = nw_protocol_default_remove_listen_handler;
        *((void *)v9 + 11) = nw_flow_passthrough_add_input_handler;
        *((void *)v9 + 12) = nw_flow_passthrough_remove_input_handler;
        *((void *)v9 + 21) = nw_flow_passthrough_get_input_frames;
        *((void *)v9 + 22) = nw_flow_passthrough_get_output_frames;
        *((void *)v9 + 23) = nw_flow_passthrough_finalize_output_frames;
        *((void *)v9 + 20) = nw_flow_passthrough_output_available;
        *((void *)v9 + 19) = nw_flow_passthrough_input_available;
        *((void *)v9 + 34) = nw_flow_passthrough_input_finished;
        uint64_t v11 = nw_flow_passthrough_supports_external_data;
        os_log_type_t v12 = nw_flow_passthrough_notify;
        BOOL v13 = nw_flow_passthrough_disconnected;
      }
      *((void *)v9 + 17) = v13;
      *((void *)v9 + 33) = v11;
      *((void *)v9 + 18) = nw_flow_error;
      *((void *)v9 + 14) = nw_flow_connect;
      *((void *)v9 + 16) = nw_flow_connected;
      *((void *)v9 + 25) = nw_flow_get_parameters;
      *((void *)v9 + 26) = nw_flow_get_path;
      *((void *)v9 + 31) = v12;
      *((void *)v9 + 32) = nw_flow_updated_path;
      *((void *)v9 + 27) = nw_flow_get_local;
      *((void *)v9 + 28) = nw_flow_get_remote;
      *((void *)v9 + 45) = nw_flow_listener_new_flow;
      *((void *)v9 + 46) = nw_flow_listener_disconnected;
      uint64_t internal = nw_hash_table_create_internal(7u, 0, (const void *(*)(const void *, unsigned int *))nw_flow_protocol_get_key, (unsigned int (*)(const void *, unsigned int))nw_flow_protocol_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_flow_protocol_matches_key, (void (*)(void *))nw_flow_protocol_release);
      if (internal) {
        *(_DWORD *)(internal + 48) &= ~2u;
      }
      *((void *)v10 + 108) = internal;
    }
    __int16 v15 = *(_WORD *)(a2 + 332);
    if (v15) {
      goto LABEL_73;
    }
    *(_WORD *)(a2 + 332) = v15 | 1;
    objc_storeStrong((id *)(a2 + 160), a1);
    os_log_type_t v16 = v7;
    BOOL v17 = v10;
    __int16 v18 = v17;
    __int16 v135 = v16;
    if ((*((unsigned char *)v10 + 32) & 8) != 0)
    {
      os_log_type_t v19 = v16;
      id v20 = v19[4];

      os_log_type_t v21 = *(void **)(a2 + 176);
      *(void *)(a2 + 176) = v20;

      id v22 = nw_parameters_copy_context(*(void **)(a2 + 176));
      char v23 = *(void **)(a2 + 184);
      *(void *)(a2 + 184) = v22;

      *(void *)(a2 + 16) = (char *)v18 + 48;
      *(void *)(a2 + 24) = (char *)v18 + 88;
      *(void *)(a2 + 88) = a2;
      *(void *)(a2 + 64) = (char *)v18 + 360;
      if (nw_flow_initialize_replay_protocol(void)::onceToken != -1) {
        dispatch_once(&nw_flow_initialize_replay_protocol(void)::onceToken, &__block_literal_global_103);
      }
      *(void *)(a2 + 136) = a2;
      *(void *)(a2 + 112) = &g_replay_protocol_identifier;
      *(void *)(a2 + 120) = &g_replay_protocol_callbacks;
      uint64_t v24 = *(void *)(a2 + 40);
      if (!v24)
      {
        *(void *)(a2 + 40) = a2;
        goto LABEL_72;
      }
      if (v24 == a2) {
        goto LABEL_72;
      }
      uint64_t v25 = v19;
      char v26 = *((unsigned char *)v25 + 268);

      if ((v26 & 0x20) != 0) {
        goto LABEL_72;
      }
      __int16 v120 = (char *)v18;
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      id v27 = (id)gconnectionLogObj;
      char v28 = v25;

      uint64_t v29 = v28;
      char v30 = *((unsigned char *)v25 + 268);

      if (v30) {
        BOOL v31 = "dry-run ";
      }
      else {
        BOOL v31 = "";
      }
      nw_endpoint_t v32 = nw_endpoint_handler_copy_endpoint(v29);
      logging_description = nw_endpoint_get_logging_description(v32);
      __int16 v129 = (char *)(v28 + 21);
      uint64_t v33 = v29;
      uint64_t v34 = v33;
      uint64_t v35 = v33[30];
      if (v35 > 5) {
        uint32_t v36 = "unknown-state";
      }
      else {
        uint32_t v36 = off_1E523FB38[v35];
      }
      os_log_t log = (os_log_t)v36;
      char v126 = v25;

      uint64_t v37 = v34;
      uint64_t v38 = v37;
      BOOL v117 = v34;
      uint64_t v39 = "path";
      switch(v7->mode)
      {
        case 0:
          break;
        case 1:
          uint64_t v39 = "resolver";
          break;
        case 2:
          uint64_t v39 = nw_endpoint_flow_mode_string(v37[31]);
          break;
        case 3:
          uint64_t v39 = "proxy";
          break;
        case 4:
          uint64_t v39 = "fallback";
          break;
        case 5:
          uint64_t v39 = "transform";
          break;
        default:
          uint64_t v39 = "unknown-mode";
          break;
      }

      uint64_t v40 = v38;
      os_unfair_lock_lock((os_unfair_lock_t)v40 + 28);
      id v41 = v40[8];
      lock = (os_unfair_lock_s *)(v40 + 14);
      os_unfair_lock_unlock((os_unfair_lock_t)v40 + 28);
      id v119 = v40;

      *(_DWORD *)buf = 136447746;
      os_log_type_t v139 = "nw_flow_protocol_initialize";
      __int16 v140 = 2082;
      os_log_type_t v141 = v129;
      __int16 v142 = 2082;
      os_log_type_t v143 = v31;
      __int16 v144 = 2082;
      uint64_t v145 = (void *)logging_description;
      __int16 v146 = 2082;
      BOOL v147 = log;
      __int16 v148 = 2082;
      os_log_type_t v149 = v39;
      __int16 v150 = 2114;
      id v151 = v41;
      __int16 v134 = (const char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v136 = 0;
      if (__nwlog_fault(v134, &type, &v136))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v42 = (id)gconnectionLogObj;
          os_log_type_t v43 = type;
          if (os_log_type_enabled(v42, type))
          {
            os_log_type_t loga = v42;
            uint64_t v44 = v119;

            __int16 v45 = v44;
            BOOL v46 = (*((unsigned char *)v126 + 268) & 1) == 0;

            if (v46) {
              uint64_t v47 = "";
            }
            else {
              uint64_t v47 = "dry-run ";
            }
            nw_endpoint_t v48 = nw_endpoint_handler_copy_endpoint(v45);
            uint64_t v49 = nw_endpoint_get_logging_description(v48);
            char v50 = v45;
            BOOL v51 = v50;
            uint64_t v52 = v117[30];
            if (v52 > 5) {
              BOOL v53 = "unknown-state";
            }
            else {
              BOOL v53 = off_1E523FB38[v52];
            }
            id v128 = v53;

            char v73 = v51;
            __int16 v74 = "path";
            switch(v7->mode)
            {
              case 0:
                break;
              case 1:
                __int16 v74 = "resolver";
                break;
              case 2:
                __int16 v74 = nw_endpoint_flow_mode_string(v73[31]);
                break;
              case 3:
                __int16 v74 = "proxy";
                break;
              case 4:
                __int16 v74 = "fallback";
                break;
              case 5:
                __int16 v74 = "transform";
                break;
              default:
                __int16 v74 = "unknown-mode";
                break;
            }
            __int16 v118 = v74;

            os_log_type_t v83 = v73;
            os_unfair_lock_lock(lock);
            id v84 = v119[8];
            os_unfair_lock_unlock(lock);

            *(_DWORD *)buf = 136447746;
            os_log_type_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            os_log_type_t v141 = v129;
            __int16 v142 = 2082;
            os_log_type_t v143 = v47;
            __int16 v144 = 2082;
            uint64_t v145 = (void *)v49;
            __int16 v146 = 2082;
            BOOL v147 = (void *)v128;
            __int16 v148 = 2082;
            os_log_type_t v149 = v118;
            __int16 v150 = 2114;
            id v151 = v84;
            _os_log_impl(&dword_1830D4000, loga, v43, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non-NULL at initialization", buf, 0x48u);

            uint64_t v42 = loga;
          }

          goto LABEL_70;
        }
        if (v136)
        {
          BOOL v54 = __nw_create_backtrace_string();
          if (v54)
          {
            __int16 v55 = (char *)v54;
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v56 = (id)gconnectionLogObj;
            os_log_type_t v57 = type;
            if (os_log_type_enabled(v56, type))
            {
              id_string = nw_endpoint_handler_get_id_string(v119);
              os_log_t logb = v56;
              os_log_type_t v127 = nw_endpoint_handler_dry_run_string(v119);
              nw_endpoint_t v130 = nw_endpoint_handler_copy_endpoint(v119);
              uint64_t v59 = id_string;
              uint64_t v60 = nw_endpoint_get_logging_description(v130);
              BOOL v61 = nw_endpoint_handler_state_string(v119);
              os_log_type_t v62 = nw_endpoint_handler_mode_string(v119);
              id v63 = nw_endpoint_handler_copy_current_path(v119);
              *(_DWORD *)buf = 136448002;
              os_log_type_t v139 = "nw_flow_protocol_initialize";
              __int16 v140 = 2082;
              os_log_type_t v141 = (void *)v59;
              __int16 v142 = 2082;
              os_log_type_t v143 = v127;
              __int16 v144 = 2082;
              uint64_t v145 = (void *)v60;
              __int16 v146 = 2082;
              BOOL v147 = (void *)v61;
              __int16 v148 = 2082;
              os_log_type_t v149 = v62;
              __int16 v150 = 2114;
              id v151 = v63;
              __int16 v152 = 2082;
              os_log_type_t v153 = v55;
              _os_log_impl(&dword_1830D4000, logb, v57, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non-NULL at initialization, dumping backtrace:%{public}s", buf, 0x52u);

              uint64_t v56 = logb;
            }

            free(v55);
            goto LABEL_70;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v64 = (id)gconnectionLogObj;
          os_log_type_t v75 = type;
          if (os_log_type_enabled(v64, type))
          {
            __int16 v76 = nw_endpoint_handler_get_id_string(v119);
            os_log_type_t logd = v64;
            size_t v77 = nw_endpoint_handler_dry_run_string(v119);
            uint64_t v78 = v76;
            nw_endpoint_t v132 = nw_endpoint_handler_copy_endpoint(v119);
            BOOL v79 = nw_endpoint_get_logging_description(v132);
            int v80 = nw_endpoint_handler_state_string(v119);
            os_log_type_t v81 = nw_endpoint_handler_mode_string(v119);
            id v82 = nw_endpoint_handler_copy_current_path(v119);
            *(_DWORD *)buf = 136447746;
            os_log_type_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            os_log_type_t v141 = (void *)v78;
            __int16 v142 = 2082;
            os_log_type_t v143 = v77;
            __int16 v144 = 2082;
            uint64_t v145 = (void *)v79;
            __int16 v146 = 2082;
            BOOL v147 = (void *)v80;
            __int16 v148 = 2082;
            os_log_type_t v149 = v81;
            __int16 v150 = 2114;
            id v151 = v82;
            _os_log_impl(&dword_1830D4000, logd, v75, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non-NULL at initialization, no backtrace", buf, 0x48u);

            BOOL v64 = logd;
          }
        }
        else
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v64 = (id)gconnectionLogObj;
          os_log_type_t v65 = type;
          if (os_log_type_enabled(v64, type))
          {
            uint64_t v66 = nw_endpoint_handler_get_id_string(v119);
            os_log_type_t logc = v64;
            os_log_type_t v67 = nw_endpoint_handler_dry_run_string(v119);
            char v68 = v66;
            nw_endpoint_t v131 = nw_endpoint_handler_copy_endpoint(v119);
            os_log_type_t v69 = nw_endpoint_get_logging_description(v131);
            va_list v70 = nw_endpoint_handler_state_string(v119);
            os_log_type_t v71 = nw_endpoint_handler_mode_string(v119);
            id v72 = nw_endpoint_handler_copy_current_path(v119);
            *(_DWORD *)buf = 136447746;
            os_log_type_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            os_log_type_t v141 = (void *)v68;
            __int16 v142 = 2082;
            os_log_type_t v143 = v67;
            __int16 v144 = 2082;
            uint64_t v145 = (void *)v69;
            __int16 v146 = 2082;
            BOOL v147 = (void *)v70;
            __int16 v148 = 2082;
            os_log_type_t v149 = v71;
            __int16 v150 = 2114;
            id v151 = v72;
            _os_log_impl(&dword_1830D4000, logc, v65, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Flow protocol handle non-NULL at initialization, backtrace limit exceeded", buf, 0x48u);

            BOOL v64 = logc;
          }
        }
      }
LABEL_70:
      __int16 v18 = (NWConcrete_nw_endpoint_mode_handler *)v120;
      uint64_t v85 = (char *)v134;
      if (v134) {
LABEL_71:
      }
        free(v85);
LABEL_72:

      *(void *)(a2 + 272) = 0;
      *(void *)(a2 + 280) = a2 + 272;
      *(void *)(a2 + 296) = 0;
      *(void *)(a2 + 304) = a2 + 296;
LABEL_73:

      goto LABEL_137;
    }
    os_log_type_t v93 = (char *)v17;
    BOOL v94 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    os_log_type_t v139 = "nw_flow_protocol_initialize";
    BOOL v95 = (const char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v136 = 0;
    if (__nwlog_fault(v95, &type, &v136))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        unint64_t v96 = __nwlog_obj();
        os_log_type_t v97 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v139 = "nw_flow_protocol_initialize";
          _os_log_impl(&dword_1830D4000, v96, v97, "%{public}s called with null endpoint_flow->initialized_protocol_callbacks", buf, 0xCu);
        }
      }
      else if (v136)
      {
        unsigned int v99 = (char *)__nw_create_backtrace_string();
        unint64_t v96 = __nwlog_obj();
        os_log_type_t v100 = type;
        BOOL v101 = os_log_type_enabled(v96, type);
        if (v99)
        {
          if (v101)
          {
            *(_DWORD *)buf = 136446466;
            os_log_type_t v139 = "nw_flow_protocol_initialize";
            __int16 v140 = 2082;
            os_log_type_t v141 = v99;
            _os_log_impl(&dword_1830D4000, v96, v100, "%{public}s called with null endpoint_flow->initialized_protocol_callbacks, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v99);
          goto LABEL_144;
        }
        if (v101)
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v139 = "nw_flow_protocol_initialize";
          _os_log_impl(&dword_1830D4000, v96, v100, "%{public}s called with null endpoint_flow->initialized_protocol_callbacks, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        unint64_t v96 = __nwlog_obj();
        os_log_type_t v115 = type;
        if (os_log_type_enabled(v96, type))
        {
          *(_DWORD *)buf = 136446210;
          os_log_type_t v139 = "nw_flow_protocol_initialize";
          _os_log_impl(&dword_1830D4000, v96, v115, "%{public}s called with null endpoint_flow->initialized_protocol_callbacks, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_144:
    __int16 v18 = (NWConcrete_nw_endpoint_mode_handler *)v93;
    if (!v95) {
      goto LABEL_72;
    }
    uint64_t v85 = (char *)v95;
    goto LABEL_71;
  }
LABEL_103:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v102 = (id)gLogObj;
  if (mode > 5) {
    int v103 = "unknown-mode";
  }
  else {
    int v103 = off_1E523FB08[mode];
  }
  *(_DWORD *)buf = 136446722;
  os_log_type_t v139 = "nw_endpoint_flow_initialize_protocol";
  __int16 v140 = 2082;
  os_log_type_t v141 = (void *)v103;
  __int16 v142 = 2082;
  os_log_type_t v143 = "flow";
  uint64_t v104 = (void *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v136 = 0;
  if (!__nwlog_fault((const char *)v104, &type, &v136))
  {
LABEL_135:
    if (!v104) {
      goto LABEL_137;
    }
LABEL_136:
    free(v104);
    goto LABEL_137;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_endpoint_t v105 = (id)gLogObj;
    os_log_type_t v106 = type;
    if (os_log_type_enabled(v105, type))
    {
      if (mode > 5) {
        os_log_type_t v107 = "unknown-mode";
      }
      else {
        os_log_type_t v107 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v139 = "nw_endpoint_flow_initialize_protocol";
      __int16 v140 = 2082;
      os_log_type_t v141 = (void *)v107;
      __int16 v142 = 2082;
      os_log_type_t v143 = "flow";
      _os_log_impl(&dword_1830D4000, v105, v106, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
LABEL_134:

    goto LABEL_135;
  }
  if (!v136)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    nw_endpoint_t v105 = (id)gLogObj;
    os_log_type_t v112 = type;
    if (os_log_type_enabled(v105, type))
    {
      if (mode > 5) {
        id v113 = "unknown-mode";
      }
      else {
        id v113 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v139 = "nw_endpoint_flow_initialize_protocol";
      __int16 v140 = 2082;
      os_log_type_t v141 = (void *)v113;
      __int16 v142 = 2082;
      os_log_type_t v143 = "flow";
      _os_log_impl(&dword_1830D4000, v105, v112, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
    }
    goto LABEL_134;
  }
  os_log_type_t v108 = (char *)__nw_create_backtrace_string();
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  nw_endpoint_t v105 = (id)gLogObj;
  os_log_type_t v109 = type;
  BOOL v110 = os_log_type_enabled(v105, type);
  if (!v108)
  {
    if (v110)
    {
      if (mode > 5) {
        os_log_type_t v114 = "unknown-mode";
      }
      else {
        os_log_type_t v114 = off_1E523FB08[mode];
      }
      *(_DWORD *)buf = 136446722;
      os_log_type_t v139 = "nw_endpoint_flow_initialize_protocol";
      __int16 v140 = 2082;
      os_log_type_t v141 = (void *)v114;
      __int16 v142 = 2082;
      os_log_type_t v143 = "flow";
      _os_log_impl(&dword_1830D4000, v105, v109, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
    }
    goto LABEL_134;
  }
  if (v110)
  {
    if (mode > 5) {
      char v111 = "unknown-mode";
    }
    else {
      char v111 = off_1E523FB08[mode];
    }
    *(_DWORD *)buf = 136446978;
    os_log_type_t v139 = "nw_endpoint_flow_initialize_protocol";
    __int16 v140 = 2082;
    os_log_type_t v141 = (void *)v111;
    __int16 v142 = 2082;
    os_log_type_t v143 = "flow";
    __int16 v144 = 2082;
    uint64_t v145 = v108;
    _os_log_impl(&dword_1830D4000, v105, v109, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
  }

  free(v108);
  if (v104) {
    goto LABEL_136;
  }
LABEL_137:
}

void sub_1831D6018(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, void *a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, void *a19, void *a20,uint64_t a21,void *a22)
{
  _Unwind_Resume(a1);
}

void nw_context_activate(void *a1)
{
  uint64_t v110 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (!v1)
  {
    char v68 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v103 = "nw_context_activate";
    os_log_type_t v69 = (char *)_os_log_send_and_compose_impl();

    LOBYTE(v99) = 16;
    os_log_type_t type = OS_LOG_TYPE_DEFAULT;
    if (__nwlog_fault(v69, &v99, &type))
    {
      if (v99 == 17)
      {
        va_list v70 = __nwlog_obj();
        os_log_type_t v71 = v99;
        if (os_log_type_enabled(v70, (os_log_type_t)v99))
        {
          *(_DWORD *)buf = 136446210;
          int v103 = "nw_context_activate";
          _os_log_impl(&dword_1830D4000, v70, v71, "%{public}s called with null context", buf, 0xCu);
        }
      }
      else if (type)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        va_list v70 = __nwlog_obj();
        os_log_type_t v84 = v99;
        BOOL v85 = os_log_type_enabled(v70, (os_log_type_t)v99);
        if (backtrace_string)
        {
          if (v85)
          {
            *(_DWORD *)buf = 136446466;
            int v103 = "nw_context_activate";
            __int16 v104 = 2082;
            __uint64_t v105 = (__uint64_t)backtrace_string;
            _os_log_impl(&dword_1830D4000, v70, v84, "%{public}s called with null context, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_161;
        }
        if (v85)
        {
          *(_DWORD *)buf = 136446210;
          int v103 = "nw_context_activate";
          _os_log_impl(&dword_1830D4000, v70, v84, "%{public}s called with null context, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        va_list v70 = __nwlog_obj();
        os_log_type_t v86 = v99;
        if (os_log_type_enabled(v70, (os_log_type_t)v99))
        {
          *(_DWORD *)buf = 136446210;
          int v103 = "nw_context_activate";
          _os_log_impl(&dword_1830D4000, v70, v86, "%{public}s called with null context, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_161:
    if (v69) {
      free(v69);
    }
    goto LABEL_132;
  }
  os_unfair_lock_lock(v1 + 20);
  __uint64_t v99 = 0;
  pthread_threadid_np(0, &v99);
  if (v2[30]._os_unfair_lock_opaque != 4) {
    goto LABEL_3;
  }
  uint64_t v72 = 0;
  atomic_compare_exchange_strong((atomic_ullong *volatile)&v2[28], (unint64_t *)&v72, v99);
  if (!v72) {
    goto LABEL_3;
  }
  char v73 = __nwlog_obj();
  *(_DWORD *)buf = 136446722;
  int v103 = "nw_context_activate";
  __int16 v104 = 2048;
  __uint64_t v105 = v99;
  __int16 v106 = 2048;
  uint64_t v107 = v72;
  __int16 v74 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v100 = 0;
  if (__nwlog_fault(v74, &type, &v100))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v75 = __nwlog_obj();
      os_log_type_t v76 = type;
      if (os_log_type_enabled(v75, type))
      {
        *(_DWORD *)buf = 136446722;
        int v103 = "nw_context_activate";
        __int16 v104 = 2048;
        __uint64_t v105 = v99;
        __int16 v106 = 2048;
        uint64_t v107 = v72;
        _os_log_impl(&dword_1830D4000, v75, v76, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu", buf, 0x20u);
      }
    }
    else if (v100)
    {
      os_log_type_t v91 = (char *)__nw_create_backtrace_string();
      os_log_type_t v75 = __nwlog_obj();
      os_log_type_t v92 = type;
      BOOL v93 = os_log_type_enabled(v75, type);
      if (v91)
      {
        if (v93)
        {
          *(_DWORD *)buf = 136446978;
          int v103 = "nw_context_activate";
          __int16 v104 = 2048;
          __uint64_t v105 = v99;
          __int16 v106 = 2048;
          uint64_t v107 = v72;
          __int16 v108 = 2082;
          os_log_type_t v109 = v91;
          _os_log_impl(&dword_1830D4000, v75, v92, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, dumping backtrace:%{public}s", buf, 0x2Au);
        }

        free(v91);
        goto LABEL_186;
      }
      if (v93)
      {
        *(_DWORD *)buf = 136446722;
        int v103 = "nw_context_activate";
        __int16 v104 = 2048;
        __uint64_t v105 = v99;
        __int16 v106 = 2048;
        uint64_t v107 = v72;
        _os_log_impl(&dword_1830D4000, v75, v92, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, no backtrace", buf, 0x20u);
      }
    }
    else
    {
      os_log_type_t v75 = __nwlog_obj();
      os_log_type_t v97 = type;
      if (os_log_type_enabled(v75, type))
      {
        *(_DWORD *)buf = 136446722;
        int v103 = "nw_context_activate";
        __int16 v104 = 2048;
        __uint64_t v105 = v99;
        __int16 v106 = 2048;
        uint64_t v107 = v72;
        _os_log_impl(&dword_1830D4000, v75, v97, "%{public}s Entering call, current TID=%llu, inline TID is already set to %llu, backtrace limit exceeded", buf, 0x20u);
      }
    }
  }
LABEL_186:
  if (v74) {
    free(v74);
  }
LABEL_3:
  char os_unfair_lock_opaque = v2[34]._os_unfair_lock_opaque;
  if ((os_unfair_lock_opaque & 0x40) != 0)
  {
LABEL_130:
    if ((os_unfair_lock_opaque & 8) == 0) {
      goto LABEL_131;
    }
    __uint64_t v77 = v99;
    __uint64_t v78 = v99;
    atomic_compare_exchange_strong((atomic_ullong *volatile)&v2[28], &v78, 0);
    if (v78 == v77) {
      goto LABEL_131;
    }
    BOOL v79 = __nwlog_obj();
    *(_DWORD *)buf = 136446722;
    int v103 = "nw_context_activate";
    __int16 v104 = 2048;
    __uint64_t v105 = v99;
    __int16 v106 = 2048;
    uint64_t v107 = v78;
    int v80 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (__nwlog_fault(v80, &type, &v100))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        os_log_type_t v81 = __nwlog_obj();
        os_log_type_t v82 = type;
        if (os_log_type_enabled(v81, type))
        {
          *(_DWORD *)buf = 136446722;
          int v103 = "nw_context_activate";
          __int16 v104 = 2048;
          __uint64_t v105 = v99;
          __int16 v106 = 2048;
          uint64_t v107 = v78;
          _os_log_impl(&dword_1830D4000, v81, v82, "%{public}s Exiting call, expected inline TID to be %llu but got %llu", buf, 0x20u);
        }
      }
      else if (v100)
      {
        BOOL v94 = (char *)__nw_create_backtrace_string();
        os_log_type_t v81 = __nwlog_obj();
        os_log_type_t v95 = type;
        BOOL v96 = os_log_type_enabled(v81, type);
        if (v94)
        {
          if (v96)
          {
            *(_DWORD *)buf = 136446978;
            int v103 = "nw_context_activate";
            __int16 v104 = 2048;
            __uint64_t v105 = v99;
            __int16 v106 = 2048;
            uint64_t v107 = v78;
            __int16 v108 = 2082;
            os_log_type_t v109 = v94;
            _os_log_impl(&dword_1830D4000, v81, v95, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v94);
          goto LABEL_191;
        }
        if (v96)
        {
          *(_DWORD *)buf = 136446722;
          int v103 = "nw_context_activate";
          __int16 v104 = 2048;
          __uint64_t v105 = v99;
          __int16 v106 = 2048;
          uint64_t v107 = v78;
          _os_log_impl(&dword_1830D4000, v81, v95, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        os_log_type_t v81 = __nwlog_obj();
        os_log_type_t v98 = type;
        if (os_log_type_enabled(v81, type))
        {
          *(_DWORD *)buf = 136446722;
          int v103 = "nw_context_activate";
          __int16 v104 = 2048;
          __uint64_t v105 = v99;
          __int16 v106 = 2048;
          uint64_t v107 = v78;
          _os_log_impl(&dword_1830D4000, v81, v98, "%{public}s Exiting call, expected inline TID to be %llu but got %llu, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
LABEL_191:
    if (v80) {
      free(v80);
    }
LABEL_131:
    os_unfair_lock_unlock(v2 + 20);
LABEL_132:

    return;
  }
  uint64_t v5 = (void **)&v2[2];
  id v4 = *(NSObject **)&v2[2]._os_unfair_lock_opaque;
  if (v4) {
    goto LABEL_12;
  }
  if ((v2[34]._os_unfair_lock_opaque & 4) != 0)
  {
    dispatch_workloop_t inactive = dispatch_workloop_create_inactive("com.apple.network.connections");
    uint64_t v7 = *v5;
    void *v5 = inactive;
  }
  else
  {
    if (v2[34]._os_unfair_lock_opaque)
    {
      switch(v2[30]._os_unfair_lock_opaque)
      {
        case 1u:
        case 2u:
        case 3u:
          dispatch_workloop_t v34 = dispatch_workloop_create_inactive(*(const char **)&v2[4]._os_unfair_lock_opaque);
          uint64_t v35 = *(void **)&v2[2]._os_unfair_lock_opaque;
          *(void *)&v2[2]._char os_unfair_lock_opaque = v34;

          dispatch_workloop_set_scheduler_priority();
          dispatch_workloop_set_cpupercent();
          id v4 = *v5;
          if (!*v5) {
            goto LABEL_53;
          }
          goto LABEL_12;
        case 4u:
          *(void *)&v2[2]._char os_unfair_lock_opaque = 0;
          char v43 = os_unfair_lock_opaque | 8;
          LOBYTE(v2[34]._os_unfair_lock_opaque) = v43;
          if ((v43 & 8) == 0) {
            goto LABEL_54;
          }
          break;
        default:
          dispatch_workloop_t v44 = dispatch_workloop_create_inactive(*(const char **)&v2[4]._os_unfair_lock_opaque);
          __int16 v45 = *(void **)&v2[2]._os_unfair_lock_opaque;
          *(void *)&v2[2]._char os_unfair_lock_opaque = v44;

          goto LABEL_11;
      }
      goto LABEL_13;
    }
    if (nw_context_copy_implicit_context::onceToken != -1) {
      dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
    }
    objc_storeStrong((id *)&v2[2], *(id *)(nw_context_copy_implicit_context::implicit_context + 8));
  }
LABEL_11:
  id v4 = *v5;
  if (*v5)
  {
LABEL_12:
    dispatch_activate(v4);
    goto LABEL_13;
  }
LABEL_53:
  if ((v2[34]._os_unfair_lock_opaque & 8) != 0) {
    goto LABEL_13;
  }
LABEL_54:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v36 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v103 = "nw_context_activate";
  uint64_t v37 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v100 = 0;
  if (__nwlog_fault(v37, &type, &v100))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v38 = __nwlog_obj();
      os_log_type_t v39 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_activate";
        _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s dispatch_workloop_create failed", buf, 0xCu);
      }
LABEL_75:

      goto LABEL_76;
    }
    if (!v100)
    {
      uint64_t v38 = __nwlog_obj();
      os_log_type_t v46 = type;
      if (os_log_type_enabled(v38, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_activate";
        _os_log_impl(&dword_1830D4000, v38, v46, "%{public}s dispatch_workloop_create failed, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_75;
    }
    uint64_t v40 = (char *)__nw_create_backtrace_string();
    uint64_t v38 = __nwlog_obj();
    os_log_type_t v41 = type;
    BOOL v42 = os_log_type_enabled(v38, type);
    if (!v40)
    {
      if (v42)
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_activate";
        _os_log_impl(&dword_1830D4000, v38, v41, "%{public}s dispatch_workloop_create failed, no backtrace", buf, 0xCu);
      }
      goto LABEL_75;
    }
    if (v42)
    {
      *(_DWORD *)buf = 136446466;
      int v103 = "nw_context_activate";
      __int16 v104 = 2082;
      __uint64_t v105 = (__uint64_t)v40;
      _os_log_impl(&dword_1830D4000, v38, v41, "%{public}s dispatch_workloop_create failed, dumping backtrace:%{public}s", buf, 0x16u);
    }

    free(v40);
  }
LABEL_76:
  if (v37) {
    free(v37);
  }
  id v4 = *v5;
  if (*v5) {
    goto LABEL_12;
  }
LABEL_13:
  char v8 = v2[34]._os_unfair_lock_opaque;
  if ((v8 & 0x24) == 0 && (v8 & 3) != 0)
  {
    BOOL v9 = -[NWConcrete_nw_context initWithIdentifier:]([NWConcrete_nw_context alloc], *(const char **)&v2[4]._os_unfair_lock_opaque);
    uint64_t v11 = (os_unfair_lock_s **)&v2[10];
    os_log_type_t v10 = *(void **)&v2[10]._os_unfair_lock_opaque;
    *(void *)&v2[10]._char os_unfair_lock_opaque = v9;

    LOBYTE((*v11)[34]._os_unfair_lock_opaque) = (*v11)[34]._os_unfair_lock_opaque & 0xFD | v2[34]._os_unfair_lock_opaque & 2;
    LOBYTE((*v11)[34]._os_unfair_lock_opaque) = (*v11)[34]._os_unfair_lock_opaque & 0xFE | v2[34]._os_unfair_lock_opaque & 1;
    (*v11)[31]._char os_unfair_lock_opaque = v2[31]._os_unfair_lock_opaque;
    LOBYTE((*v11)[34]._os_unfair_lock_opaque) = v2[34]._os_unfair_lock_opaque & 0x80 | (*v11)[34]._os_unfair_lock_opaque & 0x7F;
    objc_storeStrong((id *)(*(void *)&v2[10]._os_unfair_lock_opaque + 48), *(id *)&v2[12]._os_unfair_lock_opaque);
    objc_storeStrong((id *)(*(void *)&v2[10]._os_unfair_lock_opaque + 56), *(id *)&v2[14]._os_unfair_lock_opaque);
    (*v11)[30]._char os_unfair_lock_opaque = v2[30]._os_unfair_lock_opaque;
    (*v11)[21]._char os_unfair_lock_opaque = v2[21]._os_unfair_lock_opaque;
    (*v11)[22]._char os_unfair_lock_opaque = v2[22]._os_unfair_lock_opaque;
    (*v11)[23]._char os_unfair_lock_opaque = v2[23]._os_unfair_lock_opaque;
    LOBYTE((*v11)[34]._os_unfair_lock_opaque) |= 0x20u;
    objc_storeStrong((id *)(*(void *)&v2[10]._os_unfair_lock_opaque + 8), *(id *)&v2[2]._os_unfair_lock_opaque);
    objc_storeStrong((id *)(*(void *)&v2[10]._os_unfair_lock_opaque + 64), *(id *)&v2[16]._os_unfair_lock_opaque);
    os_log_type_t v12 = _Block_copy(*(const void **)&v2[18]._os_unfair_lock_opaque);
    BOOL v13 = *(void **)(*(void *)&v2[10]._os_unfair_lock_opaque + 72);
    *(void *)&(*v11)[18]._char os_unfair_lock_opaque = v12;

    BYTE1((*v11)[34]._os_unfair_lock_opaque) = BYTE1((*v11)[34]._os_unfair_lock_opaque) & 0xFE | BYTE1(v2[34]._os_unfair_lock_opaque) & 1;
    os_log_type_t v14 = _Block_copy(*(const void **)&v2[32]._os_unfair_lock_opaque);
    __int16 v15 = *(void **)(*(void *)&v2[10]._os_unfair_lock_opaque + 128);
    *(void *)&(*v11)[32]._char os_unfair_lock_opaque = v14;

    nw_context_activate(*(void *)&v2[10]._os_unfair_lock_opaque);
LABEL_129:
    char os_unfair_lock_opaque = LOBYTE(v2[34]._os_unfair_lock_opaque) | 0x40;
    LOBYTE(v2[34]._os_unfair_lock_opaque) = os_unfair_lock_opaque;
    goto LABEL_130;
  }
  if ((v2[34]._os_unfair_lock_opaque & 4) == 0)
  {
    int v16 = 0;
    if ((v2[34]._os_unfair_lock_opaque & 0x20) == 0 || (v8 & 3) == 0) {
      goto LABEL_86;
    }
  }
  BOOL v17 = v2;
  if (*(void *)&v17[6]._os_unfair_lock_opaque)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v18 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v103 = "nw_context_initialize_cache";
    os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v19, &type, &v100)) {
      goto LABEL_83;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      os_log_type_t v21 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_cache";
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s Cannot initialize cache twice", buf, 0xCu);
      }
    }
    else if (v100)
    {
      char v23 = __nw_create_backtrace_string();
      if (v23)
      {
        uint64_t v24 = (char *)v23;
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = (id)gLogObj;
        os_log_type_t v26 = type;
        if (os_log_type_enabled(v25, type))
        {
          *(_DWORD *)buf = 136446466;
          int v103 = "nw_context_initialize_cache";
          __int16 v104 = 2082;
          __uint64_t v105 = (__uint64_t)v24;
          _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s Cannot initialize cache twice, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v24);
        if (!v19) {
          goto LABEL_85;
        }
        goto LABEL_84;
      }
      id v20 = __nwlog_obj();
      os_log_type_t v30 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_cache";
        _os_log_impl(&dword_1830D4000, v20, v30, "%{public}s Cannot initialize cache twice, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v20 = (id)gLogObj;
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_cache";
        _os_log_impl(&dword_1830D4000, v20, v29, "%{public}s Cannot initialize cache twice, backtrace limit exceeded", buf, 0xCu);
      }
    }
    goto LABEL_82;
  }
  if ((v2[34]._os_unfair_lock_opaque & 7) != 0)
  {
    id v22 = (char *)malloc_type_calloc(1uLL, 0x48uLL, 0xEAFB8F1AuLL);
    if (!v22)
    {
      uint64_t v87 = __nwlog_obj();
      os_log_type_enabled(v87, OS_LOG_TYPE_ERROR);
      *(_DWORD *)buf = 136446722;
      int v103 = "strict_calloc";
      __int16 v104 = 2048;
      __uint64_t v105 = 1;
      __int16 v106 = 2048;
      uint64_t v107 = 72;
      uint64_t v88 = (void *)_os_log_send_and_compose_impl();

      if (__nwlog_abort((uint64_t)v88)) {
        goto LABEL_193;
      }
      free(v88);
    }
    *(_OWORD *)(v22 + 56) = 0u;
    *(_OWORD *)(v22 + 40) = 0u;
    *(_OWORD *)(v22 + 24) = 0u;
    *(_OWORD *)(v22 + 8) = 0u;
    *(void *)&v17[6]._char os_unfair_lock_opaque = v22;
    *(void *)id v22 = 0;
    *(void *)(*(void *)&v17[6]._os_unfair_lock_opaque + 8) = *(void *)&v17[6]._os_unfair_lock_opaque;
    *(void *)(*(void *)&v17[6]._os_unfair_lock_opaque + 16) = 0;
    *(void *)(*(void *)&v17[6]._os_unfair_lock_opaque + 24) = *(void *)&v17[6]._os_unfair_lock_opaque + 16;
    *(void *)(*(void *)&v17[6]._os_unfair_lock_opaque + 32) = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_context_endpoint_table_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_endpoint_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_endpoint_table_matches_key, (void (*)(void *))nw_context_endpoint_table_release);
    *(void *)(*(void *)&v17[6]._os_unfair_lock_opaque + 40) = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_context_endpoint_table_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_endpoint_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_endpoint_table_matches_key, (void (*)(void *))nw_context_endpoint_table_release);
    *(void *)(*(void *)&v17[6]._os_unfair_lock_opaque + 48) = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_context_endpoint_table_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_endpoint_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_endpoint_table_matches_key, (void (*)(void *))nw_context_endpoint_table_release);
    goto LABEL_85;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v27 = (id)gLogObj;
  *(_DWORD *)buf = 136446210;
  int v103 = "nw_context_initialize_cache";
  os_log_type_t v19 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v100 = 0;
  if (__nwlog_fault(v19, &type, &v100))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      id v20 = __nwlog_obj();
      os_log_type_t v28 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_cache";
        _os_log_impl(&dword_1830D4000, v20, v28, "%{public}s Cannot initialize cache for non-isolated context", buf, 0xCu);
      }
    }
    else if (v100)
    {
      BOOL v31 = (char *)__nw_create_backtrace_string();
      id v20 = __nwlog_obj();
      os_log_type_t v32 = type;
      BOOL v33 = os_log_type_enabled(v20, type);
      if (v31)
      {
        if (v33)
        {
          *(_DWORD *)buf = 136446466;
          int v103 = "nw_context_initialize_cache";
          __int16 v104 = 2082;
          __uint64_t v105 = (__uint64_t)v31;
          _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s Cannot initialize cache for non-isolated context, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v31);
        if (!v19) {
          goto LABEL_85;
        }
        goto LABEL_84;
      }
      if (v33)
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_cache";
        _os_log_impl(&dword_1830D4000, v20, v32, "%{public}s Cannot initialize cache for non-isolated context, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      id v20 = __nwlog_obj();
      os_log_type_t v47 = type;
      if (os_log_type_enabled(v20, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_cache";
        _os_log_impl(&dword_1830D4000, v20, v47, "%{public}s Cannot initialize cache for non-isolated context, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_82:
  }
LABEL_83:
  if (v19) {
LABEL_84:
  }
    free(v19);
LABEL_85:

  char v8 = v2[34]._os_unfair_lock_opaque;
  int v16 = v8 & 4;
LABEL_86:
  if (!v16 && (v8 & 0x21) != 0x21) {
    goto LABEL_129;
  }
  nw_endpoint_t v48 = v2;
  if (*(void *)&v48[8]._os_unfair_lock_opaque)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v49 = (id)gLogObj;
    *(_DWORD *)buf = 136446210;
    int v103 = "nw_context_initialize_globals";
    char v50 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v50, &type, &v100)) {
      goto LABEL_126;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      BOOL v51 = (id)gLogObj;
      os_log_type_t v52 = type;
      if (os_log_type_enabled(v51, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_globals";
        _os_log_impl(&dword_1830D4000, v51, v52, "%{public}s Cannot initialize globals twice", buf, 0xCu);
      }
LABEL_125:

LABEL_126:
      if (!v50)
      {
LABEL_128:

        goto LABEL_129;
      }
LABEL_127:
      free(v50);
      goto LABEL_128;
    }
    if (!v100)
    {
      BOOL v51 = __nwlog_obj();
      os_log_type_t v64 = type;
      if (os_log_type_enabled(v51, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_globals";
        _os_log_impl(&dword_1830D4000, v51, v64, "%{public}s Cannot initialize globals twice, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_125;
    }
    uint64_t v59 = (char *)__nw_create_backtrace_string();
    BOOL v51 = __nwlog_obj();
    os_log_type_t v60 = type;
    BOOL v61 = os_log_type_enabled(v51, type);
    if (!v59)
    {
      if (v61)
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_globals";
        _os_log_impl(&dword_1830D4000, v51, v60, "%{public}s Cannot initialize globals twice, no backtrace", buf, 0xCu);
      }
      goto LABEL_125;
    }
    if (v61)
    {
      *(_DWORD *)buf = 136446466;
      int v103 = "nw_context_initialize_globals";
      __int16 v104 = 2082;
      __uint64_t v105 = (__uint64_t)v59;
      _os_log_impl(&dword_1830D4000, v51, v60, "%{public}s Cannot initialize globals twice, dumping backtrace:%{public}s", buf, 0x16u);
    }
LABEL_102:

    free(v59);
    if (!v50) {
      goto LABEL_128;
    }
    goto LABEL_127;
  }
  if ((v2[34]._os_unfair_lock_opaque & 5) == 0)
  {
    os_log_type_t v62 = __nwlog_obj();
    *(_DWORD *)buf = 136446210;
    int v103 = "nw_context_initialize_globals";
    char v50 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v100 = 0;
    if (!__nwlog_fault(v50, &type, &v100)) {
      goto LABEL_126;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      BOOL v51 = __nwlog_obj();
      os_log_type_t v63 = type;
      if (os_log_type_enabled(v51, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_globals";
        _os_log_impl(&dword_1830D4000, v51, v63, "%{public}s Cannot initialize globals for non-isolated context", buf, 0xCu);
      }
      goto LABEL_125;
    }
    if (!v100)
    {
      BOOL v51 = __nwlog_obj();
      os_log_type_t v67 = type;
      if (os_log_type_enabled(v51, type))
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_globals";
        _os_log_impl(&dword_1830D4000, v51, v67, "%{public}s Cannot initialize globals for non-isolated context, backtrace limit exceeded", buf, 0xCu);
      }
      goto LABEL_125;
    }
    uint64_t v59 = (char *)__nw_create_backtrace_string();
    BOOL v51 = __nwlog_obj();
    os_log_type_t v65 = type;
    BOOL v66 = os_log_type_enabled(v51, type);
    if (!v59)
    {
      if (v66)
      {
        *(_DWORD *)buf = 136446210;
        int v103 = "nw_context_initialize_globals";
        _os_log_impl(&dword_1830D4000, v51, v65, "%{public}s Cannot initialize globals for non-isolated context, no backtrace", buf, 0xCu);
      }
      goto LABEL_125;
    }
    if (v66)
    {
      *(_DWORD *)buf = 136446466;
      int v103 = "nw_context_initialize_globals";
      __int16 v104 = 2082;
      __uint64_t v105 = (__uint64_t)v59;
      _os_log_impl(&dword_1830D4000, v51, v65, "%{public}s Cannot initialize globals for non-isolated context, dumping backtrace:%{public}s", buf, 0x16u);
    }
    goto LABEL_102;
  }
  BOOL v53 = malloc_type_calloc(1uLL, 0xBCuLL, 0xEAFB8F1AuLL);
  if (v53)
  {
LABEL_96:
    *(_OWORD *)((char *)v53 + 172) = 0u;
    v53[9] = 0u;
    v53[10] = 0u;
    v53[7] = 0u;
    v53[8] = 0u;
    v53[5] = 0u;
    v53[6] = 0u;
    v53[3] = 0u;
    void v53[4] = 0u;
    v53[1] = 0u;
    v53[2] = 0u;
    *BOOL v53 = 0u;
    *(void *)&v48[8]._char os_unfair_lock_opaque = v53;
    *((void *)v53 + 1) = 0;
    *(void *)(*(void *)&v48[8]._os_unfair_lock_opaque + 16) = *(void *)&v48[8]._os_unfair_lock_opaque + 8;
    *(void *)(*(void *)&v48[8]._os_unfair_lock_opaque + 52) = nw_hash_table_create_internal(0x11u, 8, (const void *(*)(const void *, unsigned int *))nw_context_object_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_object_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_object_matches_key, (void (*)(void *))nw_context_object_release);
    *(void *)(*(void *)&v48[8]._os_unfair_lock_opaque + 24) = nw_hash_table_create_internal(0x11u, 0, (const void *(*)(const void *, unsigned int *))nw_context_timer_object_get_key, (unsigned int (*)(const void *, unsigned int))nw_context_timer_object_key_hash, (BOOL (*)(const void *, const void *, unsigned int))nw_context_timer_object_matches_key, (void (*)(void *))nw_context_timer_object_release);
    if ((v2[34]._os_unfair_lock_opaque & 8) != 0)
    {
      BOOL v54 = nw_array_create();
      uint64_t v55 = *(void *)&v48[8]._os_unfair_lock_opaque;
      uint64_t v56 = *(void **)(v55 + 100);
      *(void *)(v55 + 100) = v54;

      BOOL v57 = nw_array_create();
      BOOL v58 = *(void **)(*(void *)&v48[8]._os_unfair_lock_opaque + 116);
      *(void *)(*(void *)&v48[8]._os_unfair_lock_opaque + 116) = v57;
    }
    goto LABEL_128;
  }
  os_log_type_t v89 = __nwlog_obj();
  os_log_type_enabled(v89, OS_LOG_TYPE_ERROR);
  *(_DWORD *)buf = 136446722;
  int v103 = "strict_calloc";
  __int16 v104 = 2048;
  __uint64_t v105 = 1;
  __int16 v106 = 2048;
  uint64_t v107 = 188;
  os_log_type_t v90 = (void *)_os_log_send_and_compose_impl();

  if (!__nwlog_abort((uint64_t)v90))
  {
    free(v90);
    goto LABEL_96;
  }
LABEL_193:
  __break(1u);
}

void sub_1831D7AB0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_hash_table_create_internal(unsigned int a1, int a2, const void *(*a3)(const void *, unsigned int *), unsigned int (*a4)(const void *, unsigned int), BOOL (*a5)(const void *, const void *, unsigned int), void (*a6)(void *))
{
  os_log_type_t v12 = (char *)malloc_type_calloc(1uLL, 16 * a1 + 56, 0xEAFB8F1AuLL);
  if (v12)
  {
LABEL_2:
    *((_DWORD *)v12 + 8) = a1;
    *((_DWORD *)v12 + 9) = a2;
    *(void *)os_log_type_t v12 = a3;
    *((void *)v12 + 1) = a4;
    *((void *)v12 + 2) = a5;
    *((void *)v12 + 3) = a6;
    *((void *)v12 + 6) = *((_DWORD *)v12 + 12) | 3u;
    if (a1 >= 4)
    {
      os_log_type_t v14 = (double *)(v12 + 56);
      uint64_t v13 = a1 & 0xFFFFFFFC;
      long long v15 = 0uLL;
      uint64_t v16 = v13;
      do
      {
        BOOL v17 = v14;
        id v18 = v14 + 2;
        *(void *)&float64_t v19 = v14 + 6;
        id v20 = v14 + 8;
        vst2q_f64(v14, *(float64x2x2_t *)&v15);
        os_log_type_t v21 = v14 + 4;
        *(void *)&v27.val[1].f64[0] = v21;
        v27.val[1].f64[1] = v19;
        v27.val[0] = 0uLL;
        vst2q_f64(v21, v27);
        os_log_type_t v14 = v20;
        v16 -= 4;
      }
      while (v16);
      if (v13 == a1) {
        return (BOOL)v12;
      }
    }
    else
    {
      uint64_t v13 = 0;
    }
    uint64_t v22 = a1 - v13;
    char v23 = &v12[16 * v13 + 56];
    do
    {
      *(void *)char v23 = 0;
      *((void *)v23 + 1) = v23;
      v23 += 16;
      --v22;
    }
    while (v22);
    return (BOOL)v12;
  }
  uint64_t v25 = __nwlog_obj();
  os_log_type_enabled(v25, OS_LOG_TYPE_ERROR);
  os_log_type_t v26 = (void *)_os_log_send_and_compose_impl();
  BOOL result = __nwlog_abort((uint64_t)v26);
  if (!result)
  {
    free(v26);
    goto LABEL_2;
  }
  __break(1u);
  return result;
}

uint64_t send_data_callback(uint64_t a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t *a5, uint64_t a6)
{
  uint64_t v144 = *MEMORY[0x1E4F143B8];
  if (!a6)
  {
    __nwlog_obj();
    unsigned int buf = 136446210;
    os_log_type_t v139 = "send_data_callback";
    char v68 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v132) = 16;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v68, &v132, &v128)) {
      goto LABEL_182;
    }
    if (v132 == 17)
    {
      os_log_type_t v69 = __nwlog_obj();
      os_log_type_t v70 = v132;
      if (!os_log_type_enabled(v69, (os_log_type_t)v132)) {
        goto LABEL_182;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      os_log_type_t v71 = "%{public}s nghttp2 user data is NULL, not http2_transport";
    }
    else if ((_BYTE)v128)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v69 = __nwlog_obj();
      os_log_type_t v70 = v132;
      BOOL v79 = os_log_type_enabled(v69, (os_log_type_t)v132);
      if (backtrace_string)
      {
        if (v79)
        {
          unsigned int buf = 136446466;
          os_log_type_t v139 = "send_data_callback";
          __int16 v140 = 2082;
          uint64_t v141 = (uint64_t)backtrace_string;
          int v80 = "%{public}s nghttp2 user data is NULL, not http2_transport, dumping backtrace:%{public}s";
          os_log_type_t v81 = v69;
          os_log_type_t v82 = v70;
          uint32_t v83 = 22;
LABEL_144:
          _os_log_impl(&dword_1830D4000, v81, v82, v80, (uint8_t *)&buf, v83);
        }
LABEL_145:
        free(backtrace_string);
        goto LABEL_182;
      }
      if (!v79) {
        goto LABEL_182;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      os_log_type_t v71 = "%{public}s nghttp2 user data is NULL, not http2_transport, no backtrace";
    }
    else
    {
      os_log_type_t v69 = __nwlog_obj();
      os_log_type_t v70 = v132;
      if (!os_log_type_enabled(v69, (os_log_type_t)v132)) {
        goto LABEL_182;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      os_log_type_t v71 = "%{public}s nghttp2 user data is NULL, not http2_transport, backtrace limit exceeded";
    }
    uint64_t v88 = v69;
    os_log_type_t v89 = v70;
    uint32_t v90 = 12;
LABEL_181:
    _os_log_impl(&dword_1830D4000, v88, v89, v71, (uint8_t *)&buf, v90);
    goto LABEL_182;
  }
  if (gLogDatapath)
  {
    uint64_t v72 = __nwlog_obj();
    if (os_log_type_enabled(v72, OS_LOG_TYPE_DEBUG))
    {
      unsigned int buf = 136446466;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = a6 + 205;
      _os_log_impl(&dword_1830D4000, v72, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", (uint8_t *)&buf, 0x16u);
    }
  }
  if (!a3)
  {
    __nwlog_obj();
    unsigned int buf = 136446210;
    os_log_type_t v139 = "send_data_callback";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v132) = 16;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v16, &v132, &v128)) {
      goto LABEL_75;
    }
    if (v132 == 17)
    {
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      if (!os_log_type_enabled(v73, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null framehd";
      goto LABEL_163;
    }
    if ((_BYTE)v128)
    {
      uint64_t v37 = (char *)__nw_create_backtrace_string();
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      BOOL v84 = os_log_type_enabled(v73, (os_log_type_t)v132);
      if (v37)
      {
        if (!v84) {
          goto LABEL_46;
        }
        unsigned int buf = 136446466;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = (uint64_t)v37;
        os_log_type_t v39 = "%{public}s called with null framehd, dumping backtrace:%{public}s";
        goto LABEL_139;
      }
      if (!v84) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null framehd, no backtrace";
    }
    else
    {
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      if (!os_log_type_enabled(v73, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null framehd, backtrace limit exceeded";
    }
    goto LABEL_163;
  }
  if (!a2)
  {
    __nwlog_obj();
    unsigned int buf = 136446210;
    os_log_type_t v139 = "send_data_callback";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v132) = 16;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v16, &v132, &v128)) {
      goto LABEL_75;
    }
    if (v132 == 17)
    {
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      if (!os_log_type_enabled(v73, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null frame";
      goto LABEL_163;
    }
    if ((_BYTE)v128)
    {
      uint64_t v37 = (char *)__nw_create_backtrace_string();
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      BOOL v85 = os_log_type_enabled(v73, (os_log_type_t)v132);
      if (v37)
      {
        if (!v85) {
          goto LABEL_46;
        }
        unsigned int buf = 136446466;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = (uint64_t)v37;
        os_log_type_t v39 = "%{public}s called with null frame, dumping backtrace:%{public}s";
        goto LABEL_139;
      }
      if (!v85) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null frame, no backtrace";
    }
    else
    {
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      if (!os_log_type_enabled(v73, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null frame, backtrace limit exceeded";
    }
LABEL_163:
    BOOL v57 = v73;
    os_log_type_t v58 = v74;
    uint32_t v59 = 12;
    goto LABEL_74;
  }
  if (!a5)
  {
    __nwlog_obj();
    unsigned int buf = 136446210;
    os_log_type_t v139 = "send_data_callback";
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v132) = 16;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v16, &v132, &v128)) {
      goto LABEL_75;
    }
    if (v132 == 17)
    {
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      if (!os_log_type_enabled(v73, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null source";
      goto LABEL_163;
    }
    if ((_BYTE)v128)
    {
      uint64_t v37 = (char *)__nw_create_backtrace_string();
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      BOOL v86 = os_log_type_enabled(v73, (os_log_type_t)v132);
      if (v37)
      {
        if (!v86) {
          goto LABEL_46;
        }
        unsigned int buf = 136446466;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = (uint64_t)v37;
        os_log_type_t v39 = "%{public}s called with null source, dumping backtrace:%{public}s";
LABEL_139:
        uint64_t v40 = v73;
        os_log_type_t v41 = v74;
        uint32_t v42 = 22;
        goto LABEL_45;
      }
      if (!v86) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null source, no backtrace";
    }
    else
    {
      char v73 = __nwlog_obj();
      os_log_type_t v74 = v132;
      if (!os_log_type_enabled(v73, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446210;
      os_log_type_t v139 = "send_data_callback";
      float64_t v19 = "%{public}s called with null source, backtrace limit exceeded";
    }
    goto LABEL_163;
  }
  if (!a4)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = a6 + 205;
    int v21 = *(_DWORD *)(a2 + 8);
    unsigned int buf = 136446722;
    os_log_type_t v139 = "send_data_callback";
    __int16 v140 = 2082;
    uint64_t v141 = a6 + 205;
    __int16 v142 = 1024;
    *(_DWORD *)os_log_type_t v143 = v21;
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v132) = 16;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v16, &v132, &v128)) {
      goto LABEL_75;
    }
    if (v132 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = gLogObj;
      os_log_type_t v23 = v132;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      int v24 = *(_DWORD *)(a2 + 8);
      unsigned int buf = 136446722;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v20;
      __int16 v142 = 1024;
      *(_DWORD *)os_log_type_t v143 = v24;
      float64_t v19 = "%{public}s %{public}s asked to send 0 bytes on stream %d";
      goto LABEL_70;
    }
    if (!(_BYTE)v128)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v22 = gLogObj;
      os_log_type_t v23 = v132;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      int v44 = *(_DWORD *)(a2 + 8);
      unsigned int buf = 136446722;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v20;
      __int16 v142 = 1024;
      *(_DWORD *)os_log_type_t v143 = v44;
      float64_t v19 = "%{public}s %{public}s asked to send 0 bytes on stream %d, backtrace limit exceeded";
      goto LABEL_70;
    }
    dispatch_workloop_t v34 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v22 = gLogObj;
    os_log_type_t v23 = v132;
    BOOL v35 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v132);
    if (v34)
    {
      if (v35)
      {
        int v36 = *(_DWORD *)(a2 + 8);
        unsigned int buf = 136446978;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = v20;
        __int16 v142 = 1024;
        *(_DWORD *)os_log_type_t v143 = v36;
        *(_WORD *)&v143[4] = 2082;
        *(void *)&v143[6] = v34;
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s %{public}s asked to send 0 bytes on stream %d, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x26u);
      }
      free(v34);
      goto LABEL_75;
    }
    if (v35)
    {
      int v56 = *(_DWORD *)(a2 + 8);
      unsigned int buf = 136446722;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v20;
      __int16 v142 = 1024;
      *(_DWORD *)os_log_type_t v143 = v56;
      float64_t v19 = "%{public}s %{public}s asked to send 0 bytes on stream %d, no backtrace";
LABEL_70:
      BOOL v57 = v22;
      os_log_type_t v58 = v23;
      uint32_t v59 = 28;
LABEL_74:
      _os_log_impl(&dword_1830D4000, v57, v58, v19, (uint8_t *)&buf, v59);
    }
LABEL_75:
    if (v16) {
      free(v16);
    }
    return 4294966775;
  }
  unint64_t v11 = *(void *)(a2 + 16);
  if (v11) {
    int v12 = 10;
  }
  else {
    int v12 = 9;
  }
  if (v11 <= 1) {
    int v13 = 0;
  }
  else {
    int v13 = v11 - 1;
  }
  unint64_t v14 = (v13 + v12);
  if (0xFFFFFFFFLL - a4 < v14)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v15 = a6 + 205;
    unsigned int buf = 136446466;
    os_log_type_t v139 = "send_data_callback";
    __int16 v140 = 2082;
    uint64_t v141 = a6 + 205;
    uint64_t v16 = (char *)_os_log_send_and_compose_impl();
    LOBYTE(v132) = 16;
    LOBYTE(v128) = 0;
    if (!__nwlog_fault(v16, &v132, &v128)) {
      goto LABEL_75;
    }
    if (v132 == 17)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = gLogObj;
      os_log_type_t v18 = v132;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446466;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v15;
      float64_t v19 = "%{public}s %{public}s bytes_to_send overflow";
LABEL_73:
      BOOL v57 = v17;
      os_log_type_t v58 = v18;
      uint32_t v59 = 22;
      goto LABEL_74;
    }
    if (!(_BYTE)v128)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v17 = gLogObj;
      os_log_type_t v18 = v132;
      if (!os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v132)) {
        goto LABEL_75;
      }
      unsigned int buf = 136446466;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v15;
      float64_t v19 = "%{public}s %{public}s bytes_to_send overflow, backtrace limit exceeded";
      goto LABEL_73;
    }
    uint64_t v37 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v17 = gLogObj;
    os_log_type_t v18 = v132;
    BOOL v38 = os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)v132);
    if (!v37)
    {
      if (!v38) {
        goto LABEL_75;
      }
      unsigned int buf = 136446466;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v15;
      float64_t v19 = "%{public}s %{public}s bytes_to_send overflow, no backtrace";
      goto LABEL_73;
    }
    if (!v38)
    {
LABEL_46:
      free(v37);
      goto LABEL_75;
    }
    unsigned int buf = 136446722;
    os_log_type_t v139 = "send_data_callback";
    __int16 v140 = 2082;
    uint64_t v141 = v15;
    __int16 v142 = 2082;
    *(void *)os_log_type_t v143 = v37;
    os_log_type_t v39 = "%{public}s %{public}s bytes_to_send overflow, dumping backtrace:%{public}s";
    uint64_t v40 = v17;
    os_log_type_t v41 = v18;
    uint32_t v42 = 32;
LABEL_45:
    _os_log_impl(&dword_1830D4000, v40, v41, v39, (uint8_t *)&buf, v42);
    goto LABEL_46;
  }
  uint64_t v25 = *a5;
  if (!*a5)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v43 = gLogObj;
    if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
    {
      unsigned int buf = 136446466;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = a6 + 205;
      _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_ERROR, "%{public}s %{public}s Received unexpected NULL frame from data source", (uint8_t *)&buf, 0x16u);
    }
    return 4294966775;
  }
  int v26 = *(_DWORD *)(v25 + 52);
  if (v26) {
    v26 -= *(_DWORD *)(v25 + 56) + *(_DWORD *)(v25 + 60);
  }
  if (v26 != a4)
  {
    if (gLogDatapath)
    {
      os_log_type_t v91 = __nwlog_obj();
      if (os_log_type_enabled(v91, OS_LOG_TYPE_DEBUG))
      {
        int v92 = *(_DWORD *)(v25 + 52);
        if (v92) {
          v92 -= *(_DWORD *)(v25 + 56) + *(_DWORD *)(v25 + 60);
        }
        unsigned int buf = 136446978;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = a6 + 205;
        __int16 v142 = 1024;
        *(_DWORD *)os_log_type_t v143 = v92;
        *(_WORD *)&v143[4] = 1024;
        *(_DWORD *)&v143[6] = a4;
        _os_log_impl(&dword_1830D4000, v91, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s source frame length %u, asked to send %u", (uint8_t *)&buf, 0x22u);
      }
    }
  }
  v137[0] = 0;
  v137[1] = (uint64_t)v137;
  v136[0] = 0;
  v136[1] = v136;
  uint64_t v27 = *(void *)(a6 + 32);
  if (v27)
  {
    uint64_t v28 = *(void *)(v27 + 24);
    if (v28)
    {
      os_log_type_t v29 = *(uint64_t (**)(void, uint64_t, void, void, uint64_t, uint64_t *))(v28 + 88);
      if (v29)
      {
        unsigned int v30 = v14 + a4;
        int v31 = v29(*(void *)(a6 + 32), a6, (v14 + a4), (v14 + a4), 0xFFFFFFFFLL, v137);
        uint64_t v32 = 4294966792;
        if (!v31 || !v137[0]) {
          return v32;
        }
        unsigned int buf = 0;
        nw_frame_array_get_frame_count(v137, 1, &buf);
        if (buf < v30)
        {
          if (gLogDatapath)
          {
            BOOL v33 = __nwlog_obj();
            if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
            {
              unsigned int buf = 136446466;
              os_log_type_t v139 = "send_data_callback";
              __int16 v140 = 2082;
              uint64_t v141 = a6 + 205;
              _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s got back fewer bytes than necessary, returing E_WOULDBLOCK", (uint8_t *)&buf, 0x16u);
            }
          }
          return v32;
        }
        uint64_t v132 = 0;
        BOOL v133 = &v132;
        int v135 = 0;
        uint64_t v134 = 0x2000000000;
        uint64_t v128 = 0;
        __int16 v129 = &v128;
        int v131 = 0;
        uint64_t v130 = 0x2000000000;
        v126[0] = 0;
        int v127 = 0;
        v126[1] = v126;
        v126[2] = 0x2000000000;
        v112[0] = MEMORY[0x1E4F143A8];
        v112[1] = 0x40000000;
        id v113 = ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke;
        os_log_type_t v114 = &unk_1E5240CF0;
        uint64_t v119 = a6;
        uint64_t v120 = a2;
        unsigned int v125 = v30;
        os_log_type_t v115 = &v132;
        os_log_type_t v116 = &v128;
        uint64_t v121 = a4;
        uint64_t v122 = v25;
        BOOL v117 = v126;
        uint64_t v118 = a3;
        uint64_t v123 = v137;
        int v124 = v136;
        uint64_t v45 = v137[0];
        do
        {
          if (!v45) {
            break;
          }
          uint64_t v46 = *(void *)(v45 + 32);
          char v47 = ((uint64_t (*)(void *))v113)(v112);
          uint64_t v45 = v46;
        }
        while ((v47 & 1) != 0);
        uint64_t v48 = *(void *)(v27 + 24);
        if (v48)
        {
          id v49 = *(void (**)(uint64_t, void *))(v48 + 96);
          if (v49)
          {
            v49(v27, v136);
            goto LABEL_59;
          }
        }
        __nwlog_obj();
        BOOL v93 = *(const char **)(v27 + 16);
        if (!v93) {
          BOOL v93 = "invalid";
        }
        unsigned int buf = 136446466;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = (uint64_t)v93;
        BOOL v94 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v110 = 0;
        if (__nwlog_fault(v94, &type, &v110))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v95 = __nwlog_obj();
            os_log_type_t v96 = type;
            if (!os_log_type_enabled(v95, type)) {
              goto LABEL_205;
            }
            os_log_type_t v97 = *(const char **)(v27 + 16);
            if (!v97) {
              os_log_type_t v97 = "invalid";
            }
            unsigned int buf = 136446466;
            os_log_type_t v139 = "send_data_callback";
            __int16 v140 = 2082;
            uint64_t v141 = (uint64_t)v97;
            os_log_type_t v98 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback";
            goto LABEL_204;
          }
          if (!v110)
          {
            os_log_type_t v95 = __nwlog_obj();
            os_log_type_t v96 = type;
            if (!os_log_type_enabled(v95, type)) {
              goto LABEL_205;
            }
            __int16 v104 = *(const char **)(v27 + 16);
            if (!v104) {
              __int16 v104 = "invalid";
            }
            unsigned int buf = 136446466;
            os_log_type_t v139 = "send_data_callback";
            __int16 v140 = 2082;
            uint64_t v141 = (uint64_t)v104;
            os_log_type_t v98 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, backtrace limit exceeded";
            goto LABEL_204;
          }
          BOOL v101 = (char *)__nw_create_backtrace_string();
          os_log_type_t v95 = __nwlog_obj();
          os_log_type_t v96 = type;
          BOOL v102 = os_log_type_enabled(v95, type);
          if (v101)
          {
            if (v102)
            {
              int v103 = *(const char **)(v27 + 16);
              if (!v103) {
                int v103 = "invalid";
              }
              unsigned int buf = 136446722;
              os_log_type_t v139 = "send_data_callback";
              __int16 v140 = 2082;
              uint64_t v141 = (uint64_t)v103;
              __int16 v142 = 2082;
              *(void *)os_log_type_t v143 = v101;
              _os_log_impl(&dword_1830D4000, v95, v96, "%{public}s protocol %{public}s has invalid finalize_output_frames callback, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
            }
            free(v101);
            goto LABEL_205;
          }
          if (v102)
          {
            uint64_t v107 = *(const char **)(v27 + 16);
            if (!v107) {
              uint64_t v107 = "invalid";
            }
            unsigned int buf = 136446466;
            os_log_type_t v139 = "send_data_callback";
            __int16 v140 = 2082;
            uint64_t v141 = (uint64_t)v107;
            os_log_type_t v98 = "%{public}s protocol %{public}s has invalid finalize_output_frames callback, no backtrace";
LABEL_204:
            _os_log_impl(&dword_1830D4000, v95, v96, v98, (uint8_t *)&buf, 0x16u);
          }
        }
LABEL_205:
        if (v94) {
          free(v94);
        }
LABEL_59:
        uint64_t v50 = v137[0];
        do
        {
          if (!v50) {
            break;
          }
          uint64_t v51 = *(void *)(v50 + 32);
          char v52 = ___ZL18send_data_callbackP15nghttp2_sessionP13nghttp2_framePKhmP19nghttp2_data_sourcePv_block_invoke_57((uint64_t)&__block_literal_global_60_37539, v50);
          uint64_t v50 = v51;
        }
        while ((v52 & 1) != 0);
        if (gLogDatapath)
        {
          __uint64_t v99 = __nwlog_obj();
          if (os_log_type_enabled(v99, OS_LOG_TYPE_DEBUG))
          {
            int v100 = *((_DWORD *)v133 + 6);
            unsigned int buf = 136446722;
            os_log_type_t v139 = "send_data_callback";
            __int16 v140 = 2082;
            uint64_t v141 = a6 + 205;
            __int16 v142 = 1024;
            *(_DWORD *)os_log_type_t v143 = v100;
            _os_log_impl(&dword_1830D4000, v99, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote %u bytes", (uint8_t *)&buf, 0x1Cu);
          }
        }
        if (*((_DWORD *)v133 + 6) == v30)
        {
          int v53 = *(_DWORD *)(v25 + 52);
          if (v53)
          {
            int v54 = *(_DWORD *)(v25 + 56) + *(_DWORD *)(v25 + 60);
            int v55 = v53 - v54;
            if (v53 != v54)
            {
              if (gLogDatapath)
              {
                __int16 v108 = __nwlog_obj();
                if (os_log_type_enabled(v108, OS_LOG_TYPE_DEBUG))
                {
                  int v109 = *((_DWORD *)v129 + 6);
                  unsigned int buf = 136446978;
                  os_log_type_t v139 = "send_data_callback";
                  __int16 v140 = 2082;
                  uint64_t v141 = a6 + 205;
                  __int16 v142 = 1024;
                  *(_DWORD *)os_log_type_t v143 = v109;
                  *(_WORD *)&v143[4] = 1024;
                  *(_DWORD *)&v143[6] = v55;
                  _os_log_impl(&dword_1830D4000, v108, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s wrote partial frame, %u bytes, %u remaining", (uint8_t *)&buf, 0x22u);
                }
              }
              uint64_t v32 = 0;
              goto LABEL_100;
            }
            if (gLogDatapath) {
              goto LABEL_198;
            }
          }
          else if (gLogDatapath)
          {
LABEL_198:
            __uint64_t v105 = __nwlog_obj();
            if (os_log_type_enabled(v105, OS_LOG_TYPE_DEBUG))
            {
              int v106 = *((_DWORD *)v129 + 6);
              unsigned int buf = 136446978;
              os_log_type_t v139 = "send_data_callback";
              __int16 v140 = 2082;
              uint64_t v141 = a6 + 205;
              __int16 v142 = 2048;
              *(void *)os_log_type_t v143 = v25;
              *(_WORD *)&v143[8] = 1024;
              *(_DWORD *)&v143[10] = v106;
              _os_log_impl(&dword_1830D4000, v105, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s finished writing complete frame %p, final length %u", (uint8_t *)&buf, 0x26u);
            }
          }
          http2_transport_cache_output_frame(a6, (void *)v25);
          uint64_t v32 = 0;
          *a5 = 0;
LABEL_100:
          _Block_object_dispose(v126, 8);
          _Block_object_dispose(&v128, 8);
          _Block_object_dispose(&v132, 8);
          return v32;
        }
        __nwlog_obj();
        uint64_t v61 = a6 + 205;
        unsigned int buf = 136446466;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = a6 + 205;
        os_log_type_t v62 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v110 = 0;
        if (__nwlog_fault(v62, &type, &v110))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v63 = __nwlog_obj();
            os_log_type_t v64 = type;
            if (os_log_type_enabled(v63, type))
            {
              unsigned int buf = 136446466;
              os_log_type_t v139 = "send_data_callback";
              __int16 v140 = 2082;
              uint64_t v141 = v61;
              os_log_type_t v65 = "%{public}s %{public}s did not write complete frame";
LABEL_96:
              _os_log_impl(&dword_1830D4000, v63, v64, v65, (uint8_t *)&buf, 0x16u);
            }
          }
          else if (v110)
          {
            BOOL v66 = (char *)__nw_create_backtrace_string();
            os_log_type_t v63 = __nwlog_obj();
            os_log_type_t v64 = type;
            BOOL v67 = os_log_type_enabled(v63, type);
            if (v66)
            {
              if (v67)
              {
                unsigned int buf = 136446722;
                os_log_type_t v139 = "send_data_callback";
                __int16 v140 = 2082;
                uint64_t v141 = v61;
                __int16 v142 = 2082;
                *(void *)os_log_type_t v143 = v66;
                _os_log_impl(&dword_1830D4000, v63, v64, "%{public}s %{public}s did not write complete frame, dumping backtrace:%{public}s", (uint8_t *)&buf, 0x20u);
              }
              free(v66);
              goto LABEL_97;
            }
            if (v67)
            {
              unsigned int buf = 136446466;
              os_log_type_t v139 = "send_data_callback";
              __int16 v140 = 2082;
              uint64_t v141 = v61;
              os_log_type_t v65 = "%{public}s %{public}s did not write complete frame, no backtrace";
              goto LABEL_96;
            }
          }
          else
          {
            os_log_type_t v63 = __nwlog_obj();
            os_log_type_t v64 = type;
            if (os_log_type_enabled(v63, type))
            {
              unsigned int buf = 136446466;
              os_log_type_t v139 = "send_data_callback";
              __int16 v140 = 2082;
              uint64_t v141 = v61;
              os_log_type_t v65 = "%{public}s %{public}s did not write complete frame, backtrace limit exceeded";
              goto LABEL_96;
            }
          }
        }
LABEL_97:
        if (v62) {
          free(v62);
        }
        uint64_t v32 = 4294966394;
        goto LABEL_100;
      }
    }
  }
  __nwlog_obj();
  uint64_t v75 = a6 + 205;
  unsigned int buf = 136446466;
  os_log_type_t v139 = "send_data_callback";
  __int16 v140 = 2082;
  uint64_t v141 = a6 + 205;
  char v68 = (char *)_os_log_send_and_compose_impl();
  LOBYTE(v132) = 16;
  LOBYTE(v128) = 0;
  if (!__nwlog_fault(v68, &v132, &v128)) {
    goto LABEL_182;
  }
  if (v132 == 17)
  {
    os_log_type_t v76 = __nwlog_obj();
    os_log_type_t v77 = v132;
    if (os_log_type_enabled(v76, (os_log_type_t)v132))
    {
      unsigned int buf = 136446466;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v75;
      os_log_type_t v71 = "%{public}s %{public}s output handler has no get_output_frames callback";
LABEL_180:
      uint64_t v88 = v76;
      os_log_type_t v89 = v77;
      uint32_t v90 = 22;
      goto LABEL_181;
    }
    goto LABEL_182;
  }
  if ((_BYTE)v128)
  {
    backtrace_string = (char *)__nw_create_backtrace_string();
    os_log_type_t v76 = __nwlog_obj();
    os_log_type_t v77 = v132;
    BOOL v87 = os_log_type_enabled(v76, (os_log_type_t)v132);
    if (!backtrace_string)
    {
      if (v87)
      {
        unsigned int buf = 136446466;
        os_log_type_t v139 = "send_data_callback";
        __int16 v140 = 2082;
        uint64_t v141 = v75;
        os_log_type_t v71 = "%{public}s %{public}s output handler has no get_output_frames callback, no backtrace";
        goto LABEL_180;
      }
      goto LABEL_182;
    }
    if (v87)
    {
      unsigned int buf = 136446722;
      os_log_type_t v139 = "send_data_callback";
      __int16 v140 = 2082;
      uint64_t v141 = v75;
      __int16 v142 = 2082;
      *(void *)os_log_type_t v143 = backtrace_string;
      int v80 = "%{public}s %{public}s output handler has no get_output_frames callback, dumping backtrace:%{public}s";
      os_log_type_t v81 = v76;
      os_log_type_t v82 = v77;
      uint32_t v83 = 32;
      goto LABEL_144;
    }
    goto LABEL_145;
  }
  os_log_type_t v76 = __nwlog_obj();
  os_log_type_t v77 = v132;
  if (os_log_type_enabled(v76, (os_log_type_t)v132))
  {
    unsigned int buf = 136446466;
    os_log_type_t v139 = "send_data_callback";
    __int16 v140 = 2082;
    uint64_t v141 = v75;
    os_log_type_t v71 = "%{public}s %{public}s output handler has no get_output_frames callback, backtrace limit exceeded";
    goto LABEL_180;
  }
LABEL_182:
  if (v68) {
    free(v68);
  }
  return 4294966394;
}

uint64_t nw_socket_finalize_output_frames(nw_protocol *a1, nw_frame_array_s *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (a1->handle == &nw_protocol_ref_counted_handle)
    {
      do
      {
        tqh_first = a2->tqh_first;
        if (!a2->tqh_first) {
          break;
        }
        uint64_t v5 = *((void *)tqh_first + 4);
        id v3 = (nw_frame **)*((void *)tqh_first + 5);
        if (v5)
        {
          *(void *)(v5 + 40) = v3;
          id v3 = (nw_frame **)*((void *)tqh_first + 5);
        }
        else
        {
          a2->tqh_last = v3;
        }
        *id v3 = (nw_frame *)v5;
        *((void *)tqh_first + 4) = 0;
        *((void *)tqh_first + 5) = 0;
      }
      while ((___ZL32nw_socket_finalize_output_framesP11nw_protocolP16nw_frame_array_s_block_invoke((uint64_t)&__block_literal_global_29_66213, (uint64_t)tqh_first) & 1) != 0);
      return 1;
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v18 = "nw_socket_finalize_output_frames";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v15 = 0;
    if (!__nwlog_fault(v7, &type, &v15)) {
      goto LABEL_38;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      char v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_socket_finalize_output_frames";
        os_log_type_t v10 = "%{public}s called with null socket_handler";
        goto LABEL_37;
      }
      goto LABEL_38;
    }
    if (!v15)
    {
      char v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_socket_finalize_output_frames";
        os_log_type_t v10 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_37;
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v14 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v14)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_socket_finalize_output_frames";
        os_log_type_t v10 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_37;
      }
      goto LABEL_38;
    }
    if (v14)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v18 = "nw_socket_finalize_output_frames";
      __int16 v19 = 2082;
      uint64_t v20 = backtrace_string;
      int v13 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_27;
    }
    goto LABEL_28;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v18 = "nw_socket_finalize_output_frames";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (!__nwlog_fault(v7, &type, &v15)) {
    goto LABEL_38;
  }
  if (type != OS_LOG_TYPE_FAULT)
  {
    if (!v15)
    {
      char v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_socket_finalize_output_frames";
        os_log_type_t v10 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_37;
      }
      goto LABEL_38;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    char v8 = __nwlog_obj();
    os_log_type_t v9 = type;
    BOOL v12 = os_log_type_enabled(v8, type);
    if (!backtrace_string)
    {
      if (v12)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_socket_finalize_output_frames";
        os_log_type_t v10 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_37;
      }
      goto LABEL_38;
    }
    if (v12)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v18 = "nw_socket_finalize_output_frames";
      __int16 v19 = 2082;
      uint64_t v20 = backtrace_string;
      int v13 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_27:
      _os_log_impl(&dword_1830D4000, v8, v9, v13, buf, 0x16u);
    }
LABEL_28:
    free(backtrace_string);
    goto LABEL_38;
  }
  char v8 = __nwlog_obj();
  os_log_type_t v9 = type;
  if (os_log_type_enabled(v8, type))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v18 = "nw_socket_finalize_output_frames";
    os_log_type_t v10 = "%{public}s called with null protocol";
LABEL_37:
    _os_log_impl(&dword_1830D4000, v8, v9, v10, buf, 0xCu);
  }
LABEL_38:
  if (v7) {
    free(v7);
  }
  return 0;
}

uint64_t nw_socket_get_output_frames(nw_protocol *a1, nw_protocol *a2, unsigned int a3, unsigned int a4, unsigned int a5, nw_frame_array_s *a6)
{
  uint64_t v74 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v71 = "nw_socket_get_output_frames";
    int v56 = (char *)_os_log_send_and_compose_impl();
    v69[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v68) = 0;
    if (!__nwlog_fault(v56, v69, &v68)) {
      goto LABEL_130;
    }
    if (v69[0] == OS_LOG_TYPE_FAULT)
    {
      int v53 = __nwlog_obj();
      os_log_type_t v54 = v69[0];
      if (!os_log_type_enabled(v53, v69[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v71 = "nw_socket_get_output_frames";
      int v55 = "%{public}s called with null protocol";
    }
    else
    {
      if ((_BYTE)v68)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v53 = __nwlog_obj();
        os_log_type_t v54 = v69[0];
        BOOL v59 = os_log_type_enabled(v53, v69[0]);
        if (!backtrace_string)
        {
          if (!v59) {
            goto LABEL_130;
          }
          *(_DWORD *)unsigned int buf = 136446210;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          int v55 = "%{public}s called with null protocol, no backtrace";
          goto LABEL_129;
        }
        if (v59)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          __int16 v72 = 2082;
          *(void *)char v73 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_130;
      }
      int v53 = __nwlog_obj();
      os_log_type_t v54 = v69[0];
      if (!os_log_type_enabled(v53, v69[0])) {
        goto LABEL_130;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v71 = "nw_socket_get_output_frames";
      int v55 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_129:
    _os_log_impl(&dword_1830D4000, v53, v54, v55, buf, 0xCu);
    goto LABEL_130;
  }
  char handle = a1->handle;
  if (handle == &nw_protocol_ref_counted_handle) {
    p_output_handler = &a1[1].output_handler;
  }
  else {
    p_output_handler = 0;
  }
  if (handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    os_log_type_t v71 = "nw_socket_get_output_frames";
    int v56 = (char *)_os_log_send_and_compose_impl();
    v69[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v68) = 0;
    if (__nwlog_fault(v56, v69, &v68))
    {
      if (v69[0] == OS_LOG_TYPE_FAULT)
      {
        int v53 = __nwlog_obj();
        os_log_type_t v54 = v69[0];
        if (!os_log_type_enabled(v53, v69[0])) {
          goto LABEL_130;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v71 = "nw_socket_get_output_frames";
        int v55 = "%{public}s called with null socket_handler";
      }
      else if ((_BYTE)v68)
      {
        os_log_type_t v60 = (char *)__nw_create_backtrace_string();
        int v53 = __nwlog_obj();
        os_log_type_t v54 = v69[0];
        BOOL v61 = os_log_type_enabled(v53, v69[0]);
        if (v60)
        {
          if (v61)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            os_log_type_t v71 = "nw_socket_get_output_frames";
            __int16 v72 = 2082;
            *(void *)char v73 = v60;
            _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(v60);
          if (!v56) {
            return 0;
          }
          goto LABEL_131;
        }
        if (!v61) {
          goto LABEL_130;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v71 = "nw_socket_get_output_frames";
        int v55 = "%{public}s called with null socket_handler, no backtrace";
      }
      else
      {
        int v53 = __nwlog_obj();
        os_log_type_t v54 = v69[0];
        if (!os_log_type_enabled(v53, v69[0])) {
          goto LABEL_130;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v71 = "nw_socket_get_output_frames";
        int v55 = "%{public}s called with null socket_handler, backtrace limit exceeded";
      }
      goto LABEL_129;
    }
LABEL_130:
    if (v56) {
LABEL_131:
    }
      free(v56);
    return 0;
  }
  a6->tqh_first = 0;
  a6->tqh_last = &a6->tqh_first;
  os_log_type_t v10 = &a1[6].flow_id[13];
  int v11 = *(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16);
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x4800) != 0) {
    return 0;
  }
  if ((~v11 & 0x18000) != 0)
  {
    int identifier = (int)a1[4].identifier;
    if (identifier != 2)
    {
      if (identifier != 1 || !a5 || !a4)
      {
LABEL_42:
        if ((v11 & 0x800) == 0)
        {
          a1[6].flow_id[15] = BYTE2(v11);
          *(_WORD *)os_log_type_t v10 = v11 | 0x800;
          nw_queue_resume_source((uint64_t)p_output_handler[15]);
        }
        nw_socket_set_send_low_water_mark((uint64_t)p_output_handler, 1u);
        return 0;
      }
      uint64_t v12 = 0;
      for (unsigned int i = 0; i < a4; i += v19)
      {
        if (a4 - i >= 0x2400) {
          unsigned int v19 = 9216;
        }
        else {
          unsigned int v19 = a4 - i;
        }
        uint64_t output_frame = nw_socket_allocate_output_frame((uint64_t)p_output_handler, v19);
        if (!output_frame) {
          break;
        }
        *(void *)(output_frame + 16) = 0;
        uint64_t v21 = *(uint64_t **)a1[5].flow_id;
        *(void *)(output_frame + 24) = v21;
        *uint64_t v21 = output_frame;
        *(void *)a1[5].flow_id = output_frame + 16;
        *(void *)(output_frame + 32) = 0;
        tqh_last = a6->tqh_last;
        *(void *)(output_frame + 40) = tqh_last;
        char *tqh_last = (nw_frame *)output_frame;
        a6->tqh_last = (nw_frame **)(output_frame + 32);
        uint64_t v12 = (v12 + 1);
        if (v12 >= a5) {
          break;
        }
      }
LABEL_28:
      int v23 = *(unsigned __int16 *)v10;
      int v11 = v23 | (a1[6].flow_id[15] << 16);
      if ((v23 & 0x8000) != 0 && v12)
      {
        *(_WORD *)os_log_type_t v10 = v23;
        a1[6].flow_id[15] = (v11 | 0x10000u) >> 16;
        return v12;
      }
      if (v12) {
        return v12;
      }
      goto LABEL_42;
    }
    if (a4 <= 0x10000)
    {
      int v31 = 0x10000;
      goto LABEL_81;
    }
    socklen_t v68 = 4;
    *(_DWORD *)os_log_type_t v69 = 0;
    if (!getsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4132, v69, &v68))
    {
LABEL_58:
      socklen_t v66 = 4;
      *(_DWORD *)os_log_type_t type = 0x10000;
      if (!getsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4097, type, &v66))
      {
        int v42 = *(_DWORD *)type;
LABEL_80:
        int v31 = v42 - *(_DWORD *)v69;
LABEL_81:
        uint64_t v12 = 0;
        unsigned int v47 = 0;
        if (a3) {
          goto LABEL_84;
        }
LABEL_82:
        if (!v12)
        {
          do
          {
            if (v31 == v47) {
              break;
            }
            unsigned int v49 = a4 - v47 >= v31 - v47 ? v31 - v47 : a4 - v47;
            if (!v49 && v12) {
              break;
            }
            uint64_t v50 = nw_socket_allocate_output_frame((uint64_t)p_output_handler, v49);
            if (!v50) {
              break;
            }
            *(void *)(v50 + 16) = 0;
            uint64_t v51 = *(uint64_t **)a1[5].flow_id;
            *(void *)(v50 + 24) = v51;
            uint64_t *v51 = v50;
            *(void *)a1[5].flow_id = v50 + 16;
            *(void *)(v50 + 32) = 0;
            char v52 = a6->tqh_last;
            *(void *)(v50 + 40) = v52;
            *char v52 = (nw_frame *)v50;
            a6->tqh_last = (nw_frame **)(v50 + 32);
            uint64_t v12 = (v12 + 1);
            v47 += v49;
            if (v47 >= a3) {
              goto LABEL_82;
            }
LABEL_84:
            ;
          }
          while (!v12 || a4 > v47);
        }
        goto LABEL_28;
      }
      int v36 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v37 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        os_log_type_t v71 = "nw_socket_get_output_frames";
        __int16 v72 = 2080;
        *(void *)char v73 = (char *)a1 + 404;
        *(_WORD *)&v73[8] = 1024;
        *(_DWORD *)&v73[10] = v36;
        _os_log_impl(&dword_1830D4000, v37, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_SNDBUF failed %{darwin.errno}d", buf, 0x1Cu);
      }
      __nwlog_obj();
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v71 = "nw_socket_get_output_frames";
      __int16 v72 = 1024;
      *(_DWORD *)char v73 = v36;
      BOOL v38 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t v65 = OS_LOG_TYPE_ERROR;
      char v64 = 0;
      if (__nwlog_fault(v38, &v65, &v64))
      {
        if (v65 == OS_LOG_TYPE_FAULT)
        {
          os_log_type_t v39 = __nwlog_obj();
          os_log_type_t v40 = v65;
          if (os_log_type_enabled(v39, v65))
          {
            *(_DWORD *)unsigned int buf = 136446466;
            os_log_type_t v71 = "nw_socket_get_output_frames";
            __int16 v72 = 1024;
            *(_DWORD *)char v73 = v36;
            os_log_type_t v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d";
LABEL_75:
            uint64_t v46 = v39;
LABEL_76:
            _os_log_impl(&dword_1830D4000, v46, v40, v41, buf, 0x12u);
          }
        }
        else if (v64)
        {
          char v43 = (char *)__nw_create_backtrace_string();
          int v44 = __nwlog_obj();
          os_log_type_t v40 = v65;
          os_log_type_t loga = v44;
          BOOL v45 = os_log_type_enabled(v44, v65);
          if (v43)
          {
            if (v45)
            {
              *(_DWORD *)unsigned int buf = 136446722;
              os_log_type_t v71 = "nw_socket_get_output_frames";
              __int16 v72 = 1024;
              *(_DWORD *)char v73 = v36;
              *(_WORD *)&v73[4] = 2082;
              *(void *)&v73[6] = v43;
              _os_log_impl(&dword_1830D4000, loga, v40, "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
            }
            free(v43);
            goto LABEL_77;
          }
          if (v45)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            os_log_type_t v71 = "nw_socket_get_output_frames";
            __int16 v72 = 1024;
            *(_DWORD *)char v73 = v36;
            os_log_type_t v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, no backtrace";
            uint64_t v46 = loga;
            goto LABEL_76;
          }
        }
        else
        {
          os_log_type_t v39 = __nwlog_obj();
          os_log_type_t v40 = v65;
          if (os_log_type_enabled(v39, v65))
          {
            *(_DWORD *)unsigned int buf = 136446466;
            os_log_type_t v71 = "nw_socket_get_output_frames";
            __int16 v72 = 1024;
            *(_DWORD *)char v73 = v36;
            os_log_type_t v41 = "%{public}s getsockopt SO_SNDBUF failed %{darwin.errno}d, backtrace limit exceeded";
            goto LABEL_75;
          }
        }
      }
LABEL_77:
      if (v38) {
        free(v38);
      }
      int v42 = 0x10000;
      goto LABEL_80;
    }
    int v25 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    int v26 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      os_log_type_t v71 = "nw_socket_get_output_frames";
      __int16 v72 = 2080;
      *(void *)char v73 = (char *)a1 + 404;
      *(_WORD *)&v73[8] = 1024;
      *(_DWORD *)&v73[10] = v25;
      _os_log_impl(&dword_1830D4000, v26, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt SO_NWRITE failed %{darwin.errno}d", buf, 0x1Cu);
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446466;
    os_log_type_t v71 = "nw_socket_get_output_frames";
    __int16 v72 = 1024;
    *(_DWORD *)char v73 = v25;
    uint64_t v27 = (char *)_os_log_send_and_compose_impl();
    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v66) = 0;
    if (__nwlog_fault(v27, type, &v66))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          __int16 v72 = 1024;
          *(_DWORD *)char v73 = v25;
          unsigned int v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d";
LABEL_53:
          BOOL v35 = v28;
LABEL_54:
          _os_log_impl(&dword_1830D4000, v35, v29, v30, buf, 0x12u);
        }
      }
      else if ((_BYTE)v66)
      {
        uint64_t v32 = (char *)__nw_create_backtrace_string();
        BOOL v33 = __nwlog_obj();
        os_log_type_t v29 = type[0];
        os_log_t log = v33;
        BOOL v34 = os_log_type_enabled(v33, type[0]);
        if (v32)
        {
          if (v34)
          {
            *(_DWORD *)unsigned int buf = 136446722;
            os_log_type_t v71 = "nw_socket_get_output_frames";
            __int16 v72 = 1024;
            *(_DWORD *)char v73 = v25;
            *(_WORD *)&v73[4] = 2082;
            *(void *)&v73[6] = v32;
            _os_log_impl(&dword_1830D4000, log, v29, "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
          }
          free(v32);
          goto LABEL_55;
        }
        if (v34)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          __int16 v72 = 1024;
          *(_DWORD *)char v73 = v25;
          unsigned int v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, no backtrace";
          BOOL v35 = log;
          goto LABEL_54;
        }
      }
      else
      {
        uint64_t v28 = __nwlog_obj();
        os_log_type_t v29 = type[0];
        if (os_log_type_enabled(v28, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v71 = "nw_socket_get_output_frames";
          __int16 v72 = 1024;
          *(_DWORD *)char v73 = v25;
          unsigned int v30 = "%{public}s getsockopt SO_NWRITE failed %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_53;
        }
      }
    }
LABEL_55:
    if (v27) {
      free(v27);
    }
    *(_DWORD *)os_log_type_t v69 = 0;
    goto LABEL_58;
  }
  uint64_t v12 = 0;
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    BOOL v14 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446466;
      os_log_type_t v71 = "nw_socket_get_output_frames";
      __int16 v72 = 2082;
      *(void *)char v73 = (char *)a1 + 404;
      _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Ignoring write while waiting for TFO", buf, 0x16u);
    }
    return 0;
  }
  return v12;
}

uint64_t nw_socket_allocate_output_frame(uint64_t a1, unsigned int a2)
{
  uint64_t v37 = *MEMORY[0x1E4F143B8];
  uint64_t external = *(void *)(a1 + 200);
  if (external)
  {
    uint64_t v5 = *(void *)(external + 16);
    BOOL v6 = *(void **)(external + 24);
    if (v5)
    {
      *(void *)(v5 + 24) = v6;
      BOOL v6 = *(void **)(external + 24);
    }
    else
    {
      *(void *)(a1 + 208) = v6;
    }
    void *v6 = v5;
    *(void *)(external + 16) = 0;
    *(void *)(external + 24) = 0;
    int v8 = nw_frame_uses_external_data(external);
    if (!a2 || v8)
    {
      uint64_t v10 = external;
      BOOL v9 = 0;
    }
    else
    {
      BOOL v9 = nw_calloc_type<unsigned char>(a2);
      uint64_t v10 = external;
    }
    nw_frame_reset(v10, v9, a2, (uint64_t)nw_socket_frame_output_finalizer, a1);
    return external;
  }
  if ((*(_WORD *)(a1 + 301) & 0x1000) == 0)
  {
    if (a2)
    {
      uint64_t v7 = nw_calloc_type<unsigned char>(a2);
      uint64_t external = nw_frame_create(0, v7, a2, (uint64_t)nw_socket_frame_output_finalizer, a1);
      if (external) {
        return external;
      }
    }
    else
    {
      uint64_t external = nw_frame_create(0, 0, 0, (uint64_t)nw_socket_frame_output_finalizer, a1);
      uint64_t v7 = 0;
      if (external) {
        return external;
      }
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v34 = "nw_socket_allocate_output_frame";
    char v15 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (!__nwlog_fault(v15, &type, &v31)) {
      goto LABEL_43;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v16 = gLogObj;
      os_log_type_t v17 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v34 = "nw_socket_allocate_output_frame";
      os_log_type_t v18 = "%{public}s nw_frame_create failed";
    }
    else
    {
      if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v24 = gLogObj;
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            BOOL v34 = "nw_socket_allocate_output_frame";
            __int16 v35 = 2082;
            int v36 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s nw_frame_create failed, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_43;
        }
        if (!v26)
        {
LABEL_43:
          if (v15) {
            free(v15);
          }
          goto LABEL_45;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v34 = "nw_socket_allocate_output_frame";
        os_log_type_t v18 = "%{public}s nw_frame_create failed, no backtrace";
        os_log_type_t v29 = v24;
        os_log_type_t v30 = v25;
LABEL_42:
        _os_log_impl(&dword_1830D4000, v29, v30, v18, buf, 0xCu);
        goto LABEL_43;
      }
      uint64_t v16 = __nwlog_obj();
      os_log_type_t v17 = type;
      if (!os_log_type_enabled(v16, type)) {
        goto LABEL_43;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v34 = "nw_socket_allocate_output_frame";
      os_log_type_t v18 = "%{public}s nw_frame_create failed, backtrace limit exceeded";
    }
    os_log_type_t v29 = v16;
    os_log_type_t v30 = v17;
    goto LABEL_42;
  }
  uint64_t external = nw_frame_create_external(0, a2, (uint64_t)nw_socket_frame_output_finalizer, a1);
  if (external) {
    return external;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v34 = "nw_socket_allocate_output_frame";
  uint64_t v7 = _os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v31 = 0;
  if (!__nwlog_fault((const char *)v7, &type, &v31)) {
    goto LABEL_45;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v12 = gLogObj;
    os_log_type_t v13 = type;
    if (os_log_type_enabled((os_log_t)gLogObj, type))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v34 = "nw_socket_allocate_output_frame";
      BOOL v14 = "%{public}s nw_frame_create_external failed";
LABEL_37:
      uint64_t v27 = v12;
      os_log_type_t v28 = v13;
LABEL_38:
      _os_log_impl(&dword_1830D4000, v27, v28, v14, buf, 0xCu);
    }
  }
  else if (v31)
  {
    unsigned int v19 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v20 = gLogObj;
    os_log_type_t v21 = type;
    BOOL v22 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v19)
    {
      if (v22)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v34 = "nw_socket_allocate_output_frame";
        __int16 v35 = 2082;
        int v36 = v19;
        _os_log_impl(&dword_1830D4000, v20, v21, "%{public}s nw_frame_create_external failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v19);
      goto LABEL_45;
    }
    if (v22)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v34 = "nw_socket_allocate_output_frame";
      BOOL v14 = "%{public}s nw_frame_create_external failed, no backtrace";
      uint64_t v27 = v20;
      os_log_type_t v28 = v21;
      goto LABEL_38;
    }
  }
  else
  {
    uint64_t v12 = __nwlog_obj();
    os_log_type_t v13 = type;
    if (os_log_type_enabled(v12, type))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v34 = "nw_socket_allocate_output_frame";
      BOOL v14 = "%{public}s nw_frame_create_external failed, backtrace limit exceeded";
      goto LABEL_37;
    }
  }
LABEL_45:
  if (v7) {
    free((void *)v7);
  }
  return 0;
}

uint64_t nw_frame_create_external(int a1, int a2, uint64_t a3, uint64_t a4)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  objc_opt_class();
  uint64_t v8 = _os_object_alloc();
  uint64_t v9 = v8;
  if (v8)
  {
    int v10 = *(unsigned __int16 *)(v8 + 204) | (*(unsigned __int8 *)(v8 + 206) << 16);
    if (a1) {
      v10 |= 4u;
    }
    *(_WORD *)(v8 + 204) = v10 | 2;
    *(unsigned char *)(v8 + 206) = BYTE2(v10);
    nw_frame_reset(v8, 0, a2, a3, a4);
    return v9;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v25 = "nw_frame_create_external";
  int v11 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v22 = 0;
  if (__nwlog_fault(v11, &type, &v22))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v25 = "nw_frame_create_external";
      BOOL v14 = "%{public}s nw_frame_obj_alloc failed";
LABEL_16:
      unsigned int v19 = v12;
      os_log_type_t v20 = v13;
LABEL_17:
      _os_log_impl(&dword_1830D4000, v19, v20, v14, buf, 0xCu);
      goto LABEL_18;
    }
    if (!v22)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = gLogObj;
      os_log_type_t v13 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_18;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v25 = "nw_frame_create_external";
      BOOL v14 = "%{public}s nw_frame_obj_alloc failed, backtrace limit exceeded";
      goto LABEL_16;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v16 = gLogObj;
    os_log_type_t v17 = type;
    BOOL v18 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v18)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        os_log_type_t v25 = "nw_frame_create_external";
        __int16 v26 = 2082;
        uint64_t v27 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v16, v17, "%{public}s nw_frame_obj_alloc failed, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_18;
    }
    if (v18)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      os_log_type_t v25 = "nw_frame_create_external";
      BOOL v14 = "%{public}s nw_frame_obj_alloc failed, no backtrace";
      unsigned int v19 = v16;
      os_log_type_t v20 = v17;
      goto LABEL_17;
    }
  }
LABEL_18:
  if (v11) {
    free(v11);
  }
  return v9;
}

void http2_transport_cache_output_frame(uint64_t a1, void *a2)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  if (gLogDatapath)
  {
    int v10 = __nwlog_obj();
    if (os_log_type_enabled(v10, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v16 = "http2_transport_cache_output_frame";
      __int16 v17 = 2082;
      uint64_t v18 = a1 + 205;
      __int16 v19 = 2048;
      os_log_type_t v20 = a2;
      _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s caching output frame %p", buf, 0x20u);
    }
  }
  if (http2_transport_output_frame_context_reset((uint64_t)a2, 0, 0))
  {
    int v14 = 0;
    uint64_t buffer = nw_frame_get_buffer((uint64_t)a2, &v14);
    if (gLogDatapath)
    {
      int v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136447234;
        uint64_t v16 = "http2_transport_cache_output_frame";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 2048;
        os_log_type_t v20 = a2;
        __int16 v21 = 2048;
        uint64_t v22 = buffer;
        __int16 v23 = 1024;
        int v24 = v14;
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s resetting output frame %p to buffer %p, length %u", buf, 0x30u);
      }
    }
    nw_frame_reset((uint64_t)a2, buffer, v14, (uint64_t)nw_protocol_http2_transport_frame_output_finalizer, 0);
    int v6 = *(_DWORD *)(a1 + 196);
    uint64_t v7 = *(void *)(a1 + 176);
    a2[2] = v7;
    if (v7) {
      uint64_t v8 = (void *)(v7 + 24);
    }
    else {
      uint64_t v8 = (void *)(a1 + 184);
    }
    void *v8 = a2 + 2;
    *(void *)(a1 + 176) = a2;
    a2[3] = a1 + 176;
    *(_DWORD *)(a1 + 196) = v6 + 1;
    if (gLogDatapath)
    {
      uint64_t v12 = __nwlog_obj();
      if (os_log_type_enabled(v12, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v16 = "http2_transport_cache_output_frame";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 1024;
        LODWORD(v20) = v14;
        _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s reset output frame of length %u, eligible for reuse", buf, 0x1Cu);
      }
    }
    http2_transport_purge_frame_cache_if_necessary((nw_frame_array_s *)(a1 + 176), (int *)(a1 + 196), v5);
  }
  else
  {
    if (gLogDatapath)
    {
      os_log_type_t v13 = __nwlog_obj();
      if (os_log_type_enabled(v13, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v16 = "http2_transport_cache_output_frame";
        __int16 v17 = 2082;
        uint64_t v18 = a1 + 205;
        __int16 v19 = 2048;
        os_log_type_t v20 = a2;
        _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s ERROR: unable to clear metadata for output frame %p, freeing", buf, 0x20u);
      }
    }
    uint64_t v9 = (void *)nw_frame_get_buffer((uint64_t)a2, 0);
    if (v9) {
      free(v9);
    }
    nw_frame_reset((uint64_t)a2, 0, 0, 0, 0);
    if (a2) {
      os_release(a2);
    }
  }
}

uint64_t nw_frame_get_buffer(uint64_t a1, _DWORD *a2)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if ((*(_WORD *)(a1 + 204) & 0x100) != 0
      && g_channel_check_validity
      && (g_channel_check_validity(a1, *(void *)(a1 + 88)) & 1) == 0)
    {
      uint64_t result = 0;
      if (a2) {
        *a2 = 0;
      }
    }
    else
    {
      if (a2) {
        *a2 = *(_DWORD *)(a1 + 48);
      }
      return *(void *)(a1 + 112);
    }
    return result;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  int v14 = "__nw_frame_get_buffer";
  uint64_t v5 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v11 = 0;
  if (__nwlog_fault(v5, &type, &v11))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v14 = "__nw_frame_get_buffer";
        uint64_t v8 = "%{public}s called with null frame";
LABEL_24:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          int v14 = "__nw_frame_get_buffer";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null frame, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_25;
      }
      if (v10)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v14 = "__nw_frame_get_buffer";
        uint64_t v8 = "%{public}s called with null frame, no backtrace";
        goto LABEL_24;
      }
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v14 = "__nw_frame_get_buffer";
        uint64_t v8 = "%{public}s called with null frame, backtrace limit exceeded";
        goto LABEL_24;
      }
    }
  }
LABEL_25:
  if (v5) {
    free(v5);
  }
  return 0;
}

BOOL http2_transport_output_frame_context_reset(uint64_t a1, uint64_t a2, uint64_t a3)
{
  uint64_t v23 = *MEMORY[0x1E4F143B8];
  metadata = (void *)nw_frame_get_metadata(a1);
  int v6 = metadata;
  if (metadata)
  {
    void *metadata = a2;
    metadata[1] = a3;
    return v6 != 0;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  if (a2) {
    os_log_type_t v7 = (const char *)(a2 + 205);
  }
  else {
    os_log_type_t v7 = "";
  }
  *(_DWORD *)unsigned int buf = 136446466;
  uint64_t v18 = "http2_transport_output_frame_context_reset";
  __int16 v19 = 2082;
  os_log_type_t v20 = v7;
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v18 = "http2_transport_output_frame_context_reset";
      __int16 v19 = 2082;
      os_log_type_t v20 = v7;
      char v11 = "%{public}s %{public}s frame has no metadata";
      goto LABEL_19;
    }
    if (!v15)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_20;
      }
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v18 = "http2_transport_output_frame_context_reset";
      __int16 v19 = 2082;
      os_log_type_t v20 = v7;
      char v11 = "%{public}s %{public}s frame has no metadata, backtrace limit exceeded";
      goto LABEL_19;
    }
    backtrace_string = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v9 = gLogObj;
    os_log_type_t v10 = type;
    BOOL v13 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (backtrace_string)
    {
      if (v13)
      {
        *(_DWORD *)unsigned int buf = 136446722;
        uint64_t v18 = "http2_transport_output_frame_context_reset";
        __int16 v19 = 2082;
        os_log_type_t v20 = v7;
        __int16 v21 = 2082;
        uint64_t v22 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s %{public}s frame has no metadata, dumping backtrace:%{public}s", buf, 0x20u);
      }
      free(backtrace_string);
      goto LABEL_20;
    }
    if (v13)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v18 = "http2_transport_output_frame_context_reset";
      __int16 v19 = 2082;
      os_log_type_t v20 = v7;
      char v11 = "%{public}s %{public}s frame has no metadata, no backtrace";
LABEL_19:
      _os_log_impl(&dword_1830D4000, v9, v10, v11, buf, 0x16u);
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
  return v6 != 0;
}

uint64_t ___ZL22nw_flow_input_finishedP11nw_protocolS0__block_invoke(uint64_t a1)
{
  return (*(uint64_t (**)(void))(*(void *)(a1 + 32) + 16))();
}

void ___ZL17nw_channel_createP10nw_contextPhjPvjbbPb_block_invoke_3(uint64_t a1)
{
  if (*(unsigned char *)(a1 + 40) && *(void *)(*(void *)(a1 + 32) + 136)) {
    os_channel_sync();
  }
  uint64_t v2 = *(void *)(a1 + 32);
  int v3 = *(unsigned __int16 *)(v2 + 444);
  int v4 = v3 | (*(unsigned __int8 *)(v2 + 446) << 16);
  if ((v3 & 2) == 0 && *(void *)(v2 + 176))
  {
    uint64_t v5 = (_WORD *)(v2 + 444);
    *(unsigned char *)(v2 + 446) = BYTE2(v4);
    *(_WORD *)(v2 + 444) = v4 | 2;
    unsigned int v6 = os_channel_available_slot_count();
    if (v6 || (nw_channel_check_defunct(v2) & 1) == 0)
    {
      if (*(_DWORD *)(v2 + 420) - 1 >= v6) {
        int v7 = 0;
      }
      else {
        int v7 = *(_DWORD *)(v2 + 420);
      }
      int v8 = *(unsigned __int16 *)(v2 + 444) | (*(unsigned __int8 *)(v2 + 446) << 16);
      if (v6 == v7)
      {
        if ((*(_WORD *)(v2 + 444) & 0x10) != 0)
        {
          int v9 = *(_WORD *)(v2 + 444) & 0xFFEF | (*(unsigned __int8 *)(v2 + 446) << 16);
          _WORD *v5 = *(_WORD *)(v2 + 444) & 0xFFEF;
          *(unsigned char *)(v2 + 446) = BYTE2(v9);
          nw_queue_resume_source(*(void *)(v2 + 176));
        }
      }
      else if ((*(_WORD *)(v2 + 444) & 0x10) == 0)
      {
        *(unsigned char *)(v2 + 446) = BYTE2(v8);
        _WORD *v5 = v8 | 0x10;
        nw_queue_suspend_source(*(void *)(v2 + 176));
      }
    }
    int v10 = (unsigned __int16)*v5;
    unsigned int v11 = v10 & 0xFFFFFFFD | (*(unsigned __int8 *)(v2 + 446) << 16);
    _WORD *v5 = v10 & 0xFFFD;
    *(unsigned char *)(v2 + 446) = BYTE2(v11);
    uint64_t v2 = *(void *)(a1 + 32);
  }
  if (*(void *)(v2 + 136) && *(void *)(v2 + 216))
  {
    unsigned int v12 = os_channel_available_slot_count();
    int v13 = *(_DWORD *)(v2 + 420);
    if (v13 - 1 >= v12) {
      int v13 = 0;
    }
    if (v12 != v13)
    {
      int v14 = *(char **)(v2 + 280);
      if (v14)
      {
        v15[0] = MEMORY[0x1E4F143A8];
        v15[1] = 0x40000000;
        v15[2] = ___ZL34nw_channel_notify_output_availableP10nw_channel_block_invoke;
        v15[3] = &__block_descriptor_tmp_69_88440;
        void v15[4] = v2;
        nw_hash_table_apply(v14, (uint64_t)v15);
      }
    }
  }
}

void nw_socket_update_input_source(char *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v23 = "nw_socket_update_input_source";
    int v8 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v8, &type, &v20)) {
      goto LABEL_32;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v23 = "nw_socket_update_input_source";
      unsigned int v11 = "%{public}s called with null socket_handler";
    }
    else
    {
      if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        int v13 = gLogObj;
        os_log_type_t v14 = type;
        BOOL v15 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v15)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v23 = "nw_socket_update_input_source";
            __int16 v24 = 2082;
            uint64_t v25 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
          }
          free(backtrace_string);
          goto LABEL_32;
        }
        if (!v15)
        {
LABEL_32:
          if (v8) {
            free(v8);
          }
          return;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v23 = "nw_socket_update_input_source";
        unsigned int v11 = "%{public}s called with null socket_handler, no backtrace";
        uint64_t v16 = v13;
        os_log_type_t v17 = v14;
LABEL_31:
        _os_log_impl(&dword_1830D4000, v16, v17, v11, buf, 0xCu);
        goto LABEL_32;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v9 = gLogObj;
      os_log_type_t v10 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_32;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v23 = "nw_socket_update_input_source";
      unsigned int v11 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }
    uint64_t v16 = v9;
    os_log_type_t v17 = v10;
    goto LABEL_31;
  }
  uint64_t v2 = (unsigned __int16 *)(a1 + 301);
  if ((*(_WORD *)(a1 + 301) & 0x80) == 0 && gLogDatapath)
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v18 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
    {
      int v19 = *((_DWORD *)a1 + 43);
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v23 = "nw_socket_update_input_source";
      __int16 v24 = 2082;
      uint64_t v25 = a1 + 308;
      __int16 v26 = 1024;
      int v27 = v19;
      _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Input available for %d", buf, 0x1Cu);
    }
  }
  int v3 = *v2;
  int v4 = v3 | (*((unsigned __int8 *)v2 + 2) << 16);
  if ((v3 & 0x4000) != 0) {
    return;
  }
  *((unsigned char *)v2 + 2) = BYTE2(v4);
  unsigned __int16 *v2 = v4 | 0x200;
  if (_nw_signposts_once != -1) {
    dispatch_once(&_nw_signposts_once, &__block_literal_global_22_65191);
  }
  if (_nw_signposts_enabled && kdebug_is_enabled())
  {
    kdebug_trace();
    uint64_t v5 = *((void *)a1 + 6);
    if (!v5) {
      goto LABEL_13;
    }
  }
  else
  {
    uint64_t v5 = *((void *)a1 + 6);
    if (!v5) {
      goto LABEL_13;
    }
  }
  uint64_t v6 = *(void *)(v5 + 24);
  if (v6)
  {
    int v7 = *(void (**)(void))(v6 + 64);
    if (v7) {
      v7();
    }
  }
LABEL_13:
  if ((*v2 & 0x600) == 0x200)
  {
    if (_nw_signposts_once == -1)
    {
      if (_nw_signposts_enabled) {
        goto LABEL_16;
      }
    }
    else
    {
      dispatch_once(&_nw_signposts_once, &__block_literal_global_22_65191);
      if (_nw_signposts_enabled)
      {
LABEL_16:
        if (kdebug_is_enabled()) {
          kdebug_trace();
        }
      }
    }
    nw_queue_suspend_source(*((void *)a1 + 14));
    *v2 |= 0x400u;
  }
}

void nw_queue_suspend_source(uint64_t a1)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    int v4 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v15 = "nw_queue_suspend_source";
    uint64_t v5 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v5, &type, &v12)) {
      goto LABEL_33;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_queue_suspend_source";
        int v8 = "%{public}s called with null source";
LABEL_31:
        _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v6 = __nwlog_obj();
        os_log_type_t v7 = type;
        BOOL v10 = os_log_type_enabled(v6, type);
        if (backtrace_string)
        {
          if (v10)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            BOOL v15 = "nw_queue_suspend_source";
            __int16 v16 = 2082;
            os_log_type_t v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null source, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_33;
        }
        if (!v10) {
          goto LABEL_32;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_queue_suspend_source";
        int v8 = "%{public}s called with null source, no backtrace";
        goto LABEL_31;
      }
      uint64_t v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (os_log_type_enabled(v6, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_queue_suspend_source";
        int v8 = "%{public}s called with null source, backtrace limit exceeded";
        goto LABEL_31;
      }
    }
LABEL_32:

LABEL_33:
    if (v5) {
      free(v5);
    }
    return;
  }
  uint64_t v2 = *(NSObject **)a1;
  if (v2)
  {
    dispatch_suspend(v2);
    return;
  }
  int v3 = *(void **)(a1 + 16);
  if (*(unsigned char *)(a1 + 48))
  {
    if (v3)
    {
      if (*(unsigned char *)(a1 + 49))
      {
        nw_context_reset_timer_block_with_time(*(void **)(a1 + 8), a1, -1, v3);
        *(unsigned char *)(a1 + 49) = 0;
      }
      return;
    }
    goto LABEL_13;
  }
  if (!v3)
  {
LABEL_13:
    if (gLogDatapath)
    {
      unsigned int v11 = __nwlog_obj();
      if (os_log_type_enabled(v11, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_queue_suspend_source";
        _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_DEBUG, "%{public}s Cancelled, not suspending source", buf, 0xCu);
      }
    }
    return;
  }
  if (*(unsigned char *)(a1 + 49))
  {
    nw_context_dequeue_source_block(*(void **)(a1 + 8), *(void **)(a1 + 16));
    *(unsigned char *)(a1 + 49) = 0;
  }
}

void nw_flow_passthrough_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    default_input_handler = a1->default_input_handler;
    if (default_input_handler)
    {
      callbacks = default_input_handler->callbacks;
      if (callbacks)
      {
        input_available = (void (*)(void))callbacks->input_available;
        if (input_available)
        {
          input_available();
        }
      }
    }
    return;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v15 = "nw_flow_passthrough_input_available";
  uint64_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (__nwlog_fault(v6, &type, &v12))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_flow_passthrough_input_available";
        uint64_t v9 = "%{public}s called with null protocol";
LABEL_21:
        _os_log_impl(&dword_1830D4000, v7, v8, v9, buf, 0xCu);
      }
    }
    else
    {
      if (v12)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        os_log_type_t v7 = __nwlog_obj();
        os_log_type_t v8 = type;
        BOOL v11 = os_log_type_enabled(v7, type);
        if (backtrace_string)
        {
          if (v11)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            BOOL v15 = "nw_flow_passthrough_input_available";
            __int16 v16 = 2082;
            os_log_type_t v17 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_23;
        }
        if (!v11) {
          goto LABEL_22;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_flow_passthrough_input_available";
        uint64_t v9 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_21;
      }
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        BOOL v15 = "nw_flow_passthrough_input_available";
        uint64_t v9 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_21;
      }
    }
LABEL_22:
  }
LABEL_23:
  if (v6) {
    free(v6);
  }
}

void nw_protocol_http2_transport_input_available(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v18 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v15 = "nw_protocol_http2_transport_input_available";
    int v3 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v12 = 0;
    if (!__nwlog_fault(v3, &type, &v12)) {
      goto LABEL_37;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v15 = "nw_protocol_http2_transport_input_available";
      uint64_t v6 = "%{public}s called with null protocol";
    }
    else if (v12)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      BOOL v9 = os_log_type_enabled(v4, type);
      if (backtrace_string)
      {
        if (v9)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          BOOL v15 = "nw_protocol_http2_transport_input_available";
          __int16 v16 = 2082;
          os_log_type_t v17 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
LABEL_37:
        if (!v3) {
          return;
        }
LABEL_38:
        free(v3);
        return;
      }
      if (!v9) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v15 = "nw_protocol_http2_transport_input_available";
      uint64_t v6 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v4 = __nwlog_obj();
      os_log_type_t v5 = type;
      if (!os_log_type_enabled(v4, type)) {
        goto LABEL_37;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      BOOL v15 = "nw_protocol_http2_transport_input_available";
      uint64_t v6 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
LABEL_36:
    _os_log_impl(&dword_1830D4000, v4, v5, v6, buf, 0xCu);
    goto LABEL_37;
  }
  char handle = a1->handle;
  if (handle)
  {
    if (gLogDatapath)
    {
      os_log_type_t v7 = __nwlog_obj();
      if (os_log_type_enabled(v7, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        BOOL v15 = "nw_protocol_http2_transport_input_available";
        __int16 v16 = 2082;
        os_log_type_t v17 = handle + 205;
        _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", buf, 0x16u);
      }
    }
    if ((handle[204] & 0x40) == 0) {
      nw_protocol_http2_transport_process_input((uint64_t)handle);
    }
    return;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  BOOL v15 = "nw_protocol_http2_transport_input_available";
  int v3 = (char *)_os_log_send_and_compose_impl();
  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v12 = 0;
  if (!__nwlog_fault(v3, &type, &v12)) {
    goto LABEL_37;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_37;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v15 = "nw_protocol_http2_transport_input_available";
    uint64_t v6 = "%{public}s called with null http2_transport";
    goto LABEL_36;
  }
  if (!v12)
  {
    int v4 = __nwlog_obj();
    os_log_type_t v5 = type;
    if (!os_log_type_enabled(v4, type)) {
      goto LABEL_37;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v15 = "nw_protocol_http2_transport_input_available";
    uint64_t v6 = "%{public}s called with null http2_transport, backtrace limit exceeded";
    goto LABEL_36;
  }
  BOOL v10 = (char *)__nw_create_backtrace_string();
  int v4 = __nwlog_obj();
  os_log_type_t v5 = type;
  BOOL v11 = os_log_type_enabled(v4, type);
  if (!v10)
  {
    if (!v11) {
      goto LABEL_37;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    BOOL v15 = "nw_protocol_http2_transport_input_available";
    uint64_t v6 = "%{public}s called with null http2_transport, no backtrace";
    goto LABEL_36;
  }
  if (v11)
  {
    *(_DWORD *)unsigned int buf = 136446466;
    BOOL v15 = "nw_protocol_http2_transport_input_available";
    __int16 v16 = 2082;
    os_log_type_t v17 = v10;
    _os_log_impl(&dword_1830D4000, v4, v5, "%{public}s called with null http2_transport, dumping backtrace:%{public}s", buf, 0x16u);
  }
  free(v10);
  if (v3) {
    goto LABEL_38;
  }
}

void nw_protocol_http2_transport_process_input(uint64_t a1)
{
  uint64_t v62 = *MEMORY[0x1E4F143B8];
  p_cache = NWConcrete_nw_resolution_report.cache;
  if (gLogDatapath)
  {
    char v43 = __nwlog_obj();
    if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)os_log_type_t v60 = 136446466;
      *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(void *)&v60[14] = a1 + 205;
      _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s called", v60, 0x16u);
    }
  }
  while (1)
  {
    v53[0] = 0;
    v53[1] = v53;
    uint64_t v3 = *(void *)(a1 + 32);
    if (!v3) {
      break;
    }
    uint64_t v4 = *(void *)(v3 + 24);
    if (!v4) {
      break;
    }
    os_log_type_t v5 = *(uint64_t (**)(uint64_t, uint64_t))(v4 + 80);
    if (!v5) {
      break;
    }
    int v6 = v5(v3, a1);
    if (!v6) {
      goto LABEL_56;
    }
    int v7 = v6;
    if (*((unsigned char *)p_cache + 3665))
    {
      BOOL v33 = __nwlog_obj();
      if (os_log_type_enabled(v33, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)os_log_type_t v60 = 136446722;
        *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
        *(_WORD *)&v60[12] = 2082;
        *(void *)&v60[14] = a1 + 205;
        *(_WORD *)&v60[22] = 1024;
        LODWORD(v61) = v7;
        _os_log_impl(&dword_1830D4000, v33, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s received %u frames from output_handler", v60, 0x1Cu);
      }
    }
    *(void *)os_log_type_t v60 = 0;
    *(void *)&v60[8] = v60;
    LODWORD(v61) = 0;
    *(void *)&v60[16] = 0x2000000000;
    v47[0] = MEMORY[0x1E4F143A8];
    v47[1] = 0x40000000;
    uint64_t v48 = ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke;
    unsigned int v49 = &unk_1E5240A30;
    uint64_t v50 = v60;
    uint64_t v51 = a1;
    uint64_t v8 = v53[0];
    do
    {
      if (!v8) {
        break;
      }
      uint64_t v9 = *(void *)(v8 + 32);
      char v10 = ((uint64_t (*)(void *))v48)(v47);
      uint64_t v8 = v9;
    }
    while ((v10 & 1) != 0);
    if (nghttp2_session_consume_connection())
    {
      BOOL v11 = p_cache;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v12 = nghttp2_strerror();
      *(_DWORD *)unsigned int buf = 136446466;
      int v55 = "nw_protocol_http2_transport_process_input";
      __int16 v56 = 2082;
      uint64_t v57 = v12;
      int v13 = (char *)_os_log_send_and_compose_impl();
      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v46 = 0;
      if (!__nwlog_fault(v13, &type, &v46)) {
        goto LABEL_25;
      }
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v14 = gLogObj;
        os_log_type_t v15 = type;
        if (os_log_type_enabled((os_log_t)gLogObj, type))
        {
          uint64_t v16 = nghttp2_strerror();
          *(_DWORD *)unsigned int buf = 136446466;
          int v55 = "nw_protocol_http2_transport_process_input";
          __int16 v56 = 2082;
          uint64_t v57 = v16;
          os_log_type_t v17 = v14;
          os_log_type_t v18 = v15;
          int v19 = "%{public}s nghttp2_session_consume_connection: %{public}s failed";
          goto LABEL_24;
        }
        goto LABEL_25;
      }
      if (v46)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        __int16 v21 = gLogObj;
        os_log_type_t v22 = type;
        BOOL v23 = os_log_type_enabled((os_log_t)gLogObj, type);
        if (backtrace_string)
        {
          if (v23)
          {
            uint64_t v24 = nghttp2_strerror();
            *(_DWORD *)unsigned int buf = 136446722;
            int v55 = "nw_protocol_http2_transport_process_input";
            __int16 v56 = 2082;
            uint64_t v57 = v24;
            __int16 v58 = 2082;
            BOOL v59 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v21, v22, "%{public}s nghttp2_session_consume_connection: %{public}s failed, dumping backtrace:%{public}s", buf, 0x20u);
          }
          free(backtrace_string);
          goto LABEL_25;
        }
        if (!v23)
        {
LABEL_25:
          if (v13) {
            free(v13);
          }
          p_cache = v11;
          goto LABEL_28;
        }
        uint64_t v28 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446466;
        int v55 = "nw_protocol_http2_transport_process_input";
        __int16 v56 = 2082;
        uint64_t v57 = v28;
        os_log_type_t v17 = v21;
        os_log_type_t v18 = v22;
        int v19 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, no backtrace";
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        uint64_t v25 = gLogObj;
        os_log_type_t v26 = type;
        if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
          goto LABEL_25;
        }
        uint64_t v27 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446466;
        int v55 = "nw_protocol_http2_transport_process_input";
        __int16 v56 = 2082;
        uint64_t v57 = v27;
        os_log_type_t v17 = v25;
        os_log_type_t v18 = v26;
        int v19 = "%{public}s nghttp2_session_consume_connection: %{public}s failed, backtrace limit exceeded";
      }
LABEL_24:
      _os_log_impl(&dword_1830D4000, v17, v18, v19, buf, 0x16u);
      goto LABEL_25;
    }
LABEL_28:
    if (*((unsigned char *)p_cache + 3665))
    {
      BOOL v34 = __nwlog_obj();
      if (os_log_type_enabled(v34, OS_LOG_TYPE_DEBUG))
      {
        int v35 = *(_DWORD *)(*(void *)&v60[8] + 24);
        *(_DWORD *)unsigned int buf = 136446722;
        int v55 = "nw_protocol_http2_transport_process_input";
        __int16 v56 = 2082;
        uint64_t v57 = a1 + 205;
        __int16 v58 = 1024;
        LODWORD(v59) = v35;
        _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s consumed %u bytes on connection", buf, 0x1Cu);
      }
    }
    os_log_type_t v29 = *(char **)(a1 + 112);
    v45[0] = MEMORY[0x1E4F143A8];
    v45[1] = 0x40000000;
    v45[2] = ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke_25;
    v45[3] = &__block_descriptor_tmp_26_38276;
    v45[4] = a1;
    nw_hash_table_apply(v29, (uint64_t)v45);
    uint64_t v30 = v53[0];
    do
    {
      if (!v30) {
        break;
      }
      uint64_t v31 = *(void *)(v30 + 32);
      char v32 = ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke_27((uint64_t)&__block_literal_global_30, v30);
      uint64_t v30 = v31;
    }
    while ((v32 & 1) != 0);
    if (*((unsigned char *)p_cache + 3665))
    {
      int v36 = __nwlog_obj();
      if (os_log_type_enabled(v36, OS_LOG_TYPE_DEBUG))
      {
        *(_DWORD *)unsigned int buf = 136446722;
        int v55 = "nw_protocol_http2_transport_process_input";
        __int16 v56 = 2082;
        uint64_t v57 = a1 + 205;
        __int16 v58 = 1024;
        LODWORD(v59) = v7;
        _os_log_impl(&dword_1830D4000, v36, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s processed %u frames", buf, 0x1Cu);
      }
    }
    _Block_object_dispose(v60, 8);
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  *(_DWORD *)os_log_type_t v60 = 136446466;
  *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
  *(_WORD *)&v60[12] = 2082;
  *(void *)&v60[14] = a1 + 205;
  uint64_t v37 = (char *)_os_log_send_and_compose_impl();
  buf[0] = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (!__nwlog_fault(v37, buf, &type)) {
    goto LABEL_54;
  }
  if (buf[0] == 17)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    BOOL v38 = gLogObj;
    os_log_type_t v39 = buf[0];
    if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)buf[0]))
    {
      *(_DWORD *)os_log_type_t v60 = 136446466;
      *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(void *)&v60[14] = a1 + 205;
      os_log_type_t v40 = "%{public}s %{public}s output handler has no get_input_frames callback";
      goto LABEL_53;
    }
    goto LABEL_54;
  }
  if (type == OS_LOG_TYPE_DEFAULT)
  {
    BOOL v38 = __nwlog_obj();
    os_log_type_t v39 = buf[0];
    if (!os_log_type_enabled(v38, (os_log_type_t)buf[0])) {
      goto LABEL_54;
    }
    *(_DWORD *)os_log_type_t v60 = 136446466;
    *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
    *(_WORD *)&v60[12] = 2082;
    *(void *)&v60[14] = a1 + 205;
    os_log_type_t v40 = "%{public}s %{public}s output handler has no get_input_frames callback, backtrace limit exceeded";
    goto LABEL_53;
  }
  os_log_type_t v41 = (char *)__nw_create_backtrace_string();
  BOOL v38 = __nwlog_obj();
  os_log_type_t v39 = buf[0];
  BOOL v42 = os_log_type_enabled(v38, (os_log_type_t)buf[0]);
  if (v41)
  {
    if (v42)
    {
      *(_DWORD *)os_log_type_t v60 = 136446722;
      *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(void *)&v60[14] = a1 + 205;
      *(_WORD *)&v60[22] = 2082;
      BOOL v61 = v41;
      _os_log_impl(&dword_1830D4000, v38, v39, "%{public}s %{public}s output handler has no get_input_frames callback, dumping backtrace:%{public}s", v60, 0x20u);
    }
    free(v41);
    goto LABEL_54;
  }
  if (v42)
  {
    *(_DWORD *)os_log_type_t v60 = 136446466;
    *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
    *(_WORD *)&v60[12] = 2082;
    *(void *)&v60[14] = a1 + 205;
    os_log_type_t v40 = "%{public}s %{public}s output handler has no get_input_frames callback, no backtrace";
LABEL_53:
    _os_log_impl(&dword_1830D4000, v38, v39, v40, v60, 0x16u);
  }
LABEL_54:
  if (v37) {
    free(v37);
  }
LABEL_56:
  if (*((unsigned char *)p_cache + 3665))
  {
    int v44 = __nwlog_obj();
    if (os_log_type_enabled(v44, OS_LOG_TYPE_DEBUG))
    {
      *(_DWORD *)os_log_type_t v60 = 136446466;
      *(void *)&v60[4] = "nw_protocol_http2_transport_process_input";
      *(_WORD *)&v60[12] = 2082;
      *(void *)&v60[14] = a1 + 205;
      _os_log_impl(&dword_1830D4000, v44, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s about to allow http2_transport to send pending data", v60, 0x16u);
    }
  }
  nw_http2_transport_session_send(a1);
}

uint64_t ___ZL41nw_protocol_http2_transport_process_inputP27nw_protocol_http2_transport_block_invoke(uint64_t a1, uint64_t a2)
{
  uint64_t v42 = *MEMORY[0x1E4F143B8];
  unsigned int v33 = 0;
  uint64_t v3 = nw_frame_unclaimed_bytes(a2, &v33);
  unsigned int v4 = v33;
  if (v3) {
    BOOL v5 = v33 == 0;
  }
  else {
    BOOL v5 = 1;
  }
  uint64_t v6 = !v5;
  if (v5) {
    return v6;
  }
  uint64_t v7 = v3;
  if (!gLogDatapath) {
    goto LABEL_9;
  }
  uint64_t v27 = __nwlog_obj();
  BOOL v28 = os_log_type_enabled(v27, OS_LOG_TYPE_DEBUG);
  unsigned int v4 = v33;
  if (v28)
  {
    uint64_t v29 = *(void *)(a1 + 40);
    uint64_t v30 = (const char *)(v29 + 205);
    BOOL v5 = v29 == 0;
    uint64_t v31 = "";
    if (!v5) {
      uint64_t v31 = v30;
    }
    *(_DWORD *)unsigned int buf = 136446722;
    int v35 = "nw_protocol_http2_transport_process_input_block_invoke";
    __int16 v36 = 2082;
    uint64_t v37 = v31;
    __int16 v38 = 1024;
    int v39 = v33;
    _os_log_impl(&dword_1830D4000, v27, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s processing frame of length %u bytes", buf, 0x1Cu);
    unsigned int v4 = v33;
  }
  if (v4)
  {
LABEL_9:
    unsigned int v8 = 0;
    while (1)
    {
      uint64_t v9 = MEMORY[0x1853175E0](*(void *)(*(void *)(a1 + 40) + 80), v7 + v8, v4 - v8);
      if ((v9 & 0x8000000000000000) == 0) {
        goto LABEL_28;
      }
      int v10 = *(unsigned char *)(*(void *)(a1 + 40) + 204) & 8;
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v11 = gLogObj;
      if (v9 == -902 && v10 != 0) {
        break;
      }
      if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
      {
        uint64_t v13 = *(void *)(a1 + 40);
        if (v13) {
          uint64_t v14 = (const char *)(v13 + 205);
        }
        else {
          uint64_t v14 = "";
        }
        uint64_t v15 = nghttp2_strerror();
        *(_DWORD *)unsigned int buf = 136446978;
        int v35 = "nw_protocol_http2_transport_process_input_block_invoke";
        __int16 v36 = 2082;
        uint64_t v37 = v14;
        __int16 v38 = 1024;
        int v39 = v9;
        __int16 v40 = 2082;
        uint64_t v41 = v15;
        uint64_t v16 = v11;
        os_log_type_t v17 = OS_LOG_TYPE_ERROR;
        os_log_type_t v18 = "%{public}s %{public}s ERROR: Could not process incoming data: %d (%{public}s)";
LABEL_26:
        _os_log_impl(&dword_1830D4000, v16, v17, v18, buf, 0x26u);
      }
LABEL_27:
      nw_http2_transport_connection_close(*(void *)(a1 + 40));
LABEL_28:
      v8 += v9;
      if (gLogDatapath)
      {
        BOOL v23 = __nwlog_obj();
        if (os_log_type_enabled(v23, OS_LOG_TYPE_DEBUG))
        {
          uint64_t v24 = *(void *)(a1 + 40);
          uint64_t v25 = (const char *)(v24 + 205);
          BOOL v5 = v24 == 0;
          os_log_type_t v26 = "";
          if (!v5) {
            os_log_type_t v26 = v25;
          }
          *(_DWORD *)unsigned int buf = 136446722;
          int v35 = "nw_protocol_http2_transport_process_input_block_invoke";
          __int16 v36 = 2082;
          uint64_t v37 = v26;
          __int16 v38 = 1024;
          int v39 = v8;
          _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s nghttp2_session_mem_recv consumed %u bytes", buf, 0x1Cu);
        }
      }
      unsigned int v4 = v33;
      if (v8 >= v33) {
        goto LABEL_41;
      }
    }
    if (!os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_DEFAULT)) {
      goto LABEL_27;
    }
    uint64_t v20 = *(void *)(a1 + 40);
    if (v20) {
      __int16 v21 = (const char *)(v20 + 205);
    }
    else {
      __int16 v21 = "";
    }
    uint64_t v22 = nghttp2_strerror();
    *(_DWORD *)unsigned int buf = 136446978;
    int v35 = "nw_protocol_http2_transport_process_input_block_invoke";
    __int16 v36 = 2082;
    uint64_t v37 = v21;
    __int16 v38 = 1024;
    int v39 = -902;
    __int16 v40 = 2082;
    uint64_t v41 = v22;
    uint64_t v16 = v11;
    os_log_type_t v17 = OS_LOG_TYPE_DEFAULT;
    os_log_type_t v18 = "%{public}s %{public}s Could not process incoming data: %d (%{public}s), closing";
    goto LABEL_26;
  }
  unsigned int v8 = 0;
LABEL_41:
  *(_DWORD *)(*(void *)(*(void *)(a1 + 32) + 8) + 24) += v8;
  return v6;
}

uint64_t nw_protocol_http1_copy_info(uint64_t a1, int a2)
{
  uint64_t v54 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_http1_protocol";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v18, &type, &v48)) {
      goto LABEL_94;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v48)
      {
        int v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_93;
      }
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v23 = os_log_type_enabled(v19, type);
      if (!backtrace_string)
      {
        if (!v23) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_93;
      }
      if (v23)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v52 = 2082;
        int v53 = backtrace_string;
        _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(backtrace_string);
      goto LABEL_94;
    }
    int v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_94;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_http1_protocol";
    __int16 v21 = "%{public}s called with null protocol";
LABEL_93:
    _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
    goto LABEL_94;
  }
  uint64_t v2 = *(void *)(a1 + 40);
  if (!v2)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_http1_protocol";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v18, &type, &v48)) {
      goto LABEL_94;
    }
    if (type != OS_LOG_TYPE_FAULT)
    {
      if (!v48)
      {
        int v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null handle, backtrace limit exceeded";
        goto LABEL_93;
      }
      uint64_t v24 = (char *)__nw_create_backtrace_string();
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v25 = os_log_type_enabled(v19, type);
      if (!v24)
      {
        if (!v25) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null handle, no backtrace";
        goto LABEL_93;
      }
      if (v25)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v52 = 2082;
        int v53 = v24;
        os_log_type_t v26 = "%{public}s called with null handle, dumping backtrace:%{public}s";
LABEL_71:
        _os_log_impl(&dword_1830D4000, v19, v20, v26, buf, 0x16u);
      }
LABEL_72:
      free(v24);
      if (!v18)
      {
LABEL_96:
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_protocol_http1_copy_info";
        int v35 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v48 = 0;
        if (!__nwlog_fault(v35, &type, &v48)) {
          goto LABEL_128;
        }
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v36 = gLogObj;
          os_log_type_t v37 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_128;
          }
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v51 = "nw_protocol_http1_copy_info";
          __int16 v38 = "%{public}s called with null http1";
        }
        else
        {
          if (v48)
          {
            int v39 = (char *)__nw_create_backtrace_string();
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            __int16 v40 = gLogObj;
            os_log_type_t v41 = type;
            BOOL v42 = os_log_type_enabled((os_log_t)gLogObj, type);
            if (!v39)
            {
              if (!v42) {
                goto LABEL_128;
              }
              *(_DWORD *)unsigned int buf = 136446210;
              uint64_t v51 = "nw_protocol_http1_copy_info";
              __int16 v38 = "%{public}s called with null http1, no backtrace";
              goto LABEL_134;
            }
            if (v42)
            {
              *(_DWORD *)unsigned int buf = 136446466;
              uint64_t v51 = "nw_protocol_http1_copy_info";
              __int16 v52 = 2082;
              int v53 = v39;
              _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null http1, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v39);
LABEL_128:
            if (!v35) {
              return 0;
            }
LABEL_129:
            free(v35);
            return 0;
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v36 = gLogObj;
          os_log_type_t v37 = type;
          if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
            goto LABEL_128;
          }
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v51 = "nw_protocol_http1_copy_info";
          __int16 v38 = "%{public}s called with null http1, backtrace limit exceeded";
        }
LABEL_126:
        BOOL v45 = v36;
        os_log_type_t v46 = v37;
LABEL_127:
        _os_log_impl(&dword_1830D4000, v45, v46, v38, buf, 0xCu);
        goto LABEL_128;
      }
LABEL_95:
      free(v18);
      goto LABEL_96;
    }
    int v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_94;
    }
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_http1_protocol";
    __int16 v21 = "%{public}s called with null handle";
    goto LABEL_93;
  }
  int v4 = *(_DWORD *)(v2 + 24);
  BOOL v5 = *(uint64_t **)(a1 + 40);
  if (v4 == 1) {
    goto LABEL_10;
  }
  if (v4 != 2)
  {
    if (v4 != 3) {
      goto LABEL_96;
    }
    uint64_t v6 = *(void *)(v2 + 16);
    if (v6)
    {
      BOOL v5 = (uint64_t *)(v6 + 480);
      goto LABEL_10;
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_http1_protocol";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (__nwlog_fault(v18, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null handle->http1_connection";
        goto LABEL_93;
      }
      if (!v48)
      {
        int v19 = __nwlog_obj();
        os_log_type_t v20 = type;
        if (!os_log_type_enabled(v19, type)) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_93;
      }
      uint64_t v24 = (char *)__nw_create_backtrace_string();
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      BOOL v31 = os_log_type_enabled(v19, type);
      if (!v24)
      {
        if (!v31) {
          goto LABEL_94;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v21 = "%{public}s called with null handle->http1_connection, no backtrace";
        goto LABEL_93;
      }
      if (v31)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v51 = "nw_http1_get_http1_protocol";
        __int16 v52 = 2082;
        int v53 = v24;
        os_log_type_t v26 = "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s";
        goto LABEL_71;
      }
      goto LABEL_72;
    }
LABEL_94:
    if (!v18) {
      goto LABEL_96;
    }
    goto LABEL_95;
  }
  uint64_t v7 = *(void *)(v2 + 8);
  if (!v7)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_http1_protocol";
    os_log_type_t v18 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v18, &type, &v48)) {
      goto LABEL_94;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v51 = "nw_http1_get_http1_protocol";
      __int16 v21 = "%{public}s called with null handle->http1_stream";
      goto LABEL_93;
    }
    if (!v48)
    {
      int v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_94;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v51 = "nw_http1_get_http1_protocol";
      __int16 v21 = "%{public}s called with null handle->http1_stream, backtrace limit exceeded";
      goto LABEL_93;
    }
    uint64_t v24 = (char *)__nw_create_backtrace_string();
    int v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    BOOL v32 = os_log_type_enabled(v19, type);
    if (!v24)
    {
      if (!v32) {
        goto LABEL_94;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v51 = "nw_http1_get_http1_protocol";
      __int16 v21 = "%{public}s called with null handle->http1_stream, no backtrace";
      goto LABEL_93;
    }
    if (v32)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      uint64_t v51 = "nw_http1_get_http1_protocol";
      __int16 v52 = 2082;
      int v53 = v24;
      os_log_type_t v26 = "%{public}s called with null handle->http1_stream, dumping backtrace:%{public}s";
      goto LABEL_71;
    }
    goto LABEL_72;
  }
  BOOL v5 = (uint64_t *)(v7 + 248);
LABEL_10:
  uint64_t v8 = *v5;
  if (!v8) {
    goto LABEL_96;
  }
  if (v4 != 2)
  {
    if (v4 != 3) {
      goto LABEL_114;
    }
    uint64_t v9 = *(void *)(v2 + 16);
    if (v9)
    {
      int v10 = (uint64_t *)(v9 + 488);
      goto LABEL_16;
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_http1_get_stream_for_protocol";
    uint64_t v27 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (__nwlog_fault(v27, &type, &v48))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        BOOL v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_stream_for_protocol";
        uint64_t v30 = "%{public}s called with null handle->http1_connection";
        goto LABEL_111;
      }
      if (!v48)
      {
        BOOL v28 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (!os_log_type_enabled(v28, type)) {
          goto LABEL_112;
        }
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_stream_for_protocol";
        uint64_t v30 = "%{public}s called with null handle->http1_connection, backtrace limit exceeded";
        goto LABEL_111;
      }
      unsigned int v33 = (char *)__nw_create_backtrace_string();
      BOOL v28 = __nwlog_obj();
      os_log_type_t v29 = type;
      BOOL v34 = os_log_type_enabled(v28, type);
      if (v33)
      {
        if (v34)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v51 = "nw_http1_get_stream_for_protocol";
          __int16 v52 = 2082;
          int v53 = v33;
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s called with null handle->http1_connection, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(v33);
        goto LABEL_112;
      }
      if (v34)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v51 = "nw_http1_get_stream_for_protocol";
        uint64_t v30 = "%{public}s called with null handle->http1_connection, no backtrace";
LABEL_111:
        _os_log_impl(&dword_1830D4000, v28, v29, v30, buf, 0xCu);
      }
    }
LABEL_112:
    if (v27) {
      free(v27);
    }
LABEL_114:
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v51 = "nw_protocol_http1_copy_info";
    int v35 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v48 = 0;
    if (!__nwlog_fault(v35, &type, &v48)) {
      goto LABEL_128;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v36 = gLogObj;
      os_log_type_t v37 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_128;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v51 = "nw_protocol_http1_copy_info";
      __int16 v38 = "%{public}s called with null http1_stream";
      goto LABEL_126;
    }
    if (!v48)
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v36 = gLogObj;
      os_log_type_t v37 = type;
      if (!os_log_type_enabled((os_log_t)gLogObj, type)) {
        goto LABEL_128;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v51 = "nw_protocol_http1_copy_info";
      __int16 v38 = "%{public}s called with null http1_stream, backtrace limit exceeded";
      goto LABEL_126;
    }
    char v43 = (char *)__nw_create_backtrace_string();
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    __int16 v40 = gLogObj;
    os_log_type_t v41 = type;
    BOOL v44 = os_log_type_enabled((os_log_t)gLogObj, type);
    if (v43)
    {
      if (v44)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        uint64_t v51 = "nw_protocol_http1_copy_info";
        __int16 v52 = 2082;
        int v53 = v43;
        _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s called with null http1_stream, dumping backtrace:%{public}s", buf, 0x16u);
      }
      free(v43);
      if (!v35) {
        return 0;
      }
      goto LABEL_129;
    }
    if (v44)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v51 = "nw_protocol_http1_copy_info";
      __int16 v38 = "%{public}s called with null http1_stream, no backtrace";
LABEL_134:
      BOOL v45 = v40;
      os_log_type_t v46 = v41;
      goto LABEL_127;
    }
    goto LABEL_128;
  }
  int v10 = (uint64_t *)(v2 + 8);
LABEL_16:
  uint64_t v11 = *v10;
  if (!*v10) {
    goto LABEL_114;
  }
  if (a2 == 253) {
    return *(void *)(v8 + 328);
  }
  uint64_t v13 = *(void *)(v11 + 256);
  if (v13)
  {
    uint64_t v14 = nw_protocol_common_copy_info(v13, a2);
    BOOL v12 = v14;
    if (a2 != 255) {
      return v12;
    }
    if (v14) {
      goto LABEL_25;
    }
    goto LABEL_24;
  }
  if (a2 != 255) {
    return 0;
  }
LABEL_24:
  BOOL v12 = nw_array_create();
LABEL_25:
  uint64_t v15 = *(void *)(v11 + 256);
  if (v15)
  {
    uint64_t v16 = *(void **)(v15 + 768);
    if (v16) {
      nw_array_append(v12, v16);
    }
  }
  os_log_type_t v17 = *(void **)(v11 + 352);
  if (v17) {
    nw_array_append(v12, v17);
  }
  return v12;
}

uint64_t __nwlog_fault(const char *a1, unsigned char *a2, unsigned char *a3)
{
  uint64_t v32 = *MEMORY[0x1E4F143B8];
  pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
  if (sNWIsBetweenForkAndExec == 1 && (sNWParentAllowedDispatch & 1) != 0) {
    return 0;
  }
  if (sNWDispatchAllowedNow)
  {
    int v7 = 1;
    uint64_t v6 = 0;
    if (!a3) {
      return v6;
    }
  }
  else if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0 {
         || (getpid(), sandbox_check() == 1))
  }
  {
    int v7 = 1;
    sNWDispatchAllowedNow = 1;
    uint64_t v6 = 0;
    if (!a3) {
      return v6;
    }
  }
  else
  {
    int v7 = sNWDispatchAllowedNow;
    uint64_t v6 = 0;
    if (!a3) {
      return v6;
    }
  }
  if (a2 && v7)
  {
    *a2 = 16;
    *a3 = 0;
    uint64_t v23 = 0;
    uint64_t v24 = &v23;
    uint64_t v25 = 0x3802000000;
    os_log_type_t v26 = __Block_byref_object_copy__44835;
    uint64_t v27 = __Block_byref_object_dispose__44836;
    aBlock = 0;
    char v29 = -1;
    v22[0] = MEMORY[0x1E4F143A8];
    v22[1] = 0x40000000;
    v22[2] = ____nwlog_fault_block_invoke;
    v22[3] = &unk_1E52420A0;
    v22[4] = &v23;
    os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
    ____nwlog_fault_block_invoke((uint64_t)v22);
    os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
    uint64_t v8 = v24[5];
    if (v8)
    {
      uint64_t v8 = (*(uint64_t (**)(uint64_t, const char *))(v8 + 16))(v8, a1);
      if (v8)
      {
        uint64_t v6 = 0;
LABEL_44:
        _Block_object_dispose(&v23, 8);
        if ((v29 & 1) != 0 && aBlock) {
          _Block_release(aBlock);
        }
        return v6;
      }
    }
    if (a1)
    {
      uint64_t v8 = pthread_once(&nw_settings_setup_atfork::pOnce, (void (*)(void))nw_settings_setup_atfork_inner);
      if (sNWIsBetweenForkAndExec != 1 || (sNWParentAllowedDispatch & 1) == 0)
      {
        if (sNWDispatchAllowedNow)
        {
LABEL_27:
          pthread_mutex_lock(&__nwlog_fault_add_description_to_list(char const*)::mutex);
          xpc_object_t v9 = (xpc_object_t)__nwlog_fault_add_description_to_list(char const*)::known_faults;
          if (__nwlog_fault_add_description_to_list(char const*)::known_faults
            || (xpc_object_t v9 = xpc_dictionary_create(0, 0, 0),
                (__nwlog_fault_add_description_to_list(char const*)::known_faults = (uint64_t)v9) != 0))
          {
            if (xpc_dictionary_get_BOOL(v9, a1))
            {
              char v10 = 1;
LABEL_34:
              uint64_t v8 = pthread_mutex_unlock(&__nwlog_fault_add_description_to_list(char const*)::mutex);
LABEL_35:
              uint64_t v11 = (const char *)nw_setting_tcpconn_disable_simulate_crash;
              networkd_settings_init(v8);
              if (sCachedSettings)
              {
                pthread_mutex_lock(&sSettingsMutex);
                BOOL v12 = (void *)sCachedSettings;
                if (sCachedSettings
                  && (Class Class = object_getClass((id)sCachedSettings), v11)
                  && Class == (Class)MEMORY[0x1E4F14590]
                  && (xpc_object_t v14 = xpc_dictionary_get_value(v12, v11)) != 0
                  && (uint64_t v15 = v14, object_getClass(v14) == (Class)MEMORY[0x1E4F14570]))
                {
                  BOOL value = xpc_BOOL_get_value(v15);
                  pthread_mutex_unlock(&sSettingsMutex);
                  if (value) {
                    goto LABEL_43;
                  }
                }
                else
                {
                  pthread_mutex_unlock(&sSettingsMutex);
                }
              }
              v20[0] = MEMORY[0x1E4F143A8];
              v20[1] = 0x40000000;
              void v20[2] = ____nwlog_fault_block_invoke_2;
              v20[3] = &__block_descriptor_tmp_1;
              char v21 = v10;
              v20[4] = a2;
              void v20[5] = a3;
              os_unfair_lock_lock((os_unfair_lock_t)&gLogLock);
              ____nwlog_fault_block_invoke_2((uint64_t)v20);
              os_unfair_lock_unlock((os_unfair_lock_t)&gLogLock);
LABEL_43:
              uint64_t v6 = 1;
              goto LABEL_44;
            }
            xpc_dictionary_set_BOOL((xpc_object_t)__nwlog_fault_add_description_to_list(char const*)::known_faults, a1, 1);
          }
          else
          {
            uint64_t v17 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init(v17);
            os_log_type_t v18 = gLogObj;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)unsigned int buf = 136446210;
              BOOL v31 = "__nwlog_fault_add_description_to_list";
              _os_log_impl(&dword_1830D4000, v18, OS_LOG_TYPE_ERROR, "%{public}s xpc_dictionary_create failed", buf, 0xCu);
            }
          }
          char v10 = 0;
          goto LABEL_34;
        }
        if ((_dispatch_is_fork_of_multithreaded_parent() & 1) == 0 && (_dispatch_is_multithreaded() & 1) != 0
          || (getpid(), uint64_t v8 = sandbox_check(), v8 == 1))
        {
          sNWDispatchAllowedNow = 1;
          goto LABEL_27;
        }
        if (sNWDispatchAllowedNow == 1) {
          goto LABEL_27;
        }
      }
    }
    char v10 = 0;
    goto LABEL_35;
  }
  return v6;
}

BOOL nw_interpose_get_client_uuid(void *a1, _OWORD *a2)
{
  uint64_t v21 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  int v4 = v3;
  if (v3)
  {
    os_unfair_lock_lock(v3 + 2);
    BOOL client_id = nw_path_evaluator_get_client_id(*(void **)&v4[10]._os_unfair_lock_opaque, a2);
    os_unfair_lock_unlock(v4 + 2);
    goto LABEL_3;
  }
  int v7 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v18 = "nw_interpose_get_client_uuid";
  uint64_t v8 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v15 = 0;
  if (__nwlog_fault(v8, &type, &v15))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      xpc_object_t v9 = __nwlog_obj();
      os_log_type_t v10 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_interpose_get_client_uuid";
        _os_log_impl(&dword_1830D4000, v9, v10, "%{public}s called with null interpose", buf, 0xCu);
      }
    }
    else if (v15)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      xpc_object_t v9 = __nwlog_obj();
      os_log_type_t v12 = type;
      BOOL v13 = os_log_type_enabled(v9, type);
      if (backtrace_string)
      {
        if (v13)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v18 = "nw_interpose_get_client_uuid";
          __int16 v19 = 2082;
          os_log_type_t v20 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null interpose, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v13)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_interpose_get_client_uuid";
        _os_log_impl(&dword_1830D4000, v9, v12, "%{public}s called with null interpose, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      xpc_object_t v9 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v9, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v18 = "nw_interpose_get_client_uuid";
        _os_log_impl(&dword_1830D4000, v9, v14, "%{public}s called with null interpose, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v8) {
    free(v8);
  }
  BOOL client_id = 0;
LABEL_3:

  return client_id;
}

nw_browser_t nw_browser_create(nw_browse_descriptor_t descriptor, nw_parameters_t parameters)
{
  uint64_t v63 = *MEMORY[0x1E4F143B8];
  int v4 = descriptor;
  BOOL v5 = parameters;
  uint64_t v6 = v5;
  if (v4)
  {
    int v53 = v5;
    int v7 = [NWConcrete_nw_browser alloc];
    uint64_t v8 = v4;
    xpc_object_t v9 = v6;
    if (!v7)
    {
LABEL_21:
      uint64_t v17 = 0;
LABEL_51:

      uint64_t v6 = v53;
      goto LABEL_52;
    }
    *((_DWORD *)v7 + 48) = nw_browser_get_next_log_id();
    if (v9)
    {
      *((unsigned char *)v7 + 198) = nw_parameters_get_sensitive_redacted(v9);
    }
    else
    {
      if (nw_context_copy_implicit_context::onceToken != -1) {
        dispatch_once(&nw_context_copy_implicit_context::onceToken, &__block_literal_global_18);
      }
      id v10 = (id)nw_context_copy_implicit_context::implicit_context;
      uint64_t v11 = v10;
      if (v10 && (int v12 = *((_DWORD *)v10 + 31), (v12 - 2) >= 2))
      {
        BOOL v13 = v12 != 1;
      }
      else
      {
        if (nwlog_get_sensitive_redacted::onceToken != -1) {
          dispatch_once(&nwlog_get_sensitive_redacted::onceToken, &__block_literal_global_75);
        }
        BOOL v13 = nwlog_get_sensitive_redacted::sensitiveRedacted != 0;
      }

      *((unsigned char *)v7 + 198) = v13;
    }
    int v14 = nw_browse_descriptor_get_type(v8);
    if (v14 == 1)
    {
      int v18 = 3;
    }
    else
    {
      if (!v14)
      {
        if (!nw_parameters_get_logging_disabled(*((void *)v7 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          char v15 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
          {
            int v16 = *((_DWORD *)v7 + 48);
            *(_DWORD *)unsigned int buf = 136446466;
            __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            __int16 v59 = 1024;
            *(_DWORD *)os_log_type_t v60 = v16;
            _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s [B%u] failed due to invalid descriptor type", buf, 0x12u);
          }
        }
        goto LABEL_21;
      }
      if (nw_browse_descriptor_is_custom_type(v8))
      {
        __int16 v19 = nw_browse_descriptor_copy_custom_browse_block(v8);

        if (v19) {
          int v18 = 1;
        }
        else {
          int v18 = 2;
        }
      }
      else
      {
        int v18 = 2;
      }
    }
    v56.os_log_type_t receiver = v7;
    v56.super_class = (Class)NWConcrete_nw_browser;
    os_log_type_t v20 = [&v56 init];
    int v7 = (NWConcrete_nw_browser *)v20;
    if (v20)
    {
      objc_storeStrong((id *)&v20[4].isa, descriptor);
      *((_DWORD *)v7 + 6) = v18;
      *((_DWORD *)v7 + 18) = 0;
      if (v9) {
        nw_parameters_t v21 = v9;
      }
      else {
        nw_parameters_t v21 = nw_parameters_create();
      }
      uint64_t v22 = (void *)*((void *)v7 + 5);
      *((void *)v7 + 5) = v21;

      id v23 = nw_parameters_copy_context(*((void **)v7 + 5));
      if (!nw_context_is_inline(v23))
      {
        *((unsigned char *)v7 + 196) = nw_browse_descriptor_get_include_txt_record(*((nw_browse_descriptor_t *)v7 + 4));
        *((unsigned char *)v7 + 197) = nw_browse_descriptor_get_sign_results(*((void **)v7 + 4));
        BOOL v28 = nw_parameters_copy_description_internal(*((NWConcrete_nw_parameters **)v7 + 5), 1);
        if (!nw_parameters_get_logging_disabled(*((void *)v7 + 5)))
        {
          if (__nwlog_browser_log::onceToken[0] != -1) {
            dispatch_once(__nwlog_browser_log::onceToken, &__block_literal_global_20_44865);
          }
          char v29 = (id)gbrowserLogObj;
          if (os_log_type_enabled(v29, OS_LOG_TYPE_DEFAULT))
          {
            int v30 = *((_DWORD *)v7 + 48);
            uint64_t v31 = *((void *)v7 + 4);
            *(_DWORD *)unsigned int buf = 136446978;
            __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            __int16 v59 = 1024;
            *(_DWORD *)os_log_type_t v60 = v30;
            *(_WORD *)&v60[4] = 2112;
            *(void *)&v60[6] = v31;
            __int16 v61 = 2080;
            uint64_t v62 = v28;
            _os_log_impl(&dword_1830D4000, v29, OS_LOG_TYPE_DEFAULT, "%{public}s [B%u] create with %@, parameters: %s", buf, 0x26u);
          }
        }
        if (v28) {
          free(v28);
        }
        uint64_t v17 = v7;
        goto LABEL_50;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      id v24 = (id)gLogObj;
      *(_DWORD *)unsigned int buf = 136446210;
      __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
      uint64_t v25 = (char *)_os_log_send_and_compose_impl();

      os_log_type_t type = OS_LOG_TYPE_ERROR;
      char v54 = 0;
      if (__nwlog_fault(v25, &type, &v54))
      {
        if (type == OS_LOG_TYPE_FAULT)
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v26 = (id)gLogObj;
          os_log_type_t v27 = type;
          if (os_log_type_enabled(v26, type))
          {
            *(_DWORD *)unsigned int buf = 136446210;
            __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s Cannot use nw_browser on inline contexts", buf, 0xCu);
          }
        }
        else if (v54)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v26 = (id)gLogObj;
          os_log_type_t v34 = type;
          BOOL v35 = os_log_type_enabled(v26, type);
          if (backtrace_string)
          {
            if (v35)
            {
              *(_DWORD *)unsigned int buf = 136446466;
              __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
              __int16 v59 = 2082;
              *(void *)os_log_type_t v60 = backtrace_string;
              _os_log_impl(&dword_1830D4000, v26, v34, "%{public}s Cannot use nw_browser on inline contexts, dumping backtrace:%{public}s", buf, 0x16u);
            }

            free(backtrace_string);
            if (!v25) {
              goto LABEL_40;
            }
            goto LABEL_39;
          }
          if (v35)
          {
            *(_DWORD *)unsigned int buf = 136446210;
            __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            _os_log_impl(&dword_1830D4000, v26, v34, "%{public}s Cannot use nw_browser on inline contexts, no backtrace", buf, 0xCu);
          }
        }
        else
        {
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v26 = (id)gLogObj;
          os_log_type_t v36 = type;
          if (os_log_type_enabled(v26, type))
          {
            *(_DWORD *)unsigned int buf = 136446210;
            __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            _os_log_impl(&dword_1830D4000, v26, v36, "%{public}s Cannot use nw_browser on inline contexts, backtrace limit exceeded", buf, 0xCu);
          }
        }
      }
      if (!v25)
      {
LABEL_40:
        uint64_t v17 = 0;
LABEL_50:

        goto LABEL_51;
      }
LABEL_39:
      free(v25);
      goto LABEL_40;
    }
    os_log_type_t v41 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
    BOOL v42 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v54 = 0;
    if (__nwlog_fault(v42, &type, &v54))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        char v43 = __nwlog_obj();
        os_log_type_t v44 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
          _os_log_impl(&dword_1830D4000, v43, v44, "%{public}s [super init] failed", buf, 0xCu);
        }
      }
      else if (v54)
      {
        char v48 = (char *)__nw_create_backtrace_string();
        char v43 = __nwlog_obj();
        os_log_type_t v49 = type;
        BOOL v50 = os_log_type_enabled(v43, type);
        if (v48)
        {
          if (v50)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
            __int16 v59 = 2082;
            *(void *)os_log_type_t v60 = v48;
            _os_log_impl(&dword_1830D4000, v43, v49, "%{public}s [super init] failed, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v48);
          goto LABEL_101;
        }
        if (v50)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
          _os_log_impl(&dword_1830D4000, v43, v49, "%{public}s [super init] failed, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        char v43 = __nwlog_obj();
        os_log_type_t v52 = type;
        if (os_log_type_enabled(v43, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          __int16 v58 = "-[NWConcrete_nw_browser initWithDescriptor:parameters:]";
          _os_log_impl(&dword_1830D4000, v43, v52, "%{public}s [super init] failed, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_101:
    if (v42) {
      free(v42);
    }
    int v7 = 0;
    goto LABEL_21;
  }
  os_log_type_t v37 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  __int16 v58 = "nw_browser_create";
  __int16 v38 = (char *)_os_log_send_and_compose_impl();

  LOBYTE(v56.receiver) = 16;
  os_log_type_t type = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v38, &v56, &type))
  {
    if (LOBYTE(v56.receiver) == 17)
    {
      int v39 = __nwlog_obj();
      os_log_type_t receiver = (os_log_type_t)v56.receiver;
      if (os_log_type_enabled(v39, (os_log_type_t)v56.receiver))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v58 = "nw_browser_create";
        _os_log_impl(&dword_1830D4000, v39, receiver, "%{public}s called with null descriptor", buf, 0xCu);
      }
    }
    else if (type)
    {
      BOOL v45 = (char *)__nw_create_backtrace_string();
      int v39 = __nwlog_obj();
      os_log_type_t v46 = (os_log_type_t)v56.receiver;
      BOOL v47 = os_log_type_enabled(v39, (os_log_type_t)v56.receiver);
      if (v45)
      {
        if (v47)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          __int16 v58 = "nw_browser_create";
          __int16 v59 = 2082;
          *(void *)os_log_type_t v60 = v45;
          _os_log_impl(&dword_1830D4000, v39, v46, "%{public}s called with null descriptor, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v45);
        goto LABEL_95;
      }
      if (v47)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v58 = "nw_browser_create";
        _os_log_impl(&dword_1830D4000, v39, v46, "%{public}s called with null descriptor, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v39 = __nwlog_obj();
      os_log_type_t v51 = (os_log_type_t)v56.receiver;
      if (os_log_type_enabled(v39, (os_log_type_t)v56.receiver))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        __int16 v58 = "nw_browser_create";
        _os_log_impl(&dword_1830D4000, v39, v51, "%{public}s called with null descriptor, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_95:
  if (v38) {
    free(v38);
  }
  uint64_t v17 = 0;
LABEL_52:

  return v17;
}

void sub_1831DF41C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13)
{
  _Unwind_Resume(a1);
}

uint64_t sub_1831DF470@<X0>(NSObject *a1@<X0>, uint64_t a2@<X8>)
{
  uint64_t v4 = __swift_instantiateConcreteTypeFromMangledName(qword_1EB266A50);
  uint64_t v5 = MEMORY[0x1F4188790](v4 - 8);
  uint64_t v34 = (uint64_t)v33 - ((v6 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v7 = MEMORY[0x1F4188790](v5);
  xpc_object_t v9 = (char *)v33 - v8;
  MEMORY[0x1F4188790](v7);
  uint64_t v11 = (char *)v33 - v10;
  int v12 = (int *)type metadata accessor for NWPath(0);
  MEMORY[0x1F4188790](v12);
  int v14 = (char *)v33 - ((v13 + 15) & 0xFFFFFFFFFFFFFFF0);
  uint64_t v42 = MEMORY[0x1E4FBC860];
  uint64_t v43 = MEMORY[0x1E4FBC860];
  uint64_t v15 = type metadata accessor for NWEndpoint();
  int v16 = *(void (**)(char *, uint64_t, uint64_t, uint64_t))(*(void *)(v15 - 8) + 56);
  v16(v11, 1, 1, v15);
  v16(v9, 1, 1, v15);
  uint64_t v35 = a2;
  if (!a1)
  {
    os_log_type_t v20 = 0;
    nw_parameters_t v21 = 0;
    char *v14 = 1;
    *((_DWORD *)v14 + 4) = 0;
LABEL_17:
    *((void *)v14 + 1) = v43;
    *((void *)v14 + 3) = v42;
    *(void *)&v14[v12[13]] = a1;
    sub_183138964((uint64_t)v11, (uint64_t)&v14[v12[11]], qword_1EB266A50);
    sub_183138964((uint64_t)v9, (uint64_t)&v14[v12[12]], qword_1EB266A50);
    sub_183138878((uint64_t)v14, v35, type metadata accessor for NWPath);
    sub_18313D870((uint64_t)v20);
    return sub_18313D870((uint64_t)v21);
  }
  uint64_t v17 = swift_unknownObjectRetain();
  nw_path_status_t status = nw_path_get_status(v17);
  if (status == nw_path_status_satisfied)
  {
    char *v14 = 0;
  }
  else
  {
    if (status == nw_path_status_satisfiable) {
      char v19 = 2;
    }
    else {
      char v19 = 1;
    }
    char *v14 = v19;
  }
  v14[16] = nw_path_is_expensive(a1);
  v14[19] = nw_path_has_dns(a1);
  v14[17] = nw_path_has_ipv4(a1);
  v14[18] = nw_path_has_ipv6(a1);
  uint64_t v22 = swift_allocObject();
  *(void *)(v22 + 16) = &v43;
  uint64_t v23 = swift_allocObject();
  *(void *)(v23 + 16) = sub_1832FF1BC;
  *(void *)(v23 + 24) = v22;
  v33[1] = v22;
  __int16 v40 = sub_1832FF15C;
  uint64_t v41 = v23;
  uint64_t aBlock = MEMORY[0x1E4F143A8];
  uint64_t v37 = 1107296256;
  __int16 v38 = sub_1832FF10C;
  int v39 = &block_descriptor_6;
  id v24 = _Block_copy(&aBlock);
  swift_retain();
  swift_release();
  nw_path_enumerate_interfaces(a1, v24);
  _Block_release(v24);
  LOBYTE(v22) = swift_isEscapingClosureAtFileLocation();
  uint64_t result = swift_release();
  if (v22)
  {
    __break(1u);
  }
  else
  {
    uint64_t v26 = swift_allocObject();
    *(void *)(v26 + 16) = &v42;
    uint64_t v27 = swift_allocObject();
    *(void *)(v27 + 16) = sub_1832FF47C;
    *(void *)(v27 + 24) = v26;
    __int16 v40 = sub_1832FF15C;
    uint64_t v41 = v27;
    uint64_t aBlock = MEMORY[0x1E4F143A8];
    uint64_t v37 = 1107296256;
    __int16 v38 = sub_1832FF10C;
    int v39 = &block_descriptor_92;
    BOOL v28 = _Block_copy(&aBlock);
    swift_retain();
    swift_release();
    nw_path_enumerate_gateways(a1, v28);
    _Block_release(v28);
    char isEscapingClosureAtFileLocation = swift_isEscapingClosureAtFileLocation();
    uint64_t result = swift_release();
    if ((isEscapingClosureAtFileLocation & 1) == 0)
    {
      int v30 = nw_path_copy_effective_local_endpoint(a1);
      uint64_t v31 = v34;
      if (v30)
      {
        sub_18315A830(v30, v34);
        sub_183138A24((uint64_t)v11, qword_1EB266A50);
        sub_183138964(v31, (uint64_t)v11, qword_1EB266A50);
      }
      if (nw_path_copy_effective_remote_endpoint(a1))
      {
        uint64_t v32 = swift_unknownObjectRetain();
        sub_18315A830(v32, v31);
        swift_unknownObjectRelease();
        swift_unknownObjectRelease();
        sub_183138A24((uint64_t)v9, qword_1EB266A50);
        sub_183138964(v31, (uint64_t)v9, qword_1EB266A50);
      }
      else
      {
        swift_unknownObjectRelease();
      }
      nw_parameters_t v21 = sub_1832FF47C;
      os_log_type_t v20 = sub_1832FF1BC;
      goto LABEL_17;
    }
  }
  __break(1u);
  return result;
}

id *nw_quic_create_connection_metadata()
{
  uint64_t v2 = *MEMORY[0x1E4F143B8];
  os_unfair_lock_lock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  if (uuid_is_null((const unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid)) {
    goto LABEL_6;
  }
  if ((void)nw_uuid_generate_insecure(unsigned char *)::last_used_uuid != -1)
  {
    *(void *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid
                                                                           + 1;
    goto LABEL_7;
  }
  if (*((void *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1) == -1)
  {
LABEL_6:
    uuid_generate_random((unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid);
    BYTE9(nw_uuid_generate_insecure(unsigned char *)::last_used_uuid) = -1;
  }
  else
  {
    ++*((void *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1);
  }
LABEL_7:
  long long v1 = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  BYTE9(v1) &= ~1u;
  if (nw_protocol_copy_quic_connection_definition::onceToken != -1) {
    dispatch_once(&nw_protocol_copy_quic_connection_definition::onceToken, &__block_literal_global_55981);
  }
  return nw_protocol_metadata_create((void *)nw_protocol_copy_quic_connection_definition::quic_definition, &v1);
}

BOOL nw_socket_initialize_socket(nw_protocol *a1)
{
  uint64_t v140 = *MEMORY[0x1E4F143B8];
  if (a1->handle != &nw_protocol_ref_counted_handle)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
    char v126 = (char *)_os_log_send_and_compose_impl();
    out[0] = 16;
    type[0] = OS_LOG_TYPE_DEFAULT;
    if (!__nwlog_fault(v126, out, type)) {
      goto LABEL_302;
    }
    if (out[0] == 17)
    {
      int v127 = __nwlog_obj();
      os_log_type_t v128 = out[0];
      if (!os_log_type_enabled(v127, (os_log_type_t)out[0])) {
        goto LABEL_302;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
      __int16 v129 = "%{public}s called with null socket_handler";
    }
    else if (type[0])
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v127 = __nwlog_obj();
      os_log_type_t v128 = out[0];
      BOOL v131 = os_log_type_enabled(v127, (os_log_type_t)out[0]);
      if (backtrace_string)
      {
        if (v131)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v127, v128, "%{public}s called with null socket_handler, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_302;
      }
      if (!v131)
      {
LABEL_302:
        if (v126) {
          free(v126);
        }
        return 0;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
      __int16 v129 = "%{public}s called with null socket_handler, no backtrace";
    }
    else
    {
      int v127 = __nwlog_obj();
      os_log_type_t v128 = out[0];
      if (!os_log_type_enabled(v127, (os_log_type_t)out[0])) {
        goto LABEL_302;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
      __int16 v129 = "%{public}s called with null socket_handler, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v127, v128, v129, buf, 0xCu);
    goto LABEL_302;
  }
  p_output_handler = &a1[1].output_handler;
  int identifier = a1[2].identifier;
  if (!identifier) {
    goto LABEL_12;
  }
  uint64_t v4 = *(void *)&identifier->name[24];
  if (!v4) {
    goto LABEL_12;
  }
  uint64_t v5 = *(uint64_t (**)(nw_protocol_identifier *))(v4 + 120);
  if (!v5) {
    goto LABEL_12;
  }
  if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
  {
    uint64_t v7 = *(void *)&identifier[2].name[8];
    if (v7) {
      *(void *)&identifier[2].name[8] = v7 + 1;
    }
    uint64_t v6 = (void *)v5(identifier);
    if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
    {
      uint64_t v19 = *(void *)&identifier[2].name[8];
      if (v19)
      {
        uint64_t v20 = v19 - 1;
        *(void *)&identifier[2].name[8] = v20;
        if (!v20)
        {
          nw_parameters_t v21 = *(void (***)(void))&identifier[1].name[24];
          if (v21)
          {
            *(void *)&identifier[1].name[24] = 0;
            v21[2](v21);
            _Block_release(v21);
          }
          if (identifier[1].level)
          {
            uint64_t v22 = *(const void **)&identifier[1].name[24];
            if (v22) {
              _Block_release(v22);
            }
          }
          free(identifier);
        }
      }
    }
  }
  else
  {
    uint64_t v6 = (void *)v5(a1[2].identifier);
  }
  if (v6) {
    int v8 = nw_path_allows_multipath(v6);
  }
  else {
LABEL_12:
  }
    int v8 = 0;
  int v9 = (int)a1[4].identifier;
  if (v9 != 1)
  {
    if (v9 != 2)
    {
      if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
      {
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v13 = gconnectionLogObj;
        BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
        if (!result) {
          return result;
        }
        int v15 = (int)a1[4].identifier;
        *(_DWORD *)unsigned int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v15;
        int v16 = "%{public}s %{public}s Data mode %d unrecognized";
        uint64_t v17 = v13;
        uint32_t v18 = 28;
        goto LABEL_73;
      }
      return 0;
    }
    if (!a1[2].callbacks)
    {
      memset(out, 0, sizeof(out));
      uuid_generate_random(out);
      if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
        dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
      }
      uint64_t v10 = (nw_protocol_callbacks *)nw_protocol_metadata_create((void *)g_tcp_definition, out);
      a1[2].callbacks = v10;
      *(void *)unsigned int buf = nw_protocol_socket_get_receive_buffer_size;
      *(void *)&uint8_t buf[8] = nw_protocol_socket_get_send_buffer_size;
      *(void *)&buf[16] = nw_protocol_socket_reset_keepalives;
      *(void *)&unsigned char buf[24] = nw_protocol_socket_set_no_delay;
      *(void *)&unsigned char buf[32] = nw_protocol_socket_set_no_push;
      uint64_t v137 = nw_protocol_socket_set_no_wake_from_sleep;
      nw_tcp_set_callbacks(v10, (uint64_t)p_output_handler, (uint64_t)buf);
    }
    int v11 = 1;
    if (!identifier) {
      goto LABEL_176;
    }
LABEL_45:
    uint64_t v23 = *(void *)&identifier->name[24];
    if (!v23) {
      goto LABEL_176;
    }
    id v24 = *(uint64_t (**)(nw_protocol_identifier *))(v23 + 128);
    if (v24)
    {
      if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
      {
        uint64_t v26 = *(void *)&identifier[2].name[8];
        if (v26) {
          *(void *)&identifier[2].name[8] = v26 + 1;
        }
        uint64_t v25 = (void *)v24(identifier);
        if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
        {
          uint64_t v37 = *(void *)&identifier[2].name[8];
          if (v37)
          {
            uint64_t v38 = v37 - 1;
            *(void *)&identifier[2].name[8] = v38;
            if (!v38)
            {
              int v39 = *(void (***)(void))&identifier[1].name[24];
              if (v39)
              {
                *(void *)&identifier[1].name[24] = 0;
                v39[2](v39);
                _Block_release(v39);
              }
              if (identifier[1].level)
              {
                __int16 v40 = *(const void **)&identifier[1].name[24];
                if (v40) {
                  _Block_release(v40);
                }
              }
              free(identifier);
            }
          }
        }
      }
      else
      {
        uint64_t v25 = (void *)v24(identifier);
      }
      uint64_t v27 = *(void *)&identifier->name[24];
      if (v27)
      {
        BOOL v28 = *(uint64_t (**)(nw_protocol_identifier *))(v27 + 136);
        if (v28)
        {
LABEL_54:
          if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
          {
            uint64_t v30 = *(void *)&identifier[2].name[8];
            if (v30) {
              *(void *)&identifier[2].name[8] = v30 + 1;
            }
            char v29 = (void *)v28(identifier);
            if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
            {
              uint64_t v41 = *(void *)&identifier[2].name[8];
              if (v41)
              {
                uint64_t v42 = v41 - 1;
                *(void *)&identifier[2].name[8] = v42;
                if (!v42)
                {
                  uint64_t v43 = *(void (***)(void))&identifier[1].name[24];
                  if (v43)
                  {
                    *(void *)&identifier[1].name[24] = 0;
                    v43[2](v43);
                    _Block_release(v43);
                  }
                  if (identifier[1].level)
                  {
                    os_log_type_t v44 = *(const void **)&identifier[1].name[24];
                    if (v44) {
                      _Block_release(v44);
                    }
                  }
                  free(identifier);
                }
              }
            }
          }
          else
          {
            char v29 = (void *)v28(identifier);
          }
          if (v29) {
            LODWORD(v29) = nw_endpoint_get_address_family(v29);
          }
          if (v25)
          {
LABEL_62:
            if (v29 == nw_endpoint_get_address_family(v25)) {
              goto LABEL_63;
            }
            if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v35 = gconnectionLogObj;
              BOOL result = os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR);
              if (!result) {
                return result;
              }
              int address_family = nw_endpoint_get_address_family(v25);
              *(_DWORD *)unsigned int buf = 136446978;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = (char *)a1 + 404;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = address_family;
              *(_WORD *)&buf[28] = 1024;
              *(_DWORD *)&buf[30] = v29;
              int v16 = "%{public}s %{public}s Local endpoint family %d does not match remote endpoint %d";
              uint64_t v17 = v35;
              uint32_t v18 = 34;
LABEL_73:
              _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_ERROR, v16, buf, v18);
              return 0;
            }
            return 0;
          }
LABEL_63:
          int v31 = *(_DWORD *)&a1[4].flow_id[12];
          if (v31 < 0) {
            goto LABEL_177;
          }
LABEL_64:
          *(_DWORD *)uuid_t out = 1;
          if (!setsockopt(v31, 0xFFFF, 4130, out, 4u)) {
            goto LABEL_108;
          }
          uint64_t v32 = p_output_handler;
          int v33 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          uint64_t v34 = gLogObj;
          if (v33 == 22)
          {
            p_output_handler = v32;
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)unsigned int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = 22;
              _os_log_impl(&dword_1830D4000, v34, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d", buf, 0x12u);
            }
            goto LABEL_108;
          }
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v33;
          int v132 = 18;
          BOOL v45 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v134 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v45, type, &v134))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v46 = gLogObj;
              os_log_type_t v47 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v33;
                char v48 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d";
LABEL_104:
                _os_log_impl(&dword_1830D4000, v46, v47, v48, buf, 0x12u);
              }
            }
            else if (v134)
            {
              os_log_type_t v49 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              os_log_type_t v46 = gLogObj;
              os_log_type_t v47 = type[0];
              BOOL v50 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
              if (v49)
              {
                if (v50)
                {
                  *(_DWORD *)unsigned int buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v33;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v49;
                  _os_log_impl(&dword_1830D4000, v46, v47, "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v49);
                goto LABEL_105;
              }
              if (v50)
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v33;
                char v48 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, no backtrace";
                goto LABEL_104;
              }
            }
            else
            {
              os_log_type_t v46 = __nwlog_obj();
              os_log_type_t v47 = type[0];
              if (os_log_type_enabled(v46, type[0]))
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v33;
                char v48 = "%{public}s setsockopt SO_NOSIGPIPE failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_104;
              }
            }
          }
LABEL_105:
          if (v45) {
            free(v45);
          }
          p_output_handler = v32;
LABEL_108:
          if ((ioctl(*(_DWORD *)&a1[4].flow_id[12], 0x8004667EuLL, out, v132) & 0x80000000) == 0)
          {
            if (uuid_is_null(a1->flow_id) || !setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4369, a1, 0x10u))
            {
LABEL_110:
              if (identifier)
              {
                uint64_t v51 = *(void *)&identifier->name[24];
                if (v51)
                {
                  os_log_type_t v52 = *(uint64_t (**)(nw_protocol_identifier *))(v51 + 112);
                  if (v52)
                  {
                    if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
                    {
                      uint64_t v62 = *(void *)&identifier[2].name[8];
                      if (v62) {
                        *(void *)&identifier[2].name[8] = v62 + 1;
                      }
                      int v53 = (void *)v52(identifier);
                      if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
                      {
                        uint64_t v71 = *(void *)&identifier[2].name[8];
                        if (v71)
                        {
                          uint64_t v72 = v71 - 1;
                          *(void *)&identifier[2].name[8] = v72;
                          if (!v72)
                          {
                            char v73 = *(void (***)(void))&identifier[1].name[24];
                            if (v73)
                            {
                              *(void *)&identifier[1].name[24] = 0;
                              v73[2](v73);
                              _Block_release(v73);
                            }
                            if (identifier[1].level)
                            {
                              uint64_t v74 = *(const void **)&identifier[1].name[24];
                              if (v74) {
                                _Block_release(v74);
                              }
                            }
                            free(identifier);
                          }
                        }
                      }
                    }
                    else
                    {
                      int v53 = (void *)v52(identifier);
                    }
                    if (v53)
                    {
                      uint64_t v63 = v53;
                      id v64 = v63[19];

                      if (v64)
                      {
                        os_log_type_t v65 = (id *)v64;
                        id v66 = v65[3];

                        os_release(v65);
                        if (v66)
                        {
                          id v67 = v66;
                          if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
                            dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
                          }
                          BOOL v68 = nw_protocol_options_matches_definition(v67, (void *)g_tcp_definition);

                          if (v68) {
                            nw_socket_set_bidirectional_tcp_sockopts((uint64_t)p_output_handler, v67);
                          }
                          os_release(v67);
                        }
                      }
                    }
                  }
                }
              }
              return 1;
            }
            int v59 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            os_log_type_t v60 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)unsigned int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
              *(_WORD *)&unsigned char buf[12] = 2080;
              *(void *)&buf[14] = (char *)a1 + 404;
              *(_WORD *)&unsigned char buf[22] = 1024;
              *(_DWORD *)&unsigned char buf[24] = v59;
              _os_log_impl(&dword_1830D4000, v60, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d", buf, 0x1Cu);
            }
            if (v59 == 2 || v59 == 22)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v61 = gLogObj;
              if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v59;
                _os_log_impl(&dword_1830D4000, v61, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d", buf, 0x12u);
              }
              goto LABEL_110;
            }
            __nwlog_obj();
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v59;
            uint64_t v75 = (char *)_os_log_send_and_compose_impl();
            type[0] = OS_LOG_TYPE_ERROR;
            os_log_type_t v134 = OS_LOG_TYPE_DEFAULT;
            if (__nwlog_fault(v75, type, &v134))
            {
              if (type[0] == OS_LOG_TYPE_FAULT)
              {
                os_log_type_t v76 = __nwlog_obj();
                os_log_type_t v77 = type[0];
                if (!os_log_type_enabled(v76, type[0])) {
                  goto LABEL_174;
                }
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v59;
                __uint64_t v78 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d";
                goto LABEL_173;
              }
              if (v134 == OS_LOG_TYPE_DEFAULT)
              {
                os_log_type_t v76 = __nwlog_obj();
                os_log_type_t v77 = type[0];
                if (!os_log_type_enabled(v76, type[0])) {
                  goto LABEL_174;
                }
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v59;
                __uint64_t v78 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_173;
              }
              int v80 = (char *)__nw_create_backtrace_string();
              os_log_type_t v76 = __nwlog_obj();
              os_log_type_t v77 = type[0];
              BOOL v81 = os_log_type_enabled(v76, type[0]);
              if (v80)
              {
                if (v81)
                {
                  *(_DWORD *)unsigned int buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v59;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v80;
                  _os_log_impl(&dword_1830D4000, v76, v77, "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v80);
                goto LABEL_174;
              }
              if (v81)
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v59;
                __uint64_t v78 = "%{public}s setsockopt SO_NECP_CLIENTUUID failed %{darwin.errno}d, no backtrace";
LABEL_173:
                _os_log_impl(&dword_1830D4000, v76, v77, v78, buf, 0x12u);
              }
            }
LABEL_174:
            if (v75) {
              free(v75);
            }
            goto LABEL_110;
          }
          uint64_t v54 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v54;
          int v55 = (char *)_os_log_send_and_compose_impl();
          type[0] = OS_LOG_TYPE_ERROR;
          os_log_type_t v134 = OS_LOG_TYPE_DEFAULT;
          if (__nwlog_fault(v55, type, &v134))
          {
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              objc_super v56 = gLogObj;
              os_log_type_t v57 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v54;
                __int16 v58 = "%{public}s FIONBIO failed %{darwin.errno}d";
LABEL_160:
                _os_log_impl(&dword_1830D4000, v56, v57, v58, buf, 0x12u);
              }
            }
            else if (v134)
            {
              os_log_type_t v69 = (char *)__nw_create_backtrace_string();
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              objc_super v56 = gLogObj;
              os_log_type_t v57 = type[0];
              BOOL v70 = os_log_type_enabled((os_log_t)gLogObj, type[0]);
              if (v69)
              {
                if (v70)
                {
                  *(_DWORD *)unsigned int buf = 136446722;
                  *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v54;
                  *(_WORD *)&buf[18] = 2082;
                  *(void *)&buf[20] = v69;
                  _os_log_impl(&dword_1830D4000, v56, v57, "%{public}s FIONBIO failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
                }
                free(v69);
                goto LABEL_161;
              }
              if (v70)
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v54;
                __int16 v58 = "%{public}s FIONBIO failed %{darwin.errno}d, no backtrace";
                goto LABEL_160;
              }
            }
            else
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              objc_super v56 = gLogObj;
              os_log_type_t v57 = type[0];
              if (os_log_type_enabled((os_log_t)gLogObj, type[0]))
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
                *(_WORD *)&unsigned char buf[12] = 1024;
                *(_DWORD *)&buf[14] = v54;
                __int16 v58 = "%{public}s FIONBIO failed %{darwin.errno}d, backtrace limit exceeded";
                goto LABEL_160;
              }
            }
          }
LABEL_161:
          if (v55) {
            free(v55);
          }
          uint64_t v79 = (uint64_t)p_output_handler;
          goto LABEL_240;
        }
      }
    }
    else
    {
      uint64_t v25 = 0;
      BOOL v28 = *(uint64_t (**)(nw_protocol_identifier *))(v23 + 136);
      if (v28) {
        goto LABEL_54;
      }
    }
    LODWORD(v29) = 0;
    if (v25) {
      goto LABEL_62;
    }
    goto LABEL_63;
  }
  if (!v8)
  {
    int v11 = 2;
    if (!identifier) {
      goto LABEL_176;
    }
    goto LABEL_45;
  }
  if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) != 0)
  {
    int v8 = 0;
    int v11 = 2;
    if (!identifier) {
      goto LABEL_176;
    }
    goto LABEL_45;
  }
  if (__nwlog_connection_log::onceToken != -1) {
    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
  }
  int v12 = gconnectionLogObj;
  int v11 = 2;
  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
  {
    *(_DWORD *)unsigned int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = (char *)a1 + 404;
    _os_log_impl(&dword_1830D4000, v12, OS_LOG_TYPE_DEBUG, "%{public}s %{public}s Multipath not supported for datagram connections", buf, 0x16u);
  }
  int v8 = 0;
  if (identifier) {
    goto LABEL_45;
  }
LABEL_176:
  LODWORD(v29) = 0;
  int v31 = *(_DWORD *)&a1[4].flow_id[12];
  if ((v31 & 0x80000000) == 0) {
    goto LABEL_64;
  }
LABEL_177:
  LOBYTE(a1[6].identifier) = (_BYTE)v29;
  if (v8)
  {
    int v82 = socket(39, v11, 0);
    *(_DWORD *)&a1[4].flow_id[12] = v82;
    if ((v82 & 0x80000000) == 0)
    {
      a1[6].flow_id[15] = (*(unsigned __int16 *)&a1[6].flow_id[13] | (a1[6].flow_id[15] << 16) | 0x20000u) >> 16;
      goto LABEL_187;
    }
    if (**(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8) != 43)
    {
LABEL_209:
      uint64_t v54 = **(unsigned int **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      os_log_type_t v95 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
      {
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&unsigned char buf[12] = 2080;
        *(_DWORD *)unsigned int buf = 136447234;
        if (v8) {
          int v96 = 39;
        }
        else {
          int v96 = (int)v29;
        }
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v96;
        *(_WORD *)&buf[28] = 1024;
        *(_DWORD *)&buf[30] = v11;
        *(_WORD *)&buf[34] = 1024;
        *(_DWORD *)&buf[36] = v54;
        _os_log_impl(&dword_1830D4000, v95, OS_LOG_TYPE_ERROR, "%{public}s %s Failed to create socket(%d,%d) %{darwin.errno}d", buf, 0x28u);
      }
      else if (v8)
      {
        int v96 = 39;
      }
      else
      {
        int v96 = (int)v29;
      }
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      *(_DWORD *)unsigned int buf = 136446978;
      *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
      *(_WORD *)&unsigned char buf[12] = 1024;
      *(_DWORD *)&buf[14] = v96;
      *(_WORD *)&buf[18] = 1024;
      *(_DWORD *)&buf[20] = v11;
      *(_WORD *)&unsigned char buf[24] = 1024;
      *(_DWORD *)&buf[26] = v54;
      os_log_type_t v97 = (char *)_os_log_send_and_compose_impl();
      out[0] = 16;
      type[0] = OS_LOG_TYPE_DEFAULT;
      if (!__nwlog_fault(v97, out, type)) {
        goto LABEL_237;
      }
      if (out[0] == 17)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v98 = gLogObj;
        os_log_type_t v99 = out[0];
        if (os_log_type_enabled((os_log_t)gLogObj, (os_log_type_t)out[0]))
        {
          *(_DWORD *)unsigned int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v96;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v11;
          *(_WORD *)&unsigned char buf[24] = 1024;
          *(_DWORD *)&buf[26] = v54;
          int v100 = "%{public}s Failed to create socket(%d,%d) %{darwin.errno}d";
LABEL_236:
          _os_log_impl(&dword_1830D4000, v98, v99, v100, buf, 0x1Eu);
        }
      }
      else if (type[0])
      {
        BOOL v101 = (char *)__nw_create_backtrace_string();
        os_log_type_t v98 = __nwlog_obj();
        os_log_type_t v99 = out[0];
        BOOL v102 = os_log_type_enabled(v98, (os_log_type_t)out[0]);
        if (v101)
        {
          if (v102)
          {
            *(_DWORD *)unsigned int buf = 136447234;
            *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v96;
            *(_WORD *)&buf[18] = 1024;
            *(_DWORD *)&buf[20] = v11;
            *(_WORD *)&unsigned char buf[24] = 1024;
            *(_DWORD *)&buf[26] = v54;
            *(_WORD *)&buf[30] = 2082;
            *(void *)&unsigned char buf[32] = v101;
            _os_log_impl(&dword_1830D4000, v98, v99, "%{public}s Failed to create socket(%d,%d) %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x28u);
          }
          free(v101);
          goto LABEL_237;
        }
        if (v102)
        {
          *(_DWORD *)unsigned int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v96;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v11;
          *(_WORD *)&unsigned char buf[24] = 1024;
          *(_DWORD *)&buf[26] = v54;
          int v100 = "%{public}s Failed to create socket(%d,%d) %{darwin.errno}d, no backtrace";
          goto LABEL_236;
        }
      }
      else
      {
        os_log_type_t v98 = __nwlog_obj();
        os_log_type_t v99 = out[0];
        if (os_log_type_enabled(v98, (os_log_type_t)out[0]))
        {
          *(_DWORD *)unsigned int buf = 136446978;
          *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v96;
          *(_WORD *)&buf[18] = 1024;
          *(_DWORD *)&buf[20] = v11;
          *(_WORD *)&unsigned char buf[24] = 1024;
          *(_DWORD *)&buf[26] = v54;
          int v100 = "%{public}s Failed to create socket(%d,%d) %{darwin.errno}d, backtrace limit exceeded";
          goto LABEL_236;
        }
      }
LABEL_237:
      if (v97) {
        free(v97);
      }
      uint64_t v79 = (uint64_t)p_output_handler;
LABEL_240:
      nw_socket_internal_error(v79, v54);
      return 0;
    }
    if ((*(_WORD *)&a1[6].flow_id[13] & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint32_t v83 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        _os_log_impl(&dword_1830D4000, v83, OS_LOG_TYPE_DEFAULT, "%{public}s %{public}s The kernel does not support MPTCP, using regular TCP", buf, 0x16u);
      }
    }
  }
  int v82 = socket((int)v29, v11, 0);
  *(_DWORD *)&a1[4].flow_id[12] = v82;
  if (v82 < 0) {
    goto LABEL_209;
  }
LABEL_187:
  BOOL v84 = (nw_protocol *)nw_fd_wrapper_create(v82);
  char handle = (char)a1[2].handle;
  if (handle)
  {
    output_handler = a1[2].output_handler;
    if (output_handler)
    {
      os_release(output_handler);
      char handle = (char)a1[2].handle;
    }
  }
  a1[2].output_handler = v84;
  LOBYTE(a1[2].handle) = handle | 1;
  if (nw_socket_set_common_sockopts(a1))
  {
    BOOL v87 = &a1[6].flow_id[13];
    if ((*(_WORD *)&a1[6].flow_id[13] & 0x100) == 0) {
      goto LABEL_253;
    }
    memset(type, 0, sizeof(type));
    nw_protocol_get_flow_id(a1, type);
    char v139 = -106;
    *(_OWORD *)uuid_t out = *(_OWORD *)type;
    if ((*(_WORD *)v87 & 0x80) == 0)
    {
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      uint64_t v88 = gconnectionLogObj;
      if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_INFO))
      {
        *(_DWORD *)unsigned int buf = 136446978;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&unsigned char buf[22] = 1042;
        *(_DWORD *)&unsigned char buf[24] = 16;
        *(_WORD *)&buf[28] = 2098;
        *(void *)&buf[30] = type;
        _os_log_impl(&dword_1830D4000, v88, OS_LOG_TYPE_INFO, "%{public}s %{public}s Setting UUID %{public,uuid_t}.16P for multilayer packet logging", buf, 0x26u);
      }
    }
    if (!setsockopt(*(_DWORD *)&a1[4].flow_id[12], 0xFFFF, 4386, out, 0x11u))
    {
      if (!identifier) {
        goto LABEL_306;
      }
      uint64_t v109 = *(void *)&identifier->name[24];
      if (!v109) {
        goto LABEL_306;
      }
      char v110 = *(uint64_t (**)(nw_protocol_identifier *))(v109 + 112);
      if (!v110) {
        goto LABEL_306;
      }
LABEL_253:
      if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
      {
        uint64_t v112 = *(void *)&identifier[2].name[8];
        if (v112) {
          *(void *)&identifier[2].name[8] = v112 + 1;
        }
        char v111 = (void *)v110(identifier);
        if (*(_UNKNOWN **)identifier[1].name == &nw_protocol_ref_counted_handle)
        {
          uint64_t v122 = *(void *)&identifier[2].name[8];
          if (v122)
          {
            uint64_t v123 = v122 - 1;
            *(void *)&identifier[2].name[8] = v123;
            if (!v123)
            {
              int v124 = *(void (***)(void))&identifier[1].name[24];
              if (v124)
              {
                *(void *)&identifier[1].name[24] = 0;
                v124[2](v124);
                _Block_release(v124);
              }
              if (identifier[1].level)
              {
                unsigned int v125 = *(const void **)&identifier[1].name[24];
                if (v125) {
                  _Block_release(v125);
                }
              }
              free(identifier);
            }
          }
        }
      }
      else
      {
        char v111 = (void *)v110(identifier);
      }
      if (v111
        && (v113 = v111, BOOL v114 = (*(_WORD *)(v113[13] + 100) & 0x10) == 0, v113, v114))
      {
        if ((nw_fd_wrapper_guard(a1[2].output_handler) & 1) != 0 || (*(_WORD *)v87 & 0x80) != 0) {
          return 1;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v115 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
          return 1;
        }
        int v116 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)unsigned int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v116;
        BOOL v117 = "%{public}s %{public}s Failed to guard socket fd %d";
        uint64_t v118 = v115;
        os_log_type_t v119 = OS_LOG_TYPE_ERROR;
      }
      else
      {
LABEL_306:
        if ((*(_WORD *)v87 & 0x80) != 0) {
          return 1;
        }
        if (__nwlog_connection_log::onceToken != -1) {
          dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
        }
        uint64_t v120 = gconnectionLogObj;
        if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEFAULT)) {
          return 1;
        }
        int v121 = *(_DWORD *)&a1[4].flow_id[12];
        *(_DWORD *)unsigned int buf = 136446722;
        *(void *)&uint8_t buf[4] = "nw_socket_initialize_socket";
        *(_WORD *)&unsigned char buf[12] = 2082;
        *(void *)&buf[14] = (char *)a1 + 404;
        *(_WORD *)&unsigned char buf[22] = 1024;
        *(_DWORD *)&unsigned char buf[24] = v121;
        BOOL v117 = "%{public}s %{public}s Not guarding fd %d";
        uint64_t v118 = v120;
        os_log_type_t v119 = OS_LOG_TYPE_DEFAULT;
      }
      _os_log_impl(&dword_1830D4000, v118, v119, v117, buf, 0x1Cu);
      return 1;
    }
    int v89 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint32_t v90 = gconnectionLogObj;
    if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
    {
      *(_DWORD *)unsigned int buf = 136446722;
      *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
      *(_WORD *)&unsigned char buf[12] = 2080;
      *(void *)&buf[14] = (char *)a1 + 404;
      *(_WORD *)&unsigned char buf[22] = 1024;
      *(_DWORD *)&unsigned char buf[24] = v89;
      _os_log_impl(&dword_1830D4000, v90, OS_LOG_TYPE_ERROR, "%{public}s %s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d", buf, 0x1Cu);
    }
    os_log_type_t v91 = __nwlog_obj();
    int v92 = v91;
    if (v89 == 22)
    {
      if (os_log_type_enabled(v91, OS_LOG_TYPE_ERROR))
      {
        *(_DWORD *)unsigned int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = 22;
        _os_log_impl(&dword_1830D4000, v92, OS_LOG_TYPE_ERROR, "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d", buf, 0x12u);
      }
      goto LABEL_253;
    }
    *(_DWORD *)unsigned int buf = 136446466;
    *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
    *(_WORD *)&unsigned char buf[12] = 1024;
    *(_DWORD *)&buf[14] = v89;
    int v103 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t v134 = OS_LOG_TYPE_ERROR;
    char v133 = 0;
    if (__nwlog_fault(v103, &v134, &v133))
    {
      if (v134 == OS_LOG_TYPE_FAULT)
      {
        __int16 v104 = __nwlog_obj();
        os_log_type_t v105 = v134;
        if (!os_log_type_enabled(v104, v134)) {
          goto LABEL_251;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v89;
        int v106 = "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d";
        goto LABEL_250;
      }
      if (!v133)
      {
        __int16 v104 = __nwlog_obj();
        os_log_type_t v105 = v134;
        if (!os_log_type_enabled(v104, v134)) {
          goto LABEL_251;
        }
        *(_DWORD *)unsigned int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v89;
        int v106 = "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d, backtrace limit exceeded";
        goto LABEL_250;
      }
      uint64_t v107 = (char *)__nw_create_backtrace_string();
      __int16 v104 = __nwlog_obj();
      os_log_type_t v105 = v134;
      BOOL v108 = os_log_type_enabled(v104, v134);
      if (v107)
      {
        if (v108)
        {
          *(_DWORD *)unsigned int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v89;
          *(_WORD *)&buf[18] = 2082;
          *(void *)&buf[20] = v107;
          _os_log_impl(&dword_1830D4000, v104, v105, "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x1Cu);
        }
        free(v107);
        goto LABEL_251;
      }
      if (v108)
      {
        *(_DWORD *)unsigned int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_socket_set_mpkl_uuid";
        *(_WORD *)&unsigned char buf[12] = 1024;
        *(_DWORD *)&buf[14] = v89;
        int v106 = "%{public}s setsockopt SCM_MPKL_SEND_INFO failed %{darwin.errno}d, no backtrace";
LABEL_250:
        _os_log_impl(&dword_1830D4000, v104, v105, v106, buf, 0x12u);
      }
    }
LABEL_251:
    if (v103) {
      free(v103);
    }
    goto LABEL_253;
  }
  char v93 = (char)a1[2].handle;
  if (v93)
  {
    BOOL v94 = a1[2].output_handler;
    if (v94)
    {
      os_release(v94);
      char v93 = (char)a1[2].handle;
    }
  }
  BOOL result = 0;
  a1[2].output_handler = 0;
  LOBYTE(a1[2].handle) = v93 | 1;
  *(_DWORD *)&a1[4].flow_id[12] = -1;
  return result;
}

void sub_1831E1834(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

nw_endpoint_t nw_flow_get_local(nw_protocol *a1)
{
  uint64_t v28 = *MEMORY[0x1E4F143B8];
  id v1 = *((id *)a1->handle + 20);
  uint64_t v2 = v1;
  if (!v1)
  {
    int v12 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v23 = "nw_flow_get_local";
    uint64_t v13 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (__nwlog_fault(v13, &type, &v20))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v14 = __nwlog_obj();
        os_log_type_t v15 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v23 = "nw_flow_get_local";
          _os_log_impl(&dword_1830D4000, v14, v15, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v20)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v14 = __nwlog_obj();
        os_log_type_t v17 = type;
        BOOL v18 = os_log_type_enabled(v14, type);
        if (backtrace_string)
        {
          if (v18)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v23 = "nw_flow_get_local";
            __int16 v24 = 2082;
            uint64_t v25 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_36;
        }
        if (v18)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v23 = "nw_flow_get_local";
          _os_log_impl(&dword_1830D4000, v14, v17, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v14 = __nwlog_obj();
        os_log_type_t v19 = type;
        if (os_log_type_enabled(v14, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v23 = "nw_flow_get_local";
          _os_log_impl(&dword_1830D4000, v14, v19, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_36:
    if (v13) {
      free(v13);
    }
    goto LABEL_13;
  }
  uint64_t v3 = (NWConcrete_nw_endpoint_handler *)v1;
  uint64_t mode = v3->mode;

  if (mode != 2)
  {
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    uint64_t v7 = (id)gLogObj;
    if (os_log_type_enabled(v7, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5) {
        int v8 = "unknown-mode";
      }
      else {
        int v8 = off_1E523FB08[mode];
      }
      *(_DWORD *)unsigned int buf = 136446722;
      uint64_t v23 = "nw_flow_get_local";
      __int16 v24 = 2082;
      uint64_t v25 = (void *)v8;
      __int16 v26 = 2082;
      uint64_t v27 = "flow";
      _os_log_impl(&dword_1830D4000, v7, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }

LABEL_13:
    nw_endpoint_t v6 = 0;
    goto LABEL_17;
  }
  uint64_t v5 = nw_endpoint_handler_copy_flow(v3);
  if (*((void *)v5 + 120))
  {
    nw_endpoint_t v6 = 0;
  }
  else
  {
    int v9 = nw_endpoint_flow_copy_path(v3);
    uint64_t v10 = v9;
    if (v9) {
      nw_endpoint_t v6 = nw_path_copy_effective_local_endpoint(v9);
    }
    else {
      nw_endpoint_t v6 = 0;
    }
  }
LABEL_17:

  return v6;
}

void sub_1831E1C10(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id nw_connection_copy_connected_local_endpoint(void *a1)
{
  uint64_t v22 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    *(void *)unsigned int buf = 0;
    *(void *)&uint8_t buf[8] = buf;
    *(void *)&buf[16] = 0x3032000000;
    os_log_type_t v19 = __Block_byref_object_copy__24353;
    char v20 = __Block_byref_object_dispose__24354;
    id v21 = 0;
    v13[0] = MEMORY[0x1E4F143A8];
    v13[1] = 3221225472;
    v13[2] = __nw_connection_copy_connected_local_endpoint_block_invoke;
    v13[3] = &unk_1E524B978;
    int v14 = v1;
    os_log_type_t v15 = buf;
    os_unfair_lock_lock(v2 + 34);
    __nw_connection_copy_connected_local_endpoint_block_invoke((uint64_t)v13);
    os_unfair_lock_unlock(v2 + 34);
    id v3 = *(id *)(*(void *)&buf[8] + 40);

    _Block_object_dispose(buf, 8);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v16 = 0;
  if (__nwlog_fault(v6, &type, &v16))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v16)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_connection_copy_connected_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  id v3 = 0;
LABEL_3:

  return v3;
}

void __nw_connection_copy_connected_local_endpoint_block_invoke(uint64_t a1)
{
  uint64_t v20 = *MEMORY[0x1E4F143B8];
  uint64_t v2 = *(void *)(a1 + 32);
  if ((*(unsigned char *)(v2 + 109) & 0x40) != 0)
  {
    nw_endpoint_t v6 = nw_endpoint_handler_copy_connected_path(*(void **)(v2 + 144));
    uint64_t v4 = v6;
    if (v6)
    {
      nw_endpoint_t v7 = nw_path_copy_effective_local_endpoint(v6);
      uint64_t v8 = *(void *)(*(void *)(a1 + 40) + 8);
      int v9 = *(void **)(v8 + 40);
      *(void *)(v8 + 40) = v7;

      if (*(void *)(*(void *)(*(void *)(a1 + 40) + 8) + 40)) {
        goto LABEL_24;
      }
      uint64_t v10 = *(void *)(*(void *)(a1 + 32) + 16);
      if (!v10 || nw_path_parameters_get_logging_disabled(*(void *)(v10 + 104))) {
        goto LABEL_24;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR)) {
        goto LABEL_23;
      }
      int v12 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_local_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v12;
      uint64_t v13 = "%{public}s [C%u] Connection has no local endpoint";
    }
    else
    {
      uint64_t v14 = *(void *)(*(void *)(a1 + 32) + 16);
      if (!v14 || nw_path_parameters_get_logging_disabled(*(void *)(v14 + 104)))
      {
        uint64_t v4 = 0;
        goto LABEL_24;
      }
      if (__nwlog_connection_log::onceToken != -1) {
        dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
      }
      BOOL v11 = (id)gconnectionLogObj;
      if (!os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
      {
LABEL_23:

LABEL_24:
        return;
      }
      int v15 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_local_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v15;
      uint64_t v13 = "%{public}s [C%u] Connection has no connected path";
    }
    _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, v13, (uint8_t *)&v16, 0x12u);
    goto LABEL_23;
  }
  uint64_t v3 = *(void *)(v2 + 16);
  if (v3 && !nw_path_parameters_get_logging_disabled(*(void *)(v3 + 104)))
  {
    if (__nwlog_connection_log::onceToken != -1) {
      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
    }
    uint64_t v4 = (id)gconnectionLogObj;
    if (os_log_type_enabled(v4, OS_LOG_TYPE_ERROR))
    {
      int v5 = *(_DWORD *)(*(void *)(a1 + 32) + 448);
      int v16 = 136446466;
      os_log_type_t v17 = "nw_connection_copy_connected_local_endpoint_block_invoke";
      __int16 v18 = 1024;
      int v19 = v5;
      _os_log_impl(&dword_1830D4000, v4, OS_LOG_TYPE_ERROR, "%{public}s [C%u] Client called nw_connection_copy_connected_local_endpoint on unconnected nw_connection", (uint8_t *)&v16, 0x12u);
    }
    goto LABEL_24;
  }
}

nw_endpoint_t nw_path_copy_effective_local_endpoint(nw_path_t path)
{
  uint64_t v25 = *MEMORY[0x1E4F143B8];
  nw_path_t v1 = path;
  uint64_t v2 = (nw_parameters_t *)v1;
  if (v1)
  {
    Class isa = v1[10].isa;
    if (isa)
    {
      nw_endpoint_t v4 = isa;
LABEL_11:
      int v9 = v4;
      goto LABEL_12;
    }
    uint64_t v5 = (uint64_t)v1[9].isa;
    if (v5 && *(void *)(v5 + 24) != *(void *)(v5 + 16))
    {
      nw_endpoint_t v6 = nw_array_get_object_at_index(v5, 0);
      nw_endpoint_t v7 = v6;
      if (v6)
      {
        uint64_t v8 = (void *)v6[4];
        if (v8)
        {
          int v9 = v8;

          goto LABEL_12;
        }
      }
    }
    nw_endpoint_t v4 = nw_parameters_copy_local_endpoint(v2[2]);
    goto LABEL_11;
  }
  BOOL v11 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v22 = "nw_path_copy_effective_local_endpoint";
  int v12 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v19 = 0;
  if (__nwlog_fault(v12, &type, &v19))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v14 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v22 = "nw_path_copy_effective_local_endpoint";
        _os_log_impl(&dword_1830D4000, v13, v14, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v19)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v16 = type;
      BOOL v17 = os_log_type_enabled(v13, type);
      if (backtrace_string)
      {
        if (v17)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v22 = "nw_path_copy_effective_local_endpoint";
          __int16 v23 = 2082;
          __int16 v24 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_29;
      }
      if (v17)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v22 = "nw_path_copy_effective_local_endpoint";
        _os_log_impl(&dword_1830D4000, v13, v16, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v13 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v13, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v22 = "nw_path_copy_effective_local_endpoint";
        _os_log_impl(&dword_1830D4000, v13, v18, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_29:
  if (v12) {
    free(v12);
  }
  int v9 = 0;
LABEL_12:

  return v9;
}

nw_endpoint_t nw_parameters_copy_local_endpoint(nw_parameters_t parameters)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  nw_parameters_t v1 = parameters;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((id *)v1[13].isa + 20);
    goto LABEL_3;
  }
  uint64_t v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v16 = "nw_parameters_copy_local_endpoint";
  nw_endpoint_t v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v16 = "nw_parameters_copy_local_endpoint";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_parameters_copy_local_endpoint";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

id *nw_protocol_metadata_create(void *a1, _OWORD *a2)
{
  uint64_t v3 = a1;
  uint64_t v4 = v3[10];
  if (v4) {
    size_t v5 = *(unsigned int *)(v4 + 260);
  }
  else {
    size_t v5 = 0;
  }
  nw_endpoint_t v6 = (objc_class *)objc_opt_class();
  Instance = (id *)class_createInstance(v6, v5);
  os_log_type_t v8 = -[NWConcrete_nw_protocol_metadata initWithDefinition:identifier:](Instance, v3, a2);

  return v8;
}

void sub_1831E284C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

id *nw_protocol_metadata_create_singleton(void *a1)
{
  uint64_t v10 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  os_unfair_lock_lock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  if (uuid_is_null((const unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid)) {
    goto LABEL_6;
  }
  if ((void)nw_uuid_generate_insecure(unsigned char *)::last_used_uuid != -1)
  {
    *(void *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid
                                                                           + 1;
    goto LABEL_7;
  }
  if (*((void *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1) == -1)
  {
LABEL_6:
    uuid_generate_random((unsigned __int8 *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid);
    BYTE9(nw_uuid_generate_insecure(unsigned char *)::last_used_uuid) = -1;
  }
  else
  {
    ++*((void *)&nw_uuid_generate_insecure(unsigned char *)::last_used_uuid + 1);
  }
LABEL_7:
  long long v9 = nw_uuid_generate_insecure(unsigned char *)::last_used_uuid;
  os_unfair_lock_unlock((os_unfair_lock_t)&nw_uuid_generate_insecure(unsigned char *)::uuid_lock);
  nw_parameters_t v2 = v1;
  uint64_t v3 = v2[10];
  if (v3) {
    size_t v4 = *(unsigned int *)(v3 + 260);
  }
  else {
    size_t v4 = 0;
  }
  size_t v5 = (objc_class *)objc_opt_class();
  Instance = (id *)class_createInstance(v5, v4);
  nw_endpoint_t v7 = -[NWConcrete_nw_protocol_metadata initWithDefinition:identifier:](Instance, v2, &v9);

  return v7;
}

void sub_1831E29A0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1831E2EF0(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double nw_quic_stream_initialize_metadata(uint64_t a1, _OWORD *a2)
{
  double result = 0.0;
  a2[1] = 0u;
  a2[2] = 0u;
  *a2 = 0u;
  *((void *)a2 + 2) = -1;
  return result;
}

BOOL nw_tcp_allocate_metadata(void *a1)
{
  id v1 = a1;
  nw_parameters_t v2 = malloc_type_calloc(1uLL, 0x40uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  size_t v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  size_t v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:
    v2[2] = 0u;
    v2[3] = 0u;
    _OWORD *v2 = 0u;
    v2[1] = 0u;

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_1831E3064(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

double nw_quic_connection_initialize_metadata(uint64_t a1, uint64_t a2)
{
  *(void *)(a2 + 216) = 0;
  double result = 0.0;
  *(_OWORD *)(a2 + 200) = 0u;
  *(_OWORD *)(a2 + 184) = 0u;
  *(_OWORD *)(a2 + 168) = 0u;
  *(_OWORD *)(a2 + 152) = 0u;
  *(_OWORD *)(a2 + 136) = 0u;
  *(_OWORD *)(a2 + 120) = 0u;
  *(_OWORD *)(a2 + 104) = 0u;
  *(_OWORD *)(a2 + 88) = 0u;
  *(_OWORD *)(a2 + 72) = 0u;
  *(_OWORD *)(a2 + 56) = 0u;
  *(_OWORD *)(a2 + 40) = 0u;
  *(_OWORD *)(a2 + 24) = 0u;
  *(_OWORD *)(a2 + 8) = 0u;
  *(void *)a2 = -1;
  return result;
}

uint64_t nw_fd_wrapper_guard(void *a1)
{
  uint64_t v40 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    __int16 v24 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v35 = "nw_fd_wrapper_guard";
    uint64_t v25 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v25, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v26 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v35 = "nw_fd_wrapper_guard";
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null wrapper", buf, 0xCu);
        }
      }
      else if (v32)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v26 = __nwlog_obj();
        os_log_type_t v29 = type;
        BOOL v30 = os_log_type_enabled(v26, type);
        if (backtrace_string)
        {
          if (v30)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            uint64_t v35 = "nw_fd_wrapper_guard";
            __int16 v36 = 2082;
            *(void *)uint64_t v37 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null wrapper, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v30)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v35 = "nw_fd_wrapper_guard";
          _os_log_impl(&dword_1830D4000, v26, v29, "%{public}s called with null wrapper, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v26 = __nwlog_obj();
        os_log_type_t v31 = type;
        if (os_log_type_enabled(v26, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          uint64_t v35 = "nw_fd_wrapper_guard";
          _os_log_impl(&dword_1830D4000, v26, v31, "%{public}s called with null wrapper, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_47:
    if (v25) {
      free(v25);
    }
    uint64_t v13 = 0;
    goto LABEL_18;
  }
  os_unfair_lock_lock(v1 + 3);
  if ((v2[2]._os_unfair_lock_opaque & 0x80000000) == 0)
  {
    char os_unfair_lock_opaque = v2[6]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 3) != 0)
    {
LABEL_17:
      uint64_t v13 = os_unfair_lock_opaque & 1;
      os_unfair_lock_unlock(v2 + 3);
      goto LABEL_18;
    }
    if (!change_fdguard_np())
    {
      char os_unfair_lock_opaque = LOBYTE(v2[6]._os_unfair_lock_opaque) | 1;
      LOBYTE(v2[6]._os_unfair_lock_opaque) = os_unfair_lock_opaque;
      goto LABEL_17;
    }
    int v4 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v5 = (id)gLogObj;
    uint32_t v6 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)unsigned int buf = 136446722;
    uint64_t v35 = "nw_fd_wrapper_guard";
    __int16 v36 = 1024;
    *(_DWORD *)uint64_t v37 = v6;
    *(_WORD *)&v37[4] = 1024;
    *(_DWORD *)&v37[6] = v4;
    nw_endpoint_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v32 = 0;
    if (__nwlog_fault(v7, &type, &v32))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v9 = type;
        if (os_log_type_enabled(v8, type))
        {
          uint32_t v10 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v35 = "nw_fd_wrapper_guard";
          __int16 v36 = 1024;
          *(_DWORD *)uint64_t v37 = v10;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s Failed to guard fd %d %{darwin.errno}d", buf, 0x18u);
        }
      }
      else if (v32)
      {
        int v15 = __nw_create_backtrace_string();
        if (v15)
        {
          os_log_type_t v16 = (char *)v15;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v17 = (id)gLogObj;
          os_log_type_t v18 = type;
          if (os_log_type_enabled(v17, type))
          {
            uint32_t v19 = v2[2]._os_unfair_lock_opaque;
            *(_DWORD *)unsigned int buf = 136446978;
            uint64_t v35 = "nw_fd_wrapper_guard";
            __int16 v36 = 1024;
            *(_DWORD *)uint64_t v37 = v19;
            *(_WORD *)&v37[4] = 1024;
            *(_DWORD *)&v37[6] = v4;
            __int16 v38 = 2082;
            int v39 = v16;
            _os_log_impl(&dword_1830D4000, v17, v18, "%{public}s Failed to guard fd %d %{darwin.errno}d, dumping backtrace:%{public}s", buf, 0x22u);
          }

          free(v16);
          if (!v7) {
            goto LABEL_12;
          }
          goto LABEL_11;
        }
        os_log_type_t v8 = __nwlog_obj();
        os_log_type_t v22 = type;
        if (os_log_type_enabled(v8, type))
        {
          uint32_t v23 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v35 = "nw_fd_wrapper_guard";
          __int16 v36 = 1024;
          *(_DWORD *)uint64_t v37 = v23;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_1830D4000, v8, v22, "%{public}s Failed to guard fd %d %{darwin.errno}d, no backtrace", buf, 0x18u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        os_log_type_t v8 = (id)gLogObj;
        os_log_type_t v20 = type;
        if (os_log_type_enabled(v8, type))
        {
          uint32_t v21 = v2[2]._os_unfair_lock_opaque;
          *(_DWORD *)unsigned int buf = 136446722;
          uint64_t v35 = "nw_fd_wrapper_guard";
          __int16 v36 = 1024;
          *(_DWORD *)uint64_t v37 = v21;
          *(_WORD *)&v37[4] = 1024;
          *(_DWORD *)&v37[6] = v4;
          _os_log_impl(&dword_1830D4000, v8, v20, "%{public}s Failed to guard fd %d %{darwin.errno}d, backtrace limit exceeded", buf, 0x18u);
        }
      }
    }
    if (!v7)
    {
LABEL_12:
      char os_unfair_lock_opaque = v2[6]._os_unfair_lock_opaque;
      goto LABEL_17;
    }
LABEL_11:
    free(v7);
    goto LABEL_12;
  }
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v11 = (id)gLogObj;
  if (os_log_type_enabled(v11, OS_LOG_TYPE_ERROR))
  {
    uint32_t v12 = v2[2]._os_unfair_lock_opaque;
    *(_DWORD *)unsigned int buf = 136446466;
    uint64_t v35 = "nw_fd_wrapper_guard";
    __int16 v36 = 1024;
    *(_DWORD *)uint64_t v37 = v12;
    _os_log_impl(&dword_1830D4000, v11, OS_LOG_TYPE_ERROR, "%{public}s Cannot guard invalid fd %d", buf, 0x12u);
  }

  os_unfair_lock_unlock(v2 + 3);
  uint64_t v13 = 0;
LABEL_18:

  return v13;
}

void sub_1831E3768(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void __tcp_connection_start_block_invoke(uint64_t a1, unsigned int a2, void *a3)
{
  uint64_t v80 = *MEMORY[0x1E4F143B8];
  id v6 = a3;
  os_unfair_lock_lock((os_unfair_lock_t)(*(void *)(a1 + 32) + 120));
  uint64_t v7 = *(void *)(a1 + 32);
  if (*(unsigned __int8 *)(v7 + 156) != 255)
  {
    switch(a2)
    {
      case 1u:
        int v8 = 0;
        int v9 = (*(unsigned __int8 *)(v7 + 159) << 29 >> 31) & 7;
        if (v6) {
          goto LABEL_29;
        }
        goto LABEL_30;
      case 2u:
        id v10 = (id)v7;
        BOOL v11 = *((void *)v10 + 10);
        if (v11)
        {
          dispatch_source_cancel(v11);
          uint32_t v12 = (void *)*((void *)v10 + 10);
          *((void *)v10 + 10) = 0;
        }
        if ((*((unsigned char *)v10 + 158) & 0x40) == 0) {
          goto LABEL_84;
        }
        dispatch_source_t v13 = dispatch_source_create(MEMORY[0x1E4F14490], 0, 0, *((dispatch_queue_t *)v10 + 7));
        os_log_type_t v14 = (void *)*((void *)v10 + 10);
        *((void *)v10 + 10) = v13;

        int v15 = *((void *)v10 + 10);
        if (v15)
        {
          *(void *)handler = MEMORY[0x1E4F143A8];
          *(void *)&handler[8] = 3221225472;
          *(void *)&handler[16] = __tcp_connection_start_attempt_timer_locked_block_invoke;
          char v73 = (char *)&unk_1E524BAA8;
          os_log_type_t v16 = v10;
          *(void *)uint64_t v74 = v16;
          dispatch_source_set_event_handler(v15, handler);
          if (v16[13]) {
            unint64_t v17 = v16[13];
          }
          else {
            unint64_t v17 = 180000000000;
          }
          os_log_type_t v18 = *((void *)v10 + 10);
          dispatch_time_t v19 = dispatch_time(0, v17);
          dispatch_source_set_timer(v18, v19, 0xFFFFFFFFFFFFFFFFLL, 0xF4240uLL);
          dispatch_resume(*((dispatch_object_t *)v10 + 10));
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          os_log_type_t v20 = (id)gLogObj;
          if (os_log_type_enabled(v20, OS_LOG_TYPE_DEBUG))
          {
            uint64_t v21 = v16[12];
            *(_DWORD *)unsigned int buf = 136446722;
            *(void *)&uint8_t buf[4] = "tcp_connection_start_attempt_timer_locked";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = v21;
            *(_WORD *)&unsigned char buf[22] = 2048;
            unint64_t v78 = v17 / 0x3B9ACA00;
            _os_log_impl(&dword_1830D4000, v20, OS_LOG_TYPE_DEBUG, "%{public}s %llu scheduling connection attempt timer for %llus", buf, 0x20u);
          }

          goto LABEL_84;
        }
        os_log_type_t v57 = __nwlog_obj();
        *(_DWORD *)handler = 136446210;
        *(void *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
        __int16 v58 = (char *)_os_log_send_and_compose_impl();

        buf[0] = 16;
        LOBYTE(v67) = 0;
        if (!__nwlog_fault(v58, buf, &v67)) {
          goto LABEL_82;
        }
        if (buf[0] == 17)
        {
          int v59 = __nwlog_obj();
          os_log_type_t v60 = buf[0];
          if (os_log_type_enabled(v59, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_1830D4000, v59, v60, "%{public}s dispatch_source_create failed", handler, 0xCu);
          }
        }
        else if ((_BYTE)v67)
        {
          backtrace_string = (char *)__nw_create_backtrace_string();
          int v59 = __nwlog_obj();
          os_log_type_t v62 = buf[0];
          BOOL v63 = os_log_type_enabled(v59, (os_log_type_t)buf[0]);
          if (backtrace_string)
          {
            if (v63)
            {
              *(_DWORD *)handler = 136446466;
              *(void *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
              *(_WORD *)&handler[12] = 2082;
              *(void *)&handler[14] = backtrace_string;
              _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s dispatch_source_create failed, dumping backtrace:%{public}s", handler, 0x16u);
            }

            free(backtrace_string);
            goto LABEL_82;
          }
          if (v63)
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_1830D4000, v59, v62, "%{public}s dispatch_source_create failed, no backtrace", handler, 0xCu);
          }
        }
        else
        {
          int v59 = __nwlog_obj();
          os_log_type_t v64 = buf[0];
          if (os_log_type_enabled(v59, (os_log_type_t)buf[0]))
          {
            *(_DWORD *)handler = 136446210;
            *(void *)&handler[4] = "tcp_connection_start_attempt_timer_locked";
            _os_log_impl(&dword_1830D4000, v59, v64, "%{public}s dispatch_source_create failed, backtrace limit exceeded", handler, 0xCu);
          }
        }

LABEL_82:
        if (v58) {
          free(v58);
        }
LABEL_84:

        int v8 = 0;
        int v9 = 0;
        *(unsigned char *)(*(void *)(a1 + 32) + 159) |= 4u;
        if (v6) {
          goto LABEL_29;
        }
        goto LABEL_30;
      case 3u:
        BOOL v22 = nw_connection_used_tls(*(void **)(v7 + 16));
        uint64_t v23 = *(void *)(a1 + 32);
        uint64_t v25 = (unsigned char *)(v23 + 159);
        int v24 = *(unsigned __int8 *)(v23 + 159);
        if ((~v24 & 3) == 0)
        {
          int v8 = 0;
          int v9 = 0;
          goto LABEL_28;
        }
        int v8 = 0;
        if (v24 & v22)
        {
          int v9 = 8;
        }
        else
        {
          unsigned char *v25 = v24 | 1;
          uint64_t v23 = *(void *)(a1 + 32);
          int v9 = 1;
          if ((v24 & 1) != 0 || !v22)
          {
LABEL_28:
            *(_DWORD *)(v23 + 112) = 0;
            objc_storeStrong((id *)(*(void *)(a1 + 32) + 24), a3);
            *(void *)(*(void *)(a1 + 32) + 128) = tcp_connection_quality_from_path(*(void **)(a1 + 32), *(void **)(*(void *)(a1 + 32) + 32));
            __int16 v26 = (void **)*(id *)(a1 + 32);
            uint64_t v28 = v26 + 2;
            os_log_type_t v27 = v26[2];
            *(void *)handler = MEMORY[0x1E4F143A8];
            *(void *)&handler[8] = 3221225472;
            *(void *)&handler[16] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke;
            char v73 = (char *)&unk_1E524BAA8;
            os_log_type_t v29 = v26;
            *(void *)uint64_t v74 = v29;
            nw_connection_set_read_close_handler(v27, handler);
            BOOL v30 = *v28;
            *(void *)unsigned int buf = MEMORY[0x1E4F143A8];
            *(void *)&uint8_t buf[8] = 3221225472;
            *(void *)&buf[16] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_2;
            unint64_t v78 = (unint64_t)&unk_1E524BAA8;
            os_log_type_t v31 = v29;
            uint64_t v79 = v31;
            nw_connection_set_write_close_handler(v30, buf);
            char v32 = *v28;
            id v67 = (void *)MEMORY[0x1E4F143A8];
            uint64_t v68 = 3221225472;
            os_log_type_t v69 = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_3;
            BOOL v70 = &unk_1E523FCB0;
            int v33 = v31;
            uint64_t v71 = v33;
            nw_connection_set_viability_changed_handler(v32, &v67);
            uint64_t v34 = *v28;
            v65[0] = MEMORY[0x1E4F143A8];
            v65[1] = 3221225472;
            v65[2] = __tcp_connection_set_nw_connection_callbacks_on_connected_block_invoke_4;
            v65[3] = &unk_1E523FCB0;
            id v66 = v33;
            uint64_t v35 = v33;
            nw_connection_set_better_path_available_handler(v34, v65);

            if (v6) {
              goto LABEL_29;
            }
LABEL_30:
            *(void *)unsigned int buf = 0;
            *(void *)&uint8_t buf[8] = 0;
            id v67 = 0;
            uint64_t v68 = 0;
            if (v9)
            {
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              __int16 v38 = (id)gLogObj;
              if (os_log_type_enabled(v38, OS_LOG_TYPE_DEBUG))
              {
                uint64_t v39 = *(void *)(*(void *)(a1 + 32) + 96);
                uint64_t v40 = off_1E523FCD0[v9 - 1];
                if (a2 > 5) {
                  uint64_t v41 = "unknown";
                }
                else {
                  uint64_t v41 = off_1E523DF08[a2];
                }
                *(_DWORD *)handler = 136447234;
                *(void *)&handler[4] = "tcp_connection_start_block_invoke";
                *(_WORD *)&handler[12] = 2048;
                *(void *)&handler[14] = v39;
                *(_WORD *)&handler[22] = 2082;
                char v73 = v40;
                *(_WORD *)uint64_t v74 = 2082;
                *(void *)&v74[2] = v41;
                __int16 v75 = 2114;
                id v76 = v6;
                _os_log_impl(&dword_1830D4000, v38, OS_LOG_TYPE_DEBUG, "%{public}s %llu sending event %{public}s in response to state %{public}s and error %{public}@", handler, 0x34u);
              }

              int v42 = tcp_connection_fillout_event_locked(*(void **)(a1 + 32), (uint64_t)buf, v9, 0, 0, (uint64_t)"nw_connection event");
              if (!v8)
              {
LABEL_45:
                uint64_t v47 = *(void *)(a1 + 32);
                if ((v42 | v8) == 1)
                {
                  char v48 = _Block_copy(*(const void **)(v47 + 64));
                  uint64_t v47 = *(void *)(a1 + 32);
                }
                else
                {
                  char v48 = 0;
                }
                os_unfair_lock_unlock((os_unfair_lock_t)(v47 + 120));
                if (!v42)
                {
LABEL_54:
                  if (!v8)
                  {
LABEL_60:

                    goto LABEL_61;
                  }
                  int v53 = (unsigned __int8 *)*(id *)(a1 + 32);
                  id v54 = v48;
                  int v55 = v54;
                  if (!v54 || v53[156] == 255)
                  {
                    objc_super v56 = v67;
                    if (!v67) {
                      goto LABEL_59;
                    }
                  }
                  else
                  {
                    objc_super v56 = v67;
                    (*((void (**)(id, void, void *))v54 + 2))(v54, v68, v67);
                    if (!v56)
                    {
LABEL_59:

                      goto LABEL_60;
                    }
                  }
                  free(v56);
                  goto LABEL_59;
                }
                os_log_type_t v49 = (unsigned __int8 *)*(id *)(a1 + 32);
                id v50 = v48;
                uint64_t v51 = v50;
                if (!v50 || v49[156] == 255)
                {
                  os_log_type_t v52 = *(void **)buf;
                  if (!*(void *)buf) {
                    goto LABEL_53;
                  }
                }
                else
                {
                  os_log_type_t v52 = *(void **)buf;
                  (*((void (**)(id, void, void))v50 + 2))(v50, *(unsigned int *)&buf[8], *(void *)buf);
                  if (!v52)
                  {
LABEL_53:

                    goto LABEL_54;
                  }
                }
                free(v52);
                goto LABEL_53;
              }
            }
            else
            {
              int v42 = 0;
              if (!v8) {
                goto LABEL_45;
              }
            }
            pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
            networkd_settings_init();
            uint64_t v43 = (id)gLogObj;
            if (os_log_type_enabled(v43, OS_LOG_TYPE_DEBUG))
            {
              uint64_t v44 = *(void *)(*(void *)(a1 + 32) + 96);
              BOOL v45 = off_1E523FCD0[v8 - 1];
              if (a2 > 5) {
                os_log_type_t v46 = "unknown";
              }
              else {
                os_log_type_t v46 = off_1E523DF08[a2];
              }
              *(_DWORD *)handler = 136447234;
              *(void *)&handler[4] = "tcp_connection_start_block_invoke";
              *(_WORD *)&handler[12] = 2048;
              *(void *)&handler[14] = v44;
              *(_WORD *)&handler[22] = 2082;
              char v73 = v45;
              *(_WORD *)uint64_t v74 = 2082;
              *(void *)&v74[2] = v46;
              __int16 v75 = 2114;
              id v76 = v6;
              _os_log_impl(&dword_1830D4000, v43, OS_LOG_TYPE_DEBUG, "%{public}s %llu sending secondary event %{public}s in response to state %{public}s and error %{public}@", handler, 0x34u);
            }

            int v8 = tcp_connection_fillout_event_locked(*(void **)(a1 + 32), (uint64_t)&v67, v8, 0, 0, (uint64_t)"nw_connection secondary event");
            goto LABEL_45;
          }
          LOBYTE(v24) = *(unsigned char *)(v23 + 159);
          int v8 = 8;
          uint64_t v25 = (unsigned char *)(v23 + 159);
        }
        unsigned char *v25 = v24 | 2;
        uint64_t v23 = *(void *)(a1 + 32);
        goto LABEL_28;
      case 4u:
      case 5u:
        int v8 = 0;
        int v9 = 3;
        if (v6) {
          goto LABEL_29;
        }
        goto LABEL_30;
      default:
        int v8 = 0;
        int v9 = 0;
        if (v6)
        {
LABEL_29:
          objc_storeStrong((id *)(*(void *)(a1 + 32) + 24), a3);
          __int16 v36 = v6;
          int v37 = v36[3];

          *(_DWORD *)(*(void *)(a1 + 32) + 112) = v37;
        }
        goto LABEL_30;
    }
  }
  os_unfair_lock_unlock((os_unfair_lock_t)(v7 + 120));
LABEL_61:
}

BOOL nw_framer_allocate_metadata(void *a1)
{
  id v1 = a1;
  nw_parameters_t v2 = malloc_type_calloc(1uLL, 0x20uLL, 0xEAFB8F1AuLL);
  if (v2) {
    goto LABEL_2;
  }
  int v4 = __nwlog_obj();
  os_log_type_enabled(v4, OS_LOG_TYPE_ERROR);
  id v5 = (void *)_os_log_send_and_compose_impl();

  BOOL result = __nwlog_abort((uint64_t)v5);
  if (!result)
  {
    free(v5);
LABEL_2:

    return (BOOL)v2;
  }
  __break(1u);
  return result;
}

void sub_1831E4344(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

uint64_t nw_protocol_data_get_ecn_flag(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = *((unsigned char *)v1 + 186) & 3;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
  id v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null data", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
          __int16 v17 = 2082;
          os_log_type_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null data, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null data, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      uint64_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        os_log_type_t v16 = "nw_protocol_data_get_ecn_flag";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null data, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

uint64_t nw_path_uses_interface_subtype(void *a1, int a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  uint64_t v3 = a1;
  int v4 = v3;
  if (v3)
  {
    id v5 = nw_path_copy_connected_interface(v3);
    id v6 = v5;
    if (v5)
    {
      uint64_t v7 = v5;
      int v8 = *((_DWORD *)v7 + 25);

      if (v8 == a2) {
        goto LABEL_15;
      }
    }
    if (v4[94] != 1)
    {
      int v9 = v4[95];
      if (v9 == 4 || v9 == 30) {
        goto LABEL_16;
      }
    }
    BOOL v11 = (void *)*((void *)v4 + 12);
    if (v11)
    {
      os_log_type_t v12 = v11;
      int v13 = v12[25];

      if (v13 == a2) {
        goto LABEL_15;
      }
    }
    os_log_type_t v14 = (void *)*((void *)v4 + 13);
    if (v14)
    {
      int v15 = v14;
      int v16 = v15[25];

      if (v16 == a2) {
        goto LABEL_15;
      }
    }
    __int16 v17 = (void *)*((void *)v4 + 14);
    if (v17 && (v18 = v17, int v19 = v18[25], v18, v19 == a2)) {
LABEL_15:
    }
      uint64_t v20 = 1;
    else {
LABEL_16:
    }
      uint64_t v20 = 0;

    goto LABEL_18;
  }
  BOOL v22 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  int v33 = "nw_path_uses_interface_subtype";
  uint64_t v23 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v30 = 0;
  if (__nwlog_fault(v23, &type, &v30))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v24 = __nwlog_obj();
      os_log_type_t v25 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v33 = "nw_path_uses_interface_subtype";
        _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null path", buf, 0xCu);
      }
    }
    else if (v30)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v24 = __nwlog_obj();
      os_log_type_t v27 = type;
      BOOL v28 = os_log_type_enabled(v24, type);
      if (backtrace_string)
      {
        if (v28)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          int v33 = "nw_path_uses_interface_subtype";
          __int16 v34 = 2082;
          uint64_t v35 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null path, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_35;
      }
      if (v28)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v33 = "nw_path_uses_interface_subtype";
        _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null path, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v24 = __nwlog_obj();
      os_log_type_t v29 = type;
      if (os_log_type_enabled(v24, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        int v33 = "nw_path_uses_interface_subtype";
        _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null path, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_35:
  if (v23) {
    free(v23);
  }
  uint64_t v20 = 0;
LABEL_18:

  return v20;
}

void nw_connection_start_activity(void *a1, void *a2)
{
  uint64_t v26 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = a2;
  id v5 = v4;
  if (!v3)
  {
    id v6 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v23 = "nw_connection_start_activity";
    uint64_t v7 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v20 = 0;
    if (!__nwlog_fault(v7, &type, &v20)) {
      goto LABEL_39;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v8 = __nwlog_obj();
      os_log_type_t v9 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v23 = "nw_connection_start_activity";
        _os_log_impl(&dword_1830D4000, v8, v9, "%{public}s called with null connection", buf, 0xCu);
      }
    }
    else if (v20)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v8 = __nwlog_obj();
      os_log_type_t v13 = type;
      BOOL v14 = os_log_type_enabled(v8, type);
      if (backtrace_string)
      {
        if (v14)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v23 = "nw_connection_start_activity";
          __int16 v24 = 2082;
          os_log_type_t v25 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
LABEL_39:
        if (!v7) {
          goto LABEL_5;
        }
LABEL_40:
        free(v7);
        goto LABEL_5;
      }
      if (v14)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v23 = "nw_connection_start_activity";
        _os_log_impl(&dword_1830D4000, v8, v13, "%{public}s called with null connection, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      int v8 = __nwlog_obj();
      os_log_type_t v18 = type;
      if (os_log_type_enabled(v8, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v23 = "nw_connection_start_activity";
        _os_log_impl(&dword_1830D4000, v8, v18, "%{public}s called with null connection, backtrace limit exceeded", buf, 0xCu);
      }
    }
LABEL_38:

    goto LABEL_39;
  }
  if (v4)
  {
    nw_activity_activate(v4);
    if (nw_activity_should_log(v5)) {
      nw_connection_add_client_event_internal(v3, 4, 0, v5);
    }
    goto LABEL_5;
  }
  os_log_type_t v10 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v23 = "nw_connection_start_activity";
  uint64_t v7 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v20 = 0;
  if (!__nwlog_fault(v7, &type, &v20)) {
    goto LABEL_39;
  }
  if (type == OS_LOG_TYPE_FAULT)
  {
    int v8 = __nwlog_obj();
    os_log_type_t v11 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v23 = "nw_connection_start_activity";
      _os_log_impl(&dword_1830D4000, v8, v11, "%{public}s called with null activity", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (!v20)
  {
    int v8 = __nwlog_obj();
    os_log_type_t v19 = type;
    if (os_log_type_enabled(v8, type))
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v23 = "nw_connection_start_activity";
      _os_log_impl(&dword_1830D4000, v8, v19, "%{public}s called with null activity, backtrace limit exceeded", buf, 0xCu);
    }
    goto LABEL_38;
  }
  int v15 = (char *)__nw_create_backtrace_string();
  int v8 = __nwlog_obj();
  os_log_type_t v16 = type;
  BOOL v17 = os_log_type_enabled(v8, type);
  if (!v15)
  {
    if (v17)
    {
      *(_DWORD *)unsigned int buf = 136446210;
      uint64_t v23 = "nw_connection_start_activity";
      _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null activity, no backtrace", buf, 0xCu);
    }
    goto LABEL_38;
  }
  if (v17)
  {
    *(_DWORD *)unsigned int buf = 136446466;
    uint64_t v23 = "nw_connection_start_activity";
    __int16 v24 = 2082;
    os_log_type_t v25 = v15;
    _os_log_impl(&dword_1830D4000, v8, v16, "%{public}s called with null activity, dumping backtrace:%{public}s", buf, 0x16u);
  }

  free(v15);
  if (v7) {
    goto LABEL_40;
  }
LABEL_5:
}

void sub_1831E4E5C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

BOOL nw_endpoint_handler_fillout_tcp_info(void *a1, void *a2)
{
  uint64_t v44 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (v3)
  {
    *(void *)uint64_t v39 = 0;
    *(void *)&v39[8] = v39;
    *(void *)&v39[16] = 0x2020000000;
    char v40 = 0;
    os_unfair_lock_lock(v3 + 28);
    id v5 = *(void **)&v4[62]._os_unfair_lock_opaque;
    if (v4[29]._os_unfair_lock_opaque != 2)
    {
      v36[0] = MEMORY[0x1E4F143A8];
      v36[1] = 3221225472;
      v36[2] = __nw_endpoint_handler_fillout_tcp_info_block_invoke;
      v36[3] = &unk_1E523F9C8;
      void v36[4] = v39;
      v36[5] = a2;
      [v5 applyWithHandler:v4 toChildren:v36];
LABEL_27:
      os_unfair_lock_unlock(v4 + 28);
      BOOL v18 = *(unsigned char *)(*(void *)&v39[8] + 24) != 0;
      _Block_object_dispose(v39, 8);
      goto LABEL_28;
    }
    id v6 = v5;
    uint64_t v7 = v6;
    if (v6)
    {
      os_unfair_lock_lock(v6 + 220);
      int v8 = *(const void **)&v7[198]._os_unfair_lock_opaque;
      if (v8)
      {
        memcpy(a2, v8, 0x198uLL);
        BOOL v9 = 1;
      }
      else
      {
        os_log_type_t v10 = *(void **)&v7[102]._os_unfair_lock_opaque;
        if (v10)
        {
          uint64_t v11 = v10[3];
          if (v11)
          {
            os_log_type_t v12 = *(uint64_t (**)(void))(v11 + 224);
            if (v12)
            {
              *(void *)os_log_type_t type = 0;
              os_log_type_t v13 = (void *)v10[5];
              if (v13 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v15 = v10[11];
                if (v15) {
                  v10[11] = v15 + 1;
                }
                char v14 = -1;
              }
              else
              {
                char v14 = 0;
              }
              *(void *)unsigned int buf = v10;
              uint8_t buf[8] = v14;
              os_log_type_t v16 = (void *)v12();
              if (v13 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              }
              if (v16)
              {
                BOOL v9 = *(void *)type == 408;
                if (*(void *)type == 408) {
                  memcpy(a2, v16, 0x198uLL);
                }
                free(v16);
                goto LABEL_25;
              }
              pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
              networkd_settings_init();
              BOOL v17 = (id)gLogObj;
              if (os_log_type_enabled(v17, OS_LOG_TYPE_DEBUG))
              {
                *(_DWORD *)unsigned int buf = 136446210;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
                _os_log_impl(&dword_1830D4000, v17, OS_LOG_TYPE_DEBUG, "%{public}s copy_info() returned NULL", buf, 0xCu);
              }
            }
          }
        }
        BOOL v9 = 0;
      }
LABEL_25:
      os_unfair_lock_unlock(v7 + 220);
LABEL_26:

      *(unsigned char *)(*(void *)&v39[8] + 24) = v9;
      goto LABEL_27;
    }
    __int16 v24 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
    os_log_type_t v25 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    char v38 = 0;
    if (__nwlog_fault(v25, type, &v38))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v27 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_1830D4000, v26, v27, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if (v38)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v32 = type[0];
        BOOL v33 = os_log_type_enabled(v26, type[0]);
        if (backtrace_string)
        {
          if (v33)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
            __int16 v42 = 2082;
            uint64_t v43 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v26, v32, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_64;
        }
        if (v33)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_1830D4000, v26, v32, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v26 = __nwlog_obj();
        os_log_type_t v35 = type[0];
        if (os_log_type_enabled(v26, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_fillout_tcp_info";
          _os_log_impl(&dword_1830D4000, v26, v35, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_64:
    if (v25) {
      free(v25);
    }
    BOOL v9 = 0;
    goto LABEL_26;
  }
  char v20 = __nwlog_obj();
  *(_DWORD *)uint64_t v39 = 136446210;
  *(void *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
  uint64_t v21 = (char *)_os_log_send_and_compose_impl();

  buf[0] = 16;
  type[0] = OS_LOG_TYPE_DEFAULT;
  if (__nwlog_fault(v21, buf, type))
  {
    if (buf[0] == 17)
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v23 = buf[0];
      if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v39 = 136446210;
        *(void *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
        _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null handler", v39, 0xCu);
      }
    }
    else if (type[0])
    {
      BOOL v28 = (char *)__nw_create_backtrace_string();
      BOOL v22 = __nwlog_obj();
      os_log_type_t v29 = buf[0];
      BOOL v30 = os_log_type_enabled(v22, (os_log_type_t)buf[0]);
      if (v28)
      {
        if (v30)
        {
          *(_DWORD *)uint64_t v39 = 136446466;
          *(void *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
          *(_WORD *)&v39[12] = 2082;
          *(void *)&v39[14] = v28;
          _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s called with null handler, dumping backtrace:%{public}s", v39, 0x16u);
        }

        free(v28);
        goto LABEL_55;
      }
      if (v30)
      {
        *(_DWORD *)uint64_t v39 = 136446210;
        *(void *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
        _os_log_impl(&dword_1830D4000, v22, v29, "%{public}s called with null handler, no backtrace", v39, 0xCu);
      }
    }
    else
    {
      BOOL v22 = __nwlog_obj();
      os_log_type_t v34 = buf[0];
      if (os_log_type_enabled(v22, (os_log_type_t)buf[0]))
      {
        *(_DWORD *)uint64_t v39 = 136446210;
        *(void *)&v39[4] = "nw_endpoint_handler_fillout_tcp_info";
        _os_log_impl(&dword_1830D4000, v22, v34, "%{public}s called with null handler, backtrace limit exceeded", v39, 0xCu);
      }
    }
  }
LABEL_55:
  if (v21) {
    free(v21);
  }
  BOOL v18 = 0;
LABEL_28:

  return v18;
}

void nw_endpoint_flow_connected(NWConcrete_nw_endpoint_handler *a1)
{
  uint64_t v105 = *MEMORY[0x1E4F143B8];
  id v1 = a1;
  nw_parameters_t v2 = v1;
  if (!v1)
  {
    id v66 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    id v67 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (__nwlog_fault(v67, &type, &v92))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        uint64_t v68 = __nwlog_obj();
        os_log_type_t v69 = type;
        if (os_log_type_enabled(v68, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v68, v69, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v92)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        uint64_t v68 = __nwlog_obj();
        os_log_type_t v71 = type;
        BOOL v72 = os_log_type_enabled(v68, type);
        if (backtrace_string)
        {
          if (v72)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = backtrace_string;
            _os_log_impl(&dword_1830D4000, v68, v71, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_111;
        }
        if (v72)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v68, v71, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        uint64_t v68 = __nwlog_obj();
        os_log_type_t v73 = type;
        if (os_log_type_enabled(v68, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v68, v73, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_111:
    if (v67) {
      free(v67);
    }
    unsigned int mode = 0;
    goto LABEL_114;
  }
  unsigned int mode = v1->mode;

  if (mode == 2)
  {
    id v4 = nw_endpoint_handler_copy_flow(v2);
    id v5 = v2;
    int state = v5->state;

    if ((state & 0xFFFFFFFE) == 4) {
      goto LABEL_119;
    }
    if (*((void *)v4 + 114))
    {
      if ((*((char *)v4 + 32) & 0x80000000) == 0)
      {
        uint64_t v7 = v5;
        id v8 = v7[7];

        if (v8) {
          nw_association_force_update(v8, *((void **)v4 + 104));
        }
      }
      BOOL v9 = (void *)*((void *)v4 + 51);
      if (v9)
      {
        uint64_t v10 = v9[3];
        if (v10)
        {
          uint64_t v11 = *(uint64_t (**)(void))(v10 + 224);
          if (v11)
          {
            os_log_type_t v12 = (void *)v9[5];
            if (v12 == &nw_protocol_ref_counted_handle)
            {
              uint64_t v14 = v9[11];
              if (v14) {
                v9[11] = v14 + 1;
              }
              char v13 = -1;
            }
            else
            {
              char v13 = 0;
            }
            *(void *)unsigned int buf = v9;
            uint8_t buf[8] = v13;
            uint64_t v15 = v11();
            if (v12 == &nw_protocol_ref_counted_handle) {
              nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
            }
            os_unfair_lock_lock((os_unfair_lock_t)v4 + 220);
            os_log_type_t v16 = (void *)*((void *)v4 + 111);
            *((void *)v4 + 111) = v15;

            os_unfair_lock_unlock((os_unfair_lock_t)v4 + 220);
          }
        }
      }
    }
    BOOL v17 = v5;
    uint64_t v18 = v2->mode;

    if (v18 == 2)
    {
      os_log_type_t v19 = nw_endpoint_handler_copy_flow(v17);
      char v20 = v17;
      id v21 = v20[4];

      int sleep_keepalive_interval = nw_parameters_get_sleep_keepalive_interval(v21);
      if (sleep_keepalive_interval)
      {
        os_log_type_t v23 = (void *)*((void *)v19 + 111);
        if (v23)
        {
          *(void *)unsigned int buf = MEMORY[0x1E4F143A8];
          *(void *)&uint8_t buf[8] = 3221225472;
          *(void *)&buf[16] = ___ZL45nw_endpoint_flow_enable_sleep_proxy_if_neededP30NWConcrete_nw_endpoint_handler_block_invoke;
          os_log_type_t v95 = (const char *)&unk_1E524A338;
          *(void *)int v96 = v19;
          *(_DWORD *)&v96[16] = sleep_keepalive_interval;
          *(void *)&v96[8] = v20;
          nw_fd_wrapper_get_fd(v23, buf);

          __int16 v24 = *(NSObject **)v96;
LABEL_42:

          goto LABEL_43;
        }
        uint64_t v36 = v20;
        BOOL v37 = (*((unsigned char *)v36 + 268) & 0x20) == 0;

        if (v37)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          __int16 v24 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v24, OS_LOG_TYPE_ERROR))
          {
            id_string = nw_endpoint_handler_get_id_string(v36);
            os_log_type_t loga = nw_endpoint_handler_dry_run_string(v36);
            BOOL v87 = id_string;
            nw_endpoint_t obja = nw_endpoint_handler_copy_endpoint(v36);
            logging_description = nw_endpoint_get_logging_description(obja);
            char v40 = nw_endpoint_handler_state_string(v36);
            uint64_t v41 = nw_endpoint_handler_mode_string(v36);
            id v42 = nw_endpoint_handler_copy_current_path(v36);
            *(_DWORD *)unsigned int buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_enable_sleep_proxy_if_needed";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v87;
            *(_WORD *)&unsigned char buf[22] = 2082;
            os_log_type_t v95 = loga;
            *(_WORD *)int v96 = 2082;
            *(void *)&v96[2] = logging_description;
            *(_WORD *)&v96[10] = 2082;
            *(void *)&v96[12] = v40;
            __int16 v97 = 2082;
            os_log_type_t v98 = v41;
            __int16 v99 = 2114;
            id v100 = v42;
            _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Sleep proxy is only supported for socket flows", buf, 0x48u);
          }
          goto LABEL_42;
        }
      }
LABEL_43:

      goto LABEL_65;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    id v25 = (id)gLogObj;
    if (v18 > 5) {
      uint64_t v26 = "unknown-mode";
    }
    else {
      uint64_t v26 = off_1E523FB08[v18];
    }
    *(_DWORD *)unsigned int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_enable_sleep_proxy_if_needed";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v26;
    *(_WORD *)&unsigned char buf[22] = 2082;
    os_log_type_t v95 = "flow";
    os_log_type_t v27 = (void *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v92 = 0;
    if (__nwlog_fault((const char *)v27, &type, &v92))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v28 = (id)gLogObj;
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v28, type))
        {
          if (v18 > 5) {
            BOOL v30 = "unknown-mode";
          }
          else {
            BOOL v30 = off_1E523FB08[v18];
          }
          *(_DWORD *)unsigned int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_enable_sleep_proxy_if_needed";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v30;
          *(_WORD *)&unsigned char buf[22] = 2082;
          os_log_type_t v95 = "flow";
          _os_log_impl(&dword_1830D4000, v28, v29, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
        }
      }
      else if (v92)
      {
        os_log_type_t v31 = __nw_create_backtrace_string();
        if (v31)
        {
          os_log_type_t v32 = (char *)v31;
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          BOOL v33 = (id)gLogObj;
          os_log_type_t v34 = type;
          if (os_log_type_enabled(v33, type))
          {
            if (v18 > 5) {
              os_log_type_t v35 = "unknown-mode";
            }
            else {
              os_log_type_t v35 = off_1E523FB08[v18];
            }
            *(_DWORD *)unsigned int buf = 136446978;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_enable_sleep_proxy_if_needed";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = v35;
            *(_WORD *)&unsigned char buf[22] = 2082;
            os_log_type_t v95 = "flow";
            *(_WORD *)int v96 = 2082;
            *(void *)&v96[2] = v32;
            _os_log_impl(&dword_1830D4000, v33, v34, "%{public}s Handler is in mode %{public}s, expected %{public}s, dumping backtrace:%{public}s", buf, 0x2Au);
          }

          free(v32);
          if (!v27)
          {
LABEL_65:

            if ((*((unsigned char *)v4 + 33) & 1) == 0 || !*((void *)v4 + 92)) {
              goto LABEL_85;
            }
            uint64_t v47 = 0;
            char v48 = (const unsigned __int8 *)v4 + 376;
            do
            {
              if (!uuid_is_null(v48)) {
                uint64_t v47 = v48;
              }
              char v48 = (const unsigned __int8 *)*((void *)v48 + 4);
            }
            while (v48);
            if (!v47) {
              goto LABEL_85;
            }
            os_log_type_t v49 = (void *)*((void *)v4 + 104);
            if (v49)
            {
              *(void *)unsigned int buf = 0;
              *(void *)&uint8_t buf[8] = 0;
              id v50 = v49;
              if (!uuid_is_null(v50 + 32)) {
                *(_OWORD *)unsigned int buf = *((_OWORD *)v50 + 2);
              }

              if (!uuid_compare(buf, v47)) {
                goto LABEL_85;
              }
            }
            uint64_t v51 = v17;
            id v52 = v51[5];

            id obj = nw_path_copy_flow_registration(v52, (uint64_t)v47);
            if (obj)
            {
              objc_storeStrong((id *)v4 + 104, obj);
              if (nw_endpoint_handler_get_minimize_logging(v51))
              {
                if (nw_endpoint_handler_get_logging_disabled(v51)) {
                  goto LABEL_84;
                }
                id v89 = v52;
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                os_log_t log = (id)gconnectionLogObj;
                if (os_log_type_enabled(log, OS_LOG_TYPE_DEBUG))
                {
                  uint32_t v83 = nw_endpoint_handler_get_id_string(v51);
                  BOOL v81 = nw_endpoint_handler_dry_run_string(v51);
                  nw_endpoint_t v75 = nw_endpoint_handler_copy_endpoint(v51);
                  id v76 = nw_endpoint_get_logging_description(v75);
                  os_log_type_t v77 = nw_endpoint_handler_state_string(v51);
                  unint64_t v78 = nw_endpoint_handler_mode_string(v51);
                  id v79 = nw_endpoint_handler_copy_current_path(v51);
                  *(_DWORD *)unsigned int buf = 136448258;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_connected";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v83;
                  *(_WORD *)&unsigned char buf[22] = 2082;
                  os_log_type_t v95 = v81;
                  *(_WORD *)int v96 = 2082;
                  *(void *)&v96[2] = v76;
                  *(_WORD *)&v96[10] = 2082;
                  *(void *)&v96[12] = v77;
                  __int16 v97 = 2082;
                  os_log_type_t v98 = v78;
                  __int16 v99 = 2114;
                  id v100 = v79;
                  __int16 v101 = 1042;
                  int v102 = 16;
                  __int16 v103 = 2098;
                  __int16 v104 = v47;
                  int v55 = log;
                  _os_log_impl(&dword_1830D4000, log, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Joined protocol has updated flow id, using flow id %{public,uuid_t}.16P", buf, 0x58u);

                  id v52 = v89;
                }
                else
                {
                  int v55 = log;
                }
                goto LABEL_83;
              }
              int v53 = v51;
              BOOL v54 = (*((unsigned char *)v53 + 268) & 0x20) == 0;

              if (v54)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                int v55 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v55, OS_LOG_TYPE_INFO))
                {
                  objc_super v56 = nw_endpoint_handler_get_id_string(v53);
                  uint64_t v80 = nw_endpoint_handler_dry_run_string(v53);
                  os_log_t logb = v55;
                  id v88 = v52;
                  nw_endpoint_t v82 = nw_endpoint_handler_copy_endpoint(v53);
                  os_log_type_t v57 = nw_endpoint_get_logging_description(v82);
                  __int16 v58 = nw_endpoint_handler_state_string(v53);
                  int v59 = nw_endpoint_handler_mode_string(v53);
                  id v60 = nw_endpoint_handler_copy_current_path(v53);
                  *(_DWORD *)unsigned int buf = 136448258;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_connected";
                  *(_WORD *)&unsigned char buf[12] = 2082;
                  *(void *)&buf[14] = v56;
                  *(_WORD *)&unsigned char buf[22] = 2082;
                  os_log_type_t v95 = v80;
                  *(_WORD *)int v96 = 2082;
                  *(void *)&v96[2] = v57;
                  *(_WORD *)&v96[10] = 2082;
                  *(void *)&v96[12] = v58;
                  __int16 v97 = 2082;
                  os_log_type_t v98 = v59;
                  __int16 v99 = 2114;
                  id v100 = v60;
                  __int16 v101 = 1042;
                  int v102 = 16;
                  __int16 v103 = 2098;
                  __int16 v104 = v47;
                  int v55 = logb;
                  _os_log_impl(&dword_1830D4000, logb, OS_LOG_TYPE_INFO, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Joined protocol has updated flow id, using flow id %{public,uuid_t}.16P", buf, 0x58u);

                  id v52 = v88;
                }
LABEL_83:
              }
            }
LABEL_84:

LABEL_85:
            os_unfair_lock_lock((os_unfair_lock_t)v4 + 220);
            __int16 v61 = (void *)*((void *)v4 + 2);
            *((void *)v4 + 2) = 0;

            os_unfair_lock_unlock((os_unfair_lock_t)v4 + 220);
            if ((*((unsigned char *)v4 + 32) & 3) == 1 && (os_log_type_t v62 = (void *)*((void *)v4 + 117)) != 0) {
              uint64_t v63 = nw_endpoint_handler_copy_connected_path(v62);
            }
            else {
              uint64_t v63 = (uint64_t)nw_endpoint_flow_copy_path(v17);
            }
            os_log_type_t v64 = (void *)v63;
            os_unfair_lock_lock((os_unfair_lock_t)v4 + 220);
            objc_storeStrong((id *)v4 + 1, v64);
            os_unfair_lock_unlock((os_unfair_lock_t)v4 + 220);
            os_log_type_t v65 = v17;
            v5->int state = 3;

            if (_nw_signposts_once != -1) {
              dispatch_once(&_nw_signposts_once, &__block_literal_global_81595);
            }
            if (_nw_signposts_enabled && kdebug_is_enabled()) {
              kdebug_trace();
            }
            nw_endpoint_flow_update_connected_metadata(v65, 0);
            nw_endpoint_flow_update_connected_metadata(v65, 1);
            nw_endpoint_flow_connected_path_change(v65);

            goto LABEL_119;
          }
LABEL_64:
          free(v27);
          goto LABEL_65;
        }
        BOOL v28 = __nwlog_obj();
        os_log_type_t v45 = type;
        if (os_log_type_enabled(v28, type))
        {
          if (v18 > 5) {
            os_log_type_t v46 = "unknown-mode";
          }
          else {
            os_log_type_t v46 = off_1E523FB08[v18];
          }
          *(_DWORD *)unsigned int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_enable_sleep_proxy_if_needed";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v46;
          *(_WORD *)&unsigned char buf[22] = 2082;
          os_log_type_t v95 = "flow";
          _os_log_impl(&dword_1830D4000, v28, v45, "%{public}s Handler is in mode %{public}s, expected %{public}s, no backtrace", buf, 0x20u);
        }
      }
      else
      {
        pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
        networkd_settings_init();
        BOOL v28 = (id)gLogObj;
        os_log_type_t v43 = type;
        if (os_log_type_enabled(v28, type))
        {
          if (v18 > 5) {
            uint64_t v44 = "unknown-mode";
          }
          else {
            uint64_t v44 = off_1E523FB08[v18];
          }
          *(_DWORD *)unsigned int buf = 136446722;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_enable_sleep_proxy_if_needed";
          *(_WORD *)&unsigned char buf[12] = 2082;
          *(void *)&buf[14] = v44;
          *(_WORD *)&unsigned char buf[22] = 2082;
          os_log_type_t v95 = "flow";
          _os_log_impl(&dword_1830D4000, v28, v43, "%{public}s Handler is in mode %{public}s, expected %{public}s, backtrace limit exceeded", buf, 0x20u);
        }
      }
    }
    if (!v27) {
      goto LABEL_65;
    }
    goto LABEL_64;
  }
LABEL_114:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  id v4 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
  if (os_log_type_enabled((os_log_t)v4, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      uint64_t v74 = "unknown-mode";
    }
    else {
      uint64_t v74 = off_1E523FB08[mode];
    }
    *(_DWORD *)unsigned int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_connected";
    *(_WORD *)&unsigned char buf[12] = 2082;
    *(void *)&buf[14] = v74;
    *(_WORD *)&unsigned char buf[22] = 2082;
    os_log_type_t v95 = "flow";
    _os_log_impl(&dword_1830D4000, (os_log_t)v4, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }
LABEL_119:
}

void sub_1831E643C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, void *a13, void *a14, void *a15)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_update_connected_metadata(NWConcrete_nw_endpoint_handler *a1, int a2)
{
  uint64_t v38 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  id v4 = v3;
  if (!v3)
  {
    BOOL v22 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
    os_log_type_t v23 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v31 = 0;
    if (__nwlog_fault(v23, &type, &v31))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        __int16 v24 = __nwlog_obj();
        os_log_type_t v25 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v24, v25, "%{public}s called with null handler", buf, 0xCu);
        }
      }
      else if (v31)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        __int16 v24 = __nwlog_obj();
        os_log_type_t v27 = type;
        BOOL v28 = os_log_type_enabled(v24, type);
        if (backtrace_string)
        {
          if (v28)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
            __int16 v34 = 2082;
            os_log_type_t v35 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_35;
        }
        if (v28)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v24, v27, "%{public}s called with null handler, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        __int16 v24 = __nwlog_obj();
        os_log_type_t v29 = type;
        if (os_log_type_enabled(v24, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_handler_get_mode";
          _os_log_impl(&dword_1830D4000, v24, v29, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_35:
    if (v23) {
      free(v23);
    }
    unsigned int mode = 0;
    goto LABEL_38;
  }
  unsigned int mode = v3->mode;

  if (mode == 2)
  {
    id v6 = v4;
    uint64_t v7 = v6->parameters;

    id v8 = nw_parameters_copy_context(v7);
    nw_context_assert_queue(v8);

    BOOL v9 = nw_endpoint_handler_copy_flow(v6);
    uint64_t v10 = (void *)*((void *)v9 + 51);
    if (v10)
    {
      uint64_t v11 = v10[3];
      if (v11)
      {
        os_log_type_t v12 = *(uint64_t (**)(void))(v11 + 224);
        if (v12)
        {
          char v13 = (void *)v10[5];
          if (v13 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v18 = v10[11];
            if (v18) {
              v10[11] = v18 + 1;
            }
            char v14 = -1;
          }
          else
          {
            char v14 = 0;
          }
          *(void *)unsigned int buf = v10;
          uint8_t buf[8] = v14;
          uint64_t v19 = v12();
          if (v13 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
          }
          os_unfair_lock_lock((os_unfair_lock_t)v9 + 220);
          uint64_t v20 = 1048;
          if (a2) {
            uint64_t v20 = 1056;
          }
          id v21 = *(void **)((char *)v9 + v20);
          *(void *)((char *)v9 + v20) = v19;

          os_unfair_lock_unlock((os_unfair_lock_t)v9 + 220);
        }
      }
    }
    else
    {
      pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
      networkd_settings_init();
      uint64_t v15 = (id)gLogObj;
      if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
      {
        os_log_type_t v16 = v6;
        id_str = v16->id_str;

        *(_DWORD *)unsigned int buf = 136446466;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_update_connected_metadata";
        __int16 v34 = 2082;
        os_log_type_t v35 = id_str;
        _os_log_impl(&dword_1830D4000, v15, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s] could not find valid output protocol", buf, 0x16u);
      }
    }
    goto LABEL_43;
  }
LABEL_38:
  pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
  networkd_settings_init();
  BOOL v9 = (NWConcrete_nw_endpoint_mode_handler *)(id)gLogObj;
  if (os_log_type_enabled((os_log_t)v9, OS_LOG_TYPE_DEFAULT))
  {
    if (mode > 5) {
      BOOL v30 = "unknown-mode";
    }
    else {
      BOOL v30 = off_1E523FB08[mode];
    }
    *(_DWORD *)unsigned int buf = 136446722;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_update_connected_metadata";
    __int16 v34 = 2082;
    os_log_type_t v35 = (char *)v30;
    __int16 v36 = 2082;
    BOOL v37 = "flow";
    _os_log_impl(&dword_1830D4000, (os_log_t)v9, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
  }
LABEL_43:
}

uint64_t nw_socket_copy_info(uint64_t a1, int a2, void *a3)
{
  uint64_t v111 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    if (*(_UNKNOWN **)(a1 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v4 = 0;
      switch(a2)
      {
        case 1:
          if (*(_DWORD *)(a1 + 272) != 2 || (int v6 = *(unsigned __int8 *)(a1 + 400), v6 != 30) && v6 != 2)
          {
            uint64_t v4 = 0;
            if ((*(_WORD *)(a1 + 397) & 0x80) != 0 || !gLogDatapath) {
              return v4;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v25 = gconnectionLogObj;
            if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
            {
              *(_DWORD *)unsigned int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = a1 + 404;
              BOOL v17 = "%{public}s %{public}s ignoring tcp_info request for non-TCP socket";
              goto LABEL_74;
            }
            return 0;
          }
          *(_DWORD *)BOOL v86 = 408;
          if (((*(unsigned __int16 *)(a1 + 397) | (*(unsigned __int8 *)(a1 + 399) << 16)) & 0x20000) != 0)
          {
            if ((*(_WORD *)(a1 + 397) & 0x80) == 0)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              uint64_t v16 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                *(_WORD *)&unsigned char buf[12] = 2082;
                *(void *)&buf[14] = a1 + 404;
                BOOL v17 = "%{public}s %{public}s Can't get TCP_INFO on a multipath socket";
                goto LABEL_108;
              }
            }
            return 0;
          }
          uint64_t v4 = (uint64_t)malloc_type_malloc(0x198uLL, 0xF2B69DE5uLL);
          if (!v4)
          {
            unint64_t v78 = __nwlog_obj();
            os_log_type_enabled(v78, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "strict_malloc";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = 408;
            id v79 = (void *)_os_log_send_and_compose_impl();
            uint64_t result = __nwlog_abort((uint64_t)v79);
            if (result) {
              goto LABEL_249;
            }
            free(v79);
          }
          if (!getsockopt(*(_DWORD *)(a1 + 268), 6, 512, (void *)v4, (socklen_t *)v86)) {
            goto LABEL_124;
          }
          int v7 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          id v8 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)unsigned int buf = 136446722;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 2080;
            *(void *)&buf[14] = a1 + 404;
            *(_WORD *)&unsigned char buf[22] = 1024;
            *(_DWORD *)&unsigned char buf[24] = v7;
            _os_log_impl(&dword_1830D4000, v8, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt TCP_INFO failed %{darwin.errno}d", buf, 0x1Cu);
          }
          BOOL v9 = __nwlog_obj();
          uint64_t v10 = v9;
          if (v7 == 102)
          {
            if (!os_log_type_enabled(v9, OS_LOG_TYPE_ERROR)) {
              goto LABEL_213;
            }
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = 102;
            uint64_t v11 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d";
            goto LABEL_34;
          }
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
          *(_WORD *)&unsigned char buf[12] = 1024;
          *(_DWORD *)&buf[14] = v7;
          os_log_type_t v62 = (const char *)_os_log_send_and_compose_impl();
          LOBYTE(v85[0]) = 16;
          LOBYTE(v84) = 0;
          if (!__nwlog_fault(v62, v85, &v84)) {
            goto LABEL_210;
          }
          if (LOBYTE(v85[0]) == 17)
          {
            uint64_t v63 = __nwlog_obj();
            os_log_type_t v64 = v85[0];
            if (!os_log_type_enabled(v63, v85[0])) {
              goto LABEL_210;
            }
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v7;
            os_log_type_t v65 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d";
            goto LABEL_209;
          }
          if ((_BYTE)v84)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            uint64_t v63 = __nwlog_obj();
            os_log_type_t v64 = v85[0];
            BOOL v71 = os_log_type_enabled(v63, v85[0]);
            if (backtrace_string)
            {
              if (!v71) {
                goto LABEL_178;
              }
              *(_DWORD *)unsigned int buf = 136446722;
              *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v7;
              *(_WORD *)&buf[18] = 2082;
              *(void *)&buf[20] = backtrace_string;
              BOOL v70 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s";
              goto LABEL_177;
            }
            if (!v71) {
              goto LABEL_210;
            }
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v7;
            os_log_type_t v65 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, no backtrace";
          }
          else
          {
            uint64_t v63 = __nwlog_obj();
            os_log_type_t v64 = v85[0];
            if (!os_log_type_enabled(v63, v85[0])) {
              goto LABEL_210;
            }
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 1024;
            *(_DWORD *)&buf[14] = v7;
            os_log_type_t v65 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, backtrace limit exceeded";
          }
          goto LABEL_209;
        case 2:
          if (*(_DWORD *)(a1 + 272) == 2)
          {
            int v12 = *(unsigned __int8 *)(a1 + 400);
            if (v12 == 30 || v12 == 2)
            {
              *(_DWORD *)BOOL v86 = 112;
              if (((*(unsigned __int16 *)(a1 + 397) | (*(unsigned __int8 *)(a1 + 399) << 16)) & 0x20000) != 0)
              {
                if ((*(_WORD *)(a1 + 397) & 0x80) == 0)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  uint64_t v16 = gconnectionLogObj;
                  if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
                  {
                    *(_DWORD *)unsigned int buf = 136446466;
                    *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                    *(_WORD *)&unsigned char buf[12] = 2082;
                    *(void *)&buf[14] = a1 + 404;
                    BOOL v17 = "%{public}s %{public}s Can't get TCP_CONNECTION_INFO on a multipath socket";
                    goto LABEL_108;
                  }
                }
                return 0;
              }
              uint64_t v4 = (uint64_t)malloc_type_malloc(0x70uLL, 0xF2B69DE5uLL);
              if (!v4)
              {
                uint64_t v80 = __nwlog_obj();
                os_log_type_enabled(v80, OS_LOG_TYPE_ERROR);
                *(_DWORD *)unsigned int buf = 136446466;
                *(void *)&uint8_t buf[4] = "strict_malloc";
                *(_WORD *)&unsigned char buf[12] = 2048;
                *(void *)&buf[14] = 112;
                BOOL v81 = (void *)_os_log_send_and_compose_impl();
                uint64_t result = __nwlog_abort((uint64_t)v81);
                if (result) {
                  goto LABEL_249;
                }
                free(v81);
              }
              if (!getsockopt(*(_DWORD *)(a1 + 268), 6, 262, (void *)v4, (socklen_t *)v86))
              {
LABEL_124:
                if (a3) {
                  *a3 = *(unsigned int *)v86;
                }
                return v4;
              }
              int v13 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              char v14 = gconnectionLogObj;
              if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
              {
                *(_DWORD *)unsigned int buf = 136446722;
                *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                *(_WORD *)&unsigned char buf[12] = 2080;
                *(void *)&buf[14] = a1 + 404;
                *(_WORD *)&unsigned char buf[22] = 1024;
                *(_DWORD *)&unsigned char buf[24] = v13;
                _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d", buf, 0x1Cu);
              }
              uint64_t v15 = __nwlog_obj();
              uint64_t v10 = v15;
              if (v13 == 102)
              {
                if (os_log_type_enabled(v15, OS_LOG_TYPE_ERROR))
                {
                  *(_DWORD *)unsigned int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = 102;
                  uint64_t v11 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d";
LABEL_34:
                  _os_log_impl(&dword_1830D4000, v10, OS_LOG_TYPE_ERROR, v11, buf, 0x12u);
                }
                goto LABEL_213;
              }
              *(_DWORD *)unsigned int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
              *(_WORD *)&unsigned char buf[12] = 1024;
              *(_DWORD *)&buf[14] = v13;
              os_log_type_t v62 = (const char *)_os_log_send_and_compose_impl();
              LOBYTE(v85[0]) = 16;
              LOBYTE(v84) = 0;
              if (!__nwlog_fault(v62, v85, &v84)) {
                goto LABEL_210;
              }
              if (LOBYTE(v85[0]) == 17)
              {
                uint64_t v63 = __nwlog_obj();
                os_log_type_t v64 = v85[0];
                if (os_log_type_enabled(v63, v85[0]))
                {
                  *(_DWORD *)unsigned int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v13;
                  os_log_type_t v65 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d";
LABEL_209:
                  _os_log_impl(&dword_1830D4000, v63, v64, v65, buf, 0x12u);
                }
              }
              else if ((_BYTE)v84)
              {
                backtrace_string = (char *)__nw_create_backtrace_string();
                uint64_t v63 = __nwlog_obj();
                os_log_type_t v64 = v85[0];
                BOOL v69 = os_log_type_enabled(v63, v85[0]);
                if (backtrace_string)
                {
                  if (v69)
                  {
                    *(_DWORD *)unsigned int buf = 136446722;
                    *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                    *(_WORD *)&unsigned char buf[12] = 1024;
                    *(_DWORD *)&buf[14] = v13;
                    *(_WORD *)&buf[18] = 2082;
                    *(void *)&buf[20] = backtrace_string;
                    BOOL v70 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s";
LABEL_177:
                    _os_log_impl(&dword_1830D4000, v63, v64, v70, buf, 0x1Cu);
                  }
LABEL_178:
                  free(backtrace_string);
                  goto LABEL_210;
                }
                if (v69)
                {
                  *(_DWORD *)unsigned int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v13;
                  os_log_type_t v65 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d, no backtrace";
                  goto LABEL_209;
                }
              }
              else
              {
                uint64_t v63 = __nwlog_obj();
                os_log_type_t v64 = v85[0];
                if (os_log_type_enabled(v63, v85[0]))
                {
                  *(_DWORD *)unsigned int buf = 136446466;
                  *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
                  *(_WORD *)&unsigned char buf[12] = 1024;
                  *(_DWORD *)&buf[14] = v13;
                  os_log_type_t v65 = "%{public}s getsockopt TCP_CONNECTION_INFO failed %{darwin.errno}d, backtrace limit exceeded";
                  goto LABEL_209;
                }
              }
LABEL_210:
              if (!v62) {
                goto LABEL_213;
              }
              int v59 = (char *)v62;
              goto LABEL_212;
            }
          }
          uint64_t v4 = 0;
          if ((*(_WORD *)(a1 + 397) & 0x80) != 0 || !gLogDatapath) {
            return v4;
          }
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          uint64_t v25 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_DEBUG))
          {
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 404;
            BOOL v17 = "%{public}s %{public}s ignoring tcp_connection_info request for non-TCP socket";
LABEL_74:
            uint64_t v26 = v25;
            os_log_type_t v27 = OS_LOG_TYPE_DEBUG;
            goto LABEL_109;
          }
          return 0;
        case 3:
          *(void *)BOOL v86 = 0;
          if (*(_DWORD *)(a1 + 272) != 2)
          {
            if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
              return 0;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v16 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
              return 0;
            }
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 404;
            BOOL v17 = "%{public}s %{public}s Can't get MPTCP_INFO on a non-stream socket";
            goto LABEL_108;
          }
          if (((*(unsigned __int16 *)(a1 + 397) | (*(unsigned __int8 *)(a1 + 399) << 16)) & 0x20000) == 0)
          {
            if ((*(_WORD *)(a1 + 397) & 0x80) != 0) {
              return 0;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            uint64_t v16 = gconnectionLogObj;
            if (!os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR)) {
              return 0;
            }
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            *(_WORD *)&unsigned char buf[12] = 2082;
            *(void *)&buf[14] = a1 + 404;
            BOOL v17 = "%{public}s %{public}s Can't get MPTCP_INFO on a TCP socket";
LABEL_108:
            uint64_t v26 = v16;
            os_log_type_t v27 = OS_LOG_TYPE_ERROR;
LABEL_109:
            _os_log_impl(&dword_1830D4000, v26, v27, v17, buf, 0x16u);
            return 0;
          }
          if (!copymptcpinfo(*(_DWORD *)(a1 + 268), v86))
          {
            if (a3) {
              *a3 = 24;
            }
            return *(void *)v86;
          }
          __nwlog_obj();
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
          uint64_t v4 = _os_log_send_and_compose_impl();
          LOBYTE(v85[0]) = 16;
          LOBYTE(v84) = 0;
          if (!__nwlog_fault((const char *)v4, v85, &v84)) {
            goto LABEL_213;
          }
          if (LOBYTE(v85[0]) == 17)
          {
            os_log_type_t v32 = __nwlog_obj();
            os_log_type_t v33 = v85[0];
            if (!os_log_type_enabled(v32, v85[0])) {
              goto LABEL_213;
            }
            *(_DWORD *)unsigned int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            __int16 v34 = "%{public}s copymptcpinfo failed";
            goto LABEL_183;
          }
          if ((_BYTE)v84)
          {
            objc_super v56 = __nw_create_backtrace_string();
            os_log_type_t v32 = __nwlog_obj();
            os_log_type_t v33 = v85[0];
            BOOL v57 = os_log_type_enabled(v32, v85[0]);
            if (v56)
            {
              if (!v57) {
                goto LABEL_147;
              }
              *(_DWORD *)unsigned int buf = 136446466;
              *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
              *(_WORD *)&unsigned char buf[12] = 2082;
              *(void *)&buf[14] = v56;
              __int16 v58 = "%{public}s copymptcpinfo failed, dumping backtrace:%{public}s";
              goto LABEL_146;
            }
            if (!v57) {
              goto LABEL_213;
            }
            *(_DWORD *)unsigned int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            __int16 v34 = "%{public}s copymptcpinfo failed, no backtrace";
          }
          else
          {
            os_log_type_t v32 = __nwlog_obj();
            os_log_type_t v33 = v85[0];
            if (!os_log_type_enabled(v32, v85[0])) {
              goto LABEL_213;
            }
            *(_DWORD *)unsigned int buf = 136446210;
            *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
            __int16 v34 = "%{public}s copymptcpinfo failed, backtrace limit exceeded";
          }
          goto LABEL_183;
        case 4:
          return v4;
        case 5:
          if (*(_DWORD *)(a1 + 272) == 1)
          {
            uint64_t v4 = (uint64_t)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
            if (v4)
            {
LABEL_44:
              *(void *)(v4 + 48) = *(void *)(a1 + 96);
              *(void *)(v4 + 72) = *(void *)(a1 + 104);
              *(void *)(v4 + 8) = *(void *)(a1 + 112);
              *(void *)(v4 + 40) = *(void *)(a1 + 120);
              goto LABEL_199;
            }
            uint64_t v74 = __nwlog_obj();
            os_log_type_enabled(v74, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int buf = 136446722;
            *(void *)&uint8_t buf[4] = "strict_calloc";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = 1;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)&unsigned char buf[24] = 184;
            nw_endpoint_t v75 = (void *)_os_log_send_and_compose_impl();
            uint64_t result = __nwlog_abort((uint64_t)v75);
            if (!result)
            {
              free(v75);
              goto LABEL_44;
            }
LABEL_249:
            __break(1u);
            return result;
          }
          *(void *)BOOL v85 = 0;
          if (((*(unsigned __int16 *)(a1 + 397) | (*(unsigned __int8 *)(a1 + 399) << 16)) & 0x20000) != 0
            && !copymptcpinfo(*(_DWORD *)(a1 + 268), v85))
          {
            uint64_t v4 = nw_calloc_type<nw_data_transfer_snapshot>(*(unsigned int *)(*(void *)v85 + 16));
            uint64_t v47 = *(void **)v85;
            unsigned int v48 = *(_DWORD *)(*(void *)v85 + 16);
            if (v48)
            {
              uint64_t v49 = *(void *)(*(void *)v85 + 8);
              id v50 = (void *)(v4 + 72);
              uint64_t v51 = *(unsigned int *)(*(void *)v85 + 16);
              do
              {
                if (*(void *)v49)
                {
                  uint64_t v52 = *(void *)(*(void *)v49 + 32);
                  *(v50 - 9) = *(int *)(v52 + 60);
                  *id v50 = *(void *)(v52 + 76);
                  *(_OWORD *)(v50 - 3) = *(_OWORD *)(v52 + 108);
                  *(v50 - 1) = *(void *)(v52 + 124);
                  v50[1] = *(void *)(v52 + 84);
                  *(v50 - 8) = *(void *)(v52 + 100);
                  *(v50 - 4) = *(void *)(v52 + 68);
                  v50[6] = *(unsigned int *)(v52 + 24);
                  v50[7] = *(unsigned int *)(v52 + 32);
                  v50[8] = *(unsigned int *)(v52 + 20);
                  v50[9] = *(unsigned int *)(v52 + 28);
                }
                v49 += 8;
                v50 += 23;
                --v51;
              }
              while (v51);
            }
            if (a3) {
              *a3 = 184 * v48;
            }
            freemptcpinfo(v47);
            return v4;
          }
          int v28 = *(unsigned __int8 *)(a1 + 400);
          if (v28 != 30 && v28 != 2)
          {
            uint64_t v4 = (uint64_t)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
            if (!v4)
            {
              BOOL v37 = __nwlog_obj();
              os_log_type_enabled(v37, OS_LOG_TYPE_ERROR);
              *(_DWORD *)unsigned int buf = 136446722;
              *(void *)&uint8_t buf[4] = "strict_calloc";
              *(_WORD *)&unsigned char buf[12] = 2048;
              *(void *)&buf[14] = 1;
              *(_WORD *)&unsigned char buf[22] = 2048;
              *(void *)&unsigned char buf[24] = 184;
              uint64_t v38 = (char *)_os_log_send_and_compose_impl();
              uint64_t result = __nwlog_abort((uint64_t)v38);
              if (result) {
                goto LABEL_249;
              }
              goto LABEL_197;
            }
LABEL_198:
            *(void *)(v4 + 48) = *(void *)(a1 + 96);
            *(void *)(v4 + 72) = *(void *)(a1 + 104);
LABEL_199:
            if (a3) {
              *a3 = 184;
            }
            return v4;
          }
          uint64_t v4 = (uint64_t)malloc_type_calloc(1uLL, 0xB8uLL, 0xEAFB8F1AuLL);
          if (!v4)
          {
            id v76 = __nwlog_obj();
            os_log_type_enabled(v76, OS_LOG_TYPE_ERROR);
            *(_DWORD *)unsigned int buf = 136446722;
            *(void *)&uint8_t buf[4] = "strict_calloc";
            *(_WORD *)&unsigned char buf[12] = 2048;
            *(void *)&buf[14] = 1;
            *(_WORD *)&unsigned char buf[22] = 2048;
            *(void *)&unsigned char buf[24] = 184;
            os_log_type_t v77 = (void *)_os_log_send_and_compose_impl();
            uint64_t result = __nwlog_abort((uint64_t)v77);
            if (result) {
              goto LABEL_249;
            }
            free(v77);
          }
          uint64_t v110 = 0;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          memset(v93, 0, sizeof(v93));
          memset(v92, 0, sizeof(v92));
          long long v90 = 0u;
          long long v91 = 0u;
          memset(buf, 0, sizeof(buf));
          socklen_t v84 = 408;
          if (!getsockopt(*(_DWORD *)(a1 + 268), 6, 512, buf, &v84))
          {
            *(void *)(v4 + 72) = *(void *)((char *)v92 + 12);
            *(_OWORD *)(v4 + 48) = *(_OWORD *)&v93[3];
            *(void *)(v4 + 64) = *(void *)&v93[7];
            *(void *)(v4 + 80) = *(void *)((char *)&v92[1] + 4);
            *(void *)(v4 + 8) = *(void *)&v93[1];
            *(void *)(v4 + 40) = *(void *)((char *)v92 + 4);
            uint64_t v43 = *(unsigned int *)&buf[20];
            uint64_t v45 = *(unsigned int *)&buf[28];
            uint64_t v44 = v90;
            *(void *)(v4 + 120) = *(unsigned int *)&buf[24];
            *(void *)(v4 + 128) = v44;
            *(void *)(v4 + 136) = v43;
            *(void *)(v4 + 144) = v45;
            v46.i64[0] = DWORD1(v90);
            v46.i64[1] = DWORD2(v90);
            *(int8x16_t *)(v4 + 152) = vextq_s8(v46, v46, 8uLL);
            *(_OWORD *)(v4 + 88) = v104;
            *(_OWORD *)(v4 + 104) = v105;
            goto LABEL_199;
          }
          int v29 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          BOOL v30 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)BOOL v86 = 136446722;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 2080;
            *(void *)id v88 = a1 + 404;
            *(_WORD *)&v88[8] = 1024;
            *(_DWORD *)&v88[10] = v29;
            _os_log_impl(&dword_1830D4000, v30, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt TCP_INFO failed %{darwin.errno}d", v86, 0x1Cu);
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          char v31 = gLogObj;
          if (v29 == 102)
          {
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)BOOL v86 = 136446466;
              *(void *)&v86[4] = "nw_socket_copy_info";
              __int16 v87 = 1024;
              *(_DWORD *)id v88 = 102;
              _os_log_impl(&dword_1830D4000, v31, OS_LOG_TYPE_ERROR, "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d", v86, 0x12u);
            }
            goto LABEL_198;
          }
          *(_DWORD *)BOOL v86 = 136446466;
          *(void *)&v86[4] = "nw_socket_copy_info";
          __int16 v87 = 1024;
          *(_DWORD *)id v88 = v29;
          uint64_t v38 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v82 = 0;
          if (!__nwlog_fault(v38, &type, &v82)) {
            goto LABEL_196;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            int v53 = __nwlog_obj();
            os_log_type_t v54 = type;
            if (!os_log_type_enabled(v53, type)) {
              goto LABEL_196;
            }
            *(_DWORD *)BOOL v86 = 136446466;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 1024;
            *(_DWORD *)id v88 = v29;
            int v55 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d";
          }
          else if (v82)
          {
            id v66 = (char *)__nw_create_backtrace_string();
            int v53 = __nwlog_obj();
            os_log_type_t v54 = type;
            BOOL v67 = os_log_type_enabled(v53, type);
            if (v66)
            {
              if (v67)
              {
                *(_DWORD *)BOOL v86 = 136446722;
                *(void *)&v86[4] = "nw_socket_copy_info";
                __int16 v87 = 1024;
                *(_DWORD *)id v88 = v29;
                *(_WORD *)&v88[4] = 2082;
                *(void *)&v88[6] = v66;
                _os_log_impl(&dword_1830D4000, v53, v54, "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s", v86, 0x1Cu);
              }
              free(v66);
              if (!v38) {
                goto LABEL_198;
              }
              goto LABEL_197;
            }
            if (!v67)
            {
LABEL_196:
              if (v38)
              {
LABEL_197:
                free(v38);
                goto LABEL_198;
              }
              goto LABEL_198;
            }
            *(_DWORD *)BOOL v86 = 136446466;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 1024;
            *(_DWORD *)id v88 = v29;
            int v55 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, no backtrace";
          }
          else
          {
            int v53 = __nwlog_obj();
            os_log_type_t v54 = type;
            if (!os_log_type_enabled(v53, type)) {
              goto LABEL_196;
            }
            *(_DWORD *)BOOL v86 = 136446466;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 1024;
            *(_DWORD *)id v88 = v29;
            int v55 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, backtrace limit exceeded";
          }
          _os_log_impl(&dword_1830D4000, v53, v54, v55, v86, 0x12u);
          goto LABEL_196;
        case 6:
          uint64_t v18 = *(void **)(a1 + 160);
          if (!v18) {
            return 0;
          }
          return (uint64_t)os_retain(v18);
        default:
          if (a2 != 254)
          {
            if (a2 != 255) {
              return v4;
            }
            if (*(void *)(a1 + 152))
            {
              uint64_t v4 = nw_array_create();
              nw_array_append(v4, *(void **)(a1 + 152));
              return v4;
            }
            return 0;
          }
          if (*(_DWORD *)(a1 + 272) != 2) {
            return 0;
          }
          if (nw_protocol_setup_tcp_definition(void)::onceToken != -1) {
            dispatch_once(&nw_protocol_setup_tcp_definition(void)::onceToken, &__block_literal_global_64304);
          }
          id v20 = (id)g_tcp_definition;
          id v21 = nw_protocol_establishment_report_create(v20, *(void *)(a1 + 136), *(void *)(a1 + 136));
          if (v20) {
            os_release(v20);
          }
          uint64_t v110 = 0;
          long long v108 = 0u;
          long long v109 = 0u;
          long long v106 = 0u;
          long long v107 = 0u;
          long long v104 = 0u;
          long long v105 = 0u;
          long long v102 = 0u;
          long long v103 = 0u;
          long long v100 = 0u;
          long long v101 = 0u;
          long long v98 = 0u;
          long long v99 = 0u;
          long long v96 = 0u;
          long long v97 = 0u;
          long long v94 = 0u;
          long long v95 = 0u;
          memset(v93, 0, sizeof(v93));
          memset(v92, 0, sizeof(v92));
          long long v90 = 0u;
          long long v91 = 0u;
          memset(buf, 0, sizeof(buf));
          v85[0] = 408;
          if (!getsockopt(*(_DWORD *)(a1 + 268), 6, 512, buf, v85))
          {
            if ((DWORD2(v103) - 2) >= 8) {
              int v35 = 1;
            }
            else {
              int v35 = DWORD2(v103);
            }
            if ((HIDWORD(v103) - 2) >= 9) {
              int v36 = 1;
            }
            else {
              int v36 = HIDWORD(v103);
            }
            nw_protocol_establishment_report_set_client_accurate_ecn_state(v21, v35);
            nw_protocol_establishment_report_set_server_accurate_ecn_state(v21, v36);
LABEL_191:
            uint64_t v4 = nw_array_create();
            nw_array_append(v4, v21);
            if (v21) {
              os_release(v21);
            }
            return v4;
          }
          int v22 = **(_DWORD **)(_ReadStatusReg(ARM64_SYSREG(3, 3, 13, 0, 3)) + 8);
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          os_log_type_t v23 = gconnectionLogObj;
          if (os_log_type_enabled((os_log_t)gconnectionLogObj, OS_LOG_TYPE_ERROR))
          {
            *(_DWORD *)BOOL v86 = 136446722;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 2080;
            *(void *)id v88 = a1 + 404;
            *(_WORD *)&v88[8] = 1024;
            *(_DWORD *)&v88[10] = v22;
            _os_log_impl(&dword_1830D4000, v23, OS_LOG_TYPE_ERROR, "%{public}s %s getsockopt TCP_INFO failed %{darwin.errno}d", v86, 0x1Cu);
          }
          pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
          networkd_settings_init();
          __int16 v24 = gLogObj;
          if (v22 == 102)
          {
            if (os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR))
            {
              *(_DWORD *)BOOL v86 = 136446466;
              *(void *)&v86[4] = "nw_socket_copy_info";
              __int16 v87 = 1024;
              *(_DWORD *)id v88 = 102;
              _os_log_impl(&dword_1830D4000, v24, OS_LOG_TYPE_ERROR, "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d", v86, 0x12u);
            }
            goto LABEL_191;
          }
          *(_DWORD *)BOOL v86 = 136446466;
          *(void *)&v86[4] = "nw_socket_copy_info";
          __int16 v87 = 1024;
          *(_DWORD *)id v88 = v22;
          uint64_t v39 = (char *)_os_log_send_and_compose_impl();
          LOBYTE(v84) = 16;
          os_log_type_t type = OS_LOG_TYPE_DEFAULT;
          if (!__nwlog_fault(v39, &v84, &type)) {
            goto LABEL_189;
          }
          if (v84 == 17)
          {
            char v40 = __nwlog_obj();
            os_log_type_t v41 = v84;
            if (!os_log_type_enabled(v40, (os_log_type_t)v84)) {
              goto LABEL_189;
            }
            *(_DWORD *)BOOL v86 = 136446466;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 1024;
            *(_DWORD *)id v88 = v22;
            id v42 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d";
          }
          else if (type)
          {
            id v60 = (char *)__nw_create_backtrace_string();
            char v40 = __nwlog_obj();
            os_log_type_t v41 = v84;
            BOOL v61 = os_log_type_enabled(v40, (os_log_type_t)v84);
            if (v60)
            {
              if (v61)
              {
                *(_DWORD *)BOOL v86 = 136446722;
                *(void *)&v86[4] = "nw_socket_copy_info";
                __int16 v87 = 1024;
                *(_DWORD *)id v88 = v22;
                *(_WORD *)&v88[4] = 2082;
                *(void *)&v88[6] = v60;
                _os_log_impl(&dword_1830D4000, v40, v41, "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, dumping backtrace:%{public}s", v86, 0x1Cu);
              }
              free(v60);
              goto LABEL_189;
            }
            if (!v61)
            {
LABEL_189:
              if (v39) {
                free(v39);
              }
              goto LABEL_191;
            }
            *(_DWORD *)BOOL v86 = 136446466;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 1024;
            *(_DWORD *)id v88 = v22;
            id v42 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, no backtrace";
          }
          else
          {
            char v40 = __nwlog_obj();
            os_log_type_t v41 = v84;
            if (!os_log_type_enabled(v40, (os_log_type_t)v84)) {
              goto LABEL_189;
            }
            *(_DWORD *)BOOL v86 = 136446466;
            *(void *)&v86[4] = "nw_socket_copy_info";
            __int16 v87 = 1024;
            *(_DWORD *)id v88 = v22;
            id v42 = "%{public}s getsockopt TCP_INFO failed %{darwin.errno}d, backtrace limit exceeded";
          }
          _os_log_impl(&dword_1830D4000, v40, v41, v42, v86, 0x12u);
          goto LABEL_189;
      }
    }
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
    uint64_t v4 = _os_log_send_and_compose_impl();
    v86[0] = 16;
    LOBYTE(v85[0]) = 0;
    if (!__nwlog_fault((const char *)v4, v86, v85)) {
      goto LABEL_213;
    }
    if (v86[0] == 17)
    {
      os_log_type_t v32 = __nwlog_obj();
      os_log_type_t v33 = v86[0];
      if (os_log_type_enabled(v32, (os_log_type_t)v86[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s called with null socket_handler";
        goto LABEL_183;
      }
      goto LABEL_213;
    }
    if (!LOBYTE(v85[0]))
    {
      os_log_type_t v32 = __nwlog_obj();
      os_log_type_t v33 = v86[0];
      if (os_log_type_enabled(v32, (os_log_type_t)v86[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s called with null socket_handler, backtrace limit exceeded";
        goto LABEL_183;
      }
      goto LABEL_213;
    }
    objc_super v56 = __nw_create_backtrace_string();
    os_log_type_t v32 = __nwlog_obj();
    os_log_type_t v33 = v86[0];
    BOOL v73 = os_log_type_enabled(v32, (os_log_type_t)v86[0]);
    if (!v56)
    {
      if (v73)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s called with null socket_handler, no backtrace";
        goto LABEL_183;
      }
      goto LABEL_213;
    }
    if (v73)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v56;
      __int16 v58 = "%{public}s called with null socket_handler, dumping backtrace:%{public}s";
      goto LABEL_146;
    }
    goto LABEL_147;
  }
  __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
  uint64_t v4 = _os_log_send_and_compose_impl();
  v86[0] = 16;
  LOBYTE(v85[0]) = 0;
  if (!__nwlog_fault((const char *)v4, v86, v85)) {
    goto LABEL_213;
  }
  if (v86[0] != 17)
  {
    if (!LOBYTE(v85[0]))
    {
      os_log_type_t v32 = __nwlog_obj();
      os_log_type_t v33 = v86[0];
      if (os_log_type_enabled(v32, (os_log_type_t)v86[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s called with null protocol, backtrace limit exceeded";
        goto LABEL_183;
      }
      goto LABEL_213;
    }
    objc_super v56 = __nw_create_backtrace_string();
    os_log_type_t v32 = __nwlog_obj();
    os_log_type_t v33 = v86[0];
    BOOL v72 = os_log_type_enabled(v32, (os_log_type_t)v86[0]);
    if (!v56)
    {
      if (v72)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
        __int16 v34 = "%{public}s called with null protocol, no backtrace";
        goto LABEL_183;
      }
      goto LABEL_213;
    }
    if (v72)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
      *(_WORD *)&unsigned char buf[12] = 2082;
      *(void *)&buf[14] = v56;
      __int16 v58 = "%{public}s called with null protocol, dumping backtrace:%{public}s";
LABEL_146:
      _os_log_impl(&dword_1830D4000, v32, v33, v58, buf, 0x16u);
    }
LABEL_147:
    int v59 = (char *)v56;
LABEL_212:
    free(v59);
    goto LABEL_213;
  }
  os_log_type_t v32 = __nwlog_obj();
  os_log_type_t v33 = v86[0];
  if (os_log_type_enabled(v32, (os_log_type_t)v86[0]))
  {
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_socket_copy_info";
    __int16 v34 = "%{public}s called with null protocol";
LABEL_183:
    _os_log_impl(&dword_1830D4000, v32, v33, v34, buf, 0xCu);
  }
LABEL_213:
  if (v4) {
    free((void *)v4);
  }
  return 0;
}

uint64_t nw_protocol_default_copy_info(uint64_t a1)
{
  uint64_t v17 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v14 = "nw_protocol_default_copy_info";
    id v5 = (char *)_os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v11 = 0;
    if (!__nwlog_fault(v5, &type, &v11)) {
      goto LABEL_22;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v14 = "nw_protocol_default_copy_info";
      id v8 = "%{public}s called with null protocol";
    }
    else if (v11)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      BOOL v10 = os_log_type_enabled(v6, type);
      if (backtrace_string)
      {
        if (v10)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          char v14 = "nw_protocol_default_copy_info";
          __int16 v15 = 2082;
          uint64_t v16 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v6, v7, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
        }
        free(backtrace_string);
        goto LABEL_22;
      }
      if (!v10)
      {
LABEL_22:
        if (v5) {
          free(v5);
        }
        return 0;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v14 = "nw_protocol_default_copy_info";
      id v8 = "%{public}s called with null protocol, no backtrace";
    }
    else
    {
      int v6 = __nwlog_obj();
      os_log_type_t v7 = type;
      if (!os_log_type_enabled(v6, type)) {
        goto LABEL_22;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v14 = "nw_protocol_default_copy_info";
      id v8 = "%{public}s called with null protocol, backtrace limit exceeded";
    }
    _os_log_impl(&dword_1830D4000, v6, v7, v8, buf, 0xCu);
    goto LABEL_22;
  }
  uint64_t v1 = *(void *)(a1 + 32);
  if (!v1) {
    return 0;
  }
  uint64_t v2 = *(void *)(v1 + 24);
  if (!v2) {
    return 0;
  }
  id v3 = *(uint64_t (**)(void))(v2 + 224);
  if (!v3) {
    return 0;
  }

  return v3();
}

uint64_t nw_parameters_get_sleep_keepalive_interval(void *a1)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  uint64_t v1 = a1;
  uint64_t v2 = v1;
  if (v1)
  {
    uint64_t v3 = v1[22];
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v16 = "nw_parameters_get_sleep_keepalive_interval";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null parameters", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v16 = "nw_parameters_get_sleep_keepalive_interval";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null parameters, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_parameters_get_sleep_keepalive_interval";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null parameters, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
  uint64_t v3 = 0;
LABEL_3:

  return v3;
}

void nw_protocol_establishment_report_set_client_accurate_ecn_state(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 6) = a2;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_protocol_establishment_report_set_client_accurate_ecn_state";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

void nw_protocol_establishment_report_set_server_accurate_ecn_state(void *a1, int a2)
{
  uint64_t v19 = *MEMORY[0x1E4F143B8];
  id v3 = a1;
  uint64_t v4 = v3;
  if (v3)
  {
    *((_DWORD *)v3 + 7) = a2;
    goto LABEL_3;
  }
  id v5 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  uint64_t v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
  int v6 = (char *)_os_log_send_and_compose_impl();

  os_log_type_t type = OS_LOG_TYPE_ERROR;
  char v13 = 0;
  if (__nwlog_fault(v6, &type, &v13))
  {
    if (type == OS_LOG_TYPE_FAULT)
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v8 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
        _os_log_impl(&dword_1830D4000, v7, v8, "%{public}s called with null report", buf, 0xCu);
      }
    }
    else if (v13)
    {
      backtrace_string = (char *)__nw_create_backtrace_string();
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v10 = type;
      BOOL v11 = os_log_type_enabled(v7, type);
      if (backtrace_string)
      {
        if (v11)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          uint64_t v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
          __int16 v17 = 2082;
          uint64_t v18 = backtrace_string;
          _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(backtrace_string);
        goto LABEL_20;
      }
      if (v11)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
        _os_log_impl(&dword_1830D4000, v7, v10, "%{public}s called with null report, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      os_log_type_t v7 = __nwlog_obj();
      os_log_type_t v12 = type;
      if (os_log_type_enabled(v7, type))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        uint64_t v16 = "nw_protocol_establishment_report_set_server_accurate_ecn_state";
        _os_log_impl(&dword_1830D4000, v7, v12, "%{public}s called with null report, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_20:
  if (v6) {
    free(v6);
  }
LABEL_3:
}

uint64_t nw_flow_passthrough_remove_input_handler(nw_protocol *a1, nw_protocol *a2)
{
  uint64_t v36 = *MEMORY[0x1E4F143B8];
  if (!a1)
  {
    id v20 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    char v31 = "nw_flow_passthrough_remove_input_handler";
    id v21 = (char *)_os_log_send_and_compose_impl();

    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v28 = 0;
    if (__nwlog_fault(v21, &type, &v28))
    {
      if (type == OS_LOG_TYPE_FAULT)
      {
        int v22 = __nwlog_obj();
        os_log_type_t v23 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          char v31 = "nw_flow_passthrough_remove_input_handler";
          _os_log_impl(&dword_1830D4000, v22, v23, "%{public}s called with null protocol", buf, 0xCu);
        }
      }
      else if (v28)
      {
        backtrace_string = (char *)__nw_create_backtrace_string();
        int v22 = __nwlog_obj();
        os_log_type_t v25 = type;
        BOOL v26 = os_log_type_enabled(v22, type);
        if (backtrace_string)
        {
          if (v26)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            char v31 = "nw_flow_passthrough_remove_input_handler";
            __int16 v32 = 2082;
            os_log_type_t v33 = backtrace_string;
            _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null protocol, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(backtrace_string);
          goto LABEL_47;
        }
        if (v26)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          char v31 = "nw_flow_passthrough_remove_input_handler";
          _os_log_impl(&dword_1830D4000, v22, v25, "%{public}s called with null protocol, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        int v22 = __nwlog_obj();
        os_log_type_t v27 = type;
        if (os_log_type_enabled(v22, type))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          char v31 = "nw_flow_passthrough_remove_input_handler";
          _os_log_impl(&dword_1830D4000, v22, v27, "%{public}s called with null protocol, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_47:
    if (v21) {
      free(v21);
    }
    return 0;
  }
  if (a2 && a2->output_handler == a1) {
    nw_protocol_set_output_handler((uint64_t)a2, 0);
  }
  if (a1->default_input_handler != a2) {
    return 0;
  }
  nw_protocol_set_input_handler((uint64_t)a1, 0);
  char handle = (id *)a1->handle;
  if (!handle)
  {
    os_log_type_t v12 = 0;
    goto LABEL_24;
  }
  id v6 = handle[20];
  os_log_type_t v7 = v6;
  if (v6)
  {
    os_log_type_t v8 = (NWConcrete_nw_endpoint_handler *)v6;
    uint64_t mode = v8->mode;

    if (mode == 2)
    {
      os_log_type_t v10 = nw_endpoint_handler_copy_flow(v8);
      BOOL v11 = v10;
      if (v10 && *((char *)v10 + 35) < 0)
      {
        nw_endpoint_flow_failed_with_error(v8, 1, handle[40]);
        os_log_type_t v12 = v8;
      }
      else
      {
        os_log_type_t v12 = 0;
      }

      goto LABEL_23;
    }
    pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
    networkd_settings_init();
    char v13 = (id)gLogObj;
    if (os_log_type_enabled(v13, OS_LOG_TYPE_DEFAULT))
    {
      if (mode > 5) {
        char v14 = "unknown-mode";
      }
      else {
        char v14 = off_1E523FB08[mode];
      }
      *(_DWORD *)unsigned int buf = 136446722;
      char v31 = "nw_flow_passthrough_fail_if_needed";
      __int16 v32 = 2082;
      os_log_type_t v33 = (void *)v14;
      __int16 v34 = 2082;
      int v35 = "flow";
      _os_log_impl(&dword_1830D4000, v13, OS_LOG_TYPE_DEFAULT, "%{public}s Handler is in mode %{public}s, expected %{public}s", buf, 0x20u);
    }
  }
  os_log_type_t v12 = 0;
LABEL_23:

LABEL_24:
  output_handler = a1->output_handler;
  if (output_handler)
  {
    callbacks = output_handler->callbacks;
    if (callbacks)
    {
      remove_input_handler = (void (*)(void))callbacks->remove_input_handler;
      if (remove_input_handler) {
        remove_input_handler();
      }
    }
  }
  uint64_t v18 = a1->handle;
  if (v18)
  {
    uint64_t v19 = (void *)v18[21];
    v18[21] = 0;
  }
  return 1;
}

void sub_1831E964C(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void sub_1831E9668(_Unwind_Exception *a1)
{
  _Unwind_Resume(a1);
}

void nw_endpoint_flow_failed_with_error(void *a1, int a2, void *a3)
{
  uint64_t v377 = *MEMORY[0x1E4F143B8];
  uint64_t v4 = a1;
  id v354 = a3;
  int v355 = v4;
  if (v4)
  {
    id v5 = nw_endpoint_handler_copy_flow(v4);
    id v6 = v5;
    if (v5)
    {
      if ((*((unsigned char *)v5 + 36) & 2) != 0)
      {
        os_log_type_t v12 = v4;
        char v13 = *((unsigned char *)v12 + 268);

        if ((v13 & 0x20) == 0)
        {
          if (__nwlog_connection_log::onceToken != -1) {
            dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
          }
          char v14 = (id)gconnectionLogObj;
          if (os_log_type_enabled(v14, OS_LOG_TYPE_ERROR))
          {
            __int16 v15 = v12;

            uint64_t v16 = v15;
            char v17 = *((unsigned char *)v12 + 268);

            if (v17) {
              uint64_t v18 = "dry-run ";
            }
            else {
              uint64_t v18 = "";
            }
            nw_endpoint_t v19 = nw_endpoint_handler_copy_endpoint(v16);
            logging_description = nw_endpoint_get_logging_description(v19);
            id_str = v15->id_str;
            int v22 = v16;
            os_log_type_t v23 = v22;
            uint64_t v24 = v22[30];
            if (v24 > 5) {
              os_log_type_t v25 = "unknown-state";
            }
            else {
              os_log_type_t v25 = off_1E523FB38[v24];
            }
            v352 = v25;

            BOOL v26 = v23;
            os_log_type_t v27 = v26;
            char v28 = "path";
            switch(*((_DWORD *)v26 + 29))
            {
              case 0:
                break;
              case 1:
                char v28 = "resolver";
                break;
              case 2:
                char v28 = nw_endpoint_flow_mode_string(v26[31]);
                break;
              case 3:
                char v28 = "proxy";
                break;
              case 4:
                char v28 = "fallback";
                break;
              case 5:
                char v28 = "transform";
                break;
              default:
                char v28 = "unknown-mode";
                break;
            }

            os_log_type_t v65 = v27;
            os_unfair_lock_lock((os_unfair_lock_t)v65 + 28);
            id v66 = v65[8];
            os_unfair_lock_unlock((os_unfair_lock_t)v65 + 28);

            *(_DWORD *)unsigned int buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
            __int16 v363 = 2082;
            v364 = id_str;
            __int16 v365 = 2082;
            v366 = v18;
            __int16 v367 = 2082;
            uint64_t v368 = (void *)logging_description;
            __int16 v369 = 2082;
            v370 = v352;
            __int16 v371 = 2082;
            v372 = v28;
            __int16 v373 = 2114;
            id v374 = v66;
            _os_log_impl(&dword_1830D4000, v14, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] already failing, returning", buf, 0x48u);
          }
        }
        goto LABEL_337;
      }
      os_log_type_t v7 = (const char *)*((void *)v5 + 51);
      *((unsigned char *)v5 + 36) |= 2u;
      if (*((_DWORD *)v5 + 206))
      {
        if (v7)
        {
          uint64_t v8 = *((void *)v7 + 3);
          if (v8)
          {
            BOOL v9 = *(uint64_t (**)(const char *, uint64_t, os_log_type_t *))(v8 + 224);
            if (v9)
            {
              *(void *)os_log_type_t type = 0;
              os_log_type_t v10 = (void *)*((void *)v7 + 5);
              if (v10 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v29 = *((void *)v7 + 11);
                if (v29) {
                  *((void *)v7 + 11) = v29 + 1;
                }
                char v11 = -1;
              }
              else
              {
                char v11 = 0;
              }
              *(void *)unsigned int buf = v7;
              uint8_t buf[8] = v11;
              uint64_t v30 = v9(v7, 5, type);
              if (v10 == &nw_protocol_ref_counted_handle) {
                nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              }
              if (v30)
              {
                char v31 = (void *)*((void *)v6 + 101);
                if (v31)
                {
                  free(v31);
                  *((void *)v6 + 101) = 0;
                }
                *((void *)v6 + 101) = v30;
                *((void *)v6 + 102) = *(void *)type;
              }
            }
          }
        }
      }
      __int16 v32 = (void *)*((void *)v6 + 104);
      if (v32)
      {
        BOOL v33 = nw_path_flow_registration_copy_path(v32);
        lock = (os_unfair_lock_s *)((char *)v6 + 880);
        os_unfair_lock_lock((os_unfair_lock_t)v6 + 220);
        if (!v33)
        {
          os_log_t v348 = 0;
          if (!*((void *)v6 + 90))
          {
LABEL_71:
            os_unfair_lock_unlock(lock);
            uint64_t v49 = (os_unfair_lock_s *)*((void *)v6 + 108);
            if (v49)
            {
              _nw_hash_table_release(v49);
              *((void *)v6 + 108) = 0;
            }
            if (*((void *)v6 + 53))
            {
              if (nw_endpoint_handler_get_minimize_logging(v355))
              {
                if (nw_endpoint_handler_get_logging_disabled(v355)) {
                  goto LABEL_103;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v52 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v52, OS_LOG_TYPE_DEBUG))
                {
                  id_string = nw_endpoint_handler_get_id_string(v355);
                  unsigned int v287 = nw_endpoint_handler_dry_run_string(v355);
                  nw_endpoint_t v288 = nw_endpoint_handler_copy_endpoint(v355);
                  v289 = nw_endpoint_get_logging_description(v288);
                  int v290 = nw_endpoint_handler_state_string(v355);
                  uint64_t v291 = nw_endpoint_handler_mode_string(v355);
                  id v292 = nw_endpoint_handler_copy_current_path(v355);
                  *(_DWORD *)unsigned int buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                  __int16 v363 = 2082;
                  v364 = (void *)id_string;
                  __int16 v365 = 2082;
                  v366 = v287;
                  __int16 v367 = 2082;
                  uint64_t v368 = (void *)v289;
                  __int16 v369 = 2082;
                  v370 = v290;
                  __int16 v371 = 2082;
                  v372 = v291;
                  __int16 v373 = 2114;
                  id v374 = v292;
                  _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Passthrough flow with an input handler should not fail on its own", buf, 0x48u);
                }
                goto LABEL_102;
              }
              id v50 = v355;
              BOOL v51 = (*((unsigned char *)v50 + 268) & 0x20) == 0;

              if (v51)
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                uint64_t v52 = (id)gconnectionLogObj;
                if (os_log_type_enabled(v52, OS_LOG_TYPE_DEFAULT))
                {
                  int v53 = v50;

                  os_log_type_t v54 = v53;
                  BOOL v55 = (*((unsigned char *)v50 + 268) & 1) == 0;

                  if (v55) {
                    objc_super v56 = "";
                  }
                  else {
                    objc_super v56 = "dry-run ";
                  }
                  nw_endpoint_t v57 = nw_endpoint_handler_copy_endpoint(v54);
                  __int16 v58 = nw_endpoint_get_logging_description(v57);
                  int v59 = v54;
                  id v60 = v59;
                  uint64_t v61 = v59[30];
                  if (v61 > 5) {
                    os_log_type_t v62 = "unknown-state";
                  }
                  else {
                    os_log_type_t v62 = off_1E523FB38[v61];
                  }
                  os_log_t log = v62;

                  uint64_t v63 = v60;
                  os_log_type_t v64 = "path";
                  switch(*((_DWORD *)v63 + 29))
                  {
                    case 0:
                      break;
                    case 1:
                      os_log_type_t v64 = "resolver";
                      break;
                    case 2:
                      os_log_type_t v64 = nw_endpoint_flow_mode_string(v63[31]);
                      break;
                    case 3:
                      os_log_type_t v64 = "proxy";
                      break;
                    case 4:
                      os_log_type_t v64 = "fallback";
                      break;
                    case 5:
                      os_log_type_t v64 = "transform";
                      break;
                    default:
                      os_log_type_t v64 = "unknown-mode";
                      break;
                  }
                  unsigned int v337 = v64;

                  BOOL v67 = v63;
                  uint64_t v68 = v53;
                  os_unfair_lock_lock((os_unfair_lock_t)v67 + 28);
                  id v69 = v67[8];
                  os_unfair_lock_unlock((os_unfair_lock_t)v67 + 28);

                  id v70 = v69;
                  *(_DWORD *)unsigned int buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                  __int16 v363 = 2082;
                  v364 = v68->id_str;
                  __int16 v365 = 2082;
                  v366 = v56;
                  __int16 v367 = 2082;
                  uint64_t v368 = (void *)v58;
                  __int16 v369 = 2082;
                  v370 = log;
                  __int16 v371 = 2082;
                  v372 = v337;
                  __int16 v373 = 2114;
                  id v374 = v70;
                  _os_log_impl(&dword_1830D4000, v52, OS_LOG_TYPE_DEFAULT, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Passthrough flow with an input handler should not fail on its own", buf, 0x48u);
                }
LABEL_102:
              }
            }
LABEL_103:
            if (v7)
            {
              uint64_t v71 = *((void *)v7 + 3);
              if (v71)
              {
                BOOL v72 = *(void (**)(const char *, char *, uint64_t))(v71 + 8);
                if (v72)
                {
                  BOOL v73 = (void *)*((void *)v7 + 5);
                  if (v73 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v75 = *((void *)v7 + 11);
                    if (v75) {
                      *((void *)v7 + 11) = v75 + 1;
                    }
                    *(void *)unsigned int buf = v7;
                    char v74 = buf[8] | 1;
                  }
                  else
                  {
                    *(void *)unsigned int buf = v7;
                    char v74 = buf[8] & 0xFE;
                  }
                  uint8_t buf[8] = v74;
                  id v76 = (void *)*((void *)v6 + 52);
                  if (v76 == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v78 = *((void *)v6 + 58);
                    if (v78) {
                      *((void *)v6 + 58) = v78 + 1;
                    }
                    *(void *)os_log_type_t type = (char *)v6 + 376;
                    char v77 = v361 | 1;
                  }
                  else
                  {
                    *(void *)os_log_type_t type = (char *)v6 + 376;
                    char v77 = v361 & 0xFE;
                  }
                  char v361 = v77;
                  v72(v7, (char *)v6 + 376, 1);
                  if (v76 == &nw_protocol_ref_counted_handle)
                  {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                    if (v73 != &nw_protocol_ref_counted_handle) {
                      goto LABEL_118;
                    }
                  }
                  else if (v73 != &nw_protocol_ref_counted_handle)
                  {
                    goto LABEL_118;
                  }
                  nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
                }
              }
            }
LABEL_118:
            uint64_t v79 = *((void *)v6 + 65);
            unint64_t v80 = *((void *)v6 + 63);
            if (!(v79 | v80)) {
              goto LABEL_286;
            }
            BOOL v81 = (char *)v6 + 472;
            if (v79 && v80)
            {
              uint64_t v82 = *(void *)(v80 + 24);
              if (!v82
                || (uint32_t v83 = *(uint64_t (**)(unint64_t, char *))(v82 + 16)) == 0
                || *(char **)(v80 + 48) != v81)
              {
                socklen_t v84 = v355;
                BOOL v85 = (*((unsigned char *)v84 + 268) & 0x20) == 0;

                if (v85)
                {
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  BOOL v86 = (id)gconnectionLogObj;
                  if (os_log_type_enabled(v86, OS_LOG_TYPE_ERROR))
                  {
                    __int16 v87 = v84;

                    id v88 = v87;
                    BOOL v89 = (*((unsigned char *)v84 + 268) & 1) == 0;

                    if (v89) {
                      long long v90 = "";
                    }
                    else {
                      long long v90 = "dry-run ";
                    }
                    nw_endpoint_t v91 = nw_endpoint_handler_copy_endpoint(v88);
                    char v92 = nw_endpoint_get_logging_description(v91);
                    char v93 = v88;
                    long long v94 = v93;
                    uint64_t v95 = v93[30];
                    if (v95 > 5) {
                      long long v96 = "unknown-state";
                    }
                    else {
                      long long v96 = off_1E523FB38[v95];
                    }

                    uint64_t v115 = v94;
                    int v116 = "path";
                    switch(*((_DWORD *)v115 + 29))
                    {
                      case 0:
                        break;
                      case 1:
                        int v116 = "resolver";
                        break;
                      case 2:
                        int v116 = nw_endpoint_flow_mode_string(v115[31]);
                        break;
                      case 3:
                        int v116 = "proxy";
                        break;
                      case 4:
                        int v116 = "fallback";
                        break;
                      case 5:
                        int v116 = "transform";
                        break;
                      default:
                        int v116 = "unknown-mode";
                        break;
                    }
                    logg = v116;

                    v195 = v86;
                    uint64_t v196 = v115;
                    unsigned int v197 = v87;
                    os_unfair_lock_lock((os_unfair_lock_t)v196 + 28);
                    id v198 = v196[8];
                    os_unfair_lock_unlock((os_unfair_lock_t)v196 + 28);

                    id v199 = v198;
                    *(_DWORD *)unsigned int buf = 136447746;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                    __int16 v363 = 2082;
                    v364 = v197->id_str;
                    BOOL v86 = v195;
                    __int16 v365 = 2082;
                    v366 = v90;
                    __int16 v367 = 2082;
                    uint64_t v368 = (void *)v92;
                    __int16 v369 = 2082;
                    v370 = v96;
                    __int16 v371 = 2082;
                    v372 = logg;
                    __int16 v373 = 2114;
                    id v374 = v199;
                    _os_log_impl(&dword_1830D4000, v195, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Replay protocol output handler cannot handle replace_input_handler", buf, 0x48u);
                  }
                }
                goto LABEL_286;
              }
              uint64_t v112 = *(void **)(v79 + 32);
              id v113 = *(void **)(v80 + 40);
              if (v113 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v167 = *(void *)(v80 + 88);
                if (v167) {
                  *(void *)(v80 + 88) = v167 + 1;
                }
                *(void *)unsigned int buf = v80;
                char v114 = buf[8] | 1;
              }
              else
              {
                *(void *)unsigned int buf = *((void *)v6 + 63);
                char v114 = buf[8] & 0xFE;
              }
              uint8_t buf[8] = v114;
              v168 = (void *)*((void *)v6 + 64);
              if (v168 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v170 = *((void *)v6 + 70);
                if (v170) {
                  *((void *)v6 + 70) = v170 + 1;
                }
                *(void *)os_log_type_t type = (char *)v6 + 472;
                char v169 = v361 | 1;
              }
              else
              {
                *(void *)os_log_type_t type = (char *)v6 + 472;
                char v169 = v361 & 0xFE;
              }
              char v361 = v169;
              __int16 v171 = *(void **)(v79 + 40);
              if (v171 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v173 = *(void *)(v79 + 88);
                if (v173) {
                  *(void *)(v79 + 88) = v173 + 1;
                }
                uint64_t v358 = v79;
                char v172 = v359 | 1;
              }
              else
              {
                uint64_t v358 = v79;
                char v172 = v359 & 0xFE;
              }
              char v359 = v172;
              __int16 v174 = (void *)v80;
              uint64_t v175 = v79;
              int v176 = v83(v80, v81);
              if (v171 == &nw_protocol_ref_counted_handle)
              {
                nw::release_if_needed<nw_protocol *>(&v358);
                if (v168 != &nw_protocol_ref_counted_handle)
                {
LABEL_201:
                  if (v113 != &nw_protocol_ref_counted_handle) {
                    goto LABEL_202;
                  }
                  goto LABEL_220;
                }
              }
              else if (v168 != &nw_protocol_ref_counted_handle)
              {
                goto LABEL_201;
              }
              nw::release_if_needed<nw_protocol *>((uint64_t *)type);
              if (v113 != &nw_protocol_ref_counted_handle)
              {
LABEL_202:
                if (v176) {
                  goto LABEL_203;
                }
                goto LABEL_221;
              }
LABEL_220:
              nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
              if (v176)
              {
LABEL_203:
                __int16 v177 = (void *)*((void *)v6 + 63);
                if (v177)
                {
                  nw_protocol_release(v177);
                  *((void *)v6 + 63) = 0;
                }
                uint64_t v178 = (void *)*((void *)v6 + 65);
                if (v178)
                {
                  nw_protocol_release(v178);
                  *((void *)v6 + 65) = 0;
                }
                os_log_type_t v179 = (const char *)v175;
                __int16 v180 = *(void **)(v175 + 32);
                if (v180) {
                  BOOL v181 = v180 == v112;
                }
                else {
                  BOOL v181 = 1;
                }
                uint64_t v182 = (uint64_t)v174;
                if (v181 && v180 != v174)
                {
                  nw_protocol_release(v180);
                  os_log_type_t v179 = (const char *)v175;
                  uint64_t v182 = (uint64_t)v174;
                  *(void *)(v175 + 32) = v174;
                  if ((_UNKNOWN *)v174[5] == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v183 = v174[11];
                    if (v183) {
                      v174[11] = v183 + 1;
                    }
                  }
                }
                __int16 v184 = (void *)*((void *)v179 + 5);
                v185 = v355;
                if (v184 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v200 = *((void *)v179 + 11);
                  if (v200) {
                    *((void *)v179 + 11) = v200 + 1;
                  }
                  *(void *)os_log_type_t type = v179;
                  char v186 = v361 | 1;
                }
                else
                {
                  *(void *)os_log_type_t type = v179;
                  char v186 = v361 & 0xFE;
                }
                char v361 = v186;
                v201 = *(void **)(v182 + 40);
                if (v201 == &nw_protocol_ref_counted_handle)
                {
                  uint64_t v203 = *(void *)(v182 + 88);
                  if (v203) {
                    *(void *)(v182 + 88) = v203 + 1;
                  }
                  uint64_t v358 = v182;
                  char v202 = v359 | 1;
                }
                else
                {
                  uint64_t v358 = v182;
                  char v202 = v359 & 0xFE;
                }
                char v359 = v202;
                uint64_t v204 = *((void *)v179 + 3);
                if (v204)
                {
                  uint64_t v205 = *(void (**)(const char *))(v204 + 160);
                  if (v205)
                  {
                    v205(v179);
                    if (v201 != &nw_protocol_ref_counted_handle) {
                      goto LABEL_246;
                    }
                    goto LABEL_245;
                  }
                }
                os_log_type_t v313 = v179;
                BOOL v314 = __nwlog_obj();
                v315 = (const char *)*((void *)v313 + 2);
                *(_DWORD *)unsigned int buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                if (!v315) {
                  v315 = "invalid";
                }
                __int16 v363 = 2082;
                v364 = (void *)v315;
                __int16 v365 = 2048;
                v366 = v313;
                os_log_type_t v316 = (char *)_os_log_send_and_compose_impl();

                os_log_type_t v357 = OS_LOG_TYPE_ERROR;
                char v356 = 0;
                if (__nwlog_fault(v316, &v357, &v356))
                {
                  if (v357 == OS_LOG_TYPE_FAULT)
                  {
                    BOOL v317 = __nwlog_obj();
                    os_log_type_t v318 = v357;
                    if (os_log_type_enabled(v317, v357))
                    {
                      BOOL v319 = *(const char **)(v175 + 16);
                      if (!v319) {
                        BOOL v319 = "invalid";
                      }
                      *(_DWORD *)unsigned int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                      __int16 v363 = 2082;
                      v364 = (void *)v319;
                      __int16 v365 = 2048;
                      v366 = (const char *)v175;
                      _os_log_impl(&dword_1830D4000, v317, v318, "%{public}s protocol %{public}s (%p) has invalid notify callback", buf, 0x20u);
                    }
LABEL_463:

                    goto LABEL_464;
                  }
                  if (!v356)
                  {
                    BOOL v317 = __nwlog_obj();
                    os_log_type_t v327 = v357;
                    if (os_log_type_enabled(v317, v357))
                    {
                      os_log_type_t v328 = *(const char **)(v175 + 16);
                      if (!v328) {
                        os_log_type_t v328 = "invalid";
                      }
                      *(_DWORD *)unsigned int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                      __int16 v363 = 2082;
                      v364 = (void *)v328;
                      __int16 v365 = 2048;
                      v366 = (const char *)v175;
                      _os_log_impl(&dword_1830D4000, v317, v327, "%{public}s protocol %{public}s (%p) has invalid notify callback, backtrace limit exceeded", buf, 0x20u);
                    }
                    goto LABEL_463;
                  }
                  backtrace_string = (char *)__nw_create_backtrace_string();
                  BOOL v317 = __nwlog_obj();
                  os_log_type_t v324 = v357;
                  BOOL v325 = os_log_type_enabled(v317, v357);
                  if (!backtrace_string)
                  {
                    if (v325)
                    {
                      os_log_type_t v329 = *(const char **)(v175 + 16);
                      if (!v329) {
                        os_log_type_t v329 = "invalid";
                      }
                      *(_DWORD *)unsigned int buf = 136446722;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                      __int16 v363 = 2082;
                      v364 = (void *)v329;
                      __int16 v365 = 2048;
                      v366 = (const char *)v175;
                      _os_log_impl(&dword_1830D4000, v317, v324, "%{public}s protocol %{public}s (%p) has invalid notify callback, no backtrace", buf, 0x20u);
                    }
                    goto LABEL_463;
                  }
                  if (v325)
                  {
                    id v326 = *(const char **)(v175 + 16);
                    if (!v326) {
                      id v326 = "invalid";
                    }
                    *(_DWORD *)unsigned int buf = 136446978;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_notify";
                    __int16 v363 = 2082;
                    v364 = (void *)v326;
                    __int16 v365 = 2048;
                    v366 = (const char *)v175;
                    __int16 v367 = 2082;
                    uint64_t v368 = backtrace_string;
                    _os_log_impl(&dword_1830D4000, v317, v324, "%{public}s protocol %{public}s (%p) has invalid notify callback, dumping backtrace:%{public}s", buf, 0x2Au);
                  }

                  free(backtrace_string);
                }
LABEL_464:
                if (v316) {
                  free(v316);
                }
                v185 = v355;
                if (v201 != &nw_protocol_ref_counted_handle)
                {
LABEL_246:
                  if (v184 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
                  if ((nw_endpoint_handler_get_logging_disabled(v185) & 1) == 0)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    id v187 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v187, OS_LOG_TYPE_DEBUG))
                    {
                      id v206 = nw_endpoint_handler_get_id_string(v355);
                      id v207 = nw_endpoint_handler_dry_run_string(v355);
                      nw_endpoint_t v208 = nw_endpoint_handler_copy_endpoint(v355);
                      uint32_t v209 = nw_endpoint_get_logging_description(v208);
                      BOOL v210 = nw_endpoint_handler_state_string(v355);
                      v211 = nw_endpoint_handler_mode_string(v355);
                      id v212 = nw_endpoint_handler_copy_current_path(v355);
                      *(_DWORD *)unsigned int buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                      __int16 v363 = 2082;
                      v364 = (void *)v206;
                      __int16 v365 = 2082;
                      v366 = v207;
                      __int16 v367 = 2082;
                      uint64_t v368 = (void *)v209;
                      __int16 v369 = 2082;
                      v370 = v210;
                      __int16 v371 = 2082;
                      v372 = v211;
                      __int16 v373 = 2114;
                      id v374 = v212;
                      _os_log_impl(&dword_1830D4000, v187, OS_LOG_TYPE_DEBUG, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Removed replay protocol from the stack on cancellation", buf, 0x48u);
                    }
LABEL_226:
                  }
LABEL_286:
                  if ((*((unsigned char *)v6 + 33) & 0x40) != 0)
                  {
                    uint64_t v228 = (void *)*((void *)v6 + 113);
                    *((void *)v6 + 113) = 0;
                  }
                  else
                  {
                    if (*((void *)v6 + 114)) {
                      *((void *)v6 + 114) = 0;
                    }
                    os_unfair_lock_lock(lock);
                    id v227 = (_DNSServiceRef_t *)*((void *)v6 + 115);
                    if (v227)
                    {
                      DNSServiceRefDeallocate(v227);
                      *((void *)v6 + 115) = 0;
                    }
                    os_unfair_lock_unlock(lock);
                  }
                  *((unsigned char *)v6 + 32) &= 0x2Fu;
                  unint64_t v229 = (void *)*((void *)v6 + 104);
                  *((void *)v6 + 104) = 0;

                  *((_OWORD *)v6 + 46) = 0u;
                  char v230 = *((unsigned char *)v6 + 33);
                  *((unsigned char *)v6 + 33) = v230 & 0xFE;
                  *((void *)v6 + 94) = 0;
                  if ((v230 & 4) != 0)
                  {
                    id v231 = v355;
                    id v232 = v231[7];

                    if (v232) {
                      nw_association_mark_flow_disconnected(v232, v231);
                    }
                    *((unsigned char *)v6 + 33) &= ~4u;
                  }
                  BOOL v233 = (void *)*((void *)v6 + 67);
                  if (v233)
                  {
                    *((void *)v6 + 67) = 0;
                  }
                  *((_WORD *)v6 + 354) &= ~1u;
                  id v234 = (void *)*((void *)v6 + 3);
                  *((void *)v6 + 3) = 0;

                  if (!a2) {
                    goto LABEL_336;
                  }
                  id v235 = v355;
                  int state = v235->state;

                  if (state == 5) {
                    goto LABEL_336;
                  }
                  uint64_t v237 = v354;
                  if (!v354) {
                    uint64_t v237 = (void *)*((void *)v6 + 109);
                  }
                  id v353 = v237;
                  uint64_t v238 = *((void *)v6 + 5);
                  if ((*((unsigned char *)v6 + 33) & 8) != 0)
                  {
                    if (!v238)
                    {
LABEL_334:
                      v265 = v235;
                      v235->int state = 4;

                      __int16 v240 = 10;
                      uint64_t v239 = v353;
                      goto LABEL_335;
                    }
                  }
                  else if (!v238)
                  {
                    uint64_t v239 = v353;
                    nw_endpoint_handler_handle_failure(v235);
                    __int16 v240 = 7;
LABEL_335:
                    v235->event.domain = 3;
                    v235->event.event = v240;
                    nw_endpoint_handler_report(v235, 0, &v235->event.domain, v239);

LABEL_336:
                    *((unsigned char *)v6 + 36) &= ~2u;

LABEL_337:
                    goto LABEL_338;
                  }
                  uint64_t v241 = v235;
                  BOOL v242 = (*((unsigned char *)v241 + 268) & 0x20) == 0;

                  if (v242)
                  {
                    if (__nwlog_connection_log::onceToken != -1) {
                      dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                    }
                    uint64_t v243 = (id)gconnectionLogObj;
                    if (os_log_type_enabled(v243, OS_LOG_TYPE_ERROR))
                    {
                      int v244 = v241;

                      long long v245 = v244;
                      BOOL v246 = (*((unsigned char *)v241 + 268) & 1) == 0;

                      if (v246) {
                        os_log_type_t v247 = "";
                      }
                      else {
                        os_log_type_t v247 = "dry-run ";
                      }
                      nw_endpoint_t v248 = nw_endpoint_handler_copy_endpoint(v245);
                      int v249 = nw_endpoint_get_logging_description(v248);
                      v250 = v245;
                      id v251 = v250;
                      uint64_t v252 = v235->state;
                      os_unfair_lock_t locka = (os_unfair_lock_t)v249;
                      if (v252 > 5) {
                        v253 = "unknown-state";
                      }
                      else {
                        v253 = off_1E523FB38[v252];
                      }
                      os_log_type_t logc = v253;

                      id v254 = v251;
                      v255 = v254;
                      uint64_t v256 = "path";
                      switch(*((_DWORD *)v254 + 29))
                      {
                        case 0:
                          break;
                        case 1:
                          uint64_t v256 = "resolver";
                          break;
                        case 2:
                          uint64_t v256 = nw_endpoint_flow_mode_string(v254[31]);
                          break;
                        case 3:
                          uint64_t v256 = "proxy";
                          break;
                        case 4:
                          uint64_t v256 = "fallback";
                          break;
                        case 5:
                          uint64_t v256 = "transform";
                          break;
                        default:
                          uint64_t v256 = "unknown-mode";
                          break;
                      }

                      int v261 = v244;
                      v262 = v255;
                      os_unfair_lock_lock((os_unfair_lock_t)v262 + 28);
                      id v263 = v262[8];
                      os_unfair_lock_unlock((os_unfair_lock_t)v262 + 28);

                      id v264 = v263;
                      *(_DWORD *)unsigned int buf = 136447746;
                      *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                      __int16 v363 = 2082;
                      v364 = v261->id_str;
                      __int16 v365 = 2082;
                      v366 = v247;
                      __int16 v367 = 2082;
                      uint64_t v368 = locka;
                      __int16 v369 = 2082;
                      v370 = logc;
                      __int16 v371 = 2082;
                      v372 = v256;
                      __int16 v373 = 2114;
                      id v374 = v264;
                      _os_log_impl(&dword_1830D4000, v243, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] failed to clone from flow, moving directly to failed state", buf, 0x48u);
                    }
                  }
                  goto LABEL_334;
                }
LABEL_245:
                nw::release_if_needed<nw_protocol *>(&v358);
                goto LABEL_246;
              }
LABEL_221:
              if (nw_endpoint_handler_get_logging_disabled(v355)) {
                goto LABEL_286;
              }
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              id v187 = (id)gconnectionLogObj;
              if (os_log_type_enabled(v187, OS_LOG_TYPE_ERROR))
              {
                __int16 v188 = nw_endpoint_handler_get_id_string(v355);
                os_log_type_t v189 = nw_endpoint_handler_dry_run_string(v355);
                nw_endpoint_t v190 = nw_endpoint_handler_copy_endpoint(v355);
                id v191 = nw_endpoint_get_logging_description(v190);
                __int16 v192 = nw_endpoint_handler_state_string(v355);
                os_log_type_t v193 = nw_endpoint_handler_mode_string(v355);
                id v194 = nw_endpoint_handler_copy_current_path(v355);
                *(_DWORD *)unsigned int buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                __int16 v363 = 2082;
                v364 = (void *)v188;
                __int16 v365 = 2082;
                v366 = v189;
                __int16 v367 = 2082;
                uint64_t v368 = (void *)v191;
                __int16 v369 = 2082;
                v370 = v192;
                __int16 v371 = 2082;
                v372 = v193;
                __int16 v373 = 2114;
                id v374 = v194;
                _os_log_impl(&dword_1830D4000, v187, OS_LOG_TYPE_ERROR, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Failed to remove replay protocol from the stack on cancellation", buf, 0x48u);
              }
              goto LABEL_226;
            }
            uint64_t v335 = *((void *)v6 + 65);
            uint64_t v336 = *((void *)v6 + 63);
            long long v97 = v355;
            BOOL v98 = (*((unsigned char *)v97 + 268) & 0x20) == 0;

            if (!v98)
            {
LABEL_264:
              uint64_t v217 = v335;
              BOOL v216 = (const char *)v336;
              if (v335)
              {
                uint64_t v218 = *(void *)(v335 + 32);
                if (v218)
                {
                  if (*(_UNKNOWN **)(v218 + 40) == &nw_protocol_ref_counted_handle)
                  {
                    uint64_t v257 = *(void *)(v218 + 88);
                    if (v257)
                    {
                      uint64_t v258 = v257 - 1;
                      *(void *)(v218 + 88) = v258;
                      if (!v258)
                      {
                        id v259 = *(void (***)(void))(v218 + 64);
                        if (v259)
                        {
                          *(void *)(v218 + 64) = 0;
                          v259[2](v259);
                          _Block_release(v259);
                        }
                        if (*(unsigned char *)(v218 + 72))
                        {
                          int v260 = *(const void **)(v218 + 64);
                          if (v260) {
                            _Block_release(v260);
                          }
                        }
                        free((void *)v218);
                        uint64_t v217 = v335;
                        BOOL v216 = (const char *)v336;
                      }
                    }
                  }
                  *(void *)(v217 + 32) = 0;
                }
              }
              if (!v216) {
                goto LABEL_286;
              }
              uint64_t v219 = (void *)*((void *)v216 + 5);
              if (v219 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v221 = *((void *)v216 + 11);
                uint64_t v220 = (uint64_t)v6 + 472;
                if (v221) {
                  *((void *)v216 + 11) = v221 + 1;
                }
                *(void *)os_log_type_t type = v216;
                v361 |= 1u;
              }
              else
              {
                *(void *)os_log_type_t type = v216;
                v361 &= ~1u;
                uint64_t v220 = (uint64_t)v6 + 472;
              }
              v222 = (void *)*((void *)v6 + 64);
              if (v222 == &nw_protocol_ref_counted_handle)
              {
                uint64_t v224 = *((void *)v6 + 70);
                if (v224) {
                  *((void *)v6 + 70) = v224 + 1;
                }
                uint64_t v358 = v220;
                char v223 = v359 | 1;
              }
              else
              {
                uint64_t v358 = v220;
                char v223 = v359 & 0xFE;
              }
              char v359 = v223;
              uint64_t v225 = *((void *)v216 + 3);
              if (v225)
              {
                uint64_t v226 = *(void (**)(const char *, uint64_t))(v225 + 8);
                if (v226)
                {
                  v226(v216, v220);
LABEL_282:
                  if (v222 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>(&v358);
                  }
                  if (v219 == &nw_protocol_ref_counted_handle) {
                    nw::release_if_needed<nw_protocol *>((uint64_t *)type);
                  }
                  goto LABEL_286;
                }
              }
              os_log_type_t v299 = v216;
              os_log_type_t v300 = __nwlog_obj();
              v301 = (const char *)*((void *)v299 + 2);
              *(_DWORD *)unsigned int buf = 136446722;
              *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
              if (!v301) {
                v301 = "invalid";
              }
              __int16 v363 = 2082;
              v364 = (void *)v301;
              __int16 v365 = 2048;
              v366 = v299;
              os_log_type_t v302 = (char *)_os_log_send_and_compose_impl();

              os_log_type_t v357 = OS_LOG_TYPE_ERROR;
              char v356 = 0;
              if (__nwlog_fault(v302, &v357, &v356))
              {
                if (v357 == OS_LOG_TYPE_FAULT)
                {
                  uint64_t v303 = __nwlog_obj();
                  os_log_type_t v304 = v357;
                  if (os_log_type_enabled(v303, v357))
                  {
                    v305 = *(const char **)(v336 + 16);
                    if (!v305) {
                      v305 = "invalid";
                    }
                    *(_DWORD *)unsigned int buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                    __int16 v363 = 2082;
                    v364 = (void *)v305;
                    __int16 v365 = 2048;
                    v366 = (const char *)v336;
                    _os_log_impl(&dword_1830D4000, v303, v304, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback", buf, 0x20u);
                  }
                }
                else if (v356)
                {
                  os_log_type_t v306 = (char *)__nw_create_backtrace_string();
                  uint64_t v303 = __nwlog_obj();
                  os_log_type_t v307 = v357;
                  BOOL v308 = os_log_type_enabled(v303, v357);
                  if (v306)
                  {
                    if (v308)
                    {
                      os_log_type_t v309 = *(const char **)(v336 + 16);
                      if (!v309) {
                        os_log_type_t v309 = "invalid";
                      }
                      *(_DWORD *)unsigned int buf = 136446978;
                      *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                      __int16 v363 = 2082;
                      v364 = (void *)v309;
                      __int16 v365 = 2048;
                      v366 = (const char *)v336;
                      __int16 v367 = 2082;
                      uint64_t v368 = v306;
                      _os_log_impl(&dword_1830D4000, v303, v307, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, dumping backtrace:%{public}s", buf, 0x2Au);
                    }

                    free(v306);
                    goto LABEL_445;
                  }
                  if (v308)
                  {
                    nw_endpoint_t v322 = *(const char **)(v336 + 16);
                    if (!v322) {
                      nw_endpoint_t v322 = "invalid";
                    }
                    *(_DWORD *)unsigned int buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                    __int16 v363 = 2082;
                    v364 = (void *)v322;
                    __int16 v365 = 2048;
                    v366 = (const char *)v336;
                    _os_log_impl(&dword_1830D4000, v303, v307, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, no backtrace", buf, 0x20u);
                  }
                }
                else
                {
                  uint64_t v303 = __nwlog_obj();
                  os_log_type_t v320 = v357;
                  if (os_log_type_enabled(v303, v357))
                  {
                    os_log_type_t v321 = *(const char **)(v336 + 16);
                    if (!v321) {
                      os_log_type_t v321 = "invalid";
                    }
                    *(_DWORD *)unsigned int buf = 136446722;
                    *(void *)&uint8_t buf[4] = "__nw_protocol_remove_input_handler";
                    __int16 v363 = 2082;
                    v364 = (void *)v321;
                    __int16 v365 = 2048;
                    v366 = (const char *)v336;
                    _os_log_impl(&dword_1830D4000, v303, v320, "%{public}s protocol %{public}s (%p) has invalid remove_input_handler callback, backtrace limit exceeded", buf, 0x20u);
                  }
                }
              }
LABEL_445:
              if (v302) {
                free(v302);
              }
              goto LABEL_282;
            }
            if (__nwlog_connection_log::onceToken != -1) {
              dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
            }
            id loga = (id)gconnectionLogObj;
            long long v99 = v97;

            long long v100 = v99;
            BOOL v101 = (*((unsigned char *)v97 + 268) & 1) == 0;

            if (v101) {
              long long v102 = "";
            }
            else {
              long long v102 = "dry-run ";
            }
            nw_endpoint_t v103 = nw_endpoint_handler_copy_endpoint(v100);
            long long v104 = nw_endpoint_get_logging_description(v103);
            long long v105 = v100;
            long long v106 = v105;
            uint64_t v107 = v105[30];
            nw_endpoint_t v332 = v103;
            v338 = v104;
            if (v107 > 5) {
              long long v108 = "unknown-state";
            }
            else {
              long long v108 = off_1E523FB38[v107];
            }
            os_log_type_t v333 = v108;

            long long v109 = v106;
            uint64_t v110 = v109;
            uint64_t v111 = "path";
            switch(v109[29])
            {
              case 0u:
                break;
              case 1u:
                uint64_t v111 = "resolver";
                break;
              case 2u:
                uint64_t v111 = nw_endpoint_flow_mode_string(*((void **)v109 + 31));
                break;
              case 3u:
                uint64_t v111 = "proxy";
                break;
              case 4u:
                uint64_t v111 = "fallback";
                break;
              case 5u:
                uint64_t v111 = "transform";
                break;
              default:
                uint64_t v111 = "unknown-mode";
                break;
            }

            BOOL v117 = v110;
            os_unfair_lock_lock((os_unfair_lock_t)v117 + 28);
            id v118 = *((id *)v117 + 8);
            uint64_t v330 = (os_unfair_lock_s *)(v117 + 112);
            os_log_type_t v119 = v102;
            uint64_t v120 = v110;
            os_unfair_lock_unlock((os_unfair_lock_t)v117 + 28);
            v331 = (id *)v117;

            int v121 = v99 + 168;
            id v122 = v118;
            *(_DWORD *)unsigned int buf = 136447746;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
            __int16 v363 = 2082;
            uint64_t v123 = v121;
            v364 = v121;
            __int16 v365 = 2082;
            v366 = v119;
            __int16 v367 = 2082;
            uint64_t v368 = (void *)v338;
            __int16 v369 = 2082;
            v370 = v333;
            __int16 v371 = 2082;
            v372 = v111;
            __int16 v373 = 2114;
            id v374 = v122;
            nw_endpoint_t v339 = (const char *)_os_log_send_and_compose_impl();

            type[0] = OS_LOG_TYPE_ERROR;
            LOBYTE(v358) = 0;
            int v124 = (char *)v339;
            if (!__nwlog_fault(v339, type, &v358))
            {
LABEL_262:
              if (v124) {
                free(v124);
              }
              goto LABEL_264;
            }
            if (type[0] == OS_LOG_TYPE_FAULT)
            {
              if (__nwlog_connection_log::onceToken != -1) {
                dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
              }
              unsigned int v125 = (id)gconnectionLogObj;
              os_log_type_t v126 = type[0];
              if (os_log_type_enabled(v125, type[0]))
              {
                os_log_t logb = v125;
                int v127 = v331;

                os_log_type_t v128 = v127;
                LODWORD(v127) = (*((unsigned char *)v97 + 268) & 1) == 0;

                if (v127) {
                  __int16 v129 = "";
                }
                else {
                  __int16 v129 = "dry-run ";
                }
                nw_endpoint_t v130 = nw_endpoint_handler_copy_endpoint(v128);
                BOOL v131 = nw_endpoint_get_logging_description(v130);
                int v132 = v128;
                char v133 = v132;
                uint64_t v134 = v106[30];
                if (v134 > 5) {
                  int v135 = "unknown-state";
                }
                else {
                  int v135 = off_1E523FB38[v134];
                }
                v334 = v135;

                os_log_type_t v156 = v133;
                os_log_type_t v157 = v156;
                os_log_type_t v158 = "path";
                switch(v120[29])
                {
                  case 0u:
                    break;
                  case 1u:
                    os_log_type_t v158 = "resolver";
                    break;
                  case 2u:
                    os_log_type_t v158 = nw_endpoint_flow_mode_string(v156[31]);
                    break;
                  case 3u:
                    os_log_type_t v158 = "proxy";
                    break;
                  case 4u:
                    os_log_type_t v158 = "fallback";
                    break;
                  case 5u:
                    os_log_type_t v158 = "transform";
                    break;
                  default:
                    os_log_type_t v158 = "unknown-mode";
                    break;
                }

                BOOL v213 = v157;
                os_unfair_lock_lock(v330);
                id v214 = v331[8];
                os_unfair_lock_unlock(v330);

                id v215 = v214;
                *(_DWORD *)unsigned int buf = 136447746;
                *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                __int16 v363 = 2082;
                v364 = v123;
                __int16 v365 = 2082;
                v366 = v129;
                __int16 v367 = 2082;
                uint64_t v368 = (void *)v131;
                __int16 v369 = 2082;
                v370 = v334;
                __int16 v371 = 2082;
                v372 = v158;
                __int16 v373 = 2114;
                id v374 = v215;
                _os_log_impl(&dword_1830D4000, logb, v126, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Replay protocol not fully connected; calling remove_input_handler without re-attaching",
                  buf,
                  0x48u);

                unsigned int v125 = logb;
              }
            }
            else
            {
              if ((_BYTE)v358)
              {
                char v136 = __nw_create_backtrace_string();
                if (v136)
                {
                  uint64_t v137 = (char *)v136;
                  if (__nwlog_connection_log::onceToken != -1) {
                    dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                  }
                  os_log_type_t v138 = (id)gconnectionLogObj;
                  os_log_type_t v139 = type[0];
                  if (os_log_type_enabled(v138, type[0]))
                  {
                    uint64_t v140 = nw_endpoint_handler_get_id_string(v331);
                    uint64_t v141 = nw_endpoint_handler_dry_run_string(v331);
                    os_log_type_t logd = v138;
                    nw_endpoint_t v142 = nw_endpoint_handler_copy_endpoint(v331);
                    os_log_type_t v143 = nw_endpoint_get_logging_description(v142);
                    uint64_t v144 = nw_endpoint_handler_state_string(v331);
                    uint64_t v145 = nw_endpoint_handler_mode_string(v331);
                    id v146 = nw_endpoint_handler_copy_current_path(v331);
                    *(_DWORD *)unsigned int buf = 136448002;
                    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                    __int16 v363 = 2082;
                    v364 = (void *)v140;
                    __int16 v365 = 2082;
                    v366 = v141;
                    __int16 v367 = 2082;
                    uint64_t v368 = (void *)v143;
                    __int16 v369 = 2082;
                    v370 = v144;
                    __int16 v371 = 2082;
                    v372 = v145;
                    __int16 v373 = 2114;
                    id v374 = v146;
                    __int16 v375 = 2082;
                    v376 = v137;
                    _os_log_impl(&dword_1830D4000, logd, v139, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Replay protocol not fully connected; calling remove_input_handler without re-attaching, dumping backtrace:%{public}s",
                      buf,
                      0x52u);

                    os_log_type_t v138 = logd;
                  }

                  free(v137);
                  goto LABEL_261;
                }
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                BOOL v147 = (id)gconnectionLogObj;
                os_log_type_t v159 = type[0];
                if (os_log_type_enabled(v147, type[0]))
                {
                  os_log_type_t v160 = nw_endpoint_handler_get_id_string(v331);
                  id v161 = nw_endpoint_handler_dry_run_string(v331);
                  logf = v147;
                  nw_endpoint_t v162 = nw_endpoint_handler_copy_endpoint(v331);
                  id v163 = nw_endpoint_get_logging_description(v162);
                  char v164 = nw_endpoint_handler_state_string(v331);
                  os_log_type_t v165 = nw_endpoint_handler_mode_string(v331);
                  id v166 = nw_endpoint_handler_copy_current_path(v331);
                  *(_DWORD *)unsigned int buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                  __int16 v363 = 2082;
                  v364 = (void *)v160;
                  __int16 v365 = 2082;
                  v366 = v161;
                  __int16 v367 = 2082;
                  uint64_t v368 = (void *)v163;
                  __int16 v369 = 2082;
                  v370 = v164;
                  __int16 v371 = 2082;
                  v372 = v165;
                  __int16 v373 = 2114;
                  id v374 = v166;
                  _os_log_impl(&dword_1830D4000, logf, v159, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Replay protocol not fully connected; calling remove_input_handler without re-attaching, no backtrace",
                    buf,
                    0x48u);

                  BOOL v147 = logf;
                }
              }
              else
              {
                if (__nwlog_connection_log::onceToken != -1) {
                  dispatch_once(&__nwlog_connection_log::onceToken, &__block_literal_global_28);
                }
                BOOL v147 = (id)gconnectionLogObj;
                os_log_type_t v148 = type[0];
                if (os_log_type_enabled(v147, type[0]))
                {
                  os_log_type_t v149 = nw_endpoint_handler_get_id_string(v331);
                  __int16 v150 = nw_endpoint_handler_dry_run_string(v331);
                  loge = v147;
                  nw_endpoint_t v151 = nw_endpoint_handler_copy_endpoint(v331);
                  __int16 v152 = nw_endpoint_get_logging_description(v151);
                  os_log_type_t v153 = nw_endpoint_handler_state_string(v331);
                  uint64_t v154 = nw_endpoint_handler_mode_string(v331);
                  id v155 = nw_endpoint_handler_copy_current_path(v331);
                  *(_DWORD *)unsigned int buf = 136447746;
                  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
                  __int16 v363 = 2082;
                  v364 = (void *)v149;
                  __int16 v365 = 2082;
                  v366 = v150;
                  __int16 v367 = 2082;
                  uint64_t v368 = (void *)v152;
                  __int16 v369 = 2082;
                  v370 = v153;
                  __int16 v371 = 2082;
                  v372 = v154;
                  __int16 v373 = 2114;
                  id v374 = v155;
                  _os_log_impl(&dword_1830D4000, loge, v148, "%{public}s [C%{public}s %{public}s%{public}s %{public}s %{public}s (%{public}@)] Replay protocol not fully connected; calling remove_input_handler without re-attaching, backtrace limit exceeded",
                    buf,
                    0x48u);

                  BOOL v147 = loge;
                }
              }
            }
LABEL_261:
            int v124 = (char *)v339;
            goto LABEL_262;
          }
LABEL_36:
          if (!v7) {
            goto LABEL_68;
          }
          uint64_t v34 = *((void *)v7 + 3);
          if (!v34) {
            goto LABEL_68;
          }
          int v35 = *(uint64_t (**)(const char *, uint64_t, uint64_t *))(v34 + 224);
          if (!v35) {
            goto LABEL_68;
          }
          uint64_t v358 = 0;
          uint64_t v36 = (void *)*((void *)v7 + 5);
          if (v36 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v38 = *((void *)v7 + 11);
            if (v38) {
              *((void *)v7 + 11) = v38 + 1;
            }
            char v37 = -1;
          }
          else
          {
            char v37 = 0;
          }
          *(void *)unsigned int buf = v7;
          uint8_t buf[8] = v37;
          uint64_t v39 = (void *)v35(v7, 1, &v358);
          if (v36 == &nw_protocol_ref_counted_handle) {
            nw::release_if_needed<nw_protocol *>((uint64_t *)buf);
          }
          if (v39)
          {
            if (v358 == 408)
            {
              char v40 = (void *)*((void *)v6 + 99);
              if (v40)
              {
                free(v40);
                *((void *)v6 + 99) = 0;
              }
              *((void *)v6 + 99) = v39;
            }
            else
            {
              free(v39);
            }
          }
          uint64_t v358 = 0;
          os_log_type_t v41 = (void *)*((void *)v7 + 5);
          if (v41 == &nw_protocol_ref_counted_handle)
          {
            uint64_t v43 = *((void *)v7 + 11);
            if (v43) {
              *((void *)v7 + 11) = v43 + 1;
            }
            char v42 = -1;
          }
          else
          {
            char v42 = 0;
          }
          *(void *)os_log_type_t type = v7;
          char v361 = v42;
          uint64_t v44 = *((void *)v7 + 3);
          if (v44)
          {
            uint64_t v45 = *(uint64_t (**)(const char *, uint64_t, uint64_t *))(v44 + 224);
            if (v45)
            {
              int8x16_t v46 = (void *)v45(v7, 2, &v358);
              if (v41 != &nw_protocol_ref_counted_handle) {
                goto LABEL_63;
              }
              goto LABEL_62;
            }
          }
          v280 = __nwlog_obj();
          nw_endpoint_t v281 = (const char *)*((void *)v7 + 2);
          *(_DWORD *)unsigned int buf = 136446722;
          *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
          if (!v281) {
            nw_endpoint_t v281 = "invalid";
          }
          __int16 v363 = 2082;
          v364 = (void *)v281;
          __int16 v365 = 2048;
          v366 = v7;
          v282 = (char *)_os_log_send_and_compose_impl();

          os_log_type_t v357 = OS_LOG_TYPE_ERROR;
          char v356 = 0;
          if (__nwlog_fault(v282, &v357, &v356))
          {
            if (v357 == OS_LOG_TYPE_FAULT)
            {
              v283 = __nwlog_obj();
              os_log_type_t v284 = v357;
              if (os_log_type_enabled(v283, v357))
              {
                id v285 = (const char *)*((void *)v7 + 2);
                if (!v285) {
                  id v285 = "invalid";
                }
                *(_DWORD *)unsigned int buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                __int16 v363 = 2082;
                v364 = (void *)v285;
                __int16 v365 = 2048;
                v366 = v7;
                _os_log_impl(&dword_1830D4000, v283, v284, "%{public}s protocol %{public}s (%p) has invalid copy_info callback", buf, 0x20u);
              }
LABEL_421:

              goto LABEL_422;
            }
            if (!v356)
            {
              v283 = __nwlog_obj();
              os_log_type_t v310 = v357;
              if (os_log_type_enabled(v283, v357))
              {
                BOOL v311 = (const char *)*((void *)v7 + 2);
                if (!v311) {
                  BOOL v311 = "invalid";
                }
                *(_DWORD *)unsigned int buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                __int16 v363 = 2082;
                v364 = (void *)v311;
                __int16 v365 = 2048;
                v366 = v7;
                _os_log_impl(&dword_1830D4000, v283, v310, "%{public}s protocol %{public}s (%p) has invalid copy_info callback, backtrace limit exceeded", buf, 0x20u);
              }
              goto LABEL_421;
            }
            uint64_t v293 = (char *)__nw_create_backtrace_string();
            v283 = __nwlog_obj();
            os_log_type_t v294 = v357;
            BOOL v295 = os_log_type_enabled(v283, v357);
            if (!v293)
            {
              if (v295)
              {
                nw_parameters_t v312 = (const char *)*((void *)v7 + 2);
                if (!v312) {
                  nw_parameters_t v312 = "invalid";
                }
                *(_DWORD *)unsigned int buf = 136446722;
                *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
                __int16 v363 = 2082;
                v364 = (void *)v312;
                __int16 v365 = 2048;
                v366 = v7;
                _os_log_impl(&dword_1830D4000, v283, v294, "%{public}s protocol %{public}s (%p) has invalid copy_info callback, no backtrace", buf, 0x20u);
              }
              goto LABEL_421;
            }
            if (v295)
            {
              v296 = (const char *)*((void *)v7 + 2);
              if (!v296) {
                v296 = "invalid";
              }
              *(_DWORD *)unsigned int buf = 136446978;
              *(void *)&uint8_t buf[4] = "__nw_protocol_copy_info";
              __int16 v363 = 2082;
              v364 = (void *)v296;
              __int16 v365 = 2048;
              v366 = v7;
              __int16 v367 = 2082;
              uint64_t v368 = v293;
              _os_log_impl(&dword_1830D4000, v283, v294, "%{public}s protocol %{public}s (%p) has invalid copy_info callback, dumping backtrace:%{public}s", buf, 0x2Au);
            }

            free(v293);
          }
LABEL_422:
          if (v282) {
            free(v282);
          }
          int8x16_t v46 = 0;
          if (v41 != &nw_protocol_ref_counted_handle)
          {
LABEL_63:
            if (v46)
            {
              if (v358 != 112)
              {
                free(v46);
                char v48 = *((unsigned char *)v6 + 728);
                if ((v48 & 1) == 0) {
                  goto LABEL_70;
                }
                goto LABEL_69;
              }
              uint64_t v47 = (void *)*((void *)v6 + 100);
              if (v47)
              {
                free(v47);
                *((void *)v6 + 100) = 0;
              }
              *((void *)v6 + 100) = v46;
            }
LABEL_68:
            char v48 = *((unsigned char *)v6 + 728);
            if ((v48 & 1) == 0)
            {
LABEL_70:
              *((void *)v6 + 90) = 0;
              *((unsigned char *)v6 + 728) = v48 | 1;
              goto LABEL_71;
            }
LABEL_69:
            nw::release_if_needed<nw_protocol *>((uint64_t *)v6 + 90);
            char v48 = *((unsigned char *)v6 + 728);
            goto LABEL_70;
          }
LABEL_62:
          nw::release_if_needed<nw_protocol *>((uint64_t *)type);
          goto LABEL_63;
        }
        os_log_t v348 = (void *)v33;
        objc_storeStrong((id *)v6 + 2, (id)v33);
      }
      else
      {
        lock = (os_unfair_lock_s *)((char *)v6 + 880);
        os_unfair_lock_lock((os_unfair_lock_t)v6 + 220);
        os_log_t v348 = 0;
      }
      if (!*((void *)v6 + 90)) {
        goto LABEL_71;
      }
      goto LABEL_36;
    }
    v270 = __nwlog_obj();
    *(_DWORD *)unsigned int buf = 136446210;
    *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
    v271 = (char *)_os_log_send_and_compose_impl();

    type[0] = OS_LOG_TYPE_ERROR;
    LOBYTE(v358) = 0;
    if (__nwlog_fault(v271, type, &v358))
    {
      if (type[0] == OS_LOG_TYPE_FAULT)
      {
        id v272 = __nwlog_obj();
        os_log_type_t v273 = type[0];
        if (os_log_type_enabled(v272, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          _os_log_impl(&dword_1830D4000, v272, v273, "%{public}s called with null endpoint_flow", buf, 0xCu);
        }
      }
      else if ((_BYTE)v358)
      {
        v277 = (char *)__nw_create_backtrace_string();
        id v272 = __nwlog_obj();
        os_log_type_t v278 = type[0];
        BOOL v279 = os_log_type_enabled(v272, type[0]);
        if (v277)
        {
          if (v279)
          {
            *(_DWORD *)unsigned int buf = 136446466;
            *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
            __int16 v363 = 2082;
            v364 = v277;
            _os_log_impl(&dword_1830D4000, v272, v278, "%{public}s called with null endpoint_flow, dumping backtrace:%{public}s", buf, 0x16u);
          }

          free(v277);
          goto LABEL_403;
        }
        if (v279)
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          _os_log_impl(&dword_1830D4000, v272, v278, "%{public}s called with null endpoint_flow, no backtrace", buf, 0xCu);
        }
      }
      else
      {
        id v272 = __nwlog_obj();
        os_log_type_t v298 = type[0];
        if (os_log_type_enabled(v272, type[0]))
        {
          *(_DWORD *)unsigned int buf = 136446210;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          _os_log_impl(&dword_1830D4000, v272, v298, "%{public}s called with null endpoint_flow, backtrace limit exceeded", buf, 0xCu);
        }
      }
    }
LABEL_403:
    if (v271) {
      free(v271);
    }
    goto LABEL_337;
  }
  unsigned int v266 = __nwlog_obj();
  *(_DWORD *)unsigned int buf = 136446210;
  *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
  uint64_t v267 = (char *)_os_log_send_and_compose_impl();

  type[0] = OS_LOG_TYPE_ERROR;
  LOBYTE(v358) = 0;
  if (__nwlog_fault(v267, type, &v358))
  {
    if (type[0] == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v268 = __nwlog_obj();
      os_log_type_t v269 = type[0];
      if (os_log_type_enabled(v268, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
        _os_log_impl(&dword_1830D4000, v268, v269, "%{public}s called with null handler", buf, 0xCu);
      }
    }
    else if ((_BYTE)v358)
    {
      int v274 = (char *)__nw_create_backtrace_string();
      nw_endpoint_t v268 = __nwlog_obj();
      os_log_type_t v275 = type[0];
      BOOL v276 = os_log_type_enabled(v268, type[0]);
      if (v274)
      {
        if (v276)
        {
          *(_DWORD *)unsigned int buf = 136446466;
          *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
          __int16 v363 = 2082;
          v364 = v274;
          _os_log_impl(&dword_1830D4000, v268, v275, "%{public}s called with null handler, dumping backtrace:%{public}s", buf, 0x16u);
        }

        free(v274);
        goto LABEL_398;
      }
      if (v276)
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
        _os_log_impl(&dword_1830D4000, v268, v275, "%{public}s called with null handler, no backtrace", buf, 0xCu);
      }
    }
    else
    {
      nw_endpoint_t v268 = __nwlog_obj();
      os_log_type_t v297 = type[0];
      if (os_log_type_enabled(v268, type[0]))
      {
        *(_DWORD *)unsigned int buf = 136446210;
        *(void *)&uint8_t buf[4] = "nw_endpoint_flow_failed_with_error";
        _os_log_impl(&dword_1830D4000, v268, v297, "%{public}s called with null handler, backtrace limit exceeded", buf, 0xCu);
      }
    }
  }
LABEL_398:
  if (v267) {
    free(v267);
  }
LABEL_338:
}

void sub_1831EC3C8(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9, uint64_t a10, uint64_t a11, uint64_t a12, uint64_t a13, uint64_t a14, uint64_t a15, uint64_t a16, uint64_t a17, uint64_t a18, uint64_t a19, uint64_t a20,uint64_t a21,uint64_t a22,uint64_t a23,uint64_t a24,void *a25,uint64_t a26,uint64_t a27,uint64_t a28,uint64_t a29,void *a30,void *a31)
{
  _Unwind_Resume(a1);
}

void nw::release_if_needed<nw_protocol *>(uint64_t *a1)
{
  uint64_t v1 = *a1;
  if (*a1)
  {
    if (*(_UNKNOWN **)(v1 + 40) == &nw_protocol_ref_counted_handle)
    {
      uint64_t v3 = *(void *)(v1 + 88);
      if (v3)
      {
        uint64_t v4 = v3 - 1;
        *(void *)(v1 + 88) = v4;
        if (!v4)
        {
          id v5 = *(const void **)(v1 + 64);
          if (v5)
          {
            id v6 = _Block_copy(v5);
            os_log_type_t v7 = *(void **)(v1 + 64);
            *(void *)(v1 + 64) = 0;

            uint64_t v8 = _Block_copy(v6);
            os_log_type_t v10 = (void (**)(void))_Block_copy(v8);

            v10[2](v10);
            BOOL v9 = *(void **)(v1 + 64);
            if (*(unsigned char *)(v1 + 72))
            {
              if (v9)
              {
                *(void *)(v1 + 64) = 0;

                BOOL v9 = *(void **)(v1 + 64);
              }
            }
          }
          else
          {
            BOOL v9 = 0;
          }
          *(void *)(v1 + 64) = 0;

          free((void *)v1);
        }
      }
    }
    *a1 = 0;
  }
}

void sub_1831EC71C(_Unwind_Exception *a1, uint64_t a2, uint64_t a3, uint64_t a4, uint64_t a5, uint64_t a6, uint64_t a7, uint64_t a8, uint64_t a9)
{
}

void _nw_hash_table_release(os_unfair_lock_s *a1)
{
  nw_hash_table_release_all_objects((uint64_t)a1);
  if (a1[8]._os_unfair_lock_opaque)
  {
    uint32_t os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 2) == 0) {
      goto LABEL_3;
    }
  }
  else
  {
    uint64_t v3 = __nwlog_obj();
    os_log_type_enabled(v3, OS_LOG_TYPE_ERROR);
    uint64_t v4 = (void *)_os_log_send_and_compose_impl();
    if (__nwlog_abort((uint64_t)v4))
    {
      __break(1u);
      return;
    }
    free(v4);
    uint32_t os_unfair_lock_opaque = a1[12]._os_unfair_lock_opaque;
    if ((os_unfair_lock_opaque & 2) == 0)
    {
LABEL_3:
      a1[12]._uint32_t os_unfair_lock_opaque = os_unfair_lock_opaque & 0xFFFFFFFE;
      if (a1[11]._os_unfair_lock_opaque) {
        return;
      }
      goto LABEL_10;
    }
  }
  os_unfair_lock_lock(a1 + 13);
  uint32_t v6 = a1[11]._os_unfair_lock_opaque;
  uint32_t v5 = a1[12]._os_unfair_lock_opaque;
  a1[12]._uint32_t os_unfair_lock_opaque = v5 & 0xFFFFFFFE;
  if ((v5 & 2) != 0) {
    os_unfair_lock_unlock(a1 + 13);
  }
  if (!v6) {
LABEL_10:
  }
    free(a1);
}

void nw_hash_table_release_all_objects(uint64_t a1)
{
  uint64_t v51 = *MEMORY[0x1E4F143B8];
  if (a1)
  {
    uint64_t v2 = a1;
    if (*(_DWORD *)(a1 + 32))
    {
      int v3 = *(_DWORD *)(a1 + 48);
      if ((v3 & 2) == 0) {
        goto LABEL_5;
      }
      goto LABEL_4;
    }
    int v22 = __nwlog_obj();
    os_log_type_enabled(v22, OS_LOG_TYPE_ERROR);
    *(_DWORD *)unsigned int buf = 136446210;
    char v48 = "nw_hash_table_lock";
    os_log_type_t v23 = (void *)_os_log_send_and_compose_impl();
    if (!__nwlog_abort((uint64_t)v23))
    {
      free(v23);
      int v3 = *(_DWORD *)(v2 + 48);
      if ((v3 & 2) == 0)
      {
LABEL_5:
        if (v3)
        {
          unsigned int v4 = *(_DWORD *)(v2 + 32);
          if (v4)
          {
            unsigned int v5 = 0;
            uint32_t v6 = (void *)(v2 + 56);
            int v44 = 136446210;
            uint64_t v1 = "%{public}s Tried to remove all hash nodes and one was not in list";
            do
            {
              os_log_type_t v7 = (void *)*v6;
              if (*v6)
              {
                unsigned int v43 = v5;
                do
                {
                  os_log_type_t v10 = v7;
                  os_log_type_t v7 = (void *)*v7;
                  int v11 = *((unsigned __int8 *)v10 + 30);
                  if (v11 == 1)
                  {
                    *((unsigned char *)v10 + 30) = 2;
                    os_log_type_t v12 = *(void (**)(void))(v2 + 24);
                    if (v12)
                    {
                      v12(v10[2]);
                      v10[2] = 0;
                    }
                    --*(_DWORD *)(v2 + 40);
                    char v13 = (void *)v10[1];
                    if (!v13 || (void *)*v13 != v10)
                    {
                      uint64_t v14 = pthread_once(&nwlog_legacy_init(void)::init_once, nwlog_legacy_init_once);
                      networkd_settings_init(v14);
                      os_log_type_enabled((os_log_t)gLogObj, OS_LOG_TYPE_ERROR);
                      *(_DWORD *)unsigned int buf = 136446210;
                      char v48 = "nw_hash_table_remove_node_internal";
                      __int16 v15 = (void *)_os_log_send_and_compose_impl();
                      if (__nwlog_abort((uint64_t)v15)) {
                        goto LABEL_47;
                      }
                      free(v15);
                    }
                    if (!*((_WORD *)v10 + 14)) {
                      nw_hash_node_free((uint64_t)v6, v10);
                    }
                  }
                  else if (v11 != 2 || !*((_WORD *)v10 + 14))
                  {
                    uint64_t v16 = __nwlog_obj();
                    os_log_type_enabled(v16, OS_LOG_TYPE_ERROR);
                    unint64_t v17 = *((unsigned __int8 *)v10 + 30);
                    uint64_t v18 = "invalid_state";
                    if (v17 <= 3) {
                      uint64_t v18 = off_1E5247AE8[v17];
                    }
                    int v8 = *((unsigned __int16 *)v10 + 14);
                    *(_DWORD *)unsigned int buf = 136446722;
                    char v48 = "nw_hash_table_release_all_objects";
                    __int16 v49 = 2082;
                    *(void *)id v50 = v18;
                    *(_WORD *)&v50[8] = 1024;
                    *(_DWORD *)&v50[10] = v8;
                    BOOL v9 = (void *)_os_log_send_and_compose_impl();
                    if (__nwlog_abort((uint64_t)v9)) {
                      goto LABEL_47;
                    }
                    free(v9);
                  }
                }
                while (v7);
                unsigned int v4 = *(_DWORD *)(v2 + 32);
                unsigned int v5 = v43;
              }
              ++v5;
              v6 += 2;
            }
            while (v5 < v4);
          }
          if (!*(_DWORD *)(v2 + 40)) {
            goto LABEL_29;
          }
          __nwlog_obj();
          int v28 = *(_DWORD *)(v2 + 40);
          *(_DWORD *)unsigned int buf = 136446466;
          char v48 = "nw_hash_table_release_all_objects";
          __int16 v49 = 1024;
          *(_DWORD *)id v50 = v28;
          uint64_t v29 = (char *)_os_log_send_and_compose_impl();
          os_log_type_t type = OS_LOG_TYPE_ERROR;
          char v45 = 0;
          if (!__nwlog_fault(v29, &type, &v45)) {
            goto LABEL_82;
          }
          if (type == OS_LOG_TYPE_FAULT)
          {
            uint64_t v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            if (os_log_type_enabled(v30, type))
            {
              int v32 = *(_DWORD *)(v2 + 40);
              *(_DWORD *)unsigned int buf = 136446466;
              char v48 = "nw_hash_table_release_all_objects";
              __int16 v49 = 1024;
              *(_DWORD *)id v50 = v32;
              BOOL v33 = "%{public}s table count %d != 0";
LABEL_81:
              _os_log_impl(&dword_1830D4000, v30, v31, v33, buf, 0x12u);
            }
          }
          else if (v45)
          {
            backtrace_string = (char *)__nw_create_backtrace_string();
            uint64_t v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            BOOL v39 = os_log_type_enabled(v30, type);
            if (backtrace_string)
            {
              if (v39)
              {
                int v40 = *(_DWORD *)(v2 + 40);
                *(_DWORD *)unsigned int buf = 136446722;
                char v48 = "nw_hash_table_release_all_objects";
                __int16 v49 = 1024;
                *(_DWORD *)id v50 = v40;
                *(_WORD *)&void v50[4] = 2082;
                *(void *)&v50[6] = backtrace_string;
                _os_log_impl(&dword_1830D4000, v30, v31, "%{public}s table count %d != 0, dumping backtrace:%{public}s", buf, 0x1Cu);
              }
              free(backtrace_string);
              goto LABEL_82;
            }
            if (v39)
            {
              int v42 = *(_DWORD *)(v2 + 40);
              *(_DWORD *)unsigned int buf = 136446466;
              char v48 = "nw_hash_table_release_all_objects";
              __int16 v49 = 1024;
              *(_DWORD *)id v50 = v42;
              BOOL v33 = "%{public}s table count %d != 0, no backtrace";
              goto LABEL_81;
            }
          }
          else
          {
            uint64_t v30 = __nwlog_obj();
            os_log_type_t v31 = type;
            if (os_log_type_enabled(v30, type))
            {
              int v41 = *(_DWORD *)(v2 + 40);
              *(_DWORD *)unsigned int buf = 136446466;
              char v48 = "nw_hash_table_release_all_objects";
              __int16 v49 = 1024;
              *(_DWORD *)id v50 = v41;
              BOOL v33 = "%{public}s table count %d != 0, backtrace limit exceeded";
              goto LABEL_81;
            }
          }
LABEL_82:
          if (v29) {
            free(v29);
          }
          *(_DWORD *)(v2 + 40) = 0;
LABEL_29:
          if ((*(unsigned char *)(v2 + 48) & 2) != 0) {
            os_unfair_lock_unlock((os_unfair_lock_t)(v2 + 52));
          }
          return;
        }
        __nwlog_obj();
        *(_DWORD *)unsigned int buf = 136446210;
        char v48 = "nw_hash_table_release_all_objects";
        uint64_t v24 = (char *)_os_log_send_and_compose_impl();
        os_log_type_t type = OS_LOG_TYPE_ERROR;
        char v45 = 0;
        if (__nwlog_fault(v24, &type, &v45))
        {
          if (type == OS_LOG_TYPE_FAULT)
          {
            os_log_type_t v25 = __nwlog_obj();
            os_log_type_t v26 = type;
            if (!os_log_type_enabled(v25, type)) {
              goto LABEL_77;
            }
            *(_DWORD *)unsigned int buf = 136446210;
            char v48 = "nw_hash_table_release_all_objects";
            os_log_type_t v27 = "%{public}s called with invalid hash table";
            goto LABEL_76;
          }
          if (!v45)
          {
            os_log_type_t v25 = __nwlog_obj();
            os_log_type_t v26 = type;
            if (!os_log_type_enabled(v25, type)) {
              goto LABEL_77;
            }
            *(_DWORD *)unsigned int buf = 136446210;
            char v48 = "nw_hash_table_release_all_objects";
            os_log_type_t v27 = "%{public}s called with invalid hash table, backtrace limit exceeded";
            goto LABEL_76;
          }
          uint64_t v36 = (char *)__nw_create_backtrace_string();
          os_log_type_t v25 = __nwlog_obj();
          os_log_type_t v26 = type;
          BOOL v37 = os_log_type_enabled(v25, type);
          if (v36)
          {
            if (v37)
            {
              *(_DWORD *)unsigned int buf = 136446466;
              char v48 = "nw_hash_table_release_all_objects";
              __int16 v49 = 2082;
              *(void *)id v50 = v36;
              _os_log_impl(&dword_1830D4000, v25, v26, "%{public}s called with invalid hash table, dumping backtrace:%{public}s", buf, 0x16u);
            }
            free(v36);
            goto LABEL_77;
          }
          if (v37)
          {
            *(_DWORD *)unsigned int buf = 136446210;
            char v48 = "nw_hash_table_release_all_objects";
            os_log_type_t v27 = "%{public}s called with invalid hash table, no backtrace";
LABEL_76:
            _os_log_impl(&dword_1830D4000, v25, v26, v27, buf, 0xCu);
          }
        }
LABEL_77:
        if (v24) {
          free(v24);
        }
        goto LABEL_29;
      }
LABEL_4:
      os_unfair_lock_lock((os_unfair_lock_t)(v2 + 52));
      int v3 = *(_DWORD *)(v2 + 48);
      goto LABEL_5;
    }
LABEL_47:
    __break(1u);
  }
  else
  {
    __nwlog_obj();
    int v44 = 136446210;
    *(_DWORD *)unsigned int buf = 136446210;
    uint64_t v1 = "nw_hash_table_release_all_objects";
    char v48 = "nw_hash_table_release_all_objects";
    uint64_t v2 = _os_log_send_and_compose_impl();
    os_log_type_t type = OS_LOG_TYPE_ERROR;
    char v45 = 0;
    if (!__nwlog_fault((const char *)v2, &type, &v45)) {
      goto LABEL_72;
    }
    if (type == OS_LOG_TYPE_FAULT)
    {
      nw_endpoint_t v19 = __nwlog_obj();
      os_log_type_t v20 = type;
      if (!os_log_type_enabled(v19, type)) {
        goto LABEL_72;
      }
      *(_DWORD *)unsigned int buf = 136446210;
      char v48 = "nw_hash_table_release_all_objects";
      id v21 = "%{public}s called with null table";
      goto LABEL_71;
    }
  }
  if (!v45)
  {
    nw_endpoint_t v19 = __nwlog_obj();
    os_log_type_t v20 = type;
    if (!os_log_type_enabled(v19, type)) {
      goto LABEL_72;
    }
    *(_DWORD *)unsigned int buf = v44;
    char v48 = v1;
    id v21 = "%{public}s called with null table, backtrace limit exceeded";
    goto LABEL_71;
  }
  uint64_t v34 = (char *)__nw_create_backtrace_string();
  nw_endpoint_t v19 = __nwlog_obj();
  os_log_type_t v20 = type;
  BOOL v35 = os_log_type_enabled(v19, type);
  if (v34)
  {
    if (v35)
    {
      *(_DWORD *)unsigned int buf = 136446466;
      char v48 = v1;
      __int16 v49 = 2082;
      *(void *)id v50 = v34;
      _os_log_impl(&dword_1830D4000, v19, v20, "%{public}s called with null table, dumping backtrace:%{public}s", buf, 0x16u);
    }
    free(v34);
    goto LABEL_72;
  }
  if (v35)
  {
    *(_DWORD *)unsigned int buf = v44;
    char v48 = v1;
    id v21 = "%{public}s called with null table, no backtrace";
LABEL_71:
    _os_log_impl(&dword_1830D4000, v19, v20, v21, buf, 0xCu);
  }
LABEL_72:
  if (v2) {
    free((void *)v2);
  }
}